{"sha": "41316f0449025394fdca6606d3fdb3b8f37a9872", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMzE2ZjA0NDkwMjUzOTRmZGNhNjYwNmQzZmRiM2I4ZjM3YTk4NzI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-31T00:36:11Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-28T15:29:07Z"}, "message": "Combine all builtin late lints", "tree": {"sha": "1b9de13b723bc67e74317478b70c183933eb0fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b9de13b723bc67e74317478b70c183933eb0fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41316f0449025394fdca6606d3fdb3b8f37a9872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41316f0449025394fdca6606d3fdb3b8f37a9872", "html_url": "https://github.com/rust-lang/rust/commit/41316f0449025394fdca6606d3fdb3b8f37a9872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41316f0449025394fdca6606d3fdb3b8f37a9872/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237bf3244fffef501cf37d4bda00e1fce3fcfb46", "url": "https://api.github.com/repos/rust-lang/rust/commits/237bf3244fffef501cf37d4bda00e1fce3fcfb46", "html_url": "https://github.com/rust-lang/rust/commit/237bf3244fffef501cf37d4bda00e1fce3fcfb46"}], "stats": {"total": 586, "additions": 362, "deletions": 224}, "files": [{"sha": "e0bd795c342eb8ab47b63722df294ca000f93d13", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 238, "deletions": 145, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=41316f0449025394fdca6606d3fdb3b8f37a9872", "patch": "@@ -18,7 +18,7 @@ use self::TargetLint::*;\n \n use std::slice;\n use rustc_data_structures::sync::ReadGuard;\n-use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n@@ -27,7 +27,6 @@ use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use crate::ty::query::Providers;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n@@ -203,13 +202,16 @@ impl LintStore {\n     pub fn register_late_pass(&mut self,\n                               sess: Option<&Session>,\n                               from_plugin: bool,\n+                              register_only: bool,\n                               per_module: bool,\n                               pass: LateLintPassObject) {\n         self.push_pass(sess, from_plugin, &pass);\n-        if per_module {\n-            self.late_module_passes.as_mut().unwrap().push(pass);\n-        } else {\n-            self.late_passes.as_mut().unwrap().push(pass);\n+        if !register_only {\n+            if per_module {\n+                self.late_module_passes.as_mut().unwrap().push(pass);\n+            } else {\n+                self.late_passes.as_mut().unwrap().push(pass);\n+            }\n         }\n     }\n \n@@ -538,6 +540,11 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     only_module: bool,\n }\n \n+pub struct LateContextAndPass<'a, 'tcx: 'a, T: LateLintPass<'a, 'tcx>> {\n+    context: LateContext<'a, 'tcx>,\n+    pass: T,\n+}\n+\n /// Context for lint checking of the AST, after expansion, before lowering to\n /// HIR.\n pub struct EarlyContext<'a> {\n@@ -560,17 +567,6 @@ pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     pass: T,\n }\n \n-/// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    // Move the vector of passes out of `$cx` so that we can\n-    // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lint_sess_mut().passes.take().unwrap();\n-    for obj in &mut passes {\n-        obj.$f($cx, $($args),*);\n-    }\n-    $cx.lint_sess_mut().passes = Some(passes);\n-}) }\n-\n pub trait LintPassObject: Sized {}\n \n impl LintPassObject for EarlyLintPassObject {}\n@@ -668,6 +664,10 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n@@ -778,6 +778,21 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    pub fn current_lint_root(&self) -> hir::HirId {\n+        self.last_node_with_lint_attrs\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty))\n+    }\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -787,107 +802,98 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let prev = self.last_node_with_lint_attrs;\n-        self.last_node_with_lint_attrs = id;\n+        let prev = self.context.last_node_with_lint_attrs;\n+        self.context.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n         f(self);\n         self.exit_attrs(attrs);\n-        self.last_node_with_lint_attrs = prev;\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        run_lints!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        run_lints!(self, exit_lint_attrs, attrs);\n+        self.context.last_node_with_lint_attrs = prev;\n     }\n \n     fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n-        let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n+        let old_param_env = self.context.param_env;\n+        self.context.param_env = self.context.tcx.param_env(\n+            self.context.tcx.hir().local_def_id_from_hir_id(id)\n+        );\n         f(self);\n-        self.param_env = old_param_env;\n-    }\n-    pub fn current_lint_root(&self) -> hir::HirId {\n-        self.last_node_with_lint_attrs\n+        self.context.param_env = old_param_env;\n     }\n \n     fn process_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        run_lints!(self, check_mod, m, s, n);\n+        lint_callback!(self, check_mod, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n-        run_lints!(self, check_mod_post, m, s, n);\n+        lint_callback!(self, check_mod_post, m, s, n);\n     }\n-}\n \n-impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n+    }\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.tcx.layout_of(self.param_env.and(ty))\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n     }\n }\n \n-impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n+for LateContextAndPass<'a, 'tcx, T> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.hir())\n+        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir().body(body);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body);\n+        let body = self.context.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n-        run_lints!(self, check_body, body);\n+        lint_callback!(self, check_body, body);\n         hir_visit::walk_body(self, body);\n-        run_lints!(self, check_body_post, body);\n+        lint_callback!(self, check_body_post, body);\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let generics = self.generics.take();\n-        self.generics = it.node.generics();\n+        let generics = self.context.generics.take();\n+        self.context.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_item, it);\n+                lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n-                run_lints!(cx, check_item_post, it);\n+                lint_callback!(cx, check_item_post, it);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_foreign_item, it);\n+                lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n-                run_lints!(cx, check_foreign_item_post, it);\n+                lint_callback!(cx, check_foreign_item_post, it);\n             });\n         })\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        run_lints!(self, check_pat, p);\n+        lint_callback!(self, check_pat, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n-            run_lints!(cx, check_expr, e);\n+            lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n-            run_lints!(cx, check_expr_post, e);\n+            lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n@@ -897,21 +903,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // - local\n         // - expression\n         // so we keep track of lint levels there\n-        run_lints!(self, check_stmt, s);\n+        lint_callback!(self, check_stmt, s);\n         hir_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n                 body_id: hir::BodyId, span: Span, id: hir::HirId) {\n         // Wrap in tables here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.hir().body(body_id);\n-        run_lints!(self, check_fn, fk, decl, body, span, id);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body_id);\n+        let body = self.context.tcx.hir().body(body_id);\n+        lint_callback!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n-        run_lints!(self, check_fn_post, fk, decl, body, span, id);\n-        self.tables = old_tables;\n+        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -920,14 +926,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                         g: &'tcx hir::Generics,\n                         item_id: hir::HirId,\n                         _: Span) {\n-        run_lints!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n-            run_lints!(cx, check_struct_field, s);\n+            lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n@@ -937,104 +943,104 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n-            run_lints!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            run_lints!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        run_lints!(self, check_ty, t);\n+        lint_callback!(self, check_ty, t);\n         hir_visit::walk_ty(self, t);\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        run_lints!(self, check_name, sp, name);\n+        lint_callback!(self, check_name, sp, name);\n     }\n \n     fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        if !self.only_module {\n+        if !self.context.only_module {\n             self.process_mod(m, s, n);\n         }\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n-            run_lints!(cx, check_local, l);\n+            lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        run_lints!(self, check_block, b);\n+        lint_callback!(self, check_block, b);\n         hir_visit::walk_block(self, b);\n-        run_lints!(self, check_block_post, b);\n+        lint_callback!(self, check_block_post, b);\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        run_lints!(self, check_arm, a);\n+        lint_callback!(self, check_arm, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n-        run_lints!(self, check_generic_param, p);\n+        lint_callback!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);\n     }\n \n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n-        run_lints!(self, check_generics, g);\n+        lint_callback!(self, check_generics, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n     fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n-        run_lints!(self, check_where_predicate, p);\n+        lint_callback!(self, check_where_predicate, p);\n         hir_visit::walk_where_predicate(self, p);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef,\n                             m: hir::TraitBoundModifier) {\n-        run_lints!(self, check_poly_trait_ref, t, m);\n+        lint_callback!(self, check_poly_trait_ref, t, m);\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&trait_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.hir_id, |cx| {\n-                run_lints!(cx, check_trait_item, trait_item);\n+                lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n-                run_lints!(cx, check_trait_item_post, trait_item);\n+                lint_callback!(cx, check_trait_item_post, trait_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&impl_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.hir_id, |cx| {\n-                run_lints!(cx, check_impl_item, impl_item);\n+                lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n-                run_lints!(cx, check_impl_item_post, impl_item);\n+                lint_callback!(cx, check_impl_item_post, impl_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-        run_lints!(self, check_lifetime, lt);\n+        lint_callback!(self, check_lifetime, lt);\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n     fn visit_path(&mut self, p: &'tcx hir::Path, id: hir::HirId) {\n-        run_lints!(self, check_path, p, id);\n+        lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        run_lints!(self, check_attribute, attr);\n+        lint_callback!(self, check_attribute, attr);\n     }\n }\n \n@@ -1222,94 +1228,182 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n }\n \n-pub fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+struct LateLintPassObjects<'a> {\n+    lints: &'a mut [LateLintPassObject],\n+}\n+\n+impl LintPass for LateLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+\n+    fn get_lints(&self) -> LintArray {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_late_lint_pass_impl_methods {\n+    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! late_lint_pass_impl {\n+    ([], [$hir:tt], $methods:tt) => (\n+        impl LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+        }\n+    )\n+}\n+\n+late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+\n+fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    pass: T,\n+) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let store = &tcx.sess.lint_store;\n-    let passes = store.borrow_mut().late_module_passes.take();\n \n-    let mut cx = LateContext {\n+    let context = LateContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_sess: LintSession {\n             lints: store.borrow(),\n-            passes,\n+            passes: None,\n         },\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n     };\n \n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n+    };\n+\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n     cx.process_mod(module, span, hir_id);\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n     }\n-\n-    // Put the lint store levels and passes back in the session.\n-    let passes = cx.lint_sess.passes;\n-    drop(cx.lint_sess.lints);\n-    store.borrow_mut().late_module_passes = passes;\n }\n \n-pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        lint_mod,\n-        ..*providers\n-    };\n+pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    builtin_lints: T,\n+) {\n+    assert!(!tcx.sess.opts.debugging_opts.no_interleave_lints);\n+\n+    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n+\n+    let mut passes = tcx.sess.lint_store.borrow_mut().late_module_passes.take().unwrap();\n+\n+    if !passes.is_empty() {\n+        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n+    }\n+\n+    // Put the passes back in the session.\n+    tcx.sess.lint_store.borrow_mut().late_module_passes = Some(passes);\n }\n \n-fn lint_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    pass: T\n+) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n-    let passes = tcx.sess.lint_store.borrow_mut().late_passes.take();\n-\n-    let passes = {\n-        let mut cx = LateContext {\n-            tcx,\n-            tables: &ty::TypeckTables::empty(None),\n-            param_env: ty::ParamEnv::empty(),\n-            access_levels,\n-            lint_sess: LintSession {\n-                passes,\n-                lints: tcx.sess.lint_store.borrow(),\n-            },\n-            last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n-            generics: None,\n-            only_module: false,\n-        };\n \n-        // Visit the whole crate.\n-        cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n-            // since the root module isn't visited as an item (because it isn't an\n-            // item), warn for it here.\n-            run_lints!(cx, check_crate, krate);\n-\n-            hir_visit::walk_crate(cx, krate);\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_sess: LintSession {\n+            passes: None,\n+            lints: tcx.sess.lint_store.borrow(),\n+        },\n+        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n+        generics: None,\n+        only_module: false,\n+    };\n \n-            run_lints!(cx, check_crate_post, krate);\n-        });\n-        cx.lint_sess.passes\n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n     };\n \n-    // Put the lint store levels and passes back in the session.\n-    tcx.sess.lint_store.borrow_mut().late_passes = passes;\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        lint_callback!(cx, check_crate, krate);\n+\n+        hir_visit::walk_crate(cx, krate);\n+\n+        lint_callback!(cx, check_crate_post, krate);\n+    })\n+}\n+\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: T\n+) {\n+    let mut passes = tcx.sess.lint_store.borrow_mut().late_passes.take().unwrap();\n+\n+    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        if !passes.is_empty() {\n+            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n+        }\n+\n+        late_lint_pass_crate(tcx, builtin_lints);\n+    } else {\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        let mut passes = tcx.sess.lint_store.borrow_mut().late_module_passes.take().unwrap();\n+            \n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        // Put the passes back in the session.\n+        tcx.sess.lint_store.borrow_mut().late_module_passes = Some(passes);\n+    }\n+\n+    // Put the passes back in the session.\n+    tcx.sess.lint_store.borrow_mut().late_passes = Some(passes);\n }\n \n /// Performs lint checking on a crate.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: T,\n+) {\n     // Run per-module lints\n     for &module in tcx.hir().krate().modules.keys() {\n         tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n     }\n \n     // Run whole crate non-incremental lints\n-    lint_crate(tcx);\n+    late_lint_crate(tcx, builtin_lints);\n }\n \n struct EarlyLintPassObjects<'a> {\n@@ -1346,7 +1440,6 @@ macro_rules! early_lint_pass_impl {\n \n early_lint_methods!(early_lint_pass_impl, []);\n \n-\n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,\n     krate: &ast::Crate,"}, {"sha": "b54da5e5e80d8e3284e2e07b6cf34d0b35eb2636", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=41316f0449025394fdca6606d3fdb3b8f37a9872", "patch": "@@ -42,8 +42,8 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        check_crate, check_ast_crate, CheckLintNameResult,\n-                        FutureIncompatibleInfo, BufferedEarlyLint};\n+                        check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n+                        FutureIncompatibleInfo, BufferedEarlyLint,};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -298,14 +298,14 @@ macro_rules! expand_combined_late_lint_pass_methods {\n \n #[macro_export]\n macro_rules! declare_combined_late_lint_pass {\n-    ([$name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n+    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n         #[allow(non_snake_case)]\n-        struct $name {\n+        $v struct $name {\n             $($passes: $passes,)*\n         }\n \n         impl $name {\n-            fn new() -> Self {\n+            $v fn new() -> Self {\n                 Self {\n                     $($passes: $constructor,)*\n                 }\n@@ -824,7 +824,6 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.lint_levels = lint_levels;\n-    context::provide(providers);\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "6a6f56332a8bc46956eec92065eea964b82737f9", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=41316f0449025394fdca6606d3fdb3b8f37a9872", "patch": "@@ -330,7 +330,7 @@ pub fn register_plugins<'a>(\n         ls.register_early_pass(Some(sess), true, false, pass);\n     }\n     for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, false, pass);\n+        ls.register_late_pass(Some(sess), true, false, false, pass);\n     }\n \n     for (name, (to, deprecated_name)) in lint_groups {\n@@ -783,6 +783,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     middle::entry::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);\n+    rustc_lint::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n@@ -988,7 +989,9 @@ fn analysis<'tcx>(\n                     stability::check_unused_or_stable_features(tcx)\n                 });\n             }, {\n-                time(sess, \"lint checking\", || lint::check_crate(tcx));\n+                time(sess, \"lint checking\", || {\n+                    lint::check_crate(tcx, rustc_lint::BuiltinCombinedLateLintPass::new());\n+                });\n             });\n         }, {\n             time(sess, \"privacy checking modules\", || {"}, {"sha": "c9301a32d83c4f747978ddff1e189a94ef382da8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41316f0449025394fdca6606d3fdb3b8f37a9872/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=41316f0449025394fdca6606d3fdb3b8f37a9872", "patch": "@@ -45,6 +45,9 @@ use rustc::lint::builtin::{\n };\n use rustc::session;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n \n use syntax::ast;\n use syntax::edition::Edition;\n@@ -62,6 +65,17 @@ use unused::*;\n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n \n+pub fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        lint_mod,\n+        ..*providers\n+    };\n+}\n+\n+fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+    lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+}\n+\n macro_rules! pre_expansion_lint_passes {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n@@ -94,6 +108,88 @@ macro_rules! declare_combined_early_pass {\n pre_expansion_lint_passes!(declare_combined_early_pass, [BuiltinCombinedPreExpansionLintPass]);\n early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);\n \n+macro_rules! late_lint_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            // FIXME: Look into regression when this is used as a module lint\n+            // May Depend on constants elsewhere\n+            UnusedBrokenConst: UnusedBrokenConst,\n+\n+            // Uses attr::is_used which is untracked, can't be an incremental module pass.\n+            UnusedAttributes: UnusedAttributes,\n+\n+            // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n+            UnstableFeatures: UnstableFeatures,\n+\n+            // Tracks state across modules\n+            UnnameableTestItems: UnnameableTestItems::new(),\n+\n+            // Tracks attributes of parents\n+            MissingDoc: MissingDoc::new(),\n+\n+            // Depends on access levels\n+            // FIXME: Turn the computation of types which implement Debug into a query\n+            // and change this to a module lint pass\n+            MissingDebugImplementations: MissingDebugImplementations::new(),\n+        ]);\n+    )\n+}\n+\n+macro_rules! late_lint_mod_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            HardwiredLints: HardwiredLints,\n+            WhileTrue: WhileTrue,\n+            ImproperCTypes: ImproperCTypes,\n+            VariantSizeDifferences: VariantSizeDifferences,\n+            BoxPointers: BoxPointers,\n+            PathStatements: PathStatements,\n+\n+            // Depends on referenced function signatures in expressions\n+            UnusedResults: UnusedResults,\n+\n+            NonUpperCaseGlobals: NonUpperCaseGlobals,\n+            NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n+            UnusedAllocation: UnusedAllocation,\n+\n+            // Depends on types used in type definitions\n+            MissingCopyImplementations: MissingCopyImplementations,\n+\n+            PluginAsLibrary: PluginAsLibrary,\n+\n+            // Depends on referenced function signatures in expressions\n+            MutableTransmutes: MutableTransmutes,\n+\n+            // Depends on types of fields, checks if they implement Drop\n+            UnionsWithDropFields: UnionsWithDropFields,\n+\n+            TypeAliasBounds: TypeAliasBounds,\n+\n+            TrivialConstraints: TrivialConstraints,\n+            TypeLimits: TypeLimits::new(),\n+\n+            NonSnakeCase: NonSnakeCase,\n+            InvalidNoMangleItems: InvalidNoMangleItems,\n+\n+            // Depends on access levels\n+            UnreachablePub: UnreachablePub,\n+\n+            ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+        ]);\n+    )\n+}\n+\n+macro_rules! declare_combined_late_pass {\n+    ([$v:vis $name:ident], $passes:tt) => (\n+        late_lint_methods!(declare_combined_late_lint_pass, [$v $name, $passes], ['tcx]);\n+    )\n+}\n+\n+// FIXME: Make a separate lint type which do not require typeck tables\n+late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass]);\n+\n+late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n@@ -104,17 +200,25 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         )\n     }\n \n+    macro_rules! register_pass {\n+        ($method:ident, $constructor:expr, [$($args:expr),*]) => (\n+            store.$method(sess, false, false, $($args,)* box $constructor);\n+        )\n+    }\n+\n     macro_rules! register_passes {\n-        ([$method:ident], [$($passes:ident: $constructor:expr,)*]) => (\n+        ([$method:ident, $args:tt], [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                store.$method(sess, false, false, box $constructor);\n+                register_pass!($method, $constructor, $args);\n             )*\n         )\n     }\n \n     if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n-        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass]);\n-        early_lint_passes!(register_passes, [register_early_pass]);\n+        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass, []]);\n+        early_lint_passes!(register_passes, [register_early_pass, []]);\n+        late_lint_passes!(register_passes, [register_late_pass, [false]]);\n+        late_lint_mod_passes!(register_passes, [register_late_pass, [true]]);\n     } else {\n         store.register_pre_expansion_pass(\n             sess,\n@@ -123,75 +227,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             box BuiltinCombinedPreExpansionLintPass::new()\n         );\n         store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n+        store.register_late_pass(\n+            sess, false, true, true, box BuiltinCombinedModuleLateLintPass::new()\n+        );\n+        store.register_late_pass(\n+            sess, false, true, false, box BuiltinCombinedLateLintPass::new()\n+        );\n     }\n \n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedModuleLateLintPass, [\n-        HardwiredLints: HardwiredLints,\n-        WhileTrue: WhileTrue,\n-        ImproperCTypes: ImproperCTypes,\n-        VariantSizeDifferences: VariantSizeDifferences,\n-        BoxPointers: BoxPointers,\n-        PathStatements: PathStatements,\n-\n-        // Depends on referenced function signatures in expressions\n-        UnusedResults: UnusedResults,\n-\n-        NonUpperCaseGlobals: NonUpperCaseGlobals,\n-        NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n-        UnusedAllocation: UnusedAllocation,\n-\n-        // Depends on types used in type definitions\n-        MissingCopyImplementations: MissingCopyImplementations,\n-\n-        PluginAsLibrary: PluginAsLibrary,\n-\n-        // Depends on referenced function signatures in expressions\n-        MutableTransmutes: MutableTransmutes,\n-\n-        // Depends on types of fields, checks if they implement Drop\n-        UnionsWithDropFields: UnionsWithDropFields,\n-\n-        TypeAliasBounds: TypeAliasBounds,\n-\n-        TrivialConstraints: TrivialConstraints,\n-        TypeLimits: TypeLimits::new(),\n-\n-        NonSnakeCase: NonSnakeCase,\n-        InvalidNoMangleItems: InvalidNoMangleItems,\n-\n-        // Depends on access levels\n-        UnreachablePub: UnreachablePub,\n-\n-        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, true, box BuiltinCombinedModuleLateLintPass::new());\n-\n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n-        // FIXME: Look into regression when this is used as a module lint\n-        // May Depend on constants elsewhere\n-        UnusedBrokenConst: UnusedBrokenConst,\n-\n-        // Uses attr::is_used which is untracked, can't be an incremental module pass.\n-        UnusedAttributes: UnusedAttributes,\n-\n-        // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n-        UnstableFeatures: UnstableFeatures,\n-\n-        // Tracks state across modules\n-        UnnameableTestItems: UnnameableTestItems::new(),\n-\n-        // Tracks attributes of parents\n-        MissingDoc: MissingDoc::new(),\n-\n-        // Depends on access levels\n-        // FIXME: Turn the computation of types which implement Debug into a query\n-        // and change this to a module lint pass\n-        MissingDebugImplementations: MissingDebugImplementations::new(),\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, false, box BuiltinCombinedLateLintPass::new());\n-\n     add_lint_group!(sess,\n                     \"nonstandard_style\",\n                     NON_CAMEL_CASE_TYPES,"}]}