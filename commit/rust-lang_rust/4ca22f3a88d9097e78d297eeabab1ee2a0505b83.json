{"sha": "4ca22f3a88d9097e78d297eeabab1ee2a0505b83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYTIyZjNhODhkOTA5N2U3OGQyOTdlZWFiYWIxZWUyYTA1MDViODM=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-22T20:07:09Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-22T22:44:15Z"}, "message": "Simplify inlay hints processing", "tree": {"sha": "18ab4e4ffceb52558b1d70ef9f67a0a9a351cf7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ab4e4ffceb52558b1d70ef9f67a0a9a351cf7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ca22f3a88d9097e78d297eeabab1ee2a0505b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca22f3a88d9097e78d297eeabab1ee2a0505b83", "html_url": "https://github.com/rust-lang/rust/commit/4ca22f3a88d9097e78d297eeabab1ee2a0505b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ca22f3a88d9097e78d297eeabab1ee2a0505b83/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650586a83869d6769c3d0fb94ffd2ccfcbd97db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/650586a83869d6769c3d0fb94ffd2ccfcbd97db5", "html_url": "https://github.com/rust-lang/rust/commit/650586a83869d6769c3d0fb94ffd2ccfcbd97db5"}], "stats": {"total": 138, "additions": 35, "deletions": 103}, "files": [{"sha": "ddf67af4a6ba789095de4a3b4989ed4b7caf47a3", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 35, "deletions": 103, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4ca22f3a88d9097e78d297eeabab1ee2a0505b83/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca22f3a88d9097e78d297eeabab1ee2a0505b83/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=4ca22f3a88d9097e78d297eeabab1ee2a0505b83", "patch": "@@ -50,51 +50,53 @@ fn get_inlay_hints(\n     let analyzer = Lazy::new(move || sb.analyze(hir::InFile::new(file_id.into(), node), None));\n     match_ast! {\n         match node {\n-            ast::LetStmt(it) => {\n-                if it.ascribed_type().is_some() {\n-                    return None;\n-                }\n-                let pat = it.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n-            },\n-            ast::LambdaExpr(it) => {\n-                it.param_list().map(|param_list| {\n-                    param_list\n-                        .params()\n-                        .filter(|closure_param| closure_param.ascribed_type().is_none())\n-                        .filter_map(|closure_param| closure_param.pat())\n-                        .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, false, max_inlay_hint_length))\n-                });\n-            },\n-            ast::ForExpr(it) => {\n-                let pat = it.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n-            },\n-            ast::IfExpr(it) => {\n-                let pat = it.condition()?.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n-            },\n-            ast::WhileExpr(it) => {\n-                let pat = it.condition()?.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n-            },\n-            ast::MatchArmList(it) => {\n-                it.arms()\n-                    .filter_map(|match_arm| match_arm.pat())\n-                    .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, true, max_inlay_hint_length));\n-            },\n             ast::CallExpr(it) => {\n                 get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n             ast::MethodCallExpr(it) => {\n                 get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n+            ast::BindPat(it) => {\n+                if should_not_display_type_hint(&it) {\n+                    return None;\n+                }\n+                let pat = ast::Pat::from(it);\n+                let ty = analyzer.type_of_pat(db, &pat)?;\n+                if ty.is_unknown() {\n+                    return None;\n+                }\n+\n+                acc.push(\n+                    InlayHint {\n+                        range: pat.syntax().text_range(),\n+                        kind: InlayKind::TypeHint,\n+                        label: ty.display_truncated(db, max_inlay_hint_length).to_string().into(),\n+                    }\n+                );\n+            },\n             _ => (),\n         }\n     };\n     Some(())\n }\n \n+fn should_not_display_type_hint(bind_pat: &ast::BindPat) -> bool {\n+    for node in bind_pat.syntax().ancestors() {\n+        match_ast! {\n+            match node {\n+                ast::LetStmt(it) => {\n+                    return it.ascribed_type().is_some()\n+                },\n+                ast::Param(it) => {\n+                    return it.ascribed_type().is_some()\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+    false\n+}\n+\n fn get_param_name_hints(\n     acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n@@ -160,76 +162,6 @@ fn get_fn_signature(\n     }\n }\n \n-fn get_pat_type_hints(\n-    acc: &mut Vec<InlayHint>,\n-    db: &RootDatabase,\n-    analyzer: &SourceAnalyzer,\n-    root_pat: ast::Pat,\n-    skip_root_pat_hint: bool,\n-    max_inlay_hint_length: Option<usize>,\n-) {\n-    let original_pat = &root_pat.clone();\n-\n-    let hints = get_leaf_pats(root_pat)\n-        .into_iter()\n-        .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n-        .filter_map(|pat| {\n-            let ty = analyzer.type_of_pat(db, &pat)?;\n-            if ty.is_unknown() {\n-                return None;\n-            }\n-            Some((pat.syntax().text_range(), ty))\n-        })\n-        .map(|(range, pat_type)| InlayHint {\n-            range,\n-            kind: InlayKind::TypeHint,\n-            label: pat_type.display_truncated(db, max_inlay_hint_length).to_string().into(),\n-        });\n-\n-    acc.extend(hints);\n-}\n-\n-fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n-    let mut pats_to_process = std::collections::VecDeque::<ast::Pat>::new();\n-    pats_to_process.push_back(root_pat);\n-\n-    let mut leaf_pats = Vec::new();\n-\n-    while let Some(maybe_leaf_pat) = pats_to_process.pop_front() {\n-        match &maybe_leaf_pat {\n-            ast::Pat::BindPat(bind_pat) => match bind_pat.pat() {\n-                Some(pat) => pats_to_process.push_back(pat),\n-                _ => leaf_pats.push(maybe_leaf_pat),\n-            },\n-            ast::Pat::OrPat(ref_pat) => pats_to_process.extend(ref_pat.pats()),\n-            ast::Pat::TuplePat(tuple_pat) => pats_to_process.extend(tuple_pat.args()),\n-            ast::Pat::RecordPat(record_pat) => {\n-                if let Some(pat_list) = record_pat.record_field_pat_list() {\n-                    pats_to_process.extend(\n-                        pat_list\n-                            .record_field_pats()\n-                            .filter_map(|record_field_pat| {\n-                                record_field_pat\n-                                    .pat()\n-                                    .filter(|pat| pat.syntax().kind() != SyntaxKind::BIND_PAT)\n-                            })\n-                            .chain(pat_list.bind_pats().map(|bind_pat| {\n-                                bind_pat.pat().unwrap_or_else(|| ast::Pat::from(bind_pat))\n-                            })),\n-                    );\n-                }\n-            }\n-            ast::Pat::TupleStructPat(tuple_struct_pat) => {\n-                pats_to_process.extend(tuple_struct_pat.args())\n-            }\n-            ast::Pat::ParenPat(inner_pat) => pats_to_process.extend(inner_pat.pat()),\n-            ast::Pat::RefPat(ref_pat) => pats_to_process.extend(ref_pat.pat()),\n-            _ => (),\n-        }\n-    }\n-    leaf_pats\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;"}]}