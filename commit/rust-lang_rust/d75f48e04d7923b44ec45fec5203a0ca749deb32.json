{"sha": "d75f48e04d7923b44ec45fec5203a0ca749deb32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NWY0OGUwNGQ3OTIzYjQ0ZWM0NWZlYzUyMDNhMGNhNzQ5ZGViMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-29T00:16:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-29T00:16:54Z"}, "message": "Auto merge of #80449 - m-ou-se:rollup-kp2e5n8, r=m-ou-se\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #80383 (clarify wrapping ptr arithmetic docs)\n - #80390 (BTreeMap: rename the area access methods)\n - #80393 (Add links to the source for the rustc and rustdoc books.)\n - #80398 (Use raw version of align_of in rc data_offset)\n - #80402 (Document `InferTy` & co.)\n - #80403 (fix: small typo error in chalk/mod.rs)\n - #80410 (rustdoc book: fix example)\n - #80419 (Add regression test for #80375)\n - #80430 (Add \"length\" as doc alias to len methods)\n - #80431 (Add \"chr\" as doc alias to char::from_u32)\n - #80448 (Fix stabilization version of deque_range feature.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "beed754390860bc1b49cbcd0cf50140cf9704c0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beed754390860bc1b49cbcd0cf50140cf9704c0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d75f48e04d7923b44ec45fec5203a0ca749deb32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d75f48e04d7923b44ec45fec5203a0ca749deb32", "html_url": "https://github.com/rust-lang/rust/commit/d75f48e04d7923b44ec45fec5203a0ca749deb32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d75f48e04d7923b44ec45fec5203a0ca749deb32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2987785df3d46d5ff144a5c67fbb8f5cca798d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/2987785df3d46d5ff144a5c67fbb8f5cca798d78", "html_url": "https://github.com/rust-lang/rust/commit/2987785df3d46d5ff144a5c67fbb8f5cca798d78"}, {"sha": "e3d26e007c9499f4c6a1f19cefba5006bb10f975", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d26e007c9499f4c6a1f19cefba5006bb10f975", "html_url": "https://github.com/rust-lang/rust/commit/e3d26e007c9499f4c6a1f19cefba5006bb10f975"}], "stats": {"total": 362, "additions": 231, "deletions": 131}, "files": [{"sha": "744c7a541a53c58e2abcb802be2bc1012aea351f", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -1424,28 +1424,33 @@ pub struct EarlyBoundRegion {\n     pub name: Symbol,\n }\n \n+/// A **ty**pe **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n+/// A **`const`** **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n+/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct IntVid {\n     pub index: u32,\n }\n \n+/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct FloatVid {\n     pub index: u32,\n }\n \n rustc_index::newtype_index! {\n+    /// A **region** (lifetime) **v**ariable **ID**.\n     pub struct RegionVid {\n         DEBUG_FORMAT = custom,\n     }\n@@ -1457,18 +1462,40 @@ impl Atom for RegionVid {\n     }\n }\n \n+/// A placeholder for a type that hasn't been inferred yet.\n+///\n+/// E.g., if we have an empty array (`[]`), then we create a fresh\n+/// type variable for the element type since we won't know until it's\n+/// used what the element type is supposed to be.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum InferTy {\n+    /// A type variable.\n     TyVar(TyVid),\n+    /// An integral type variable (`{integer}`).\n+    ///\n+    /// These are created when the compiler sees an integer literal like\n+    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n     IntVar(IntVid),\n+    /// A floating-point type variable (`{float}`).\n+    ///\n+    /// These are created when the compiler sees an float literal like\n+    /// `1.0` that could be either an `f32` or an `f64`.\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n     FloatVar(FloatVid),\n \n-    /// A `FreshTy` is one that is generated as a replacement for an\n-    /// unbound type variable. This is convenient for caching etc. See\n-    /// `infer::freshen` for more details.\n+    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n+    /// for an unbound type variable. This is convenient for caching etc. See\n+    /// `rustc_infer::infer::freshen` for more details.\n+    ///\n+    /// Compare with [`TyVar`][Self::TyVar].\n     FreshTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n     FreshIntTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n     FreshFloatTy(u32),\n }\n "}, {"sha": "bd2f87f70a2f1f983aaa197591f5798e36acb80f", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -98,7 +98,7 @@ crate fn evaluate_goal<'tcx>(\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n     let db = ChalkRustIrDatabase { interner, reempty_placeholder };\n     let solution = solver.solve(&db, &lowered_goal);\n-    debug!(?obligation, ?solution, \"evaluatate goal\");\n+    debug!(?obligation, ?solution, \"evaluate goal\");\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't"}, {"sha": "76051d9e1dffdc149d2c3344d55d53fc3629a516", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -915,6 +915,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// assert_eq!(heap.len(), 2);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "944e0e65cf7c111e061d3fd94a5105254120df3d", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -2132,6 +2132,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n     pub const fn len(&self) -> usize {"}, {"sha": "b3641a7a0c6973a8cd52e2dd2a9a6645d1e6f06d", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -489,7 +489,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY\n-    unsafe fn key_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn key_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<K>], Output = Output>,\n     {\n@@ -503,7 +503,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY\n-    unsafe fn val_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn val_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<V>], Output = Output>,\n     {\n@@ -519,7 +519,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY + 1\n-    unsafe fn edge_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn edge_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<BoxedNode<K, V>>], Output = Output>,\n     {\n@@ -583,8 +583,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.key_area_mut_at(idx).write(key);\n-            self.val_area_mut_at(idx).write(val);\n+            self.key_area_mut(idx).write(key);\n+            self.val_area_mut(idx).write(val);\n         }\n     }\n \n@@ -593,8 +593,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         let new_len = self.len() + 1;\n         assert!(new_len <= CAPACITY);\n         unsafe {\n-            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n-            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n+            slice_insert(self.key_area_mut(..new_len), 0, key);\n+            slice_insert(self.val_area_mut(..new_len), 0, val);\n             *self.len_mut() = new_len as u16;\n         }\n     }\n@@ -627,9 +627,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.key_area_mut_at(idx).write(key);\n-            self.val_area_mut_at(idx).write(val);\n-            self.edge_area_mut_at(idx + 1).write(edge.node);\n+            self.key_area_mut(idx).write(key);\n+            self.val_area_mut(idx).write(val);\n+            self.edge_area_mut(idx + 1).write(edge.node);\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -642,9 +642,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(new_len <= CAPACITY);\n \n         unsafe {\n-            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n-            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n-            slice_insert(self.edge_area_mut_at(..new_len + 1), 0, edge.node);\n+            slice_insert(self.key_area_mut(..new_len), 0, key);\n+            slice_insert(self.val_area_mut(..new_len), 0, val);\n+            slice_insert(self.edge_area_mut(..new_len + 1), 0, edge.node);\n             *self.len_mut() = new_len as u16;\n         }\n \n@@ -662,12 +662,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = self.key_area_mut_at(idx).assume_init_read();\n-            let val = self.val_area_mut_at(idx).assume_init_read();\n+            let key = self.key_area_mut(idx).assume_init_read();\n+            let val = self.val_area_mut(idx).assume_init_read();\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = internal.edge_area_mut_at(idx + 1).assume_init_read();\n+                    let node = internal.edge_area_mut(idx + 1).assume_init_read();\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -690,12 +690,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.key_area_mut_at(..old_len), 0);\n-            let val = slice_remove(self.val_area_mut_at(..old_len), 0);\n+            let key = slice_remove(self.key_area_mut(..old_len), 0);\n+            let val = slice_remove(self.val_area_mut(..old_len), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = slice_remove(internal.edge_area_mut_at(..old_len + 1), 0);\n+                    let node = slice_remove(internal.edge_area_mut(..old_len + 1), 0);\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -919,11 +919,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         let new_len = self.node.len() + 1;\n \n         unsafe {\n-            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n-            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n+            slice_insert(self.node.key_area_mut(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n             *self.node.len_mut() = new_len as u16;\n \n-            self.node.val_area_mut_at(self.idx).assume_init_mut()\n+            self.node.val_area_mut(self.idx).assume_init_mut()\n         }\n     }\n }\n@@ -978,9 +978,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         let new_len = self.node.len() + 1;\n \n         unsafe {\n-            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n-            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n-            slice_insert(self.node.edge_area_mut_at(..new_len + 1), self.idx + 1, edge.node);\n+            slice_insert(self.node.key_area_mut(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n+            slice_insert(self.node.edge_area_mut(..new_len + 1), self.idx + 1, edge.node);\n             *self.node.len_mut() = new_len as u16;\n \n             self.node.correct_childrens_parent_links(self.idx + 1..new_len + 1);\n@@ -1085,7 +1085,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeTyp\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn key_mut(&mut self) -> &mut K {\n-        unsafe { self.node.key_area_mut_at(self.idx).assume_init_mut() }\n+        unsafe { self.node.key_area_mut(self.idx).assume_init_mut() }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n@@ -1127,16 +1127,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let new_len = self.node.len() - self.idx - 1;\n         new_node.len = new_len as u16;\n         unsafe {\n-            let k = self.node.key_area_mut_at(self.idx).assume_init_read();\n-            let v = self.node.val_area_mut_at(self.idx).assume_init_read();\n+            let k = self.node.key_area_mut(self.idx).assume_init_read();\n+            let v = self.node.val_area_mut(self.idx).assume_init_read();\n \n             ptr::copy_nonoverlapping(\n-                self.node.key_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.key_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.keys.as_mut_ptr(),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.val_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.val_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.vals.as_mut_ptr(),\n                 new_len,\n             );\n@@ -1173,8 +1173,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let old_len = self.node.len();\n         unsafe {\n-            let k = slice_remove(self.node.key_area_mut_at(..old_len), self.idx);\n-            let v = slice_remove(self.node.val_area_mut_at(..old_len), self.idx);\n+            let k = slice_remove(self.node.key_area_mut(..old_len), self.idx);\n+            let v = slice_remove(self.node.val_area_mut(..old_len), self.idx);\n             *self.node.len_mut() = (old_len - 1) as u16;\n             ((k, v), self.left_edge())\n         }\n@@ -1195,7 +1195,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             ptr::copy_nonoverlapping(\n-                self.node.edge_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.edge_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n@@ -1321,25 +1321,23 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         unsafe {\n             *left_node.len_mut() = new_left_len as u16;\n \n-            let parent_key =\n-                slice_remove(parent_node.key_area_mut_at(..old_parent_len), parent_idx);\n-            left_node.key_area_mut_at(old_left_len).write(parent_key);\n+            let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);\n+            left_node.key_area_mut(old_left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n-                right_node.key_area_mut_at(..).as_ptr(),\n-                left_node.key_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                right_node.key_area_mut(..).as_ptr(),\n+                left_node.key_area_mut(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            let parent_val =\n-                slice_remove(parent_node.val_area_mut_at(..old_parent_len), parent_idx);\n-            left_node.val_area_mut_at(old_left_len).write(parent_val);\n+            let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);\n+            left_node.val_area_mut(old_left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n-                right_node.val_area_mut_at(..).as_ptr(),\n-                left_node.val_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                right_node.val_area_mut(..).as_ptr(),\n+                left_node.val_area_mut(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            slice_remove(&mut parent_node.edge_area_mut_at(..old_parent_len + 1), parent_idx + 1);\n+            slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);\n             parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n             *parent_node.len_mut() -= 1;\n \n@@ -1349,8 +1347,8 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                 let mut right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.edge_area_mut_at(..).as_ptr(),\n-                    left_node.edge_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                    right_node.edge_area_mut(..).as_ptr(),\n+                    left_node.edge_area_mut(old_left_len + 1..).as_mut_ptr(),\n                     right_len + 1,\n                 );\n \n@@ -1458,7 +1456,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n+                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n                     right.correct_childrens_parent_links(count..new_right_len + 1);\n \n@@ -1518,7 +1516,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                     move_edges(right.reborrow_mut(), 0, left, old_left_len + 1, count);\n \n                     // Fill gap where stolen edges used to be.\n-                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n+                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1551,8 +1549,8 @@ unsafe fn move_edges<'a, K: 'a, V: 'a>(\n     count: usize,\n ) {\n     unsafe {\n-        let source_ptr = source.edge_area_mut_at(..).as_ptr();\n-        let dest_ptr = dest.edge_area_mut_at(dest_offset..).as_mut_ptr();\n+        let source_ptr = source.edge_area_mut(..).as_ptr();\n+        let dest_ptr = dest.edge_area_mut(dest_offset..).as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr, count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }"}, {"sha": "c72e305a1f9470334f641ed77fb1361aed103199", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -975,6 +975,7 @@ impl<T> BTreeSet<T> {\n     /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n     pub const fn len(&self) -> usize {"}, {"sha": "397e774f1a03da6f6f615ff5cdf066c9c48c65af", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -593,6 +593,7 @@ impl<T> LinkedList<T> {\n     /// dl.push_back(3);\n     /// assert_eq!(dl.len(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {"}, {"sha": "f8fad6de1a3cc567be060543fa9f4d3e2234f5ca", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -1038,6 +1038,7 @@ impl<T> VecDeque<T> {\n     /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         count(self.tail, self.head, self.cap())\n@@ -1091,7 +1092,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(all.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"deque_range\", since = \"1.50.0\")]\n+    #[stable(feature = \"deque_range\", since = \"1.51.0\")]\n     pub fn range<R>(&self, range: R) -> Iter<'_, T>\n     where\n         R: RangeBounds<usize>,\n@@ -1130,7 +1131,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(v, vec![2, 4, 12]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"deque_range\", since = \"1.50.0\")]\n+    #[stable(feature = \"deque_range\", since = \"1.51.0\")]\n     pub fn range_mut<R>(&mut self, range: R) -> IterMut<'_, T>\n     where\n         R: RangeBounds<usize>,"}, {"sha": "9198892859317e02e1d3214a98df477a564cc86e", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -1388,6 +1388,7 @@ impl String {\n     /// assert_eq!(fancy_f.len(), 4);\n     /// assert_eq!(fancy_f.chars().count(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {"}, {"sha": "7c03345aba50722982423af6e8ee0db6d543c95c", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -14,7 +14,7 @@ use core::hint;\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of_val_raw, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -2366,7 +2366,7 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Because it is `?Sized`, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    unsafe { data_offset_align(align_of_val(&*ptr)) }\n+    unsafe { data_offset_align(align_of_val_raw(ptr)) }\n }\n \n #[inline]"}, {"sha": "c9fa41138cd416f46bbb0aa4faa78ada33d4bce5", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -1559,6 +1559,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// let a = vec![1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {"}, {"sha": "de05a8c82e8f6a6d373f151d0c037391df1221ac", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -47,6 +47,7 @@ use super::MAX;\n ///\n /// assert_eq!(None, c);\n /// ```\n+#[doc(alias = \"chr\")]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {"}, {"sha": "996d62e2b4a42fd0c34a77edd6ed7a7887a1f653", "filename": "library/core/src/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -91,6 +91,7 @@ pub trait ExactSizeIterator: Iterator {\n     ///\n     /// assert_eq!(5, five.len());\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len(&self) -> usize {"}, {"sha": "38519f759ae0504cdd483b396f1c451f4945ac70", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 56, "deletions": 36, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -232,23 +232,27 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n     ///\n-    /// In other words, `x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::<T>())`\n-    /// is *not* the same as `y`, and dereferencing it is undefined behavior\n-    /// unless `x` and `y` point into the same allocated object.\n+    /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// Compared to [`offset`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// Compared to [`offset`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`offset`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_offset` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`offset`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n+    ///\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n+    /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there.\n@@ -571,19 +575,27 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n+    ///\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// Compared to [`add`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`add`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n     ///\n-    /// Compared to [`add`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n+    /// allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there.\n@@ -628,19 +640,27 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n+    ///\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// Compared to [`sub`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`sub`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_sub` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`sub`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n     ///\n-    /// Compared to [`sub`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n+    /// allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there."}, {"sha": "92f4e431de499dbf24ae88abeeb1be3020b0a97b", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 56, "deletions": 36, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -238,23 +238,27 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n     ///\n-    /// In other words, `x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::<T>())`\n-    /// is *not* the same as `y`, and dereferencing it is undefined behavior\n-    /// unless `x` and `y` point into the same allocated object.\n+    /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// Compared to [`offset`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// Compared to [`offset`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`offset`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_offset` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`offset`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n+    ///\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n+    /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there.\n@@ -678,19 +682,27 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n+    ///\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// Compared to [`add`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`add`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n     ///\n-    /// Compared to [`add`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n+    /// allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there.\n@@ -735,19 +747,27 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// This operation itself is always safe, but using the resulting pointer is not.\n+    ///\n+    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n+    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n+    /// (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n+    /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n+    /// attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n+    /// `x` and `y` point into the same allocated object.\n     ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n+    /// Compared to [`sub`], this method basically delays the requirement of staying within the\n+    /// same allocated object: [`sub`] is immediate Undefined Behavior when crossing object\n+    /// boundaries; `wrapping_sub` produces a pointer but still leads to Undefined Behavior if a\n+    /// pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`sub`]\n+    /// can be optimized better and is thus preferable in performance-sensitive code.\n     ///\n-    /// Compared to [`sub`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n-    /// better and is thus preferable in performance-sensitive code.\n+    /// The delayed check only considers the value of the pointer that was dereferenced, not the\n+    /// intermediate values used during the computation of the final result. For example,\n+    /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n+    /// allocated object and then re-entering it later is permitted.\n     ///\n     /// If you need to cross object boundaries, cast the pointer to an integer and\n     /// do the arithmetic there."}, {"sha": "bb1014332a1cf2c58d24b5dce0f8944ffc889509", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -84,6 +84,7 @@ impl<T> [T] {\n     /// let a = [1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.32.0\")]\n     #[inline]"}, {"sha": "ba495a1a9fbe4b6421315e526543efee6ae35702", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -138,6 +138,7 @@ impl str {\n     /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n     /// assert_eq!(\"\u0192oo\".chars().count(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_str_len\", since = \"1.32.0\")]\n     #[inline]"}, {"sha": "0680b1fc32975ea2b4b533e4913e7bdec989213f", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -448,6 +448,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         self.base.len()"}, {"sha": "f49e5801c353516adfcd018819a86e087d1c6274", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -199,6 +199,7 @@ impl<T, S> HashSet<T, S> {\n     /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {"}, {"sha": "2eef4d58507c002209893d7468a8b727c3eb89cb", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -653,6 +653,7 @@ impl OsStr {\n     /// let os_str = OsStr::new(\"foo\");\n     /// assert_eq!(os_str.len(), 3);\n     /// ```\n+    #[doc(alias = \"length\")]\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn len(&self) -> usize {\n         self.inner.inner.len()"}, {"sha": "21d127c39c904a39215d1a25240a64c69e542810", "filename": "src/doc/rustc/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fbook.toml?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -3,3 +3,6 @@ authors = [\"The Rust Project Developers\"]\n multilingual = false\n src = \"src\"\n title = \"The rustc book\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/rustc\""}, {"sha": "c2e7ff589066b65b4f98771fd3928fd5d309d51c", "filename": "src/doc/rustdoc/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustdoc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustdoc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fbook.toml?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -2,3 +2,6 @@\n authors = [\"The Rust Project Developers\"]\n src = \"src\"\n title = \"The rustdoc book\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/rustdoc\""}, {"sha": "32dc1e02bb3dbb9bcc6251b49a6926bfc6f79d08", "filename": "src/doc/rustdoc/src/what-is-rustdoc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -10,7 +10,7 @@ CSS, and JavaScript.\n Let's give it a try! Create a new project with Cargo:\n \n ```bash\n-$ cargo new docs\n+$ cargo new docs --lib\n $ cd docs\n ```\n "}, {"sha": "c906bb2c4d9b46a515f7d7a3197a964f2a71042c", "filename": "src/test/ui/const-generics/issues/issue-80375.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.rs?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -0,0 +1,4 @@\n+struct MyArray<const COUNT: usize>([u8; COUNT + 1]);\n+//~^ ERROR generic parameters may not be used in const operations\n+\n+fn main() {}"}, {"sha": "9765a639a48d09ee9351cd6165829b05a6874f55", "filename": "src/test/ui/const-generics/issues/issue-80375.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d75f48e04d7923b44ec45fec5203a0ca749deb32/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80375.stderr?ref=d75f48e04d7923b44ec45fec5203a0ca749deb32", "patch": "@@ -0,0 +1,11 @@\n+error: generic parameters may not be used in const operations\n+  --> $DIR/issue-80375.rs:1:41\n+   |\n+LL | struct MyArray<const COUNT: usize>([u8; COUNT + 1]);\n+   |                                         ^^^^^ cannot perform const operation using `COUNT`\n+   |\n+   = help: const parameters may only be used as standalone arguments, i.e. `COUNT`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n+\n+error: aborting due to previous error\n+"}]}