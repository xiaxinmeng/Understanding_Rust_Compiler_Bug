{"sha": "4a742a691e7dd2522bad68b86fe2fd5a199d5561", "node_id": "C_kwDOAAsO6NoAKDRhNzQyYTY5MWU3ZGQyNTIyYmFkNjhiODZmZTJmZDVhMTk5ZDU1NjE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-20T07:55:58Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-20T07:55:58Z"}, "message": "Revert \"Rollup merge of #98582 - oli-obk:unconstrained_opaque_type, r=estebank\"\n\nThis reverts commit 6f8fb911ad504b77549cf3256a09465621beab9d, reversing\nchanges made to 7210e46dc69a4b197a313d093fe145722c248b7d.", "tree": {"sha": "2612ec56be2d5c353973eee585ea3f6ffb28ca2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2612ec56be2d5c353973eee585ea3f6ffb28ca2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a742a691e7dd2522bad68b86fe2fd5a199d5561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a742a691e7dd2522bad68b86fe2fd5a199d5561", "html_url": "https://github.com/rust-lang/rust/commit/4a742a691e7dd2522bad68b86fe2fd5a199d5561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a742a691e7dd2522bad68b86fe2fd5a199d5561/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03d488b48af9f66b91e9400387f781b82411fa82", "url": "https://api.github.com/repos/rust-lang/rust/commits/03d488b48af9f66b91e9400387f781b82411fa82", "html_url": "https://github.com/rust-lang/rust/commit/03d488b48af9f66b91e9400387f781b82411fa82"}], "stats": {"total": 601, "additions": 205, "deletions": 396}, "files": [{"sha": "1b3c6cac9c42f82dc915aa65a4406d4af8427086", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -2155,9 +2155,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             StorageDeadOrDrop::Destructor(_) => kind,\n                         },\n-                        ProjectionElem::OpaqueCast { .. }\n-                        | ProjectionElem::Field(..)\n-                        | ProjectionElem::Downcast(..) => {\n+                        ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n                             match place_ty.ty.kind() {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     // Report the outermost adt with a destructor"}, {"sha": "53c07a3d481e0912d509944ba441de351c47906c", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -226,7 +226,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n                 ProjectionElem::Downcast(..) => (),\n-                ProjectionElem::OpaqueCast(..) => (),\n                 ProjectionElem::Field(field, _ty) => {\n                     // FIXME(project-rfc_2229#36): print capture precisely here.\n                     if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -287,7 +286,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     PlaceRef { local, projection: proj_base }.ty(self.body, self.infcx.tcx)\n                 }\n                 ProjectionElem::Downcast(..) => place.ty(self.body, self.infcx.tcx),\n-                ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(*ty),\n                 ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n         };"}, {"sha": "8134e1226628fa2aef91e132497f0b4599ce6d98", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -169,7 +169,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ..,\n                         ProjectionElem::Index(_)\n                         | ProjectionElem::ConstantIndex { .. }\n-                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::Downcast(..),\n                     ],"}, {"sha": "29f47200b807642aa2f090c3b6ec9bbc5966a515", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1788,7 +1788,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n-                ProjectionElem::OpaqueCast(_) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n                 ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n@@ -2180,7 +2179,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::Index(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n-                    | ProjectionElem::OpaqueCast { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {"}, {"sha": "97335fd0dffaeb4d28205c7adfd76654f4e4706e", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -255,7 +255,6 @@ fn place_components_conflict<'tcx>(\n                 | (ProjectionElem::Index { .. }, _, _)\n                 | (ProjectionElem::ConstantIndex { .. }, _, _)\n                 | (ProjectionElem::Subslice { .. }, _, _)\n-                | (ProjectionElem::OpaqueCast { .. }, _, _)\n                 | (ProjectionElem::Downcast { .. }, _, _) => {\n                     // Recursive case. This can still be disjoint on a\n                     // further iteration if this a shallow access and\n@@ -323,17 +322,6 @@ fn place_projection_conflict<'tcx>(\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n             Overlap::EqualOrDisjoint\n         }\n-        (ProjectionElem::OpaqueCast(v1), ProjectionElem::OpaqueCast(v2)) => {\n-            if v1 == v2 {\n-                // same type - recur.\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // Different types. Disjoint!\n-                debug!(\"place_element_conflict: DISJOINT-OPAQUE\");\n-                Overlap::Disjoint\n-            }\n-        }\n         (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n             if f1 == f2 {\n                 // same field (e.g., `a.y` vs. `a.y`) - recur.\n@@ -537,7 +525,6 @@ fn place_projection_conflict<'tcx>(\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n-            | ProjectionElem::OpaqueCast { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(..),\n             _,"}, {"sha": "bdf2becb711264eff522a8cbe962ea5db3888cc1", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -81,7 +81,6 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n-                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n                             cursor = cursor_base;"}, {"sha": "cf2140097e6da02b45253fef2e86ec5777de83d4", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -790,19 +790,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 PlaceTy::from_ty(fty)\n             }\n-            ProjectionElem::OpaqueCast(ty) => {\n-                let ty = self.sanitize_type(place, ty);\n-                let ty = self.cx.normalize(ty, location);\n-                self.cx\n-                    .eq_types(\n-                        base.ty,\n-                        ty,\n-                        location.to_locations(),\n-                        ConstraintCategory::TypeAnnotation,\n-                    )\n-                    .unwrap();\n-                PlaceTy::from_ty(ty)\n-            }\n         }\n     }\n \n@@ -1208,11 +1195,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, _| {\n+                |this, field, ()| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n-                |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n@@ -2507,7 +2493,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 ProjectionElem::Field(..)\n                 | ProjectionElem::Downcast(..)\n-                | ProjectionElem::OpaqueCast(..)\n                 | ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {"}, {"sha": "63cd4d6de4c3e12fab188e78f1c323e019e8915e", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -825,7 +825,6 @@ pub(crate) fn codegen_place<'tcx>(\n                     cplace = cplace.place_deref(fx);\n                 }\n             }\n-            PlaceElem::OpaqueCast(ty) => cplace = cplace.place_opaque_cast(fx, ty),\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);\n             }"}, {"sha": "a68225de58b32d160dd2302ed54eaf352b3d8831", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -615,14 +615,6 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn place_opaque_cast(\n-        self,\n-        fx: &mut FunctionCx<'_, '_, 'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> CPlace<'tcx> {\n-        CPlace { inner: self.inner, layout: fx.layout_of(ty) }\n-    }\n-\n     pub(crate) fn place_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "58cee0c8bb0dbf166d9d7fbb827e44d319607e1a", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -411,21 +411,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n-    pub fn project_type<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        &self,\n-        bx: &mut Bx,\n-        ty: Ty<'tcx>,\n-    ) -> Self {\n-        let mut downcast = *self;\n-        downcast.layout = bx.cx().layout_of(ty);\n-\n-        // Cast to the appropriate type.\n-        let variant_ty = bx.cx().backend_type(downcast.layout);\n-        downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n-\n-        downcast\n-    }\n-\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n@@ -474,7 +459,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }\n-                mir::ProjectionElem::OpaqueCast(ty) => cg_base.project_type(bx, ty),\n                 mir::ProjectionElem::Index(index) => {\n                     let index = &mir::Operand::Copy(mir::Place::from(index));\n                     let index = self.codegen_operand(bx, index);"}, {"sha": "61d58232dc29c5bccabcf418093443242900b8b9", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -349,11 +349,6 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n-            OpaqueCast(ty) => {\n-                let mut place = base.clone();\n-                place.layout = self.layout_of(ty)?;\n-                place\n-            }\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n@@ -378,11 +373,6 @@ where\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n-            OpaqueCast(ty) => {\n-                let mut op = base.clone();\n-                op.layout = self.layout_of(ty)?;\n-                op\n-            }\n             Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),"}, {"sha": "628298df4738560af218809c0cba1f6770768344", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -652,7 +652,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n-            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {}"}, {"sha": "29464cf8c4e4fa1856269a66e30828b8c5d5076f", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -316,7 +316,6 @@ where\n \n             ProjectionElem::Deref\n             | ProjectionElem::Field(_, _)\n-            | ProjectionElem::OpaqueCast(_)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(_, _)"}, {"sha": "ed4d8c95d1e6178d882bcaef5a3c9b5bad620a39", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             return Err(Unpromotable);\n                         }\n                     }\n-                    ProjectionElem::OpaqueCast(..) | ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n                     }\n "}, {"sha": "f61cb7e8c472e68a55674e853d2c168f262e0a95", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1397,7 +1397,6 @@ impl<V, T> ProjectionElem<V, T> {\n \n             Self::Field(_, _)\n             | Self::Index(_)\n-            | Self::OpaqueCast(_)\n             | Self::ConstantIndex { .. }\n             | Self::Subslice { .. }\n             | Self::Downcast(_, _) => false,\n@@ -1575,9 +1574,7 @@ impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         for elem in self.projection.iter().rev() {\n             match elem {\n-                ProjectionElem::OpaqueCast(_)\n-                | ProjectionElem::Downcast(_, _)\n-                | ProjectionElem::Field(_, _) => {\n+                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n                     write!(fmt, \"(\").unwrap();\n                 }\n                 ProjectionElem::Deref => {\n@@ -1593,9 +1590,6 @@ impl Debug for Place<'_> {\n \n         for elem in self.projection.iter() {\n             match elem {\n-                ProjectionElem::OpaqueCast(ty) => {\n-                    write!(fmt, \" as {})\", ty)?;\n-                }\n                 ProjectionElem::Downcast(Some(name), _index) => {\n                     write!(fmt, \" as {})\", name)?;\n                 }"}, {"sha": "510316c778bc7678a0ebd40ec4a8549cebbec164", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -754,9 +754,6 @@ pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n ///    generator has more than one variant, the parent place's variant index must be set, indicating\n ///    which variant is being used. If it has just one variant, the variant index may or may not be\n ///    included - the single possible variant is inferred if it is not included.\n-///  - [`OpaqueCast`](ProjectionElem::OpaqueCast): This projection changes the place's type to the\n-///    given one, and makes no other changes. A `OpaqueCast` projection on any type other than an\n-///    opaque type from the current crate is not well-formed.\n ///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n ///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n ///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n@@ -859,10 +856,6 @@ pub enum ProjectionElem<V, T> {\n     ///\n     /// The included Symbol is the name of the variant, used for printing MIR.\n     Downcast(Option<Symbol>, VariantIdx),\n-\n-    /// Like an explicit cast from an opaque type to a concrete type, but without\n-    /// requiring an intermediate variable.\n-    OpaqueCast(T),\n }\n \n /// Alias for projections as they appear in places, where the base is a place"}, {"sha": "fd3359ea80fe50e6d6776d25d861db65cd1a4df9", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty, |_, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -71,7 +71,6 @@ impl<'tcx> PlaceTy<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n-        mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n@@ -110,7 +109,6 @@ impl<'tcx> PlaceTy<'tcx> {\n                 PlaceTy { ty: self.ty, variant_index: Some(index) }\n             }\n             ProjectionElem::Field(f, fty) => PlaceTy::from_ty(handle_field(&self, f, fty)),\n-            ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(handle_opaque_cast(&self, ty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer"}, {"sha": "82a6b0c506f58c0087ce9dff2713ae2c6314dee1", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -182,7 +182,6 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n         Ok(match self {\n             Deref => Deref,\n             Field(f, ty) => Field(f, ty.try_fold_with(folder)?),\n-            OpaqueCast(ty) => OpaqueCast(ty.try_fold_with(folder)?),\n             Index(v) => Index(v.try_fold_with(folder)?),\n             Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "d285728ec0783002073eaf556b9aefd8bbc832cd", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1064,11 +1064,6 @@ macro_rules! visit_place_fns {\n                     self.visit_ty(&mut new_ty, TyContext::Location(location));\n                     if ty != new_ty { Some(PlaceElem::Field(field, new_ty)) } else { None }\n                 }\n-                PlaceElem::OpaqueCast(ty) => {\n-                    let mut new_ty = ty;\n-                    self.visit_ty(&mut new_ty, TyContext::Location(location));\n-                    if ty != new_ty { Some(PlaceElem::OpaqueCast(new_ty)) } else { None }\n-                }\n                 PlaceElem::Deref\n                 | PlaceElem::ConstantIndex { .. }\n                 | PlaceElem::Subslice { .. }\n@@ -1138,7 +1133,7 @@ macro_rules! visit_place_fns {\n             location: Location,\n         ) {\n             match elem {\n-                ProjectionElem::OpaqueCast(ty) | ProjectionElem::Field(_, ty) => {\n+                ProjectionElem::Field(_field, ty) => {\n                     self.visit_ty(ty, TyContext::Location(location));\n                 }\n                 ProjectionElem::Index(local) => {"}, {"sha": "e88f9dc1f08f5bf81c1218c051399adcc561be3b", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 39, "deletions": 52, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -7,7 +7,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n@@ -72,7 +71,7 @@ pub(crate) enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-pub(in crate::build) struct PlaceBuilder<'tcx> {\n+pub(crate) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -105,8 +104,6 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 variant = Some(*idx);\n                 continue;\n             }\n-            // These do not affect anything, they just make sure we know the right type.\n-            ProjectionElem::OpaqueCast(_) => continue,\n             ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. } => {\n@@ -204,10 +201,10 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n /// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n-#[instrument(level = \"trace\", skip(cx))]\n-fn to_upvars_resolved_place_builder<'tcx>(\n+fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n-    cx: &Builder<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n@@ -222,13 +219,13 @@ fn to_upvars_resolved_place_builder<'tcx>(\n \n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n-                    cx.typeck_results,\n+                    typeck_results,\n                     var_hir_id,\n                     closure_def_id,\n                     &from_builder.projection,\n                 ) else {\n-                let closure_span = cx.tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(cx.tcx, closure_span) {\n+                let closure_span = tcx.def_span(closure_def_id);\n+                if !enable_precise_capture(tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n                             capture_disjoint_fields isn't enabled\",\n@@ -245,8 +242,8 @@ fn to_upvars_resolved_place_builder<'tcx>(\n             };\n \n             // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = cx.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-            let closure_ty = cx.typeck_results.node_type(closure_hir_id);\n+            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            let closure_ty = typeck_results.node_type(closure_hir_id);\n \n             let substs = match closure_ty.kind() {\n                 ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n@@ -273,14 +270,12 @@ fn to_upvars_resolved_place_builder<'tcx>(\n \n             // We used some of the projections to build the capture itself,\n             // now we apply the remaining to the upvar resolved place.\n-            trace!(?capture.place, ?from_builder.projection);\n             let remaining_projections = strip_prefix(\n                 capture.place.base_ty,\n                 from_builder.projection,\n                 &capture.place.projections,\n             );\n             upvar_resolved_place_builder.projection.extend(remaining_projections);\n-            trace!(?upvar_resolved_place_builder);\n \n             Ok(upvar_resolved_place_builder)\n         }\n@@ -299,21 +294,16 @@ fn strip_prefix<'tcx>(\n     prefix_projections: &[HirProjection<'tcx>],\n ) -> impl Iterator<Item = PlaceElem<'tcx>> {\n     let mut iter = projections.into_iter();\n-    let mut next = || match iter.next()? {\n-        // Filter out opaque casts, they are unnecessary in the prefix.\n-        ProjectionElem::OpaqueCast(..) => iter.next(),\n-        other => Some(other),\n-    };\n     for projection in prefix_projections {\n         match projection.kind {\n             HirProjectionKind::Deref => {\n-                assert!(matches!(next(), Some(ProjectionElem::Deref)));\n+                assert!(matches!(iter.next(), Some(ProjectionElem::Deref)));\n             }\n             HirProjectionKind::Field(..) => {\n                 if base_ty.is_enum() {\n-                    assert!(matches!(next(), Some(ProjectionElem::Downcast(..))));\n+                    assert!(matches!(iter.next(), Some(ProjectionElem::Downcast(..))));\n                 }\n-                assert!(matches!(next(), Some(ProjectionElem::Field(..))));\n+                assert!(matches!(iter.next(), Some(ProjectionElem::Field(..))));\n             }\n             HirProjectionKind::Index | HirProjectionKind::Subslice => {\n                 bug!(\"unexpected projection kind: {:?}\", projection);\n@@ -325,32 +315,24 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(crate) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n+    pub(crate) fn into_place<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> Place<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n-            let mut projections = vec![];\n-            let mut ty = PlaceTy::from_ty(cx.local_decls[local].ty);\n-            for projection in self.projection {\n-                // Only preserve those opaque casts that actually go from an opaque type\n-                // to another type.\n-                if let ProjectionElem::OpaqueCast(t) = projection {\n-                    if let ty::Opaque(..) = ty.ty.kind() {\n-                        if t != ty.ty {\n-                            projections.push(ProjectionElem::OpaqueCast(t));\n-                        }\n-                    }\n-                } else {\n-                    projections.push(projection);\n-                }\n-                ty = ty.projection_ty(cx.tcx, projection);\n-            }\n-            Place { local, projection: cx.tcx.intern_place_elems(&projections) }\n+            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.expect_upvars_resolved(cx).into_place(cx)\n+            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n         }\n     }\n \n-    fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, cx).unwrap()\n+    fn expect_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -364,11 +346,12 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(crate) fn try_upvars_resolved(\n+    pub(crate) fn try_upvars_resolved<'a>(\n         self,\n-        cx: &Builder<'_, 'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, cx)\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n@@ -428,7 +411,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -452,7 +435,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -547,7 +530,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this);\n+                    let place = place_builder.clone().into_place(this.tcx, this.typeck_results);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -699,7 +682,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self);\n+            base_place = base_place.expect_upvars_resolved(self.tcx, self.typeck_results);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -727,7 +710,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.into_place(self)));\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            len,\n+            Rvalue::Len(slice.into_place(self.tcx, self.typeck_results)),\n+        );\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,\n@@ -807,7 +795,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ProjectionElem::Field(..)\n                     | ProjectionElem::Downcast(..)\n-                    | ProjectionElem::OpaqueCast(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. } => (),\n                 }"}, {"sha": "15f2d17c4e08b2ddc45d181ea9f89d0a2c408cfa", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -321,8 +321,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n-                        let mir_place = place_builder_resolved.into_place(this);\n+                    if let Ok(place_builder_resolved) =\n+                        place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                    {\n+                        let mir_place =\n+                            place_builder_resolved.into_place(this.tcx, this.typeck_results);\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -613,7 +616,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n-                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(this);\n+                let enclosing_upvars_resolved =\n+                    arg_place_builder.clone().into_place(this.tcx, this.typeck_results);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -650,7 +654,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this);\n+        let arg_place = arg_place_builder.into_place(this.tcx, this.typeck_results);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "724b72f8769b8bc8bd460880f3a3cb90a5fc2d44", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -23,14 +23,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n+        debug!(\n+            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n+            block, temp_lifetime, expr, mutability\n+        );\n         let this = self;\n \n         let expr_span = expr.span;"}, {"sha": "017d43d10a9a917a52b5db18720d92a9f20a4f8d", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -15,13 +15,14 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n+        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n+\n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n         // just use the name `this` uniformly\n@@ -365,7 +366,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder.field(n, *ty).into_place(this),\n+                                    place_builder\n+                                        .field(n, *ty)\n+                                        .into_place(this.tcx, this.typeck_results),\n                                 )\n                             }\n                         })"}, {"sha": "7067a48b783ec24ad61e1c066db7c6120249c738", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -220,8 +220,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n-            let scrutinee_place = scrutinee_builder.into_place(self);\n+        if let Ok(scrutinee_builder) =\n+            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            let scrutinee_place = scrutinee_builder.into_place(self.tcx, self.typeck_results);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -346,10 +348,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // ```\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n+                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n+                        .clone()\n+                        .try_upvars_resolved(this.tcx, this.typeck_results)\n                     {\n-                        scrutinee_place = scrutinee_builder.into_place(this);\n+                        scrutinee_place =\n+                            scrutinee_builder.into_place(this.tcx, this.typeck_results);\n                         opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n                     }\n                     let scope = this.declare_bindings(\n@@ -598,6 +602,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n+\n+                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                    )))) = self.local_decls[local].local_info else {\n+                        bug!(\"Let binding to non-user variable.\")\n+                    };\n                     // `try_upvars_resolved` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n@@ -612,15 +622,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n-                        let place = match_pair_resolved.into_place(self);\n-\n-                        let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                            VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                        )))) = self.local_decls[local].local_info else {\n-                            bug!(\"Let binding to non-user variable.\")\n-                        };\n-\n+                    if let Ok(match_pair_resolved) =\n+                        initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                    {\n+                        let place = match_pair_resolved.into_place(self.tcx, self.typeck_results);\n                         *match_place = Some(place);\n                     }\n                 }\n@@ -649,7 +654,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    #[instrument(skip(self), level = \"debug\")]\n     pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n@@ -658,6 +662,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n+        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_primary_bindings(\n             &pattern,\n             UserTypeProjections::none(),\n@@ -867,7 +872,7 @@ impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n-            match_pairs: smallvec![MatchPair::new(place, pattern)],\n+            match_pairs: smallvec![MatchPair { place, pattern }],\n             bindings: Vec::new(),\n             ascriptions: Vec::new(),\n             subcandidates: Vec::new(),\n@@ -1043,7 +1048,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n-    #[instrument(skip(self, fake_borrows), level = \"debug\")]\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n@@ -1053,6 +1057,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n+        debug!(\n+            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n+            span, candidates, start_block, otherwise_block,\n+        );\n+\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n@@ -1371,10 +1380,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         )\n     }\n \n-    #[instrument(\n-        skip(self, otherwise, or_span, place, fake_borrows, candidate, pats),\n-        level = \"debug\"\n-    )]\n     fn test_or_pattern<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n@@ -1384,7 +1389,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\"candidate={:#?}\\npats={:#?}\", candidate, pats);\n+        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n         let mut or_candidates: Vec<_> = pats\n             .iter()\n             .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n@@ -1600,9 +1605,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self)\n+            match_place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n         {\n-            let resolved_place = match_place_resolved.into_place(self);\n+            let resolved_place = match_place_resolved.into_place(self.tcx, self.typeck_results);\n             fb.insert(resolved_place);\n         }\n \n@@ -1629,14 +1634,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n-        assert!(\n-            total_candidate_count > candidates.len(),\n-            \"{}, {:#?}\",\n-            total_candidate_count,\n-            candidates\n-        );\n-        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"untested_candidates: {}\", candidates.len());\n+        assert!(total_candidate_count > candidates.len());\n+        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -1794,8 +1794,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n         let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n-            expr_place = expr_builder.into_place(self);\n+        if let Ok(expr_builder) =\n+            expr_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            expr_place = expr_builder.into_place(self.tcx, self.typeck_results);\n             opt_expr_place = Some((Some(&expr_place), expr_span));\n         }\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n@@ -2193,7 +2195,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// first local is a binding for occurrences of `var` in the guard, which\n     /// will have type `&T`. The second local is a binding for occurrences of\n     /// `var` in the arm body, which will have type `T`.\n-    #[instrument(skip(self), level = \"debug\")]\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n@@ -2208,12 +2209,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n     ) {\n+        debug!(\n+            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n+             visibility_scope={:?}, source_info={:?})\",\n+            var_id, name, mode, var_ty, visibility_scope, source_info\n+        );\n+\n         let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n+        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n@@ -2263,7 +2271,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };\n-        debug!(?locals);\n+        debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n "}, {"sha": "c6298904140c39ef9166191ac078d9b597ba18ed", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -37,13 +37,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// only generates a single switch. If this happens this method returns\n     /// `true`.\n-    #[instrument(skip(self, candidate), level = \"debug\")]\n     pub(super) fn simplify_candidate<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n-        debug!(\"{:#?}\", candidate);\n+        debug!(?candidate, \"simplify_candidate\");\n \n         // existing_bindings and new_bindings exists to keep the semantics in order.\n         // Reversing the binding order for bindings after `@` changes the binding order in places\n@@ -156,10 +155,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Ok(place_resolved) =\n+                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self),\n+                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n                         variance,\n                     });\n                 }\n@@ -183,10 +184,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Ok(place_resolved) =\n+                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self),\n+                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "598da80c574aff45ba7d4684fb4d307c86f16dd0", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -144,7 +144,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self, make_target_blocks, place_builder), level = \"debug\")]\n     pub(super) fn perform_test(\n         &mut self,\n         match_start_span: Span,\n@@ -154,9 +153,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place = place_builder.into_place(self);\n-        let place_ty = place.ty(&self.local_decls, self.tcx);\n-        debug!(?place, ?place_ty,);\n+        let place: Place<'tcx>;\n+        if let Ok(test_place_builder) =\n+            place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            place = test_place_builder.into_place(self.tcx, self.typeck_results);\n+        } else {\n+            return;\n+        }\n+        debug!(\n+            \"perform_test({:?}, {:?}: {:?}, {:?})\",\n+            block,\n+            place,\n+            place.ty(&self.local_decls, self.tcx),\n+            test\n+        );\n \n         let source_info = self.source_info(test.span);\n         match test.kind {\n@@ -724,7 +735,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n+        let elem =\n+            ProjectionElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index);\n+        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n             let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);"}, {"sha": "9a1e98d3bb18ddc8d6b6e646a1de00610ae4ae33", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -31,15 +31,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) =\n-            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n-                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n-                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-                }\n-            } else {\n-                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-            };\n+        let (min_length, exact_size) = if let Ok(place_resolved) =\n+            place.clone().try_upvars_resolved(tcx, self.typeck_results)\n+        {\n+            match place_resolved\n+                .into_place(tcx, self.typeck_results)\n+                .ty(&self.local_decls, tcx)\n+                .ty\n+                .kind()\n+            {\n+                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+            }\n+        } else {\n+            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+        };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n@@ -94,14 +100,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub(in crate::build) fn new(\n+    pub(crate) fn new(\n         place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {\n-        // Force the place type to the pattern's type.\n-        // FIXME(oli-obk): only do this when we don't already know the place type.\n-        // FIXME(oli-obk): can we use this to simplify slice/array pattern hacks?\n-        let place = place.project(ProjectionElem::OpaqueCast(pattern.ty));\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "b9fd8c50e6a047fb593411dfc8b07afa23b591e9", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -553,7 +553,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    #[instrument(skip(self, f), level = \"debug\")]\n     pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n@@ -563,6 +562,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n+        debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n         let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n         self.source_scope = source_scope;\n-        debug!(?block);\n+        debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n         block.and(rv)\n     }\n "}, {"sha": "4eb3607e9cca0e914138c344bb39fb2e1691c469", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -48,8 +48,6 @@ impl<'tcx> Cx<'tcx> {\n             _ => None,\n         };\n \n-        trace!(?expr.ty);\n-\n         // Now apply adjustments, if any.\n         for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             trace!(?expr, ?adjustment);\n@@ -58,8 +56,6 @@ impl<'tcx> Cx<'tcx> {\n                 self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n         }\n \n-        trace!(?expr.ty, \"after adjustments\");\n-\n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,"}, {"sha": "60db98073a3b91776504b854718a6f88ffb494ad", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1202,32 +1202,35 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n     /// Creates a new list of wildcard fields for a given constructor. The result must have a\n     /// length of `constructor.arity()`.\n-    #[instrument(level = \"trace\")]\n-    pub(super) fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n+    pub(super) fn wildcards(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        constructor: &Constructor<'tcx>,\n+    ) -> Self {\n         let ret = match constructor {\n-            Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n+            Single | Variant(_) => match ty.kind() {\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n-                        let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(pcx.cx, tys)\n+                        Fields::wildcards_from_tys(cx, tys)\n                     }\n                 }\n-                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n             },\n-            Slice(slice) => match *pcx.ty.kind() {\n+            Slice(slice) => match *ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n                 }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n             Str(..)\n             | FloatRange(..)\n@@ -1240,7 +1243,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n             }\n         };\n-        debug!(?ret);\n+        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n     }\n \n@@ -1283,7 +1286,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx, &ctor);\n+        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }\n \n@@ -1550,13 +1553,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n     pub(super) fn specialize<'a>(\n         &'a self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n     ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Fields::wildcards(pcx, other_ctor).iter_patterns().collect()\n+                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n@@ -1575,7 +1578,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n                         let wildcard: &_ =\n-                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "a13748a2d474ad1b92e74f24de438222379b376b", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -196,7 +196,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n "}, {"sha": "9e7a267ecbd7fc86dd9d057324d9595f21ac5b74", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -411,12 +411,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn pop_head_constructor(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(pcx, ctor);\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -475,7 +475,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head().ctor()) {\n-                let new_row = row.pop_head_constructor(pcx, ctor);\n+                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -786,7 +786,7 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n-    debug!(?matrix, ?v);\n+    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -806,6 +806,11 @@ fn is_useful<'p, 'tcx>(\n \n     debug_assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    let ty = v.head().ty();\n+    let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+    debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n+    let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n+\n     // If the first pattern is an or-pattern, expand it.\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n     if v.head().is_or_pat() {\n@@ -827,19 +832,6 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n-        let mut ty = v.head().ty();\n-\n-        // Opaque types can't get destructured/split, but the patterns can\n-        // actually hint at hidden types, so we use the patterns' types instead.\n-        if let ty::Opaque(..) = v.head().ty().kind() {\n-            if let Some(row) = rows.first() {\n-                ty = row.head().ty();\n-            }\n-        }\n-        let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n-        debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n-        let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n-\n         let v_ctor = v.head().ctor();\n         debug!(?v_ctor);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n@@ -861,7 +853,7 @@ fn is_useful<'p, 'tcx>(\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n-            let v = v.pop_head_constructor(pcx, &ctor);\n+            let v = v.pop_head_constructor(cx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });"}, {"sha": "28936274baafa639614b7aa547c37859c8a0b8aa", "filename": "compiler/rustc_mir_dataflow/src/move_paths/abs_domain.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -48,7 +48,6 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n         match *self {\n             ProjectionElem::Deref => ProjectionElem::Deref,\n             ProjectionElem::Field(f, ty) => ProjectionElem::Field(f, ty.lift()),\n-            ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty.lift()),\n             ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n             ProjectionElem::Subslice { from, to, from_end } => {\n                 ProjectionElem::Subslice { from, to, from_end }"}, {"sha": "b91ae083cf594e10bec90714a67d525407592139", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -28,7 +28,6 @@ fn is_stable(place: PlaceRef<'_>) -> bool {\n             ProjectionElem::Field { .. } |\n             ProjectionElem::ConstantIndex { .. } |\n             ProjectionElem::Subslice { .. } |\n-            ProjectionElem::OpaqueCast { .. } |\n             ProjectionElem::Downcast { .. } => true,\n         }\n     })"}, {"sha": "811832848d9dd24f5206e3d160841e4fee7af808", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1,9 +1,8 @@\n // compile-flags: --edition=2021\n-// check-pass\n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy;\n+    type T = impl Copy; //~ ERROR unconstrained opaque type\n     let foo: T = (1u32, 2u32);\n     let (a, b): (u32, u32) = foo;\n }"}, {"sha": "03b172e6de5706f8dcf6e1c38e289bed1df6f022", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained opaque type\n+  --> $DIR/cross_inference_pattern_bug.rs:5:14\n+   |\n+LL |     type T = impl Copy;\n+   |              ^^^^^^^^^\n+   |\n+   = note: `T` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to previous error\n+"}, {"sha": "328096d44b4b506161d68defef2d878e87bfb0bc", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -1,13 +1,13 @@\n+// known-bug: #96572\n // compile-flags: --edition=2021 --crate-type=lib\n // rustc-env:RUST_BACKTRACE=0\n-// check-pass\n \n // tracked in https://github.com/rust-lang/rust/issues/96572\n \n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy;\n+    type T = impl Copy;  // error: unconstrained opaque type\n     let foo: T = (1u32, 2u32);\n-    let (a, b) = foo; // this line used to make the code fail\n+    let (a, b) = foo; // removing this line makes the code compile\n }"}, {"sha": "8aa1f495639951ff05e51d906d728a69dd8fd9bf", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained opaque type\n+  --> $DIR/cross_inference_pattern_bug_no_type.rs:10:14\n+   |\n+LL |     type T = impl Copy;  // error: unconstrained opaque type\n+   |              ^^^^^^^^^\n+   |\n+   = note: `T` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to previous error\n+"}, {"sha": "825710851b01f0dcab6c8bdb7cdd1f6fd9f916da", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,10 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-fn main() {\n-    type T = impl Copy;\n-    let foo: T = Some((1u32, 2u32));\n-    match foo {\n-        None => (),\n-        Some((a, b, c)) => (), //~ ERROR mismatched types\n-    }\n-}"}, {"sha": "728244a1844dbe8eccb6b8143e1966218814d372", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,15 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-96572-unconstrained-mismatch.rs:8:14\n-   |\n-LL |     match foo {\n-   |           --- this expression has type `T`\n-LL |         None => (),\n-LL |         Some((a, b, c)) => (),\n-   |              ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n-   |\n-   = note: expected tuple `(u32, u32)`\n-              found tuple `(_, _, _)`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c0a371eca1c6feaa6945cbf5ce8cc01a97a00cde", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern-rpit.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,29 +0,0 @@\n-// check-pass\n-\n-#[allow(unconditional_recursion)]\n-fn foo(b: bool) -> impl Copy {\n-    let (mut x, mut y) = foo(false);\n-    x = 42;\n-    y = \"foo\";\n-    if b {\n-        panic!()\n-    } else {\n-        foo(true)\n-    }\n-}\n-\n-fn bar(b: bool) -> Option<impl Copy> {\n-    if b {\n-        return None;\n-    }\n-    match bar(!b) {\n-        Some((mut x, mut y)) => {\n-            x = 42;\n-            y = \"foo\";\n-        }\n-        None => {}\n-    }\n-    None\n-}\n-\n-fn main() {}"}, {"sha": "ec249958590f1ce12549e07194c661fe15d6e8ff", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,24 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-// check-pass\n-\n-type T = impl Copy;\n-\n-fn foo(foo: T) {\n-    let (mut x, mut y) = foo;\n-    x = 42;\n-    y = \"foo\";\n-}\n-\n-type U = impl Copy;\n-\n-fn bar(bar: Option<U>) {\n-    match bar {\n-        Some((mut x, mut y)) => {\n-            x = 42;\n-            y = \"foo\";\n-        }\n-        None => {}\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "3351d9bcff1f88db8113b98edae332981fb41fff", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-struct.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,11 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-// check-pass\n-\n-#[derive(Copy, Clone)]\n-struct Foo((u32, u32));\n-\n-fn main() {\n-    type U = impl Copy;\n-    let foo: U = Foo((1u32, 2u32));\n-    let Foo((a, b)) = foo;\n-}"}, {"sha": "ef3279a98d199f1cd2ca4115f2e06d7e362f1b05", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-upvar-enum.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,13 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-// check-pass\n-\n-fn main() {\n-    type T = impl Copy;\n-    let foo: T = Some((1u32, 2u32));\n-    let x = move || {\n-        match foo {\n-            None => (),\n-            Some((a, b)) => (),\n-        }\n-    };\n-}"}, {"sha": "bb0fc7c7534f5cec459993187a9f338378f99962", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-upvar.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,13 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-// check-pass\n-\n-#[derive(Copy, Clone)]\n-struct Foo((u32, u32));\n-\n-fn main() {\n-    type T = impl Copy;\n-    let foo: T = Foo((1u32, 2u32));\n-    let x = move || {\n-        let Foo((a, b)) = foo;\n-    };\n-}"}, {"sha": "4b9ed7f28eb3f3ca621f63dd1e98b54f48eaa8ee", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d488b48af9f66b91e9400387f781b82411fa82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs?ref=03d488b48af9f66b91e9400387f781b82411fa82", "patch": "@@ -1,11 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-// check-pass\n-\n-fn main() {\n-    type T = impl Copy;\n-    let foo: T = Some((1u32, 2u32));\n-    match foo {\n-        None => (),\n-        Some((a, b)) => (),\n-    }\n-}"}, {"sha": "3bf75bcbee83e85d779b96ba2478d91b76d96450", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a742a691e7dd2522bad68b86fe2fd5a199d5561/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=4a742a691e7dd2522bad68b86fe2fd5a199d5561", "patch": "@@ -252,7 +252,6 @@ fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &B\n                 }\n             },\n             ProjectionElem::ConstantIndex { .. }\n-            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref"}]}