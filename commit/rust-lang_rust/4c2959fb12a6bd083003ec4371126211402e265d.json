{"sha": "4c2959fb12a6bd083003ec4371126211402e265d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMjk1OWZiMTJhNmJkMDgzMDAzZWM0MzcxMTI2MjExNDAyZTI2NWQ=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-07-18T08:44:39Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-07-26T03:53:32Z"}, "message": "fix a bunch of clippy warnings\n\nclippy::bind_instead_of_map\nclippy::branches_sharing_code\nclippy::collapsible_match\nclippy::inconsistent_struct_constructor\nclippy::int_plus_one\nclippy::iter_count\nclippy::iter_nth_zero\nclippy::manual_range_contains\nclippy::match_like_matches_macro\nclippy::needless::collect\nclippy::needless_question_mark\nclippy::needless_return\nclippy::op_ref\nclippy::option_as_ref_deref\nclippy::ptr_arg\nclippy::redundant_clone\nclippy::redundant_closure\nclippy::redundant_static_lifetimes\nclippy::search_is_some\nclippy::#single_char_add_str\nclippy::single_char_pattern\nclippy::single_component_path_imports\nclippy::single_match\nclippy::skip_while_next\nclippy::unnecessary_lazy_evaluations\nclippy::unnecessary_unwrap\nclippy::useless_conversion\nclippy::useless_format", "tree": {"sha": "191d301fa9083fcd42a08fabc8e8dc73e565fba9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/191d301fa9083fcd42a08fabc8e8dc73e565fba9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c2959fb12a6bd083003ec4371126211402e265d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2959fb12a6bd083003ec4371126211402e265d", "html_url": "https://github.com/rust-lang/rust/commit/4c2959fb12a6bd083003ec4371126211402e265d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c2959fb12a6bd083003ec4371126211402e265d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cf280ed1ba84001aa4e14152ae37cea18ebcb1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf280ed1ba84001aa4e14152ae37cea18ebcb1c", "html_url": "https://github.com/rust-lang/rust/commit/2cf280ed1ba84001aa4e14152ae37cea18ebcb1c"}], "stats": {"total": 335, "additions": 130, "deletions": 205}, "files": [{"sha": "315eb10a9dbc0eeb5f720949cf0b0d6b95d75f7a", "filename": "src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -183,7 +183,7 @@ fn format_derive(\n     } else if let SeparatorTactic::Always = context.config.trailing_comma() {\n         // Retain the trailing comma.\n         result.push_str(&item_str);\n-    } else if item_str.ends_with(\",\") {\n+    } else if item_str.ends_with(',') {\n         // Remove the trailing comma.\n         result.push_str(&item_str[..item_str.len() - 1]);\n     } else {"}, {"sha": "ba693e852ffa66358bf9f919b3324cdb4f2f2ffd", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -405,8 +405,8 @@ fn get_targets_recursive(\n                 .packages\n                 .iter()\n                 .find(|p| p.name == dependency.name && p.source.is_none());\n-            let manifest_path = if dependency_package.is_some() {\n-                PathBuf::from(&dependency_package.unwrap().manifest_path)\n+            let manifest_path = if let Some(dep_pkg) = dependency_package {\n+                PathBuf::from(&dep_pkg.manifest_path)\n             } else {\n                 let mut package_manifest_path = PathBuf::from(&package.manifest_path);\n                 package_manifest_path.pop();"}, {"sha": "614638ea2abfbea7c4096c9cf5443bb7afe17041", "filename": "src/chains.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -231,10 +231,7 @@ impl ChainItem {\n     }\n \n     fn is_comment(&self) -> bool {\n-        match self.kind {\n-            ChainItemKind::Comment(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, ChainItemKind::Comment(..))\n     }\n \n     fn rewrite_method_call("}, {"sha": "c9d46aef294a0df562df28960531048d9a431c66", "filename": "src/closures.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -336,23 +336,23 @@ pub(crate) fn rewrite_last_closure(\n \n         // We force to use block for the body of the closure for certain kinds of expressions.\n         if is_block_closure_forced(context, body) {\n-            return rewrite_closure_with_block(body, &prefix, context, body_shape).and_then(\n+            return rewrite_closure_with_block(body, &prefix, context, body_shape).map(\n                 |body_str| {\n                     match fn_decl.output {\n                         ast::FnRetTy::Default(..) if body_str.lines().count() <= 7 => {\n                             // If the expression can fit in a single line, we need not force block\n                             // closure.  However, if the closure has a return type, then we must\n                             // keep the blocks.\n                             match rewrite_closure_expr(body, &prefix, context, shape) {\n-                                Some(ref single_line_body_str)\n+                                Some(single_line_body_str)\n                                     if !single_line_body_str.contains('\\n') =>\n                                 {\n-                                    Some(single_line_body_str.clone())\n+                                    single_line_body_str\n                                 }\n-                                _ => Some(body_str),\n+                                _ => body_str,\n                             }\n                         }\n-                        _ => Some(body_str),\n+                        _ => body_str,\n                     }\n                 },\n             );\n@@ -377,10 +377,7 @@ pub(crate) fn rewrite_last_closure(\n pub(crate) fn args_have_many_closure(args: &[OverflowableItem<'_>]) -> bool {\n     args.iter()\n         .filter_map(OverflowableItem::to_expr)\n-        .filter(|expr| match expr.kind {\n-            ast::ExprKind::Closure(..) => true,\n-            _ => false,\n-        })\n+        .filter(|expr| matches!(expr.kind, ast::ExprKind::Closure(..)))\n         .count()\n         > 1\n }"}, {"sha": "0f8118a408ec007efca529e03ffba4ff90aceeee", "filename": "src/comment.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -67,10 +67,7 @@ impl<'a> CommentStyle<'a> {\n \n     /// Returns `true` if the commenting style is for documentation.\n     pub(crate) fn is_doc_comment(&self) -> bool {\n-        match *self {\n-            CommentStyle::TripleSlash | CommentStyle::Doc => true,\n-            _ => false,\n-        }\n+        matches!(*self, CommentStyle::TripleSlash | CommentStyle::Doc)\n     }\n \n     pub(crate) fn opener(&self) -> &'a str {\n@@ -689,8 +686,8 @@ impl<'a> CommentRewrite<'a> {\n \n         self.code_block_attr = None;\n         self.item_block = None;\n-        if line.starts_with(\"```\") {\n-            self.code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n+        if let Some(stripped) = line.strip_prefix(\"```\") {\n+            self.code_block_attr = Some(CodeBlockAttribute::new(stripped))\n         } else if self.fmt.config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n             let ib = ItemizedBlock::new(&line);\n             self.item_block = Some(ib);\n@@ -948,8 +945,8 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle<'_>) -> (&'a s\n     {\n         (&line[4..], true)\n     } else if let CommentStyle::Custom(opener) = *style {\n-        if line.starts_with(opener) {\n-            (&line[opener.len()..], true)\n+        if let Some(ref stripped) = line.strip_prefix(opener) {\n+            (stripped, true)\n         } else {\n             (&line[opener.trim_end().len()..], false)\n         }\n@@ -968,8 +965,8 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle<'_>) -> (&'a s\n         || line.starts_with(\"**\")\n     {\n         (&line[2..], line.chars().nth(1).unwrap() == ' ')\n-    } else if line.starts_with('*') {\n-        (&line[1..], false)\n+    } else if let Some(stripped) = line.strip_prefix('*') {\n+        (stripped, false)\n     } else {\n         (line, line.starts_with(' '))\n     }\n@@ -1682,8 +1679,8 @@ impl<'a> Iterator for CommentReducer<'a> {\n fn remove_comment_header(comment: &str) -> &str {\n     if comment.starts_with(\"///\") || comment.starts_with(\"//!\") {\n         &comment[3..]\n-    } else if comment.starts_with(\"//\") {\n-        &comment[2..]\n+    } else if let Some(ref stripped) = comment.strip_prefix(\"//\") {\n+        stripped\n     } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\"))\n         || comment.starts_with(\"/*!\")\n     {"}, {"sha": "4b799780d85d964e528246b4fe934e9da527ee84", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -305,7 +305,7 @@ impl str::FromStr for FileLines {\n         let mut m = HashMap::new();\n         for js in v {\n             let (s, r) = JsonSpan::into_tuple(js)?;\n-            m.entry(s).or_insert_with(|| vec![]).push(r);\n+            m.entry(s).or_insert_with(Vec::new).push(r);\n         }\n         Ok(FileLines::from_ranges(m))\n     }\n@@ -322,7 +322,7 @@ impl JsonSpan {\n     fn into_tuple(self) -> Result<(FileName, Range), FileLinesError> {\n         let (lo, hi) = self.range;\n         let canonical = canonicalize_path_string(&self.file)\n-            .ok_or_else(|| FileLinesError::CannotCanonicalize(self.file))?;\n+            .ok_or(FileLinesError::CannotCanonicalize(self.file))?;\n         Ok((canonical, Range::new(lo, hi)))\n     }\n }"}, {"sha": "c7feb502ea91e5786790aaf0c2f46d12eabd0207", "filename": "src/config/license.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -3,7 +3,6 @@ use std::fs::File;\n use std::io;\n use std::io::Read;\n \n-use regex;\n use regex::Regex;\n \n #[derive(Debug)]"}, {"sha": "2fbbfedb566d13cbe1bb657685de4cd1fa6cd71e", "filename": "src/emitter/diff.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Femitter%2Fdiff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Femitter%2Fdiff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Femitter%2Fdiff.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -45,7 +45,7 @@ impl Emitter for DiffEmitter {\n             return Ok(EmitterResult { has_diff: true });\n         }\n \n-        return Ok(EmitterResult { has_diff });\n+        Ok(EmitterResult { has_diff })\n     }\n }\n "}, {"sha": "6cfeb9977a966a4a1d2783662027f2a460826854", "filename": "src/expr.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -263,15 +263,12 @@ pub(crate) fn format_expr(\n             }\n \n             fn needs_space_after_range(rhs: &ast::Expr) -> bool {\n-                match rhs.kind {\n-                    // Don't format `.. ..` into `....`, which is invalid.\n-                    //\n-                    // This check is unnecessary for `lhs`, because a range\n-                    // starting from another range needs parentheses as `(x ..) ..`\n-                    // (`x .. ..` is a range from `x` to `..`).\n-                    ast::ExprKind::Range(None, _, _) => true,\n-                    _ => false,\n-                }\n+                // Don't format `.. ..` into `....`, which is invalid.\n+                //\n+                // This check is unnecessary for `lhs`, because a range\n+                // starting from another range needs parentheses as `(x ..) ..`\n+                // (`x .. ..` is a range from `x` to `..`).\n+                matches!(rhs.kind, ast::ExprKind::Range(None, _, _))\n             }\n \n             let default_sp_delim = |lhs: Option<&ast::Expr>, rhs: Option<&ast::Expr>| {\n@@ -531,7 +528,7 @@ pub(crate) fn rewrite_block_with_visitor(\n \n     let inner_attrs = attrs.map(inner_attributes);\n     let label_str = rewrite_label(label);\n-    visitor.visit_block(block, inner_attrs.as_ref().map(|a| &**a), has_braces);\n+    visitor.visit_block(block, inner_attrs.as_deref(), has_braces);\n     let visitor_context = visitor.get_context();\n     context\n         .skipped_range\n@@ -595,7 +592,7 @@ pub(crate) fn rewrite_cond(\n                 String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n             control_flow\n                 .rewrite_cond(context, shape, &alt_block_sep)\n-                .and_then(|rw| Some(rw.0))\n+                .map(|rw| rw.0)\n         }),\n     }\n }\n@@ -1157,18 +1154,11 @@ pub(crate) fn is_empty_block(\n }\n \n pub(crate) fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n-    match stmt.kind {\n-        ast::StmtKind::Expr(..) => true,\n-        _ => false,\n-    }\n+    matches!(stmt.kind, ast::StmtKind::Expr(..))\n }\n \n pub(crate) fn is_unsafe_block(block: &ast::Block) -> bool {\n-    if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(block.rules, ast::BlockCheckMode::Unsafe(..))\n }\n \n pub(crate) fn rewrite_literal("}, {"sha": "97c4fc16d6f5d2aa382a41ff9a0e3f89dadb7580", "filename": "src/formatting/newline_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fformatting%2Fnewline_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fformatting%2Fnewline_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting%2Fnewline_style.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -77,7 +77,7 @@ fn convert_to_windows_newlines(formatted_text: &String) -> String {\n     transformed\n }\n \n-fn convert_to_unix_newlines(formatted_text: &String) -> String {\n+fn convert_to_unix_newlines(formatted_text: &str) -> String {\n     formatted_text.replace(WINDOWS_NEWLINE, UNIX_NEWLINE)\n }\n "}, {"sha": "64d78605f0c5f7be90d706fc43a40a25f2df57f5", "filename": "src/imports.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -374,7 +374,7 @@ impl UseTree {\n             UseTreeKind::Nested(ref list) => {\n                 // Extract comments between nested use items.\n                 // This needs to be done before sorting use items.\n-                let items: Vec<_> = itemize_list(\n+                let items = itemize_list(\n                     context.snippet_provider,\n                     list.iter().map(|(tree, _)| tree),\n                     \"}\",\n@@ -385,16 +385,16 @@ impl UseTree {\n                     context.snippet_provider.span_after(a.span, \"{\"),\n                     a.span.hi(),\n                     false,\n-                )\n-                .collect();\n+                );\n+\n                 // in case of a global path and the nested list starts at the root,\n                 // e.g., \"::{foo, bar}\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n                     result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n                 }\n                 result.path.push(UseSegment::List(\n                     list.iter()\n-                        .zip(items.into_iter())\n+                        .zip(items)\n                         .map(|(t, list_item)| {\n                             Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n                         })\n@@ -466,11 +466,8 @@ impl UseTree {\n \n         // Normalise foo::self as bar -> foo as bar.\n         if let UseSegment::Slf(_) = last {\n-            match self.path.last() {\n-                Some(UseSegment::Ident(_, None)) => {\n-                    aliased_self = true;\n-                }\n-                _ => {}\n+            if let Some(UseSegment::Ident(_, None)) = self.path.last() {\n+                aliased_self = true;\n             }\n         }\n \n@@ -572,9 +569,8 @@ impl UseTree {\n         match self.path.clone().last().unwrap() {\n             UseSegment::List(list) => {\n                 if list.len() == 1 && list[0].path.len() == 1 {\n-                    match list[0].path[0] {\n-                        UseSegment::Slf(..) => return vec![self],\n-                        _ => (),\n+                    if let UseSegment::Slf(..) = list[0].path[0] {\n+                        return vec![self];\n                     };\n                 }\n                 let prefix = &self.path[..self.path.len() - 1];\n@@ -790,13 +786,9 @@ fn rewrite_nested_use_tree(\n         }\n     }\n     let has_nested_list = use_tree_list.iter().any(|use_segment| {\n-        use_segment\n-            .path\n-            .last()\n-            .map_or(false, |last_segment| match last_segment {\n-                UseSegment::List(..) => true,\n-                _ => false,\n-            })\n+        use_segment.path.last().map_or(false, |last_segment| {\n+            matches!(last_segment, UseSegment::List(..))\n+        })\n     });\n \n     let remaining_width = if has_nested_list {"}, {"sha": "33fb5522aeae53e757fd244592e9d90a678208fc", "filename": "src/issues.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -126,11 +126,7 @@ impl BadIssueSeeker {\n                     return Seeking::Number {\n                         issue: Issue {\n                             issue_type: IssueType::Todo,\n-                            missing_number: if let ReportTactic::Unnumbered = self.report_todo {\n-                                true\n-                            } else {\n-                                false\n-                            },\n+                            missing_number: matches!(self.report_todo, ReportTactic::Unnumbered),\n                         },\n                         part: NumberPart::OpenParen,\n                     };\n@@ -144,11 +140,7 @@ impl BadIssueSeeker {\n                     return Seeking::Number {\n                         issue: Issue {\n                             issue_type: IssueType::Fixme,\n-                            missing_number: if let ReportTactic::Unnumbered = self.report_fixme {\n-                                true\n-                            } else {\n-                                false\n-                            },\n+                            missing_number: matches!(self.report_fixme, ReportTactic::Unnumbered),\n                         },\n                         part: NumberPart::OpenParen,\n                     };\n@@ -196,7 +188,7 @@ impl BadIssueSeeker {\n                 }\n             }\n             NumberPart::Number => {\n-                if c >= '0' && c <= '9' {\n+                if ('0'..='9').contains(&c) {\n                     part = NumberPart::CloseParen;\n                 } else {\n                     return IssueClassification::Bad(issue);"}, {"sha": "0542358c6e7c5ebb40e15055364449df2caae79c", "filename": "src/items.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -741,7 +741,7 @@ pub(crate) fn format_impl(\n                 // there is only one where-clause predicate\n                 // recover the suppressed comma in single line where_clause formatting\n                 if generics.where_clause.predicates.len() == 1 {\n-                    result.push_str(\",\");\n+                    result.push(',');\n                 }\n                 result.push_str(&format!(\"{}{{{}}}\", sep, sep));\n             } else {\n@@ -1207,7 +1207,7 @@ impl<'a> Rewrite for TraitAliasBounds<'a> {\n \n         let fits_single_line = !generic_bounds_str.contains('\\n')\n             && !where_str.contains('\\n')\n-            && generic_bounds_str.len() + where_str.len() + 1 <= shape.width;\n+            && generic_bounds_str.len() + where_str.len() < shape.width;\n         let space = if generic_bounds_str.is_empty() || where_str.is_empty() {\n             Cow::from(\"\")\n         } else if fits_single_line {\n@@ -1236,8 +1236,8 @@ pub(crate) fn format_trait_alias(\n     let lhs = format!(\"{}trait {} =\", vis_str, generics_str);\n     // 1 = \";\"\n     let trait_alias_bounds = TraitAliasBounds {\n-        generics,\n         generic_bounds,\n+        generics,\n     };\n     rewrite_assign_rhs(context, lhs, &trait_alias_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n@@ -1993,7 +1993,7 @@ impl Rewrite for ast::Param {\n             let num_attrs = self.attrs.len();\n             (\n                 mk_sp(self.attrs[num_attrs - 1].span.hi(), self.pat.span.lo()),\n-                param_attrs_result.contains(\"\\n\"),\n+                param_attrs_result.contains('\\n'),\n             )\n         } else {\n             (mk_sp(self.span.lo(), self.span.lo()), false)\n@@ -3265,22 +3265,16 @@ pub(crate) fn rewrite_extern_crate(\n \n /// Returns `true` for `mod foo;`, false for `mod foo { .. }`.\n pub(crate) fn is_mod_decl(item: &ast::Item) -> bool {\n-    match item.kind {\n-        ast::ItemKind::Mod(_, ast::ModKind::Loaded(_, ast::Inline::Yes, _)) => false,\n-        _ => true,\n-    }\n+    !matches!(\n+        item.kind,\n+        ast::ItemKind::Mod(_, ast::ModKind::Loaded(_, ast::Inline::Yes, _))\n+    )\n }\n \n pub(crate) fn is_use_item(item: &ast::Item) -> bool {\n-    match item.kind {\n-        ast::ItemKind::Use(_) => true,\n-        _ => false,\n-    }\n+    matches!(item.kind, ast::ItemKind::Use(_))\n }\n \n pub(crate) fn is_extern_crate(item: &ast::Item) -> bool {\n-    match item.kind {\n-        ast::ItemKind::ExternCrate(..) => true,\n-        _ => false,\n-    }\n+    matches!(item.kind, ast::ItemKind::ExternCrate(..))\n }"}, {"sha": "eb314e63de3684225954929d36e945535e36510a", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -30,7 +30,6 @@ use std::panic;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n-use ignore;\n use rustc_ast::ast;\n use rustc_span::{symbol, DUMMY_SP};\n use thiserror::Error;\n@@ -149,10 +148,7 @@ pub enum ErrorKind {\n \n impl ErrorKind {\n     fn is_comment(&self) -> bool {\n-        match self {\n-            ErrorKind::LostComment => true,\n-            _ => false,\n-        }\n+        matches!(self, ErrorKind::LostComment)\n     }\n }\n "}, {"sha": "73e886c55637e1d01073409c361a0151349e85ab", "filename": "src/lists.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -194,10 +194,7 @@ impl ListItem {\n     // Returns `true` if the item causes something to be written.\n     fn is_substantial(&self) -> bool {\n         fn empty(s: &Option<String>) -> bool {\n-            match *s {\n-                Some(ref s) if !s.is_empty() => false,\n-                _ => true,\n-            }\n+            !matches!(*s, Some(ref s) if !s.is_empty())\n         }\n \n         !(empty(&self.pre_comment) && empty(&self.item) && empty(&self.post_comment))\n@@ -618,8 +615,8 @@ pub(crate) fn extract_post_comment(\n     let post_snippet = post_snippet[..comment_end].trim();\n     let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n         post_snippet[1..].trim_matches(white_space)\n-    } else if post_snippet.starts_with(separator) {\n-        post_snippet[separator.len()..].trim_matches(white_space)\n+    } else if let Some(stripped) = post_snippet.strip_prefix(separator) {\n+        stripped.trim_matches(white_space)\n     }\n     // not comment or over two lines\n     else if post_snippet.ends_with(',')\n@@ -823,7 +820,7 @@ where\n pub(crate) fn total_item_width(item: &ListItem) -> usize {\n     comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..]))\n         + comment_len(item.post_comment.as_ref().map(|x| &(*x)[..]))\n-        + &item.item.as_ref().map_or(0, |s| unicode_str_width(&s))\n+        + item.item.as_ref().map_or(0, |s| unicode_str_width(&s))\n }\n \n fn comment_len(comment: Option<&str>) -> usize {"}, {"sha": "6c5e32716c017a61e12530f86826819fb693db83", "filename": "src/macros.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -179,10 +179,10 @@ fn return_macro_parse_failure_fallback(\n         .lines()\n         .last()\n         .map(|closing_line| {\n-            closing_line.trim().chars().all(|ch| match ch {\n-                '}' | ')' | ']' => true,\n-                _ => false,\n-            })\n+            closing_line\n+                .trim()\n+                .chars()\n+                .all(|ch| matches!(ch, '}' | ')' | ']'))\n         })\n         .unwrap_or(false);\n     if is_like_block_indent_style {\n@@ -690,25 +690,22 @@ fn delim_token_to_str(\n \n impl MacroArgKind {\n     fn starts_with_brace(&self) -> bool {\n-        match *self {\n+        matches!(\n+            *self,\n             MacroArgKind::Repeat(DelimToken::Brace, _, _, _)\n-            | MacroArgKind::Delimited(DelimToken::Brace, _) => true,\n-            _ => false,\n-        }\n+                | MacroArgKind::Delimited(DelimToken::Brace, _)\n+        )\n     }\n \n     fn starts_with_dollar(&self) -> bool {\n-        match *self {\n-            MacroArgKind::Repeat(..) | MacroArgKind::MetaVariable(..) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            *self,\n+            MacroArgKind::Repeat(..) | MacroArgKind::MetaVariable(..)\n+        )\n     }\n \n     fn ends_with_space(&self) -> bool {\n-        match *self {\n-            MacroArgKind::Separator(..) => true,\n-            _ => false,\n-        }\n+        matches!(*self, MacroArgKind::Separator(..))\n     }\n \n     fn has_meta_var(&self) -> bool {\n@@ -1162,10 +1159,10 @@ fn force_space_before(tok: &TokenKind) -> bool {\n }\n \n fn ident_like(tok: &Token) -> bool {\n-    match tok.kind {\n-        TokenKind::Ident(..) | TokenKind::Literal(..) | TokenKind::Lifetime(_) => true,\n-        _ => false,\n-    }\n+    matches!(\n+        tok.kind,\n+        TokenKind::Ident(..) | TokenKind::Literal(..) | TokenKind::Lifetime(_)\n+    )\n }\n \n fn next_space(tok: &TokenKind) -> SpaceState {\n@@ -1399,7 +1396,7 @@ impl MacroBranch {\n         // Undo our replacement of macro variables.\n         // FIXME: this could be *much* more efficient.\n         for (old, new) in &substs {\n-            if old_body.find(new).is_some() {\n+            if old_body.contains(new) {\n                 debug!(\"rewrite_macro_def: bailing matching variable: `{}`\", new);\n                 return None;\n             }"}, {"sha": "263d840785a2953468f42a976058d8490c4a7f53", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -230,8 +230,7 @@ impl<'a> FmtVisitor<'a> {\n         let last_char = big_snippet\n             .chars()\n             .rev()\n-            .skip_while(|rev_c| [' ', '\\t'].contains(rev_c))\n-            .next();\n+            .find(|rev_c| ![' ', '\\t'].contains(rev_c));\n \n         let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n         let mut on_same_line = false;\n@@ -262,7 +261,7 @@ impl<'a> FmtVisitor<'a> {\n         let comment_shape = Shape::legacy(comment_width, comment_indent);\n \n         if on_same_line {\n-            match subslice.find(\"\\n\") {\n+            match subslice.find('\\n') {\n                 None => {\n                     self.push_str(subslice);\n                 }\n@@ -299,8 +298,7 @@ impl<'a> FmtVisitor<'a> {\n             match snippet[status.line_start..]\n                 .chars()\n                 // skip trailing whitespaces\n-                .skip_while(|c| *c == ' ' || *c == '\\t')\n-                .next()\n+                .find(|c| !(*c == ' ' || *c == '\\t'))\n             {\n                 Some('\\n') | Some('\\r') => {\n                     if !is_last_comment_block(subslice) {"}, {"sha": "e32213467a51f8f2ee08053135a59e9c3c8c2c5a", "filename": "src/overflow.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -126,21 +126,19 @@ impl<'a> OverflowableItem<'a> {\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n             OverflowableItem::NestedMetaItem(nested_meta_item) => match nested_meta_item {\n                 ast::NestedMetaItem::Literal(..) => true,\n-                ast::NestedMetaItem::MetaItem(ref meta_item) => match meta_item.kind {\n-                    ast::MetaItemKind::Word => true,\n-                    _ => false,\n-                },\n+                ast::NestedMetaItem::MetaItem(ref meta_item) => {\n+                    matches!(meta_item.kind, ast::MetaItemKind::Word)\n+                }\n             },\n             _ => false,\n         }\n     }\n \n     pub(crate) fn is_expr(&self) -> bool {\n-        match self {\n-            OverflowableItem::Expr(..) => true,\n-            OverflowableItem::MacroArg(MacroArg::Expr(..)) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self,\n+            OverflowableItem::Expr(..) | OverflowableItem::MacroArg(MacroArg::Expr(..))\n+        )\n     }\n \n     pub(crate) fn is_nested_call(&self) -> bool {\n@@ -154,10 +152,7 @@ impl<'a> OverflowableItem<'a> {\n     pub(crate) fn to_expr(&self) -> Option<&'a ast::Expr> {\n         match self {\n             OverflowableItem::Expr(expr) => Some(expr),\n-            OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n-                MacroArg::Expr(ref expr) => Some(expr),\n-                _ => None,\n-            },\n+            OverflowableItem::MacroArg(MacroArg::Expr(ref expr)) => Some(expr),\n             _ => None,\n         }\n     }\n@@ -178,10 +173,9 @@ impl<'a> OverflowableItem<'a> {\n                     ast::NestedMetaItem::MetaItem(..) => true,\n                 }\n             }\n-            OverflowableItem::SegmentParam(seg) => match seg {\n-                SegmentParam::Type(ty) => can_be_overflowed_type(context, ty, len),\n-                _ => false,\n-            },\n+            OverflowableItem::SegmentParam(SegmentParam::Type(ty)) => {\n+                can_be_overflowed_type(context, ty, len)\n+            }\n             OverflowableItem::TuplePatField(pat) => can_be_overflowed_pat(context, pat, len),\n             OverflowableItem::Ty(ty) => can_be_overflowed_type(context, ty, len),\n             _ => false,"}, {"sha": "062e9cef9bbd3382d0840de1ce984454daf3e139", "filename": "src/patterns.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -238,7 +238,7 @@ impl Rewrite for Pat {\n                         if let Some(rw) = p.rewrite(context, shape) {\n                             rw\n                         } else {\n-                            format!(\"{}\", context.snippet(p.span))\n+                            context.snippet(p.span).to_string()\n                         }\n                     })\n                     .collect();\n@@ -310,23 +310,22 @@ fn rewrite_struct_pat(\n         if fields_str.contains('\\n') || fields_str.len() > one_line_width {\n             // Add a missing trailing comma.\n             if context.config.trailing_comma() == SeparatorTactic::Never {\n-                fields_str.push_str(\",\");\n+                fields_str.push(',');\n             }\n-            fields_str.push_str(\"\\n\");\n+            fields_str.push('\\n');\n             fields_str.push_str(&nested_shape.indent.to_string(context.config));\n-            fields_str.push_str(\"..\");\n         } else {\n             if !fields_str.is_empty() {\n                 // there are preceding struct fields being matched on\n                 if tactic == DefinitiveListTactic::Vertical {\n                     // if the tactic is Vertical, write_list already added a trailing ,\n-                    fields_str.push_str(\" \");\n+                    fields_str.push(' ');\n                 } else {\n                     fields_str.push_str(\", \");\n                 }\n             }\n-            fields_str.push_str(\"..\");\n         }\n+        fields_str.push_str(\"..\");\n     }\n \n     // ast::Pat doesn't have attrs so use &[]\n@@ -411,10 +410,7 @@ impl<'a> Spanned for TuplePatField<'a> {\n impl<'a> TuplePatField<'a> {\n     fn is_dotdot(&self) -> bool {\n         match self {\n-            TuplePatField::Pat(pat) => match pat.kind {\n-                ast::PatKind::Rest => true,\n-                _ => false,\n-            },\n+            TuplePatField::Pat(pat) => matches!(pat.kind, ast::PatKind::Rest),\n             TuplePatField::Dotdot(_) => true,\n         }\n     }\n@@ -510,10 +506,11 @@ fn count_wildcard_suffix_len(\n     )\n     .collect();\n \n-    for item in items.iter().rev().take_while(|i| match i.item {\n-        Some(ref internal_string) if internal_string == \"_\" => true,\n-        _ => false,\n-    }) {\n+    for item in items\n+        .iter()\n+        .rev()\n+        .take_while(|i| matches!(i.item, Some(ref internal_string) if internal_string == \"_\"))\n+    {\n         suffix_len += 1;\n \n         if item.has_comment() {"}, {"sha": "a394ce07398efe24a80eeeec494af32f297b3e17", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -56,10 +56,7 @@ impl From<Vec<Mismatch>> for ModifiedLines {\n         let chunks = mismatches.into_iter().map(|mismatch| {\n             let lines = mismatch.lines.iter();\n             let num_removed = lines\n-                .filter(|line| match line {\n-                    DiffLine::Resulting(_) => true,\n-                    _ => false,\n-                })\n+                .filter(|line| matches!(line, DiffLine::Resulting(_)))\n                 .count();\n \n             let new_lines = mismatch.lines.into_iter().filter_map(|line| match line {\n@@ -94,7 +91,7 @@ impl fmt::Display for ModifiedLines {\n                 \"{} {} {}\",\n                 chunk.line_number_orig,\n                 chunk.lines_removed,\n-                chunk.lines.iter().count()\n+                chunk.lines.len()\n             )?;\n \n             for line in &chunk.lines {"}, {"sha": "0fdc097efc23fae6ce60d6faaa5a6461dc2aa1b0", "filename": "src/skip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fskip.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -32,8 +32,8 @@ impl SkipContext {\n     }\n }\n \n-static RUSTFMT: &'static str = \"rustfmt\";\n-static SKIP: &'static str = \"skip\";\n+static RUSTFMT: &str = \"rustfmt\";\n+static SKIP: &str = \"skip\";\n \n /// Say if you're playing with `rustfmt`'s skip attribute\n pub(crate) fn is_skip_attr(segments: &[ast::PathSegment]) -> bool {\n@@ -46,7 +46,7 @@ pub(crate) fn is_skip_attr(segments: &[ast::PathSegment]) -> bool {\n             segments[1].ident.to_string() == SKIP\n                 && [\"macros\", \"attributes\"]\n                     .iter()\n-                    .any(|&n| n == &pprust::path_segment_to_string(&segments[2]))\n+                    .any(|&n| n == pprust::path_segment_to_string(&segments[2]))\n         }\n         _ => false,\n     }"}, {"sha": "853336004d8b1a477c67d0adc75b792d5f1f9a05", "filename": "src/source_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_file.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::sync::Lrc;\n \n // Append a newline to the end of each file.\n pub(crate) fn append_newline(s: &mut String) {\n-    s.push_str(\"\\n\");\n+    s.push('\\n');\n }\n \n #[cfg(test)]"}, {"sha": "0cb9d817ca2d3dc7e1c36eeeb4ec57295bfa021c", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -57,7 +57,7 @@ impl<'a> StringFormat<'a> {\n     /// This allows to fit more graphemes from the string on a line when\n     /// SnippetState::EndWithLineFeed.\n     fn max_width_without_indent(&self) -> Option<usize> {\n-        Some(self.config.max_width().checked_sub(self.line_end.len())?)\n+        self.config.max_width().checked_sub(self.line_end.len())\n     }\n }\n \n@@ -99,7 +99,7 @@ pub(crate) fn rewrite_string<'a>(\n                 if is_new_line(grapheme) {\n                     // take care of blank lines\n                     result = trim_end_but_line_feed(fmt.trim_end, result);\n-                    result.push_str(\"\\n\");\n+                    result.push('\\n');\n                     if !is_bareline_ok && cur_start + i + 1 < graphemes.len() {\n                         result.push_str(&indent_without_newline);\n                         result.push_str(fmt.line_start);"}, {"sha": "b5fe4335dd33dff97c682f1820ab14acd748dffc", "filename": "src/syntux/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fparser.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -79,7 +79,7 @@ impl<'a> ParserBuilder<'a> {\n                 rustc_span::FileName::Custom(\"stdin\".to_owned()),\n                 text,\n             )\n-            .map_err(|db| Some(db)),\n+            .map_err(Some),\n         }\n     }\n }\n@@ -196,8 +196,7 @@ impl<'a> Parser<'a> {\n         mac: &'a ast::MacCall,\n     ) -> Result<Vec<ast::Item>, &'static str> {\n         let token_stream = mac.args.inner_tokens();\n-        let mut parser =\n-            rustc_parse::stream_to_parser(sess.inner(), token_stream.clone(), Some(\"\"));\n+        let mut parser = rustc_parse::stream_to_parser(sess.inner(), token_stream, Some(\"\"));\n \n         let mut items = vec![];\n         let mut process_if_cfg = true;"}, {"sha": "c6f89c310650c93306adca00625e6e117f70bfcc", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -662,7 +662,7 @@ impl Rewrite for ast::Ty {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 let mut result = String::with_capacity(128);\n-                result.push_str(\"&\");\n+                result.push('&');\n                 let ref_hi = context.snippet_provider.span_after(self.span(), \"&\");\n                 let mut cmnt_lo = ref_hi;\n \n@@ -685,7 +685,7 @@ impl Rewrite for ast::Ty {\n                     } else {\n                         result.push_str(&lt_str);\n                     }\n-                    result.push_str(\" \");\n+                    result.push(' ');\n                     cmnt_lo = lifetime.ident.span.hi();\n                 }\n \n@@ -1048,11 +1048,7 @@ fn join_bounds_inner(\n                     true,\n                 )\n                 .map(|v| (v, trailing_span, extendable)),\n-                _ => Some((\n-                    String::from(strs) + &trailing_str,\n-                    trailing_span,\n-                    extendable,\n-                )),\n+                _ => Some((strs + &trailing_str, trailing_span, extendable)),\n             }\n         },\n     )?;\n@@ -1089,10 +1085,7 @@ fn rewrite_lifetime_param(\n ) -> Option<String> {\n     let result = generic_params\n         .iter()\n-        .filter(|p| match p.kind {\n-            ast::GenericParamKind::Lifetime => true,\n-            _ => false,\n-        })\n+        .filter(|p| matches!(p.kind, ast::GenericParamKind::Lifetime))\n         .map(|lt| lt.rewrite(context, shape))\n         .collect::<Option<Vec<_>>>()?\n         .join(\", \");"}, {"sha": "06159a1b26e8698cdf0102b7c95514c7354e8ebc", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -191,7 +191,7 @@ pub(crate) fn outer_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute>\n \n #[inline]\n pub(crate) fn is_single_line(s: &str) -> bool {\n-    s.chars().find(|&c| c == '\\n').is_none()\n+    !s.chars().any(|c| c == '\\n')\n }\n \n #[inline]\n@@ -260,8 +260,7 @@ fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.kind {\n         MetaItemKind::Word => {\n             let path_str = pprust::path_to_string(&meta_item.path);\n-            path_str == &*skip_annotation().as_str()\n-                || path_str == &*depr_skip_annotation().as_str()\n+            path_str == *skip_annotation().as_str() || path_str == *depr_skip_annotation().as_str()\n         }\n         MetaItemKind::List(ref l) => {\n             meta_item.has_name(sym::cfg_attr) && l.len() == 2 && is_skip_nested(&l[1])"}, {"sha": "3f251bf7c16b30d31bed135f2030c671b3bdc52a", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2959fb12a6bd083003ec4371126211402e265d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=4c2959fb12a6bd083003ec4371126211402e265d", "patch": "@@ -198,7 +198,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             let missing_span = self.next_span(hi);\n             let snippet = self.snippet(missing_span);\n             let len = CommentCodeSlices::new(snippet)\n-                .nth(0)\n+                .next()\n                 .and_then(|(kind, _, s)| {\n                     if kind == CodeCharKind::Normal {\n                         s.rfind('\\n')\n@@ -293,15 +293,15 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     }\n                     let span_in_between = mk_sp(last_hi, span.lo() + BytePos::from_usize(offset));\n                     let snippet_in_between = self.snippet(span_in_between);\n-                    let mut comment_on_same_line = !snippet_in_between.contains(\"\\n\");\n+                    let mut comment_on_same_line = !snippet_in_between.contains('\\n');\n \n                     let mut comment_shape =\n                         Shape::indented(self.block_indent, config).comment(config);\n                     if self.config.version() == Version::Two && comment_on_same_line {\n                         self.push_str(\" \");\n                         // put the first line of the comment on the same line as the\n                         // block's last line\n-                        match sub_slice.find(\"\\n\") {\n+                        match sub_slice.find('\\n') {\n                             None => {\n                                 self.push_str(&sub_slice);\n                             }\n@@ -764,7 +764,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 let hi = self.snippet_provider.span_before(search_span, \";\");\n                 let target_span = mk_sp(mac.span().lo(), hi + BytePos(1));\n                 let rewrite = rewrite.map(|rw| {\n-                    if !rw.ends_with(\";\") {\n+                    if !rw.ends_with(';') {\n                         format!(\"{};\", rw)\n                     } else {\n                         rw\n@@ -921,7 +921,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         !is_skip_attr(segments)\n     }\n \n-    fn walk_mod_items(&mut self, items: &Vec<rustc_ast::ptr::P<ast::Item>>) {\n+    fn walk_mod_items(&mut self, items: &[rustc_ast::ptr::P<ast::Item>]) {\n         self.visit_items_with_reordering(&ptr_vec_to_ref_vec(&items));\n     }\n \n@@ -953,10 +953,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             // break the Stability Guarantee\n             // N.B. This could be updated to utilize the version gates.\n             let include_next_empty = if stmts.len() > 1 {\n-                match (&stmts[0].as_ast_node().kind, &stmts[1].as_ast_node().kind) {\n-                    (ast::StmtKind::Item(_), ast::StmtKind::Empty) => true,\n-                    _ => false,\n-                }\n+                matches!(\n+                    (&stmts[0].as_ast_node().kind, &stmts[1].as_ast_node().kind),\n+                    (ast::StmtKind::Item(_), ast::StmtKind::Empty)\n+                )\n             } else {\n                 false\n             };"}]}