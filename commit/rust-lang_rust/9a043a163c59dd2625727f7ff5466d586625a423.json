{"sha": "9a043a163c59dd2625727f7ff5466d586625a423", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMDQzYTE2M2M1OWRkMjYyNTcyN2Y3ZmY1NDY2ZDU4NjYyNWE0MjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T10:32:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "parses simple macro", "tree": {"sha": "33a8a6fe8f7a7f352c870bc0be2b93dfe9d410bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33a8a6fe8f7a7f352c870bc0be2b93dfe9d410bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a043a163c59dd2625727f7ff5466d586625a423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a043a163c59dd2625727f7ff5466d586625a423", "html_url": "https://github.com/rust-lang/rust/commit/9a043a163c59dd2625727f7ff5466d586625a423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a043a163c59dd2625727f7ff5466d586625a423/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d9210e9bc807ce64ea5fa694abb331ee5370c26", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9210e9bc807ce64ea5fa694abb331ee5370c26", "html_url": "https://github.com/rust-lang/rust/commit/0d9210e9bc807ce64ea5fa694abb331ee5370c26"}], "stats": {"total": 154, "additions": 131, "deletions": 23}, "files": [{"sha": "dc016a704c92a0cd9ef41b956445b8ca0d33b7a4", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=9a043a163c59dd2625727f7ff5466d586625a423", "patch": "@@ -260,7 +260,7 @@ fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n fn test_convert_tt() {\n     let text = r#\"\n macro_rules! impl_froms {\n-    ($e:ident: $($v:ident), *) => {\n+    ($e:ident: $($v:ident),*) => {\n         $(\n             impl From<$v> for $e {\n                 fn from(it: $v) -> $e {\n@@ -279,5 +279,5 @@ macro_rules! impl_froms {\n         .unwrap();\n     let tt = macro_call_to_tt(maco_call).unwrap();\n     let tt = mbe::parse(&tt);\n-    dbg!(tt);\n+    assert!(tt.is_some());\n }"}, {"sha": "6c93ae5e30a01fe52f84d76014297ffec09961ee", "filename": "crates/ra_hir/src/macros/mbe.rs", "status": "modified", "additions": 128, "deletions": 20, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros%2Fmbe.rs?ref=9a043a163c59dd2625727f7ff5466d586625a423", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::SmolStr;\n \n-use crate::macros::tt;\n+use crate::macros::tt::{self, Delimiter};\n \n #[derive(Debug)]\n pub(crate) struct MacroRules {\n@@ -19,6 +19,7 @@ enum TokenTree {\n     Subtree(Subtree),\n     Repeat(Repeat),\n }\n+impl_froms!(TokenTree: Leaf, Subtree, Repeat);\n \n #[derive(Debug)]\n enum Leaf {\n@@ -27,25 +28,19 @@ enum Leaf {\n     Ident(Ident),\n     Var(Var),\n }\n+impl_froms!(Leaf: Literal, Punct, Ident, Var);\n \n #[derive(Debug)]\n struct Subtree {\n     delimiter: Delimiter,\n     token_trees: Vec<TokenTree>,\n }\n \n-#[derive(Debug)]\n-enum Delimiter {\n-    Parenthesis,\n-    Brace,\n-    Bracket,\n-    None,\n-}\n-\n #[derive(Debug)]\n struct Repeat {\n     subtree: Subtree,\n     kind: RepeatKind,\n+    separator: Option<Punct>,\n }\n \n #[derive(Debug)]\n@@ -73,6 +68,7 @@ struct Ident {\n #[derive(Debug)]\n struct Var {\n     text: SmolStr,\n+    kind: Option<SmolStr>,\n }\n \n pub(crate) fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n@@ -86,16 +82,81 @@ pub(crate) fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n \n fn parse_rule(p: &mut RulesParser) -> Option<Rule> {\n     let lhs = parse_subtree(p.eat_subtree()?)?;\n-    p.eat_punct('=')?;\n-    p.eat_punct('>')?;\n+    p.expect_char('=')?;\n+    p.expect_char('>')?;\n     let rhs = parse_subtree(p.eat_subtree()?)?;\n     Some(Rule { lhs, rhs })\n }\n \n fn parse_subtree(tt: &tt::Subtree) -> Option<Subtree> {\n+    let mut token_trees = Vec::new();\n+    let mut p = RulesParser::new(tt);\n+    while let Some(tt) = p.eat() {\n+        let child: TokenTree = match tt {\n+            tt::TokenTree::Leaf(leaf) => match leaf {\n+                tt::Leaf::Punct(tt::Punct { char: '$' }) => {\n+                    if p.at_ident().is_some() {\n+                        Leaf::from(parse_var(&mut p)?).into()\n+                    } else {\n+                        parse_repeat(&mut p)?.into()\n+                    }\n+                }\n+                tt::Leaf::Punct(tt::Punct { char }) => Leaf::from(Punct { char: *char }).into(),\n+                tt::Leaf::Ident(tt::Ident { text }) => {\n+                    Leaf::from(Ident { text: text.clone() }).into()\n+                }\n+                tt::Leaf::Literal(tt::Literal { text }) => {\n+                    Leaf::from(Literal { text: text.clone() }).into()\n+                }\n+            },\n+            tt::TokenTree::Subtree(subtree) => parse_subtree(subtree)?.into(),\n+        };\n+        token_trees.push(child);\n+    }\n     Some(Subtree {\n-        token_trees: Vec::new(),\n-        delimiter: Delimiter::None,\n+        token_trees,\n+        delimiter: tt.delimiter,\n+    })\n+}\n+\n+fn parse_var(p: &mut RulesParser) -> Option<Var> {\n+    let ident = p.eat_ident().unwrap();\n+    let text = ident.text.clone();\n+    let kind = if p.at_char(':') {\n+        p.bump();\n+        if let Some(ident) = p.eat_ident() {\n+            Some(ident.text.clone())\n+        } else {\n+            // ugly as hell :(\n+            p.pos -= 1;\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+    Some(Var { text, kind })\n+}\n+\n+fn parse_repeat(p: &mut RulesParser) -> Option<Repeat> {\n+    let subtree = p.eat_subtree().unwrap();\n+    let subtree = parse_subtree(subtree)?;\n+    let mut sep = p.eat_punct()?;\n+    let (separator, rep) = match sep.char {\n+        '*' | '+' | '?' => (None, sep.char),\n+        char => (Some(Punct { char }), p.eat_punct()?.char),\n+    };\n+\n+    let kind = match rep {\n+        '*' => RepeatKind::ZeroOrMore,\n+        '+' => RepeatKind::OneOrMore,\n+        '?' => RepeatKind::ZeroOrMore,\n+        _ => return None,\n+    };\n+    p.bump();\n+    Some(Repeat {\n+        subtree,\n+        kind,\n+        separator,\n     })\n }\n \n@@ -117,9 +178,41 @@ impl<'a> RulesParser<'a> {\n         self.subtree.token_trees.get(self.pos)\n     }\n \n+    fn at_punct(&self) -> Option<&'a tt::Punct> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn at_char(&self, char: char) -> bool {\n+        match self.at_punct() {\n+            Some(tt::Punct { char: c }) if *c == char => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n+            _ => None,\n+        }\n+    }\n+\n     fn bump(&mut self) {\n         self.pos += 1;\n     }\n+\n+    fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n+        match self.current() {\n+            Some(it) => {\n+                self.bump();\n+                Some(it)\n+            }\n+            None => None,\n+        }\n+    }\n+\n     fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n         match self.current()? {\n             tt::TokenTree::Subtree(sub) => {\n@@ -129,13 +222,28 @@ impl<'a> RulesParser<'a> {\n             _ => return None,\n         }\n     }\n-    fn eat_punct(&mut self, char: char) -> Option<()> {\n-        match self.current()? {\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: c })) if *c == char => {\n-                self.bump();\n-                Some(())\n-            }\n-            _ => None,\n+\n+    fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n+        if let Some(it) = self.at_punct() {\n+            self.bump();\n+            return Some(it);\n+        }\n+        None\n+    }\n+\n+    fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n+        if let Some(i) = self.at_ident() {\n+            self.bump();\n+            return Some(i);\n+        }\n+        None\n+    }\n+\n+    fn expect_char(&mut self, char: char) -> Option<()> {\n+        if self.at_char(char) {\n+            self.bump();\n+            return Some(());\n         }\n+        None\n     }\n }"}, {"sha": "64e88ddc55b8e98e67c54727f638929fd6749cbb", "filename": "crates/ra_hir/src/macros/tt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros%2Ftt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a043a163c59dd2625727f7ff5466d586625a423/crates%2Fra_hir%2Fsrc%2Fmacros%2Ftt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros%2Ftt.rs?ref=9a043a163c59dd2625727f7ff5466d586625a423", "patch": "@@ -21,7 +21,7 @@ pub(crate) struct Subtree {\n     pub(crate) token_trees: Vec<TokenTree>,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub(crate) enum Delimiter {\n     Parenthesis,\n     Brace,"}]}