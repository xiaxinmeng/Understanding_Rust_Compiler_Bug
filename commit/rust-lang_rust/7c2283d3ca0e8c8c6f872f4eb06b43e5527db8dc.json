{"sha": "7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc", "node_id": "C_kwDOAAsO6NoAKDdjMjI4M2QzY2EwZThjOGM2Zjg3MmY0ZWIwNmI0M2U1NTI3ZGI4ZGM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-23T08:18:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-13T17:42:53Z"}, "message": "rustdoc: Do not create `UrlFragment`s until they are necessary\n\nThis simplifies error types and allows to remove `fn resolve_inner` and `fn check_full_res`\n\n`visited_links` caching is not touched for now", "tree": {"sha": "d8344b187f1fa60c34feb2027bfdb99e920dab4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8344b187f1fa60c34feb2027bfdb99e920dab4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc", "html_url": "https://github.com/rust-lang/rust/commit/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7256c6f93ee0c0773d749d865e8b7041635dd6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/7256c6f93ee0c0773d749d865e8b7041635dd6ed", "html_url": "https://github.com/rust-lang/rust/commit/7256c6f93ee0c0773d749d865e8b7041635dd6ed"}], "stats": {"total": 369, "additions": 133, "deletions": 236}, "files": [{"sha": "25702c8ed0ae6df2df81cad2388c77a919f48e42", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 133, "deletions": 236, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7c2283d3ca0e8c8c6f872f4eb06b43e5527db8dc", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n-use rustc_middle::{bug, span_bug, ty};\n+use rustc_middle::{bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n@@ -48,12 +48,6 @@ fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     krate\n }\n \n-/// Top-level errors emitted by this pass.\n-enum ErrorKind<'a> {\n-    Resolve(Box<ResolutionFailure<'a>>),\n-    AnchorFailure(AnchorFailure),\n-}\n-\n #[derive(Copy, Clone, Debug, Hash)]\n enum Res {\n     Def(DefKind, DefId),\n@@ -91,6 +85,10 @@ impl Res {\n         }\n     }\n \n+    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Res {\n+        Res::Def(tcx.def_kind(def_id), def_id)\n+    }\n+\n     /// Used for error reporting.\n     fn disambiguator_suggestion(self) -> Suggestion {\n         let kind = match self {\n@@ -146,8 +144,25 @@ impl TryFrom<ResolveRes> for Res {\n     }\n }\n \n-/// A link failed to resolve.\n-#[derive(Clone, Debug)]\n+/// The link failed to resolve. [`resolution_failure`] should look to see if there's\n+/// a more helpful error that can be given.\n+#[derive(Debug)]\n+struct UnresolvedPath<'a> {\n+    /// Item on which the link is resolved, used for resolving `Self`.\n+    item_id: ItemId,\n+    /// The scope the link was resolved in.\n+    module_id: DefId,\n+    /// If part of the link resolved, this has the `Res`.\n+    ///\n+    /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n+    partial_res: Option<Res>,\n+    /// The remaining unresolved path segments.\n+    ///\n+    /// In `[std::io::Error::x]`, `x` would be unresolved.\n+    unresolved: Cow<'a, str>,\n+}\n+\n+#[derive(Debug)]\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     WrongNamespace {\n@@ -159,22 +174,7 @@ enum ResolutionFailure<'a> {\n         /// even though `Result`'s actual namespace is [`Namespace::TypeNS`].\n         expected_ns: Namespace,\n     },\n-    /// The link failed to resolve. [`resolution_failure`] should look to see if there's\n-    /// a more helpful error that can be given.\n-    NotResolved {\n-        /// Item on which the link is resolved, used for resolving `Self`.\n-        item_id: ItemId,\n-        /// The scope the link was resolved in.\n-        module_id: DefId,\n-        /// If part of the link resolved, this has the `Res`.\n-        ///\n-        /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n-        partial_res: Option<Res>,\n-        /// The remaining unresolved path segments.\n-        ///\n-        /// In `[std::io::Error::x]`, `x` would be unresolved.\n-        unresolved: Cow<'a, str>,\n-    },\n+    NotResolved(UnresolvedPath<'a>),\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -218,35 +218,6 @@ enum MalformedGenerics {\n     EmptyAngleBrackets,\n }\n \n-impl ResolutionFailure<'_> {\n-    /// This resolved fully (not just partially) but is erroneous for some other reason\n-    ///\n-    /// Returns the full resolution of the link, if present.\n-    fn full_res(&self) -> Option<Res> {\n-        match self {\n-            Self::WrongNamespace { res, expected_ns: _ } => Some(*res),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-enum AnchorFailure {\n-    /// User error: `[std#x#y]` is not valid\n-    MultipleAnchors,\n-    /// The anchor provided by the user conflicts with Rustdoc's generated anchor.\n-    ///\n-    /// This is an unfortunate state of affairs. Not every item that can be\n-    /// linked to has its own page; sometimes it is a subheading within a page,\n-    /// like for associated items. In those cases, rustdoc uses an anchor to\n-    /// link to the subheading. Since you can't have two anchors for the same\n-    /// link, Rustdoc disallows having a user-specified anchor.\n-    ///\n-    /// Most of the time this is fine, because you can just link to the page of\n-    /// the item if you want to provide your own anchor.\n-    RustdocAnchorConflict(Res),\n-}\n-\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n crate enum UrlFragment {\n     Item(ItemFragment),\n@@ -278,24 +249,32 @@ crate enum FragmentKind {\n     VariantField,\n }\n \n-impl ItemFragment {\n-    /// Create a fragment for an associated item.\n-    #[instrument(level = \"debug\")]\n-    fn from_assoc_item(item: &ty::AssocItem) -> Self {\n-        let def_id = item.def_id;\n-        match item.kind {\n-            ty::AssocKind::Fn => {\n-                if item.defaultness.has_value() {\n-                    ItemFragment(FragmentKind::Method, def_id)\n+impl FragmentKind {\n+    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> FragmentKind {\n+        match tcx.def_kind(def_id) {\n+            DefKind::AssocFn => {\n+                if tcx.associated_item(def_id).defaultness.has_value() {\n+                    FragmentKind::Method\n                 } else {\n-                    ItemFragment(FragmentKind::TyMethod, def_id)\n+                    FragmentKind::TyMethod\n                 }\n             }\n-            ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n-            ty::AssocKind::Type => ItemFragment(FragmentKind::AssociatedType, def_id),\n+            DefKind::AssocConst => FragmentKind::AssociatedConstant,\n+            DefKind::AssocTy => FragmentKind::AssociatedType,\n+            DefKind::Variant => FragmentKind::Variant,\n+            DefKind::Field => {\n+                if tcx.def_kind(tcx.parent(def_id).unwrap()) == DefKind::Variant {\n+                    FragmentKind::VariantField\n+                } else {\n+                    FragmentKind::StructField\n+                }\n+            }\n+            kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n         }\n     }\n+}\n \n+impl ItemFragment {\n     /// Render the fragment, including the leading `#`.\n     crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         write!(s, \"#\")?;\n@@ -365,9 +344,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         item_id: ItemId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ResolutionFailure<'path>> {\n+    ) -> Result<(Res, DefId), UnresolvedPath<'path>> {\n         let tcx = self.cx.tcx;\n-        let no_res = || ResolutionFailure::NotResolved {\n+        let no_res = || UnresolvedPath {\n             item_id,\n             module_id,\n             partial_res: None,\n@@ -397,26 +376,24 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             Res::Def(DefKind::Enum, did) => match tcx.type_of(did).kind() {\n                 ty::Adt(def, _) if def.is_enum() => {\n                     if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name) {\n-                        Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n+                        Ok((ty_res, field.did))\n                     } else {\n-                        Err(ResolutionFailure::NotResolved {\n+                        Err(UnresolvedPath {\n                             item_id,\n                             module_id,\n                             partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n                             unresolved: variant_field_name.to_string().into(),\n-                        }\n-                        .into())\n+                        })\n                     }\n                 }\n                 _ => unreachable!(),\n             },\n-            _ => Err(ResolutionFailure::NotResolved {\n+            _ => Err(UnresolvedPath {\n                 item_id,\n                 module_id,\n                 partial_res: Some(ty_res),\n                 unresolved: variant_name.to_string().into(),\n-            }\n-            .into()),\n+            }),\n         }\n     }\n \n@@ -426,16 +403,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, ItemFragment)> {\n+    ) -> Option<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).find_map(|impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n-                .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(item);\n-                    (Res::Primitive(prim_ty), fragment)\n-                })\n+                .map(|item| (Res::Primitive(prim_ty), item.def_id))\n         })\n     }\n \n@@ -529,31 +503,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         item_id: ItemId,\n         module_id: DefId,\n-        user_fragment: &Option<String>,\n-    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n-        let (res, rustdoc_fragment) = self\n-            .resolve_inner(path_str, ns, item_id, module_id)\n-            .map_err(|err| ErrorKind::Resolve(box err))?;\n-        let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n-            (Some(_), Some(ItemFragment(_, did))) => {\n-                let diag_res = Res::Def(self.cx.tcx.def_kind(did), did);\n-                let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n-                return Err(ErrorKind::AnchorFailure(failure));\n-            }\n-            (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n-            (None, Some(r_frag)) => Some(UrlFragment::Item(r_frag)),\n-            (None, None) => None,\n-        };\n-        Ok((res, chosen_fragment))\n-    }\n-\n-    fn resolve_inner<'path>(\n-        &mut self,\n-        path_str: &'path str,\n-        ns: Namespace,\n-        item_id: ItemId,\n-        module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ResolutionFailure<'path>> {\n+    ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -562,16 +512,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n                 Res::Def(DefKind::Variant, def_id) => {\n                     let enum_def_id = self.cx.tcx.parent(def_id).expect(\"variant has no parent\");\n-                    return Ok((\n-                        Res::Def(DefKind::Enum, enum_def_id),\n-                        Some(ItemFragment(FragmentKind::Variant, def_id)),\n-                    ));\n+                    return Ok((Res::Def(DefKind::Enum, enum_def_id), Some(def_id)));\n                 }\n                 // Not a trait item; just return what we found.\n                 _ => return Ok((res, None)),\n             }\n         } else if ns == MacroNS {\n-            return Err(ResolutionFailure::NotResolved {\n+            return Err(UnresolvedPath {\n                 item_id,\n                 module_id,\n                 partial_res: None,\n@@ -592,7 +539,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                ResolutionFailure::NotResolved {\n+                UnresolvedPath {\n                     item_id,\n                     module_id,\n                     partial_res: None,\n@@ -607,23 +554,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n-                let (res, fragment) =\n-                    self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n-\n-                Some(Ok((res, Some(fragment))))\n+                self.resolve_associated_item(ty_res, item_name, ns, module_id).map(Ok)\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, item_id, module_id)\n                 } else {\n-                    Err(ResolutionFailure::NotResolved {\n+                    Err(UnresolvedPath {\n                         item_id,\n                         module_id,\n                         partial_res: None,\n                         unresolved: path_root.into(),\n                     })\n                 }\n             })\n+            .map(|(res, def_id)| (res, Some(def_id)))\n     }\n \n     /// Convert a DefId to a Res, where possible.\n@@ -648,7 +593,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::FnPtr(_) => Res::Primitive(Fn),\n             ty::Never => Res::Primitive(Never),\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) | ty::Foreign(did) => {\n-                Res::Def(self.cx.tcx.def_kind(did), did)\n+                Res::from_def_id(self.cx.tcx, did)\n             }\n             ty::Projection(_)\n             | ty::Closure(..)\n@@ -705,23 +650,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, ItemFragment)> {\n+    ) -> Option<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n             Res::Primitive(prim) => {\n                 self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n-                    let assoc_item = self\n-                        .primitive_type_to_ty(prim)\n+                    self.primitive_type_to_ty(prim)\n                         .map(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n                         })\n-                        .flatten();\n-\n-                    assoc_item.map(|item| {\n-                        let fragment = ItemFragment::from_assoc_item(&item);\n-                        (root_res, fragment)\n-                    })\n+                        .flatten()\n+                        .map(|item| (root_res, item.def_id))\n                 })\n             }\n             Res::Def(DefKind::TyAlias, did) => {\n@@ -742,10 +682,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n-                                    return Some((\n-                                        root_res,\n-                                        ItemFragment(FragmentKind::Variant, variant.def_id),\n-                                    ));\n+                                    return Some((root_res, variant.def_id));\n                                 }\n                             }\n                         }\n@@ -786,8 +723,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 debug!(\"got associated item {:?}\", assoc_item);\n \n                 if let Some(item) = assoc_item {\n-                    let fragment = ItemFragment::from_assoc_item(&item);\n-                    return Some((root_res, fragment));\n+                    return Some((root_res, item.def_id));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -815,48 +751,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 };\n                 let field =\n                     def.non_enum_variant().fields.iter().find(|item| item.name == item_name)?;\n-                Some((root_res, ItemFragment(FragmentKind::StructField, field.did)))\n+                Some((root_res, field.did))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(item);\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, fragment)\n+                    (res, item.def_id)\n                 }),\n             _ => None,\n         }\n     }\n+}\n \n-    /// Used for reporting better errors.\n-    ///\n-    /// Returns whether the link resolved 'fully' in another namespace.\n-    /// 'fully' here means that all parts of the link resolved, not just some path segments.\n-    /// This returns the `Res` even if it was erroneous for some reason\n-    /// (such as having invalid URL fragments or being in the wrong namespace).\n-    fn check_full_res(\n-        &mut self,\n-        ns: Namespace,\n-        path_str: &str,\n-        item_id: ItemId,\n-        module_id: DefId,\n-        extra_fragment: &Option<String>,\n-    ) -> Option<Res> {\n-        let res = match self.resolve(path_str, ns, item_id, module_id, extra_fragment) {\n-            Ok((res, frag)) => {\n-                if let Some(UrlFragment::Item(ItemFragment(_, id))) = frag {\n-                    Some(Res::Def(self.cx.tcx.def_kind(id), id))\n-                } else {\n-                    Some(res)\n-                }\n-            }\n-            Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n-            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => Some(res),\n-            Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n-        };\n-        res\n-    }\n+fn full_res(tcx: TyCtxt<'_>, (base, assoc_item): (Res, Option<DefId>)) -> Res {\n+    assoc_item.map_or(base, |def_id| Res::from_def_id(tcx, def_id))\n }\n \n /// Look to see if a resolved item has an associated item named `item_name`.\n@@ -1036,15 +946,16 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n }\n \n enum PreprocessingError {\n-    Anchor(AnchorFailure),\n+    /// User error: `[std#x#y]` is not valid\n+    MultipleAnchors,\n     Disambiguator(Range<usize>, String),\n     MalformedGenerics(MalformedGenerics, String),\n }\n \n impl PreprocessingError {\n     fn report(&self, cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n         match self {\n-            PreprocessingError::Anchor(err) => anchor_failure(cx, diag_info, *err),\n+            PreprocessingError::MultipleAnchors => report_multiple_anchors(cx, diag_info),\n             PreprocessingError::Disambiguator(range, msg) => {\n                 disambiguator_error(cx, diag_info, range.clone(), msg)\n             }\n@@ -1096,7 +1007,7 @@ fn preprocess_link(\n     let extra_fragment = parts.next();\n     if parts.next().is_some() {\n         // A valid link can't have multiple #'s\n-        return Some(Err(PreprocessingError::Anchor(AnchorFailure::MultipleAnchors)));\n+        return Some(Err(PreprocessingError::MultipleAnchors));\n     }\n \n     // Parse and strip the disambiguator from the link, if present.\n@@ -1418,7 +1329,21 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let res = self.resolve_with_disambiguator(&key, diag);\n+        let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n+            let fragment = match (&key.extra_fragment, def_id) {\n+                (Some(_), Some(def_id)) => {\n+                    report_anchor_conflict(self.cx, diag, Res::from_def_id(self.cx.tcx, def_id));\n+                    return None;\n+                }\n+                (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n+                (None, Some(def_id)) => Some(UrlFragment::Item(ItemFragment(\n+                    FragmentKind::from_def_id(self.cx.tcx, def_id),\n+                    def_id,\n+                ))),\n+                (None, None) => None,\n+            };\n+            Some((res, fragment))\n+        });\n \n         // Cache only if resolved successfully - don't silence duplicate errors\n         if let Some(res) = res {\n@@ -1443,40 +1368,35 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<UrlFragment>)> {\n+    ) -> Option<(Res, Option<DefId>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n         let base_node = key.module_id;\n-        let extra_fragment = &key.extra_fragment;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n-                match self.resolve(path_str, expected_ns, item_id, base_node, extra_fragment) {\n+                match self.resolve(path_str, expected_ns, item_id, base_node) {\n                     Ok(res) => Some(res),\n-                    Err(ErrorKind::AnchorFailure(msg)) => {\n-                        anchor_failure(self.cx, diag, msg);\n-                        None\n-                    }\n-                    Err(ErrorKind::Resolve(mut err)) => {\n+                    Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n                         // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach.\n+                        let mut err = ResolutionFailure::NotResolved(err);\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n-                                if let Some(res) = self.check_full_res(\n-                                    other_ns,\n-                                    path_str,\n-                                    item_id,\n-                                    base_node,\n-                                    extra_fragment,\n-                                ) {\n-                                    *err = ResolutionFailure::WrongNamespace { res, expected_ns };\n+                                if let Ok(res) =\n+                                    self.resolve(path_str, other_ns, item_id, base_node)\n+                                {\n+                                    err = ResolutionFailure::WrongNamespace {\n+                                        res: full_res(self.cx.tcx, res),\n+                                        expected_ns,\n+                                    };\n                                     break;\n                                 }\n                             }\n                         }\n-                        resolution_failure(self, diag, path_str, disambiguator, smallvec![*err]);\n+                        resolution_failure(self, diag, path_str, disambiguator, smallvec![err]);\n                         // This could just be a normal link or a broken link\n                         // we could potentially check if something is\n                         // \"intra-doc-link-like\" and warn in that case.\n@@ -1486,37 +1406,21 @@ impl LinkCollector<'_, '_> {\n             }\n             None => {\n                 // Try everything!\n-                let mut candidate =\n-                    |ns| match self.resolve(path_str, ns, item_id, base_node, extra_fragment) {\n-                        Ok(res) => Some(Ok(res)),\n-                        Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, diag.clone(), msg);\n-                            None\n-                        }\n-                        Err(ErrorKind::Resolve(err)) => Some(Err(*err)),\n-                    };\n+                let mut candidate = |ns| {\n+                    self.resolve(path_str, ns, item_id, base_node)\n+                        .map_err(ResolutionFailure::NotResolved)\n+                };\n \n                 let candidates = PerNS {\n-                    macro_ns: candidate(MacroNS)?,\n-                    type_ns: candidate(TypeNS)?,\n-                    value_ns: candidate(ValueNS)?.and_then(|(res, fragment)| {\n+                    macro_ns: candidate(MacroNS),\n+                    type_ns: candidate(TypeNS),\n+                    value_ns: candidate(ValueNS).and_then(|(res, def_id)| {\n                         match res {\n                             // Constructors are picked up in the type namespace.\n                             Res::Def(DefKind::Ctor(..), _) => {\n                                 Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n                             }\n-                            _ => {\n-                                match (fragment, extra_fragment.clone()) {\n-                                    (Some(fragment), Some(_)) => {\n-                                        // Shouldn't happen but who knows?\n-                                        Ok((res, Some(fragment)))\n-                                    }\n-                                    (fragment, None) => Ok((res, fragment)),\n-                                    (None, fragment) => {\n-                                        Ok((res, fragment.map(UrlFragment::UserWritten)))\n-                                    }\n-                                }\n-                            }\n+                            _ => Ok((res, def_id)),\n                         }\n                     }),\n                 };\n@@ -1865,12 +1769,12 @@ fn resolution_failure(\n                 }\n                 variants_seen.push(variant);\n \n-                if let ResolutionFailure::NotResolved {\n+                if let ResolutionFailure::NotResolved(UnresolvedPath {\n                     item_id,\n                     module_id,\n                     partial_res,\n                     unresolved,\n-                } = &mut failure\n+                }) = &mut failure\n                 {\n                     use DefKind::*;\n \n@@ -1896,11 +1800,9 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Some(res) =\n-                                collector.check_full_res(ns, start, item_id, module_id, &None)\n-                            {\n+                            if let Ok(res) = collector.resolve(start, ns, item_id, module_id) {\n                                 debug!(\"found partial_res={:?}\", res);\n-                                *partial_res = Some(res);\n+                                *partial_res = Some(full_res(collector.cx.tcx, res));\n                                 *unresolved = end.into();\n                                 break 'outer;\n                             }\n@@ -2020,22 +1922,24 @@ fn resolution_failure(\n     );\n }\n \n-/// Report an anchor failure.\n-fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: AnchorFailure) {\n-    let (msg, anchor_idx) = match failure {\n-        AnchorFailure::MultipleAnchors => {\n-            (format!(\"`{}` contains multiple anchors\", diag_info.ori_link), 1)\n-        }\n-        AnchorFailure::RustdocAnchorConflict(res) => (\n-            format!(\n-                \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n-                diag_info.ori_link,\n-                kind = res.descr(),\n-            ),\n-            0,\n-        ),\n-    };\n+fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n+    let msg = format!(\"`{}` contains multiple anchors\", diag_info.ori_link);\n+    anchor_failure(cx, diag_info, &msg, 1)\n+}\n \n+fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, res: Res) {\n+    let (link, kind) = (diag_info.ori_link, res.descr());\n+    let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n+    anchor_failure(cx, diag_info, &msg, 0)\n+}\n+\n+/// Report an anchor failure.\n+fn anchor_failure(\n+    cx: &DocContext<'_>,\n+    diag_info: DiagnosticInfo<'_>,\n+    msg: &str,\n+    anchor_idx: usize,\n+) {\n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n@@ -2045,13 +1949,6 @@ fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: A\n             }\n             diag.span_label(sp, \"invalid anchor\");\n         }\n-        if let AnchorFailure::RustdocAnchorConflict(Res::Primitive(_)) = failure {\n-            if let Some(sp) = sp {\n-                span_bug!(sp, \"anchors should be allowed now\");\n-            } else {\n-                bug!(\"anchors should be allowed now\");\n-            }\n-        }\n     });\n }\n "}]}