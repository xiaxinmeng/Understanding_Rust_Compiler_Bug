{"sha": "39f9751716986b498bfb2b14b481751a4256957f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Zjk3NTE3MTY5ODZiNDk4YmZiMmIxNGI0ODE3NTFhNDI1Njk1N2Y=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-08-28T04:40:08Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:50Z"}, "message": "SGX target: add thread local storage", "tree": {"sha": "84c05dc06dec23daa5cbdd9d68535c0fe8892fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84c05dc06dec23daa5cbdd9d68535c0fe8892fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f9751716986b498bfb2b14b481751a4256957f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f9751716986b498bfb2b14b481751a4256957f", "html_url": "https://github.com/rust-lang/rust/commit/39f9751716986b498bfb2b14b481751a4256957f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f9751716986b498bfb2b14b481751a4256957f/comments", "author": null, "committer": null, "parents": [{"sha": "4a3505682e97c8e667338056ae216e4b84b22dd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3505682e97c8e667338056ae216e4b84b22dd7", "html_url": "https://github.com/rust-lang/rust/commit/4a3505682e97c8e667338056ae216e4b84b22dd7"}], "stats": {"total": 294, "additions": 277, "deletions": 17}, "files": [{"sha": "99ea7a381f37b2c27614ed4d25241611c4eb79a8", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=39f9751716986b498bfb2b14b481751a4256957f", "patch": "@@ -17,6 +17,8 @@ mod mem;\n pub(super) mod panic;\n \n // library features\n+pub mod thread;\n+pub mod tls;\n #[macro_use]\n mod usercalls;\n \n@@ -59,6 +61,10 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n #[no_mangle]\n #[allow(unreachable_code)]\n extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n+    // FIXME: how to support TLS in library mode?\n+    let tls = Box::new(tls::Tls::new());\n+    let _tls_guard = unsafe { tls.activate() };\n+\n     if secondary {\n         unimplemented!(\"thread entrypoint\");\n "}, {"sha": "4640b812fea84a17a812c04a27cceba93ddaa508", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=39f9751716986b498bfb2b14b481751a4256957f", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::Tcs;\n+\n+/// Get the ID for the current thread. The ID is guaranteed to be unique among\n+/// all currently running threads in the enclave, and it is guaranteed to be\n+/// constant for the lifetime of the thread. More specifically for SGX, there\n+/// is a one-to-one correspondence of the ID to the address of the TCS.\n+pub fn current() -> Tcs {\n+    extern \"C\" { fn get_tcs_addr() -> Tcs; }\n+    unsafe { get_tcs_addr() }\n+}"}, {"sha": "ab7822182a579f905b1fdd66f82dc53c59ddc4b2", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=39f9751716986b498bfb2b14b481751a4256957f", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use ptr;\n+use mem;\n+use cell::Cell;\n+use num::NonZeroUsize;\n+use self::sync_bitset::*;\n+\n+#[cfg(target_pointer_width=\"64\")]\n+const USIZE_BITS: usize = 64;\n+const TLS_KEYS: usize = 128; // Same as POSIX minimum\n+const TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n+\n+static TLS_KEY_IN_USE: SyncBitset = SYNC_BITSET_INIT;\n+macro_rules! dup {\n+    ((* $($exp:tt)*) $($val:tt)*) => (dup!( ($($exp)*) $($val)* $($val)* ));\n+    (() $($val:tt)*) => ([$($val),*])\n+}\n+static TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = dup!((* * * * * * *) ATOMIC_USIZE_INIT);\n+\n+extern \"C\" {\n+    fn get_tls_ptr() -> *const u8;\n+    fn set_tls_ptr(tls: *const u8);\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct Key(NonZeroUsize);\n+\n+impl Key {\n+    fn to_index(self) -> usize {\n+        self.0.get() - 1\n+    }\n+\n+    fn from_index(index: usize) -> Self {\n+        Key(NonZeroUsize::new(index + 1).unwrap())\n+    }\n+\n+    pub fn as_usize(self) -> usize {\n+        self.0.get()\n+    }\n+\n+    pub fn from_usize(index: usize) -> Self {\n+        Key(NonZeroUsize::new(index).unwrap())\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct Tls {\n+    data: [Cell<*mut u8>; TLS_KEYS]\n+}\n+\n+pub struct ActiveTls<'a> {\n+    tls: &'a Tls\n+}\n+\n+impl<'a> Drop for ActiveTls<'a> {\n+    fn drop(&mut self) {\n+        let value_with_destructor = |key: usize| {\n+            let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n+            unsafe { mem::transmute::<_,Option<unsafe extern fn(*mut u8)>>(ptr) }\n+                .map(|dtor| (&self.tls.data[key], dtor))\n+        };\n+\n+        let mut any_non_null_dtor = true;\n+        while any_non_null_dtor {\n+            any_non_null_dtor = false;\n+            for (value, dtor) in TLS_KEY_IN_USE.iter().filter_map(&value_with_destructor) {\n+                let value = value.replace(ptr::null_mut());\n+                if value != ptr::null_mut() {\n+                    any_non_null_dtor = true;\n+                    unsafe { dtor(value) }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Tls {\n+    pub fn new() -> Tls {\n+        Tls { data: dup!((* * * * * * *) (Cell::new(ptr::null_mut()))) }\n+    }\n+\n+    pub unsafe fn activate(&self) -> ActiveTls {\n+        set_tls_ptr(self as *const Tls as _);\n+        ActiveTls { tls: self }\n+    }\n+\n+    #[allow(unused)]\n+    pub unsafe fn activate_persistent(self: Box<Self>) {\n+        set_tls_ptr((&*self) as *const Tls as _);\n+        mem::forget(self);\n+    }\n+\n+    unsafe fn current<'a>() -> &'a Tls {\n+        &*(get_tls_ptr() as *const Tls)\n+    }\n+\n+    pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+        let index = TLS_KEY_IN_USE.set().expect(\"TLS limit exceeded\");\n+        TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n+        Key::from_index(index)\n+    }\n+\n+    pub fn set(key: Key, value: *mut u8) {\n+        let index = key.to_index();\n+        assert!(TLS_KEY_IN_USE.get(index));\n+        unsafe { Self::current() }.data[index].set(value);\n+    }\n+\n+    pub fn get(key: Key) -> *mut u8 {\n+        let index = key.to_index();\n+        assert!(TLS_KEY_IN_USE.get(index));\n+        unsafe { Self::current() }.data[index].get()\n+    }\n+\n+    pub fn destroy(key: Key) {\n+        TLS_KEY_IN_USE.clear(key.to_index());\n+    }\n+}\n+\n+mod sync_bitset {\n+    use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use iter::{Enumerate, Peekable};\n+    use slice::Iter;\n+    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n+\n+    /// A bitset that can be used synchronously.\n+    pub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n+\n+    pub(super) const SYNC_BITSET_INIT: SyncBitset =\n+        SyncBitset([ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT]);\n+\n+    impl SyncBitset {\n+        pub fn get(&self, index: usize) -> bool {\n+            let (hi, lo) = Self::split(index);\n+            (self.0[hi].load(Ordering::Relaxed) & lo) != 0\n+        }\n+\n+        /// Not atomic.\n+        pub fn iter(&self) -> SyncBitsetIter {\n+            SyncBitsetIter {\n+                iter: self.0.iter().enumerate().peekable(),\n+                elem_idx: 0,\n+            }\n+        }\n+\n+        pub fn clear(&self, index: usize) {\n+            let (hi, lo) = Self::split(index);\n+            self.0[hi].fetch_and(!lo, Ordering::Relaxed);\n+        }\n+\n+        /// Set any unset bit. Not atomic. Returns `None` if all bits were\n+        /// observed to be set.\n+        pub fn set(&self) -> Option<usize> {\n+            'elems: for (idx, elem) in self.0.iter().enumerate() {\n+                let mut current = elem.load(Ordering::Relaxed);\n+                loop {\n+                    if 0 == !current {\n+                        continue 'elems;\n+                    }\n+                    let trailing_ones = (!current).trailing_zeros() as usize;\n+                    match elem.compare_exchange(\n+                        current,\n+                        current | (1 << trailing_ones),\n+                        Ordering::AcqRel,\n+                        Ordering::Relaxed\n+                    ) {\n+                        Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n+                        Err(previous) => current = previous,\n+                    }\n+                }\n+            }\n+            None\n+        }\n+\n+        fn split(index: usize) -> (usize, usize) {\n+            (index / USIZE_BITS, 1 << (index % USIZE_BITS))\n+        }\n+    }\n+\n+    pub(super) struct SyncBitsetIter<'a> {\n+        iter: Peekable<Enumerate<Iter<'a, AtomicUsize>>>,\n+        elem_idx: usize,\n+    }\n+\n+    impl<'a> Iterator for SyncBitsetIter<'a> {\n+        type Item = usize;\n+\n+        fn next(&mut self) -> Option<usize> {\n+            self.iter.peek().cloned().and_then(|(idx, elem)| {\n+                let elem = elem.load(Ordering::Relaxed);\n+                let low_mask = (1 << self.elem_idx) - 1;\n+                let next = elem & !low_mask;\n+                let next_idx = next.trailing_zeros() as usize;\n+                self.elem_idx = next_idx + 1;\n+                if self.elem_idx >= 64 {\n+                    self.elem_idx = 0;\n+                    self.iter.next();\n+                }\n+                match next_idx {\n+                    64 => self.next(),\n+                    _ => Some(idx * USIZE_BITS + next_idx),\n+                }\n+            })\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::*;\n+\n+        fn test_data(bitset: [usize; 2], bit_indices: &[usize]) {\n+            let set = SyncBitset([AtomicUsize::new(bitset[0]), AtomicUsize::new(bitset[1])]);\n+            assert_eq!(set.iter().collect::<Vec<_>>(), bit_indices);\n+            for &i in bit_indices {\n+                assert!(set.get(i));\n+            }\n+        }\n+\n+        #[test]\n+        fn iter() {\n+            test_data([0b0110_1001, 0], &[0, 3, 5, 6]);\n+            test_data([0x8000_0000_0000_0000, 0x8000_0000_0000_0001], &[63, 64, 127]);\n+            test_data([0, 0], &[]);\n+        }\n+\n+        #[test]\n+        fn set_get_clear() {\n+            let set = SYNC_BITSET_INIT;\n+            let key = set.set().unwrap();\n+            assert!(set.get(key));\n+            set.clear(key);\n+            assert!(!set.get(key));\n+        }\n+    }\n+}"}, {"sha": "3b628bae4fbf639331e50ee2635692ae1cda4ab6", "filename": "src/libstd/sys/sgx/thread_local.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f9751716986b498bfb2b14b481751a4256957f/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs?ref=39f9751716986b498bfb2b14b481751a4256957f", "patch": "@@ -8,40 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use boxed::Box;\n-use ptr;\n+use super::abi::tls::{Tls, Key as AbiKey};\n \n pub type Key = usize;\n \n-struct Allocated {\n-    value: *mut u8,\n-    dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n #[inline]\n pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    Box::into_raw(Box::new(Allocated {\n-        value: ptr::null_mut(),\n-        dtor,\n-    })) as usize\n+    Tls::create(dtor).as_usize()\n }\n \n #[inline]\n pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*(key as *mut Allocated)).value = value;\n+    Tls::set(AbiKey::from_usize(key), value)\n }\n \n #[inline]\n pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*(key as *mut Allocated)).value\n+    Tls::get(AbiKey::from_usize(key))\n }\n \n #[inline]\n pub unsafe fn destroy(key: Key) {\n-    let key = Box::from_raw(key as *mut Allocated);\n-    if let Some(f) = key.dtor {\n-        f(key.value);\n-    }\n+    Tls::destroy(AbiKey::from_usize(key))\n }\n \n #[inline]"}]}