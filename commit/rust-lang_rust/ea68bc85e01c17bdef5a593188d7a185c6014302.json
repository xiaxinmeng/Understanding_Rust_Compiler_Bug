{"sha": "ea68bc85e01c17bdef5a593188d7a185c6014302", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNjhiYzg1ZTAxYzE3YmRlZjVhNTkzMTg4ZDdhMTg1YzYwMTQzMDI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-12T22:39:10Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T17:40:47Z"}, "message": "resolve: Make `ParentScope` `Copy`\n\nBy allocating its derive paths on the resolver arena.", "tree": {"sha": "ca11fda9c4bd9de40edc0d1e584539adc816e2dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca11fda9c4bd9de40edc0d1e584539adc816e2dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea68bc85e01c17bdef5a593188d7a185c6014302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea68bc85e01c17bdef5a593188d7a185c6014302", "html_url": "https://github.com/rust-lang/rust/commit/ea68bc85e01c17bdef5a593188d7a185c6014302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea68bc85e01c17bdef5a593188d7a185c6014302/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "url": "https://api.github.com/repos/rust-lang/rust/commits/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "html_url": "https://github.com/rust-lang/rust/commit/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "bfb7844b543c1b57ad5169c8ab7fcd6b0104f693", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ea68bc85e01c17bdef5a593188d7a185c6014302", "patch": "@@ -300,10 +300,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         root_id: NodeId,\n         vis: ty::Visibility,\n     ) {\n-        let parent_scope = &self.parent_scope;\n-        let current_module = parent_scope.module;\n+        let current_module = self.parent_scope.module;\n         let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -601,7 +600,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope: self.parent_scope.clone(),\n+                    parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -994,7 +993,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: this.parent_scope.clone(),\n+            parent_scope: this.parent_scope,\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -1066,11 +1065,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        let parent_scope = self.parent_scope.clone();\n-        parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let old_parent_scope =\n-            self.r.invocation_parent_scopes.insert(invoc_id, parent_scope.clone());\n+        let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n         LegacyScope::Invocation(invoc_id)\n@@ -1261,7 +1258,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope.clone()));\n+            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "8ec5d64ef3d09e1478ce00de5c594cddac21eb88", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ea68bc85e01c17bdef5a593188d7a185c6014302", "patch": "@@ -376,9 +376,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n-                        for derive in &parent_scope.derives {\n+                        for derive in parent_scope.derives {\n                             let parent_scope =\n-                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                                &ParentScope { derives: &[], ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n                                 derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {"}, {"sha": "b0944b480a2d03450a15aa9fb6cc338865b21ae8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ea68bc85e01c17bdef5a593188d7a185c6014302", "patch": "@@ -122,12 +122,12 @@ enum ScopeSet {\n /// Serves as a starting point for the scope visitor.\n /// This struct is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n-    derives: Vec<ast::Path>,\n+    derives: &'a [ast::Path],\n }\n \n impl<'a> ParentScope<'a> {\n@@ -136,7 +136,7 @@ impl<'a> ParentScope<'a> {\n             module,\n             expansion: ExpnId::root(),\n             legacy: LegacyScope::Empty,\n-            derives: Vec::new(),\n+            derives: &[],\n         }\n     }\n }\n@@ -940,6 +940,7 @@ pub struct ResolverArenas<'a> {\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    ast_paths: arena::TypedArena<ast::Path>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -966,6 +967,9 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n         self.legacy_bindings.alloc(binding)\n     }\n+    fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n+        self.ast_paths.alloc_from_iter(paths.iter().cloned())\n+    }\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n@@ -1515,7 +1519,7 @@ impl<'a> Resolver<'a> {\n                 self.hygienic_lexical_parent(module, &mut ident.span)\n             };\n             module = unwrap_or!(opt_module, break);\n-            let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+            let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n@@ -1651,7 +1655,7 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(m) => {\n                 if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }"}, {"sha": "dd8e340703115202e7db9fdfb58a6917824a33fd", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ea68bc85e01c17bdef5a593188d7a185c6014302", "patch": "@@ -118,11 +118,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n     ) {\n         // Fill in some data for derives if the fragment is from a derive container.\n-        let parent_scope = self.invocation_parent_scopes[&expansion].clone();\n+        let parent_scope = self.invocation_parent_scopes[&expansion];\n         let parent_def = self.definitions.invocation_parent(expansion);\n-        self.invocation_parent_scopes.extend(\n-            derives.iter().map(|&derive| (derive, parent_scope.clone()))\n-        );\n+        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n@@ -152,14 +150,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let parent_scope = &self.invocation_parent_scopes[&invoc_id].clone();\n+        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n         let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n+                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.path, MacroKind::Bang, Vec::new(), false),\n+                (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), false),\n+                (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of derives in the container until we know whether one of them\n                 // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n@@ -169,7 +167,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 if derives.len() > 1 {\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      parent_scope, true, force) {\n+                                                      &parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -184,7 +182,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n-        let parent_scope = &ParentScope { derives, ..parent_scope.clone() };\n+        let parent_scope = &ParentScope { derives, ..parent_scope };\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n@@ -324,7 +322,7 @@ impl<'a> Resolver<'a> {\n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n                 self.multi_segment_macro_resolutions\n-                    .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n+                    .push((path, path_span, kind, *parent_scope, res.ok()));\n             }\n \n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n@@ -341,7 +339,7 @@ impl<'a> Resolver<'a> {\n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n                 self.single_segment_macro_resolutions\n-                    .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+                    .push((path[0].ident, kind, *parent_scope, binding.ok()));\n             }\n \n             let res = binding.map(|binding| binding.res());\n@@ -410,8 +408,8 @@ impl<'a> Resolver<'a> {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                    for derive in parent_scope.derives {\n+                        let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n@@ -457,7 +455,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+                    let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,"}, {"sha": "0e3bdc1274a689afa53b8ecf0b54b6bc6a47fbdd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bc85e01c17bdef5a593188d7a185c6014302/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ea68bc85e01c17bdef5a593188d7a185c6014302", "patch": "@@ -394,7 +394,7 @@ impl<'a> Resolver<'a> {\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n                 Some(None) => {}"}]}