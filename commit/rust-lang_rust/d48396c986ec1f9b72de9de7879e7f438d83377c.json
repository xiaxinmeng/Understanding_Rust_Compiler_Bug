{"sha": "d48396c986ec1f9b72de9de7879e7f438d83377c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ODM5NmM5ODZlYzFmOWI3MmRlOWRlNzg3OWU3ZjQzOGQ4MzM3N2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-22T01:36:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-22T01:37:06Z"}, "message": "libcore: De-mode str", "tree": {"sha": "1857f4736a07c2fc56047bad1976cbccd4a84148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1857f4736a07c2fc56047bad1976cbccd4a84148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d48396c986ec1f9b72de9de7879e7f438d83377c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d48396c986ec1f9b72de9de7879e7f438d83377c", "html_url": "https://github.com/rust-lang/rust/commit/d48396c986ec1f9b72de9de7879e7f438d83377c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d48396c986ec1f9b72de9de7879e7f438d83377c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49af969e2cd4cfb36cdfb55b70bea01592b404eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/49af969e2cd4cfb36cdfb55b70bea01592b404eb", "html_url": "https://github.com/rust-lang/rust/commit/49af969e2cd4cfb36cdfb55b70bea01592b404eb"}], "stats": {"total": 341, "additions": 182, "deletions": 159}, "files": [{"sha": "39076b700298bdf3149298249086c8fd71173d79", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -104,7 +104,7 @@ fn readclose(fd: c_int) -> ~str {\n     let mut buf = ~\"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n-        str::push_str(buf, str::from_bytes(bytes));\n+        str::push_str(&mut buf, str::from_bytes(bytes));\n     }\n     os::fclose(file);\n     return buf;"}, {"sha": "d7e553073bf02665b29dbbc76982f4e82fa1080a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -141,9 +141,9 @@ fn escape_unicode(c: char) -> ~str {\n                     else { ('U', 8u) });\n     assert str::len(s) <= pad;\n     let mut out = ~\"\\\\\";\n-    str::push_str(out, str::from_char(c));\n-    for uint::range(str::len(s), pad) |_i| { str::push_str(out, ~\"0\"); }\n-    str::push_str(out, s);\n+    str::push_str(&mut out, str::from_char(c));\n+    for uint::range(str::len(s), pad) |_i| { str::push_str(&mut out, ~\"0\"); }\n+    str::push_str(&mut out, s);\n     move out\n }\n "}, {"sha": "624cb97dbca34214b150bd974b4335b0003c96a8", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -293,9 +293,9 @@ mod rt {\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                unsafe { str::unshift_char(s, '+') };\n+                unsafe { str::unshift_char(&mut s, '+') };\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unsafe { str::unshift_char(s, ' ') };\n+                unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n@@ -463,13 +463,13 @@ mod rt {\n         // instead.\n \n         if signed && zero_padding && str::len(s) > 0u {\n-            let head = str::shift_char(s);\n+            let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));\n                 return headstr + padstr + s;\n             }\n             else {\n-                str::unshift_char(s, head);\n+                str::unshift_char(&mut s, head);\n             }\n         }\n         return padstr + s;\n@@ -500,9 +500,9 @@ mod rt2 {\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                unsafe { str::unshift_char(s, '+') };\n+                unsafe { str::unshift_char(&mut s, '+') };\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unsafe { str::unshift_char(s, ' ') };\n+                unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n@@ -670,13 +670,13 @@ mod rt2 {\n         // instead.\n \n         if signed && zero_padding && str::len(s) > 0u {\n-            let head = str::shift_char(s);\n+            let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));\n                 return headstr + padstr + s;\n             }\n             else {\n-                str::unshift_char(s, head);\n+                str::unshift_char(&mut s, head);\n             }\n         }\n         return padstr + s;"}, {"sha": "e9a72ef2ba064678ac1e9ed3d83d4b81ec99b5f4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 84, "deletions": 67, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -7,9 +7,13 @@\n  * some heavy-duty uses, try std::rope.\n  */\n \n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+\n use cmp::{Eq, Ord};\n use libc::size_t;\n use io::WriterUtil;\n+use to_str::ToStr;\n \n export\n    // Creating a string\n@@ -154,7 +158,7 @@ pure fn from_byte(b: u8) -> ~str {\n }\n \n /// Appends a character at the end of a string\n-fn push_char(&s: ~str, ch: char) {\n+fn push_char(s: &const ~str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n         let nb = if code < max_one_b { 1u }\n@@ -163,11 +167,11 @@ fn push_char(&s: ~str, ch: char) {\n         else if code < max_four_b { 4u }\n         else if code < max_five_b { 5u }\n         else { 6u };\n-        let len = len(s);\n+        let len = len(*s);\n         let new_len = len + nb;\n         reserve_at_least(s, new_len);\n         let off = len;\n-        do as_buf(s) |buf, _len| {\n+        do as_buf(*s) |buf, _len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             if nb == 1u {\n                 *ptr::mut_offset(buf, off) =\n@@ -227,30 +231,30 @@ fn push_char(&s: ~str, ch: char) {\n /// Convert a char to a string\n pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe { push_char(buf, ch); }\n+    unsafe { push_char(&mut buf, ch); }\n     move buf\n }\n \n /// Convert a vector of chars to a string\n pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n-        reserve(buf, chs.len());\n+        reserve(&mut buf, chs.len());\n         for vec::each(chs) |ch| {\n-            push_char(buf, *ch);\n+            push_char(&mut buf, *ch);\n         }\n     }\n     move buf\n }\n \n /// Appends a string slice to the back of a string, without overallocating\n #[inline(always)]\n-fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n+fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n         reserve(lhs, llen + rlen);\n-        do as_buf(lhs) |lbuf, _llen| {\n+        do as_buf(*lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 let dst = ::cast::transmute_mut_unsafe(dst);\n@@ -262,12 +266,12 @@ fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n }\n /// Appends a string slice to the back of a string\n #[inline(always)]\n-fn push_str(&lhs: ~str, rhs: &str) {\n+fn push_str(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n         reserve_at_least(lhs, llen + rlen);\n-        do as_buf(lhs) |lbuf, _llen| {\n+        do as_buf(*lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 let dst = ::cast::transmute_mut_unsafe(dst);\n@@ -283,7 +287,7 @@ fn push_str(&lhs: ~str, rhs: &str) {\n pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n     unsafe {\n-        push_str_no_overallocate(v, rhs);\n+        push_str_no_overallocate(&mut v, rhs);\n     }\n     move v\n }\n@@ -293,7 +297,7 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n-        unsafe { push_str(s, *ss) };\n+        unsafe { push_str(&mut s, *ss) };\n     }\n     move s\n }\n@@ -302,8 +306,8 @@ pure fn concat(v: &[~str]) -> ~str {\n pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unsafe { push_str(s, sep); } }\n-        unsafe { push_str(s, *ss) };\n+        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n+        unsafe { push_str(&mut s, *ss) };\n     }\n     move s\n }\n@@ -319,10 +323,10 @@ Section: Adding to and removing from a string\n  *\n  * If the string does not contain any characters\n  */\n-fn pop_char(&s: ~str) -> char {\n-    let end = len(s);\n+fn pop_char(s: &const ~str) -> char {\n+    let end = len(*s);\n     assert end > 0u;\n-    let {ch, prev} = char_range_at_reverse(s, end);\n+    let {ch, prev} = char_range_at_reverse(*s, end);\n     unsafe { raw::set_len(s, prev); }\n     return ch;\n }\n@@ -334,9 +338,9 @@ fn pop_char(&s: ~str) -> char {\n  *\n  * If the string does not contain any characters\n  */\n-fn shift_char(&s: ~str) -> char {\n-    let {ch, next} = char_range_at(s, 0u);\n-    s = unsafe { raw::slice_bytes(s, next, len(s)) };\n+fn shift_char(s: &mut ~str) -> char {\n+    let {ch, next} = char_range_at(*s, 0u);\n+    *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n     return ch;\n }\n \n@@ -357,7 +361,9 @@ fn view_shift_char(s: &a/str) -> (char, &a/str) {\n }\n \n /// Prepend a char to a string\n-fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n+fn unshift_char(s: &mut ~str, ch: char) {\n+    *s = from_char(ch) + *s;\n+}\n \n /**\n  * Returns a string with leading `chars_to_trim` removed.\n@@ -666,7 +672,7 @@ pure fn lines_any(s: &str) -> ~[~str] {\n         let l = len(s);\n         let mut cp = copy s;\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            unsafe { raw::set_len(cp, l - 1u); }\n+            unsafe { raw::set_len(&mut cp, l - 1u); }\n         }\n         move cp\n     })\n@@ -707,8 +713,12 @@ pure fn to_upper(s: &str) -> ~str {\n pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n-        if first { first = false; } else { unsafe {push_str(result, to); }}\n-        unsafe { push_str(result, raw::slice_bytes(s, start, end)); }\n+        if first {\n+            first = false;\n+        } else {\n+            unsafe { push_str(&mut result, to); }\n+        }\n+        unsafe { push_str(&mut result, raw::slice_bytes(s, start, end)); }\n     }\n     move result\n }\n@@ -950,9 +960,9 @@ pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n-        reserve(result, len(ss));\n+        reserve(&mut result, len(ss));\n         for chars_each(ss) |cc| {\n-            str::push_char(result, ff(cc));\n+            str::push_char(&mut result, ff(cc));\n         }\n     }\n     move result\n@@ -1638,8 +1648,8 @@ pure fn utf16_chars(v: &[u16], f: fn(char)) {\n pure fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n-        reserve(buf, vec::len(v));\n-        utf16_chars(v, |ch| push_char(buf, ch));\n+        reserve(&mut buf, vec::len(v));\n+        utf16_chars(v, |ch| push_char(&mut buf, ch));\n     }\n     move buf\n }\n@@ -1890,9 +1900,9 @@ const tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pure fn as_bytes<T>(s: ~str, f: fn(~[u8]) -> T) -> T {\n+pure fn as_bytes<T>(s: &const ~str, f: fn(~[u8]) -> T) -> T {\n     unsafe {\n-        let v: *~[u8] = ::cast::reinterpret_cast(&ptr::addr_of(s));\n+        let v: *~[u8] = cast::transmute(copy s);\n         f(*v)\n     }\n }\n@@ -1971,9 +1981,9 @@ pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve(&s: ~str, n: uint) {\n+fn reserve(s: &const ~str, n: uint) {\n     unsafe {\n-        let v: *mut ~[u8] = ::cast::reinterpret_cast(&ptr::addr_of(s));\n+        let v: *mut ~[u8] = cast::transmute(copy s);\n         vec::reserve(*v, n + 1);\n     }\n }\n@@ -1998,15 +2008,15 @@ fn reserve(&s: ~str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve_at_least(&s: ~str, n: uint) {\n+fn reserve_at_least(s: &const ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n /**\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pure fn capacity(&&s: ~str) -> uint {\n+pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -2018,9 +2028,9 @@ pure fn capacity(&&s: ~str) -> uint {\n pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n-        reserve_at_least(out, str::len(s));\n+        reserve_at_least(&mut out, str::len(s));\n         for chars_each(s) |c| {\n-            push_str(out, char::escape_default(c));\n+            push_str(&mut out, char::escape_default(c));\n         }\n     }\n     move out\n@@ -2030,9 +2040,9 @@ pure fn escape_default(s: &str) -> ~str {\n pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n-        reserve_at_least(out, str::len(s));\n+        reserve_at_least(&mut out, str::len(s));\n         for chars_each(s) |c| {\n-            push_str(out, char::escape_unicode(c));\n+            push_str(&mut out, char::escape_unicode(c));\n         }\n     }\n     move out\n@@ -2159,42 +2169,43 @@ mod raw {\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n-    unsafe fn push_byte(&s: ~str, b: u8) {\n+    unsafe fn push_byte(s: &const ~str, b: u8) {\n         reserve_at_least(s, s.len() + 1);\n-        do as_buf(s) |buf, len| {\n+        do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             *ptr::mut_offset(buf, len) = b;\n         }\n         set_len(s, s.len() + 1);\n     }\n \n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n-    unsafe fn push_bytes(&s: ~str, bytes: ~[u8]) {\n+    unsafe fn push_bytes(s: &const ~str, bytes: &[u8]) {\n         reserve_at_least(s, s.len() + bytes.len());\n         for vec::each(bytes) |byte| { push_byte(s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn pop_byte(&s: ~str) -> u8 {\n-        let len = len(s);\n+    unsafe fn pop_byte(s: &const ~str) -> u8 {\n+        let len = len(*s);\n         assert (len > 0u);\n         let b = s[len - 1u];\n         unsafe { set_len(s, len - 1u) };\n         return b;\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn shift_byte(&s: ~str) -> u8 {\n-        let len = len(s);\n+    unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+        let len = len(*s);\n         assert (len > 0u);\n         let b = s[0];\n-        s = unsafe { raw::slice_bytes(s, 1u, len) };\n+        *s = unsafe { raw::slice_bytes(*s, 1u, len) };\n         return b;\n     }\n \n     /// Sets the length of the string and adds the null terminator\n-    unsafe fn set_len(&v: ~str, new_len: uint) {\n-        let repr: *vec::raw::VecRepr = ::cast::reinterpret_cast(&v);\n+    unsafe fn set_len(v: &const ~str, new_len: uint) {\n+        let v: **vec::raw::VecRepr = cast::transmute(copy v);\n+        let repr: *vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of((*repr).unboxed.data),\n                                    new_len);\n@@ -2457,15 +2468,15 @@ mod tests {\n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let cc = pop_char(data);\n+        let cc = pop_char(&mut data);\n         assert ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n         assert '\u534e' == cc;\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n-        let cc2 = pop_char(data2);\n+        let cc2 = pop_char(&mut data2);\n         assert ~\"\" == data2;\n         assert '\u534e' == cc2;\n     }\n@@ -2475,12 +2486,12 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_pop_char_fail() {\n         let mut data = ~\"\";\n-        let _cc3 = pop_char(data);\n+        let _cc3 = pop_char(&mut data);\n     }\n \n     #[test]\n     fn test_split_char() {\n-        fn t(s: ~str, c: char, u: ~[~str]) {\n+        fn t(s: &str, c: char, u: &[~str]) {\n             log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n             debug!(\"split_byte to: %?\", v);\n@@ -2509,7 +2520,7 @@ mod tests {\n \n     #[test]\n     fn test_splitn_char() {\n-        fn t(s: ~str, c: char, n: uint, u: ~[~str]) {\n+        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n             log(debug, ~\"splitn_byte: \" + s);\n             let v = splitn_char(s, c, n);\n             debug!(\"split_byte to: %?\", v);\n@@ -2560,9 +2571,10 @@ mod tests {\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: ~str, sep: &a/str, i: int, k: ~str) {\n+        fn t(s: &str, sep: &a/str, i: int, k: &str) {\n+            fn borrow(x: &a/str) -> &a/str { x }\n             let v = split_str(s, sep);\n-            assert v[i] == k;\n+            assert borrow(v[i]) == k;\n         }\n \n         t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n@@ -2689,8 +2701,8 @@ mod tests {\n \n     #[test]\n     fn test_substr() {\n-        fn t(a: ~str, b: ~str, start: int) {\n-            assert substr(a, start as uint, len(b)) == b;\n+        fn t(a: &str, b: &str, start: int) {\n+            assert substr(a, start as uint, len(b)) == b.to_str();\n         }\n         t(~\"hello\", ~\"llo\", 2);\n         t(~\"hello\", ~\"el\", 1);\n@@ -2699,7 +2711,9 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: ~[~str], s: ~str) { assert concat(v) == s; }\n+        fn t(v: &[~str], s: &str) {\n+            assert concat(v) == s.to_str();\n+        }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n         t(v, ~\"\");\n@@ -2708,8 +2722,8 @@ mod tests {\n \n     #[test]\n     fn test_connect() {\n-        fn t(v: ~[~str], sep: ~str, s: ~str) {\n-            assert connect(v, sep) == s;\n+        fn t(v: &[~str], sep: &str, s: &str) {\n+            assert connect(v, sep) == s.to_str();\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -2746,13 +2760,13 @@ mod tests {\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n-                while i < 100000 { push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n+                while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n                 return rs;\n             }\n             fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n-                while i < 100000 { push_str(rs, ~\"aaaaa\"); i += 1; }\n+                while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n                 return rs;\n             }\n             assert half_a_million_letter_a() ==\n@@ -2856,13 +2870,16 @@ mod tests {\n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            while i < 100000 {\n+                push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n             return rs;\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             return rs;\n         }\n         assert half_a_million_letter_X() ==\n@@ -2975,15 +2992,15 @@ mod tests {\n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { raw::shift_byte(s) };\n+        let b = unsafe { raw::shift_byte(&mut s) };\n         assert (s == ~\"BC\");\n         assert (b == 65u8);\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { raw::pop_byte(s) };\n+        let b = unsafe { raw::pop_byte(&mut s) };\n         assert (s == ~\"AB\");\n         assert (b == 67u8);\n     }\n@@ -3045,7 +3062,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         // Don't double free\n-        as_bytes::<()>(~\"\", |_bytes| fail );\n+        as_bytes::<()>(&~\"\", |_bytes| fail );\n     }\n \n     #[test]"}, {"sha": "f279945a161080c9c1670579536392ffb80aec2c", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -83,10 +83,10 @@ impl<A: ToStr> ~[A]: ToStr {\n         let mut acc = ~\"[\", first = true;\n         for vec::each(self) |elt| {\n             if first { first = false; }\n-            else { str::push_str(acc, ~\", \"); }\n-            str::push_str(acc, elt.to_str());\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n-        str::push_char(acc, ']');\n+        str::push_char(&mut acc, ']');\n         move acc\n     }\n }"}, {"sha": "402b4241cb3ca9c209cfb03e8d2828666a149182", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -14,7 +14,7 @@ impl &[u8]: ToBase64 {\n \n         let len = self.len();\n         let mut s = ~\"\";\n-        str::reserve(s, ((len + 3u) / 4u) * 3u);\n+        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n \n         let mut i = 0u;\n \n@@ -24,10 +24,10 @@ impl &[u8]: ToBase64 {\n                     (self[i + 2u] as uint);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            str::push_char(s, chars[(n >> 18u) & 63u]);\n-            str::push_char(s, chars[(n >> 12u) & 63u]);\n-            str::push_char(s, chars[(n >> 6u) & 63u]);\n-            str::push_char(s, chars[n & 63u]);\n+            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, chars[n & 63u]);\n \n             i += 3u;\n         }\n@@ -38,17 +38,17 @@ impl &[u8]: ToBase64 {\n           0 => (),\n           1 => {\n             let n = (self[i] as uint) << 16u;\n-            str::push_char(s, chars[(n >> 18u) & 63u]);\n-            str::push_char(s, chars[(n >> 12u) & 63u]);\n-            str::push_char(s, '=');\n-            str::push_char(s, '=');\n+            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, '=');\n+            str::push_char(&mut s, '=');\n           }\n           2 => {\n             let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n-            str::push_char(s, chars[(n >> 18u) & 63u]);\n-            str::push_char(s, chars[(n >> 12u) & 63u]);\n-            str::push_char(s, chars[(n >> 6u) & 63u]);\n-            str::push_char(s, '=');\n+            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, '=');\n           }\n           _ => fail ~\"Algebra is broken, please alert the math police\"\n         }"}, {"sha": "6b80aa716a07739ad0fa466dc0f50fb42a162f15", "filename": "src/libstd/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -92,7 +92,7 @@ fn to_writer(wr: io::Writer, j: Json) {\n fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n     fn spaces(n: uint) -> ~str {\n         let mut ss = ~\"\";\n-        for n.times { str::push_str(ss, \" \"); }\n+        for n.times { str::push_str(&mut ss, \" \"); }\n         return ss;\n     }\n \n@@ -428,14 +428,14 @@ impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(res, '\"'),\n-                  '\\\\' => str::push_char(res, '\\\\'),\n-                  '/' => str::push_char(res, '/'),\n-                  'b' => str::push_char(res, '\\x08'),\n-                  'f' => str::push_char(res, '\\x0c'),\n-                  'n' => str::push_char(res, '\\n'),\n-                  'r' => str::push_char(res, '\\r'),\n-                  't' => str::push_char(res, '\\t'),\n+                  '\"' => str::push_char(&mut res, '\"'),\n+                  '\\\\' => str::push_char(&mut res, '\\\\'),\n+                  '/' => str::push_char(&mut res, '/'),\n+                  'b' => str::push_char(&mut res, '\\x08'),\n+                  'f' => str::push_char(&mut res, '\\x0c'),\n+                  'n' => str::push_char(&mut res, '\\n'),\n+                  'r' => str::push_char(&mut res, '\\r'),\n+                  't' => str::push_char(&mut res, '\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -464,7 +464,7 @@ impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(res, n as char);\n+                      str::push_char(&mut res, n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -476,7 +476,7 @@ impl Parser {\n                     self.bump();\n                     return Ok(@res);\n                 }\n-                str::push_char(res, self.ch);\n+                str::push_char(&mut res, self.ch);\n             }\n         }\n "}, {"sha": "a824f5ab11740e4ba23b8aae55059d73e398385c", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -61,7 +61,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n               'a' .. 'z' |\n               '0' .. '9' |\n               '-' | '.' | '_' | '~' => {\n-                str::push_char(out, ch);\n+                str::push_char(&mut out, ch);\n               }\n               _ => {\n                   if full_url {\n@@ -72,7 +72,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(out, ch);\n+                        str::push_char(&mut out, ch);\n                       }\n \n                       _ => out += #fmt(\"%%%X\", ch as uint)\n@@ -127,18 +127,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(out, '%');\n-                        str::push_char(out, bytes[0u] as char);\n-                        str::push_char(out, bytes[1u] as char);\n+                        str::push_char(&mut out, '%');\n+                        str::push_char(&mut out, bytes[0u] as char);\n+                        str::push_char(&mut out, bytes[1u] as char);\n                       }\n \n-                      ch => str::push_char(out, ch)\n+                      ch => str::push_char(&mut out, ch)\n                     }\n                 } else {\n-                      str::push_char(out, ch);\n+                      str::push_char(&mut out, ch);\n                 }\n               }\n-              ch => str::push_char(out, ch)\n+              ch => str::push_char(&mut out, ch)\n             }\n         }\n \n@@ -170,9 +170,9 @@ fn encode_plus(s: &str) -> ~str {\n             let ch = rdr.read_byte() as char;\n             match ch {\n               'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                str::push_char(out, ch);\n+                str::push_char(&mut out, ch);\n               }\n-              ' ' => str::push_char(out, '+'),\n+              ' ' => str::push_char(&mut out, '+'),\n               _ => out += #fmt(\"%%%X\", ch as uint)\n             }\n         }\n@@ -195,7 +195,7 @@ fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n             if first {\n                 first = false;\n             } else {\n-                str::push_char(out, '&');\n+                str::push_char(&mut out, '&');\n                 first = false;\n             }\n \n@@ -248,9 +248,9 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n                 };\n \n                 if parsing_key {\n-                    str::push_char(key, ch)\n+                    str::push_char(&mut key, ch)\n                 } else {\n-                    str::push_char(value, ch)\n+                    str::push_char(&mut value, ch)\n                 }\n               }\n             }"}, {"sha": "a40db2c1f1fc2e9b573e65ed3f742e2ad97a0dc3", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -271,7 +271,10 @@ mod tests {\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { str::push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n+            while i < 100000 {\n+                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                i += 1;\n+            }\n             return rs;\n         }\n         // Test messages from FIPS 180-1"}, {"sha": "bc3f8162c4d8221b95874780396f0ffdd4a37eed", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -800,7 +800,7 @@ fn strftime(format: &str, +tm: Tm) -> ~str {\n         while !rdr.eof() {\n             match rdr.read_char() {\n                 '%' => buf += parse_type(rdr.read_char(), &tm),\n-                ch => str::push_char(buf, ch)\n+                ch => str::push_char(&mut buf, ch)\n             }\n         }\n     }"}, {"sha": "5b72bf61fdeb53579bfc8885d567edf57f79a9f5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -255,14 +255,14 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n         // indent past |name:## | and the 0-offset column location\n         let mut left = str::len(fm.name) + digits + lo.col + 3u;\n         let mut s = ~\"\";\n-        while left > 0u { str::push_char(s, ' '); left -= 1u; }\n+        while left > 0u { str::push_char(&mut s, ' '); left -= 1u; }\n \n         s += ~\"^\";\n         let hi = codemap::lookup_char_pos(cm, sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let mut width = hi.col - lo.col - 1u;\n-            while width > 0u { str::push_char(s, '~'); width -= 1u; }\n+            while width > 0u { str::push_char(&mut s, '~'); width -= 1u; }\n         }\n         io::stderr().write_str(s + ~\"\\n\");\n     }"}, {"sha": "83899b58d662e18af45b86201a89bf37956456f5", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -236,11 +236,11 @@ fn finish<T: qq_helper>\n             str2 += repl;\n         }\n         match copy state {\n-          active => str::push_char(str2, ch),\n+          active => str::push_char(&mut str2, ch),\n           skip(1u) => state = blank,\n           skip(sk) => state = skip (sk-1u),\n-          blank if is_space(ch) => str::push_char(str2, ch),\n-          blank => str::push_char(str2, ' ')\n+          blank if is_space(ch) => str::push_char(&mut str2, ch),\n+          blank => str::push_char(&mut str2, ' ')\n         }\n         i += 1u;\n         if (j < g_len && i == cx.gather[j].hi) {"}, {"sha": "7f1ec1093709fb66769be4a8c8210de5f62b7bb1", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -117,7 +117,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n fn read_to_eol(rdr: string_reader) -> ~str {\n     let mut val = ~\"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n-        str::push_char(val, rdr.curr);\n+        str::push_char(&mut val, rdr.curr);\n         bump(rdr);\n     }\n     if rdr.curr == '\\n' { bump(rdr); }\n@@ -242,7 +242,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n             curr_line = ~\"\";\n             bump(rdr);\n         } else {\n-            str::push_char(curr_line, rdr.curr);\n+            str::push_char(&mut curr_line, rdr.curr);\n             if rdr.curr == '/' && nextch(rdr) == '*' {\n                 bump(rdr);\n                 bump(rdr);"}, {"sha": "c32aaa3d474ce605e1fb73d90ca8d5be878066c5", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -214,7 +214,7 @@ fn consume_any_line_comment(rdr: string_reader)\n                 let start_chpos = rdr.chpos - 2u;\n                 let mut acc = ~\"//\";\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n-                    str::push_char(acc, rdr.curr);\n+                    str::push_char(&mut acc, rdr.curr);\n                     bump(rdr);\n                 }\n                 return Some({\n@@ -253,7 +253,7 @@ fn consume_block_comment(rdr: string_reader)\n         let start_chpos = rdr.chpos - 2u;\n         let mut acc = ~\"/*\";\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            str::push_char(acc, rdr.curr);\n+            str::push_char(&mut acc, rdr.curr);\n             bump(rdr);\n         }\n         if is_eof(rdr) {\n@@ -288,11 +288,11 @@ fn scan_exponent(rdr: string_reader) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n-        str::push_char(rslt, c);\n+        str::push_char(&mut rslt, c);\n         bump(rdr);\n         c = rdr.curr;\n         if c == '-' || c == '+' {\n-            str::push_char(rslt, c);\n+            str::push_char(&mut rslt, c);\n             bump(rdr);\n         }\n         let exponent = scan_digits(rdr, 10u);\n@@ -309,7 +309,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n         if c == '_' { bump(rdr); loop; }\n         match char::to_digit(c, radix) {\n           Some(_) => {\n-            str::push_char(rslt, c);\n+            str::push_char(&mut rslt, c);\n             bump(rdr);\n           }\n           _ => return rslt\n@@ -447,7 +447,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             || (c >= '0' && c <= '9')\n             || c == '_'\n             || (c > 'z' && char::is_XID_continue(c)) {\n-            str::push_char(accum_str, c);\n+            str::push_char(&mut accum_str, c);\n             bump(rdr);\n             c = rdr.curr;\n         }\n@@ -599,28 +599,31 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n                 let escaped = rdr.curr;\n                 bump(rdr);\n                 match escaped {\n-                  'n' => str::push_char(accum_str, '\\n'),\n-                  'r' => str::push_char(accum_str, '\\r'),\n-                  't' => str::push_char(accum_str, '\\t'),\n-                  '\\\\' => str::push_char(accum_str, '\\\\'),\n-                  '\\'' => str::push_char(accum_str, '\\''),\n-                  '\"' => str::push_char(accum_str, '\"'),\n+                  'n' => str::push_char(&mut accum_str, '\\n'),\n+                  'r' => str::push_char(&mut accum_str, '\\r'),\n+                  't' => str::push_char(&mut accum_str, '\\t'),\n+                  '\\\\' => str::push_char(&mut accum_str, '\\\\'),\n+                  '\\'' => str::push_char(&mut accum_str, '\\''),\n+                  '\"' => str::push_char(&mut accum_str, '\"'),\n                   '\\n' => consume_whitespace(rdr),\n                   'x' => {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n+                    str::push_char(&mut accum_str,\n+                                   scan_numeric_escape(rdr, 2u));\n                   }\n                   'u' => {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n+                    str::push_char(&mut accum_str,\n+                                   scan_numeric_escape(rdr, 4u));\n                   }\n                   'U' => {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n+                    str::push_char(&mut accum_str,\n+                                   scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n                     rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n                   }\n                 }\n               }\n-              _ => str::push_char(accum_str, ch)\n+              _ => str::push_char(&mut accum_str, ch)\n             }\n         }\n         bump(rdr);"}, {"sha": "e99e35b596cf76fd154ee3ab252f186c3adae703", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -2093,13 +2093,13 @@ fn fn_header_info_to_str(opt_sty: Option<ast::self_ty_>,\n     match opt_purity {\n       Some(ast::impure_fn) => { }\n       Some(purity) => {\n-        str::push_str(s, purity_to_str(purity));\n-        str::push_char(s, ' ');\n+        str::push_str(&mut s, purity_to_str(purity));\n+        str::push_char(&mut s, ' ');\n       }\n       None => {}\n     }\n \n-    str::push_str(s, opt_proto_to_str(opt_p));\n+    str::push_str(&mut s, opt_proto_to_str(opt_p));\n \n     return s;\n }"}, {"sha": "c2d4925838e55485fb55c3625137150c167efca3", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -548,10 +548,10 @@ fn sanitize(s: ~str) -> ~str {\n           'a' .. 'z'\n           | 'A' .. 'Z'\n           | '0' .. '9'\n-          | '_' => str::push_char(result,c),\n+          | '_' => str::push_char(&mut result, c),\n           _ => {\n             if c > 'z' && char::is_XID_continue(c) {\n-                str::push_char(result,c);\n+                str::push_char(&mut result, c);\n             }\n           }\n         }"}, {"sha": "67c85102cd6990e964ecc548a3757ebec49ee1dd", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -1175,7 +1175,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n     //\n     //   vec::from_slice(metadata_encoding_version) +\n \n-    (do str::as_bytes(~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n+    (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(bytes, 0, 8)\n     }) + flate::deflate_bytes(wr.buf.check_out(|buf| buf))\n }"}, {"sha": "5813aa87750c777369ba833182a80d9c33635fdd", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -44,8 +44,8 @@ fn make_random_fasta(wr: io::Writer, id: ~str, desc: ~str, genelist: ~[aminoacid\n     let rng = @{mut last: rand::Rng().next()};\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n-        str::push_char(op, select_random(myrandom_next(rng, 100u32),\n-                                         genelist));\n+        str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),\n+                                              genelist));\n         if str::len(op) >= LINE_LENGTH() {\n             wr.write_line(op);\n             op = ~\"\";\n@@ -59,7 +59,7 @@ fn make_repeat_fasta(wr: io::Writer, id: ~str, desc: ~str, s: ~str, n: int) unsa\n     let mut op: ~str = ~\"\";\n     let sl: uint = str::len(s);\n     for uint::range(0u, n as uint) |i| {\n-        str::raw::push_byte(op, s[i % sl]);\n+        str::raw::push_byte(&mut op, s[i % sl]);\n         if str::len(op) >= LINE_LENGTH() {\n             wr.write_line(op);\n             op = ~\"\";"}, {"sha": "63210c0d8aa9f6adf52c618612113be4bc4438ac", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48396c986ec1f9b72de9de7879e7f438d83377c/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=d48396c986ec1f9b72de9de7879e7f438d83377c", "patch": "@@ -18,12 +18,12 @@ fn main() {\n     assert (!str::is_utf8(~[0xc0_u8, 0x10_u8]));\n \n     let mut stack = ~\"a\u00d7c\u20ac\";\n-    assert (str::pop_char(stack) == '\u20ac');\n-    assert (str::pop_char(stack) == 'c');\n-    str::push_char(stack, 'u');\n+    assert (str::pop_char(&mut stack) == '\u20ac');\n+    assert (str::pop_char(&mut stack) == 'c');\n+    str::push_char(&mut stack, 'u');\n     assert (stack == ~\"a\u00d7u\");\n-    assert (str::shift_char(stack) == 'a');\n-    assert (str::shift_char(stack) == '\u00d7');\n-    str::unshift_char(stack, '\u00df');\n+    assert (str::shift_char(&mut stack) == 'a');\n+    assert (str::shift_char(&mut stack) == '\u00d7');\n+    str::unshift_char(&mut stack, '\u00df');\n     assert (stack == ~\"\u00dfu\");\n }"}]}