{"sha": "cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMDU1NjEwNDhmMDdhZTVlOTliMjViYmU1ZGIwNGVlYmUwYzdjZDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-12T21:00:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-12T21:49:21Z"}, "message": "detect wrong number of args when type-checking a closure\n\nInstead of creating inference variables for those argument types, use\nthe trait error-reporting code to give a nicer error.", "tree": {"sha": "e919e219f99fa2db1acdf1970343d7d3751d375d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e919e219f99fa2db1acdf1970343d7d3751d375d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "html_url": "https://github.com/rust-lang/rust/commit/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd10ef7b27e7c6ab6e4e68898aa6ccd240fc57f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd10ef7b27e7c6ab6e4e68898aa6ccd240fc57f3", "html_url": "https://github.com/rust-lang/rust/commit/bd10ef7b27e7c6ab6e4e68898aa6ccd240fc57f3"}], "stats": {"total": 218, "additions": 191, "deletions": 27}, "files": [{"sha": "f3aab4020594b81b60dbf12e948cad3ad854896d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "patch": "@@ -747,7 +747,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyTuple(ref tys, _) => tys.iter()\n                         .map(|t| match t.sty {\n                             ty::TypeVariants::TyTuple(ref tys, _) => ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 tys.iter()\n                                     .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n                                     .collect::<Vec<_>>()\n@@ -815,7 +815,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n         match node {\n             hir::map::NodeExpr(&hir::Expr {\n                 node: hir::ExprClosure(_, ref _decl, id, span, _),\n@@ -829,7 +833,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ..\n                         } = arg.pat.clone().into_inner() {\n                             ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 args.iter().map(|pat| {\n                                     let snippet = self.tcx.sess.codemap()\n                                         .span_to_snippet(pat.span).unwrap();\n@@ -862,7 +866,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().into_inner().node {\n                     hir::TyTup(ref tys) => ArgKind::Tuple(\n-                        arg.span,\n+                        Some(arg.span),\n                         tys.iter()\n                             .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n                             .collect::<Vec<_>>(),\n@@ -874,7 +878,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_arg_count_mismatch(\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n@@ -1363,13 +1370,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-enum ArgKind {\n+/// Summarizes information\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n     Arg(String, String),\n-    Tuple(Span, Vec<(String, String)>),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n }\n \n impl ArgKind {\n     fn empty() -> ArgKind {\n         ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n     }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. This has no name (`_`) and no source spans..\n+    pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n+        match t.sty {\n+            ty::TyTuple(ref tys, _) => ArgKind::Tuple(\n+                None,\n+                tys.iter()\n+                   .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n+                   .collect::<Vec<_>>()\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", t.sty)),\n+        }\n+    }\n }"}, {"sha": "a80e91df03de17067e29a17c2a64edaac7dc0890", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "patch": "@@ -49,7 +49,7 @@ pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n \n mod coherence;\n-mod error_reporting;\n+pub mod error_reporting;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "794d466ee7cdbf5b47d206efea90f9d90b5a3903", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 112, "deletions": 19, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "patch": "@@ -17,14 +17,24 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use rustc::traits::error_reporting::ArgKind;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use rustc::ty::subst::Substs;\n use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n+use syntax::codemap::Span;\n use rustc::hir;\n \n+/// What signature do we *expect* the closure to have from context?\n+#[derive(Debug)]\n+struct ExpectedSig<'tcx> {\n+    /// Span that gave us this expectation, if we know that.\n+    cause_span: Option<Span>,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n struct ClosureSignatures<'tcx> {\n     bound_sig: ty::PolyFnSig<'tcx>,\n     liberated_sig: ty::FnSig<'tcx>,\n@@ -63,7 +73,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         decl: &'gcx hir::FnDecl,\n         body: &'gcx hir::Body,\n         gen: Option<hir::GeneratorMovability>,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_closure(opt_kind={:?}, expected_sig={:?})\",\n@@ -160,10 +170,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_type\n     }\n \n+    /// Given the expected type, figures out what it can about this closure we\n+    /// are about to type check:\n     fn deduce_expectations_from_expected_type(\n         &self,\n         expected_ty: Ty<'tcx>,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         debug!(\n             \"deduce_expectations_from_expected_type(expected_ty={:?})\",\n             expected_ty\n@@ -175,7 +187,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n-                        self.deduce_sig_from_projection(&pb)\n+                        self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n                 let kind = object_type\n@@ -184,15 +196,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n-            ty::TyFnPtr(sig) => (Some(sig.skip_binder().clone()), Some(ty::ClosureKind::Fn)),\n+            ty::TyFnPtr(sig) => {\n+                let expected_sig = ExpectedSig {\n+                    cause_span: None,\n+                    sig: sig.skip_binder().clone(),\n+                };\n+                (Some(expected_sig), Some(ty::ClosureKind::Fn))\n+            }\n             _ => (None, None),\n         }\n     }\n \n     fn deduce_expectations_from_obligations(\n         &self,\n         expected_vid: ty::TyVid,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n@@ -212,7 +230,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(ref proj_predicate) => {\n                         let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n                         self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                            .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n+                            .and_then(|_| {\n+                                self.deduce_sig_from_projection(\n+                                    Some(obligation.cause.span),\n+                                    proj_predicate,\n+                                )\n+                            })\n                     }\n                     _ => None,\n                 }\n@@ -262,10 +285,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n+    ///\n+    /// The `cause_span` should be the span that caused us to\n+    /// have this expected signature, or `None` if we can't readily\n+    /// know that.\n     fn deduce_sig_from_projection(\n         &self,\n+        cause_span: Option<Span>,\n         projection: &ty::PolyProjectionPredicate<'tcx>,\n-    ) -> Option<ty::FnSig<'tcx>> {\n+    ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n@@ -297,16 +325,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_param_ty\n         );\n \n-        let fn_sig = self.tcx.mk_fn_sig(\n+        let sig = self.tcx.mk_fn_sig(\n             input_tys.cloned(),\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         );\n-        debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n+        debug!(\"deduce_sig_from_projection: sig {:?}\", sig);\n \n-        Some(fn_sig)\n+        Some(ExpectedSig { cause_span, sig })\n     }\n \n     fn self_type_matches_expected_vid(\n@@ -330,7 +358,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n             self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n@@ -406,7 +434,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: ty::FnSig<'tcx>,\n+        expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\n             \"sig_of_closure_with_expectation(expected_sig={:?})\",\n@@ -416,20 +444,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n-        if expected_sig.variadic != decl.variadic {\n-            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n-        } else if expected_sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n-            // we could probably handle this case more gracefully\n+        if expected_sig.sig.variadic != decl.variadic {\n             return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        } else if expected_sig.sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+            return self.sig_of_closure_with_mismatched_number_of_arguments(\n+                expr_def_id,\n+                decl,\n+                body,\n+                expected_sig,\n+            );\n         }\n \n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.has_regions_escaping_depth(1));\n+        assert!(!expected_sig.sig.has_regions_escaping_depth(1));\n         let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n-            expected_sig.inputs().iter().cloned(),\n-            expected_sig.output(),\n+            expected_sig.sig.inputs().iter().cloned(),\n+            expected_sig.sig.output(),\n             decl.variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n@@ -455,6 +487,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_sigs\n     }\n \n+    fn sig_of_closure_with_mismatched_number_of_arguments(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: ExpectedSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        let expr_map_node = self.tcx.hir.get_if_local(expr_def_id).unwrap();\n+        let expected_args: Vec<_> = expected_sig\n+            .sig\n+            .inputs()\n+            .iter()\n+            .map(|ty| ArgKind::from_expected_ty(ty))\n+            .collect();\n+        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n+        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        self.report_arg_count_mismatch(\n+            expected_span,\n+            Some(closure_span),\n+            expected_args,\n+            found_args,\n+            true,\n+        ).emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl);\n+\n+        self.closure_sigs(expr_def_id, body, error_sig)\n+    }\n+\n     /// Enforce the user's types against the expectation.  See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n@@ -560,6 +621,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n+    /// Converts the types that the user supplied, in case that doing\n+    /// so should yield an error, but returns back a signature where\n+    /// all parameters are of type `TyErr`.\n+    fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+        let astconv: &AstConv = self;\n+\n+        let supplied_arguments = decl.inputs.iter().map(|a| {\n+            // Convert the types that the user supplied (if any), but ignore them.\n+            astconv.ast_ty_to_ty(a);\n+            self.tcx.types.err\n+        });\n+\n+        match decl.output {\n+            hir::Return(ref output) => {\n+                astconv.ast_ty_to_ty(&output);\n+            }\n+            hir::DefaultReturn(_) => {}\n+        }\n+\n+        let result = ty::Binder(self.tcx.mk_fn_sig(\n+            supplied_arguments,\n+            self.tcx.types.err,\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n+\n+        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+\n+        result\n+    }\n+\n     fn closure_sigs(\n         &self,\n         expr_def_id: DefId,"}, {"sha": "b6463ca067b7f5c7eb1faba7e36f396e7ca3e8c8", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs?ref=cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #47244: in this specific scenario, when the\n+// expected type indicated 1 argument but the closure takes two, we\n+// would (early on) create type variables for the type of `b`. If the\n+// user then attempts to invoke a method on `b`, we would get an error\n+// saying that the type of `b` must be known, which was not very\n+// helpful.\n+\n+use std::collections::HashMap;\n+fn main() {\n+\n+    let m = HashMap::new();\n+    m.insert( \"foo\", \"bar\" );\n+\n+    m.iter().map( |_, b| {\n+        //~^ ERROR closure is expected to take a single 2-tuple\n+\n+        b.to_string()\n+    });\n+}"}, {"sha": "34934b8d19598c43e07d750c32dadc2f68746682", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr?ref=cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "patch": "@@ -0,0 +1,14 @@\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count-expected-type-issue-47244.rs:24:14\n+   |\n+24 |     m.iter().map( |_, b| {\n+   |              ^^^  ------ takes 2 distinct arguments\n+   |              |\n+   |              expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+24 |     m.iter().map( |(_, b)| {\n+   |                   ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}