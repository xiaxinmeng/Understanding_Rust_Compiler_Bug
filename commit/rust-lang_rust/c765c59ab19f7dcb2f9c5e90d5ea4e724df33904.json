{"sha": "c765c59ab19f7dcb2f9c5e90d5ea4e724df33904", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjVjNTlhYjE5ZjdkY2IyZjljNWU5MGQ1ZWE0ZTcyNGRmMzM5MDQ=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-10-09T23:59:17Z"}, "committer": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-10-09T23:59:17Z"}, "message": "core::str - making StrSlice trait functions pure", "tree": {"sha": "ee390a644cb0b774e8e2aeba33d2ad1df0bcb086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee390a644cb0b774e8e2aeba33d2ad1df0bcb086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904", "html_url": "https://github.com/rust-lang/rust/commit/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904/comments", "author": null, "committer": null, "parents": [{"sha": "cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "html_url": "https://github.com/rust-lang/rust/commit/cd6f24f9d14ac90d167386a56e7a6ac1f0318195"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "1256e5b5617cc66f26150ef29ecde25397e37e25", "filename": "src/libcore/str.rs", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765c59ab19f7dcb2f9c5e90d5ea4e724df33904/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c765c59ab19f7dcb2f9c5e90d5ea4e724df33904", "patch": "@@ -1361,7 +1361,7 @@ pub pure fn is_whitespace(s: &str) -> bool {\n  *\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n-fn is_alphanumeric(s: &str) -> bool {\n+pure fn is_alphanumeric(s: &str) -> bool {\n     return all(s, char::is_alphanumeric);\n }\n \n@@ -2030,22 +2030,22 @@ pub mod raw {\n }\n \n pub trait UniqueStr {\n-    fn trim() -> self;\n-    fn trim_left() -> self;\n-    fn trim_right() -> self;\n+    pure fn trim() -> self;\n+    pure fn trim_left() -> self;\n+    pure fn trim_right() -> self;\n }\n \n /// Extension methods for strings\n impl ~str: UniqueStr {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    fn trim() -> ~str { trim(self) }\n+    pure fn trim() -> ~str { trim(self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    fn trim_left() -> ~str { trim_left(self) }\n+    pure fn trim_left() -> ~str { trim_left(self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    fn trim_right() -> ~str { trim_right(self) }\n+    pure fn trim_right() -> ~str { trim_right(self) }\n }\n \n #[cfg(notest)]\n@@ -2062,33 +2062,33 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    fn all(it: fn(char) -> bool) -> bool;\n-    fn any(it: fn(char) -> bool) -> bool;\n-    fn contains(needle: &a/str) -> bool;\n-    fn contains_char(needle: char) -> bool;\n-    fn each(it: fn(u8) -> bool);\n-    fn eachi(it: fn(uint, u8) -> bool);\n-    fn each_char(it: fn(char) -> bool);\n-    fn each_chari(it: fn(uint, char) -> bool);\n-    fn ends_with(needle: &str) -> bool;\n-    fn is_empty() -> bool;\n-    fn is_not_empty() -> bool;\n-    fn is_whitespace() -> bool;\n-    fn is_alphanumeric() -> bool;\n+    pure fn all(it: fn(char) -> bool) -> bool;\n+    pure fn any(it: fn(char) -> bool) -> bool;\n+    pure fn contains(needle: &a/str) -> bool;\n+    pure fn contains_char(needle: char) -> bool;\n+    pure fn each(it: fn(u8) -> bool);\n+    pure fn eachi(it: fn(uint, u8) -> bool);\n+    pure fn each_char(it: fn(char) -> bool);\n+    pure fn each_chari(it: fn(uint, char) -> bool);\n+    pure fn ends_with(needle: &str) -> bool;\n+    pure fn is_empty() -> bool;\n+    pure fn is_not_empty() -> bool;\n+    pure fn is_whitespace() -> bool;\n+    pure fn is_alphanumeric() -> bool;\n     pure fn len() -> uint;\n     pure fn slice(begin: uint, end: uint) -> ~str;\n-    fn split(sepfn: fn(char) -> bool) -> ~[~str];\n-    fn split_char(sep: char) -> ~[~str];\n-    fn split_str(sep: &a/str) -> ~[~str];\n-    fn starts_with(needle: &a/str) -> bool;\n-    fn substr(begin: uint, n: uint) -> ~str;\n+    pure fn split(sepfn: fn(char) -> bool) -> ~[~str];\n+    pure fn split_char(sep: char) -> ~[~str];\n+    pure fn split_str(sep: &a/str) -> ~[~str];\n+    pure fn starts_with(needle: &a/str) -> bool;\n+    pure fn substr(begin: uint, n: uint) -> ~str;\n     pure fn to_lower() -> ~str;\n     pure fn to_upper() -> ~str;\n-    fn escape_default() -> ~str;\n-    fn escape_unicode() -> ~str;\n-    fn trim() -> ~str;\n-    fn trim_left() -> ~str;\n-    fn trim_right() -> ~str;\n+    pure fn escape_default() -> ~str;\n+    pure fn escape_unicode() -> ~str;\n+    pure fn trim() -> ~str;\n+    pure fn trim_left() -> ~str;\n+    pure fn trim_right() -> ~str;\n     pure fn to_unique() -> ~str;\n     pure fn char_at(i: uint) -> char;\n }\n@@ -2100,54 +2100,56 @@ impl &str: StrSlice {\n      * contains no characters\n      */\n     #[inline]\n-    fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n+    pure fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n+    pure fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    fn contains(needle: &a/str) -> bool { contains(self, needle) }\n+    pure fn contains(needle: &a/str) -> bool { contains(self, needle) }\n     /// Returns true if a string contains a char\n     #[inline]\n-    fn contains_char(needle: char) -> bool { contains_char(self, needle) }\n+    pure fn contains_char(needle: char) -> bool {\n+        contains_char(self, needle)\n+    }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    fn each(it: fn(u8) -> bool) { each(self, it) }\n+    pure fn each(it: fn(u8) -> bool) { each(self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n+    pure fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n     /// Iterate over the chars in a string\n     #[inline]\n-    fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n+    pure fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n+    pure fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n     /// Returns true if one string ends with another\n     #[inline]\n-    fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n+    pure fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n     /// Returns true if the string has length 0\n     #[inline]\n-    fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty() -> bool { is_empty(self) }\n     /// Returns true if the string has length greater than 0\n     #[inline]\n-    fn is_not_empty() -> bool { is_not_empty(self) }\n+    pure fn is_not_empty() -> bool { is_not_empty(self) }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n      * Whitespace characters are determined by `char::is_whitespace`\n      */\n     #[inline]\n-    fn is_whitespace() -> bool { is_whitespace(self) }\n+    pure fn is_whitespace() -> bool { is_whitespace(self) }\n     /**\n      * Returns true if the string contains only alphanumerics\n      *\n      * Alphanumeric characters are determined by `char::is_alphanumeric`\n      */\n     #[inline]\n-    fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n+    pure fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n     #[inline]\n     /// Returns the size in bytes not counting the null terminator\n     pure fn len() -> uint { len(self) }\n@@ -2162,29 +2164,29 @@ impl &str: StrSlice {\n     pure fn slice(begin: uint, end: uint) -> ~str { slice(self, begin, end) }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n+    pure fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n+    pure fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n+    pure fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n+    pure fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n     /**\n      * Take a substring of another.\n      *\n      * Returns a string containing `n` characters starting at byte offset\n      * `begin`.\n      */\n     #[inline]\n-    fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n+    pure fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n     /// Convert a string to lowercase\n     #[inline]\n     pure fn to_lower() -> ~str { to_lower(self) }\n@@ -2193,20 +2195,20 @@ impl &str: StrSlice {\n     pure fn to_upper() -> ~str { to_upper(self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    fn escape_default() -> ~str { escape_default(self) }\n+    pure fn escape_default() -> ~str { escape_default(self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    fn escape_unicode() -> ~str { escape_unicode(self) }\n+    pure fn escape_unicode() -> ~str { escape_unicode(self) }\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    fn trim() -> ~str { trim(self) }\n+    pure fn trim() -> ~str { trim(self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    fn trim_left() -> ~str { trim_left(self) }\n+    pure fn trim_left() -> ~str { trim_left(self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    fn trim_right() -> ~str { trim_right(self) }\n+    pure fn trim_right() -> ~str { trim_right(self) }\n \n     #[inline]\n     pure fn to_unique() -> ~str { self.slice(0, self.len()) }"}]}