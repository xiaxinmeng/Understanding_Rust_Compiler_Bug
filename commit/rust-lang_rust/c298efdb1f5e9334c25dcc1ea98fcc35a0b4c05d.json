{"sha": "c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOThlZmRiMWY1ZTkzMzRjMjVkY2MxZWE5OGZjYzM1YTBiNGMwNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-05T03:06:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-05T03:06:33Z"}, "message": "Auto merge of #28748 - nikomatsakis:universal-mir, r=pnkfelix\n\nI had to fix a few things. Notable changes:\r\n\r\n1. I removed the MIR support for constants, instead falling back to the existing `ConstVal`. I still think we ought to reform how we handle constants, but it's not clear to me that the approach I was taking is correct, and anyway I think we ought to do it separately.\r\n2. I adjusted how we handle bindings in matches: we now *declare* all the bindings up front, rather than doing it as we encounter them. This is not only simpler, since we don't have to check if a binding has already been declared, it avoids ICEs if any of the arms turn out to be unreachable.\r\n3. I do MIR construction *after* `check_match`, because it detects various broken cases. I'd like for `check_match` to be subsumed by MIR construction, but we can do that as a separate PR (if indeed it makes sense).\r\n\r\nI did a crater run and found no regressions in the wild: https://gist.github.com/nikomatsakis/0038f90e10c8ad00f2f8", "tree": {"sha": "73f9126b129198f1c4e7f1da93f49f4b3f29def2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73f9126b129198f1c4e7f1da93f49f4b3f29def2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "html_url": "https://github.com/rust-lang/rust/commit/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0db2bc63ba72b11db0112468a1c08ff68aaa6ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/0db2bc63ba72b11db0112468a1c08ff68aaa6ada", "html_url": "https://github.com/rust-lang/rust/commit/0db2bc63ba72b11db0112468a1c08ff68aaa6ada"}, {"sha": "7e1e830a6f6f32b053b71ac628c0fbf8698ad888", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1e830a6f6f32b053b71ac628c0fbf8698ad888", "html_url": "https://github.com/rust-lang/rust/commit/7e1e830a6f6f32b053b71ac628c0fbf8698ad888"}], "stats": {"total": 495, "additions": 201, "deletions": 294}, "files": [{"sha": "acda0fe2f0e3532ffd25fe837616a220e6caa5d5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -38,6 +38,7 @@ use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n+use std::mem::transmute;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64};\n use std::rc::Rc;\n \n@@ -242,7 +243,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug)]\n pub enum ConstVal {\n     Float(f64),\n     Int(i64),\n@@ -254,6 +255,27 @@ pub enum ConstVal {\n     Tuple(ast::NodeId),\n }\n \n+/// Note that equality for `ConstVal` means that the it is the same\n+/// constant, not that the rust values are equal. In particular, `NaN\n+/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+/// are considering unequal).\n+impl PartialEq for ConstVal {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn eq(&self, other: &ConstVal) -> bool {\n+        match (self, other) {\n+            (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n+            (&Int(a), &Int(b)) => a == b,\n+            (&Uint(a), &Uint(b)) => a == b,\n+            (&Str(ref a), &Str(ref b)) => a == b,\n+            (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n+            (&Bool(a), &Bool(b)) => a == b,\n+            (&Struct(a), &Struct(b)) => a == b,\n+            (&Tuple(a), &Tuple(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl ConstVal {\n     pub fn description(&self) -> &'static str {\n         match *self {"}, {"sha": "64d09a2365869aa0f033f3ee566374401de29bba", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -718,9 +718,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         // passes are timed inside typeck\n         typeck::check_crate(tcx, trait_map);\n \n-        time(time_passes, \"MIR dump\", ||\n-             mir::dump::dump_crate(tcx));\n-\n         time(time_passes, \"const checking\", ||\n             middle::check_const::check_crate(tcx));\n \n@@ -741,6 +738,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         time(time_passes, \"match checking\", ||\n             middle::check_match::check_crate(tcx));\n \n+        time(time_passes, \"MIR dump\", ||\n+             mir::dump::dump_crate(tcx));\n+\n         time(time_passes, \"liveness checking\", ||\n             middle::liveness::check_crate(tcx));\n "}, {"sha": "6cc99a56933d68e22a022b8bb09bb1eecf50ed3c", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 9, "deletions": 88, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -10,8 +10,6 @@\n \n //! See docs in build/expr/mod.rs\n \n-use rustc_data_structures::fnv::FnvHashMap;\n-\n use build::{Builder};\n use hair::*;\n use repr::*;\n@@ -28,93 +26,16 @@ impl<H:Hair> Builder<H> {\n \n     fn expr_as_constant(&mut self, expr: Expr<H>) -> Constant<H> {\n         let this = self;\n-        let Expr { ty: _, temp_lifetime: _, span, kind } = expr;\n-        let kind = match kind {\n-            ExprKind::Scope { extent: _, value } => {\n-                return this.as_constant(value);\n-            }\n-            ExprKind::Literal { literal } => {\n-                ConstantKind::Literal(literal)\n-            }\n-            ExprKind::Vec { fields } => {\n-                let fields = this.as_constants(fields);\n-                ConstantKind::Aggregate(AggregateKind::Vec, fields)\n-            }\n-            ExprKind::Tuple { fields } => {\n-                let fields = this.as_constants(fields);\n-                ConstantKind::Aggregate(AggregateKind::Tuple, fields)\n-            }\n-            ExprKind::Adt { adt_def, variant_index, substs, fields, base: None } => {\n-                let field_names = this.hir.fields(adt_def, variant_index);\n-                let fields = this.named_field_constants(field_names, fields);\n-                ConstantKind::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs), fields)\n-            }\n-            ExprKind::Repeat { value, count } => {\n-                let value = Box::new(this.as_constant(value));\n-                let count = Box::new(this.as_constant(count));\n-                ConstantKind::Repeat(value, count)\n-            }\n-            ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = Box::new(this.as_constant(lhs));\n-                let rhs = Box::new(this.as_constant(rhs));\n-                ConstantKind::BinaryOp(op, lhs, rhs)\n-            }\n-            ExprKind::Unary { op, arg } => {\n-                let arg = Box::new(this.as_constant(arg));\n-                ConstantKind::UnaryOp(op, arg)\n-            }\n-            ExprKind::Field { lhs, name } => {\n-                let lhs = this.as_constant(lhs);\n-                ConstantKind::Projection(\n-                    Box::new(ConstantProjection {\n-                        base: lhs,\n-                        elem: ProjectionElem::Field(name),\n-                    }))\n-            }\n-            ExprKind::Deref { arg } => {\n-                let arg = this.as_constant(arg);\n-                ConstantKind::Projection(\n-                    Box::new(ConstantProjection {\n-                        base: arg,\n-                        elem: ProjectionElem::Deref,\n-                    }))\n-            }\n-            ExprKind::Call { fun, args } => {\n-                let fun = this.as_constant(fun);\n-                let args = this.as_constants(args);\n-                ConstantKind::Call(Box::new(fun), args)\n-            }\n-            _ => {\n+        let Expr { ty, temp_lifetime: _, span, kind } = expr;\n+        match kind {\n+            ExprKind::Scope { extent: _, value } =>\n+                this.as_constant(value),\n+            ExprKind::Literal { literal } =>\n+                Constant { span: span, ty: ty, literal: literal },\n+            _ =>\n                 this.hir.span_bug(\n                     span,\n-                    &format!(\"expression is not a valid constant {:?}\", kind));\n-            }\n-        };\n-        Constant { span: span, kind: kind }\n-    }\n-\n-    fn as_constants(&mut self,\n-                    exprs: Vec<ExprRef<H>>)\n-                    -> Vec<Constant<H>>\n-    {\n-        exprs.into_iter().map(|expr| self.as_constant(expr)).collect()\n-    }\n-\n-    fn named_field_constants(&mut self,\n-                             field_names: Vec<Field<H>>,\n-                             field_exprs: Vec<FieldExprRef<H>>)\n-                             -> Vec<Constant<H>>\n-    {\n-        let fields_map: FnvHashMap<_, _> =\n-            field_exprs.into_iter()\n-                       .map(|f| (f.name, self.as_constant(f.expr)))\n-                       .collect();\n-\n-        let fields: Vec<_> =\n-            field_names.into_iter()\n-                       .map(|n| fields_map[&n].clone())\n-                       .collect();\n-\n-        fields\n+                    &format!(\"expression is not a valid constant {:?}\", kind)),\n+        }\n     }\n }"}, {"sha": "61eeac30c0f1dae66374204cde3c877f5ad283fc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -99,14 +99,16 @@ impl<H:Hair> Builder<H> {\n                     true_block, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n-                        kind: ConstantKind::Literal(Literal::Bool { value: true }),\n+                        ty: this.hir.bool_ty(),\n+                        literal: this.hir.true_literal(),\n                     });\n \n                 this.cfg.push_assign_constant(\n                     false_block, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n-                        kind: ConstantKind::Literal(Literal::Bool { value: false }),\n+                        ty: this.hir.bool_ty(),\n+                        literal: this.hir.false_literal(),\n                     });\n \n                 this.cfg.terminate(true_block, Terminator::Goto { target: join_block });"}, {"sha": "4d0acd5fac9244bafd0c02c49a6407260b0ea260", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 71, "deletions": 59, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -34,10 +34,20 @@ impl<H:Hair> Builder<H> {\n         let discriminant_lvalue =\n             unpack!(block = self.as_lvalue(block, discriminant));\n \n-        let arm_blocks: Vec<BasicBlock> =\n-            arms.iter()\n-                .map(|_| self.cfg.start_new_block())\n-                .collect();\n+        // Before we do anything, create uninitialized variables with\n+        // suitable extent for all of the bindings in this match. It's\n+        // easiest to do this up front because some of these arms may\n+        // be unreachable or reachable multiple times.\n+        let var_extent = self.extent_of_innermost_scope().unwrap();\n+        for arm in &arms {\n+            self.declare_bindings(var_extent, arm.patterns[0].clone());\n+        }\n+\n+        let mut arm_blocks = ArmBlocks {\n+            blocks: arms.iter()\n+                        .map(|_| self.cfg.start_new_block())\n+                        .collect(),\n+        };\n \n         let arm_bodies: Vec<ExprRef<H>> =\n             arms.iter()\n@@ -51,35 +61,33 @@ impl<H:Hair> Builder<H> {\n         // reverse of the order in which candidates are written in the\n         // source.\n         let candidates: Vec<Candidate<H>> =\n-            arms.into_iter()\n-                .zip(arm_blocks.iter())\n+            arms.iter()\n+                .enumerate()\n                 .rev() // highest priority comes last\n-                .flat_map(|(arm, &arm_block)| {\n-                    let guard = arm.guard;\n-                    arm.patterns.into_iter()\n+                .flat_map(|(arm_index, arm)| {\n+                    arm.patterns.iter()\n                                 .rev()\n-                                .map(move |pat| (arm_block, pat, guard.clone()))\n+                                .map(move |pat| (arm_index, pat.clone(), arm.guard.clone()))\n                 })\n-                .map(|(arm_block, pattern, guard)| {\n+                .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n                         match_pairs: vec![self.match_pair(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n-                        arm_block: arm_block,\n+                        arm_index: arm_index,\n                     }\n                 })\n                 .collect();\n \n         // this will generate code to test discriminant_lvalue and\n         // branch to the appropriate arm block\n-        let var_extent = self.extent_of_innermost_scope().unwrap();\n-        self.match_candidates(span, var_extent, candidates, block);\n+        self.match_candidates(span, &mut arm_blocks, candidates, block);\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        for (arm_body, &arm_block) in arm_bodies.into_iter().zip(arm_blocks.iter()) {\n-            let mut arm_block = arm_block;\n+        for (arm_index, arm_body) in arm_bodies.into_iter().enumerate() {\n+            let mut arm_block = arm_blocks.blocks[arm_index];\n             unpack!(arm_block = self.into(destination, arm_block, arm_body));\n             self.cfg.terminate(arm_block, Terminator::Goto { target: end_block });\n         }\n@@ -122,12 +130,15 @@ impl<H:Hair> Builder<H> {\n                                initializer: &Lvalue<H>)\n                                -> BlockAnd<()>\n     {\n+        // first, creating the bindings\n+        self.declare_bindings(var_extent, irrefutable_pat.clone());\n+\n         // create a dummy candidate\n         let mut candidate = Candidate::<H> {\n-            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat)],\n+            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat.clone())],\n             bindings: vec![],\n             guard: None,\n-            arm_block: block\n+            arm_index: 0, // since we don't call `match_candidates`, this field is unused\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n@@ -142,44 +153,50 @@ impl<H:Hair> Builder<H> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+        self.bind_matched_candidate(block, candidate.bindings);\n \n         block.unit()\n     }\n \n-    pub fn declare_uninitialized_variables(&mut self,\n-                                           var_extent: H::CodeExtent,\n-                                           pattern: PatternRef<H>)\n+    pub fn declare_bindings(&mut self,\n+                            var_extent: H::CodeExtent,\n+                            pattern: PatternRef<H>)\n     {\n         let pattern = self.hir.mirror(pattern);\n         match pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n                 self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n                 if let Some(subpattern) = subpattern {\n-                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                    self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n             PatternKind::Array { prefix, slice, suffix } |\n             PatternKind::Slice { prefix, slice, suffix } => {\n                 for subpattern in prefix.into_iter().chain(slice).chain(suffix) {\n-                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                    self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { subpattern } => {\n-                self.declare_uninitialized_variables(var_extent, subpattern);\n+                self.declare_bindings(var_extent, subpattern);\n             }\n             PatternKind::Leaf { subpatterns } |\n             PatternKind::Variant { subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_uninitialized_variables(var_extent, subpattern.pattern);\n+                    self.declare_bindings(var_extent, subpattern.pattern);\n                 }\n             }\n         }\n     }\n }\n \n+/// List of blocks for each arm (and potentially other metadata in the\n+/// future).\n+struct ArmBlocks {\n+    blocks: Vec<BasicBlock>,\n+}\n+\n #[derive(Clone, Debug)]\n struct Candidate<H:Hair> {\n     // all of these must be satisfied...\n@@ -191,8 +208,8 @@ struct Candidate<H:Hair> {\n     // ...and the guard must be evaluated...\n     guard: Option<ExprRef<H>>,\n \n-    // ...and then we branch here.\n-    arm_block: BasicBlock,\n+    // ...and then we branch to arm with this index.\n+    arm_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -221,10 +238,10 @@ enum TestKind<H:Hair> {\n     Switch { adt_def: H::AdtDef },\n \n     // test for equality\n-    Eq { value: Constant<H>, ty: H::Ty },\n+    Eq { value: Literal<H>, ty: H::Ty },\n \n     // test whether the value falls within an inclusive range\n-    Range { lo: Constant<H>, hi: Constant<H>, ty: H::Ty },\n+    Range { lo: Literal<H>, hi: Literal<H>, ty: H::Ty },\n \n     // test length of the slice is equal to len\n     Len { len: usize, op: BinOp },\n@@ -242,12 +259,12 @@ struct Test<H:Hair> {\n impl<H:Hair> Builder<H> {\n     fn match_candidates(&mut self,\n                         span: H::Span,\n-                        var_extent: H::CodeExtent,\n+                        arm_blocks: &mut ArmBlocks,\n                         mut candidates: Vec<Candidate<H>>,\n                         mut block: BasicBlock)\n     {\n-        debug!(\"matched_candidate(span={:?}, var_extent={:?}, block={:?}, candidates={:?})\",\n-               span, var_extent, block, candidates);\n+        debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n+               span, block, candidates);\n \n         // Start by simplifying candidates. Once this process is\n         // complete, all the match pairs which remain require some\n@@ -267,9 +284,12 @@ impl<H:Hair> Builder<H> {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n             let candidate = candidates.pop().unwrap();\n-            match self.bind_and_guard_matched_candidate(block, var_extent, candidate) {\n-                None => { return; }\n-                Some(b) => { block = b; }\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n+                block = b;\n+            } else {\n+                // if None is returned, then any remaining candidates\n+                // are unreachable (at least not through this path).\n+                return;\n             }\n         }\n \n@@ -297,7 +317,7 @@ impl<H:Hair> Builder<H> {\n                                                                       candidate))\n                           })\n                           .collect();\n-            self.match_candidates(span, var_extent, applicable_candidates, target_block);\n+            self.match_candidates(span, arm_blocks, applicable_candidates, target_block);\n         }\n     }\n \n@@ -315,52 +335,44 @@ impl<H:Hair> Builder<H> {\n     /// MIR).\n     fn bind_and_guard_matched_candidate(&mut self,\n                                         mut block: BasicBlock,\n-                                        var_extent: H::CodeExtent,\n+                                        arm_blocks: &mut ArmBlocks,\n                                         candidate: Candidate<H>)\n                                         -> Option<BasicBlock> {\n-        debug!(\"bind_and_guard_matched_candidate(block={:?}, var_extent={:?}, candidate={:?})\",\n-               block, var_extent, candidate);\n+        debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n+               block, candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n-        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+        self.bind_matched_candidate(block, candidate.bindings);\n+\n+        let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, Terminator::If { cond: cond,\n-                                                       targets: [candidate.arm_block, otherwise]});\n+                                                       targets: [arm_block, otherwise]});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block, Terminator::Goto { target: candidate.arm_block });\n+            self.cfg.terminate(block, Terminator::Goto { target: arm_block });\n             None\n         }\n     }\n \n     fn bind_matched_candidate(&mut self,\n                               block: BasicBlock,\n-                              var_extent: H::CodeExtent,\n                               bindings: Vec<Binding<H>>) {\n-        debug!(\"bind_matched_candidate(block={:?}, var_extent={:?}, bindings={:?})\",\n-               block, var_extent, bindings);\n+        debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n+               block, bindings);\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            // Create a variable for the `var_id` being bound. In the\n-            // case where there are multiple patterns for a single\n-            // arm, it may already exist.\n-            let var_index = if !self.var_indices.contains_key(&binding.var_id) {\n-                self.declare_binding(var_extent,\n-                                     binding.mutability,\n-                                     binding.name,\n-                                     binding.var_id,\n-                                     binding.var_ty,\n-                                     binding.span)\n-            } else {\n-                self.var_indices[&binding.var_id]\n-            };\n+            // Find the variable for the `var_id` being bound. It\n+            // should have been created by a previous call to\n+            // `declare_bindings`.\n+            let var_index = self.var_indices[&binding.var_id];\n \n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue =>"}, {"sha": "2d034baef167d6b1433d9c97781ea00f40fc659b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -33,20 +33,20 @@ impl<H:Hair> Builder<H> {\n                 }\n             }\n \n-            PatternKind::Constant { ref expr } => {\n-                let expr = self.as_constant(expr.clone());\n+            PatternKind::Constant { ref value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Eq { value: expr, ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Eq { value: value.clone(),\n+                                         ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n             PatternKind::Range { ref lo, ref hi } => {\n-                let lo = self.as_constant(lo.clone());\n-                let hi = self.as_constant(hi.clone());\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Range { lo: lo, hi: hi, ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Range { lo: lo.clone(),\n+                                            hi: hi.clone(),\n+                                            ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n@@ -90,15 +90,15 @@ impl<H:Hair> Builder<H> {\n \n             TestKind::Eq { value, ty } => {\n                 // call PartialEq::eq(discrim, constant)\n-                let constant = self.push_constant(block, test.span, ty.clone(), value);\n+                let constant = self.push_literal(block, test.span, ty.clone(), value);\n                 let item_ref = self.hir.partial_eq(ty);\n                 self.call_comparison_fn(block, test.span, item_ref, lvalue.clone(), constant)\n             }\n \n             TestKind::Range { lo, hi, ty } => {\n                 // Test `v` by computing `PartialOrd::le(lo, v) && PartialOrd::le(v, hi)`.\n-                let lo = self.push_constant(block, test.span, ty.clone(), lo);\n-                let hi = self.push_constant(block, test.span, ty.clone(), hi);\n+                let lo = self.push_literal(block, test.span, ty.clone(), lo);\n+                let hi = self.push_literal(block, test.span, ty.clone(), hi);\n                 let item_ref = self.hir.partial_le(ty);\n \n                 let lo_blocks ="}, {"sha": "9fa1d55e82f9c1eba2c6b5a5a7a66fd317c40727", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -33,13 +33,14 @@ impl<H:Hair> Builder<H> {\n         lvalue\n     }\n \n-    pub fn push_constant(&mut self,\n-                         block: BasicBlock,\n-                         span: H::Span,\n-                         ty: H::Ty,\n-                         constant: Constant<H>)\n-                         -> Lvalue<H> {\n-        let temp = self.temp(ty);\n+    pub fn push_literal(&mut self,\n+                        block: BasicBlock,\n+                        span: H::Span,\n+                        ty: H::Ty,\n+                        literal: Literal<H>)\n+                        -> Lvalue<H> {\n+        let temp = self.temp(ty.clone());\n+        let constant = Constant { span: span, ty: ty, literal: literal };\n         self.cfg.push_assign_constant(block, span, &temp, constant);\n         temp\n     }\n@@ -55,8 +56,8 @@ impl<H:Hair> Builder<H> {\n             block, span, &temp,\n             Constant {\n                 span: span,\n-                kind: ConstantKind::Literal(Literal::Uint { bits: IntegralBits::BSize,\n-                                                            value: value as u64 }),\n+                ty: self.hir.usize_ty(),\n+                literal: self.hir.usize_literal(value),\n             });\n         temp\n     }\n@@ -66,13 +67,7 @@ impl<H:Hair> Builder<H> {\n                          span: H::Span,\n                          item_ref: ItemRef<H>)\n                          -> Lvalue<H> {\n-        let constant = Constant {\n-            span: span,\n-            kind: ConstantKind::Literal(Literal::Item {\n-                def_id: item_ref.def_id,\n-                substs: item_ref.substs\n-            })\n-        };\n-        self.push_constant(block, span, item_ref.ty, constant)\n+        let literal = Literal::Item { def_id: item_ref.def_id, substs: item_ref.substs };\n+        self.push_literal(block, span, item_ref.ty, literal)\n     }\n }"}, {"sha": "3dd4f5f253c0ad549b835cc82715206f4541cc2f", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -40,7 +40,7 @@ impl<H:Hair> Builder<H> {\n             StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n                 this.in_scope(remainder_scope, block, |this| {\n                     unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_uninitialized_variables(remainder_scope, pattern);\n+                        this.declare_bindings(remainder_scope, pattern);\n                         block.unit()\n                     }));\n                     this.stmts(block, stmts)"}, {"sha": "4251b550cfc4dd41421f98deef93e85c928eb119", "filename": "src/librustc_mir/dump.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n             }\n         }\n \n-        let always_build_mir = self.tcx.sess.opts.always_build_mir;\n+        let always_build_mir = true;\n         if !built_mir && always_build_mir {\n             let mut closure_dump = InnerDump { tcx: self.tcx, attr: None };\n             walk_op(&mut closure_dump);"}, {"sha": "f4eb03c5d07c2371dbbfd0660cc3e9dd75117bf3", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -38,6 +38,7 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     type Ty: Clone+Debug+Eq;                                     // e.g., ty::Ty<'tcx>\n     type Region: Copy+Debug;                                     // e.g., ty::Region\n     type CodeExtent: Copy+Debug+Hash+Eq;                         // e.g., region::CodeExtent\n+    type ConstVal: Clone+Debug+PartialEq;                        // e.g., ConstVal\n     type Pattern: Clone+Debug+Mirror<Self,Output=Pattern<Self>>; // e.g., &P<ast::Pat>\n     type Expr: Clone+Debug+Mirror<Self,Output=Expr<Self>>;       // e.g., &P<ast::Expr>\n     type Stmt: Clone+Debug+Mirror<Self,Output=Stmt<Self>>;       // e.g., &P<ast::Stmt>\n@@ -55,9 +56,18 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     /// Returns the type `usize`.\n     fn usize_ty(&mut self) -> Self::Ty;\n \n+    /// Returns the literal for `true`\n+    fn usize_literal(&mut self, value: usize) -> Literal<Self>;\n+\n     /// Returns the type `bool`.\n     fn bool_ty(&mut self) -> Self::Ty;\n \n+    /// Returns the literal for `true`\n+    fn true_literal(&mut self) -> Literal<Self>;\n+\n+    /// Returns the literal for `true`\n+    fn false_literal(&mut self) -> Literal<Self>;\n+\n     /// Returns a reference to `PartialEq::<T,T>::eq`\n     fn partial_eq(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n \n@@ -261,9 +271,9 @@ pub enum PatternKind<H:Hair> {\n \n     Deref { subpattern: PatternRef<H> }, // box P, &P, &mut P, etc\n \n-    Constant { expr: ExprRef<H> },\n+    Constant { value: Literal<H> },\n \n-    Range { lo: ExprRef<H>, hi: ExprRef<H> },\n+    Range { lo: Literal<H>, hi: Literal<H> },\n \n     // matches against a slice, checking the length and extracting elements\n     Slice { prefix: Vec<PatternRef<H>>,"}, {"sha": "d522518a3d4afbda1b8ab9d1ef70662fd0b52dd5", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -642,48 +642,21 @@ impl<H:Hair> Debug for Rvalue<H> {\n \n ///////////////////////////////////////////////////////////////////////////\n // Constants\n+//\n+// Two constants are equal if they are the same constant. Note that\n+// this does not necessarily mean that they are \"==\" in Rust -- in\n+// particular one must be wary of `NaN`!\n \n #[derive(Clone, Debug, PartialEq)]\n pub struct Constant<H:Hair> {\n     pub span: H::Span,\n-    pub kind: ConstantKind<H>\n+    pub ty: H::Ty,\n+    pub literal: Literal<H>\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-pub enum ConstantKind<H:Hair> {\n-    Literal(Literal<H>),\n-    Aggregate(AggregateKind<H>, Vec<Constant<H>>),\n-    Call(Box<Constant<H>>, Vec<Constant<H>>),\n-    Cast(Box<Constant<H>>, H::Ty),\n-    Repeat(Box<Constant<H>>, Box<Constant<H>>),\n-    Ref(BorrowKind, Box<Constant<H>>),\n-    BinaryOp(BinOp, Box<Constant<H>>, Box<Constant<H>>),\n-    UnaryOp(UnOp, Box<Constant<H>>),\n-    Projection(Box<ConstantProjection<H>>)\n-}\n-\n-pub type ConstantProjection<H> =\n-    Projection<H,Constant<H>,Constant<H>>;\n-\n #[derive(Clone, Debug, PartialEq)]\n pub enum Literal<H:Hair> {\n     Item { def_id: H::DefId, substs: H::Substs },\n-    Projection { projection: H::Projection },\n-    Int { bits: IntegralBits, value: i64 },\n-    Uint { bits: IntegralBits, value: u64 },\n-    Float { bits: FloatBits, value: f64 },\n-    Char { c: char },\n-    Bool { value: bool },\n-    Bytes { value: H::Bytes },\n-    String { value: H::InternedString },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n-pub enum IntegralBits {\n-    B8, B16, B32, B64, BSize\n+    Value { value: H::ConstVal },\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n-pub enum FloatBits {\n-    F32, F64\n-}"}, {"sha": "098a85514eb2af21eee7060b93f05d1887513248", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 4, "deletions": 66, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -16,14 +16,13 @@ use tcx::Cx;\n use tcx::block;\n use tcx::pattern::PatNode;\n use tcx::rustc::front::map;\n+use tcx::rustc::middle::const_eval;\n use tcx::rustc::middle::def;\n use tcx::rustc::middle::region::CodeExtent;\n use tcx::rustc::middle::pat_util;\n use tcx::rustc::middle::ty::{self, Ty};\n use tcx::rustc_front::hir;\n use tcx::rustc_front::util as hir_util;\n-use tcx::syntax::ast;\n-use tcx::syntax::codemap::Span;\n use tcx::syntax::parse::token;\n use tcx::syntax::ptr::P;\n use tcx::to_ref::ToRef;\n@@ -83,9 +82,9 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                 }\n             }\n \n-            hir::ExprLit(ref lit) => {\n-                let literal = convert_literal(cx, self.span, expr_ty, lit);\n-                ExprKind::Literal { literal: literal }\n+            hir::ExprLit(..) => {\n+                let value = const_eval::eval_const_expr(cx.tcx, self);\n+                ExprKind::Literal { literal: Literal::Value { value: value } }\n             }\n \n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -452,67 +451,6 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_literal<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                               expr_span: Span,\n-                               expr_ty: Ty<'tcx>,\n-                               literal: &ast::Lit)\n-                               -> Literal<Cx<'a,'tcx>>\n-{\n-    use repr::IntegralBits::*;\n-    match (&literal.node, &expr_ty.sty) {\n-        (&ast::LitStr(ref text, _), _) =>\n-            Literal::String { value: text.clone() },\n-        (&ast::LitByteStr(ref bytes), _) =>\n-            Literal::Bytes { value: bytes.clone() },\n-        (&ast::LitByte(c), _) =>\n-            Literal::Uint { bits: B8, value: c as u64 },\n-        (&ast::LitChar(c), _) =>\n-            Literal::Char { c: c },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU8)) =>\n-            Literal::Uint { bits: B8, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU16)) =>\n-            Literal::Uint { bits: B16, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU32)) =>\n-            Literal::Uint { bits: B32, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU64)) =>\n-            Literal::Uint { bits: B64, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyUs)) =>\n-            Literal::Uint { bits: BSize, value: v },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI8)) =>\n-            Literal::Int { bits: B8, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI16)) =>\n-            Literal::Int { bits: B16, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI32)) =>\n-            Literal::Int { bits: B32, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI64)) =>\n-            Literal::Int { bits: B64, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyIs)) =>\n-            Literal::Int { bits: BSize, value: -(v as i64) },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI8)) =>\n-            Literal::Int { bits: B8, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI16)) =>\n-            Literal::Int { bits: B16, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI32)) =>\n-            Literal::Int { bits: B32, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI64)) =>\n-            Literal::Int { bits: B64, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyIs)) =>\n-            Literal::Int { bits: BSize, value: v as i64 },\n-        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF32)) |\n-        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF32)) =>\n-            Literal::Float { bits: FloatBits::F32, value: v.parse::<f64>().unwrap() },\n-        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF64)) |\n-        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF64)) =>\n-            Literal::Float { bits: FloatBits::F64, value: v.parse::<f64>().unwrap() },\n-        (&ast::LitBool(v), _) =>\n-            Literal::Bool { value: v },\n-        (ref l, ref t) =>\n-            cx.tcx.sess.span_bug(\n-                expr_span,\n-                &format!(\"Invalid literal/type combination: {:?},{:?}\", l, t))\n-    }\n-}\n-\n fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<Cx<'a,'tcx>> {\n     let map = if arm.pats.len() == 1 {\n         None"}, {"sha": "04f52a52464b7cb963b45fba5319cbcd8323304d", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -14,6 +14,7 @@ use std::fmt::{Debug, Formatter, Error};\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n \n+use self::rustc::middle::const_eval::ConstVal;\n use self::rustc::middle::def_id::DefId;\n use self::rustc::middle::infer::InferCtxt;\n use self::rustc::middle::region::CodeExtent;\n@@ -56,6 +57,7 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type Region = ty::Region;\n     type CodeExtent = CodeExtent;\n+    type ConstVal = ConstVal;\n     type Pattern = PatNode<'tcx>;\n     type Expr = &'tcx hir::Expr;\n     type Stmt = &'tcx hir::Stmt;\n@@ -70,10 +72,22 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n         self.tcx.types.usize\n     }\n \n+    fn usize_literal(&mut self, value: usize) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Uint(value as u64) }\n+    }\n+\n     fn bool_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.bool\n     }\n \n+    fn true_literal(&mut self) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Bool(true) }\n+    }\n+\n+    fn false_literal(&mut self) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Bool(false) }\n+    }\n+\n     fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n         let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n         self.cmp_method_ref(eq_def_id, \"eq\", ty)"}, {"sha": "fe0c2c6c76add2a309e5f6e932946db6311f8783", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "patch": "@@ -14,9 +14,10 @@ use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::rc::Rc;\n use tcx::Cx;\n-use tcx::rustc::middle::const_eval::lookup_const_by_id;\n+use tcx::rustc::middle::const_eval;\n use tcx::rustc::middle::def;\n use tcx::rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use tcx::rustc::middle::subst::Substs;\n use tcx::rustc::middle::ty::{self, Ty};\n use tcx::rustc_front::hir;\n use tcx::syntax::ast;\n@@ -145,26 +146,45 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n             hir::PatWild(..) =>\n                 PatternKind::Wild,\n \n-            hir::PatLit(ref lt) =>\n-                PatternKind::Constant { expr: lt.to_ref() },\n+            hir::PatLit(ref value) => {\n+                let value = const_eval::eval_const_expr(cx.tcx, value);\n+                let value = Literal::Value { value: value };\n+                PatternKind::Constant { value: value }\n+            },\n \n-            hir::PatRange(ref begin, ref end) =>\n-                PatternKind::Range { lo: begin.to_ref(),\n-                                     hi: end.to_ref() },\n+            hir::PatRange(ref lo, ref hi) => {\n+                let lo = const_eval::eval_const_expr(cx.tcx, lo);\n+                let lo = Literal::Value { value: lo };\n+                let hi = const_eval::eval_const_expr(cx.tcx, hi);\n+                let hi = Literal::Value { value: hi };\n+                PatternKind::Range { lo: lo, hi: hi }\n+            },\n \n             hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n                 if pat_is_resolved_const(&cx.tcx.def_map, self.pat) =>\n             {\n                 let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n                 match def {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n-                        match lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n-                            Some(const_expr) =>\n-                                PatternKind::Constant { expr: const_expr.to_ref() },\n-                            None =>\n+                        match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n+                            Some(const_expr) => {\n+                                let opt_value =\n+                                    const_eval::eval_const_expr_partial(\n+                                        cx.tcx, const_expr,\n+                                        const_eval::EvalHint::ExprTypeChecked);\n+                                let literal = if let Ok(value) = opt_value {\n+                                    Literal::Value { value: value }\n+                                } else {\n+                                    let substs = cx.tcx.mk_substs(Substs::empty());\n+                                    Literal::Item { def_id: def_id, substs: substs }\n+                                };\n+                                PatternKind::Constant { value: literal }\n+                            }\n+                            None => {\n                                 cx.tcx.sess.span_bug(\n                                     self.pat.span,\n-                                    &format!(\"cannot eval constant: {:?}\", def_id)),\n+                                    &format!(\"cannot eval constant: {:?}\", def_id))\n+                            }\n                         },\n                     _ =>\n                         cx.tcx.sess.span_bug("}]}