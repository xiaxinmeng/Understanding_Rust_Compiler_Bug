{"sha": "1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZWU2MDE4MWZlYTU2ZWJlNmI1ZTRhZWIxMWNmOWRmMjVhMWQwODc=", "commit": {"author": {"name": "Matthew Hall", "email": "matthew@quickbeam.me.uk", "date": "2020-04-01T21:26:41Z"}, "committer": {"name": "Matthew Hall", "email": "matthew@quickbeam.me.uk", "date": "2020-04-01T21:26:41Z"}, "message": "Add impl From for enum variant assist\n\nBasically adds a From impl for tuple enum variants with one field. Added\nto cover the fairly common case of implementing your own Error that can\nbe created from another one, although other use cases exist.", "tree": {"sha": "0a157b2f478a2b4334167da483f401d0ba5e4938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a157b2f478a2b4334167da483f401d0ba5e4938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "html_url": "https://github.com/rust-lang/rust/commit/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/comments", "author": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2d4135db867efe335a0654d86429bea7bb9caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2d4135db867efe335a0654d86429bea7bb9caf", "html_url": "https://github.com/rust-lang/rust/commit/1c2d4135db867efe335a0654d86429bea7bb9caf"}], "stats": {"total": 257, "additions": 255, "deletions": 2}, "files": [{"sha": "cf94a214a4ec0bef9095891c28c587b3cc22e43c", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "patch": "@@ -0,0 +1,218 @@\n+use hir::ImplDef;\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner},\n+    TextUnit,\n+};\n+use stdx::format_to;\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use ra_ide_db::RootDatabase;\n+\n+// Assist add_from_impl_for_enum\n+//\n+// Adds a From impl for an enum variant with one tuple field\n+//\n+// ```\n+// enum A { <|>One(u32) }\n+// ```\n+// ->\n+// ```\n+// enum A { One(u32) }\n+//\n+// impl From<u32> for A {\n+//     fn from(v: u32) -> Self {\n+//         A::One(v)\n+//     }\n+// }\n+// ```\n+pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let variant_name = variant.name()?;\n+    let enum_name = variant.parent_enum().name()?;\n+    let field_list = match variant.kind() {\n+        ast::StructKind::Tuple(field_list) => field_list,\n+        _ => return None,\n+    };\n+    if field_list.fields().count() != 1 {\n+        return None;\n+    }\n+    let field_type = field_list.fields().next()?.type_ref()?;\n+    let path = match field_type {\n+        ast::TypeRef::PathType(p) => p,\n+        _ => return None,\n+    };\n+\n+    if already_has_from_impl(ctx.sema, &variant) {\n+        return None;\n+    }\n+\n+    ctx.add_assist(\n+        AssistId(\"add_from_impl_for_enum\"),\n+        \"Add From impl for this enum variant\",\n+        |edit| {\n+            let start_offset = variant.parent_enum().syntax().text_range().end();\n+            let mut buf = String::new();\n+            format_to!(\n+                buf,\n+                r#\"\n+\n+impl From<{0}> for {1} {{\n+    fn from(v: {0}) -> Self {{\n+        {1}::{2}(v)\n+    }}\n+}}\"#,\n+                path.syntax(),\n+                enum_name,\n+                variant_name\n+            );\n+            edit.insert(start_offset, buf);\n+            edit.set_cursor(start_offset + TextUnit::of_str(\"\\n\\n\"));\n+        },\n+    )\n+}\n+\n+fn already_has_from_impl(\n+    sema: &'_ hir::Semantics<'_, RootDatabase>,\n+    variant: &ast::EnumVariant,\n+) -> bool {\n+    let scope = sema.scope(&variant.syntax());\n+\n+    let from_path = ast::make::path_from_text(\"From\");\n+    let from_hir_path = match hir::Path::from_ast(from_path) {\n+        Some(p) => p,\n+        None => return false,\n+    };\n+    let from_trait = match scope.resolve_hir_path(&from_hir_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(t))) => t,\n+        _ => return false,\n+    };\n+\n+    let e: hir::Enum = match sema.to_def(&variant.parent_enum()) {\n+        Some(e) => e,\n+        None => return false,\n+    };\n+    let e_ty = e.ty(sema.db);\n+\n+    let hir_enum_var: hir::EnumVariant = match sema.to_def(variant) {\n+        Some(ev) => ev,\n+        None => return false,\n+    };\n+    let var_ty = hir_enum_var.fields(sema.db)[0].signature_ty(sema.db);\n+\n+    let krate = match scope.module() {\n+        Some(s) => s.krate(),\n+        _ => return false,\n+    };\n+    let impls = ImplDef::for_trait(sema.db, krate, from_trait);\n+    let imp = impls.iter().find(|imp| {\n+        let targets_enum = imp.target_ty(sema.db) == e_ty;\n+        let param_matches = imp.target_trait_substs_matches(sema.db, &[var_ty.clone()]);\n+        targets_enum && param_matches\n+    });\n+\n+    imp.is_some()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn test_add_from_impl_for_enum() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            \"enum A { <|>One(u32) }\",\n+            r#\"enum A { One(u32) }\n+\n+<|>impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_for_enum_complicated_path() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            \"enum A { <|>One(foo::bar::baz::Boo) }\",\n+            r#\"enum A { One(foo::bar::baz::Boo) }\n+\n+<|>impl From<foo::bar::baz::Boo> for A {\n+    fn from(v: foo::bar::baz::Boo) -> Self {\n+        A::One(v)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_no_element() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_more_than_one_element_in_tuple() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One(u32, String) }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_struct_variant() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One { x: u32 } }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_already_exists() {\n+        check_assist_not_applicable(\n+            add_from_impl_for_enum,\n+            r#\"enum A { <|>One(u32), }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_different_variant_impl_exists() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            r#\"enum A { <|>One(u32), Two(String), }\n+\n+impl From<String> for A {\n+    fn from(v: String) -> Self {\n+        A::Two(v)\n+    }\n+}\n+    \n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+            r#\"enum A { One(u32), Two(String), }\n+\n+<|>impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\n+impl From<String> for A {\n+    fn from(v: String) -> Self {\n+        A::Two(v)\n+    }\n+}\n+    \n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "6b4c56dcdc12c803ea09089e6d8cc3cb9b2ea5b4", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n+    mod add_from_impl_for_enum;\n \n     pub(crate) fn all() -> &'static [AssistHandler] {\n         &[\n@@ -159,6 +160,7 @@ mod handlers {\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_unwrap_with_match::replace_unwrap_with_match,\n             split_import::split_import,\n+            add_from_impl_for_enum::add_from_impl_for_enum,\n         ]\n     }\n }"}, {"sha": "3889a7e5a17dbdd512b023c50ca5fcbceba60cd1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "patch": "@@ -23,7 +23,7 @@ use hir_expand::{\n };\n use hir_ty::{\n     autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -960,6 +960,38 @@ impl ImplDef {\n         db.impl_data(self.id).target_trait.clone()\n     }\n \n+    pub fn target_trait_substs_matches(&self, db: &dyn HirDatabase, typs: &[Type]) -> bool {\n+        let type_ref = match self.target_trait(db) {\n+            Some(typ_ref) => typ_ref,\n+            None => return false,\n+        };\n+        let resolver = self.id.resolver(db.upcast());\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let ty = Ty::from_hir(&ctx, &type_ref);\n+        let d = match ty.dyn_trait_ref() {\n+            Some(d) => d,\n+            None => return false,\n+        };\n+        let mut matches = true;\n+        let mut i = 0;\n+        d.substs.walk(&mut |t| {\n+            if matches {\n+                if i >= typs.len() {\n+                    matches = false;\n+                    return;\n+                }\n+                match t {\n+                    Ty::Bound(_) => matches = i == 0,\n+                    _ => {\n+                        matches = *t == typs[i].ty.value;\n+                        i += 1;\n+                    }\n+                }\n+            }\n+        });\n+        matches\n+    }\n+\n     pub fn target_type(&self, db: &dyn HirDatabase) -> TypeRef {\n         db.impl_data(self.id).target_type.clone()\n     }"}, {"sha": "c49cf9a3b89a1cbccffac7f222000fb22ea31ed4", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fee60181fea56ebe6b5e4aeb11cf9df25a1d087/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=1fee60181fea56ebe6b5e4aeb11cf9df25a1d087", "patch": "@@ -22,7 +22,8 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-fn path_from_text(text: &str) -> ast::Path {\n+\n+pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}]}