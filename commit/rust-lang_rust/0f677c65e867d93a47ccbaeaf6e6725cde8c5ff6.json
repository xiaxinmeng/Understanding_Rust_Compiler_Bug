{"sha": "0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNjc3YzY1ZTg2N2Q5M2E0N2NjYmFlYWY2ZTY3MjVjZGU4YzVmZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T12:58:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T12:58:10Z"}, "message": "Auto merge of #65541 - eddyb:spanned-inferred-outlives, r=nikomatsakis\n\nrustc: add `Span`s to `inferred_outlives_of` predicates.\n\nThis would simplify #59789, and I suspect it has some potential in diagnostics (although we don't seem to use the predicate `Span`s much atm).", "tree": {"sha": "7bab7c6cced461c05c36ce0c1490c52a3a50b844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bab7c6cced461c05c36ce0c1490c52a3a50b844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "html_url": "https://github.com/rust-lang/rust/commit/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7176b44a203322c834302f3b515f8c10a54f2c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7176b44a203322c834302f3b515f8c10a54f2c1", "html_url": "https://github.com/rust-lang/rust/commit/b7176b44a203322c834302f3b515f8c10a54f2c1"}, {"sha": "1ca8da40366a417aef90415d8f745764cab5783b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca8da40366a417aef90415d8f745764cab5783b", "html_url": "https://github.com/rust-lang/rust/commit/1ca8da40366a417aef90415d8f745764cab5783b"}], "stats": {"total": 98, "additions": 62, "deletions": 36}, "files": [{"sha": "7cae74b59c7f9a91d2beb9bff709386e68053d39", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -191,7 +191,7 @@ rustc_queries! {\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        query inferred_outlives_of(_: DefId) -> &'tcx [ty::Predicate<'tcx>] {}\n+        query inferred_outlives_of(_: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {}\n \n         /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of"}, {"sha": "eb673fcefcc9a3fad4e53fed1863405af351c2b8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -1143,7 +1143,7 @@ pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n-    pub predicates: FxHashMap<DefId, &'tcx [ty::Predicate<'tcx>]>,\n+    pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n }\n \n impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {"}, {"sha": "7c19449f96b86f674bcb627584c02603d1910435", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -1497,10 +1497,10 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n-        inferred_outlives.iter().filter_map(|pred| {\n+        inferred_outlives.iter().filter_map(|(pred, _)| {\n             match pred {\n                 ty::Predicate::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n@@ -1517,10 +1517,10 @@ impl ExplicitOutlivesRequirements {\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n-        inferred_outlives.iter().filter_map(|pred| {\n+        inferred_outlives.iter().filter_map(|(pred, _)| {\n             match pred {\n                 ty::Predicate::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n@@ -1539,7 +1539,7 @@ impl ExplicitOutlivesRequirements {\n         &self,\n         param: &'tcx hir::GenericParam,\n         tcx: TyCtxt<'tcx>,\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n     ) -> Vec<ty::Region<'tcx>> {\n         let index = ty_generics.param_def_id_to_index["}, {"sha": "08554c83ed5bf0e325e7727c1a5ad2c01eafb8d7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -197,6 +197,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n             return TAG_INVALID_SPAN.encode(self)\n         }\n \n+        // HACK(eddyb) there's no way to indicate which crate a Span is coming\n+        // from right now, so decoding would fail to find the SourceFile if\n+        // it's not local to the crate the Span is found in.\n+        if self.source_file_cache.is_imported() {\n+            return TAG_INVALID_SPAN.encode(self)\n+        }\n+\n         TAG_VALID_SPAN.encode(self)?;\n         span.lo.encode(self)?;\n \n@@ -379,6 +386,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             .filter(|source_file| {\n                 // No need to re-export imported source_files, as any downstream\n                 // crate will import them from their original source.\n+                // FIXME(eddyb) the `Span` encoding should take that into account.\n                 !source_file.is_imported()\n             })\n             .map(|source_file| {"}, {"sha": "a0550b5126a9c0e999e09f05841c00a67e5b6120", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -1983,19 +1983,18 @@ fn predicates_defined_on(\n     );\n     let inferred_outlives = tcx.inferred_outlives_of(def_id);\n     if !inferred_outlives.is_empty() {\n-        let span = tcx.def_span(def_id);\n         debug!(\n             \"predicates_defined_on: inferred_outlives_of({:?}) = {:?}\",\n             def_id,\n             inferred_outlives,\n         );\n-        result.predicates = tcx.arena.alloc_from_iter(\n-            result.predicates.iter().copied().chain(\n-                // FIXME(eddyb) use better spans - maybe add `Span`s\n-                // to `inferred_outlives_of` predicates as well?\n-                inferred_outlives.iter().map(|&p| (p, span)),\n-            ),\n-        );\n+        if result.predicates.is_empty() {\n+            result.predicates = inferred_outlives;\n+        } else {\n+            result.predicates = tcx.arena.alloc_from_iter(\n+                result.predicates.iter().chain(inferred_outlives).copied(),\n+            );\n+        }\n     }\n     debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result"}, {"sha": "21e529f33cfd00e36cc2609b47854b6b9bd11a2b", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -30,11 +30,17 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             let mut required_predicates = RequiredPredicates::default();\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n-            for (pred, _) in predicates.predicates {\n-                match pred {\n+            for &(predicate, span) in predicates.predicates {\n+                match predicate {\n                     ty::Predicate::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n-                        insert_outlives_predicate(tcx, (*ty).into(), reg, &mut required_predicates)\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            (*ty).into(),\n+                            reg,\n+                            span,\n+                            &mut required_predicates,\n+                        )\n                     }\n \n                     ty::Predicate::RegionOutlives(predicate) => {\n@@ -43,6 +49,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                             tcx,\n                             (*reg1).into(),\n                             reg2,\n+                            span,\n                             &mut required_predicates,\n                         )\n                     }"}, {"sha": "74048b8d20c825ad23ba9ffab0208d10a34af188", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{GenericArg, Subst, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n+use syntax_pos::Span;\n \n use super::explicit::ExplicitPredicatesMap;\n use super::utils::*;\n@@ -79,9 +80,11 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n                     // (struct/enum/union) there will be outlive\n                     // requirements for adt_def.\n                     let field_ty = self.tcx.type_of(field_def.did);\n+                    let field_span = self.tcx.def_span(field_def.did);\n                     insert_required_predicates_to_be_wf(\n                         self.tcx,\n                         field_ty,\n+                        field_span,\n                         self.global_inferred_outlives,\n                         &mut item_required_predicates,\n                         &mut self.explicit_map,\n@@ -118,6 +121,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n fn insert_required_predicates_to_be_wf<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     field_ty: Ty<'tcx>,\n+    field_span: Span,\n     global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n@@ -130,7 +134,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // We also want to calculate potential predicates for the T\n             ty::Ref(region, rty, _) => {\n                 debug!(\"Ref\");\n-                insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n+                insert_outlives_predicate(tcx, rty.into(), region, field_span, required_predicates);\n             }\n \n             // For each Adt (struct/enum/union) type `Foo<'a, T>`, we\n@@ -158,7 +162,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // 'a` holds for `Foo`.\n                 debug!(\"Adt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n-                    for unsubstituted_predicate in unsubstituted_predicates {\n+                    for (unsubstituted_predicate, &span) in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n                         // example above.  So apply the substitution to\n                         // get `T: 'a` (or `predicate`):\n@@ -167,6 +171,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                             tcx,\n                             predicate.0,\n                             predicate.1,\n+                            span,\n                             required_predicates,\n                         );\n                     }\n@@ -272,7 +277,7 @@ pub fn check_explicit_predicates<'tcx>(\n     );\n     let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n-    for outlives_predicate in explicit_predicates.iter() {\n+    for (outlives_predicate, &span) in explicit_predicates {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n \n         // Careful: If we are inferring the effects of a `dyn Trait<..>`\n@@ -320,6 +325,6 @@ pub fn check_explicit_predicates<'tcx>(\n \n         let predicate = outlives_predicate.subst(tcx, substs);\n         debug!(\"predicate = {:?}\", &predicate);\n-        insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n+        insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, span, required_predicates);\n     }\n }"}, {"sha": "6b861656d7e2dce0188d4803f75c0935fa6e9e6c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -5,6 +5,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use syntax::symbol::sym;\n+use syntax_pos::Span;\n \n mod explicit;\n mod implicit_infer;\n@@ -23,7 +24,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n fn inferred_outlives_of(\n     tcx: TyCtxt<'_>,\n     item_def_id: DefId,\n-) -> &[ty::Predicate<'_>] {\n+) -> &[(ty::Predicate<'_>, Span)] {\n     let id = tcx\n         .hir()\n         .as_local_hir_id(item_def_id)\n@@ -43,7 +44,7 @@ fn inferred_outlives_of(\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|out_pred| match out_pred {\n+                        .map(|(out_pred, _)| match out_pred {\n                             ty::Predicate::RegionOutlives(p) => p.to_string(),\n                             ty::Predicate::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n@@ -96,27 +97,27 @@ fn inferred_outlives_crate(\n     let predicates = global_inferred_outlives\n         .iter()\n         .map(|(&def_id, set)| {\n-            let predicates = tcx.arena.alloc_from_iter(set\n+            let predicates = &*tcx.arena.alloc_from_iter(set\n                 .iter()\n                 .filter_map(\n-                    |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n+                    |(ty::OutlivesPredicate(kind1, region2), &span)| match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => {\n-                            Some(ty::Predicate::TypeOutlives(ty::Binder::bind(\n+                            Some((ty::Predicate::TypeOutlives(ty::Binder::bind(\n                                 ty::OutlivesPredicate(ty1, region2)\n-                            )))\n+                            )), span))\n                         }\n                         GenericArgKind::Lifetime(region1) => {\n-                            Some(ty::Predicate::RegionOutlives(\n+                            Some((ty::Predicate::RegionOutlives(\n                                 ty::Binder::bind(ty::OutlivesPredicate(region1, region2))\n-                            ))\n+                            ), span))\n                         }\n                         GenericArgKind::Const(_) => {\n                             // Generic consts don't impose any constraints.\n                             None\n                         }\n                     },\n                 ));\n-            (def_id, &*predicates)\n+            (def_id, predicates)\n         }).collect();\n \n     tcx.arena.alloc(ty::CratePredicatesMap {"}, {"sha": "361116e96d0bfc9f53d8103bbde23d60850b8336", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "patch": "@@ -2,19 +2,21 @@ use rustc::ty::outlives::Component;\n use rustc::ty::subst::{GenericArg, GenericArgKind};\n use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n use smallvec::smallvec;\n-use std::collections::BTreeSet;\n+use std::collections::BTreeMap;\n+use syntax_pos::Span;\n \n /// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n /// must be added to the struct header.\n pub type RequiredPredicates<'tcx> =\n-    BTreeSet<ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>>;\n+    BTreeMap<ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>, Span>;\n \n /// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n /// outlives_component and add it to `required_predicates`\n pub fn insert_outlives_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     kind: GenericArg<'tcx>,\n     outlived_region: Region<'tcx>,\n+    span: Span,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n ) {\n     // If the `'a` region is bound within the field type itself, we\n@@ -53,6 +55,7 @@ pub fn insert_outlives_predicate<'tcx>(\n                             tcx,\n                             r.into(),\n                             outlived_region,\n+                            span,\n                             required_predicates,\n                         );\n                     }\n@@ -73,7 +76,8 @@ pub fn insert_outlives_predicate<'tcx>(\n                         // where clause that `U: 'a`.\n                         let ty: Ty<'tcx> = param_ty.to_ty(tcx);\n                         required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                            .or_insert(span);\n                     }\n \n                     Component::Projection(proj_ty) => {\n@@ -88,7 +92,8 @@ pub fn insert_outlives_predicate<'tcx>(\n                         // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n                         let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n                         required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                            .or_insert(span);\n                     }\n \n                     Component::EscapingProjection(_) => {\n@@ -117,7 +122,8 @@ pub fn insert_outlives_predicate<'tcx>(\n             if !is_free_region(tcx, r) {\n                 return;\n             }\n-            required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n+            required_predicates.entry(ty::OutlivesPredicate(kind, outlived_region))\n+                .or_insert(span);\n         }\n \n         GenericArgKind::Const(_) => {"}]}