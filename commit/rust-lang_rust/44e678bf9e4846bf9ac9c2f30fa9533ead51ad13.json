{"sha": "44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTY3OGJmOWU0ODQ2YmY5YWM5YzJmMzBmYTk1MzNlYWQ1MWFkMTM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-03T16:34:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-03T16:34:46Z"}, "message": "Rollup merge of #71726 - ldm0:ref2ptr, r=oli-obk\n\nSuggest deref when coercing `ty::Ref` to `ty::RawPtr` with arbitrary mutability\n\nFixes #71676\n1. Implement dereference suggestion when coercing `ty::Ref` to `ty::RawPtr` with arbitrary mutability.\n2. Extract the dereference steps into `deref_steps()`, which removes all the `use` and `pub` noise introduced by last PR #71540, and makes the code more readable.\n3. Use the `remove_prefix()` closure which makes the prefix removal more readable.\n4. Introduce `Applicability` as a return value of `check_ref` to suggest `Applicability::Unspecified` suggestion.\n\n**Special**: I found it is not possible to genereate `Applicability::MachineApplicable` suggestion for situation like this:\n```rust\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nstruct Bar(u8);\nstruct Foo(Bar);\nstruct Emm(Foo);\nimpl Deref for Bar{\n    type Target = u8;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl Deref for Foo {\n    type Target = Bar;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl Deref for Emm {\n    type Target = Foo;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl DerefMut for Bar{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nimpl DerefMut for Foo {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nimpl DerefMut for Emm {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nfn main() {\n    let a = Emm(Foo(Bar(0)));\n    let _: *mut u8 = &a; //~ ERROR mismatched types\n}\n```\nWe may suggest `&mut ***a` here, but the `a` is not declared as mutable variable. And also when processing HIR, it's not possible to check if `a` is declared as a mutable variable (currently we do borrow checking with MIR). So we cannot ensure that suggestion when coercing immutable reference to mutable pointer is always machine applicable. Therefore I added a `Applicability` return value in `check_ref()`. And move the `immutable reference -> mutable pointer` situation into a sperate test file without `run-rustfix`. (It seems that `run-rustfix` will also adopt `Applicability::Unspecified` suggestion, which is strange)", "tree": {"sha": "50a12b9206ac413a5b395f5d555f591266725926", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50a12b9206ac413a5b395f5d555f591266725926"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJervKnCRBK7hj4Ov3rIwAAdHIIAJET5yGnH1n7+OzYFqRAbrvW\nQaMbypcFIcKQsyUEb0GOHklrhro43NGG5jKo28D45Gg01XXZN7l5HjFYcpK9E9U3\n1fwKKCiD+uCB1Q4bn25lQpnQ78JLwWUD0fdcRzm8HJZyGgk+ypcx7GXr3BP1yM9R\n9o5/bAq1VqQ+14OHJCD8+h15vbEkCST4mumEZ5pnVKw5MDL7ASmTlU0Dqib58iU8\ntqbjOmP99qI5xbKm5jWGnJQXrjSOfoCyuEIuDjRfrb0fJqyZD6pvtles77+Jzar1\ngW1ywaPS6lGskGZJalMF8FG5J8LDBm9nywaG6Oeq3Kmj6JR4t3d674z0sn7CzEE=\n=QUPm\n-----END PGP SIGNATURE-----\n", "payload": "tree 50a12b9206ac413a5b395f5d555f591266725926\nparent 5b1729030ab99a32f5c68f8964f42f37810116a3\nparent 9a212c1625514fdc5588cdfe6f2d58290e73248d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588523686 +0200\ncommitter GitHub <noreply@github.com> 1588523686 +0200\n\nRollup merge of #71726 - ldm0:ref2ptr, r=oli-obk\n\nSuggest deref when coercing `ty::Ref` to `ty::RawPtr` with arbitrary mutability\n\nFixes #71676\n1. Implement dereference suggestion when coercing `ty::Ref` to `ty::RawPtr` with arbitrary mutability.\n2. Extract the dereference steps into `deref_steps()`, which removes all the `use` and `pub` noise introduced by last PR #71540, and makes the code more readable.\n3. Use the `remove_prefix()` closure which makes the prefix removal more readable.\n4. Introduce `Applicability` as a return value of `check_ref` to suggest `Applicability::Unspecified` suggestion.\n\n**Special**: I found it is not possible to genereate `Applicability::MachineApplicable` suggestion for situation like this:\n```rust\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nstruct Bar(u8);\nstruct Foo(Bar);\nstruct Emm(Foo);\nimpl Deref for Bar{\n    type Target = u8;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl Deref for Foo {\n    type Target = Bar;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl Deref for Emm {\n    type Target = Foo;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\nimpl DerefMut for Bar{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nimpl DerefMut for Foo {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nimpl DerefMut for Emm {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nfn main() {\n    let a = Emm(Foo(Bar(0)));\n    let _: *mut u8 = &a; //~ ERROR mismatched types\n}\n```\nWe may suggest `&mut ***a` here, but the `a` is not declared as mutable variable. And also when processing HIR, it's not possible to check if `a` is declared as a mutable variable (currently we do borrow checking with MIR). So we cannot ensure that suggestion when coercing immutable reference to mutable pointer is always machine applicable. Therefore I added a `Applicability` return value in `check_ref()`. And move the `immutable reference -> mutable pointer` situation into a sperate test file without `run-rustfix`. (It seems that `run-rustfix` will also adopt `Applicability::Unspecified` suggestion, which is strange)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "html_url": "https://github.com/rust-lang/rust/commit/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1729030ab99a32f5c68f8964f42f37810116a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1729030ab99a32f5c68f8964f42f37810116a3", "html_url": "https://github.com/rust-lang/rust/commit/5b1729030ab99a32f5c68f8964f42f37810116a3"}, {"sha": "9a212c1625514fdc5588cdfe6f2d58290e73248d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a212c1625514fdc5588cdfe6f2d58290e73248d", "html_url": "https://github.com/rust-lang/rust/commit/9a212c1625514fdc5588cdfe6f2d58290e73248d"}], "stats": {"total": 381, "additions": 334, "deletions": 47}, "files": [{"sha": "86cafa0b8ca2500ef84bedce90abd1339a43660f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -74,7 +74,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n \n-pub struct Coerce<'a, 'tcx> {\n+struct Coerce<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n@@ -126,15 +126,15 @@ fn success<'tcx>(\n }\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    pub fn new(\n+    fn new(\n         fcx: &'f FnCtxt<'f, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Self {\n         Coerce { fcx, cause, allow_two_phase, use_lub: false }\n     }\n \n-    pub fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n@@ -841,6 +841,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n+    /// Given a type and a target type, this function will calculate and return\n+    /// how many dereference steps needed to achieve `expr_ty <: target`. If\n+    /// it's not possible, return `None`.\n+    pub fn deref_steps(&self, expr_ty: Ty<'tcx>, target: Ty<'tcx>) -> Option<usize> {\n+        let cause = self.cause(rustc_span::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n+        // We don't ever need two-phase here since we throw out the result of the coercion\n+        let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n+        coerce\n+            .autoderef(rustc_span::DUMMY_SP, expr_ty)\n+            .find_map(|(ty, steps)| coerce.unify(ty, target).ok().map(|_| steps))\n+    }\n+\n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\")."}, {"sha": "9e14efb67a94ca5df426bb0fb66bbbfad8662a7e", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 96, "deletions": 40, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -1,4 +1,3 @@\n-use crate::check::coercion::Coerce;\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -9,7 +8,6 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Node};\n-use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n@@ -355,6 +353,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn replace_prefix<A, B, C>(&self, s: A, old: B, new: C) -> Option<String>\n+    where\n+        A: AsRef<str>,\n+        B: AsRef<str>,\n+        C: AsRef<str>,\n+    {\n+        let s = s.as_ref();\n+        let old = old.as_ref();\n+        if s.starts_with(old) { Some(new.as_ref().to_owned() + &s[old.len()..]) } else { None }\n+    }\n+\n     /// This function is used to determine potential \"simple\" improvements or users' errors and\n     /// provide them useful help. For example:\n     ///\n@@ -376,7 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, &'static str, String)> {\n+    ) -> Option<(Span, &'static str, String, Applicability)> {\n         let sm = self.sess().source_map();\n         let sp = expr.span;\n         if sm.is_imported(sp) {\n@@ -400,11 +409,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if src.starts_with(\"b\\\"\") {\n+                            if let Some(src) = self.replace_prefix(src, \"b\\\"\", \"\\\"\") {\n                                 return Some((\n                                     sp,\n                                     \"consider removing the leading `b`\",\n-                                    src[1..].to_string(),\n+                                    src,\n+                                    Applicability::MachineApplicable,\n                                 ));\n                             }\n                         }\n@@ -413,11 +423,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if src.starts_with('\"') {\n+                            if let Some(src) = self.replace_prefix(src, \"\\\"\", \"b\\\"\") {\n                                 return Some((\n                                     sp,\n                                     \"consider adding a leading `b`\",\n-                                    format!(\"b{}\", src),\n+                                    src,\n+                                    Applicability::MachineApplicable,\n                                 ));\n                             }\n                         }\n@@ -470,7 +481,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };\n \n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n-                            return Some(sugg);\n+                            return Some((\n+                                sugg.0,\n+                                sugg.1,\n+                                sugg.2,\n+                                Applicability::MachineApplicable,\n+                            ));\n                         }\n                         let field_name = if is_struct_pat_shorthand_field {\n                             format!(\"{}: \", sugg_expr)\n@@ -495,6 +511,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         \"consider dereferencing here to assign to the mutable \\\n                                          borrowed piece of memory\",\n                                         format!(\"*{}\", src),\n+                                        Applicability::MachineApplicable,\n                                     ));\n                                 }\n                             }\n@@ -505,11 +522,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 sp,\n                                 \"consider mutably borrowing here\",\n                                 format!(\"{}&mut {}\", field_name, sugg_expr),\n+                                Applicability::MachineApplicable,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\",\n                                 format!(\"{}&{}\", field_name, sugg_expr),\n+                                Applicability::MachineApplicable,\n                             ),\n                         });\n                     }\n@@ -526,51 +545,88 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n-                    if let Ok(code) = sm.span_to_snippet(sp) {\n-                        if code.starts_with('&') {\n+                    if let Ok(src) = sm.span_to_snippet(sp) {\n+                        if let Some(src) = self.replace_prefix(src, \"&\", \"\") {\n                             return Some((\n                                 sp,\n                                 \"consider removing the borrow\",\n-                                code[1..].to_string(),\n+                                src,\n+                                Applicability::MachineApplicable,\n                             ));\n                         }\n                     }\n                     return None;\n                 }\n                 if let Ok(code) = sm.span_to_snippet(expr.span) {\n-                    return Some((sp, \"consider removing the borrow\", code));\n+                    return Some((\n+                        sp,\n+                        \"consider removing the borrow\",\n+                        code,\n+                        Applicability::MachineApplicable,\n+                    ));\n                 }\n             }\n             (\n                 _,\n-                &ty::RawPtr(TypeAndMut { ty: _, mutbl: hir::Mutability::Not }),\n-                &ty::Ref(_, _, hir::Mutability::Not),\n+                &ty::RawPtr(TypeAndMut { ty: ty_b, mutbl: mutbl_b }),\n+                &ty::Ref(_, ty_a, mutbl_a),\n             ) => {\n-                let cause = self.cause(rustc_span::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n-                // We don't ever need two-phase here since we throw out the result of the coercion\n-                let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n-\n-                if let Some(steps) =\n-                    coerce.autoderef(sp, checked_ty).skip(1).find_map(|(referent_ty, steps)| {\n-                        coerce\n-                            .unify(\n-                                coerce.tcx.mk_ptr(ty::TypeAndMut {\n-                                    mutbl: hir::Mutability::Not,\n-                                    ty: referent_ty,\n-                                }),\n-                                expected,\n-                            )\n-                            .ok()\n-                            .map(|_| steps)\n-                    })\n-                {\n-                    // The pointer type implements `Copy` trait so the suggestion is always valid.\n-                    if let Ok(code) = sm.span_to_snippet(sp) {\n-                        if code.starts_with('&') {\n-                            let derefs = \"*\".repeat(steps - 1);\n-                            let message = \"consider dereferencing the reference\";\n-                            let suggestion = format!(\"&{}{}\", derefs, code[1..].to_string());\n-                            return Some((sp, message, suggestion));\n+                if let Some(steps) = self.deref_steps(ty_a, ty_b) {\n+                    // Only suggest valid if dereferencing needed.\n+                    if steps > 0 {\n+                        // The pointer type implements `Copy` trait so the suggestion is always valid.\n+                        if let Ok(src) = sm.span_to_snippet(sp) {\n+                            let derefs = &\"*\".repeat(steps);\n+                            if let Some((src, applicability)) = match mutbl_b {\n+                                hir::Mutability::Mut => {\n+                                    let new_prefix = \"&mut \".to_owned() + derefs;\n+                                    match mutbl_a {\n+                                        hir::Mutability::Mut => {\n+                                            if let Some(s) =\n+                                                self.replace_prefix(src, \"&mut \", new_prefix)\n+                                            {\n+                                                Some((s, Applicability::MachineApplicable))\n+                                            } else {\n+                                                None\n+                                            }\n+                                        }\n+                                        hir::Mutability::Not => {\n+                                            if let Some(s) =\n+                                                self.replace_prefix(src, \"&\", new_prefix)\n+                                            {\n+                                                Some((s, Applicability::Unspecified))\n+                                            } else {\n+                                                None\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                hir::Mutability::Not => {\n+                                    let new_prefix = \"&\".to_owned() + derefs;\n+                                    match mutbl_a {\n+                                        hir::Mutability::Mut => {\n+                                            if let Some(s) =\n+                                                self.replace_prefix(src, \"&mut \", new_prefix)\n+                                            {\n+                                                Some((s, Applicability::MachineApplicable))\n+                                            } else {\n+                                                None\n+                                            }\n+                                        }\n+                                        hir::Mutability::Not => {\n+                                            if let Some(s) =\n+                                                self.replace_prefix(src, \"&\", new_prefix)\n+                                            {\n+                                                Some((s, Applicability::MachineApplicable))\n+                                            } else {\n+                                                None\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            } {\n+                                return Some((sp, \"consider dereferencing\", src, applicability));\n+                            }\n                         }\n                     }\n                 }\n@@ -616,7 +672,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             format!(\"*{}\", code)\n                         };\n-                        return Some((sp, message, suggestion));\n+                        return Some((sp, message, suggestion, Applicability::MachineApplicable));\n                     }\n                 }\n             }"}, {"sha": "6274a11ebd5d0842efe1635fe4bb621e3adddd98", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -5036,8 +5036,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n-        if let Some((sp, msg, suggestion)) = self.check_ref(expr, found, expected) {\n-            err.span_suggestion(sp, msg, suggestion, Applicability::MachineApplicable);\n+        if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n+            err.span_suggestion(sp, msg, suggestion, applicability);\n         } else if let (ty::FnDef(def_id, ..), true) =\n             (&found.kind, self.suggest_fn_call(err, expr, expected, found))\n         {"}, {"sha": "dfbd3223efc86136662a3f13bbaccd2a9bcb3a87", "filename": "src/test/ui/issues/issue-32122-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -5,7 +5,7 @@ LL |     let _: *const u8 = &a;\n    |            ---------   ^^\n    |            |           |\n    |            |           expected `u8`, found struct `Foo`\n-   |            |           help: consider dereferencing the reference: `&*a`\n+   |            |           help: consider dereferencing: `&*a`\n    |            expected due to this\n    |\n    = note: expected raw pointer `*const u8`"}, {"sha": "2e199e2a19f732e28cccea1232931be87d1ec273", "filename": "src/test/ui/issues/issue-32122-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -5,7 +5,7 @@ LL |     let _: *const u8 = &a;\n    |            ---------   ^^\n    |            |           |\n    |            |           expected `u8`, found struct `Emm`\n-   |            |           help: consider dereferencing the reference: `&***a`\n+   |            |           help: consider dereferencing: `&***a`\n    |            expected due to this\n    |\n    = note: expected raw pointer `*const u8`"}, {"sha": "cbc0e8c061b820184dfa45ebe77b80383c465947", "filename": "src/test/ui/issues/issue-71676-1.fixed", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.fixed?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -0,0 +1,53 @@\n+// run-rustfix\n+use std::ops::Deref;\n+use std::ops::DerefMut;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Bar{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Emm {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+fn main() {\n+    // Suggest dereference with arbitrary mutability\n+    let a = Emm(Foo(Bar(0)));\n+    let _: *const u8 = &***a; //~ ERROR mismatched types\n+\n+    let mut a = Emm(Foo(Bar(0)));\n+    let _: *mut u8 = &mut ***a; //~ ERROR mismatched types\n+\n+    let a = Emm(Foo(Bar(0)));\n+    let _: *const u8 = &***a; //~ ERROR mismatched types\n+\n+    let mut a = Emm(Foo(Bar(0)));\n+    let _: *mut u8 = &mut ***a; //~ ERROR mismatched types\n+}"}, {"sha": "6e87c7174c6335f0b01acaced49609cf89a36ba2", "filename": "src/test/ui/issues/issue-71676-1.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.rs?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -0,0 +1,53 @@\n+// run-rustfix\n+use std::ops::Deref;\n+use std::ops::DerefMut;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Bar{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Emm {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+fn main() {\n+    // Suggest dereference with arbitrary mutability\n+    let a = Emm(Foo(Bar(0)));\n+    let _: *const u8 = &a; //~ ERROR mismatched types\n+\n+    let mut a = Emm(Foo(Bar(0)));\n+    let _: *mut u8 = &a; //~ ERROR mismatched types\n+\n+    let a = Emm(Foo(Bar(0)));\n+    let _: *const u8 = &mut a; //~ ERROR mismatched types\n+\n+    let mut a = Emm(Foo(Bar(0)));\n+    let _: *mut u8 = &mut a; //~ ERROR mismatched types\n+}"}, {"sha": "bbabc2202dc840fbaee18bc0cb30728e7404b0e2", "filename": "src/test/ui/issues/issue-71676-1.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71676-1.stderr?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -0,0 +1,55 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-71676-1.rs:43:24\n+   |\n+LL |     let _: *const u8 = &a;\n+   |            ---------   ^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Emm`\n+   |            |           help: consider dereferencing: `&***a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*const u8`\n+                found reference `&Emm`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-71676-1.rs:46:22\n+   |\n+LL |     let _: *mut u8 = &a;\n+   |            -------   ^^\n+   |            |         |\n+   |            |         types differ in mutability\n+   |            |         help: consider dereferencing: `&mut ***a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*mut u8`\n+                found reference `&Emm`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-71676-1.rs:49:24\n+   |\n+LL |     let _: *const u8 = &mut a;\n+   |            ---------   ^^^^^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Emm`\n+   |            |           help: consider dereferencing: `&***a`\n+   |            expected due to this\n+   |\n+   = note:    expected raw pointer `*const u8`\n+           found mutable reference `&mut Emm`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-71676-1.rs:52:22\n+   |\n+LL |     let _: *mut u8 = &mut a;\n+   |            -------   ^^^^^^\n+   |            |         |\n+   |            |         expected `u8`, found struct `Emm`\n+   |            |         help: consider dereferencing: `&mut ***a`\n+   |            expected due to this\n+   |\n+   = note:    expected raw pointer `*mut u8`\n+           found mutable reference `&mut Emm`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f3183899dc5238f7c93c0753d5acadc57a5c4dbe", "filename": "src/test/ui/issues/issue-71676-2.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.rs?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -0,0 +1,42 @@\n+use std::ops::Deref;\n+use std::ops::DerefMut;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Bar{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Emm {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+fn main() {\n+    let a = Emm(Foo(Bar(0)));\n+    let _: *mut u8 = &a; //~ ERROR mismatched types\n+}"}, {"sha": "ebdd345809af563fc1e5f7862024380a06b52672", "filename": "src/test/ui/issues/issue-71676-2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e678bf9e4846bf9ac9c2f30fa9533ead51ad13/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71676-2.stderr?ref=44e678bf9e4846bf9ac9c2f30fa9533ead51ad13", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-71676-2.rs:41:22\n+   |\n+LL |     let _: *mut u8 = &a;\n+   |            -------   ^^\n+   |            |         |\n+   |            |         types differ in mutability\n+   |            |         help: consider dereferencing: `&mut ***a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*mut u8`\n+                found reference `&Emm`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}