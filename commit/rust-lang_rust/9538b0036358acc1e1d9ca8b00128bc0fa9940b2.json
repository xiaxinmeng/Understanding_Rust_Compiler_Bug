{"sha": "9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MzhiMDAzNjM1OGFjYzFlMWQ5Y2E4YjAwMTI4YmMwZmE5OTQwYjI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-15T09:40:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-15T09:40:38Z"}, "message": "Tuple types back, not constructable yet", "tree": {"sha": "b73c9feabcdcb66f6cc318e7ce03727c9db4af6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b73c9feabcdcb66f6cc318e7ce03727c9db4af6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "html_url": "https://github.com/rust-lang/rust/commit/9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25b85df3704de79467dafa30ed185e8d94cd46c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b85df3704de79467dafa30ed185e8d94cd46c7", "html_url": "https://github.com/rust-lang/rust/commit/25b85df3704de79467dafa30ed185e8d94cd46c7"}], "stats": {"total": 294, "additions": 278, "deletions": 16}, "files": [{"sha": "523aada6e6236c1a960451de3b646917a63924d4", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -236,6 +236,13 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         st.pos = st.pos + 1u;\n         ret ty::mk_rec(st.tcx, fields);\n       }\n+      'T' {\n+        assert (next(st) as char == '[');\n+        let params = ~[];\n+        while peek(st) as char != ']' { params += ~[parse_mt(st, sd)]; }\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_tup(st.tcx, params);\n+      }\n       'F' {\n         let func = parse_ty_fn(st, sd);\n         ret ty::mk_fn(st.tcx, ast::proto_fn, func.args, func.ty, func.cf,"}, {"sha": "71f9e2ca113c20a1c703d55fda2b1b49c7e1d2e8", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -120,6 +120,11 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         for t: ty::t  in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n+      ty::ty_tup(mts) {\n+        w.write_str(\"T[\");\n+        for mt in mts { enc_mt(w, cx, mt); }\n+        w.write_char(']');\n+      }\n       ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n       ty::ty_uniq(t) { w.write_char('~'); enc_ty(w, cx, t); }\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }"}, {"sha": "8f19665ea5663560929f018d8532add782b430e1", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -678,6 +678,14 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n             }\n             ret false;\n           }\n+          ty::ty_tup(mts) {\n+            for mt in mts {\n+                if helper(tcx, needle, mt.ty, get_mut(mut, mt)) {\n+                    ret true;\n+                }\n+            }\n+            ret false;\n+          }\n \n           // These may contain anything.\n           ty::ty_fn(_, _, _, _, _) {"}, {"sha": "c2b0819d5ff52ba05f9cb01958fd2dc9642baeb5", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -46,6 +46,12 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n             }\n             ret false;\n         }\n+        ty::ty_tup(elts) {\n+            for elt in elts {\n+                if type_is_gc_relevant(cx, elt.ty) { ret true; }\n+            }\n+            ret false;\n+        }\n \n         ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(cx, did);"}, {"sha": "7c01a8e2751aba5413ab6f923de1883d85776ceb", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -371,6 +371,12 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n         for f : field in fields { sub += shape_of(ccx, f.mt.ty); }\n         add_substr(s, sub);\n       }\n+      ty::ty_tup(elts) {\n+        s += ~[shape_struct];\n+        let sub = ~[];\n+        for elt in elts { sub += shape_of(ccx, elt.ty); }\n+        add_substr(s, sub);\n+      }\n \n       ty::ty_fn(_,_,_,_,_) { s += ~[shape_fn]; }\n       ty::ty_native_fn(_,_,_) { s += ~[shape_u32]; }"}, {"sha": "0cc9176a66f5b7367e127c0fb641bb1e0e97c2bd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -253,6 +253,13 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       }\n       ty::ty_param(_, _) { llty = T_typaram(cx.tn); }\n       ty::ty_type. { llty = T_ptr(cx.tydesc_type); }\n+      ty::ty_tup(elts) {\n+        let tys = ~[];\n+        for elt in elts {\n+            tys += ~[type_of_inner(cx, sp, elt.ty)];\n+        }\n+        llty = T_struct(tys);\n+      }\n     }\n     assert (llty as int != 0);\n     cx.lltypes.insert(t, llty);\n@@ -577,6 +584,11 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         for f: ty::field  in flds { tys += ~[f.mt.ty]; }\n         ret align_elements(cx, tys);\n       }\n+      ty::ty_tup(elts) {\n+        let tys = ~[];\n+        for mt in elts { tys += ~[mt.ty]; }\n+        ret align_elements(cx, tys);\n+      }\n       ty::ty_tag(tid, tps) {\n         let bcx = cx;\n         // Compute max(variant sizes).\n@@ -645,6 +657,16 @@ fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n         let llalign = umax(bcx, llalign_of(T_int()), llunitalign);\n         ret rslt(bcx, llalign);\n       }\n+      ty::ty_tup(elts) {\n+        let a = C_int(1);\n+        let bcx = cx;\n+        for e in elts {\n+            let align = align_of(bcx, e.ty);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n     }\n }\n \n@@ -1811,14 +1833,24 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let i: int = 0;\n-        for fld: ty::field  in fields {\n+        for fld: ty::field in fields {\n             r = GEP_tup_like(r.bcx, t, av, ~[0, i]);\n             let llfld_a = r.val;\n             r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n                   fld.mt.ty);\n             i += 1;\n         }\n       }\n+      ty::ty_tup(args) {\n+        let i = 0;\n+        for arg in args {\n+            r = GEP_tup_like(r.bcx, t, av, ~[0, i]);\n+            let llfld_a = r.val;\n+            r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, arg.ty),\n+                  arg.ty);\n+            i += 1;\n+        }\n+      }\n       ty::ty_res(_, inner, tps) {\n         let tcx = bcx_tcx(cx);\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n@@ -4737,6 +4769,26 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n     ret rslt(bcx, retval);\n }\n \n+fn trans_tup(cx: &@block_ctxt, elts: &[ast::elt], id: ast::node_id)\n+    -> result {\n+    let bcx = cx;\n+    let t = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let tup_res = alloc_ty(bcx, t);\n+    let tup_val = tup_res.val;\n+    bcx = tup_res.bcx;\n+    add_clean_temp(cx, tup_val, t);\n+    let i: int = 0;\n+    for e in elts {\n+        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n+        let src = trans_lval(bcx, e.expr);\n+        bcx = src.res.bcx;\n+        let dst_res = GEP_tup_like(bcx, t, tup_val, ~[0, i]);\n+        bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty).bcx;\n+        i += 1;\n+    }\n+    ret rslt(bcx, tup_val);\n+}\n+\n fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n    result {\n     let t = node_id_type(bcx_ccx(cx), id);\n@@ -5085,6 +5137,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         ret trans_ivec(cx, args, e.id);\n       }\n       ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n+      ast::expr_tup(args) { ret trans_tup(cx, args, e.id); }\n       ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(\"unexpanded macro\"); }\n       ast::expr_fail(expr) { ret trans_fail_expr(cx, some(e.span), expr); }\n       ast::expr_log(lvl, a) { ret trans_log(lvl, cx, a); }"}, {"sha": "343fb055e08b4f6cfb1d22d28b61c158edca117f", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -174,9 +174,9 @@ fn mk_spawn_wrapper(cx: &@block_ctxt, func: &@ast::expr, args_ty: &ty::t) ->\n     // unpack the arguments\n \n     alt ty::struct(fcx.lcx.ccx.tcx, args_ty) {\n-      ty::ty_rec(fields) {\n+      ty::ty_tup(elts) {\n         let i = 0;\n-        for f: ty::field  in fields {\n+        for elt in elts {\n             let src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n             i += 1;\n             let child_arg = fbcx.build.Load(src);"}, {"sha": "4f651da9f8f8bac5f6e2e13c71e206a09aadfdc5", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -404,6 +404,9 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         alt maybe_base { none. {/* no-op */ } some(b) { es += ~[b]; } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n+      expr_tup(elts) {\n+        find_pre_post_exprs(fcx, elt_exprs(elts), e.id);\n+      }\n       expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n       expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }\n       expr_assign(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_assign); }"}, {"sha": "d3b5701dd5265fcb048fb48ad9a19a2b488edfce", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -388,6 +388,12 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         }\n         ret changed;\n       }\n+      expr_tup(elts) {\n+        ret find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      ivec::init_elt(init_assign,\n+                                                     ivec::len(elts)),\n+                                      elt_exprs(elts), return);\n+      }\n       expr_move(lhs, rhs) {\n         ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);\n       }"}, {"sha": "b0d0ab7b7e9f47344c3fd4d5028505902331bdac", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 126, "deletions": 12, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -47,6 +47,7 @@ export expr_ty_params_and_ty;\n export fold_ty;\n export field;\n export field_idx;\n+export field_num;\n export fm_general;\n export get_element_type;\n export hash_ty;\n@@ -69,6 +70,7 @@ export mk_float;\n export mk_fn;\n export mk_imm_box;\n export mk_mut_ptr;\n+export mk_imm_tup;\n export mk_imm_vec;\n export mk_int;\n export mk_istr;\n@@ -83,10 +85,10 @@ export mk_param;\n export mk_port;\n export mk_ptr;\n export mk_rec;\n-export mk_imm_tup;\n export mk_str;\n export mk_tag;\n export mk_task;\n+export mk_tup;\n export mk_type;\n export mk_uint;\n export mk_uniq;\n@@ -146,6 +148,7 @@ export ty_rec;\n export ty_str;\n export ty_tag;\n export ty_task;\n+export ty_tup;\n export ty_type;\n export ty_uint;\n export ty_uniq;\n@@ -279,6 +282,7 @@ tag sty {\n     ty_native_fn(ast::native_abi, [arg], t);\n     ty_obj([method]);\n     ty_res(def_id, t, [t]);\n+    ty_tup([mt]);\n     ty_var(int); // type variable\n \n     ty_param(uint, ast::kind); // fn/tag type param\n@@ -301,6 +305,8 @@ tag type_err {\n     terr_controlflow_mismatch;\n     terr_box_mutability;\n     terr_vec_mutability;\n+    terr_tuple_size(uint, uint);\n+    terr_tuple_mutability;\n     terr_record_size(uint, uint);\n     terr_record_mutability;\n     terr_record_fields(ast::ident, ast::ident);\n@@ -485,6 +491,11 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n             derive_flags_mt(cx, has_params, has_vars, f.mt);\n         }\n       }\n+      ty_tup(mts) {\n+        for m in mts {\n+            derive_flags_mt(cx, has_params, has_vars, m);\n+        }\n+      }\n       ty_fn(_, args, tt, _, _) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n@@ -590,20 +601,19 @@ fn mk_task(cx: &ctxt) -> t { ret gen_ty(cx, ty_task); }\n \n fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_imm_tup(cx: &ctxt, tys: &[t]) -> t {\n-    let fields = ~[];\n-    let i = 0u;\n-    for typ: t  in tys {\n-        fields += ~[{ident: #fmt(\"_%u\", i), mt: {ty: typ, mut: ast::imm}}];\n-        i += 1u;\n-    }\n-    ret gen_ty(cx, ty_rec(fields));\n-}\n-\n fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n \n+fn mk_tup(cx: &ctxt, tms: &[mt]) -> t { ret gen_ty(cx, ty_tup(tms)); }\n+\n+fn mk_imm_tup(cx: &ctxt, tys: &[t]) -> t {\n+    // TODO: map\n+    let mts = ~[];\n+    for typ in tys { mts += ~[{ty: typ, mut: ast::imm}]; }\n+    ret mk_tup(cx, mts);\n+}\n+\n fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: &t,\n          cf: &controlflow, constrs: &[@constr]) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n@@ -677,6 +687,9 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_rec(fields) {\n         for fl: field  in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n+      ty_tup(mts) {\n+        for tm in mts { walk_ty(cx, walker, tm.ty); }\n+      }\n       ty_fn(proto, args, ret_ty, _, _) {\n         for a: arg  in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n@@ -762,6 +775,14 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n         }\n         ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n       }\n+      ty_tup(mts) {\n+        let new_mts = ~[];\n+        for tm in mts {\n+            let new_subty = fold_ty(cx, fld, tm.ty);\n+            new_mts += ~[{ty: new_subty, mut: tm.mut}];\n+        }\n+        ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n+      }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n         let new_args: [arg] = ~[];\n         for a: arg  in args {\n@@ -861,6 +882,7 @@ fn type_is_task(cx: &ctxt, ty: &t) -> bool {\n fn type_is_structural(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_rec(_) { ret true; }\n+      ty_tup(_) { ret true; }\n       ty_tag(_, _) { ret true; }\n       ty_fn(_, _, _, _, _) { ret true; }\n       ty_obj(_) { ret true; }\n@@ -925,6 +947,7 @@ fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_box(_) { ret true; }\n       ty_rec(_) { ret true; }\n+      ty_tup(_) { ret true; }\n       ty_tag(_, _) { ret true; }\n       _ { ret false; }\n     }\n@@ -933,6 +956,7 @@ fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n fn get_element_type(cx: &ctxt, ty: &t, i: uint) -> t {\n     alt struct(cx, ty) {\n       ty_rec(flds) { ret flds.(i).mt.ty; }\n+      ty_tup(mts) { ret mts.(i).ty; }\n       _ {\n         cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n                         \" - expected a \\\n@@ -1006,6 +1030,11 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n             }\n         }\n       }\n+      ty_tup(elts) {\n+        for m in elts {\n+            if type_has_pointers(cx, m.ty) { result = true; }\n+        }\n+      }\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n         for variant: variant_info  in variants {\n@@ -1196,6 +1225,14 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n         }\n         ret false;\n       }\n+      ty_tup(mts) {\n+        let i = 0u;\n+        while i < ivec::len(mts) {\n+            if type_has_dynamic_size(cx, mts.(i).ty) { ret true; }\n+            i += 1u;\n+        }\n+        ret false;\n+      }\n       ty_fn(_, _, _, _, _) { ret false; }\n       ty_native_fn(_, _, _) { ret false; }\n       ty_obj(_) { ret false; }\n@@ -1317,12 +1354,16 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n             if type_owns_heap_mem(cx, f.mt.ty) { result = true; }\n         }\n       }\n+      ty_tup(elts) {\n+        for m in elts {\n+            if type_owns_heap_mem(cx, m.ty) { result = true; }\n+        }\n+      }\n       ty_res(_, inner, tps) {\n         result =\n             type_owns_heap_mem(cx, substitute_type_params(cx, tps, inner));\n       }\n \n-\n       ty_ptr(_) {\n         result = false;\n       }\n@@ -1368,6 +1409,11 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n                 if !type_is_pod(cx, f.mt.ty) { result = false; }\n             }\n         }\n+        ty_tup(elts) {\n+            for elt in elts {\n+                if !type_is_pod(cx, elt.ty) { result = false; }\n+            }\n+        }\n         ty_res(_, inner, tps) {\n             result = type_is_pod(cx,\n                 substitute_type_params(cx, tps, inner));\n@@ -1517,6 +1563,11 @@ fn hash_type_structure(st: &sty) -> uint {\n         for f: field  in fields { h += h << 5u + hash_ty(f.mt.ty); }\n         ret h;\n       }\n+      ty_tup(mts) {\n+        let h = 25u;\n+        for tm in mts { h += h << 5u + hash_ty(tm.ty); }\n+        ret h;\n+      }\n \n       // ???\n       ty_fn(_, args, rty, _, _) {\n@@ -1698,6 +1749,22 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n           _ { ret false; }\n         }\n       }\n+      ty_tup(mts_a) {\n+        alt (b) {\n+          ty_tup(mts_b) {\n+            let len = ivec::len(mts_a);\n+            if len != ivec::len(mts_b) { ret false; }\n+            let i = 0u;\n+            while i < len {\n+                if !equal_mt(mts_a.(i), mts_b.(i)) { ret false; }\n+                i += 1u;\n+            }\n+            ret true;\n+          }\n+          _ { ret false; }\n+        }\n+      }\n+\n       ty_fn(p_a, args_a, rty_a, cf_a, constrs_a) {\n         alt b {\n           ty_fn(p_b, args_b, rty_b, cf_b, constrs_b) {\n@@ -2659,6 +2726,44 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n+          ty::ty_tup(expected_elems) {\n+            alt struct(cx.tcx, actual) {\n+              ty::ty_tup(actual_elems) {\n+                let expected_len = ivec::len(expected_elems);\n+                let actual_len = ivec::len(actual_elems);\n+                if (expected_len != actual_len) {\n+                    let err = terr_tuple_size(expected_len, actual_len);\n+                    ret ures_err(err);\n+                }\n+                // TODO: implement an iterator that can iterate over\n+                // two arrays simultaneously.\n+\n+                let result_elems = ~[];\n+                let i = 0u;\n+                while i < expected_len {\n+                    let expected_elem = expected_elems.(i);\n+                    let actual_elem = actual_elems.(i);\n+                    let mut;\n+                    alt unify_mut(expected_elem.mut, actual_elem.mut) {\n+                      none. { ret ures_err(terr_tuple_mutability); }\n+                      some(m) { mut = m; }\n+                    }\n+                    let result = unify_step(cx, expected_elem.ty,\n+                                            actual_elem.ty);\n+                    alt result {\n+                      ures_ok(rty) {\n+                        let mt = {ty: rty, mut: mut};\n+                        result_elems += ~[mt];\n+                      }\n+                      _ { ret result; }\n+                    }\n+                    i += 1u;\n+                }\n+                ret ures_ok(mk_tup(cx.tcx, result_elems));\n+              }\n+              _ { ret ures_err(terr_mismatch); }\n+            }\n+          }\n           ty::ty_fn(ep, expected_inputs, expected_output, expected_cf,\n                     expected_constrs) {\n             alt struct(cx.tcx, actual) {\n@@ -2802,6 +2907,14 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n       }\n       terr_box_mutability. { ret \"boxed values differ in mutability\"; }\n       terr_vec_mutability. { ret \"vectors differ in mutability\"; }\n+      terr_tuple_size(e_sz, a_sz) {\n+        ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n+            \" elements but found one with \" + uint::to_str(a_sz, 10u)\n+            + \" elements\";\n+      }\n+      terr_tuple_mutability. {\n+        ret \"tuple elements differ in mutability\";\n+      }\n       terr_record_size(e_sz, a_sz) {\n         ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n                 \" fields but found one with \" + uint::to_str(a_sz, 10u) +\n@@ -3044,6 +3157,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n           ty_vec(_) { tycat_vec }\n           ty_ivec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }\n+          ty_tup(_) { tycat_struct }\n           ty_tag(_, _) { tycat_struct }\n           ty_bot.    { tycat_bot }\n           _ { tycat_other }"}, {"sha": "64b900f80530802a099085558b7806b075fd2529", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -339,6 +339,10 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       ast::ty_chan(t) {\n         typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n       }\n+      ast::ty_tup(fields) {\n+        let flds = ivec::map(bind ast_mt_to_mt(tcx, getter, _), fields);\n+        typ = ty::mk_tup(tcx, flds);\n+      }\n       ast::ty_rec(fields) {\n         let flds: [field] = ~[];\n         for f: ast::ty_field  in fields {\n@@ -2160,7 +2164,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_vec(args, mut, kind) {\n-        let t: ty::t = next_ty_var(fcx);;\n+        let t: ty::t = next_ty_var(fcx);\n         for e: @ast::expr in args {\n             bot |= check_expr_with(fcx, e, t);\n         }\n@@ -2173,6 +2177,17 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n         write::ty_only_fixup(fcx, id, typ);\n       }\n+      ast::expr_tup(elts) {\n+        let elts_mt = ~[];\n+        ivec::reserve(elts_mt, ivec::len(elts));\n+        for e in elts {\n+            check_expr(fcx, e.expr);\n+            let ety = expr_ty(fcx.ccx.tcx, e.expr);\n+            elts_mt += ~[{ty: ety, mut: e.mut}];\n+        }\n+        let typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n+        write::ty_only_fixup(fcx, id, typ);\n+      }\n       ast::expr_rec(fields, base) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n         let fields_t: [spanned[field]] = ~[];"}, {"sha": "4052c5cc1d8cc1af66ea44e4fee07edf42608dbd", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -292,6 +292,7 @@ tag expr_ {\n     expr_vec([@expr], mutability, seq_kind);\n     expr_rec([field], option::t[@expr]);\n     expr_call(@expr, [@expr]);\n+    expr_tup([elt]);\n     expr_self_method(ident);\n     expr_bind(@expr, [option::t[@expr]]);\n     expr_spawn(spawn_dom, option::t[str], @expr, [@expr]);\n@@ -447,6 +448,7 @@ tag ty_ {\n     ty_rec([ty_field]);\n     ty_fn(proto, [ty_arg], @ty, controlflow, [@constr]);\n     ty_obj([ty_method]);\n+    ty_tup([mt]);\n     ty_path(path, node_id);\n     ty_type;\n     ty_constr(@ty, [@ty_constr]);"}, {"sha": "4819e893bdb9ef83edded13e0d05aecea5dac5ee", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -338,6 +338,13 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             expr_rec(ivec::map(fold_field, fields),\n                      option::map(fld.fold_expr, maybe_expr))\n           }\n+          expr_tup(elts) {\n+            let elts_ = ~[];\n+            for elt in elts {\n+                elts_ += ~[{mut: elt.mut, expr: fld.fold_expr(elt.expr)}];\n+            }\n+            expr_tup(elts_)\n+          }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n           }"}, {"sha": "58c7b618ec3ae20ef69781791c8d259080b9056f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -1569,6 +1569,7 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n         ret alt e.node {\n               ast::expr_vec(_, _, _) { true }\n               ast::expr_rec(_, _) { true }\n+              ast::expr_tup(_) { true }\n               ast::expr_call(_, _) { true }\n               ast::expr_self_method(_) { false }\n               ast::expr_bind(_, _) { true }"}, {"sha": "deae225a221648729beab271646ec35e85d97c56", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -322,6 +322,11 @@ fn print_type(s: &ps, ty: &ast::ty) {\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         word(s.s, \"}\");\n       }\n+      ast::ty_tup(elts) {\n+          popen(s);\n+          commasep(s, inconsistent, elts, print_mt);\n+          pclose(s);\n+      }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n         print_ty_fn(s, proto, none[str], inputs, output, cf, constrs);\n       }\n@@ -713,6 +718,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         alt kind {\n           ast::sk_rc. { word(s.s, \"[\"); }\n           ast::sk_unique. { word(s.s, \"~[\"); }\n+\n         }\n         if mut == ast::mut {\n             word(s.s, \"mutable\");\n@@ -746,6 +752,18 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         }\n         word(s.s, \"}\");\n       }\n+      ast::expr_tup(exprs) {\n+        fn printElt(s: &ps, elt: &ast::elt) {\n+            ibox(s, indent_unit);\n+            if elt.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n+            print_expr(s, elt.expr);\n+            end(s);\n+        }\n+        fn get_span(elt: &ast::elt) -> codemap::span { ret elt.expr.span; }\n+        popen(s);\n+        commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n+        pclose(s);\n+      }\n       ast::expr_call(func, args) {\n         print_expr_parens_if_unary(s, func);\n         popen(s);"}, {"sha": "4b1f709a9fcab44f4cf090527f6f12b8bab28797", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -133,6 +133,9 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n       ty_rec(flds) {\n         for f: ty_field  in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n+      ty_tup(mts) {\n+        for mt in mts { v.visit_ty(mt.ty, e, v); }\n+      }\n       ty_fn(_, args, out, _, constrs) {\n         for a: ty_arg  in args { v.visit_ty(a.node.ty, e, v); }\n         for c: @constr  in constrs {\n@@ -244,6 +247,9 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n         for f: field  in flds { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n+      expr_tup(elts) {\n+        for el in elts { v.visit_expr(el.expr, e, v); }\n+      }\n       expr_call(callee, args) {\n         v.visit_expr(callee, e, v);\n         visit_exprs(args, e, v);"}, {"sha": "eadcb1422d0df26b67db615145a5849b30259135", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9538b0036358acc1e1d9ca8b00128bc0fa9940b2/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=9538b0036358acc1e1d9ca8b00128bc0fa9940b2", "patch": "@@ -103,6 +103,11 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         for fld: field  in elems { strs += ~[field_to_str(cx, fld)]; }\n         s += \"{\" + str::connect(strs, \",\") + \"}\";\n       }\n+      ty_tup(elems) {\n+        let strs = ~[];\n+        for tm in elems { strs += ~[mt_to_str(cx, tm)]; }\n+        s += \"(\" + str::connect(strs, \",\") + \")\";\n+      }\n       ty_tag(id, tps) {\n         // The user should never see this if the cname is set properly!\n "}]}