{"sha": "f3ee99bd4d9d282c33127449073c521f29b07c21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZWU5OWJkNGQ5ZDI4MmMzMzEyNzQ0OTA3M2M1MjFmMjliMDdjMjE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-20T23:13:14Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-22T11:32:56Z"}, "message": "try to recover the non-matching types in projection errors\n\nThe type equation in projection takes place under a binder and a snapshot, which\nwe can't easily take types out of. Instead, when encountering a projection error,\ntry to re-do the projection and find the type error then.\n\nThis fails to produce a sane type error when the failure was a \"leak_check\" failure.\nI can't think of a sane way to show *these*, so I just left them use the old crappy\nrepresentation, and added a test to make sure we don't break them.", "tree": {"sha": "5628ddb3c510048143500c5228f93e3cb64c3e82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5628ddb3c510048143500c5228f93e3cb64c3e82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ee99bd4d9d282c33127449073c521f29b07c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ee99bd4d9d282c33127449073c521f29b07c21", "html_url": "https://github.com/rust-lang/rust/commit/f3ee99bd4d9d282c33127449073c521f29b07c21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ee99bd4d9d282c33127449073c521f29b07c21/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "712c5cadbbb460a0b313a2fbcdaa9d6e10a25b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/712c5cadbbb460a0b313a2fbcdaa9d6e10a25b6b", "html_url": "https://github.com/rust-lang/rust/commit/712c5cadbbb460a0b313a2fbcdaa9d6e10a25b6b"}], "stats": {"total": 122, "additions": 100, "deletions": 22}, "files": [{"sha": "33ca1d05cad7e0f68d4857bea4f3089ea0308291", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 60, "deletions": 21, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f3ee99bd4d9d282c33127449073c521f29b07c21", "patch": "@@ -26,8 +26,9 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt, TypeOrigin};\n+use infer::{self, InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::{self, Subst, TypeSpace};\n@@ -107,28 +108,66 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let predicate =\n             self.resolve_type_vars_if_possible(&obligation.predicate);\n \n-        if !predicate.references_error() {\n-            if let Some(warning_node_id) = warning_node_id {\n-                self.tcx.sess.add_lint(\n-                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                    warning_node_id,\n+        if predicate.references_error() {\n+            return\n+        }\n+        if let Some(warning_node_id) = warning_node_id {\n+            self.tcx.sess.add_lint(\n+                ::lint::builtin::UNSIZED_IN_TUPLE,\n+                warning_node_id,\n+                obligation.cause.span,\n+                format!(\"type mismatch resolving `{}`: {}\",\n+                        predicate,\n+                        error.err));\n+            return\n+        }\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(obligation.cause.span);\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_late_bound_regions_with_fresh_var(\n                     obligation.cause.span,\n-                    format!(\"type mismatch resolving `{}`: {}\",\n-                            predicate,\n-                            error.err));\n-            } else {\n-                let mut err = type_err!(\n-                    self,\n-                    TypeOrigin::Misc(obligation.cause.span),\n-                    None, // FIXME: be smarter\n-                    error.err,\n-                    E0271,\n-                    \"type mismatch resolving `{}`\",\n-                    predicate);\n-                self.note_obligation_cause(&mut err, obligation);\n-                err.emit();\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data);\n+                let normalized = super::normalize_projection_type(\n+                    &mut selcx,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0\n+                );\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n+                if let Err(error) = self.eq_types(\n+                    false, origin,\n+                    data.ty, normalized.value\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound {\n+                        expected: normalized.value,\n+                        found: data.ty,\n+                    }));\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n             }\n-        }\n+\n+            let mut diag = type_err!(\n+                self,\n+                origin,\n+                values,\n+                err,\n+                E0271,\n+                \"type mismatch resolving `{}`\",\n+                predicate);\n+            self.note_obligation_cause(&mut diag, obligation);\n+            diag.emit();\n+        });\n     }\n \n     fn impl_substs(&self,"}, {"sha": "12341fa8db38f790c487a7ff0382b81be3e8abb7", "filename": "src/test/compile-fail/associated-types/higher-ranked-projection.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=f3ee99bd4d9d282c33127449073c521f29b07c21", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// revisions: good bad\n+\n+trait Mirror {\n+    type Image;\n+}\n+\n+impl<T> Mirror for T {\n+    type Image = T;\n+}\n+\n+#[cfg(bad)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=U>\n+{}\n+\n+#[cfg(good)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=&'a U>\n+{}\n+\n+#[rustc_error]\n+fn main() { //[good]~ ERROR compilation successful\n+    foo(());\n+    //[bad]~^ ERROR type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n+    //[bad]~| expected bound lifetime parameter 'a, found concrete lifetime\n+}"}, {"sha": "fb1e3cc87e88cf610da2b7a31fbb34e8bd486621", "filename": "src/test/compile-fail/issue-31173.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ee99bd4d9d282c33127449073c521f29b07c21/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs?ref=f3ee99bd4d9d282c33127449073c521f29b07c21", "patch": "@@ -19,7 +19,8 @@ pub fn get_tok(it: &mut IntoIter<u8>) {\n     })\n         .cloned()\n         //~^ ERROR type mismatch resolving\n-        //~| expected u8, found &-ptr\n+        //~| expected type `u8`\n+        //~| found type `&_`\n         .collect(); //~ ERROR no method named `collect`\n }\n "}]}