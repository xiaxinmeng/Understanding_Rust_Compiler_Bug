{"sha": "7311b6347de4205b71e8a221140a527e789fd353", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMTFiNjM0N2RlNDIwNWI3MWU4YTIyMTE0MGE1MjdlNzg5ZmQzNTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:47:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:47:11Z"}, "message": "rollup merge of #20053: csouth3/misc-stab\n\nThis pull request:\n\n*Renames `BinaryHeap::top` to `BinaryHeap::peek`\n*Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`\n*Stabilizes `swap` in `RingBuf`\n\nin accordance with rust-lang/rfcs#509.\n\nNote that this PR does not address `Bitv::{get,set}` or HashMap's iterators, nor does it move `std::vec` to `std::collections::vec`, all of which still need to be done.\n\nBecause of the method renaming, this is a [breaking-change].", "tree": {"sha": "120893dba41dffacb5b21c6f5c75cafae9fffd2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/120893dba41dffacb5b21c6f5c75cafae9fffd2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7311b6347de4205b71e8a221140a527e789fd353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7311b6347de4205b71e8a221140a527e789fd353", "html_url": "https://github.com/rust-lang/rust/commit/7311b6347de4205b71e8a221140a527e789fd353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7311b6347de4205b71e8a221140a527e789fd353/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b04bc5cc49a398df712092a68ab9ad83019498ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b04bc5cc49a398df712092a68ab9ad83019498ad", "html_url": "https://github.com/rust-lang/rust/commit/b04bc5cc49a398df712092a68ab9ad83019498ad"}, {"sha": "abf492d44f0a3b705be8c0920bfb4771f039b843", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf492d44f0a3b705be8c0920bfb4771f039b843", "html_url": "https://github.com/rust-lang/rust/commit/abf492d44f0a3b705be8c0920bfb4771f039b843"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "051001cf3c6bb95bd18ca95b6b7c4730b1ee87e2", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=7311b6347de4205b71e8a221140a527e789fd353", "patch": "@@ -272,15 +272,16 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     ///\n     /// let mut heap = BinaryHeap::new();\n-    /// assert_eq!(heap.top(), None);\n+    /// assert_eq!(heap.peek(), None);\n     ///\n     /// heap.push(1i);\n     /// heap.push(5i);\n     /// heap.push(2i);\n-    /// assert_eq!(heap.top(), Some(&5i));\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     ///\n     /// ```\n-    pub fn top(&self) -> Option<&T> {\n+    #[stable]\n+    pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n \n@@ -388,7 +389,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(1i);\n     ///\n     /// assert_eq!(heap.len(), 3);\n-    /// assert_eq!(heap.top(), Some(&5i));\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n@@ -412,7 +413,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.push_pop(3i), 5);\n     /// assert_eq!(heap.push_pop(9i), 9);\n     /// assert_eq!(heap.len(), 2);\n-    /// assert_eq!(heap.top(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n@@ -442,7 +443,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.replace(1i), None);\n     /// assert_eq!(heap.replace(3i), Some(1i));\n     /// assert_eq!(heap.len(), 1);\n-    /// assert_eq!(heap.top(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -714,13 +715,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_top_and_pop() {\n+    fn test_peek_and_pop() {\n         let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = BinaryHeap::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n+            assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n             assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n         }\n     }\n@@ -729,44 +730,44 @@ mod tests {\n     fn test_push() {\n         let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == 9);\n+        assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == 103);\n+        assert!(*heap.peek().unwrap() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == box 9);\n+        assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == box 103);\n+        assert!(*heap.peek().unwrap() == box 103);\n     }\n \n     #[test]\n@@ -831,9 +832,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_empty_top() {\n+    fn test_empty_peek() {\n         let empty = BinaryHeap::<int>::new();\n-        assert!(empty.top().is_none());\n+        assert!(empty.peek().is_none());\n     }\n \n     #[test]"}, {"sha": "d5e6676872656d3ed8606256d23458f1c77dd94d", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7311b6347de4205b71e8a221140a527e789fd353", "patch": "@@ -451,31 +451,31 @@ impl<T> DList<T> {\n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }"}, {"sha": "29fb863b6bea0217f3bfa1619942bf4c89b752b7", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7311b6347de4205b71e8a221140a527e789fd353/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=7311b6347de4205b71e8a221140a527e789fd353", "patch": "@@ -228,6 +228,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n+    #[stable]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -546,7 +547,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -570,7 +571,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -590,7 +591,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -614,7 +615,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }"}]}