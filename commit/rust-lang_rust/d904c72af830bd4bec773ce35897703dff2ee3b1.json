{"sha": "d904c72af830bd4bec773ce35897703dff2ee3b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MDRjNzJhZjgzMGJkNGJlYzc3M2NlMzU4OTc3MDNkZmYyZWUzYjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-06-18T21:45:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-06-18T21:48:48Z"}, "message": "replace #[inline(always)] with #[inline]. r=burningtree.", "tree": {"sha": "c9253d1282f12af3aac7e854cd1115cd2eede863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9253d1282f12af3aac7e854cd1115cd2eede863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d904c72af830bd4bec773ce35897703dff2ee3b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d904c72af830bd4bec773ce35897703dff2ee3b1", "html_url": "https://github.com/rust-lang/rust/commit/d904c72af830bd4bec773ce35897703dff2ee3b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d904c72af830bd4bec773ce35897703dff2ee3b1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303d7bfc87ca370354ac4264cc23a80cbcd8a792", "url": "https://api.github.com/repos/rust-lang/rust/commits/303d7bfc87ca370354ac4264cc23a80cbcd8a792", "html_url": "https://github.com/rust-lang/rust/commit/303d7bfc87ca370354ac4264cc23a80cbcd8a792"}], "stats": {"total": 2638, "additions": 1319, "deletions": 1319}, "files": [{"sha": "6dc37ef58d3ad33dbca58002a5adf048ea20d035", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -58,7 +58,7 @@ pub struct Condvar<'self> {\n \n impl<'self> Condvar<'self> {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n-    #[inline(always)]\n+    #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n@@ -67,7 +67,7 @@ impl<'self> Condvar<'self> {\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn wait_on(&self, condvar_id: uint) {\n         assert!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n@@ -76,28 +76,28 @@ impl<'self> Condvar<'self> {\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    #[inline(always)]\n+    #[inline]\n     pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /**\n      * Wake up a blocked task on a specified condvar (as\n      * sync::cond.signal_on). Returns false if there was no blocked task.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn signal_on(&self, condvar_id: uint) -> bool {\n         assert!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    #[inline(always)]\n+    #[inline]\n     pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /**\n      * Wake up all blocked tasks on a specified condvar (as\n      * sync::cond.broadcast_on). Returns the number of tasks woken.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         assert!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n@@ -198,7 +198,7 @@ impl<T:Owned> MutexARC<T> {\n      * any tasks that subsequently try to access it (including those already\n      * blocked on the mutex) will also fail immediately.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n@@ -213,7 +213,7 @@ impl<T:Owned> MutexARC<T> {\n     }\n \n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn access_cond<'x, 'c, U>(&self,\n                                          blk: &fn(x: &'x mut T,\n                                                   c: &'c Condvar) -> U)\n@@ -231,7 +231,7 @@ impl<T:Owned> MutexARC<T> {\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n-#[inline(always)]\n+#[inline]\n #[doc(hidden)]\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n@@ -322,7 +322,7 @@ impl<T:Const + Owned> RWARC<T> {\n      * that other tasks won't block forever. As MutexARC.access, it will also\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n@@ -335,7 +335,7 @@ impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n-    #[inline(always)]\n+    #[inline]\n     pub fn write_cond<'x, 'c, U>(&self,\n                                  blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                                  -> U {"}, {"sha": "db4cf564babc593261f78ffd0e77597833d3b8d8", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -119,7 +119,7 @@ pub fn Arena() -> Arena {\n     arena_with_size(32u)\n }\n \n-#[inline(always)]\n+#[inline]\n fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n@@ -156,12 +156,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // initialized in the arena in the low bit of the tydesc pointer. This\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n-#[inline(always)]\n+#[inline]\n unsafe fn bitpack_tydesc_ptr(p: *TypeDesc, is_done: bool) -> uint {\n     let p_bits: uint = transmute(p);\n     p_bits | (is_done as uint)\n }\n-#[inline(always)]\n+#[inline]\n unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n@@ -179,7 +179,7 @@ impl Arena {\n         return self.alloc_pod_inner(n_bytes, align);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             // XXX: Borrow check\n@@ -199,7 +199,7 @@ impl Arena {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -223,7 +223,7 @@ impl Arena {\n         return self.alloc_nonpod_inner(n_bytes, align);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n                           -> (*u8, *u8) {\n         unsafe {\n@@ -246,7 +246,7 @@ impl Arena {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -268,7 +268,7 @@ impl Arena {\n     }\n \n     // The external interface\n-    #[inline(always)]\n+    #[inline]\n     pub fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check"}, {"sha": "647fa81c71857584cd6cbd04411dec7a4b799a96", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -23,7 +23,7 @@ struct SmallBitv {\n }\n \n /// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n-#[inline(always)]\n+#[inline]\n fn small_mask(nbits: uint) -> uint {\n     (1 << nbits) - 1\n }\n@@ -33,7 +33,7 @@ impl SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn bits_op(&mut self,\n                    right_bits: uint,\n                    nbits: uint,\n@@ -46,32 +46,32 @@ impl SmallBitv {\n         mask & old_b != mask & new_b\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n@@ -81,29 +81,29 @@ impl SmallBitv {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self) { self.bits = 0; }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set_all(&mut self) { self.bits = !0; }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) { self.bits = !self.bits; }\n }\n \n@@ -115,7 +115,7 @@ struct BigBitv {\n  * a mask that has a 1 for each defined bit in the nth element of a big_bitv,\n  * assuming n bits.\n  */\n-#[inline(always)]\n+#[inline]\n fn big_mask(nbits: uint, elem: uint) -> uint {\n     let rmd = nbits % uint::bits;\n     let nelems = nbits/uint::bits + if rmd == 0 {0} else {1};\n@@ -132,7 +132,7 @@ impl BigBitv {\n         BigBitv {storage: storage}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn process(&mut self,\n                    b: &BigBitv,\n                    nbits: uint,\n@@ -154,43 +154,43 @@ impl BigBitv {\n         changed\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n         uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |_, w| w)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n@@ -199,7 +199,7 @@ impl BigBitv {\n                           else { self.storage[w] & !flag };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n@@ -229,7 +229,7 @@ fn die() -> ! {\n }\n \n impl Bitv {\n-    #[inline(always)]\n+    #[inline]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n             die();\n@@ -279,7 +279,7 @@ impl Bitv {\n      * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n      * the same length. Returns 'true' if `self` changed.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n@@ -288,7 +288,7 @@ impl Bitv {\n      * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, v1: &Bitv) -> bool {\n         self.do_op(Intersect, v1)\n     }\n@@ -299,11 +299,11 @@ impl Bitv {\n      * Both bitvectors must be the same length. Returns `true` if `self` was\n      * changed\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         assert!((i < self.nbits));\n         match self.rep {\n@@ -317,7 +317,7 @@ impl Bitv {\n      *\n      * `i` must be less than the length of the bitvector.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n       assert!((i < self.nbits));\n       match self.rep {\n@@ -332,7 +332,7 @@ impl Bitv {\n      * Both bitvectors must be the same length. Returns `true` if both\n      * bitvectors contain identical elements.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n@@ -348,7 +348,7 @@ impl Bitv {\n     }\n \n     /// Set all bits to 0\n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self) {\n         match self.rep {\n           Small(ref mut b) => b.clear(),\n@@ -357,15 +357,15 @@ impl Bitv {\n     }\n \n     /// Set all bits to 1\n-    #[inline(always)]\n+    #[inline]\n     pub fn set_all(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.set_all(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.invert(),\n@@ -381,13 +381,13 @@ impl Bitv {\n      *\n      * Returns `true` if `v0` was changed.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, v: &Bitv) -> bool {\n         self.do_op(Difference, v)\n     }\n \n     /// Returns true if all bits are 1\n-    #[inline(always)]\n+    #[inline]\n     pub fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n@@ -398,7 +398,7 @@ impl Bitv {\n       }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n         let mut i = 0;\n         while i < self.nbits {\n@@ -508,7 +508,7 @@ impl Bitv {\n \n impl Clone for Bitv {\n     /// Makes a copy of a bitvector\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> Bitv {\n         match self.rep {\n           Small(ref b) => {\n@@ -562,7 +562,7 @@ impl ops::Index<uint,bool> for Bitv {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n@@ -623,7 +623,7 @@ impl BitvSet {\n         return Bitv{ nbits:cap, rep: Big(~bitv) };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;"}, {"sha": "953803c6843f7fbfc848d8a08c1a855a1ff8c04c", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -160,7 +160,7 @@ impl<T> DList<T> {\n     }\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n-    #[inline(always)]\n+    #[inline]\n     fn link(&mut self, before: DListLink<T>, after: DListLink<T>) {\n         match before {\n             Some(neighbour) => neighbour.next = after,\n@@ -532,7 +532,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n         return true;\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n "}, {"sha": "90ca3bc47c08fe318f30569df7bfec4ee676f1dc", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -83,7 +83,7 @@ impl<T: Clone + Num> Cmplx<T> {\n #[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Algebraic + Num> Cmplx<T> {\n     /// Calculate |self|\n-    #[inline(always)]\n+    #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(&self.im)\n     }\n@@ -92,7 +92,7 @@ impl<T: Clone + Algebraic + Num> Cmplx<T> {\n #[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n-    #[inline(always)]\n+    #[inline]\n     pub fn arg(&self) -> T {\n         self.im.atan2(&self.re)\n     }"}, {"sha": "b2b966928e9ac539c6e15beeccdfd79244dd58d6", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -36,19 +36,19 @@ pub type BigRational = Ratio<BigInt>;\n impl<T: Clone + Integer + Ord>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn from_integer(t: T) -> Ratio<T> {\n         Ratio::new_raw(t, One::one())\n     }\n \n     /// Create a ratio without checking for `denom == 0` or reducing.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n         Ratio { numer: numer, denom: denom }\n     }\n \n     /// Create a new Ratio. Fails if `denom == 0`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n             fail!(\"denominator == 0\");\n@@ -206,7 +206,7 @@ impl<T: Clone + Integer + Ord>\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n             Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n@@ -215,7 +215,7 @@ impl<T: Clone + Integer + Ord>\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> Ratio<T> {\n         Ratio::from_integer(self.numer / self.denom)\n     }"}, {"sha": "b90b0983dc246d28537abe65affc982855e49451", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -60,7 +60,7 @@ pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n }\n \n impl<T> Rc<T> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n     }"}, {"sha": "cb372dd920da92e7fee867042749f24656458e6e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -29,7 +29,7 @@ pub enum Identifier {\n }\n \n impl cmp::Ord for Identifier {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Identifier) -> bool {\n         match (self, other) {\n             (&Numeric(a), &Numeric(b)) => a < b,\n@@ -38,22 +38,22 @@ impl cmp::Ord for Identifier {\n             (&AlphaNumeric(_), _) => false\n         }\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Identifier) -> bool {\n         ! (other < self)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Identifier) -> bool {\n         other < self\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Identifier) -> bool {\n         ! (self < other)\n     }\n }\n \n impl ToStr for Identifier {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         match self {\n             &Numeric(n) => n.to_str(),\n@@ -73,7 +73,7 @@ pub struct Version {\n }\n \n impl ToStr for Version {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n@@ -90,7 +90,7 @@ impl ToStr for Version {\n }\n \n impl cmp::Ord for Version {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Version) -> bool {\n \n         self.major < other.major ||\n@@ -123,15 +123,15 @@ impl cmp::Ord for Version {\n              self.build < other.build)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Version) -> bool {\n         ! (other < self)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Version) -> bool {\n         other < self\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Version) -> bool {\n         ! (self < other)\n     }"}, {"sha": "3e81216fc3a1d9b3427a9079c24e3bacea244bbd", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -725,7 +725,7 @@ impl<T:Copy + Ord> MergeState<T> {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn copy_vec<T:Copy>(dest: &mut [T],\n                     s1: uint,\n                     from: &[T]) {\n@@ -736,7 +736,7 @@ fn copy_vec<T:Copy>(dest: &mut [T],\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn shift_vec<T:Copy>(dest: &mut [T],\n                      s1: uint,\n                      s2: uint,"}, {"sha": "f5d0b6946d33236be035201946360394ba61527f", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -363,7 +363,7 @@ impl<'self> Condvar<'self> {\n \n // Checks whether a condvar ID was out of bounds, and fails if so, or does\n // something else next on success.\n-#[inline(always)]\n+#[inline]\n #[doc(hidden)]\n fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: &fn() -> U) -> U {"}, {"sha": "f857581c17dd26d73333bdb18b65f60befe71276", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -75,13 +75,13 @@ fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n }\n \n impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n@@ -145,7 +145,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[inline(always)]\n+    #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n     }\n@@ -236,7 +236,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n \n impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n         do self.iter.next().map |&(value, _)| { value }\n     }\n@@ -251,69 +251,69 @@ pub struct TreeSet<T> {\n \n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n-    #[inline(always)]\n+    #[inline]\n     fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n     /// Return true if the set has no elements in common with `other`.\n@@ -336,7 +336,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Return true if the set is a subset of another\n-    #[inline(always)]\n+    #[inline]\n     fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n     }\n@@ -490,12 +490,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n impl<T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n-    #[inline(always)]\n+    #[inline]\n     pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n@@ -518,7 +518,7 @@ struct TreeNode<K, V> {\n \n impl<K: TotalOrd, V> TreeNode<K, V> {\n     /// Creates a new tree node.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }"}, {"sha": "12a26606f36e3f44ed8ddf00f39bad62626d2c57", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -104,7 +104,7 @@ struct WorkKey {\n }\n \n impl to_bytes::IterBytes for WorkKey {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n     }"}, {"sha": "07e5d9e4f25a0e936d30e48585b320cd3f521e69", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -221,7 +221,7 @@ pub static analysis_passes : &'static [(&'static str, &'static str)] = &'static\n /** Transformation Passes */\n pub static transform_passes : &'static [(&'static str, &'static str)] = &'static [\n     (\"adce\",                            \"Aggressive Dead Code Elimination\"),\n-    (\"always-inline\",                   \"Inliner for #[inline(always)] functions\"),\n+    (\"always-inline\",                   \"Inliner for #[inline] functions\"),\n     (\"argpromotion\",                    \"Promote 'by reference' arguments to scalars\"),\n     (\"bb-vectorize\",                    \"Basic-Block Vectorization\"),\n     (\"block-placement\",                 \"Profile Guided Basic Block Placement\"),"}, {"sha": "d7186ad933355d47bb23e3d6c24cdf2ac8c5f477", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -775,17 +775,17 @@ impl BorrowckCtxt {\n }\n \n impl DataFlowOperator for LoanDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // loans from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }"}, {"sha": "3b1c451d0a6ed6132c9b8bd2ed33567ab67190fd", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -571,34 +571,34 @@ impl FlowedMoveData {\n }\n \n impl DataFlowOperator for MoveDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }\n }\n \n impl DataFlowOperator for AssignDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no assignments in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }"}, {"sha": "b4942fba05da1f8dc525d28ac601388cd4e693fb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -1016,7 +1016,7 @@ fn join_bits<O:DataFlowOperator>(oper: &O,\n     bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n }\n \n-#[inline(always)]\n+#[inline]\n fn bitwise(out_vec: &mut [uint],\n            in_vec: &[uint],\n            op: &fn(uint, uint) -> uint) -> bool {"}, {"sha": "0976407b0bd0f52045184a7379a9a34c92097638", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -576,7 +576,7 @@ fn padding(size: u64) -> ValueRef {\n }\n \n // XXX this utility routine should be somewhere more general\n-#[inline(always)]\n+#[inline]\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)"}, {"sha": "4fc431e0a54caccec4e7ccb7eda8876bae16132b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -1094,62 +1094,62 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n         cast::transmute::<&'static t_box_, t>(primitive)\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_bot() -> t { mk_prim_t(&primitives::TY_BOT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_bool() -> t { mk_prim_t(&primitives::TY_BOOL) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_int() -> t { mk_prim_t(&primitives::TY_INT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i8() -> t { mk_prim_t(&primitives::TY_I8) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i16() -> t { mk_prim_t(&primitives::TY_I16) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i32() -> t { mk_prim_t(&primitives::TY_I32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i64() -> t { mk_prim_t(&primitives::TY_I64) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_float() -> t { mk_prim_t(&primitives::TY_FLOAT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_f32() -> t { mk_prim_t(&primitives::TY_F32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_f64() -> t { mk_prim_t(&primitives::TY_F64) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_uint() -> t { mk_prim_t(&primitives::TY_UINT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u8() -> t { mk_prim_t(&primitives::TY_U8) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u16() -> t { mk_prim_t(&primitives::TY_U16) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u32() -> t { mk_prim_t(&primitives::TY_U32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n \n pub fn mk_mach_int(tm: ast::int_ty) -> t {\n@@ -1181,7 +1181,7 @@ pub fn mk_mach_float(tm: ast::float_ty) -> t {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n pub fn mk_estr(cx: ctxt, t: vstore) -> t {"}, {"sha": "12b413bc5af918c21aa6eeee1e1686ee29293770", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -725,7 +725,7 @@ impl FnCtxt {\n         ty::re_scope(self.region_lb)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());"}, {"sha": "3875847ff9bbd00f01a57acccbbde1f9f669c6f8", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -38,7 +38,7 @@ pub mod rustrt {\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n-#[inline(always)]\n+#[inline]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(&v);\n@@ -58,7 +58,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec: @[A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n@@ -76,7 +76,7 @@ pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n@@ -93,7 +93,7 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A>(size: Option<uint>,\n                           builder: &fn(push: &fn(v: A)))\n                        -> @[A] {\n@@ -104,7 +104,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for lhs.each |x| { push(copy *x); }\n@@ -178,7 +178,7 @@ pub mod traits {\n     use ops::Add;\n \n     impl<'self,T:Copy> Add<&'self const [T],@[T]> for @[T] {\n-        #[inline(always)]\n+        #[inline]\n         fn add(&self, rhs: & &'self const [T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n@@ -208,7 +208,7 @@ pub mod raw {\n      * modifing its buffers, so it is up to the caller to ensure that\n      * the vector is actually the specified size.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n         let repr: **mut VecRepr = transmute(&v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n@@ -217,7 +217,7 @@ pub mod raw {\n     /**\n      * Pushes a new value onto this vector.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n         let repr: **VecRepr = transmute_copy(&v);\n         let fill = (**repr).unboxed.fill;\n@@ -228,7 +228,7 @@ pub mod raw {\n         }\n     }\n \n-    #[inline(always)] // really pretty please\n+    #[inline] // really pretty please\n     unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n         let repr: **mut VecRepr = ::cast::transmute(v);\n         let fill = (**repr).unboxed.fill;"}, {"sha": "e6be164099bf00b2e6315fee864d0463c8255872", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -212,7 +212,7 @@ impl FromStr for bool {\n * ~~~\n */\n impl ToStr for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         if *self { ~\"true\" } else { ~\"false\" }\n     }\n@@ -250,24 +250,24 @@ pub fn all_values(blk: &fn(v: bool)) {\n * 0\n * ~~~\n */\n-#[inline(always)]\n+#[inline]\n pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[cfg(not(test))]\n impl Ord for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &bool) -> bool { to_bit(*self) < to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &bool) -> bool { to_bit(*self) <= to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &bool) -> bool { to_bit(*self) > to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &bool) -> bool { to_bit(*self) >= to_bit(*other) }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &bool) -> Ordering { to_bit(*self).cmp(&to_bit(*other)) }\n }\n \n@@ -298,9 +298,9 @@ impl TotalOrd for bool {\n */\n #[cfg(not(test))]\n impl Eq for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "9e3a3a28fe8cef39aa0b1020d8f548ca37e8cfdb", "filename": "src/libstd/borrow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -14,25 +14,25 @@\n use prelude::*;\n \n /// Cast a region pointer - &T - to a uint.\n-#[inline(always)]\n+#[inline]\n pub fn to_uint<T>(thing: &T) -> uint {\n     thing as *T as uint\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n-#[inline(always)]\n+#[inline]\n pub fn ref_eq<'a, 'b, T>(thing: &'a T, other: &'b T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n // Equality for region pointers\n #[cfg(not(test))]\n impl<'self, T: Eq> Eq for &'self T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: & &'self T) -> bool {\n         *(*self) == *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: & &'self T) -> bool {\n         *(*self) != *(*other)\n     }\n@@ -41,19 +41,19 @@ impl<'self, T: Eq> Eq for &'self T {\n // Comparison for region pointers\n #[cfg(not(test))]\n impl<'self, T: Ord> Ord for &'self T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: & &'self T) -> bool {\n         *(*self) < *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: & &'self T) -> bool {\n         *(*self) <= *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: & &'self T) -> bool {\n         *(*self) >= *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: & &'self T) -> bool {\n         *(*self) > *(*other)\n     }"}, {"sha": "900cc600923828117381d015970ee1425971cba1", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -29,7 +29,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n \n /// Casts the value at `src` to U. The two types must have the same length.\n #[cfg(target_word_size = \"32\", not(stage0))]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n@@ -40,7 +40,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n \n /// Casts the value at `src` to U. The two types must have the same length.\n #[cfg(target_word_size = \"64\", not(stage0))]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n@@ -56,14 +56,14 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n  * to run any required cleanup or memory-management operations on it. This\n  * can be used for various acts of magick.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n  * carelessly, this can leak the box.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n \n /**\n@@ -74,59 +74,59 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     intrinsics::transmute(thing)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n /// Coerce a mutable reference to be immutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_immut<'a,T>(ptr: &'a mut T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T {\n     transmute_mut_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }"}, {"sha": "797fd9e8c020e3d3e9916054b82240bf6fcdbfe5", "filename": "src/libstd/char.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -65,22 +65,22 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n /// Indicates whether a character is in lower case, defined\n /// in terms of the Unicode General Category 'Ll'\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_lowercase(c: char) -> bool { general_category::Ll(c) }\n \n ///\n /// Indicates whether a character is in upper case, defined\n /// in terms of the Unicode General Category 'Lu'.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n \n ///\n /// Indicates whether a character is whitespace. Whitespace is defined in\n /// terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n /// additional 'Cc'-category control codes in the range [0x09, 0x0d]\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_whitespace(c: char) -> bool {\n     ('\\x09' <= c && c <= '\\x0d')\n         || general_category::Zs(c)\n@@ -93,7 +93,7 @@ pub fn is_whitespace(c: char) -> bool {\n /// defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n /// and the Derived Core Property 'Alphabetic'.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_alphanumeric(c: char) -> bool {\n     derived_property::Alphabetic(c)\n         || general_category::Nd(c)\n@@ -102,7 +102,7 @@ pub fn is_alphanumeric(c: char) -> bool {\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n-#[inline(always)]\n+#[inline]\n pub fn is_digit(c: char) -> bool {\n     general_category::Nd(c)\n         || general_category::Nl(c)\n@@ -127,7 +127,7 @@ pub fn is_digit(c: char) -> bool {\n ///\n /// This just wraps `to_digit()`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n@@ -310,21 +310,21 @@ impl Char for char {\n \n #[cfg(not(test))]\n impl Eq for char {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl Ord for char {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &char) -> bool { *self < *other }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &char) -> bool { *self <= *other }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &char) -> bool { *self > *other }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &char) -> bool { *self >= *other }\n }\n "}, {"sha": "5ec594cef7ee6c747a0703d6b81801089e28bb97", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -34,33 +34,33 @@ pub trait Clone {\n \n impl<T: Clone> Clone for ~T {\n     /// Return a deep copy of the owned box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> ~T { ~(**self).clone() }\n }\n \n impl<T> Clone for @T {\n     /// Return a shallow copy of the managed box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> @T { *self }\n }\n \n impl<T> Clone for @mut T {\n     /// Return a shallow copy of the managed box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> @mut T { *self }\n }\n \n impl<'self, T> Clone for &'self T {\n     /// Return a shallow copy of the borrowed pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> &'self T { *self }\n }\n \n macro_rules! clone_impl(\n     ($t:ty) => {\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n-            #[inline(always)]\n+            #[inline]\n             fn clone(&self) -> $t { *self }\n         }\n     }\n@@ -96,31 +96,31 @@ pub trait DeepClone {\n \n impl<T: DeepClone> DeepClone for ~T {\n     /// Return a deep copy of the owned box.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> ~T { ~(**self).deep_clone() }\n }\n \n // FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n impl<T: Const + DeepClone> DeepClone for @T {\n     /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> @T { @(**self).deep_clone() }\n }\n \n // FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n impl<T: Const + DeepClone> DeepClone for @mut T {\n     /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> @mut T { @mut (**self).deep_clone() }\n }\n \n macro_rules! deep_clone_impl(\n     ($t:ty) => {\n         impl DeepClone for $t {\n             /// Return a deep copy of the value.\n-            #[inline(always)]\n+            #[inline]\n             fn deep_clone(&self) -> $t { *self }\n         }\n     }"}, {"sha": "2c4bb46b23b83a0cff9dd550ebd5dbac5e1526c5", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -45,7 +45,7 @@ pub trait TotalEq {\n macro_rules! totaleq_impl(\n     ($t:ty) => {\n         impl TotalEq for $t {\n-            #[inline(always)]\n+            #[inline]\n             fn equals(&self, other: &$t) -> bool { *self == *other }\n         }\n     }\n@@ -84,27 +84,27 @@ pub trait TotalOrd: TotalEq {\n }\n \n impl TotalOrd for Ordering {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n impl Ord for Ordering {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Ordering) -> bool { (*self as int) <= (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Ordering) -> bool { (*self as int) > (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Ordering) -> bool { (*self as int) >= (*other as int) }\n }\n \n macro_rules! totalord_impl(\n     ($t:ty) => {\n         impl TotalOrd for $t {\n-            #[inline(always)]\n+            #[inline]\n             fn cmp(&self, other: &$t) -> Ordering {\n                 if *self < *other { Less }\n                 else if *self > *other { Greater }\n@@ -146,7 +146,7 @@ Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n lexical ordering on a type `(int, int)`.\n */\n // used in deriving code in libsyntax\n-#[inline(always)]\n+#[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n         Equal => o2,\n@@ -180,12 +180,12 @@ pub trait Equiv<T> {\n     fn equiv(&self, other: &T) -> bool;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }"}, {"sha": "3f30c811e51643a26d7ede2199140bedc353f048", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -625,7 +625,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericChan<T> for Chan<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn send(&self, x: T) {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -636,7 +636,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn try_send(&self, x: T) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -653,7 +653,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericPort<T> for Port<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn recv(&self) -> T {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -664,7 +664,7 @@ mod pipesy {\n             }\n         }\n \n-        #[inline(always)]\n+        #[inline]\n         fn try_recv(&self) -> Option<T> {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -681,7 +681,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> Peekable<T> for Port<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn peek(&self) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);"}, {"sha": "681a7fbc821f89273d72b325afcdde87abb7becd", "filename": "src/libstd/either.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -33,7 +33,7 @@ pub enum Either<T, U> {\n /// If `value` is left(T) then `f_left` is applied to its contents, if\n /// `value` is right(U) then `f_right` is applied to its contents, and the\n /// result is returned.\n-#[inline(always)]\n+#[inline]\n pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n                        f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n     match *value {\n@@ -83,7 +83,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n }\n \n /// Flips between left and right of a given either\n-#[inline(always)]\n+#[inline]\n pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     match eith {\n         Right(r) => Left(r),\n@@ -95,7 +95,7 @@ pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n ///\n /// Converts an `either` type to a `result` type, making the \"right\" choice\n /// an ok result, and the \"left\" choice a fail\n-#[inline(always)]\n+#[inline]\n pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n     match eith {\n         Right(r) => result::Ok(r),\n@@ -104,7 +104,7 @@ pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n }\n \n /// Checks whether the given value is a left\n-#[inline(always)]\n+#[inline]\n pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     match *eith {\n         Left(_) => true,\n@@ -113,7 +113,7 @@ pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n }\n \n /// Checks whether the given value is a right\n-#[inline(always)]\n+#[inline]\n pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     match *eith {\n         Right(_) => true,\n@@ -122,7 +122,7 @@ pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n }\n \n /// Retrieves the value in the left branch. Fails if the either is Right.\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     match eith {\n         Left(x) => x,\n@@ -131,7 +131,7 @@ pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n }\n \n /// Retrieves the value in the right branch. Fails if the either is Left.\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     match eith {\n         Right(x) => x,\n@@ -140,27 +140,27 @@ pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n }\n \n impl<T, U> Either<T, U> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n         either(f_left, f_right, self)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn flip(self) -> Either<U, T> { flip(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn to_result(self) -> Result<U, T> { to_result(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_left(&self) -> bool { is_left(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_right(&self) -> bool { is_right(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_left(self) -> T { unwrap_left(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_right(self) -> U { unwrap_right(self) }\n }\n "}, {"sha": "1967a57e867fb18f440a446e457a394748a01498", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -64,7 +64,7 @@ pub trait HashUtil {\n }\n \n impl<A:Hash> HashUtil for A {\n-    #[inline(always)]\n+    #[inline]\n     fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n }\n \n@@ -79,7 +79,7 @@ pub trait Streaming {\n }\n \n impl<A:IterBytes> Hash for A {\n-    #[inline(always)]\n+    #[inline]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         let mut s = State::new(k0, k1);\n         for self.iter_bytes(true) |bytes| {\n@@ -176,7 +176,7 @@ fn hash_keyed_5<A: IterBytes,\n     s.result_u64()\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn default_state() -> State {\n     State::new(0, 0)\n }\n@@ -194,7 +194,7 @@ struct SipState {\n }\n \n impl SipState {\n-    #[inline(always)]\n+    #[inline]\n     fn new(key0: u64, key1: u64) -> SipState {\n         let mut state = SipState {\n             k0: key0,\n@@ -248,7 +248,7 @@ macro_rules! compress (\n \n impl Writer for SipState {\n     // Methods for io::writer\n-    #[inline(always)]\n+    #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n@@ -315,12 +315,12 @@ impl Writer for SipState {\n }\n \n impl Streaming for SipState {\n-    #[inline(always)]\n+    #[inline]\n     fn input(&mut self, buf: &[u8]) {\n         self.write(buf);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn result_u64(&mut self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n@@ -373,7 +373,7 @@ impl Streaming for SipState {\n         s\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;"}, {"sha": "d05fa63a6f9b3bc74c248291224480af2e847568", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -59,7 +59,7 @@ enum SearchResult {\n     FoundEntry(uint), FoundHole(uint), TableFull\n }\n \n-#[inline(always)]\n+#[inline]\n fn resize_at(capacity: uint) -> uint {\n     ((capacity as float) * 3. / 4.) as uint\n }\n@@ -85,19 +85,19 @@ fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n }\n \n impl<K:Hash + Eq,V> HashMap<K, V> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n         // bits is assumed. SipHash is more than good enough.\n         h % self.buckets.len()\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n         (idx + 1) % len_buckets\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_sequence(&self, hash: uint,\n                        op: &fn(uint) -> bool) -> bool {\n         let start_idx = self.to_bucket(hash);\n@@ -112,20 +112,20 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key(&self, k: &K) -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash(hash, k)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n                                                -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_with_hash(&self,\n                                 hash: uint,\n                                 k: &K)\n@@ -141,7 +141,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         TableFull\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n                                                   hash: uint,\n                                                   k: &Q)\n@@ -161,7 +161,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n     /// Expand the capacity of the array to the next power of two\n     /// and re-insert each of the existing buckets.\n-    #[inline(always)]\n+    #[inline]\n     fn expand(&mut self) {\n         let new_capacity = self.buckets.len() * 2;\n         self.resize(new_capacity);\n@@ -190,15 +190,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n             None => fail!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n         match self.buckets[idx] {\n             Some(ref mut bkt) => &mut bkt.value,"}, {"sha": "7053cbe0df5a6478c47abb0398706334ba4d14ed", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -73,7 +73,7 @@ pub trait FromIter<T> {\n  * assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn any<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     for iter |x| {\n@@ -94,7 +94,7 @@ pub fn any<T>(predicate: &fn(T) -> bool,\n  * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn all<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     // If we ever break, iter will return false, so this will only return true\n@@ -112,7 +112,7 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n  * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn find<T>(predicate: &fn(&T) -> bool,\n                iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     for iter |x| {\n@@ -226,7 +226,7 @@ pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&m\n  * assert_eq!(do sum |f| { xs.each(f) }, 10);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n }\n@@ -241,7 +241,7 @@ pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  * assert_eq!(do product |f| { xs.each(f) }, 24);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n }"}, {"sha": "eefad1a03dcb22f4a7b1da438f60bd3bd9cbe815", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -321,59 +321,59 @@ pub trait IteratorUtil<A> {\n ///\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, T, B, U> {\n         ZipIterator{a: self, b: other}\n     }\n \n     // FIXME: #5898: should be called map\n-    #[inline(always)]\n+    #[inline]\n     fn transform<'r, B>(self, f: &'r fn(A) -> B) -> MapIterator<'r, A, B, T> {\n         MapIterator{iter: self, f: f}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> FilterIterator<'r, A, T> {\n         FilterIterator{iter: self, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMapIterator<'r, A, B, T> {\n         FilterMapIterator { iter: self, f: f }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn enumerate(self) -> EnumerateIterator<A, T> {\n         EnumerateIterator{iter: self, count: 0}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhileIterator<'r, A, T> {\n         SkipWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, T> {\n         TakeWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn skip(self, n: uint) -> SkipIterator<A, T> {\n         SkipIterator{iter: self, n: n}\n     }\n \n     // FIXME: #5898: should be called take\n-    #[inline(always)]\n+    #[inline]\n     fn take_(self, n: uint) -> TakeIterator<A, T> {\n         TakeIterator{iter: self, n: n}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, T, St> {\n         ScanIterator{iter: self, f: f, state: initial_state}\n@@ -392,13 +392,13 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn collect<B: FromIter<A>>(&mut self) -> B {\n         FromIter::from_iter::<A, B>(|f| self.advance(f))\n     }\n \n     /// Return the `n`th item yielded by an iterator.\n-    #[inline(always)]\n+    #[inline]\n     fn nth(&mut self, mut n: uint) -> Option<A> {\n         loop {\n             match self.next() {\n@@ -410,7 +410,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     /// Return the last item yielded by an iterator.\n-    #[inline(always)]\n+    #[inline]\n     fn last_(&mut self) -> Option<A> {\n         let mut last = None;\n         for self.advance |x| { last = Some(x); }\n@@ -431,23 +431,23 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     /// Count the number of items yielded by an iterator\n-    #[inline(always)]\n+    #[inline]\n     fn count(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if !f(x) { return false; } }\n         true\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn any_(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if f(x) { return true; } }\n         false\n     }\n \n     /// Return the first element satisfying the specified predicate\n-    #[inline(always)]\n+    #[inline]\n     fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n         for self.advance |x| {\n             if predicate(&x) { return Some(x) }\n@@ -484,7 +484,7 @@ pub trait AdditiveIterator<A> {\n }\n \n impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn sum(&mut self) -> A { self.fold(Zero::zero::<A>(), |s, x| s + x) }\n }\n \n@@ -509,7 +509,7 @@ pub trait MultiplicativeIterator<A> {\n }\n \n impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn product(&mut self) -> A { self.fold(One::one::<A>(), |p, x| p * x) }\n }\n \n@@ -538,7 +538,7 @@ pub trait OrdIterator<A> {\n }\n \n impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn max(&mut self) -> Option<A> {\n         self.fold(None, |max, x| {\n             match max {\n@@ -548,7 +548,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n         })\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min(&mut self) -> Option<A> {\n         self.fold(None, |min, x| {\n             match min {\n@@ -843,14 +843,14 @@ pub struct Counter<A> {\n \n impl<A> Counter<A> {\n     /// Creates a new counter with the specified start/step\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(start: A, step: A) -> Counter<A> {\n         Counter{state: start, step: step}\n     }\n }\n \n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> Option<A> {\n         let result = self.state.clone();\n         self.state = self.state.add(&self.step); // FIXME: #6050"}, {"sha": "07b2ac6ed01b563ef51a0274fdff13ff12954400", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -1457,11 +1457,11 @@ pub mod funcs {\n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n                 #[rust_stack]\n-                #[inline(always)]\n+                #[inline]\n                 unsafe fn memcmp(cx: *c_void, ct: *c_void, n: size_t)\n                               -> c_int;\n                 #[rust_stack]\n-                #[inline(always)]\n+                #[inline]\n                 unsafe fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n             }\n         }"}, {"sha": "d514612b5afd8205401b76370e6c2514488f1a11", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -38,56 +38,56 @@ pub mod raw {\n }\n \n /// Determine if two shared boxes point to the same object\n-#[inline(always)]\n+#[inline]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n \n /// Determine if two mutable shared boxes point to the same object\n-#[inline(always)]\n+#[inline]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @mut T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @mut T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "40f6d53ed22f063b1b92ae26c1678be7fb5fbb69", "filename": "src/libstd/nil.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnil.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,32 +19,32 @@ use prelude::*;\n \n #[cfg(not(test))]\n impl Eq for () {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(not(test))]\n impl Ord for () {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, _other: &()) -> bool { false }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for () {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, _other: &()) -> Ordering { Equal }\n }\n \n #[cfg(not(test))]\n impl TotalEq for () {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, _other: &()) -> bool { true }\n }"}, {"sha": "117a474ffd7d3b4bc12aaace61c80e1465161da3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 129, "deletions": 129, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -20,7 +20,7 @@ use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n-// An inner module is required to get the #[inline(always)] attribute on the\n+// An inner module is required to get the #[inline] attribute on the\n // functions.\n pub use self::delegated::*;\n \n@@ -40,7 +40,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline(always)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)\n@@ -115,45 +115,45 @@ pub static infinity: f32 = 1.0_f32/0.0_f32;\n \n pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-#[inline(always)]\n+#[inline]\n pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmax(x: f32, y: f32) -> f32 {\n     if x >= y || y.is_NaN() { x } else { y }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmin(x: f32, y: f32) -> f32 {\n     if x <= y || y.is_NaN() { x } else { y }\n }\n@@ -212,56 +212,56 @@ impl Num for f32 {}\n \n #[cfg(not(test))]\n impl Eq for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> f32 { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &f32) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f32, f32>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &f32, approx_epsilon: &f32) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for f32 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &f32) -> f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &f32) -> f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         cond!(\n             (self.is_NaN())   { *self }\n@@ -273,65 +273,65 @@ impl Orderable for f32 {\n }\n \n impl Zero for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> f32 { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> f32 { 1.0 }\n }\n \n #[cfg(not(test))]\n impl Add<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &f32) -> f32 { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> f32 { -*self }\n }\n \n impl Signed for f32 {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> f32 { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n \n     ///\n@@ -341,35 +341,35 @@ impl Signed for f32 {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> f32 {\n         if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Round for f32 {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> f32 { floor(*self) }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> f32 { ceil(*self) }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> f32 { round(*self) }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> f32 { trunc(*self) }\n \n     ///\n@@ -379,96 +379,96 @@ impl Round for f32 {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> f32 { *self - self.trunc() }\n }\n \n impl Fractional for f32 {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> f32 { 1.0 / *self }\n }\n \n impl Algebraic for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &f32) -> f32 { pow(*self, *n) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> f32 { sqrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> f32 { cbrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &f32) -> f32 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> f32 { sin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> f32 { cos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> f32 { tan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> f32 { asin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> f32 { acos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> f32 { atan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &f32) -> f32 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (f32, f32) {\n         (self.sin(), self.cos())\n     }\n }\n \n impl Exponential for f32 {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> f32 { exp(*self) }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> f32 { exp2(*self) }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> f32 { ln(*self) }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> f32 { log2(*self) }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> f32 { log10(*self) }\n }\n \n impl Hyperbolic for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> f32 { sinh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> f32 { cosh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> f32 { tanh(*self) }\n \n     ///\n@@ -480,7 +480,7 @@ impl Hyperbolic for f32 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> f32 {\n         match *self {\n             neg_infinity => neg_infinity,\n@@ -497,7 +497,7 @@ impl Hyperbolic for f32 {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> f32 {\n         match *self {\n             x if x < 1.0 => Float::NaN(),\n@@ -517,137 +517,137 @@ impl Hyperbolic for f32 {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> f32 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n     }\n }\n \n impl Real for f32 {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n     /// 1 .0/ pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n     /// 2.0 / sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> f32 { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n }\n \n impl Bounded for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> f32 { 1.17549435e-38 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> f32 { 3.40282347e+38 }\n }\n \n impl Primitive for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { 32 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n }\n \n impl Float for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> f32 { 0.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> f32 { 1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> f32 { -1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool {\n         self.classify() == FPNormal\n     }\n@@ -670,29 +670,29 @@ impl Float for f32 {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { 24 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { 6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> f32 { 1.19209290e-07 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { -125 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { 128 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { -37 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { 38 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: f32, exp: int) -> f32 {\n         ldexp(x, exp as c_int)\n     }\n@@ -703,7 +703,7 @@ impl Float for f32 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (f32, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n@@ -714,28 +714,28 @@ impl Float for f32 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> f32 { exp_m1(*self) }\n \n     ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> f32 { ln_1p(*self) }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: f32, b: f32) -> f32 {\n         mul_add(*self, a, b)\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: f32) -> f32 {\n         next_after(*self, other)\n     }\n@@ -752,7 +752,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -766,7 +766,7 @@ pub fn to_str(num: f32) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -787,7 +787,7 @@ pub fn to_str_hex(num: f32) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n@@ -805,7 +805,7 @@ pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -820,7 +820,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n@@ -836,20 +836,20 @@ pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n@@ -882,7 +882,7 @@ impl num::ToStrRadix for f32 {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -915,7 +915,7 @@ pub fn from_str(num: &str) -> Option<f32> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -940,19 +940,19 @@ pub fn from_str_hex(num: &str) -> Option<f32> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<f32> { from_str(val) }\n }\n \n impl num::FromStrRadix for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         from_str_radix(val, rdx)\n     }"}, {"sha": "e13dff1e623573854df48db1cfa3aea991ccdd26", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 132, "deletions": 132, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -22,7 +22,7 @@ use to_str;\n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n-// An inner module is required to get the #[inline(always)] attribute on the\n+// An inner module is required to get the #[inline] attribute on the\n // functions.\n pub use self::delegated::*;\n \n@@ -42,7 +42,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline(always)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)\n@@ -141,45 +141,45 @@ pub static infinity: f64 = 1.0_f64/0.0_f64;\n \n pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-#[inline(always)]\n+#[inline]\n pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmax(x: f64, y: f64) -> f64 {\n     if x >= y || y.is_NaN() { x } else { y }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmin(x: f64, y: f64) -> f64 {\n     if x <= y || y.is_NaN() { x } else { y }\n }\n@@ -234,56 +234,56 @@ impl Num for f64 {}\n \n #[cfg(not(test))]\n impl Eq for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<f64> for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> f64 { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &f64) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f64, f64>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &f64, approx_epsilon: &f64) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for f64 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &f64) -> f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &f64) -> f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         cond!(\n             (self.is_NaN())   { *self }\n@@ -295,16 +295,16 @@ impl Orderable for f64 {\n }\n \n impl Zero for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> f64 { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> f64 { 1.0 }\n }\n \n@@ -326,7 +326,7 @@ impl Div<f64,f64> for f64 {\n }\n #[cfg(not(test))]\n impl Rem<f64,f64> for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &f64) -> f64 { *self % *other }\n }\n #[cfg(not(test))]\n@@ -336,14 +336,14 @@ impl Neg<f64> for f64 {\n \n impl Signed for f64 {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> f64 { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n \n     ///\n@@ -353,35 +353,35 @@ impl Signed for f64 {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> f64 {\n         if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Round for f64 {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> f64 { floor(*self) }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> f64 { ceil(*self) }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> f64 { round(*self) }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> f64 { trunc(*self) }\n \n     ///\n@@ -391,96 +391,96 @@ impl Round for f64 {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> f64 { *self - self.trunc() }\n }\n \n impl Fractional for f64 {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> f64 { 1.0 / *self }\n }\n \n impl Algebraic for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &f64) -> f64 { pow(*self, *n) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> f64 { sqrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> f64 { cbrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &f64) -> f64 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> f64 { sin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> f64 { cos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> f64 { tan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> f64 { asin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> f64 { acos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> f64 { atan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &f64) -> f64 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (f64, f64) {\n         (self.sin(), self.cos())\n     }\n }\n \n impl Exponential for f64 {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> f64 { exp(*self) }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> f64 { exp2(*self) }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> f64 { ln(*self) }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> f64 { log2(*self) }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> f64 { log10(*self) }\n }\n \n impl Hyperbolic for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> f64 { sinh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> f64 { cosh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> f64 { tanh(*self) }\n \n     ///\n@@ -492,7 +492,7 @@ impl Hyperbolic for f64 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> f64 {\n         match *self {\n             neg_infinity => neg_infinity,\n@@ -509,7 +509,7 @@ impl Hyperbolic for f64 {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> f64 {\n         match *self {\n             x if x < 1.0 => Float::NaN(),\n@@ -529,167 +529,167 @@ impl Hyperbolic for f64 {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> f64 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n     }\n }\n \n impl Real for f64 {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n \n     /// 1.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n \n     /// 2.0 / sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> f64 { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n }\n \n impl RealExt for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn lgamma(&self) -> (int, f64) {\n         let mut sign = 0;\n         let result = lgamma(*self, &mut sign);\n         (sign as int, result)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tgamma(&self) -> f64 { tgamma(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j0(&self) -> f64 { j0(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j1(&self) -> f64 { j1(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn jn(&self, n: int) -> f64 { jn(n as c_int, *self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y0(&self) -> f64 { y0(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y1(&self) -> f64 { y1(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n impl Bounded for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> f64 { 2.2250738585072014e-308 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> f64 { 1.7976931348623157e+308 }\n }\n \n impl Primitive for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { 64 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n }\n \n impl Float for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> f64 { 0.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> f64 { 1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> f64 { -1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool {\n         self.classify() == FPNormal\n     }\n@@ -712,29 +712,29 @@ impl Float for f64 {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { 53 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { 15 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> f64 { 2.2204460492503131e-16 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { -1021 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { 1024 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { -307 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { 308 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: f64, exp: int) -> f64 {\n         ldexp(x, exp as c_int)\n     }\n@@ -745,7 +745,7 @@ impl Float for f64 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (f64, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n@@ -756,28 +756,28 @@ impl Float for f64 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> f64 { exp_m1(*self) }\n \n     ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> f64 { ln_1p(*self) }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: f64, b: f64) -> f64 {\n         mul_add(*self, a, b)\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: f64) -> f64 {\n         next_after(*self, other)\n     }\n@@ -794,7 +794,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -808,7 +808,7 @@ pub fn to_str(num: f64) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -829,7 +829,7 @@ pub fn to_str_hex(num: f64) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n@@ -847,7 +847,7 @@ pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -862,7 +862,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n@@ -878,20 +878,20 @@ pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n@@ -924,7 +924,7 @@ impl num::ToStrRadix for f64 {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -957,7 +957,7 @@ pub fn from_str(num: &str) -> Option<f64> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -982,19 +982,19 @@ pub fn from_str_hex(num: &str) -> Option<f64> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<f64> { from_str(val) }\n }\n \n impl num::FromStrRadix for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         from_str_radix(val, rdx)\n     }"}, {"sha": "c583aeacf162dd4a84fb12bb220f27f9752b19a1", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 129, "deletions": 129, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -99,7 +99,7 @@ pub mod consts {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -113,7 +113,7 @@ pub fn to_str(num: float) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -134,7 +134,7 @@ pub fn to_str_hex(num: float) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n@@ -152,7 +152,7 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -167,7 +167,7 @@ pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n@@ -183,20 +183,20 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n \n impl to_str::ToStr for float {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for float {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n@@ -229,7 +229,7 @@ impl num::ToStrRadix for float {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -262,7 +262,7 @@ pub fn from_str(num: &str) -> Option<float> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -287,19 +287,19 @@ pub fn from_str_hex(num: &str) -> Option<float> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for float {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<float> { from_str(val) }\n }\n \n impl num::FromStrRadix for float {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n         from_str_radix(val, radix)\n     }\n@@ -341,27 +341,27 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn abs(x: float) -> float {\n     f64::abs(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn sqrt(x: float) -> float {\n     f64::sqrt(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn atan(x: float) -> float {\n     f64::atan(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn sin(x: float) -> float {\n     f64::sin(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn cos(x: float) -> float {\n     f64::cos(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn tan(x: float) -> float {\n     f64::tan(x as f64) as float\n }\n@@ -370,90 +370,90 @@ impl Num for float {}\n \n #[cfg(not(test))]\n impl Eq for float {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> float { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &float) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<float, float>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &float, approx_epsilon: &float) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for float {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for float {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &float) -> float {\n         (*self as f64).min(&(*other as f64)) as float\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &float) -> float {\n         (*self as f64).max(&(*other as f64)) as float\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &float, mx: &float) -> float {\n         (*self as f64).clamp(&(*mn as f64), &(*mx as f64)) as float\n     }\n }\n \n impl Zero for float {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> float { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for float {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> float { 1.0 }\n }\n \n impl Round for float {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> float { floor(*self as f64) as float }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> float { ceil(*self as f64) as float }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> float { round(*self as f64) as float }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> float { trunc(*self as f64) as float }\n \n     ///\n@@ -463,81 +463,81 @@ impl Round for float {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> float { *self - self.trunc() }\n }\n \n impl Fractional for float {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> float { 1.0 / *self }\n }\n \n impl Algebraic for float {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &float) -> float {\n         (*self as f64).pow(&(*n as f64)) as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> float {\n         (*self as f64).sqrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> float {\n         (*self as f64).rsqrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> float {\n         (*self as f64).cbrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &float) -> float {\n         (*self as f64).hypot(&(*other as f64)) as float\n     }\n }\n \n impl Trigonometric for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> float {\n         (*self as f64).sin() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> float {\n         (*self as f64).cos() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> float {\n         (*self as f64).tan() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> float {\n         (*self as f64).asin() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> float {\n         (*self as f64).acos() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> float {\n         (*self as f64).atan() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &float) -> float {\n         (*self as f64).atan2(&(*other as f64)) as float\n     }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (float, float) {\n         match (*self as f64).sin_cos() {\n             (s, c) => (s as float, c as float)\n@@ -547,54 +547,54 @@ impl Trigonometric for float {\n \n impl Exponential for float {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> float {\n         (*self as f64).exp() as float\n     }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> float {\n         (*self as f64).exp2() as float\n     }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> float {\n         (*self as f64).ln() as float\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &float) -> float {\n         (*self as f64).log(&(*base as f64)) as float\n     }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> float {\n         (*self as f64).log2() as float\n     }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> float {\n         (*self as f64).log10() as float\n     }\n }\n \n impl Hyperbolic for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> float {\n         (*self as f64).sinh() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> float {\n         (*self as f64).cosh() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> float {\n         (*self as f64).tanh() as float\n     }\n@@ -608,7 +608,7 @@ impl Hyperbolic for float {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> float {\n         (*self as f64).asinh() as float\n     }\n@@ -622,7 +622,7 @@ impl Hyperbolic for float {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> float {\n         (*self as f64).acosh() as float\n     }\n@@ -639,165 +639,165 @@ impl Hyperbolic for float {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> float {\n         (*self as f64).atanh() as float\n     }\n }\n \n impl Real for float {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> float { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n \n     /// 1.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n \n     /// 2 .0/ sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> float { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> float { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> float { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> float { (*self as f64).to_degrees() as float }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> float { (*self as f64).to_radians() as float }\n }\n \n impl RealExt for float {\n-    #[inline(always)]\n+    #[inline]\n     fn lgamma(&self) -> (int, float) {\n         let mut sign = 0;\n         let result = lgamma(*self as f64, &mut sign);\n         (sign as int, result as float)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tgamma(&self) -> float { tgamma(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j0(&self) -> float { j0(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j1(&self) -> float { j1(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn jn(&self, n: int) -> float { jn(n as c_int, *self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y0(&self) -> float { y0(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y1(&self) -> float { y1(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn yn(&self, n: int) -> float { yn(n as c_int, *self as f64) as float }\n }\n \n #[cfg(not(test))]\n impl Add<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &float) -> float { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &float) -> float { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &float) -> float { *self % *other }\n }\n #[cfg(not(test))]\n impl Neg<float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> float { -*self }\n }\n \n impl Signed for float {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> float { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &float) -> float {\n         (*self as f64).abs_sub(&(*other as f64)) as float\n     }\n@@ -809,93 +809,93 @@ impl Signed for float {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> float {\n         if self.is_NaN() { NaN } else { f64::copysign(1.0, *self as f64) as float }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Bounded for float {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> float { Bounded::min_value::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> float { Bounded::max_value::<f64>() as float }\n }\n \n impl Primitive for float {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { Primitive::bits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bytes::<f64>() }\n }\n \n impl Float for float {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> float { Float::NaN::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> float { Float::infinity::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { (*self as f64).is_NaN() }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool { (*self as f64).is_infinite() }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool { (*self as f64).is_finite() }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool { (*self as f64).is_normal() }\n \n     /// Returns the floating point category of the number. If only one property is going to\n     /// be tested, it is generally faster to use the specific predicate instead.\n-    #[inline(always)]\n+    #[inline]\n     fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { Float::digits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> float { Float::epsilon::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { Float::min_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { Float::max_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { Float::min_10_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: float, exp: int) -> float {\n         Float::ldexp(x as f64, exp) as float\n     }\n@@ -906,7 +906,7 @@ impl Float for float {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (float, int) {\n         match (*self as f64).frexp() {\n             (x, exp) => (x as float, exp)\n@@ -917,7 +917,7 @@ impl Float for float {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> float {\n         (*self as f64).exp_m1() as float\n     }\n@@ -926,7 +926,7 @@ impl Float for float {\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> float {\n         (*self as f64).ln_1p() as float\n     }\n@@ -936,13 +936,13 @@ impl Float for float {\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: float, b: float) -> float {\n         mul_add(*self as f64, a as f64, b as f64) as float\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: float) -> float {\n         next_after(*self as f64, other as f64) as float\n     }"}, {"sha": "eec20297a533ea1bc6eddee2b1d9b52258c91b86", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,14 +19,14 @@ int_module!(i16, 16)\n \n impl BitCount for i16 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n }"}, {"sha": "769187cc66d6dd45a8ef39f28e44bb05855602da", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,14 +19,14 @@ int_module!(i32, 32)\n \n impl BitCount for i32 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n }"}, {"sha": "ae0e59d16610e53c9e8b561f0951f4575e426cc1", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,14 +19,14 @@ int_module!(i64, 64)\n \n impl BitCount for i64 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n }"}, {"sha": "31a1f4241f58e47f54fe829d05747104ea568178", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,14 +19,14 @@ int_module!(i8, 8)\n \n impl BitCount for i8 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n }"}, {"sha": "d3c2733b47d5c2a60c209e3f6efaa586c9d8857e", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -22,30 +22,30 @@ int_module!(int, super::bits)\n #[cfg(target_word_size = \"32\")]\n impl BitCount for int {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> int { (*self as i32).population_count() as int }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl BitCount for int {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> int { (*self as i64).population_count() as int }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n }\n "}, {"sha": "74ec46ccfcd47ca708475524123ab55dec29e771", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -27,17 +27,17 @@ pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n /// Calculates the sum of two numbers\n-#[inline(always)]\n+#[inline]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n /// Subtracts the second number from the first\n-#[inline(always)]\n+#[inline]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n /// Multiplies two numbers together\n-#[inline(always)]\n+#[inline]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n /// Divides the first argument by the second argument (using integer division)\n /// Divides the first argument by the second argument (using integer division)\n-#[inline(always)]\n+#[inline]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n \n ///\n@@ -60,26 +60,26 @@ pub fn div(x: $T, y: $T) -> $T { x / y }\n /// ~~~\n ///\n ///\n-#[inline(always)]\n+#[inline]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n /// Returns true iff `x < y`\n-#[inline(always)]\n+#[inline]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n /// Returns true iff `x <= y`\n-#[inline(always)]\n+#[inline]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n /// Returns true iff `x == y`\n-#[inline(always)]\n+#[inline]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n /// Returns true iff `x != y`\n-#[inline(always)]\n+#[inline]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n /// Returns true iff `x >= y`\n-#[inline(always)]\n+#[inline]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n /// Returns true iff `x > y`\n-#[inline(always)]\n+#[inline]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n ///\n@@ -99,7 +99,7 @@ pub fn gt(x: $T, y: $T) -> bool { x > y }\n /// assert!(sum == 10);\n /// ~~~\n ///\n-#[inline(always)]\n+#[inline]\n pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n@@ -122,96 +122,96 @@ pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n     range_step(lo, hi, 1 as $T, it)\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T, it)\n }\n \n /// Computes the bitwise complement\n-#[inline(always)]\n+#[inline]\n pub fn compl(i: $T) -> $T {\n     -1 as $T ^ i\n }\n \n /// Computes the absolute value\n-#[inline(always)]\n+#[inline]\n pub fn abs(i: $T) -> $T { i.abs() }\n \n impl Num for $T {}\n \n #[cfg(not(test))]\n impl Ord for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &$T) -> bool { return (*self) <= (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &$T) -> bool { return (*self) >= (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &$T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(not(test))]\n impl Eq for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n impl Orderable for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n         if *self > *mx { *mx } else\n         if *self < *mn { *mn } else { *self }\n     }\n }\n \n impl Zero for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> $T { 0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n impl One for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n impl Add<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n@@ -235,7 +235,7 @@ impl Div<$T,$T> for $T {\n     /// assert!(-1 / -2 ==  0);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n@@ -262,19 +262,19 @@ impl Rem<$T,$T> for $T {\n     /// assert!(-1 % -2 == -1);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> $T { -*self }\n }\n \n impl Signed for $T {\n     /// Computes the absolute value\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> $T {\n         if self.is_negative() { -*self } else { *self }\n     }\n@@ -283,7 +283,7 @@ impl Signed for $T {\n     /// The positive difference of two numbers. Returns `0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &$T) -> $T {\n         if *self <= *other { 0 } else { *self - *other }\n     }\n@@ -295,7 +295,7 @@ impl Signed for $T {\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> $T {\n         match *self {\n             n if n > 0 =>  1,\n@@ -305,11 +305,11 @@ impl Signed for $T {\n     }\n \n     /// Returns true if the number is positive\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0 }\n \n     /// Returns true if the number is negative\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n@@ -331,7 +331,7 @@ impl Integer for $T {\n     /// assert!((-1).div_floor(-2) ==  0);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn div_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -363,7 +363,7 @@ impl Integer for $T {\n     /// assert!((-1).mod_floor(-2) == -1);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mod_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -375,7 +375,7 @@ impl Integer for $T {\n     }\n \n     /// Calculates `div_floor` and `mod_floor` simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -387,7 +387,7 @@ impl Integer for $T {\n     }\n \n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n@@ -397,7 +397,7 @@ impl Integer for $T {\n     ///\n     /// The result is always positive\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut (m, n) = (*self, *other);\n@@ -412,112 +412,112 @@ impl Integer for $T {\n     ///\n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn lcm(&self, other: &$T) -> $T {\n         ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+    #[inline]\n     fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl Bitwise for $T {}\n \n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n impl BitAnd<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n impl BitXor<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n impl Shl<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n impl Shr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n impl Not<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn not(&self) -> $T { !*self }\n }\n \n impl Bounded for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> $T { min_value }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> $T { max_value }\n }\n \n impl Int for $T {}\n \n impl Primitive for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { bits }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { bits / 8 }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, true, false, false,\n                                strconv::ExpNone, false, false)\n }\n \n impl FromStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n@@ -526,38 +526,38 @@ impl FromStrRadix for $T {\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }"}, {"sha": "30a18a0587bc025781b86a519f5f51b591e25f05", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -307,7 +307,7 @@ pub trait Float: Real\n /// assert_eq!(twenty, 20f32);\n /// ~~~\n ///\n-#[inline(always)]\n+#[inline]\n pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n@@ -338,28 +338,28 @@ pub trait NumCast {\n macro_rules! impl_num_cast(\n     ($T:ty, $conv:ident) => (\n         impl NumCast for $T {\n-            #[inline(always)]\n+            #[inline]\n             fn from<N:NumCast>(n: N) -> $T {\n                 // `$conv` could be generated using `concat_idents!`, but that\n                 // macro seems to be broken at the moment\n                 n.$conv()\n             }\n \n-            #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-            #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-            #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-            #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-            #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-            #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-            #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-            #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-            #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-            #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-            #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-            #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-            #[inline(always)] fn to_float(&self) -> float { *self as float }\n+            #[inline] fn to_u8(&self)    -> u8    { *self as u8    }\n+            #[inline] fn to_u16(&self)   -> u16   { *self as u16   }\n+            #[inline] fn to_u32(&self)   -> u32   { *self as u32   }\n+            #[inline] fn to_u64(&self)   -> u64   { *self as u64   }\n+            #[inline] fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+            #[inline] fn to_i8(&self)    -> i8    { *self as i8    }\n+            #[inline] fn to_i16(&self)   -> i16   { *self as i16   }\n+            #[inline] fn to_i32(&self)   -> i32   { *self as i32   }\n+            #[inline] fn to_i64(&self)   -> i64   { *self as i64   }\n+            #[inline] fn to_int(&self)   -> int   { *self as int   }\n+\n+            #[inline] fn to_f32(&self)   -> f32   { *self as f32   }\n+            #[inline] fn to_f64(&self)   -> f64   { *self as f64   }\n+            #[inline] fn to_float(&self) -> float { *self as float }\n         }\n     )\n )"}, {"sha": "a062838aacf049889e6ee56535a7b746cfa9d68d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -42,28 +42,28 @@ pub enum SignFormat {\n     SignAll\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_NaN<T:Eq>(num: &T) -> bool {\n     *num != *num\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::neg_inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -83,23 +83,23 @@ pub trait NumStrConv {\n \n macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)]\n+        #[inline]\n         fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n \n-        #[inline(always)]\n+        #[inline]\n         fn round_to_zero(&self) -> $t {\n             ( if *self < 0.0 { f64::ceil(*self as f64)  }\n               else           { f64::floor(*self as f64) }\n             ) as $t\n         }\n \n-        #[inline(always)]\n+        #[inline]\n         fn fractional_part(&self) -> $t {\n             *self - self.round_to_zero()\n         }\n@@ -108,13 +108,13 @@ macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n \n macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)] fn NaN()      -> Option<$t> { None }\n-        #[inline(always)] fn inf()      -> Option<$t> { None }\n-        #[inline(always)] fn neg_inf()  -> Option<$t> { None }\n-        #[inline(always)] fn neg_zero() -> Option<$t> { None }\n+        #[inline] fn NaN()      -> Option<$t> { None }\n+        #[inline] fn inf()      -> Option<$t> { None }\n+        #[inline] fn neg_inf()  -> Option<$t> { None }\n+        #[inline] fn neg_zero() -> Option<$t> { None }\n \n-        #[inline(always)] fn round_to_zero(&self)   -> $t { *self }\n-        #[inline(always)] fn fractional_part(&self) -> $t {     0 }\n+        #[inline] fn round_to_zero(&self)   -> $t { *self }\n+        #[inline] fn fractional_part(&self) -> $t {     0 }\n     }\n ))\n \n@@ -381,7 +381,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  * Converts a number to its string representation. This is a wrapper for\n  * `to_str_bytes_common()`, for details see there.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n@@ -632,7 +632,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n  * Parses a string as a number. This is a wrapper for\n  * `from_str_bytes_common()`, for details see there.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,"}, {"sha": "126150c0f1bfcbb1acc3fff73157cc04a38d9ad9", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -95,7 +95,7 @@ pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n }\n \n impl iter::Times for uint {\n-    #[inline(always)]\n+    #[inline]\n     ///\n     /// A convenience form for basic iteration. Given a uint `x`,\n     /// `for x.times { ... }` executes the given block x times.\n@@ -117,7 +117,7 @@ impl iter::Times for uint {\n }\n \n /// Returns the smallest power of 2 greater than or equal to `n`\n-#[inline(always)]\n+#[inline]\n pub fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;"}, {"sha": "52f620f97ce8674daeb1b3d0152c8333e50146f0", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -28,42 +28,42 @@ pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n /// Calculates the sum of two numbers\n-#[inline(always)]\n+#[inline]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n /// Subtracts the second number from the first\n-#[inline(always)]\n+#[inline]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n /// Multiplies two numbers together\n-#[inline(always)]\n+#[inline]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n /// Divides the first argument by the second argument (using integer division)\n-#[inline(always)]\n+#[inline]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n /// Calculates the integer remainder when x is divided by y (equivalent to the\n /// '%' operator)\n-#[inline(always)]\n+#[inline]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n /// Returns true iff `x < y`\n-#[inline(always)]\n+#[inline]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n /// Returns true iff `x <= y`\n-#[inline(always)]\n+#[inline]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n /// Returns true iff `x == y`\n-#[inline(always)]\n+#[inline]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n /// Returns true iff `x != y`\n-#[inline(always)]\n+#[inline]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n /// Returns true iff `x >= y`\n-#[inline(always)]\n+#[inline]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n /// Returns true iff `x > y`\n-#[inline(always)]\n+#[inline]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n-#[inline(always)]\n+#[inline]\n /**\n  * Iterate through a range with a given step value.\n  *\n@@ -99,20 +99,20 @@ pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) ->\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n     range_step(lo, hi, 1 as $T_SIGNED, it)\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T_SIGNED, it)\n }\n \n /// Computes the bitwise complement\n-#[inline(always)]\n+#[inline]\n pub fn compl(i: $T) -> $T {\n     max_value ^ i\n }\n@@ -121,37 +121,37 @@ impl Num for $T {}\n \n #[cfg(not(test))]\n impl Ord for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &$T) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &$T) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &$T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(not(test))]\n impl Eq for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n impl Orderable for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n         cond!(\n             (*self > *mx) { *mx   }\n@@ -162,79 +162,79 @@ impl Orderable for $T {\n }\n \n impl Zero for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> $T { 0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n impl One for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n impl Add<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> $T { -*self }\n }\n \n impl Unsigned for $T {}\n \n impl Integer for $T {\n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Unsigned integer division. Returns the same result as `div` (`/`).\n-    #[inline(always)]\n+    #[inline]\n     fn div_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-    #[inline(always)]\n+    #[inline]\n     fn mod_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Calculates `div_floor` and `modulo_floor` simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-    #[inline(always)]\n+    #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut (m, n) = (*self, *other);\n@@ -247,67 +247,67 @@ impl Integer for $T {\n     }\n \n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-    #[inline(always)]\n+    #[inline]\n     fn lcm(&self, other: &$T) -> $T {\n         (*self * *other) / self.gcd(other)\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+    #[inline]\n     fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl Bitwise for $T {}\n \n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n impl BitAnd<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n impl BitXor<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n impl Shl<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n impl Shr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n impl Not<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn not(&self) -> $T { !*self }\n }\n \n impl Bounded for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> $T { min_value }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> $T { max_value }\n }\n \n@@ -316,35 +316,35 @@ impl Int for $T {}\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, false, false, false,\n                                    strconv::ExpNone, false, false)\n }\n \n impl FromStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n@@ -353,66 +353,66 @@ impl FromStrRadix for $T {\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }\n \n impl Primitive for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { bits }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { bits / 8 }\n }\n \n impl BitCount for $T {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> $T {\n         (*self as $T_SIGNED).population_count() as $T\n     }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> $T {\n         (*self as $T_SIGNED).leading_zeros() as $T\n     }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> $T {\n         (*self as $T_SIGNED).trailing_zeros() as $T\n     }"}, {"sha": "d0e1cfd15f48531434cf1bdb595763728d8f01ac", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -73,7 +73,7 @@ pub trait Buildable<A> {\n      fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn _eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     let mut i = 0;\n     for this.each |a| {\n@@ -89,7 +89,7 @@ pub fn eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     _eachi(this, blk)\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     for this.each |a| {\n         if !blk(a) {\n@@ -99,7 +99,7 @@ pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     for this.each |a| {\n         if blk(a) {\n@@ -109,7 +109,7 @@ pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     return false;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n                                             prd: &fn(&A) -> bool)\n                                          -> ~[A] {\n@@ -120,7 +120,7 @@ pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n     do vec::build_sized_opt(this.size_hint()) |push| {\n         for this.each |a| {\n@@ -129,7 +129,7 @@ pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n                                                           op: &fn(&A) -> IB)\n                                                        -> ~[B] {\n@@ -142,7 +142,7 @@ pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n                               -> B {\n     let mut b = b0;\n@@ -152,20 +152,20 @@ pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n     b\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn to_vec<A:Copy,IA:BaseIter<A>>(this: &IA) -> ~[A] {\n     map_to_vec(this, |&x| x)\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn contains<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> bool {\n     for this.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n     do foldl(this, 0) |count, value| {\n         if *value == *x {\n@@ -176,7 +176,7 @@ pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                -> Option<uint> {\n     let mut i = 0;\n@@ -187,7 +187,7 @@ pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n     return None;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                 -> Option<A> {\n     for this.each |i| {\n@@ -208,7 +208,7 @@ pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n  *             as an argument a function that will push an element\n  *             onto the sequence being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(4, builder)\n }\n@@ -226,7 +226,7 @@ pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n  *             as an argument a function that will push an element\n  *             onto the sequence being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n                                           builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(size.get_or_default(4), builder)\n@@ -236,7 +236,7 @@ pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n \n /// Applies a function to each element of an iterable and returns the results\n /// in a sequence built via `BU`.  See also `map_to_vec`.\n-#[inline(always)]\n+#[inline]\n pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n     -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n@@ -252,7 +252,7 @@ pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n  * Creates a generic sequence of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n@@ -266,7 +266,7 @@ pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n@@ -275,7 +275,7 @@ pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n }\n \n /// Appends two generic sequences.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n                                                   -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n@@ -288,7 +288,7 @@ pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n \n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n-#[inline(always)]\n+#[inline]\n pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(copy *x); }"}, {"sha": "7dc6b7fe4b1676f449e5b6a3670acf00f25fb31f", "filename": "src/libstd/option.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -89,7 +89,7 @@ impl<T:Ord> Ord for Option<T> {\n }\n \n impl<T: Copy+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n         match (&*self, &*other) {\n             (&None, &None) => None,\n@@ -126,12 +126,12 @@ impl<T> Option<T> {\n     }\n \n     /// Returns true if the option contains some value\n-    #[inline(always)]\n+    #[inline]\n     pub fn is_some(&const self) -> bool { !self.is_none() }\n \n     /// Update an optional value by optionally running its content through a\n     /// function that returns an option.\n-    #[inline(always)]\n+    #[inline]\n     pub fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n         match self {\n             Some(t) => f(t),\n@@ -140,7 +140,7 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the leftmost Some() value, or None if both are None.\n-    #[inline(always)]\n+    #[inline]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(opta) => Some(opta),\n@@ -150,7 +150,7 @@ impl<T> Option<T> {\n \n     /// Update an optional value by optionally running its content by reference\n     /// through a function that returns an option.\n-    #[inline(always)]\n+    #[inline]\n     pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>)\n                             -> Option<U> {\n         match *self {\n@@ -160,27 +160,27 @@ impl<T> Option<T> {\n     }\n \n     /// Maps a `some` value from one type to another by reference\n-    #[inline(always)]\n+    #[inline]\n     pub fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         match self { None => None, Some(v) => Some(f(v)) }\n     }\n \n     /// Applies a function to the contained value or returns a default\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n@@ -237,15 +237,15 @@ impl<T> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,\n           None => fail!(\"option::get_mut_ref none\")\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap(self) -> T {\n         /*!\n         Moves a value out of an option type and returns it.\n@@ -277,7 +277,7 @@ impl<T> Option<T> {\n      *\n      * Fails if the value equals `None`.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn swap_unwrap(&mut self) -> T {\n         if self.is_none() { fail!(\"option::swap_unwrap none\") }\n         util::replace(self, None).unwrap()\n@@ -291,7 +291,7 @@ impl<T> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n           Some(val) => val,\n@@ -315,7 +315,7 @@ impl<T:Copy> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(self) -> T {\n         match self {\n           Some(x) => return x,\n@@ -324,13 +324,13 @@ impl<T:Copy> Option<T> {\n     }\n \n     /// Returns the contained value or a default\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_or_default(self, def: T) -> T {\n         match self { Some(x) => x, None => def }\n     }\n \n     /// Applies a function zero or more times until the result is none.\n-    #[inline(always)]\n+    #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         let mut opt = self;\n         while opt.is_some() {\n@@ -341,7 +341,7 @@ impl<T:Copy> Option<T> {\n \n impl<T:Copy + Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_or_zero(self) -> T {\n         match self {\n             Some(x) => x,"}, {"sha": "e7a6e38fdb08874d5474806d66f346a9167e75ca", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -14,20 +14,20 @@\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for ~T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for ~T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }"}, {"sha": "9c51526aa7f66b4240ee0976c05b59b5f9163059", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -904,7 +904,7 @@ pub mod windows {\n     use libc;\n     use option::{None, Option, Some};\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_sep(u: char) -> bool {\n         u == '/' || u == '\\\\'\n     }"}, {"sha": "b505602702b484f00897d3a0a491224f5d70890c", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -19,31 +19,31 @@ use unstable::intrinsics;\n use uint;\n \n /// Calculate the offset from a pointer\n-#[inline(always)]\n+#[inline]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a const pointer\n-#[inline(always)]\n+#[inline]\n pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer\n-#[inline(always)]\n+#[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n /// Return the offset of the first null pointer in `buf`.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn buf_len<T>(buf: **T) -> uint {\n     position(buf, |i| *i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n     let mut i = 0;\n     loop {\n@@ -53,19 +53,19 @@ pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n }\n \n /// Create an unsafe null pointer\n-#[inline(always)]\n+#[inline]\n pub fn null<T>() -> *T { 0 as *T }\n \n /// Create an unsafe mutable null pointer\n-#[inline(always)]\n+#[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n /// Returns true if the pointer is equal to the null pointer.\n-#[inline(always)]\n+#[inline]\n pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n-#[inline(always)]\n+#[inline]\n pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n@@ -74,7 +74,7 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"32\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n@@ -88,7 +88,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n@@ -101,7 +101,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"64\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n@@ -115,7 +115,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n@@ -128,7 +128,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"32\", stage0)]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n@@ -142,7 +142,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy32;\n@@ -155,7 +155,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"64\", stage0)]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n@@ -169,7 +169,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy64;\n@@ -180,7 +180,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n  * bytes of memory starting at `dst` to `c`.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset32;\n@@ -191,7 +191,7 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n  * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n  * bytes of memory starting at `dst` to `c`.\n  */\n-#[inline(always)]\n+#[inline]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset64;\n@@ -222,26 +222,26 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n  * Replace the value at a mutable location with a new one, returning the old\n  * value, without deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n     swap_ptr(dest, &mut src);\n     src\n }\n \n /// Transform a region pointer - &T - to an unsafe pointer - *T.\n-#[inline(always)]\n+#[inline]\n pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     thing as *T\n }\n \n /// Transform a const region pointer - &const T - to a const unsafe pointer - *const T.\n-#[inline(always)]\n+#[inline]\n pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     thing as *const T\n }\n \n /// Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T.\n-#[inline(always)]\n+#[inline]\n pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     thing as *mut T\n }\n@@ -297,11 +297,11 @@ pub trait RawPtr<T> {\n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     ///\n@@ -314,26 +314,26 @@ impl<T> RawPtr<T> for *T {\n     /// that this is still an unsafe operation because the returned value could\n     /// be pointing to invalid memory.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_option(&const self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n     }\n \n     /// Calculates the offset from a pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn offset(&self, count: uint) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n impl<T> RawPtr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     ///\n@@ -346,45 +346,45 @@ impl<T> RawPtr<T> for *mut T {\n     /// that this is still an unsafe operation because the returned value could\n     /// be pointing to invalid memory.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_option(&const self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n     }\n \n     /// Calculates the offset from a mutable pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers\n #[cfg(not(test))]\n impl<T> Eq for *const T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n         (*self as uint) == (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n // Comparison for pointers\n #[cfg(not(test))]\n impl<T> Ord for *const T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &*const T) -> bool {\n         (*self as uint) < (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &*const T) -> bool {\n         (*self as uint) <= (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &*const T) -> bool {\n         (*self as uint) >= (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &*const T) -> bool {\n         (*self as uint) > (*other as uint)\n     }"}, {"sha": "739e3dfedc7f4bfb09af0140df7c9e4d4be018bd", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -451,7 +451,7 @@ pub trait RngUtil {\n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n-    #[inline(always)]\n+    #[inline]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n@@ -762,7 +762,7 @@ impl IsaacRng {\n }\n \n impl Rng for IsaacRng {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> u32 {\n         if self.cnt == 0 {\n             // make some more numbers\n@@ -862,7 +862,7 @@ pub fn task_rng() -> @@mut IsaacRng {\n \n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @@mut R {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> u32 {\n         match *self {\n             @@ref mut r => r.next()"}, {"sha": "6f4f1a34977e9a7d8e155416821078cac4905884", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -26,7 +26,7 @@ use rand::{Rng,Rand};\n mod ziggurat_tables;\n \n // inlining should mean there is no performance penalty for this\n-#[inline(always)]\n+#[inline]\n fn ziggurat<R:Rng>(rng: &mut R,\n                    center_u: bool,\n                    X: ziggurat_tables::ZigTable,\n@@ -77,11 +77,11 @@ pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n     fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n-        #[inline(always)]\n+        #[inline]\n         fn pdf(x: f64) -> f64 {\n             f64::exp((-x*x/2.0) as f64) as f64\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n             // compute a random number in the tail by hand\n \n@@ -131,11 +131,11 @@ pub struct Exp1(f64);\n impl Rand for Exp1 {\n     #[inline]\n     fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n-        #[inline(always)]\n+        #[inline]\n         fn pdf(x: f64) -> f64 {\n             f64::exp(-x)\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n             ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n         }"}, {"sha": "d276abf0c8b3e33a96a873d29c2c560c89e3425a", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -35,7 +35,7 @@ pub trait MovePtr {\n }\n \n /// Helper function for alignment calculation.\n-#[inline(always)]\n+#[inline]\n pub fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1u) & !(align - 1u)\n }\n@@ -49,26 +49,26 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n }\n \n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn bump(&self, sz: uint) {\n         do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n         };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn align(&self, a: uint) {\n         do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n         };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn align_to<T>(&self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }"}, {"sha": "ab3f83d34d59013b9a1f65104bb7d564f66b3bbb", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -164,7 +164,7 @@ pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n }\n \n impl MovePtr for ReprVisitor {\n-    #[inline(always)]\n+    #[inline]\n     fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n         *self.ptr = adjustment(*self.ptr);\n     }\n@@ -179,20 +179,20 @@ impl MovePtr for ReprVisitor {\n impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(*self.ptr));\n         }\n         true\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(*self.ptr, inner)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor(ptr, self.writer);\n@@ -202,7 +202,7 @@ impl ReprVisitor {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn write<T:Repr>(&self) -> bool {\n         do self.get |v:&T| {\n             v.write_repr(self.writer);"}, {"sha": "6cef5c33de0652d5af55d6b1df5fa7b58a25a3f7", "filename": "src/libstd/result.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -38,7 +38,7 @@ pub enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(ref t) => copy *t,\n@@ -54,7 +54,7 @@ pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n@@ -70,7 +70,7 @@ pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n  *\n  * If the result is not an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(ref u) => copy *u,\n@@ -79,7 +79,7 @@ pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n }\n \n /// Returns true if the result is `ok`\n-#[inline(always)]\n+#[inline]\n pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n@@ -88,7 +88,7 @@ pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n }\n \n /// Returns true if the result is `err`\n-#[inline(always)]\n+#[inline]\n pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n@@ -99,7 +99,7 @@ pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n@@ -122,7 +122,7 @@ pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n@@ -139,7 +139,7 @@ pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: &fn(t: V) -> Result<T, U>)\n@@ -164,7 +164,7 @@ pub fn chain_err<T, U, V>(\n  *         print_buf(buf)\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n@@ -180,7 +180,7 @@ pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n@@ -202,7 +202,7 @@ pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n@@ -219,7 +219,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n@@ -229,53 +229,53 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n impl<T, E> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_ok(&self) -> bool { is_ok(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_err(&self) -> bool { is_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap(self) -> T { unwrap(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_err(self) -> E { unwrap_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n \n impl<T:Copy,E> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self) -> T { get(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n impl<T, E: Copy> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_err(&self) -> E { get_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n@@ -298,7 +298,7 @@ impl<T, E: Copy> Result<T, E> {\n  *         assert!(incd == ~[2u, 3u, 4u]);\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -312,7 +312,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     return Ok(vs);\n }\n \n-#[inline(always)]\n+#[inline]\n #[allow(missing_doc)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n     o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n@@ -335,7 +335,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -358,7 +358,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map_zip()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n@@ -376,7 +376,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-#[inline(always)]\n+#[inline]\n pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n@@ -385,7 +385,7 @@ pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match res {\n       Err(u) => u,"}, {"sha": "09ba869549fd04f70d4364b8ae0807575422cc2c", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -207,7 +207,7 @@ fn align_down(sp: *mut uint) -> *mut uint {\n }\n \n // XXX: ptr::offset is positive ints only\n-#[inline(always)]\n+#[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T"}, {"sha": "04f5247782b0ed1a87130029b1f5eb269af8cf23", "filename": "src/libstd/str.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -106,21 +106,21 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n }\n \n /// Copy a slice into a new unique str\n-#[inline(always)]\n+#[inline]\n pub fn to_owned(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_owned(s, 0, s.len()) }\n }\n \n impl ToStr for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n impl<'self> ToStr for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n impl ToStr for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n \n@@ -241,26 +241,26 @@ pub trait CharEq {\n     fn only_ascii(&self) -> bool;\n }\n impl CharEq for char {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { *self == c }\n \n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n impl<'self> CharEq for &'self fn(char) -> bool {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n impl CharEq for extern \"Rust\" fn(char) -> bool {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n \n impl<'self, C: CharEq> CharEq for &'self [C] {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool {\n         self.iter().any_(|m| m.matches(c))\n     }\n@@ -705,7 +705,7 @@ impl<'self> StrUtil for &'self str {\n /**\n  * Deprecated. Use the `as_c_str` method on strings instead.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     s.as_c_str(f)\n }\n@@ -718,7 +718,7 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n  * indexable area for a null byte, as is the case in slices pointing\n  * to full strings, or suffixes of them.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = transmute(&s);\n@@ -915,7 +915,7 @@ pub mod traits {\n     use super::{Str, eq_slice};\n \n     impl<'self> Add<&'self str,~str> for &'self str {\n-        #[inline(always)]\n+        #[inline]\n         fn add(&self, rhs: & &'self str) -> ~str {\n             let mut ret = self.to_owned();\n             ret.push_str(*rhs);\n@@ -949,98 +949,98 @@ pub mod traits {\n     }\n \n     impl<'self> Eq for &'self str {\n-        #[inline(always)]\n+        #[inline]\n         fn eq(&self, other: & &'self str) -> bool {\n             eq_slice((*self), (*other))\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n     }\n \n     impl Eq for ~str {\n-        #[inline(always)]\n+        #[inline]\n         fn eq(&self, other: &~str) -> bool {\n             eq_slice((*self), (*other))\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n     }\n \n     impl Eq for @str {\n-        #[inline(always)]\n+        #[inline]\n         fn eq(&self, other: &@str) -> bool {\n             eq_slice((*self), (*other))\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n     }\n \n     impl<'self> TotalEq for &'self str {\n-        #[inline(always)]\n+        #[inline]\n         fn equals(&self, other: & &'self str) -> bool {\n             eq_slice((*self), (*other))\n         }\n     }\n \n     impl TotalEq for ~str {\n-        #[inline(always)]\n+        #[inline]\n         fn equals(&self, other: &~str) -> bool {\n             eq_slice((*self), (*other))\n         }\n     }\n \n     impl TotalEq for @str {\n-        #[inline(always)]\n+        #[inline]\n         fn equals(&self, other: &@str) -> bool {\n             eq_slice((*self), (*other))\n         }\n     }\n \n     impl<'self> Ord for &'self str {\n-        #[inline(always)]\n+        #[inline]\n         fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n-        #[inline(always)]\n+        #[inline]\n         fn le(&self, other: & &'self str) -> bool { self.cmp(other) != Greater }\n-        #[inline(always)]\n+        #[inline]\n         fn ge(&self, other: & &'self str) -> bool { self.cmp(other) != Less }\n-        #[inline(always)]\n+        #[inline]\n         fn gt(&self, other: & &'self str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl Ord for ~str {\n-        #[inline(always)]\n+        #[inline]\n         fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n-        #[inline(always)]\n+        #[inline]\n         fn le(&self, other: &~str) -> bool { self.cmp(other) != Greater }\n-        #[inline(always)]\n+        #[inline]\n         fn ge(&self, other: &~str) -> bool { self.cmp(other) != Less }\n-        #[inline(always)]\n+        #[inline]\n         fn gt(&self, other: &~str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl Ord for @str {\n-        #[inline(always)]\n+        #[inline]\n         fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n-        #[inline(always)]\n+        #[inline]\n         fn le(&self, other: &@str) -> bool { self.cmp(other) != Greater }\n-        #[inline(always)]\n+        #[inline]\n         fn ge(&self, other: &@str) -> bool { self.cmp(other) != Less }\n-        #[inline(always)]\n+        #[inline]\n         fn gt(&self, other: &@str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl<'self, S: Str> Equiv<S> for &'self str {\n-        #[inline(always)]\n+        #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n     impl<'self, S: Str> Equiv<S> for @str {\n-        #[inline(always)]\n+        #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n     impl<'self, S: Str> Equiv<S> for ~str {\n-        #[inline(always)]\n+        #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n }\n@@ -1055,17 +1055,17 @@ pub trait Str {\n }\n \n impl<'self> Str for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n }\n impl<'self> Str for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n     }\n }\n impl<'self> Str for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n     }\n@@ -1311,7 +1311,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n     /// Returns the size in bytes not counting the null terminator\n-    #[inline(always)]\n+    #[inline]\n     fn len(&self) -> uint {\n         do as_buf(*self) |_p, n| { n - 1u }\n     }\n@@ -1854,7 +1854,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      * assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n      * ~~~\n      */\n-    #[inline(always)]\n+    #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         do as_buf(*self) |a, a_len| {\n             do as_buf(inner) |b, b_len| {\n@@ -1925,7 +1925,7 @@ pub trait OwnedStr {\n \n impl OwnedStr for ~str {\n     /// Appends a string slice to the back of a string, without overallocating\n-    #[inline(always)]\n+    #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n         unsafe {\n             let llen = self.len();\n@@ -2078,7 +2078,7 @@ impl OwnedStr for ~str {\n      * * s - A string\n      * * n - The number of bytes to reserve space for\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n             let v: *mut ~[u8] = cast::transmute(self);\n@@ -2106,7 +2106,7 @@ impl OwnedStr for ~str {\n      * * s - A string\n      * * n - The number of bytes to reserve space for\n      */\n-    #[inline(always)]\n+    #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n@@ -2131,7 +2131,7 @@ impl OwnedStr for ~str {\n }\n \n impl Clone for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> ~str {\n         to_owned(*self)\n     }"}, {"sha": "c71765f911afae34a03e937a8dba16798b841a57", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -25,19 +25,19 @@ pub struct Ascii { priv chr: u8 }\n \n impl Ascii {\n     /// Converts a ascii character into a `u8`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_byte(self) -> u8 {\n         self.chr\n     }\n \n     /// Converts a ascii character into a `char`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_char(self) -> char {\n         self.chr as char\n     }\n \n     /// Convert to lowercase.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_lower(self) -> Ascii {\n         if self.chr >= 65 && self.chr <= 90 {\n             Ascii{chr: self.chr | 0x20 }\n@@ -47,7 +47,7 @@ impl Ascii {\n     }\n \n     /// Convert to uppercase.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_upper(self) -> Ascii {\n         if self.chr >= 97 && self.chr <= 122 {\n             Ascii{chr: self.chr & !0x20 }\n@@ -57,14 +57,14 @@ impl Ascii {\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n-    #[inline(always)]\n+    #[inline]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n         self.to_lower().chr == other.to_lower().chr\n     }\n }\n \n impl ToStr for Ascii {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { str::from_bytes(['\\'' as u8, self.chr, '\\'' as u8]) }\n }\n \n@@ -81,18 +81,18 @@ pub trait AsciiCast<T> {\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n         unsafe {self.to_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n         cast::transmute(*self)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         for self.each |b| {\n             if !b.is_ascii() { return false; }\n@@ -102,55 +102,55 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n         unsafe {self.to_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n         let (p,len): (*u8, uint) = cast::transmute(*self);\n         cast::transmute((p, len - 1))\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         self.bytes_iter().all(|b| b.is_ascii())\n     }\n }\n \n impl AsciiCast<Ascii> for u8 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n         unsafe {self.to_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n         Ascii{ chr: *self }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         *self & 128 == 0u8\n     }\n }\n \n impl AsciiCast<Ascii> for char {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n         unsafe {self.to_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n         Ascii{ chr: *self as u8 }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         *self - ('\\x7F' & *self) == '\\x00'\n     }\n@@ -167,26 +167,26 @@ pub trait OwnedAsciiCast {\n }\n \n impl OwnedAsciiCast for ~[u8] {\n-    #[inline(always)]\n+    #[inline]\n     fn into_ascii(self) -> ~[Ascii] {\n         assert!(self.is_ascii());\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n         cast::transmute(self)\n     }\n }\n \n impl OwnedAsciiCast for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn into_ascii(self) -> ~[Ascii] {\n         assert!(self.is_ascii());\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n         let mut r: ~[Ascii] = cast::transmute(self);\n         r.pop();\n@@ -210,31 +210,31 @@ pub trait AsciiStr {\n }\n \n impl<'self> AsciiStr for &'self [Ascii] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_ascii(&self) -> ~str {\n         let mut cpy = self.to_owned();\n         cpy.push(0u8.to_ascii());\n         unsafe {cast::transmute(cpy)}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn to_lower(&self) -> ~[Ascii] {\n         self.map(|a| a.to_lower())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn to_upper(&self) -> ~[Ascii] {\n         self.map(|a| a.to_upper())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n         do self.iter().zip(other.iter()).all |(&a, &b)| { a.eq_ignore_case(b) }\n     }\n }\n \n impl ToStrConsume for ~[Ascii] {\n-    #[inline(always)]\n+    #[inline]\n     fn into_str(self) -> ~str {\n         let mut cpy = self;\n         cpy.push(0u8.to_ascii());\n@@ -243,7 +243,7 @@ impl ToStrConsume for ~[Ascii] {\n }\n \n impl IterBytes for Ascii {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n         f([self.to_byte()])\n     }"}, {"sha": "79ea60cc224061810fd1263f6278d4239211a464", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -57,25 +57,25 @@ pub mod rustrt {\n  * Useful for calling certain function in the Rust runtime or otherwise\n  * performing dark magick.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { intrinsics::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns a pointer to a type descriptor.\n-#[inline(always)]\n+#[inline]\n pub fn get_type_desc_val<T>(_val: &T) -> *TypeDesc {\n     get_type_desc::<T>()\n }\n \n /// Returns the size of a type\n-#[inline(always)]\n+#[inline]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n /// Returns the size of the type that `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -85,14 +85,14 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n  *\n  * Useful for building structures containing variable-length arrays.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn nonzero_size_of<T>() -> uint {\n     let s = size_of::<T>();\n     if s == 0 { 1 } else { s }\n }\n \n /// Returns the size of the type of the value that `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n     nonzero_size_of::<T>()\n }\n@@ -104,33 +104,33 @@ pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n  * This is the alignment used for struct fields. It may be smaller\n  * than the preferred alignment.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n /// Returns the ABI-required minimum alignment of the type of the value that\n /// `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n \n /// Returns the preferred alignment of a type\n-#[inline(always)]\n+#[inline]\n pub fn pref_align_of<T>() -> uint {\n     unsafe { intrinsics::pref_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of the type of the value that\n /// `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn pref_align_of_val<T>(_val: &T) -> uint {\n     pref_align_of::<T>()\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n-#[inline(always)]\n+#[inline]\n pub fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::transmute_copy(&t);"}, {"sha": "16bb2fab7ba71b3d1eebf5f3b546fd3417b30846", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -157,14 +157,14 @@ struct AncestorNode {\n struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n-#[inline(always)]\n+#[inline]\n fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n     unsafe {\n         x.with(blk)\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe {"}, {"sha": "822aab0a02719f5a66c01b43c36810fc800f39d6", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -49,7 +49,7 @@ pub trait IterBytes {\n }\n \n impl IterBytes for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f([\n             *self as u8\n@@ -58,7 +58,7 @@ impl IterBytes for bool {\n }\n \n impl IterBytes for u8 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f([\n             *self\n@@ -67,7 +67,7 @@ impl IterBytes for u8 {\n }\n \n impl IterBytes for u16 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -84,7 +84,7 @@ impl IterBytes for u16 {\n }\n \n impl IterBytes for u32 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -105,7 +105,7 @@ impl IterBytes for u32 {\n }\n \n impl IterBytes for u64 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -134,72 +134,72 @@ impl IterBytes for u64 {\n }\n \n impl IterBytes for i8 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i16 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i32 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i64 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for char {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n #[cfg(target_word_size = \"32\")]\n impl IterBytes for uint {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl IterBytes for uint {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for int {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for float {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as f64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         let i: u32 = unsafe {\n             // 0.0 == -0.0 so they should also have the same hashcode\n@@ -210,7 +210,7 @@ impl IterBytes for f32 {\n }\n \n impl IterBytes for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         let i: u64 = unsafe {\n             // 0.0 == -0.0 so they should also have the same hashcode\n@@ -221,14 +221,14 @@ impl IterBytes for f64 {\n }\n \n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n \n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n-  #[inline(always)]\n+  #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n@@ -237,7 +237,7 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n }\n \n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n-  #[inline(always)]\n+  #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b, ref c) => {\n@@ -253,28 +253,28 @@ fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n }\n \n impl<A:IterBytes> IterBytes for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<'self> IterBytes for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f(self.as_bytes())\n     }\n }\n \n impl IterBytes for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         // this should possibly include the null terminator, but that\n         // breaks .find_equiv on hashmaps.\n@@ -283,7 +283,7 @@ impl IterBytes for ~str {\n }\n \n impl IterBytes for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         // this should possibly include the null terminator, but that\n         // breaks .find_equiv on hashmaps.\n@@ -292,7 +292,7 @@ impl IterBytes for @str {\n }\n \n impl<A:IterBytes> IterBytes for Option<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         match *self {\n           Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n@@ -302,21 +302,21 @@ impl<A:IterBytes> IterBytes for Option<A> {\n }\n \n impl<'self,A:IterBytes> IterBytes for &'self A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for ~A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n@@ -325,7 +325,7 @@ impl<A:IterBytes> IterBytes for ~A {\n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n impl<A> IterBytes for *const A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }"}, {"sha": "3e782e728fe3c52b3b781534d8203cfbafbc1074", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -35,12 +35,12 @@ pub trait ToStrConsume {\n }\n \n impl ToStr for () {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { ~\"()\" }\n }\n \n impl<A:ToStr> ToStr for (A,) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         match *self {\n             (ref a,) => {\n@@ -51,7 +51,7 @@ impl<A:ToStr> ToStr for (A,) {\n }\n \n impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n         for self.each |key, value| {\n@@ -71,7 +71,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n }\n \n impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n         for self.each |element| {\n@@ -89,7 +89,7 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n }\n \n impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         // FIXME(#4653): this causes an llvm assertion\n         //let &(ref a, ref b) = self;\n@@ -102,7 +102,7 @@ impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n }\n \n impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         // FIXME(#4653): this causes an llvm assertion\n         //let &(ref a, ref b, ref c) = self;\n@@ -119,7 +119,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n }\n \n impl<'self,A:ToStr> ToStr for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n@@ -137,7 +137,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n }\n \n impl<A:ToStr> ToStr for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n@@ -155,7 +155,7 @@ impl<A:ToStr> ToStr for ~[A] {\n }\n \n impl<A:ToStr> ToStr for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {"}, {"sha": "aaeaa489834f2f0221a1c384a3f9ae0d6108393b", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -34,17 +34,17 @@ pub struct TrieMap<T> {\n \n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n     /// Clear the map, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) {\n         self.root = TrieNode::new();\n         self.length = 0;\n@@ -53,37 +53,37 @@ impl<T> Mutable for TrieMap<T> {\n \n impl<T> Map<uint, T> for TrieMap<T> {\n     /// Return true if the map contains a value for the specified key\n-    #[inline(always)]\n+    #[inline]\n     fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all key-value pairs in order\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each(f)\n     }\n \n     /// Visit all keys in order\n-    #[inline(always)]\n+    #[inline]\n     fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    #[inline(always)]\n+    #[inline]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         self.root.mutate_values(f)\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[inline(hint)]\n+    #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n         let mut idx = 0;\n@@ -104,22 +104,22 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[inline(always)]\n+    #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n-    #[inline(always)]\n+    #[inline]\n     fn insert(&mut self, key: uint, value: T) -> bool {\n         self.swap(key, value).is_none()\n     }\n \n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n-    #[inline(always)]\n+    #[inline]\n     fn remove(&mut self, key: &uint) -> bool {\n         self.pop(key).is_some()\n     }\n@@ -147,25 +147,25 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n     /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all keys in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n@@ -178,59 +178,59 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl Container for TrieSet {\n     /// Return the number of elements in the set\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {\n     /// Clear the set, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl TrieSet {\n     /// Create an empty TrieSet\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n     /// Return true if the set contains a value\n-    #[inline(always)]\n+    #[inline]\n     pub fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     pub fn insert(&mut self, value: uint) -> bool {\n         self.map.insert(value, ())\n     }\n \n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         self.map.remove(value)\n     }\n@@ -242,7 +242,7 @@ struct TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn new() -> TrieNode<T> {\n         // FIXME: #5244: [Nothing, ..SIZE] should be possible without Copy\n         TrieNode{count: 0,\n@@ -291,7 +291,7 @@ impl<T> TrieNode<T> {\n }\n \n // if this was done via a trait, the key could be generic\n-#[inline(always)]\n+#[inline]\n fn chunk(n: uint, idx: uint) -> uint {\n     let sh = uint::bits - (SHIFT * (idx + 1));\n     (n >> sh) & MASK"}, {"sha": "fefd55c354158a19e3c68e2f2e511aa26005bbf4", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -29,23 +29,23 @@ pub trait CopyableTuple<T, U> {\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n     /// Return the first element of self\n-    #[inline(always)]\n+    #[inline]\n     fn first(&self) -> T {\n         match *self {\n             (ref t, _) => copy *t,\n         }\n     }\n \n     /// Return the second element of self\n-    #[inline(always)]\n+    #[inline]\n     fn second(&self) -> U {\n         match *self {\n             (_, ref u) => copy *u,\n         }\n     }\n \n     /// Return the results of swapping the two elements of self\n-    #[inline(always)]\n+    #[inline]\n     fn swap(&self) -> (U, T) {\n         match copy *self {\n             (t, u) => (u, t),\n@@ -63,13 +63,13 @@ pub trait ImmutableTuple<T, U> {\n }\n \n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n-    #[inline(always)]\n+    #[inline]\n     fn first_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn second_ref<'a>(&'a self) -> &'a U {\n         match *self {\n             (_, ref u) => u,\n@@ -83,7 +83,7 @@ pub trait ExtendedTupleOps<A,B> {\n }\n \n impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n-    #[inline(always)]\n+    #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -92,7 +92,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -103,7 +103,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n }\n \n impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n-    #[inline(always)]\n+    #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -112,7 +112,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -144,7 +144,7 @@ macro_rules! tuple_impls {\n \n                 impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T),+) {\n                     $(\n-                        #[inline(always)]\n+                        #[inline]\n                         fn $get_fn(&self) -> $T {\n                             self.$get_ref_fn().clone()\n                         }\n@@ -157,7 +157,7 @@ macro_rules! tuple_impls {\n \n                 impl<$($T),+> $immutable_trait<$($T),+> for ($($T),+) {\n                     $(\n-                        #[inline(always)]\n+                        #[inline]\n                         fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n                             match *self { $get_pattern => $ret }\n                         }\n@@ -172,35 +172,35 @@ macro_rules! tuple_impls {\n \n                 #[cfg(not(test))]\n                 impl<$($T:Eq),+> Eq for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn eq(&self, other: &($($T),+)) -> bool {\n                         $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n                     }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn ne(&self, other: &($($T),+)) -> bool {\n                         !(*self == *other)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n                 impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn equals(&self, other: &($($T),+)) -> bool {\n                         $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                     }\n                 }\n \n                 #[cfg(not(test))]\n                 impl<$($T:Ord),+> Ord for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn lt(&self, other: &($($T),+)) -> bool {\n                         lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn ge(&self, other: &($($T),+)) -> bool { !(*self).lt(other) }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n                 }\n "}, {"sha": "6e7a7e2b129ce4b7ea85a2190161054d13a7c0d7", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -82,7 +82,7 @@ impl AtomicFlag {\n     /**\n      * Clears the atomic flag\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self, order: Ordering) {\n         unsafe {atomic_store(&mut self.v, 0, order)}\n     }\n@@ -91,7 +91,7 @@ impl AtomicFlag {\n      * Sets the flag if it was previously unset, returns the previous value of the\n      * flag.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn test_and_set(&mut self, order: Ordering) -> bool {\n         unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n     }\n@@ -102,26 +102,26 @@ impl AtomicBool {\n         AtomicBool { v: if v { 1 } else { 0 } }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(&self.v, order) > 0 }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: bool, order: Ordering) {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_swap(&mut self.v, val, order) > 0}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { 1 } else { 0 };\n         let new = if new { 1 } else { 0 };\n@@ -135,34 +135,34 @@ impl AtomicInt {\n         AtomicInt { v:v }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: int, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_add).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_sub).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n@@ -173,34 +173,34 @@ impl AtomicUint {\n         AtomicUint { v:v }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: uint, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_add).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_sub)..\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n@@ -211,22 +211,22 @@ impl<T> AtomicPtr<T> {\n         AtomicPtr { p:p }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe { atomic_load(&self.p, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(&mut self.p, ptr, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(&mut self.p, ptr, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_compare_and_swap(&mut self.p, old, new, order) }\n     }\n@@ -249,7 +249,7 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n             let val = cast::transmute(val);\n@@ -265,7 +265,7 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn take(&mut self, order: Ordering) -> Option<~T> {\n         unsafe {\n             self.swap(cast::transmute(0), order)\n@@ -286,7 +286,7 @@ impl<T> Drop for AtomicOption<T> {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -297,7 +297,7 @@ pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n     let dst = cast::transmute(dst);\n \n@@ -307,7 +307,7 @@ pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n     })\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -320,7 +320,7 @@ pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n }\n \n /// Returns the old value (like __sync_fetch_and_add).\n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -333,7 +333,7 @@ pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n }\n \n /// Returns the old value (like __sync_fetch_and_sub).\n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -345,7 +345,7 @@ pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     })\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let old = cast::transmute(old);"}, {"sha": "d466488ce5e5d2260aa9c17010246a272d35d1d8", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -673,7 +673,7 @@ pub mod rt {\n         }\n         buf.push_str(s);\n     }\n-    #[inline(always)]\n+    #[inline]\n     pub fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }"}, {"sha": "505cfa2fcd905d90241883f1e3f2404f2d59aec4", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -152,7 +152,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n \n // FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n #[lang=\"exchange_malloc\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n@@ -232,7 +232,7 @@ impl DebugPrints for io::fd_t {\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[lang=\"exchange_free\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn exchange_free(ptr: *c_char) {\n     global_heap::free(transmute(ptr))\n }\n@@ -271,7 +271,7 @@ pub unsafe fn local_free(ptr: *c_char) {\n }\n \n #[lang=\"borrow_as_imm\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n     let a: *mut BoxRepr = transmute(a);\n     let old_ref_count = (*a).header.ref_count;\n@@ -289,7 +289,7 @@ pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n }\n \n #[lang=\"borrow_as_mut\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n     let a: *mut BoxRepr = transmute(a);\n     let old_ref_count = (*a).header.ref_count;\n@@ -346,7 +346,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n }\n \n #[lang=\"return_to_mut\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n                             file: *c_char, line: size_t) {\n     // Sometimes the box is null, if it is conditionally frozen.\n@@ -365,7 +365,7 @@ pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n }\n \n #[lang=\"check_not_borrowed\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn check_not_borrowed(a: *u8,\n                                  file: *c_char,\n                                  line: size_t) {\n@@ -378,7 +378,7 @@ pub unsafe fn check_not_borrowed(a: *u8,\n }\n \n #[lang=\"strdup_uniq\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n     str::raw::from_buf_len(ptr, len)\n }"}, {"sha": "79aa22fabea84af4bb51087cba1a9788887ed522", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -40,7 +40,7 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get(&self) -> *mut T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -50,7 +50,7 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n         return r;\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get_immut(&self) -> *T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -118,7 +118,7 @@ fn LittleLock() -> LittleLock {\n }\n \n impl LittleLock {\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n             rust_lock_little_lock(self.l);\n@@ -169,7 +169,7 @@ impl<T:Owned> Exclusive<T> {\n     // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n     // the exclusive. Supporting that is a work in progress.\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n@@ -183,7 +183,7 @@ impl<T:Owned> Exclusive<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))"}, {"sha": "2a5d44c9ce26ce4181af23e6989e4a34249e4b59", "filename": "src/libstd/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -16,11 +16,11 @@ use prelude::*;\n use unstable::intrinsics;\n \n /// The identity function.\n-#[inline(always)]\n+#[inline]\n pub fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n-#[inline(always)]\n+#[inline]\n pub fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n@@ -30,7 +30,7 @@ pub fn ignore<T>(_x: T) { }\n /// an obvious borrowck hazard. Typically passing in `&mut T` will\n /// cause borrow check errors because it freezes whatever location\n /// that `&mut T` is stored in (either statically or dynamically).\n-#[inline(always)]\n+#[inline]\n pub fn with<T,R>(\n     ptr: @mut T,\n     value: T,\n@@ -46,7 +46,7 @@ pub fn with<T,R>(\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -68,7 +68,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  * Replace the value at a mutable location with a new one, returning the old\n  * value, without deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src"}, {"sha": "0af69815cf23afd5e83e951180ef687521646cfe", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -111,7 +111,7 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n-#[inline(always)]\n+#[inline]\n pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(v);\n@@ -189,7 +189,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| vec.push(x));\n@@ -206,7 +206,7 @@ pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n@@ -223,7 +223,7 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A>(size: Option<uint>,\n                           builder: &fn(push: &fn(v: A)))\n                        -> ~[A] {\n@@ -271,7 +271,7 @@ pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     assert!(start <= end);\n     assert!(end <= v.len());\n@@ -284,7 +284,7 @@ pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n                     -> &'r mut [T] {\n     assert!(start <= end);\n@@ -298,7 +298,7 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n                       -> &'r const [T] {\n     assert!(start <= end);\n@@ -633,7 +633,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n }\n \n /// Append an element to a vector\n-#[inline(always)]\n+#[inline]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(&mut *v);\n@@ -648,7 +648,7 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n }\n \n // This doesn't bother to make sure we have space.\n-#[inline(always)] // really pretty please\n+#[inline] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     let repr: **mut raw::VecRepr = transmute(v);\n     let fill = (**repr).unboxed.fill;\n@@ -675,7 +675,7 @@ fn push_slow<T>(v: &mut ~[T], initval: T) {\n /// vec::push_all(&mut a, [2, 3, 4]);\n /// assert!(a == ~[1, 2, 3, 4]);\n /// ~~~\n-#[inline(always)]\n+#[inline]\n pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -696,7 +696,7 @@ pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n /// vec::push_all_move(&mut a, ~[~2, ~3, ~4]);\n /// assert!(a == ~[~1, ~2, ~3, ~4]);\n /// ~~~\n-#[inline(always)]\n+#[inline]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -767,7 +767,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n@@ -776,7 +776,7 @@ pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n \n /// Appends one element to the vector provided. The vector itself is then\n /// returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n     v.push(x);\n@@ -1295,7 +1295,7 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-#[inline(always)]\n+#[inline]\n pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n     unsafe {\n         // Can't take two mutable loans from one vector, so instead just cast\n@@ -1403,7 +1403,7 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * }\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     //            ^^^^\n     // NB---this CANNOT be &const [T]!  The reason\n@@ -1429,7 +1429,7 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n \n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n-#[inline(always)]\n+#[inline]\n pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     let mut i = 0;\n     let n = v.len();\n@@ -1447,7 +1447,7 @@ pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n  *\n  * Return true to continue, false to break.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     let mut i = 0;\n     for each(v) |p| {\n@@ -1540,7 +1540,7 @@ pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n  * Allows for unsafe manipulation of vector contents, which is useful for\n  * foreign interop.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_imm_buf<T,U>(s: &[T],\n                        /* NB---this CANNOT be const, see below */\n                        f: &fn(*T, uint) -> U) -> U {\n@@ -1559,7 +1559,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n }\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n-#[inline(always)]\n+#[inline]\n pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*const T,uint) = transmute(&s);\n@@ -1569,7 +1569,7 @@ pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n }\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n-#[inline(always)]\n+#[inline]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*mut T,uint) = transmute(&s);\n@@ -1612,49 +1612,49 @@ fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n \n #[cfg(not(test))]\n impl<'self,T:Eq> Eq for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T:TotalEq> TotalEq for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T:TotalEq> TotalEq for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<'self,T:Eq> Equiv<~[T]> for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n }\n \n@@ -1676,19 +1676,19 @@ fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n \n #[cfg(not(test))]\n impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T: TotalOrd> TotalOrd for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T: TotalOrd> TotalOrd for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n }\n \n@@ -1713,37 +1713,37 @@ fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(not(test))]\n impl<'self,T:Ord> Ord for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n \n@@ -1754,7 +1754,7 @@ pub mod traits {\n     use vec::append;\n \n     impl<'self,T:Copy> Add<&'self const [T],~[T]> for ~[T] {\n-        #[inline(always)]\n+        #[inline]\n         fn add(&self, rhs: & &'self const [T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n@@ -1958,7 +1958,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_ref(&self, index: uint) -> *T {\n         let (ptr, _): (*T, uint) = transmute(*self);\n         ptr.offset(index)\n@@ -2029,7 +2029,7 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     }\n \n     /// Returns the element at the given index, without doing bounds checking.\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n         copy *self.unsafe_ref(index)\n     }\n@@ -2210,14 +2210,14 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n         let pair_ptr: &(*mut T, uint) = transmute(self);\n         let (ptr, _) = *pair_ptr;\n         ptr.offset(index)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_set(&self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n@@ -2278,7 +2278,7 @@ pub mod raw {\n      * modifing its buffers, so it is up to the caller to ensure that\n      * the vector is actually the specified size.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         let repr: **mut VecRepr = transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n@@ -2293,7 +2293,7 @@ pub mod raw {\n      * Modifying the vector may cause its buffer to be reallocated, which\n      * would also make any pointers to it invalid.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_ptr<T>(v: &[T]) -> *T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2302,7 +2302,7 @@ pub mod raw {\n     }\n \n     /** see `to_ptr()` */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_const_ptr<T>(v: &const [T]) -> *const T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2311,7 +2311,7 @@ pub mod raw {\n     }\n \n     /** see `to_ptr()` */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2323,7 +2323,7 @@ pub mod raw {\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n@@ -2336,7 +2336,7 @@ pub mod raw {\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n@@ -2348,7 +2348,7 @@ pub mod raw {\n     /**\n      * Unchecked vector indexing.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n         as_const_buf(v, |p, _len| copy *ptr::const_offset(p, i))\n     }\n@@ -2358,7 +2358,7 @@ pub mod raw {\n      * old value and hence is only suitable when the vector\n      * is newly allocated.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n@@ -2377,7 +2377,7 @@ pub mod raw {\n     * * elts - The number of elements in the buffer\n     */\n     // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n@@ -2391,7 +2391,7 @@ pub mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n                                  count: uint) {\n         assert!(dst.len() >= count);\n@@ -2457,7 +2457,7 @@ pub mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    #[inline(always)]\n+    #[inline]\n     pub fn copy_memory(dst: &mut [u8], src: &const [u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n@@ -2468,31 +2468,31 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n@@ -2710,7 +2710,7 @@ pub struct VecMutRevIterator<'self, T> {\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n impl<T> FromIter<T> for ~[T]{\n-    #[inline(always)]\n+    #[inline]\n     pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n         let mut v = ~[];\n         for iter |x| { v.push(x) }"}, {"sha": "1758433aa7375c8927ae16fb6de23a27a5bf3f76", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -95,7 +95,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.name.iter_bytes(lsb0, f)\n     }"}, {"sha": "a4ded8fea8c40ad59b7d47f9198f275fa283e897", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -198,7 +198,7 @@ pub fn is_call_expr(e: @expr) -> bool {\n \n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.crate.iter_bytes(lsb0, f) && self.node.iter_bytes(lsb0, f)\n     }"}, {"sha": "e096711262fb0b3ffa4fdd643a771049cd664eda", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -312,7 +312,7 @@ pub enum inline_attr {\n \n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n-    // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n+    // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     do attrs.iter().fold(ia_none) |ia,attr| {\n         match attr.node.value.node {\n           ast::meta_word(s) if \"inline\" == s => ia_hint,"}, {"sha": "22ce305b85752ff5be019fd15b2ae0502f6a0cbf", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -1052,7 +1052,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n               self_2.method(__arg_1_2, __arg_2_2)])\n ~~~\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: @ExtCtxt, span: span,\n@@ -1083,7 +1083,7 @@ Fold together the results of calling the derived method on all the\n fields. `use_foldl` controls whether this is done left-to-right\n (`true`) or right-to-left (`false`).\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: &fn(@ExtCtxt, span, @expr, @expr) -> @expr,\n                            base: @expr,\n@@ -1111,7 +1111,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: @ExtCtxt, span: span,\n@@ -1130,7 +1130,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n }\n \n /// cs_binop with binop == or\n-#[inline(always)]\n+#[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n@@ -1139,7 +1139,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx, span, substructure)\n }\n /// cs_binop with binop == and\n-#[inline(always)]\n+#[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {"}, {"sha": "81f540fd69f2b0b23b652afb1d4e2b6db4049109", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -103,7 +103,7 @@ impl<T:Copy> OptVec<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n         let mut index = 0;\n         old_iter::map_to_vec(self, |a| {\n@@ -145,31 +145,31 @@ impl<A> BaseIter<A> for OptVec<A> {\n }\n \n impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::any(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         old_iter::foldl(self, b0, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         old_iter::position(self, f)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         old_iter::map_to_vec(self, op)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         old_iter::flat_map_to_vec(self, op)\n@@ -178,20 +178,20 @@ impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n }\n \n impl<A: Eq> old_iter::EqIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    #[inline(always)]\n+    #[inline]\n     fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n impl<A: Copy> old_iter::CopyableIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         old_iter::filter_to_vec(self, pred)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    #[inline(always)]\n+    #[inline]\n     fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         old_iter::find(self, f)\n     }"}, {"sha": "bb315bf2933957dffa8a71eb263565cb03004c8e", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d904c72af830bd4bec773ce35897703dff2ee3b1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=d904c72af830bd4bec773ce35897703dff2ee3b1", "patch": "@@ -68,7 +68,7 @@ pub enum ObsoleteSyntax {\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }"}]}