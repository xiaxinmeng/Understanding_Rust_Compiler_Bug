{"sha": "825bc606f5d27e66c573db96d85eec907755f1ed", "node_id": "C_kwDOAAsO6NoAKDgyNWJjNjA2ZjVkMjdlNjZjNTczZGI5NmQ4NWVlYzkwNzc1NWYxZWQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-29T13:51:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-29T13:51:15Z"}, "message": "Rollup merge of #105848 - lukas-code:backticks, r=GuillaumeGomez,jyn514,notriddle\n\nrustdoc: Add a new lint for broken inline code\n\nThis patch adds `rustdoc::unescaped_backticks`, a new rustdoc lint that will detect broken inline code nodes.\n\nThe lint woks by finding stray backticks and with some heuristics tries to guess where the second backtick might be missing.\n\nHere is how it looks:\n```rust\n#![warn(rustdoc::unescaped_backticks)]\n\n/// `add(a, b) is the same as `add(b, a)`.\npub fn add(a: i32, b: i32) -> i32 { a + b }\n```\n```text\nwarning: unescaped backtick\n --> src/lib.rs:3:41\n  |\n3 | /// `add(a, b) is the same as `add(b, a)`.\n  |                                         ^\n  |\nhelp: a previous inline code might be longer than expected\n  |\n3 | /// `add(a, b)` is the same as `add(b, a)`.\n  |               +\nhelp: if you meant to use a literal backtick, escape it\n  |\n3 | /// `add(a, b) is the same as `add(b, a)\\`.\n  |                                         +\n```\n\nIf we can't get proper spans, for example if the doc comment comes from a macro expansion, we print the suggestion in help messages instead. Here's a [real-world example](https://docs.rs/tracing-subscriber/0.3.17/tracing_subscriber/layer/trait.Filter.html#method.max_level_hint):\n\n```text\nwarning: unescaped backtick\n    --> /tracing-subscriber-0.3.17/src/layer/mod.rs:1400:9\n     |\n1400 | /         /// Returns an optional hint of the highest [verbosity level][level] that\n1401 | |         /// this `Filter` will enable.\n1402 | |         ///\n1403 | |         /// If this method returns a [`LevelFilter`], it will be used as a hint to\n...    |\n1427 | |         /// [`Interest`]: tracing_core::subscriber::Interest\n1428 | |         /// [rebuild]: tracing_core::callsite::rebuild_interest_cache\n     | |_____________________________________________________________________^\n     |\n     = help: a previous inline code might be longer than expected\n              change: Therefore, if the `Filter will change the value returned by this\n             to this: Therefore, if the `Filter` will change the value returned by this\n     = help: if you meant to use a literal backtick, escape it\n              change: [`rebuild_interest_cache`][rebuild] is called after the value of the max\n             to this: [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n```\n\nYou can find more examples [here](https://gist.github.com/lukas-code/7678ddf5c608aee97b3a669de80d3465).\n\nA limitation of the current implementation is, that it cannot suggest removing misplaced backticks, for example [here](https://docs.rs/tikv-jemalloc-sys/0.5.3+5.3.0-patched/tikv_jemalloc_sys/fn.mallctl.html).\n\nThe lint is allowed by default ~~and nightly-only~~ for now, ~~but without a feature gate. This is similar to how `rustdoc::invalid_html_tags` and `rustdoc::bare_urls` were handled.~~", "tree": {"sha": "4bad7aa839dcfe396d33876df85c04489387b0ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bad7aa839dcfe396d33876df85c04489387b0ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/825bc606f5d27e66c573db96d85eec907755f1ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkTSDTCRBK7hj4Ov3rIwAAE60IADZsVZiTA/g4aqwDyAIHbCFj\nG2YdqGKQvXfLzzdYjyN3ciz2KCSjOfGhmB2jXqzyoB9wQGESu83YjvEj9vZx3+9g\n732K7eIfbI0vNiqc1TMZx0NqnElwRXdEoAS6zjd3KQ/+A5PdG9HkXYsweu5DDUVl\nsGtV90BUj4Z2p/tifndKtKc6sXzkEJYUtNV1oaCS4SPwstLM//JAH7/CTRBmrZjI\nU1F2e/Pat3s1jOPNAQD60FFEy/Fw/CwgXIUfNWixGbQfitGdNh6WrqAf/50p4uCU\nUFd7wxepGbVh6UFJnllfV8Il9WQMhqbwHXVhSC++fh/fk1Y4r+3Q9RYknlMr5EM=\n=Fuf3\n-----END PGP SIGNATURE-----\n", "payload": "tree 4bad7aa839dcfe396d33876df85c04489387b0ed\nparent f2299490c11b0c53ece5f6a13dd092fc9c99d264\nparent 4f15a772b3ac7b56f177bcad4d59ad399844e588\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682776275 +0200\ncommitter GitHub <noreply@github.com> 1682776275 +0200\n\nRollup merge of #105848 - lukas-code:backticks, r=GuillaumeGomez,jyn514,notriddle\n\nrustdoc: Add a new lint for broken inline code\n\nThis patch adds `rustdoc::unescaped_backticks`, a new rustdoc lint that will detect broken inline code nodes.\n\nThe lint woks by finding stray backticks and with some heuristics tries to guess where the second backtick might be missing.\n\nHere is how it looks:\n```rust\n#![warn(rustdoc::unescaped_backticks)]\n\n/// `add(a, b) is the same as `add(b, a)`.\npub fn add(a: i32, b: i32) -> i32 { a + b }\n```\n```text\nwarning: unescaped backtick\n --> src/lib.rs:3:41\n  |\n3 | /// `add(a, b) is the same as `add(b, a)`.\n  |                                         ^\n  |\nhelp: a previous inline code might be longer than expected\n  |\n3 | /// `add(a, b)` is the same as `add(b, a)`.\n  |               +\nhelp: if you meant to use a literal backtick, escape it\n  |\n3 | /// `add(a, b) is the same as `add(b, a)\\`.\n  |                                         +\n```\n\nIf we can't get proper spans, for example if the doc comment comes from a macro expansion, we print the suggestion in help messages instead. Here's a [real-world example](https://docs.rs/tracing-subscriber/0.3.17/tracing_subscriber/layer/trait.Filter.html#method.max_level_hint):\n\n```text\nwarning: unescaped backtick\n    --> /tracing-subscriber-0.3.17/src/layer/mod.rs:1400:9\n     |\n1400 | /         /// Returns an optional hint of the highest [verbosity level][level] that\n1401 | |         /// this `Filter` will enable.\n1402 | |         ///\n1403 | |         /// If this method returns a [`LevelFilter`], it will be used as a hint to\n...    |\n1427 | |         /// [`Interest`]: tracing_core::subscriber::Interest\n1428 | |         /// [rebuild]: tracing_core::callsite::rebuild_interest_cache\n     | |_____________________________________________________________________^\n     |\n     = help: a previous inline code might be longer than expected\n              change: Therefore, if the `Filter will change the value returned by this\n             to this: Therefore, if the `Filter` will change the value returned by this\n     = help: if you meant to use a literal backtick, escape it\n              change: [`rebuild_interest_cache`][rebuild] is called after the value of the max\n             to this: [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n```\n\nYou can find more examples [here](https://gist.github.com/lukas-code/7678ddf5c608aee97b3a669de80d3465).\n\nA limitation of the current implementation is, that it cannot suggest removing misplaced backticks, for example [here](https://docs.rs/tikv-jemalloc-sys/0.5.3+5.3.0-patched/tikv_jemalloc_sys/fn.mallctl.html).\n\nThe lint is allowed by default ~~and nightly-only~~ for now, ~~but without a feature gate. This is similar to how `rustdoc::invalid_html_tags` and `rustdoc::bare_urls` were handled.~~\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/825bc606f5d27e66c573db96d85eec907755f1ed", "html_url": "https://github.com/rust-lang/rust/commit/825bc606f5d27e66c573db96d85eec907755f1ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/825bc606f5d27e66c573db96d85eec907755f1ed/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2299490c11b0c53ece5f6a13dd092fc9c99d264", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2299490c11b0c53ece5f6a13dd092fc9c99d264", "html_url": "https://github.com/rust-lang/rust/commit/f2299490c11b0c53ece5f6a13dd092fc9c99d264"}, {"sha": "4f15a772b3ac7b56f177bcad4d59ad399844e588", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f15a772b3ac7b56f177bcad4d59ad399844e588", "html_url": "https://github.com/rust-lang/rust/commit/4f15a772b3ac7b56f177bcad4d59ad399844e588"}], "stats": {"total": 1780, "additions": 1775, "deletions": 5}, "files": [{"sha": "fd57b07964481b3382c89c1aeb734d8306d66823", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -374,3 +374,41 @@ warning: this URL is not a hyperlink\n \n warning: 2 warnings emitted\n ```\n+\n+## `unescaped_backticks`\n+\n+This lint is **allowed by default**. It detects backticks (\\`) that are not escaped.\n+This usually means broken inline code. For example:\n+\n+```rust\n+#![warn(rustdoc::unescaped_backticks)]\n+\n+/// `add(a, b) is the same as `add(b, a)`.\n+pub fn add(a: i32, b: i32) -> i32 { a + b }\n+```\n+\n+Which will give:\n+\n+```text\n+warning: unescaped backtick\n+ --> src/lib.rs:3:41\n+  |\n+3 | /// `add(a, b) is the same as `add(b, a)`.\n+  |                                         ^\n+  |\n+note: the lint level is defined here\n+ --> src/lib.rs:1:9\n+  |\n+1 | #![warn(rustdoc::unescaped_backticks)]\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: a previous inline code might be longer than expected\n+  |\n+3 | /// `add(a, b)` is the same as `add(b, a)`.\n+  |               +\n+help: if you meant to use a literal backtick, escape it\n+  |\n+3 | /// `add(a, b) is the same as `add(b, a)\\`.\n+  |                                         +\n+\n+warning: 1 warning emitted\n+```"}, {"sha": "60754130d997c56afcdcd475023faa2f08d544c0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -7,14 +7,15 @@\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(impl_trait_in_assoc_type)]\n+#![feature(iter_intersperse)]\n+#![feature(lazy_cell)]\n #![feature(let_chains)]\n-#![feature(test)]\n #![feature(never_type)]\n-#![feature(lazy_cell)]\n-#![feature(type_ascription)]\n-#![feature(iter_intersperse)]\n+#![feature(round_char_boundary)]\n+#![feature(test)]\n #![feature(type_alias_impl_trait)]\n-#![feature(impl_trait_in_assoc_type)]\n+#![feature(type_ascription)]\n #![recursion_limit = \"256\"]\n #![warn(rustc::internal)]\n #![allow(clippy::collapsible_if, clippy::collapsible_else_if)]"}, {"sha": "749c1ff51bfc582bf51bdf6a7bea080739418efd", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -174,6 +174,17 @@ declare_rustdoc_lint! {\n    \"codeblock could not be parsed as valid Rust or is empty\"\n }\n \n+declare_rustdoc_lint! {\n+   /// The `unescaped_backticks` lint detects unescaped backticks (\\`), which usually\n+   /// mean broken inline code. This is a `rustdoc` only lint, see the documentation\n+   /// in the [rustdoc book].\n+   ///\n+   /// [rustdoc book]: ../../../rustdoc/lints.html#unescaped_backticks\n+   UNESCAPED_BACKTICKS,\n+   Allow,\n+   \"detects unescaped backticks in doc comments\"\n+}\n+\n pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     vec![\n         BROKEN_INTRA_DOC_LINKS,\n@@ -185,6 +196,7 @@ pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n         INVALID_HTML_TAGS,\n         BARE_URLS,\n         MISSING_CRATE_LEVEL_DOCS,\n+        UNESCAPED_BACKTICKS,\n     ]\n });\n "}, {"sha": "e653207b9b6d4278b587c9cf0b5f0cada25c566b", "filename": "src/librustdoc/passes/lint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Fpasses%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Fpasses%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint.rs?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -4,6 +4,7 @@\n mod bare_urls;\n mod check_code_block_syntax;\n mod html_tags;\n+mod unescaped_backticks;\n \n use super::Pass;\n use crate::clean::*;\n@@ -27,6 +28,7 @@ impl<'a, 'tcx> DocVisitor for Linter<'a, 'tcx> {\n         bare_urls::visit_item(self.cx, item);\n         check_code_block_syntax::visit_item(self.cx, item);\n         html_tags::visit_item(self.cx, item);\n+        unescaped_backticks::visit_item(self.cx, item);\n \n         self.visit_item_recur(item)\n     }"}, {"sha": "33cef82a60cbb54385fb9dbf0a4a9dba8ee5c0b8", "filename": "src/librustdoc/passes/lint/unescaped_backticks.rs", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -0,0 +1,416 @@\n+//! Detects unescaped backticks (\\`) in doc comments.\n+\n+use crate::clean::Item;\n+use crate::core::DocContext;\n+use crate::html::markdown::main_body_opts;\n+use crate::passes::source_span_for_markdown_range;\n+use pulldown_cmark::{BrokenLink, Event, Parser};\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_lint_defs::Applicability;\n+use std::ops::Range;\n+\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let tcx = cx.tcx;\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id) else {\n+        // If non-local, no need to check anything.\n+        return;\n+    };\n+\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if dox.is_empty() {\n+        return;\n+    }\n+\n+    let link_names = item.link_names(&cx.cache);\n+    let mut replacer = |broken_link: BrokenLink<'_>| {\n+        link_names\n+            .iter()\n+            .find(|link| *link.original_text == *broken_link.reference)\n+            .map(|link| ((*link.href).into(), (*link.new_text).into()))\n+    };\n+    let parser = Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n+        .into_offset_iter();\n+\n+    let mut element_stack = Vec::new();\n+\n+    let mut prev_text_end = 0;\n+    for (event, event_range) in parser {\n+        match event {\n+            Event::Start(_) => {\n+                element_stack.push(Element::new(event_range));\n+            }\n+            Event::End(_) => {\n+                let element = element_stack.pop().unwrap();\n+\n+                let Some(backtick_index) = element.backtick_index else {\n+                    continue;\n+                };\n+\n+                // If we can't get a span of the backtick, because it is in a `#[doc = \"\"]` attribute,\n+                // use the span of the entire attribute as a fallback.\n+                let span = source_span_for_markdown_range(\n+                    tcx,\n+                    &dox,\n+                    &(backtick_index..backtick_index + 1),\n+                    &item.attrs,\n+                )\n+                .unwrap_or_else(|| item.attr_span(tcx));\n+\n+                cx.tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n+                    let mut help_emitted = false;\n+\n+                    match element.prev_code_guess {\n+                        PrevCodeGuess::None => {}\n+                        PrevCodeGuess::Start { guess, .. } => {\n+                            // \"foo` `bar`\" -> \"`foo` `bar`\"\n+                            if let Some(suggest_index) = clamp_start(guess, &element.suggestible_ranges)\n+                                && can_suggest_backtick(&dox, suggest_index)\n+                            {\n+                                suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the opening backtick of a previous inline code may be missing\");\n+                                help_emitted = true;\n+                            }\n+                        }\n+                        PrevCodeGuess::End { guess, .. } => {\n+                            // \"`foo `bar`\" -> \"`foo` `bar`\"\n+                            // Don't `clamp_end` here, because the suggestion is guaranteed to be inside\n+                            // an inline code node and we intentionally \"break\" the inline code here.\n+                            let suggest_index = guess;\n+                            if can_suggest_backtick(&dox, suggest_index) {\n+                                suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"a previous inline code might be longer than expected\");\n+                                help_emitted = true;\n+                            }\n+                        }\n+                    }\n+\n+                    if !element.prev_code_guess.is_confident() {\n+                        // \"`foo` bar`\" -> \"`foo` `bar`\"\n+                        if let Some(guess) = guess_start_of_code(&dox, element.element_range.start..backtick_index)\n+                            && let Some(suggest_index) = clamp_start(guess, &element.suggestible_ranges)\n+                            && can_suggest_backtick(&dox, suggest_index)\n+                        {\n+                            suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the opening backtick of an inline code may be missing\");\n+                            help_emitted = true;\n+                        }\n+\n+                        // \"`foo` `bar\" -> \"`foo` `bar`\"\n+                        // Don't suggest closing backtick after single trailing char,\n+                        // if we already suggested opening backtick. For example:\n+                        // \"foo`.\" -> \"`foo`.\" or \"foo`s\" -> \"`foo`s\".\n+                        if let Some(guess) = guess_end_of_code(&dox, backtick_index + 1..element.element_range.end)\n+                            && let Some(suggest_index) = clamp_end(guess, &element.suggestible_ranges)\n+                            && can_suggest_backtick(&dox, suggest_index)\n+                            && (!help_emitted || suggest_index - backtick_index > 2)\n+                        {\n+                            suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the closing backtick of an inline code may be missing\");\n+                            help_emitted = true;\n+                        }\n+                    }\n+\n+                    if !help_emitted {\n+                        lint.help(\"the opening or closing backtick of an inline code may be missing\");\n+                    }\n+\n+                    suggest_insertion(cx, item, &dox, lint, backtick_index, '\\\\', \"if you meant to use a literal backtick, escape it\");\n+\n+                    lint\n+                });\n+            }\n+            Event::Code(_) => {\n+                let element = element_stack\n+                    .last_mut()\n+                    .expect(\"expected inline code node to be inside of an element\");\n+                assert!(\n+                    event_range.start >= element.element_range.start\n+                        && event_range.end <= element.element_range.end\n+                );\n+\n+                // This inline code might be longer than it's supposed to be.\n+                // Only check single backtick inline code for now.\n+                if !element.prev_code_guess.is_confident()\n+                    && dox.as_bytes().get(event_range.start) == Some(&b'`')\n+                    && dox.as_bytes().get(event_range.start + 1) != Some(&b'`')\n+                {\n+                    let range_inside = event_range.start + 1..event_range.end - 1;\n+                    let text_inside = &dox[range_inside.clone()];\n+\n+                    let is_confident = text_inside.starts_with(char::is_whitespace)\n+                        || text_inside.ends_with(char::is_whitespace);\n+\n+                    if let Some(guess) = guess_end_of_code(&dox, range_inside) {\n+                        // Find earlier end of code.\n+                        element.prev_code_guess = PrevCodeGuess::End { guess, is_confident };\n+                    } else {\n+                        // Find alternate start of code.\n+                        let range_before = element.element_range.start..event_range.start;\n+                        if let Some(guess) = guess_start_of_code(&dox, range_before) {\n+                            element.prev_code_guess = PrevCodeGuess::Start { guess, is_confident };\n+                        }\n+                    }\n+                }\n+            }\n+            Event::Text(text) => {\n+                let element = element_stack\n+                    .last_mut()\n+                    .expect(\"expected inline text node to be inside of an element\");\n+                assert!(\n+                    event_range.start >= element.element_range.start\n+                        && event_range.end <= element.element_range.end\n+                );\n+\n+                // The first char is escaped if the prev char is \\ and not part of a text node.\n+                let is_escaped = prev_text_end < event_range.start\n+                    && dox.as_bytes()[event_range.start - 1] == b'\\\\';\n+\n+                // Don't lint backslash-escaped (\\`) or html-escaped (&#96;) backticks.\n+                if *text == *\"`\" && !is_escaped && *text == dox[event_range.clone()] {\n+                    // We found a stray backtick.\n+                    assert!(\n+                        element.backtick_index.is_none(),\n+                        \"expected at most one unescaped backtick per element\",\n+                    );\n+                    element.backtick_index = Some(event_range.start);\n+                }\n+\n+                prev_text_end = event_range.end;\n+\n+                if is_escaped {\n+                    // Ensure that we suggest \"`\\x\" and not \"\\`x\".\n+                    element.suggestible_ranges.push(event_range.start - 1..event_range.end);\n+                } else {\n+                    element.suggestible_ranges.push(event_range);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+/// A previous inline code node, that looks wrong.\n+///\n+/// `guess` is the position, where we want to suggest a \\` and the guess `is_confident` if an\n+/// inline code starts or ends with a whitespace.\n+#[derive(Debug)]\n+enum PrevCodeGuess {\n+    None,\n+\n+    /// Missing \\` at start.\n+    ///\n+    /// ```markdown\n+    /// foo` `bar`\n+    /// ```\n+    Start {\n+        guess: usize,\n+        is_confident: bool,\n+    },\n+\n+    /// Missing \\` at end.\n+    ///\n+    /// ```markdown\n+    /// `foo `bar`\n+    /// ```\n+    End {\n+        guess: usize,\n+        is_confident: bool,\n+    },\n+}\n+\n+impl PrevCodeGuess {\n+    fn is_confident(&self) -> bool {\n+        match *self {\n+            PrevCodeGuess::None => false,\n+            PrevCodeGuess::Start { is_confident, .. } | PrevCodeGuess::End { is_confident, .. } => {\n+                is_confident\n+            }\n+        }\n+    }\n+}\n+\n+/// A markdown [tagged element], which may or may not contain an unescaped backtick.\n+///\n+/// [tagged element]: https://docs.rs/pulldown-cmark/0.9/pulldown_cmark/enum.Tag.html\n+#[derive(Debug)]\n+struct Element {\n+    /// The full range (span) of the element in the doc string.\n+    element_range: Range<usize>,\n+\n+    /// The ranges where we're allowed to put backticks.\n+    /// This is used to prevent breaking markdown elements like links or lists.\n+    suggestible_ranges: Vec<Range<usize>>,\n+\n+    /// The unescaped backtick.\n+    backtick_index: Option<usize>,\n+\n+    /// Suggest a different start or end of an inline code.\n+    prev_code_guess: PrevCodeGuess,\n+}\n+\n+impl Element {\n+    const fn new(element_range: Range<usize>) -> Self {\n+        Self {\n+            element_range,\n+            suggestible_ranges: Vec::new(),\n+            backtick_index: None,\n+            prev_code_guess: PrevCodeGuess::None,\n+        }\n+    }\n+}\n+\n+/// Given a potentially unclosed inline code, attempt to find the start.\n+fn guess_start_of_code(dox: &str, range: Range<usize>) -> Option<usize> {\n+    assert!(dox.as_bytes()[range.end] == b'`');\n+\n+    let mut braces = 0;\n+    let mut guess = 0;\n+    for (idx, ch) in dox[range.clone()].char_indices().rev() {\n+        match ch {\n+            ')' | ']' | '}' => braces += 1,\n+            '(' | '[' | '{' => {\n+                if braces == 0 {\n+                    guess = idx + 1;\n+                    break;\n+                }\n+                braces -= 1;\n+            }\n+            ch if ch.is_whitespace() && braces == 0 => {\n+                guess = idx + 1;\n+                break;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    guess += range.start;\n+\n+    // Don't suggest empty inline code or duplicate backticks.\n+    can_suggest_backtick(dox, guess).then_some(guess)\n+}\n+\n+/// Given a potentially unclosed inline code, attempt to find the end.\n+fn guess_end_of_code(dox: &str, range: Range<usize>) -> Option<usize> {\n+    // Punctuation that should be outside of the inline code.\n+    const TRAILING_PUNCTUATION: &[u8] = b\".,\";\n+\n+    assert!(dox.as_bytes()[range.start - 1] == b'`');\n+\n+    let text = dox[range.clone()].trim_end();\n+    let mut braces = 0;\n+    let mut guess = text.len();\n+    for (idx, ch) in text.char_indices() {\n+        match ch {\n+            '(' | '[' | '{' => braces += 1,\n+            ')' | ']' | '}' => {\n+                if braces == 0 {\n+                    guess = idx;\n+                    break;\n+                }\n+                braces -= 1;\n+            }\n+            ch if ch.is_whitespace() && braces == 0 => {\n+                guess = idx;\n+                break;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    // Strip a single trailing punctuation.\n+    if guess >= 1\n+        && TRAILING_PUNCTUATION.contains(&text.as_bytes()[guess - 1])\n+        && (guess < 2 || !TRAILING_PUNCTUATION.contains(&text.as_bytes()[guess - 2]))\n+    {\n+        guess -= 1;\n+    }\n+\n+    guess += range.start;\n+\n+    // Don't suggest empty inline code or duplicate backticks.\n+    can_suggest_backtick(dox, guess).then_some(guess)\n+}\n+\n+/// Returns whether inserting a backtick at `dox[index]` will not produce double backticks.\n+fn can_suggest_backtick(dox: &str, index: usize) -> bool {\n+    (index == 0 || dox.as_bytes()[index - 1] != b'`')\n+        && (index == dox.len() || dox.as_bytes()[index] != b'`')\n+}\n+\n+/// Increase the index until it is inside or one past the end of one of the ranges.\n+///\n+/// The ranges must be sorted for this to work correctly.\n+fn clamp_start(index: usize, ranges: &[Range<usize>]) -> Option<usize> {\n+    for range in ranges {\n+        if range.start >= index {\n+            return Some(range.start);\n+        }\n+        if index <= range.end {\n+            return Some(index);\n+        }\n+    }\n+    None\n+}\n+\n+/// Decrease the index until it is inside or one past the end of one of the ranges.\n+///\n+/// The ranges must be sorted for this to work correctly.\n+fn clamp_end(index: usize, ranges: &[Range<usize>]) -> Option<usize> {\n+    for range in ranges.iter().rev() {\n+        if range.end <= index {\n+            return Some(range.end);\n+        }\n+        if index >= range.start {\n+            return Some(index);\n+        }\n+    }\n+    None\n+}\n+\n+/// Try to emit a span suggestion and fall back to help messages if we can't find a suitable span.\n+///\n+/// This helps finding backticks in huge macro-generated docs.\n+fn suggest_insertion(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    dox: &str,\n+    lint: &mut DiagnosticBuilder<'_, ()>,\n+    insert_index: usize,\n+    suggestion: char,\n+    message: &str,\n+) {\n+    /// Maximum bytes of context to show around the insertion.\n+    const CONTEXT_MAX_LEN: usize = 80;\n+\n+    if let Some(span) =\n+        source_span_for_markdown_range(cx.tcx, &dox, &(insert_index..insert_index), &item.attrs)\n+    {\n+        lint.span_suggestion(span, message, suggestion, Applicability::MaybeIncorrect);\n+    } else {\n+        let line_start = dox[..insert_index].rfind('\\n').map_or(0, |idx| idx + 1);\n+        let line_end = dox[insert_index..].find('\\n').map_or(dox.len(), |idx| idx + insert_index);\n+\n+        let context_before_max_len = if insert_index - line_start < CONTEXT_MAX_LEN / 2 {\n+            insert_index - line_start\n+        } else if line_end - insert_index < CONTEXT_MAX_LEN / 2 {\n+            CONTEXT_MAX_LEN - (line_end - insert_index)\n+        } else {\n+            CONTEXT_MAX_LEN / 2\n+        };\n+        let context_after_max_len = CONTEXT_MAX_LEN - context_before_max_len;\n+\n+        let (prefix, context_start) = if insert_index - line_start <= context_before_max_len {\n+            (\"\", line_start)\n+        } else {\n+            (\"...\", dox.ceil_char_boundary(insert_index - context_before_max_len))\n+        };\n+        let (suffix, context_end) = if line_end - insert_index <= context_after_max_len {\n+            (\"\", line_end)\n+        } else {\n+            (\"...\", dox.floor_char_boundary(insert_index + context_after_max_len))\n+        };\n+\n+        let context_full = &dox[context_start..context_end].trim_end();\n+        let context_before = &dox[context_start..insert_index];\n+        let context_after = &dox[insert_index..context_end].trim_end();\n+        lint.help(format!(\n+            \"{message}\\n change: {prefix}{context_full}{suffix}\\nto this: {prefix}{context_before}{suggestion}{context_after}{suffix}\"\n+        ));\n+    }\n+}"}, {"sha": "f1ad7c8d4c7841f12177fe968f3802f834f429e5", "filename": "tests/rustdoc-ui/unescaped_backticks.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.rs?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -0,0 +1,342 @@\n+#![deny(rustdoc::unescaped_backticks)]\n+#![allow(rustdoc::broken_intra_doc_links)]\n+#![allow(rustdoc::invalid_html_tags)]\n+\n+///\n+pub fn empty() {}\n+\n+#[doc = \"\"]\n+pub fn empty2() {}\n+\n+/// `\n+//~^ ERROR unescaped backtick\n+pub fn single() {}\n+\n+/// \\`\n+pub fn escaped() {}\n+\n+/// \\\\`\n+//~^ ERROR unescaped backtick\n+pub fn not_escaped() {}\n+\n+/// \\\\\\`\n+pub fn not_not_escaped() {}\n+\n+/// [`link1]\n+//~^ ERROR unescaped backtick\n+pub fn link1() {}\n+\n+/// [link2`]\n+//~^ ERROR unescaped backtick\n+pub fn link2() {}\n+\n+/// [`link_long](link_long)\n+//~^ ERROR unescaped backtick\n+pub fn link_long() {}\n+\n+/// [`broken-link]\n+//~^ ERROR unescaped backtick\n+pub fn broken_link() {}\n+\n+/// <xx:`>\n+pub fn url() {}\n+\n+/// <x:`>\n+//~^ ERROR unescaped backtick\n+pub fn not_url() {}\n+\n+/// <h1>`</h1>\n+pub fn html_tag() {}\n+\n+/// &#96;\n+pub fn html_escape() {}\n+\n+/// \ud83e\udd80`\ud83e\udd80\n+//~^ ERROR unescaped backtick\n+pub fn unicode() {}\n+\n+/// `foo(\n+//~^ ERROR unescaped backtick\n+///\n+/// paragraph\n+pub fn paragraph() {}\n+\n+/// `foo `bar`\n+//~^ ERROR unescaped backtick\n+///\n+/// paragraph\n+pub fn paragraph2() {}\n+\n+/// `foo(\n+//~^ ERROR unescaped backtick\n+/// not paragraph\n+pub fn not_paragraph() {}\n+\n+/// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (add(n, 42)`),\n+/// or even to add a number `n` to 42 (`add(42, b)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add1(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)),\n+/// or even to add a number `n` to 42 (`add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add2(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+/// or even to add a number `n` to 42 (add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add3(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)),\n+/// or even to add a number `n` to 42 (`add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add4(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"`\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr() {}\n+\n+#[doc = concat!(\"\\\\\", \"`\")]\n+pub fn attr_escaped() {}\n+\n+#[doc = concat!(\"\\\\\\\\\", \"`\")]\n+//~^ ERROR unescaped backtick\n+pub fn attr_not_escaped() {}\n+\n+#[doc = \"Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add1(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add2(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add3(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add4(a: i32, b: i32) -> i32 { a + b }\n+\n+/// ``double backticks``\n+/// `foo\n+//~^ ERROR unescaped backtick\n+pub fn double_backticks() {}\n+\n+/// # `(heading\n+//~^ ERROR unescaped backtick\n+/// ## heading2)`\n+//~^ ERROR unescaped backtick\n+///\n+/// multi `(\n+//~^ ERROR unescaped backtick\n+/// line\n+/// ) heading\n+/// =\n+///\n+/// para)`(graph\n+//~^ ERROR unescaped backtick\n+///\n+/// para)`(graph2\n+//~^ ERROR unescaped backtick\n+///\n+/// 1. foo)`\n+//~^ ERROR unescaped backtick\n+/// 2. `(bar\n+//~^ ERROR unescaped backtick\n+/// * baz)`\n+//~^ ERROR unescaped backtick\n+/// * `(quux\n+//~^ ERROR unescaped backtick\n+///\n+/// `#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+//~^ ERROR unescaped backtick\n+///\n+/// #![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+//~^ ERROR unescaped backtick\n+///\n+/// [this_is_actually_an_image(and(not), an = \"attribute\")]: `.png\n+///\n+/// | `table( | )head` |\n+//~^ ERROR unescaped backtick\n+//~| ERROR unescaped backtick\n+/// |---------|--------|\n+/// | table`( | )`body |\n+//~^ ERROR unescaped backtick\n+//~| ERROR unescaped backtick\n+pub fn complicated_markdown() {}\n+\n+/// The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n+/// attribute only works on functions - there is no way to insert custom MIR into the middle of\n+/// another function. The `dialect` and `phase` parameters indicate which [version of MIR][dialect\n+/// docs] you are inserting here. Generally you'll want to use `#![custom_mir(dialect = \"built\")]`\n+/// if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n+//~^ ERROR unescaped backtick\n+/// \"runtime\", phase = \"optimized\")] if you don't.\n+pub mod mir {}\n+\n+pub mod rustc {\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    //~^ ERROR unescaped backtick\n+    /// ensure it gets used.\n+    pub fn ty_error_with_message() {}\n+\n+    pub struct WhereClause {\n+        /// `true` if we ate a `where` token: this can happen\n+        /// if we parsed no predicates (e.g. `struct Foo where {}\n+        /// This allows us to accurately pretty-print\n+        /// in `nt_to_tokenstream`\n+        //~^ ERROR unescaped backtick\n+        pub has_where_token: bool,\n+    }\n+\n+    /// A symbol is an interned or gensymed string. The use of `newtype_index!` means\n+    /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index! reserves\n+    //~^ ERROR unescaped backtick\n+    /// the last 256 values for tagging purposes.\n+    pub struct Symbol();\n+\n+    /// It is equivalent to `OpenOptions::new()` but allows you to write more\n+    /// readable code. Instead of `OpenOptions::new().read(true).open(\"foo.txt\")`\n+    /// you can write `File::with_options().read(true).open(\"foo.txt\"). This\n+    /// also avoids the need to import `OpenOptions`.\n+    //~^ ERROR unescaped backtick\n+    pub fn with_options() {}\n+\n+    /// Subtracts `set from `row`. `set` can be either `BitSet` or\n+    /// `HybridBitSet`. Has no effect if `row` does not exist.\n+    //~^ ERROR unescaped backtick\n+    ///\n+    /// Returns true if the row was changed.\n+    pub fn subtract_row() {}\n+\n+    pub mod assert_module_sources {\n+        //! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n+        //! the HIR doesn't change as a result of the annotations, which might\n+        //! perturb the reuse results.\n+        //!\n+        //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+        //~^ ERROR unescaped backtick\n+        //! allows for doing a more fine-grained check to see if pre- or post-lto data\n+        //! was re-used.\n+\n+        /// `cfg=...\n+        //~^ ERROR unescaped backtick\n+        pub fn foo() {}\n+\n+        /// `cfg=... and not `#[cfg_attr]`\n+        //~^ ERROR unescaped backtick\n+        pub fn bar() {}\n+    }\n+\n+    /// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n+    /// RWU`s can get very large, so it uses a more compact representation.\n+    //~^ ERROR unescaped backtick\n+    pub struct RWUTable {}\n+\n+    /// Like [Self::canonicalize_query], but preserves distinct universes. For\n+    /// example, canonicalizing `&'?0: Trait<'?1>`, where `'?0` is in `U1` and\n+    /// `'?1` is in `U3` would be canonicalized to have ?0` in `U1` and `'?1`\n+    /// in `U2`.\n+    //~^ ERROR unescaped backtick\n+    ///\n+    /// This is used for Chalk integration.\n+    pub fn canonicalize_query_preserving_universes() {}\n+\n+    /// Note that we used to return `Error` here, but that was quite\n+    /// dubious -- the premise was that an error would *eventually* be\n+    /// reported, when the obligation was processed. But in general once\n+    /// you see an `Error` you are supposed to be able to assume that an\n+    /// error *has been* reported, so that you can take whatever heuristic\n+    /// paths you want to take. To make things worse, it was possible for\n+    /// cycles to arise, where you basically had a setup like `<MyType<$0>\n+    /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n+    /// Trait>::Foo> to `[type error]` would lead to an obligation of\n+    /// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n+    /// an error for this obligation, but we legitimately should not,\n+    /// because it contains `[type error]`. Yuck! (See issue #29857 for\n+    //~^ ERROR unescaped backtick\n+    /// one case where this arose.)\n+    pub fn normalize_to_error() {}\n+\n+    /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n+    /// is `EvaluatedToOk`; this is because they were only considered\n+    /// ok on the premise that if `A: AutoTrait` held, but we indeed\n+    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// currently set a flag on the stack node for `B: AutoTrait` (as\n+    /// well as the second instance of `A: AutoTrait`) to suppress\n+    //~^ ERROR unescaped backtick\n+    /// caching.\n+    pub struct TraitObligationStack;\n+\n+    /// Extend `scc` so that it can outlive some placeholder region\n+    /// from a universe it can't name; at present, the only way for\n+    /// this to be true is if `scc` outlives `'static`. This is\n+    /// actually stricter than necessary: ideally, we'd support bounds\n+    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// `'a` with `'b` and not `'static`. But it will have to do for\n+    //~^ ERROR unescaped backtick\n+    /// now.\n+    pub fn add_incompatible_universe(){}\n+}\n+\n+/// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+/// which returns an `Option<Dispatch>`. If all [`Dispatch`] clones that point\n+/// at the `Subscriber` have been dropped, [`WeakDispatch::upgrade`] will return\n+/// `None`. Otherwise, it will return `Some(Dispatch)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// Returns some reference to this `[`Subscriber`] value if it is of type `T`,\n+/// or `None` if it isn't.\n+//~^ ERROR unescaped backtick\n+///\n+/// Called before the filtered [`Layer]'s [`on_event`], to determine if\n+/// `on_event` should be called.\n+//~^ ERROR unescaped backtick\n+///\n+/// Therefore, if the `Filter will change the value returned by this\n+/// method, it is responsible for ensuring that\n+/// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+//~^ ERROR unescaped backtick\n+/// level changes.\n+pub mod tracing {}\n+\n+macro_rules! id {\n+    ($($tt:tt)*) => { $($tt)* }\n+}\n+\n+id! {\n+    /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+    //~^ ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    /// which returns an `Option<Dispatch>`. If all [`Dispatch`] clones that point\n+    /// at the `Subscriber` have been dropped, [`WeakDispatch::upgrade`] will return\n+    /// `None`. Otherwise, it will return `Some(Dispatch)`.\n+    ///\n+    /// Returns some reference to this `[`Subscriber`] value if it is of type `T`,\n+    /// or `None` if it isn't.\n+    ///\n+    /// Called before the filtered [`Layer]'s [`on_event`], to determine if\n+    /// `on_event` should be called.\n+    ///\n+    /// Therefore, if the `Filter will change the value returned by this\n+    /// method, it is responsible for ensuring that\n+    /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+    /// level changes.\n+    pub mod tracing_macro {}\n+}"}, {"sha": "e629dbc34e9b44e42d36e3132544ff9343cb725b", "filename": "tests/rustdoc-ui/unescaped_backticks.stderr", "status": "added", "additions": 959, "deletions": 0, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/825bc606f5d27e66c573db96d85eec907755f1ed/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/825bc606f5d27e66c573db96d85eec907755f1ed/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.stderr?ref=825bc606f5d27e66c573db96d85eec907755f1ed", "patch": "@@ -0,0 +1,959 @@\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:186:70\n+   |\n+LL | /// if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n+   |                                                                      ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unescaped_backticks.rs:1:9\n+   |\n+LL | #![deny(rustdoc::unescaped_backticks)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// \"runtime\", phase = \"optimized\")]` if you don't.\n+   |                                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// if you want your MIR to be modified by the full MIR pipeline, or \\`#![custom_mir(dialect =\n+   |                                                                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:231:13\n+   |\n+LL |         //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+   |             ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |         //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]`\n+   |                                                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         //! \\`#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:236:13\n+   |\n+LL |         /// `cfg=...\n+   |             ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |         /// `cfg=...`\n+   |                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// \\`cfg=...\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:240:42\n+   |\n+LL |         /// `cfg=... and not `#[cfg_attr]`\n+   |                                          ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |         /// `cfg=...` and not `#[cfg_attr]`\n+   |                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// `cfg=... and not `#[cfg_attr]\\`\n+   |                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:192:91\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+   |                                                                                           ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n+   |                                                                                               +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given \\`msg to\n+   |                                                                                           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:201:34\n+   |\n+LL |         /// in `nt_to_tokenstream`\n+   |                                  ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |         /// if we parsed no predicates (e.g. `struct` Foo where {}\n+   |                                                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// in `nt_to_tokenstream\\`\n+   |                                  +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:207:62\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index! reserves\n+   |                                                              ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index!` reserves\n+   |                                                                             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because \\`newtype_index! reserves\n+   |                                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:215:52\n+   |\n+LL |     /// also avoids the need to import `OpenOptions`.\n+   |                                                    ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// you can write `File::with_options().read(true).open(\"foo.txt\")`. This\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// also avoids the need to import `OpenOptions\\`.\n+   |                                                    +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:220:46\n+   |\n+LL |     /// `HybridBitSet`. Has no effect if `row` does not exist.\n+   |                                              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// Subtracts `set` from `row`. `set` can be either `BitSet` or\n+   |                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// `HybridBitSet`. Has no effect if `row\\` does not exist.\n+   |                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:246:12\n+   |\n+LL |     /// RWU`s can get very large, so it uses a more compact representation.\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL |     /// `RWU`s can get very large, so it uses a more compact representation.\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// RWU\\`s can get very large, so it uses a more compact representation.\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:253:15\n+   |\n+LL |     /// in `U2`.\n+   |               ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL |     /// `'?1` is in `U3` would be canonicalized to have `?0` in `U1` and `'?1`\n+   |                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// in `U2\\`.\n+   |               +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:270:42\n+   |\n+LL |     /// because it contains `[type error]`. Yuck! (See issue #29857 for\n+   |                                          ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0>` as\n+   |                                                              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// because it contains `[type error]\\`. Yuck! (See issue #29857 for\n+   |                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:280:53\n+   |\n+LL |     /// well as the second instance of `A: AutoTrait`) to suppress\n+   |                                                     ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// encountered a problem (later on) with `A:` AutoTrait. So we\n+   |                                                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// well as the second instance of `A: AutoTrait\\`) to suppress\n+   |                                                     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:290:40\n+   |\n+LL |     /// `'a` with `'b` and not `'static`. But it will have to do for\n+   |                                        ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// `'a` with `'b` and not `'static\\`. But it will have to do for\n+   |                                        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:299:54\n+   |\n+LL | /// `None`. Otherwise, it will return `Some(Dispatch)`.\n+   |                                                      ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// The `Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `None`. Otherwise, it will return `Some(Dispatch)\\`.\n+   |                                                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:303:13\n+   |\n+LL | /// or `None` if it isn't.\n+   |             ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or `None\\` if it isn't.\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:307:14\n+   |\n+LL | /// `on_event` should be called.\n+   |              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Called before the filtered [`Layer`]'s [`on_event`], to determine if\n+   |                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `on_event\\` should be called.\n+   |              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:312:29\n+   |\n+LL | /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+   |                             ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Therefore, if the `Filter` will change the value returned by this\n+   |                              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n+   |                             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: the opening backtick of a previous inline code may be missing\n+            change: The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+           to this: The `Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `None`. Otherwise, it will return `Some(Dispatch)`.\n+           to this: `None`. Otherwise, it will return `Some(Dispatch)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+   = help: if you meant to use a literal backtick, escape it\n+            change: or `None` if it isn't.\n+           to this: or `None\\` if it isn't.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Called before the filtered [`Layer]'s [`on_event`], to determine if\n+           to this: Called before the filtered [`Layer`]'s [`on_event`], to determine if\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `on_event` should be called.\n+           to this: `on_event\\` should be called.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Therefore, if the `Filter will change the value returned by this\n+           to this: Therefore, if the `Filter` will change the value returned by this\n+   = help: if you meant to use a literal backtick, escape it\n+            change: [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+           to this: [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:11:5\n+   |\n+LL | /// `\n+   |     ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:18:7\n+   |\n+LL | /// \\`\n+   |       ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `\\`\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\\\`\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:25:6\n+   |\n+LL | /// [`link1]\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`link1`]\n+   |            +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`link1]\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:29:11\n+   |\n+LL | /// [link2`]\n+   |           ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// [`link2`]\n+   |      +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [link2\\`]\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:33:6\n+   |\n+LL | /// [`link_long](link_long)\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`link_long`](link_long)\n+   |                +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`link_long](link_long)\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:37:6\n+   |\n+LL | /// [`broken-link]\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`broken-link`]\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`broken-link]\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:44:8\n+   |\n+LL | /// <x:`>\n+   |        ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `<x:`>\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// <x:\\`>\n+   |        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:54:6\n+   |\n+LL | /// \ud83e\udd80`\ud83e\udd80\n+   |       ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `\ud83e\udd80`\ud83e\udd80\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// \ud83e\udd80`\ud83e\udd80`\n+   |          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \ud83e\udd80\\`\ud83e\udd80\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:58:5\n+   |\n+LL | /// `foo(\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `foo(`\n+   |          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo(\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:64:14\n+   |\n+LL | /// `foo `bar`\n+   |              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// `foo` `bar`\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `foo `bar\\`\n+   |              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:70:5\n+   |\n+LL | /// `foo(\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// not paragraph`\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo(\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:75:83\n+   |\n+LL | /// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                               +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:79:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, b)`)!\n+   |                                                   ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                            +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, b)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:83:83\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:87:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:91:83\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                                          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:95:50\n+   |\n+LL | /// or even to add a number `n` to 42 (add(42, n)`)!\n+   |                                                  ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (add(42, n)\\`)!\n+   |                                                  +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:99:74\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+   |                                                                          ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                                                    +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as \\`add(b, a).\n+   |                                                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:103:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:107:1\n+   |\n+LL | #[doc = \"`\"]\n+   | ^^^^^^^^^^^^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `\n+           to this: \\`\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:114:1\n+   |\n+LL | #[doc = concat!(\"\\\\\", \"`\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of an inline code may be missing\n+            change: \\`\n+           to this: `\\`\n+   = help: if you meant to use a literal backtick, escape it\n+            change: \\`\n+           to this: \\\\`\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:118:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of a previous inline code may be missing\n+            change: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:122:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:126:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of an inline code may be missing\n+            change: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:130:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the closing backtick of an inline code may be missing\n+            change: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as \\`add(b, a).\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:135:5\n+   |\n+LL | /// `foo\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `foo`\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:139:7\n+   |\n+LL | /// # `(heading\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// # `(heading`\n+   |                +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// # \\`(heading\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:141:17\n+   |\n+LL | /// ## heading2)`\n+   |                 ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// ## `heading2)`\n+   |        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// ## heading2)\\`\n+   |                 +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:144:11\n+   |\n+LL | /// multi `(\n+   |           ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// )` heading\n+   |      +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// multi \\`(\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:150:10\n+   |\n+LL | /// para)`(graph\n+   |          ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `para)`(graph\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// para)`(graph`\n+   |                 +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// para)\\`(graph\n+   |          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:153:10\n+   |\n+LL | /// para)`(graph2\n+   |          ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `para)`(graph2\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// para)`(graph2`\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// para)\\`(graph2\n+   |          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:156:12\n+   |\n+LL | /// 1. foo)`\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// 1. `foo)`\n+   |        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// 1. foo)\\`\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:158:8\n+   |\n+LL | /// 2. `(bar\n+   |        ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// 2. `(bar`\n+   |             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// 2. \\`(bar\n+   |        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:160:11\n+   |\n+LL | /// * baz)`\n+   |           ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// * `baz)`\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// * baz)\\`\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:162:7\n+   |\n+LL | /// * `(quux\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// * `(quux`\n+   |             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// * \\`(quux\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:165:5\n+   |\n+LL | /// `#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `#`![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:168:62\n+   |\n+LL | /// #![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+   |                                                              ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `#![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// #![this_is_actually_an_image(and(not), an = \"attribute\")]\\`\n+   |                                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:173:7\n+   |\n+LL | /// | `table( | )head` |\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// | `table(` | )head` |\n+   |              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | \\`table( | )head` |\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:173:22\n+   |\n+LL | /// | `table( | )head` |\n+   |                      ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | `table( | `)head` |\n+   |                 +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | `table( | )head\\` |\n+   |                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:177:12\n+   |\n+LL | /// | table`( | )`body |\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | `table`( | )`body |\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | table\\`( | )`body |\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:177:18\n+   |\n+LL | /// | table`( | )`body |\n+   |                  ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | table`( | `)`body |\n+   |                 +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// | table`( | )`body` |\n+   |                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | table`( | )\\`body |\n+   |                  +\n+\n+error: aborting due to 63 previous errors\n+"}]}