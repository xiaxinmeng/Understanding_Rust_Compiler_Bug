{"sha": "584c79888b8e33f8b90ce95c9fc075954cdc9e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NGM3OTg4OGI4ZTMzZjhiOTBjZTk1YzlmYzA3NTk1NGNkYzllNDU=", "commit": {"author": {"name": "Charlie Fan", "email": "changchu@synopsys.com", "date": "2017-03-09T07:50:48Z"}, "committer": {"name": "f001", "email": "changchun.fan@qq.com", "date": "2017-03-11T13:08:18Z"}, "message": "Implement placement-in protocol for `HashMap`", "tree": {"sha": "77d1f15a675d863551dd70b9d8e06c5b2e29fba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77d1f15a675d863551dd70b9d8e06c5b2e29fba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584c79888b8e33f8b90ce95c9fc075954cdc9e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584c79888b8e33f8b90ce95c9fc075954cdc9e45", "html_url": "https://github.com/rust-lang/rust/commit/584c79888b8e33f8b90ce95c9fc075954cdc9e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584c79888b8e33f8b90ce95c9fc075954cdc9e45/comments", "author": null, "committer": {"login": "F001", "id": 3314340, "node_id": "MDQ6VXNlcjMzMTQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/3314340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/F001", "html_url": "https://github.com/F001", "followers_url": "https://api.github.com/users/F001/followers", "following_url": "https://api.github.com/users/F001/following{/other_user}", "gists_url": "https://api.github.com/users/F001/gists{/gist_id}", "starred_url": "https://api.github.com/users/F001/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/F001/subscriptions", "organizations_url": "https://api.github.com/users/F001/orgs", "repos_url": "https://api.github.com/users/F001/repos", "events_url": "https://api.github.com/users/F001/events{/privacy}", "received_events_url": "https://api.github.com/users/F001/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1727b2331740cb6fe684cf81b774e290eb875b6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1727b2331740cb6fe684cf81b774e290eb875b6e", "html_url": "https://github.com/rust-lang/rust/commit/1727b2331740cb6fe684cf81b774e290eb875b6e"}], "stats": {"total": 188, "additions": 183, "deletions": 5}, "files": [{"sha": "3ca8b41347a268c3ac3f65529ee09bf00506dd6c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 155, "deletions": 5, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=584c79888b8e33f8b90ce95c9fc075954cdc9e45", "patch": "@@ -19,8 +19,9 @@ use fmt::{self, Debug};\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n-use ops::{Deref, Index};\n+use ops::{Deref, Index, InPlace, Place, Placer};\n use rand::{self, Rng};\n+use ptr;\n \n use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n use super::table::BucketState::{Empty, Full};\n@@ -483,7 +484,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n-                                -> &'a mut V {\n+                                -> FullBucketMut<'a, K, V> {\n     let start_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -515,7 +516,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                     // bucket, which is a FullBucket on top of a\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n-                    return bucket.into_table().into_mut_refs().1;\n+                    return bucket.into_table();\n                 }\n                 Full(bucket) => bucket,\n             };\n@@ -1818,6 +1819,80 @@ impl<'a, K, V> fmt::Debug for Drain<'a, K, V>\n     }\n }\n \n+/// A place for insertion to a `Entry`.\n+///\n+/// See [`HashMap::entry`](struct.HashMap.html#method.entry) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+pub struct EntryPlace<'a, K: 'a, V: 'a> {\n+    bucket: FullBucketMut<'a, K, V>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for EntryPlace<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"EntryPlace\")\n+            .field(\"key\", self.bucket.read().0)\n+            .field(\"value\", self.bucket.read().1)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Drop for EntryPlace<'a, K, V> {\n+    fn drop(&mut self) {\n+        // Inplacement insertion failed. Only key need to drop.\n+        // The value is failed to insert into map.\n+        unsafe { self.bucket.remove_key() };\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Placer<V> for Entry<'a, K, V> {\n+    type Place = EntryPlace<'a, K, V>;\n+\n+    fn make_place(self) -> EntryPlace<'a, K, V> {\n+        let b = match self {\n+            Occupied(mut o) => {\n+                unsafe { ptr::drop_in_place(o.elem.read_mut().1); }\n+                o.elem\n+            }\n+            Vacant(v) => {\n+                unsafe { v.insert_key() }\n+            }\n+        };\n+        EntryPlace { bucket: b }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {\n+    fn pointer(&mut self) -> *mut V {\n+        self.bucket.read_mut().1\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, K, V> InPlace<V> for EntryPlace<'a, K, V> {\n+    type Owner = ();\n+\n+    unsafe fn finalize(self) {\n+        mem::forget(self);\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2108,7 +2183,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        match self.elem {\n+        let b = match self.elem {\n             NeqElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n@@ -2119,7 +2194,28 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n                 }\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n+                bucket.put(self.hash, self.key, value)\n+            },\n+        };\n+        b.into_mut_refs().1\n+    }\n+\n+    // Only used for InPlacement insert. Avoid unnecessary value copy.\n+    // The value remains uninitialized.\n+    unsafe fn insert_key(self) -> FullBucketMut<'a, K, V> {\n+        match self.elem {\n+            NeqElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                let uninit = mem::uninitialized();\n+                robin_hood(bucket, disp, self.hash, self.key, uninit)\n+            },\n+            NoElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                bucket.put_key(self.hash, self.key)\n             },\n         }\n     }\n@@ -2392,6 +2488,7 @@ mod test_map {\n     use super::RandomState;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n+    use panic;\n \n     #[test]\n     fn test_zero_capacities() {\n@@ -3265,4 +3362,57 @@ mod test_map {\n         }\n         panic!(\"Adaptive early resize failed\");\n     }\n+\n+    #[test]\n+    fn test_placement_in() {\n+        let mut map = HashMap::new();\n+        map.extend((0..10).map(|i| (i, i)));\n+\n+        map.entry(100) <- 100;\n+        assert_eq!(map[&100], 100);\n+\n+        map.entry(0) <- 10;\n+        assert_eq!(map[&0], 10);\n+\n+        assert_eq!(map.len(), 11);\n+    }\n+\n+    #[test]\n+    fn test_placement_panic() {\n+        let mut map = HashMap::new();\n+        map.extend((0..10).map(|i| (i, i)));\n+\n+        fn mkpanic() -> usize { panic!() }\n+\n+        // modify existing key\n+        // when panic happens, previous key is removed.\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(0) <- mkpanic(); }));\n+        assert_eq!(map.len(), 9);\n+        assert!(!map.contains_key(&0));\n+\n+        // add new key\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(100) <- mkpanic(); }));\n+        assert_eq!(map.len(), 9);\n+        assert!(!map.contains_key(&100));\n+    }\n+\n+    #[test]\n+    fn test_placement_drop() {\n+        // correctly drop\n+        struct TestV<'a>(&'a mut bool);\n+        impl<'a> Drop for TestV<'a> {\n+            fn drop(&mut self) {\n+                if !*self.0 { panic!(\"value double drop!\"); } // no double drop\n+                *self.0 = false;\n+            }\n+        }\n+\n+        fn makepanic<'a>() -> TestV<'a> { panic!() }\n+\n+        let mut can_drop = true;\n+        let mut hm = HashMap::new();\n+        hm.insert(0, TestV(&mut can_drop));\n+        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { hm.entry(0) <- makepanic(); }));\n+        assert_eq!(hm.len(), 0);\n+    }\n }"}, {"sha": "2c8bb433e8aef1ba1fd65a5d3948802be26293e8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=584c79888b8e33f8b90ce95c9fc075954cdc9e45", "patch": "@@ -506,6 +506,22 @@ impl<K, V, M> EmptyBucket<K, V, M>\n             table: self.table,\n         }\n     }\n+\n+    /// Puts given key, remain value uninitialized.\n+    /// It is only used for inplacement insertion.\n+    pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n+        *self.raw.hash = hash.inspect();\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        ptr::write(&mut (*pair_mut).0, key);\n+\n+        self.table.borrow_table_mut().size += 1;\n+\n+        FullBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self.table,\n+        }\n+    }\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n@@ -581,6 +597,17 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n             v)\n         }\n     }\n+\n+    /// Remove this bucket's `key` from the hashtable.\n+    /// Only used for inplacement insertion.\n+    /// NOTE: `Value` is uninitialized when this function is called, don't try to drop the `Value`.\n+    pub unsafe fn remove_key(&mut self) {\n+        self.table.size -= 1;\n+\n+        *self.raw.hash = EMPTY_BUCKET;\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        ptr::drop_in_place(&mut (*pair_mut).0); // only drop key\n+    }\n }\n \n // This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases"}, {"sha": "7fa5ad255609cc236a48c8f5248aac4a49412388", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584c79888b8e33f8b90ce95c9fc075954cdc9e45/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=584c79888b8e33f8b90ce95c9fc075954cdc9e45", "patch": "@@ -281,6 +281,7 @@\n #![feature(panic_unwind)]\n #![feature(peek)]\n #![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(prelude_import)]\n #![feature(pub_restricted)]\n #![feature(rand)]"}]}