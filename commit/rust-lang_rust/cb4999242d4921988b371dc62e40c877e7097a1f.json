{"sha": "cb4999242d4921988b371dc62e40c877e7097a1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDk5OTI0MmQ0OTIxOTg4YjM3MWRjNjJlNDBjODc3ZTcwOTdhMWY=", "commit": {"author": {"name": "jam1garner", "email": "8260240+jam1garner@users.noreply.github.com", "date": "2021-05-28T02:29:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-14T17:27:24Z"}, "message": "Fix `future_prelude_collision` lint breaking for pointer mutabilty coercion", "tree": {"sha": "c3b0a7f20e72b8f28aee132daf203ef739fbd988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b0a7f20e72b8f28aee132daf203ef739fbd988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb4999242d4921988b371dc62e40c877e7097a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4999242d4921988b371dc62e40c877e7097a1f", "html_url": "https://github.com/rust-lang/rust/commit/cb4999242d4921988b371dc62e40c877e7097a1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb4999242d4921988b371dc62e40c877e7097a1f/comments", "author": {"login": "jam1garner", "id": 8260240, "node_id": "MDQ6VXNlcjgyNjAyNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8260240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jam1garner", "html_url": "https://github.com/jam1garner", "followers_url": "https://api.github.com/users/jam1garner/followers", "following_url": "https://api.github.com/users/jam1garner/following{/other_user}", "gists_url": "https://api.github.com/users/jam1garner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jam1garner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jam1garner/subscriptions", "organizations_url": "https://api.github.com/users/jam1garner/orgs", "repos_url": "https://api.github.com/users/jam1garner/repos", "events_url": "https://api.github.com/users/jam1garner/events{/privacy}", "received_events_url": "https://api.github.com/users/jam1garner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c60f26bfe5a6ae07774fb9aa03f3cacd48bae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c60f26bfe5a6ae07774fb9aa03f3cacd48bae4", "html_url": "https://github.com/rust-lang/rust/commit/93c60f26bfe5a6ae07774fb9aa03f3cacd48bae4"}], "stats": {"total": 235, "additions": 144, "deletions": 91}, "files": [{"sha": "a1383fc4af0aef366158da8884a970413a498e08", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 109, "deletions": 84, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/cb4999242d4921988b371dc62e40c877e7097a1f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4999242d4921988b371dc62e40c877e7097a1f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=cb4999242d4921988b371dc62e40c877e7097a1f", "patch": "@@ -203,60 +203,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if span.edition() < Edition::Edition2021 {\n             if let sym::try_into = segment.ident.name {\n-                if let probe::PickKind::TraitPick = pick.kind {\n-                    if !matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core)\n-                    {\n-                        self.tcx.struct_span_lint_hir(\n-                            FUTURE_PRELUDE_COLLISION,\n-                            call_expr.hir_id,\n-                            call_expr.span,\n-                            |lint| {\n-                                let sp = call_expr.span;\n-                                let trait_name =\n-                                    self.tcx.def_path_str(pick.item.container.assert_trait());\n-\n-                                let mut lint = lint.build(&format!(\n-                                    \"trait method `{}` will become ambiguous in Rust 2021\",\n-                                    segment.ident.name\n-                                ));\n-\n-                                if let Ok(self_expr) =\n-                                    self.sess().source_map().span_to_snippet(self_expr.span)\n-                                {\n-                                    let derefs = \"*\".repeat(pick.autoderefs);\n-                                    let self_adjusted = match pick.autoref_or_ptr_adjustment {\n-                                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                                            mutbl: Mutability::Mut, ..\n-                                        }) => format!(\"&mut {}{}\", derefs, self_expr),\n-                                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                                            mutbl: Mutability::Not, ..\n-                                        }) => format!(\"&{}{}\", derefs, self_expr),\n-                                        Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None\n-                                            => format!(\"{}{}\", derefs, self_expr),\n+                if !matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+                    self.tcx.struct_span_lint_hir(\n+                        FUTURE_PRELUDE_COLLISION,\n+                        call_expr.hir_id,\n+                        call_expr.span,\n+                        |lint| {\n+                            let sp = call_expr.span;\n+                            let type_name = self.tcx.def_path_str(pick.item.container.id());\n+                            let type_generics = self.tcx.generics_of(pick.item.container.id());\n+                            let parameter_count =\n+                                type_generics.count() - (type_generics.has_self as usize);\n+                            let trait_name = if parameter_count == 0 {\n+                                type_name\n+                            } else {\n+                                format!(\n+                                    \"{}<{}>\",\n+                                    type_name,\n+                                    std::iter::repeat(\"_\")\n+                                        .take(parameter_count)\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \")\n+                                )\n+                            };\n+\n+                            let mut lint = lint.build(&format!(\n+                                \"trait method `{}` will become ambiguous in Rust 2021\",\n+                                segment.ident.name\n+                            ));\n+\n+                            if let Ok(self_expr) =\n+                                self.sess().source_map().span_to_snippet(self_expr.span)\n+                            {\n+                                let derefs = \"*\".repeat(pick.autoderefs);\n+\n+                                let autoref = match pick.autoref_or_ptr_adjustment {\n+                                    Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                                        mutbl: Mutability::Mut,\n+                                        ..\n+                                    }) => \"&mut \",\n+                                    Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                                        mutbl: Mutability::Not,\n+                                        ..\n+                                    }) => \"&\",\n+                                    Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n+                                };\n+                                let self_adjusted =\n+                                    if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                                        pick.autoref_or_ptr_adjustment\n+                                    {\n+                                        format!(\"{}{} as *const _\", derefs, self_expr)\n+                                    } else {\n+                                        format!(\"{}{}{}\", autoref, derefs, self_expr)\n                                     };\n-                                    lint.span_suggestion(\n-                                        sp,\n-                                        \"disambiguate the associated function\",\n-                                        format!(\n-                                            \"{}::{}({})\",\n-                                            trait_name, segment.ident.name, self_adjusted,\n-                                        ),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else {\n-                                    lint.span_help(\n-                                        sp,\n-                                        &format!(\n-                                            \"disambiguate the associated function with `{}::{}(...)`\",\n-                                            trait_name, segment.ident,\n-                                        ),\n-                                    );\n-                                }\n-\n-                                lint.emit();\n-                            },\n-                        );\n-                    }\n+                                lint.span_suggestion(\n+                                    sp,\n+                                    \"disambiguate the associated function\",\n+                                    format!(\n+                                        \"{}::{}({})\",\n+                                        trait_name, segment.ident.name, self_adjusted,\n+                                    ),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            } else {\n+                                lint.span_help(\n+                                    sp,\n+                                    &format!(\n+                                        \"disambiguate the associated function with `{}::{}(...)`\",\n+                                        trait_name, segment.ident,\n+                                    ),\n+                                );\n+                            }\n+\n+                            lint.emit();\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -541,38 +562,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if span.edition() < Edition::Edition2021 {\n             if let sym::try_into | sym::try_from | sym::from_iter = method_name.name {\n-                if let probe::PickKind::TraitPick = pick.kind {\n-                    if !matches!(tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n-                        tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n-                            let trait_def_id = pick.item.container.assert_trait();\n-                            let trait_generics = tcx.generics_of(trait_def_id);\n-                            let parameter_count = trait_generics.count() - (trait_generics.has_self as usize);\n-\n-                            let trait_name = if parameter_count == 0 {\n-                                tcx.def_path_str(trait_def_id)\n-                            } else {\n-                                format!(\n-                                    \"{}<{}>\",\n-                                    tcx.def_path_str(trait_def_id),\n-                                    std::iter::repeat(\"_\").take(parameter_count).collect::<Vec<_>>().join(\", \")\n-                                )\n-                            };\n-\n-                            let mut lint = lint.build(&format!(\n-                                \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n-                                method_name.name\n-                            ));\n-\n-                            lint.span_suggestion(\n-                                span,\n-                                \"disambiguate the associated function\",\n-                                format!(\"<{} as {}>::{}\", self_ty, trait_name, method_name.name,),\n-                                Applicability::MachineApplicable,\n-                            );\n+                if !matches!(tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+                    tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n+                        // \"type\" refers to either a type or, more likely, a trait from which\n+                        // the associated function or method is from.\n+                        let type_name = tcx.def_path_str(pick.item.container.id());\n+                        let type_generics = tcx.generics_of(pick.item.container.id());\n+\n+                        let parameter_count =\n+                            type_generics.count() - (type_generics.has_self as usize);\n+                        let trait_name = if parameter_count == 0 {\n+                            type_name\n+                        } else {\n+                            format!(\n+                                \"{}<{}>\",\n+                                type_name,\n+                                std::iter::repeat(\"_\")\n+                                    .take(parameter_count)\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \")\n+                            )\n+                        };\n+\n+                        let mut lint = lint.build(&format!(\n+                            \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n+                            method_name.name\n+                        ));\n+\n+                        lint.span_suggestion(\n+                            span,\n+                            \"disambiguate the associated function\",\n+                            format!(\"<{} as {}>::{}\", self_ty, trait_name, method_name.name,),\n+                            Applicability::MachineApplicable,\n+                        );\n \n-                            lint.emit();\n-                        });\n-                    }\n+                        lint.emit();\n+                    });\n                 }\n             }\n         }"}, {"sha": "2a0f74edc09ae626058c0809c5bb96d44b165641", "filename": "src/test/ui/lint/future-prelude-collision.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.fixed?ref=cb4999242d4921988b371dc62e40c877e7097a1f", "patch": "@@ -29,6 +29,12 @@ impl TryFromU8 for u32 {\n     }\n }\n \n+impl TryIntoU32 for *const u16 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(unsafe { *self } as u32)\n+    }\n+}\n+\n trait FromByteIterator {\n     fn from_iter<T>(iter: T) -> Self\n         where T: Iterator<Item = u8>;\n@@ -69,4 +75,9 @@ fn main() {\n     // test autoref\n     let _: u32 = TryIntoU32::try_into(&3.0).unwrap();\n     //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+\n+    let mut data = 3u16;\n+    let mut_ptr = std::ptr::addr_of_mut!(data);\n+    let _: u32 = TryIntoU32::try_into(mut_ptr as *const _).unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n }"}, {"sha": "9a38bc065bf6976e0a1359947fa4ce07a8386bfb", "filename": "src/test/ui/lint/future-prelude-collision.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.rs?ref=cb4999242d4921988b371dc62e40c877e7097a1f", "patch": "@@ -29,6 +29,12 @@ impl TryFromU8 for u32 {\n     }\n }\n \n+impl TryIntoU32 for *const u16 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(unsafe { *self } as u32)\n+    }\n+}\n+\n trait FromByteIterator {\n     fn from_iter<T>(iter: T) -> Self\n         where T: Iterator<Item = u8>;\n@@ -69,4 +75,9 @@ fn main() {\n     // test autoref\n     let _: u32 = 3.0.try_into().unwrap();\n     //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+\n+    let mut data = 3u16;\n+    let mut_ptr = std::ptr::addr_of_mut!(data);\n+    let _: u32 = mut_ptr.try_into().unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n }"}, {"sha": "13c8b8afddfb4d68e3041f083814a0d228aec5aa", "filename": "src/test/ui/lint/future-prelude-collision.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb4999242d4921988b371dc62e40c877e7097a1f/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffuture-prelude-collision.stderr?ref=cb4999242d4921988b371dc62e40c877e7097a1f", "patch": "@@ -1,40 +1,46 @@\n warning: trait method `try_into` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:47:18\n+  --> $DIR/future-prelude-collision.rs:53:18\n    |\n LL |     let _: u32 = 3u8.try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(3u8)`\n    |\n    = note: `#[warn(future_prelude_collision)]` on by default\n \n warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:51:13\n+  --> $DIR/future-prelude-collision.rs:57:13\n    |\n LL |     let _ = u32::try_from(3u8).unwrap();\n    |             ^^^^^^^^^^^^^ help: disambiguate the associated function: `<u32 as TryFromU8>::try_from`\n \n warning: trait-associated function `from_iter` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:55:13\n+  --> $DIR/future-prelude-collision.rs:61:13\n    |\n LL |     let _ = <Vec<u8>>::from_iter(vec![1u8, 2, 3, 4, 5, 6].into_iter());\n    |             ^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `<Vec<u8> as FromByteIterator>::from_iter`\n \n warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:62:18\n+  --> $DIR/future-prelude-collision.rs:68:18\n    |\n LL |     let _: u32 = <_>::try_from(3u8).unwrap();\n    |                  ^^^^^^^^^^^^^ help: disambiguate the associated function: `<_ as TryFromU8>::try_from`\n \n warning: trait method `try_into` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:66:18\n+  --> $DIR/future-prelude-collision.rs:72:18\n    |\n LL |     let _: u32 = (&3u8).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(*(&3u8))`\n \n warning: trait method `try_into` will become ambiguous in Rust 2021\n-  --> $DIR/future-prelude-collision.rs:70:18\n+  --> $DIR/future-prelude-collision.rs:76:18\n    |\n LL |     let _: u32 = 3.0.try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(&3.0)`\n \n-warning: 6 warnings emitted\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:81:18\n+   |\n+LL |     let _: u32 = mut_ptr.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(mut_ptr as *const _)`\n+\n+warning: 7 warnings emitted\n "}]}