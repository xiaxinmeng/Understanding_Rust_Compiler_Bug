{"sha": "2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNjk2YjljOWViMjA2ZjY5NTU2ZDdmOTMzYzVhN2JhZjVhZTNjNzc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-22T17:38:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-22T17:38:49Z"}, "message": "Move out record completion tests", "tree": {"sha": "4c253c3b47f3622f36321492d87c27de351c5a40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c253c3b47f3622f36321492d87c27de351c5a40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "html_url": "https://github.com/rust-lang/rust/commit/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444679f202742c8fd00e9d1c7fddfaa9a067e640", "url": "https://api.github.com/repos/rust-lang/rust/commits/444679f202742c8fd00e9d1c7fddfaa9a067e640", "html_url": "https://github.com/rust-lang/rust/commit/444679f202742c8fd00e9d1c7fddfaa9a067e640"}], "stats": {"total": 555, "additions": 233, "deletions": 322}, "files": [{"sha": "c7b8ba3d144ce8dedf9a6435ef90c7a8d9523172", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "patch": "@@ -44,325 +44,3 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n     Some(())\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    fn check_snippet(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_default() {\n-        let test_code = r#\"\n-//- minicore: default\n-struct S { foo: u32, bar: usize }\n-\n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n-}\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        .$0\n-    };\n-}\n-\"#;\n-        check(\n-            test_code,\n-            expect![[r#\"\n-                fd bar usize\n-            \"#]],\n-        );\n-\n-        check_snippet(\n-            test_code,\n-            expect![[r#\"\n-                fd ..Default::default()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_default_completion() {\n-        check_edit(\n-            \"..Default::default()\",\n-            r#\"\n-//- minicore: default\n-struct S { foo: u32, bar: usize }\n-\n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n-}\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        .$0\n-    };\n-}\n-\"#,\n-            r#\"\n-struct S { foo: u32, bar: usize }\n-\n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n-}\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        ..Default::default()\n-    };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_without_default() {\n-        let test_code = r#\"\n-struct S { foo: u32, bar: usize }\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        .$0\n-    };\n-}\n-\"#;\n-        check(\n-            test_code,\n-            expect![[r#\"\n-                fd bar usize\n-            \"#]],\n-        );\n-\n-        check_snippet(test_code, expect![[r#\"\"#]]);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field() {\n-        check(\n-            r#\"\n-struct S { foo: u32 }\n-\n-fn process(f: S) {\n-    match f {\n-        S { f$0: 92 } => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd foo u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_enum_variant() {\n-        check(\n-            r#\"\n-enum E { S { foo: u32, bar: () } }\n-\n-fn process(e: E) {\n-    match e {\n-        E::S { $0 } => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd foo u32\n-                fd bar ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field_in_simple_macro() {\n-        check(\n-            r\"\n-macro_rules! m { ($e:expr) => { $e } }\n-struct S { foo: u32 }\n-\n-fn process(f: S) {\n-    m!(match f {\n-        S { f$0: 92 } => (),\n-    })\n-}\n-\",\n-            expect![[r#\"\n-                fd foo u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed_in_destruct_pats() {\n-        check(\n-            r#\"\n-struct S {\n-    foo1: u32, foo2: u32,\n-    bar: u32, baz: u32,\n-}\n-\n-fn main() {\n-    let s = S {\n-        foo1: 1, foo2: 2,\n-        bar: 3, baz: 4,\n-    };\n-    if let S { foo1, foo2: a, $0 } = s {}\n-}\n-\"#,\n-            expect![[r#\"\n-                fd bar u32\n-                fd baz u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field() {\n-        check(\n-            r#\"\n-struct A { the_field: u32 }\n-fn foo() {\n-   A { the$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd the_field u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_enum_variant() {\n-        check(\n-            r#\"\n-enum E { A { a: u32 } }\n-fn foo() {\n-    let _ = E::A { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd a u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_two_structs() {\n-        check(\n-            r#\"\n-struct A { a: u32 }\n-struct B { b: u32 }\n-\n-fn foo() {\n-   let _: A = B { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd b u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_generic_struct() {\n-        check(\n-            r#\"\n-struct A<T> { a: T }\n-\n-fn foo() {\n-   let _: A<u32> = A { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd a u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_in_simple_macro() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-struct A { the_field: u32 }\n-fn foo() {\n-   m!(A { the$0 })\n-}\n-\"#,\n-            expect![[r#\"\n-                fd the_field u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed() {\n-        check(\n-            r#\"\n-struct S {\n-    foo1: u32, foo2: u32,\n-    bar: u32, baz: u32,\n-}\n-\n-fn main() {\n-    let foo1 = 1;\n-    let s = S { foo1, foo2: 5, $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd bar u32\n-                fd baz u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_functional_update() {\n-        check(\n-            r#\"\n-struct S { foo1: u32, foo2: u32 }\n-\n-fn main() {\n-    let foo1 = 1;\n-    let s = S { foo1, $0 .. loop {} }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd foo2 u32\n-            \"#]],\n-        );\n-    }\n-}"}, {"sha": "1eec2c113e3cd87c66c1dbea15f27121a8b6a249", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "patch": "@@ -10,6 +10,7 @@ mod item_list;\n mod item;\n mod pattern;\n mod predicate;\n+mod record;\n mod sourcegen;\n mod type_pos;\n mod use_tree;"}, {"sha": "fa5f3fe46e0548d5f740e070250c56090f913720", "filename": "crates/ide_completion/src/tests/record.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d696b9c9eb206f69556d7f933c5a7baf5ae3c77/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=2d696b9c9eb206f69556d7f933c5a7baf5ae3c77", "patch": "@@ -0,0 +1,232 @@\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{check_edit, completion_list};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn with_default_impl() {\n+    check(\n+        r#\"\n+//- minicore: default\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {\n+        Struct {\n+            foo: 0,\n+            bar: 0,\n+        }\n+    }\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fd ..Default::default()\n+            fd bar                  usize\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn without_default_impl() {\n+    check(\n+        r#\"\n+struct Struct { foo: u32, bar: usize }\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar usize\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_pattern_field() {\n+    check(\n+        r#\"\n+struct Struct { foo: u32, bar: u32 }\n+\n+fn foo(s: Struct) {\n+    match s {\n+        Struct { foo, $0: 92 } => (),\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pattern_enum_variant() {\n+    check(\n+        r#\"\n+enum Enum { Variant { foo: u32, bar: u32 } }\n+fn foo(e: Enum) {\n+    match e {\n+        Enum::Variant { foo, $0 } => (),\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_literal_field_in_macro() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct Struct { field: u32 }\n+fn foo() {\n+    m!(Struct { fie$0 })\n+}\n+\"#,\n+        expect![[r#\"\n+            fd field u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_pattern_field_in_macro() {\n+    check(\n+        r\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct Struct { field: u32 }\n+\n+fn foo(f: Struct) {\n+    m!(match f {\n+        Struct { f$0: 92 } => (),\n+    })\n+}\n+\",\n+        expect![[r#\"\n+            fd field u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn functional_update() {\n+    // FIXME: This should filter out all completions that do not have the type `Foo`\n+    check(\n+        r#\"\n+struct Foo { foo1: u32, foo2: u32 }\n+\n+fn main() {\n+    let thing = 1;\n+    let foo = Foo { foo1: 0, foo2: 0 };\n+    let foo2 = Foo { thing, ..$0 }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc foo       Foo\n+            lc thing     i32\n+            st Foo\n+            fn main()    fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn default_completion_edit() {\n+    check_edit(\n+        \"..Default::default()\",\n+        r#\"\n+//- minicore: default\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {}\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        .$0\n+    };\n+}\n+\"#,\n+        r#\"\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {}\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        ..Default::default()\n+    };\n+}\n+\"#,\n+    );\n+    check_edit(\n+        \"..Default::default()\",\n+        r#\"\n+//- minicore: default\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {}\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n+}\n+\"#,\n+        r#\"\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {}\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        ..Default::default()\n+    };\n+}\n+\"#,\n+    );\n+}"}]}