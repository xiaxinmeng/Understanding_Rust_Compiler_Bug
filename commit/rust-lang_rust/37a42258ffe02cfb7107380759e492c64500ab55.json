{"sha": "37a42258ffe02cfb7107380759e492c64500ab55", "node_id": "C_kwDOAAsO6NoAKDM3YTQyMjU4ZmZlMDJjZmI3MTA3MzgwNzU5ZTQ5MmM2NDUwMGFiNTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-12T00:47:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-12T00:47:54Z"}, "message": "Auto merge of #97778 - compiler-errors:misc-diagnostics-tidy, r=cjgillot\n\nTidy up miscellaneous bounds suggestions\n\nJust some small fixes to suggestions\n\n- Generalizes `Ty::is_suggestable` into a `TypeVisitor`, so that it can be called on things other than `Ty`\n- Makes `impl Trait` in arg position no longer suggestible (generalizing the fix in #97640)\n- Fixes `impl Trait` not being replaced with fresh type param when it's deeply nested in function signature (fixes #97760)\n- Fixes some poor handling of `where` clauses with no predicates (also #97760)\n- Uses `InferCtxt::resolve_numeric_literals_with_default` so we suggest `i32` instead of `{integer}` (fixes #97677)\n\nSorry there aren't many tests the fixes. Most of them would just be duplicates of other tests with empty `where` clauses or `impl Trait` in arg position instead of generic params. Let me know if you'd want more test coverage.", "tree": {"sha": "8ed8b58ef18bc8200c18fcc299010e9bb12b0832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ed8b58ef18bc8200c18fcc299010e9bb12b0832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a42258ffe02cfb7107380759e492c64500ab55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a42258ffe02cfb7107380759e492c64500ab55", "html_url": "https://github.com/rust-lang/rust/commit/37a42258ffe02cfb7107380759e492c64500ab55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a42258ffe02cfb7107380759e492c64500ab55/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e652caa679a304af11fc04f1f12452f255a82593", "url": "https://api.github.com/repos/rust-lang/rust/commits/e652caa679a304af11fc04f1f12452f255a82593", "html_url": "https://github.com/rust-lang/rust/commit/e652caa679a304af11fc04f1f12452f255a82593"}, {"sha": "5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01", "html_url": "https://github.com/rust-lang/rust/commit/5f7474e6dc9ad8ddc802606c1a538b4f567cbc01"}], "stats": {"total": 574, "additions": 363, "deletions": 211}, "files": [{"sha": "4244e67482cad5a0311cd75ec78bb0bdf54f9e3d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -1377,7 +1377,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n             self.lower_generic_params_mut(&generics.params).collect();\n-        let has_where_clause = !generics.where_clause.predicates.is_empty();\n+        let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n         let where_clause_span = self.lower_span(generics.where_clause.span);\n         let span = self.lower_span(generics.span);\n         let res = f(self);\n@@ -1395,7 +1395,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let lowered_generics = self.arena.alloc(hir::Generics {\n             params: self.arena.alloc_from_iter(params),\n             predicates: self.arena.alloc_from_iter(predicates),\n-            has_where_clause,\n+            has_where_clause_predicates,\n             where_clause_span,\n             span,\n         });"}, {"sha": "6fe95a21fa42af80ef5173f6468b49524c241bd7", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -1315,7 +1315,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generics: self.arena.alloc(hir::Generics {\n                     params: lifetime_defs,\n                     predicates: &[],\n-                    has_where_clause: false,\n+                    has_where_clause_predicates: false,\n                     where_clause_span: lctx.lower_span(span),\n                     span: lctx.lower_span(span),\n                 }),\n@@ -1637,7 +1637,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generics: this.arena.alloc(hir::Generics {\n                     params: generic_params,\n                     predicates: &[],\n-                    has_where_clause: false,\n+                    has_where_clause_predicates: false,\n                     where_clause_span: this.lower_span(span),\n                     span: this.lower_span(span),\n                 }),"}, {"sha": "bd5973f31cfae769b9aa09591e0c822ba884a999", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -535,7 +535,7 @@ pub struct GenericParamCount {\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub predicates: &'hir [WherePredicate<'hir>],\n-    pub has_where_clause: bool,\n+    pub has_where_clause_predicates: bool,\n     pub where_clause_span: Span,\n     pub span: Span,\n }\n@@ -545,7 +545,7 @@ impl<'hir> Generics<'hir> {\n         const NOPE: Generics<'_> = Generics {\n             params: &[],\n             predicates: &[],\n-            has_where_clause: false,\n+            has_where_clause_predicates: false,\n             where_clause_span: DUMMY_SP,\n             span: DUMMY_SP,\n         };\n@@ -581,21 +581,11 @@ impl<'hir> Generics<'hir> {\n         }\n     }\n \n-    pub fn where_clause_span(&self) -> Option<Span> {\n-        if self.predicates.is_empty() { None } else { Some(self.where_clause_span) }\n-    }\n-\n-    /// The `where_span` under normal circumstances points at either the predicates or the empty\n-    /// space where the `where` clause should be. Only of use for diagnostic suggestions.\n-    pub fn span_for_predicates_or_empty_place(&self) -> Span {\n-        self.where_clause_span\n-    }\n-\n     /// `Span` where further predicates would be suggested, accounting for trailing commas, like\n     ///  in `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n     pub fn tail_span_for_predicate_suggestion(&self) -> Span {\n-        let end = self.span_for_predicates_or_empty_place().shrink_to_hi();\n-        if self.has_where_clause {\n+        let end = self.where_clause_span.shrink_to_hi();\n+        if self.has_where_clause_predicates {\n             self.predicates\n                 .iter()\n                 .filter(|p| p.in_where_clause())\n@@ -608,6 +598,17 @@ impl<'hir> Generics<'hir> {\n         }\n     }\n \n+    pub fn add_where_or_trailing_comma(&self) -> &'static str {\n+        if self.has_where_clause_predicates {\n+            \",\"\n+        } else if self.where_clause_span.is_empty() {\n+            \" where\"\n+        } else {\n+            // No where clause predicates, but we have `where` token\n+            \"\"\n+        }\n+    }\n+\n     pub fn bounds_for_param(\n         &self,\n         param_def_id: LocalDefId,"}, {"sha": "ebca8bccefc712cb8f1d50f5c8a9c2f617cd8b73", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -2509,11 +2509,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     labeled_user_string\n                 );\n                 let pred = format!(\"{}: {}\", bound_kind, sub);\n-                let suggestion = format!(\n-                    \"{} {}\",\n-                    if !generics.predicates.is_empty() { \",\" } else { \" where\" },\n-                    pred,\n-                );\n+                let suggestion = format!(\"{} {}\", generics.add_where_or_trailing_comma(), pred,);\n                 err.span_suggestion(\n                     generics.tail_span_for_predicate_suggestion(),\n                     \"consider adding a where clause\","}, {"sha": "67bbace39e3ca7392f7fa5cbf041771f2aa3022e", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -367,17 +367,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .collect();\n \n                 if !clauses.is_empty() {\n-                    let where_clause_span = self\n-                        .tcx\n-                        .hir()\n-                        .get_generics(impl_item_def_id)\n-                        .unwrap()\n-                        .where_clause_span\n-                        .shrink_to_hi();\n+                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n+                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n \n                     let suggestion = format!(\n                         \"{} {}\",\n-                        if !impl_predicates.is_empty() { \",\" } else { \" where\" },\n+                        generics.add_where_or_trailing_comma(),\n                         clauses.join(\", \"),\n                     );\n                     err.span_suggestion("}, {"sha": "205ca72aae8a86304dadcf4afcd3b7c843379ed4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -2293,10 +2293,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             // If all predicates are inferable, drop the entire clause\n             // (including the `where`)\n-            if hir_generics.has_where_clause && dropped_predicate_count == num_predicates {\n-                let where_span = hir_generics\n-                    .where_clause_span()\n-                    .expect(\"span of (nonempty) where clause should exist\");\n+            if hir_generics.has_where_clause_predicates && dropped_predicate_count == num_predicates\n+            {\n+                let where_span = hir_generics.where_clause_span;\n                 // Extend the where clause back to the closing `>` of the\n                 // generics, except for tuple struct, which have the `where`\n                 // after the fields of the struct."}, {"sha": "1acded8c6e499e7001d23b3d14d4ed055587c5ee", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 113, "deletions": 85, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -1,9 +1,10 @@\n //! Diagnostics related methods for `Ty`.\n \n-use crate::ty::subst::{GenericArg, GenericArgKind};\n+use std::ops::ControlFlow;\n+\n use crate::ty::{\n-    ConstKind, DefIdTree, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef,\n-    InferTy, ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n+    fold::TypeFoldable, Const, ConstKind, DefIdTree, ExistentialPredicate, InferTy,\n+    PolyTraitPredicate, Ty, TyCtxt, TypeSuperFoldable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -72,103 +73,55 @@ impl<'tcx> Ty<'tcx> {\n             _ => self.is_simple_ty(),\n         }\n     }\n+}\n \n-    /// Whether the type can be safely suggested during error recovery.\n-    pub fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool {\n-        fn generic_arg_is_suggestible<'tcx>(arg: GenericArg<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n-            match arg.unpack() {\n-                GenericArgKind::Type(ty) => ty.is_suggestable(tcx),\n-                GenericArgKind::Const(c) => const_is_suggestable(c.val()),\n-                _ => true,\n-            }\n-        }\n-\n-        fn const_is_suggestable(kind: ConstKind<'_>) -> bool {\n-            match kind {\n-                ConstKind::Infer(..)\n-                | ConstKind::Bound(..)\n-                | ConstKind::Placeholder(..)\n-                | ConstKind::Error(..) => false,\n-                _ => true,\n-            }\n-        }\n-\n-        // FIXME(compiler-errors): Some types are still not good to suggest,\n-        // specifically references with lifetimes within the function. Not\n-        //sure we have enough information to resolve whether a region is\n-        // temporary, so I'll leave this as a fixme.\n+pub trait IsSuggestable<'tcx> {\n+    /// Whether this makes sense to suggest in a diagnostic.\n+    ///\n+    /// We filter out certain types and constants since they don't provide\n+    /// meaningful rendered suggestions when pretty-printed. We leave some\n+    /// nonsense, such as region vars, since those render as `'_` and are\n+    /// usually okay to reinterpret as elided lifetimes.\n+    fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool;\n+}\n \n-        match self.kind() {\n-            FnDef(..)\n-            | Closure(..)\n-            | Infer(..)\n-            | Generator(..)\n-            | GeneratorWitness(..)\n-            | Bound(_, _)\n-            | Placeholder(_)\n-            | Error(_) => false,\n-            Opaque(did, substs) => {\n-                let parent = tcx.parent(*did);\n-                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = tcx.def_kind(parent)\n-                    && let Opaque(parent_did, _) = tcx.type_of(parent).kind()\n-                    && parent_did == did\n-                {\n-                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                } else {\n-                    false\n-                }\n-            }\n-            Dynamic(dty, _) => dty.iter().all(|pred| match pred.skip_binder() {\n-                ExistentialPredicate::Trait(ExistentialTraitRef { substs, .. }) => {\n-                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                }\n-                ExistentialPredicate::Projection(ExistentialProjection {\n-                    substs, term, ..\n-                }) => {\n-                    let term_is_suggestable = match term {\n-                        Term::Ty(ty) => ty.is_suggestable(tcx),\n-                        Term::Const(c) => const_is_suggestable(c.val()),\n-                    };\n-                    term_is_suggestable && substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                }\n-                _ => true,\n-            }),\n-            Projection(ProjectionTy { substs: args, .. }) | Adt(_, args) => {\n-                args.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-            }\n-            Tuple(args) => args.iter().all(|ty| ty.is_suggestable(tcx)),\n-            Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(tcx),\n-            Array(ty, c) => ty.is_suggestable(tcx) && const_is_suggestable(c.val()),\n-            _ => true,\n-        }\n+impl<'tcx, T> IsSuggestable<'tcx> for T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.visit_with(&mut IsSuggestableVisitor { tcx }).is_continue()\n     }\n }\n \n-pub fn suggest_arbitrary_trait_bound(\n+pub fn suggest_arbitrary_trait_bound<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n-    param_name: &str,\n-    constraint: &str,\n+    trait_pred: PolyTraitPredicate<'tcx>,\n ) -> bool {\n+    if !trait_pred.is_suggestable(tcx) {\n+        return false;\n+    }\n+\n+    let param_name = trait_pred.skip_binder().self_ty().to_string();\n+    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n     let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n-    match (param, param_name) {\n-        (Some(_), \"Self\") => return false,\n-        _ => {}\n+\n+    // Skip, there is a param named Self\n+    if param.is_some() && param_name == \"Self\" {\n+        return false;\n     }\n+\n     // Suggest a where clause bound for a non-type parameter.\n-    let (action, prefix) = if generics.has_where_clause {\n-        (\"extending the\", \", \")\n-    } else {\n-        (\"introducing a\", \" where \")\n-    };\n     err.span_suggestion_verbose(\n         generics.tail_span_for_predicate_suggestion(),\n         &format!(\n-            \"consider {} `where` bound, but there might be an alternative better way to express \\\n+            \"consider {} `where` clause, but there might be an alternative better way to express \\\n              this requirement\",\n-            action,\n+            if generics.where_clause_span.is_empty() { \"introducing a\" } else { \"extending the\" },\n         ),\n-        format!(\"{}{}: {}\", prefix, param_name, constraint),\n+        format!(\"{} {}: {}\", generics.add_where_or_trailing_comma(), param_name, constraint),\n         Applicability::MaybeIncorrect,\n     );\n     true\n@@ -321,7 +274,7 @@ pub fn suggest_constraining_type_params<'a>(\n             continue;\n         }\n \n-        if generics.has_where_clause {\n+        if generics.has_where_clause_predicates {\n             // This part is a bit tricky, because using the `where` clause user can\n             // provide zero, one or many bounds for the same type parameter, so we\n             // have following cases to consider:\n@@ -463,3 +416,78 @@ impl<'v> hir::intravisit::Visitor<'v> for StaticLifetimeVisitor<'v> {\n         }\n     }\n }\n+\n+pub struct IsSuggestableVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match t.kind() {\n+            FnDef(..)\n+            | Closure(..)\n+            | Infer(..)\n+            | Generator(..)\n+            | GeneratorWitness(..)\n+            | Bound(_, _)\n+            | Placeholder(_)\n+            | Error(_) => {\n+                return ControlFlow::Break(());\n+            }\n+\n+            Opaque(did, _) => {\n+                let parent = self.tcx.parent(*did);\n+                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n+                    && let Opaque(parent_did, _) = self.tcx.type_of(parent).kind()\n+                    && parent_did == did\n+                {\n+                    // Okay\n+                } else {\n+                    return ControlFlow::Break(());\n+                }\n+            }\n+\n+            Dynamic(dty, _) => {\n+                for pred in *dty {\n+                    match pred.skip_binder() {\n+                        ExistentialPredicate::Trait(_) | ExistentialPredicate::Projection(_) => {\n+                            // Okay\n+                        }\n+                        _ => return ControlFlow::Break(()),\n+                    }\n+                }\n+            }\n+\n+            Param(param) => {\n+                // FIXME: It would be nice to make this not use string manipulation,\n+                // but it's pretty hard to do this, since `ty::ParamTy` is missing\n+                // sufficient info to determine if it is synthetic, and we don't\n+                // always have a convenient way of getting `ty::Generics` at the call\n+                // sites we invoke `IsSuggestable::is_suggestable`.\n+                if param.name.as_str().starts_with(\"impl \") {\n+                    return ControlFlow::Break(());\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val() {\n+            ConstKind::Infer(..)\n+            | ConstKind::Bound(..)\n+            | ConstKind::Placeholder(..)\n+            | ConstKind::Error(..) => {\n+                return ControlFlow::Break(());\n+            }\n+            _ => {}\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+}"}, {"sha": "84547dca45363c696552f58fb06927758959744d", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -39,6 +39,13 @@ impl GenericParamDefKind {\n             GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => true,\n         }\n     }\n+\n+    pub fn is_synthetic(&self) -> bool {\n+        match self {\n+            GenericParamDefKind::Type { synthetic, .. } => *synthetic,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "353547a2fb8cb59b39a7d27a1690de6fcb56a2c9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 117, "deletions": 58, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -7,6 +7,7 @@ use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::normalize_to;\n \n+use hir::HirId;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n@@ -21,11 +22,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n-    self,\n-    subst::{GenericArgKind, SubstsRef},\n-    suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, ToPredicate, Ty, TyCtxt,\n-    TypeFoldable,\n+    self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n+    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -324,7 +323,7 @@ pub trait InferCtxtExt<'tcx> {\n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n     (\n         generics.tail_span_for_predicate_suggestion(),\n-        format!(\"{} {}\", if generics.has_where_clause { \",\" } else { \" where\" }, pred,),\n+        format!(\"{} {}\", generics.add_where_or_trailing_comma(), pred),\n     )\n }\n \n@@ -333,35 +332,53 @@ fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, St\n /// param for cleaner code.\n fn suggest_restriction<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    generics: &hir::Generics<'tcx>,\n+    hir_id: HirId,\n+    hir_generics: &hir::Generics<'tcx>,\n     msg: &str,\n     err: &mut Diagnostic,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n     trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n-) {\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n     // Given `trait T: A + B + C {}`\n     //              -  ^^^^^^^^^ GenericBounds\n     //              |\n     //              &Ident\n-    let span = generics.span_for_predicates_or_empty_place();\n-    if span.from_expansion() || span.desugaring_kind().is_some() {\n+    super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n+) {\n+    if hir_generics.where_clause_span.from_expansion()\n+        || hir_generics.where_clause_span.desugaring_kind().is_some()\n+    {\n         return;\n     }\n+    let Some(item_id) = hir_id.as_owner() else { return; };\n+    let generics = tcx.generics_of(item_id);\n     // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n-    if let Some((bound_str, fn_sig)) =\n+    if let Some((param, bound_str, fn_sig)) =\n         fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind() {\n             // Shenanigans to get the `Trait` from the `impl Trait`.\n             ty::Param(param) => {\n-                // `fn foo(t: impl Trait)`\n-                //                 ^^^^^ get this string\n-                param.name.as_str().strip_prefix(\"impl\").map(|s| (s.trim_start().to_string(), sig))\n+                let param_def = generics.type_param(param, tcx);\n+                if param_def.kind.is_synthetic() {\n+                    let bound_str =\n+                        param_def.name.as_str().strip_prefix(\"impl \")?.trim_start().to_string();\n+                    return Some((param_def, bound_str, sig));\n+                }\n+                None\n             }\n             _ => None,\n         })\n     {\n+        let type_param_name = hir_generics.params.next_type_param_name(Some(&bound_str));\n+        let trait_pred = trait_pred.fold_with(&mut ReplaceImplTraitFolder {\n+            tcx,\n+            param,\n+            replace_ty: ty::ParamTy::new(generics.count() as u32, Symbol::intern(&type_param_name))\n+                .to_ty(tcx),\n+        });\n+        if !trait_pred.is_suggestable(tcx) {\n+            return;\n+        }\n         // We know we have an `impl Trait` that doesn't satisfy a required projection.\n \n         // Find all of the occurrences of `impl Trait` for `Trait` in the function arguments'\n@@ -370,40 +387,22 @@ fn suggest_restriction<'tcx>(\n         // but instead we choose to suggest replacing all instances of `impl Trait` with `T`\n         // where `T: Trait`.\n         let mut ty_spans = vec![];\n-        let impl_trait_str = format!(\"impl {}\", bound_str);\n         for input in fn_sig.decl.inputs {\n-            if let hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                hir::Path { segments: [segment], .. },\n-            )) = input.kind\n-            {\n-                if segment.ident.as_str() == impl_trait_str.as_str() {\n-                    // `fn foo(t: impl Trait)`\n-                    //            ^^^^^^^^^^ get this to suggest `T` instead\n-\n-                    // There might be more than one `impl Trait`.\n-                    ty_spans.push(input.span);\n-                }\n-            }\n+            ReplaceImplTraitVisitor { ty_spans: &mut ty_spans, param_did: param.def_id }\n+                .visit_ty(input);\n         }\n-\n-        let type_param_name = generics.params.next_type_param_name(Some(&bound_str));\n         // The type param `T: Trait` we will suggest to introduce.\n         let type_param = format!(\"{}: {}\", type_param_name, bound_str);\n \n-        // FIXME: modify the `trait_pred` instead of string shenanigans.\n-        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_pred.to_predicate(tcx).to_string();\n-        let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n-            if let Some(span) = generics.span_for_param_suggestion() {\n+            if let Some(span) = hir_generics.span_for_param_suggestion() {\n                 (span, format!(\", {}\", type_param))\n             } else {\n-                (generics.span, format!(\"<{}>\", type_param))\n+                (hir_generics.span, format!(\"<{}>\", type_param))\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`\n-            predicate_constraint(generics, pred),\n+            predicate_constraint(hir_generics, trait_pred.to_predicate(tcx).to_string()),\n         ];\n         sugg.extend(ty_spans.into_iter().map(|s| (s, type_param_name.to_string())));\n \n@@ -416,15 +415,20 @@ fn suggest_restriction<'tcx>(\n             Applicability::MaybeIncorrect,\n         );\n     } else {\n+        if !trait_pred.is_suggestable(tcx) {\n+            return;\n+        }\n         // Trivial case: `T` needs an extra bound: `T: Bound`.\n         let (sp, suggestion) = match (\n-            generics\n+            hir_generics\n                 .params\n                 .iter()\n                 .find(|p| !matches!(p.kind, hir::GenericParamKind::Type { synthetic: true, .. })),\n             super_traits,\n         ) {\n-            (_, None) => predicate_constraint(generics, trait_pred.to_predicate(tcx).to_string()),\n+            (_, None) => {\n+                predicate_constraint(hir_generics, trait_pred.to_predicate(tcx).to_string())\n+            }\n             (None, Some((ident, []))) => (\n                 ident.span.shrink_to_hi(),\n                 format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n@@ -434,7 +438,7 @@ fn suggest_restriction<'tcx>(\n                 format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n             (Some(_), Some((_, []))) => (\n-                generics.span.shrink_to_hi(),\n+                hir_generics.span.shrink_to_hi(),\n                 format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n         };\n@@ -455,23 +459,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     ) {\n+        let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n+\n         let self_ty = trait_pred.skip_binder().self_ty();\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n             ty::Projection(projection) => (false, Some(projection)),\n             _ => (false, None),\n         };\n \n-        let generic_args_have_impl_trait = |args: SubstsRef<'tcx>| -> bool {\n-            args.iter().any(|arg| match arg.unpack() {\n-                GenericArgKind::Type(ty) => match ty.kind() {\n-                    ty::Param(param) => param.name.as_str().starts_with(\"impl\"),\n-                    _ => false,\n-                },\n-                _ => false,\n-            })\n-        };\n-\n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n         let mut hir_id = body_id;\n@@ -486,6 +482,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"`Self`\",\n                         err,\n@@ -505,7 +502,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_pred, None,\n+                        self.tcx, hir_id, &generics, \"`Self`\", err, None, projection, trait_pred,\n+                        None,\n                     );\n                     return;\n                 }\n@@ -526,6 +524,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -545,6 +544,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n+                        hir_id,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -573,6 +573,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | hir::Node::ImplItem(hir::ImplItem { generics, .. })\n                     if param_ty =>\n                 {\n+                    // We skip the 0'th subst (self) because we do not want\n+                    // to consider the predicate as not suggestible if the\n+                    // self type is an arg position `impl Trait` -- instead,\n+                    // we handle that by adding ` + Bound` below.\n+                    // FIXME(compiler-errors): It would be nice to do the same\n+                    // this that we do in `suggest_restriction` and pull the\n+                    // `impl Trait` into a new generic if it shows up somewhere\n+                    // else in the predicate.\n+                    if !trait_pred.skip_binder().trait_ref.substs[1..]\n+                        .iter()\n+                        .all(|g| g.is_suggestable(self.tcx))\n+                    {\n+                        return;\n+                    }\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n                     let constraint = with_no_trimmed_paths!(\n@@ -602,13 +616,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         | hir::ItemKind::TraitAlias(generics, _)\n                         | hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }),\n                     ..\n-                }) if !param_ty\n-                    && !generic_args_have_impl_trait(trait_pred.skip_binder().trait_ref.substs) =>\n-                {\n+                }) if !param_ty => {\n                     // Missing generic type parameter bound.\n-                    let param_name = self_ty.to_string();\n-                    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n-                    if suggest_arbitrary_trait_bound(generics, &mut err, &param_name, &constraint) {\n+                    if suggest_arbitrary_trait_bound(self.tcx, generics, &mut err, trait_pred) {\n                         return;\n                     }\n                 }\n@@ -2982,3 +2992,52 @@ fn suggest_trait_object_return_type_alternatives(\n         );\n     }\n }\n+\n+/// Collect the spans that we see the generic param `param_did`\n+struct ReplaceImplTraitVisitor<'a> {\n+    ty_spans: &'a mut Vec<Span>,\n+    param_did: DefId,\n+}\n+\n+impl<'a, 'hir> hir::intravisit::Visitor<'hir> for ReplaceImplTraitVisitor<'a> {\n+    fn visit_ty(&mut self, t: &'hir hir::Ty<'hir>) {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(\n+            None,\n+            hir::Path { res: hir::def::Res::Def(_, segment_did), .. },\n+        )) = t.kind\n+        {\n+            if self.param_did == *segment_did {\n+                // `fn foo(t: impl Trait)`\n+                //            ^^^^^^^^^^ get this to suggest `T` instead\n+\n+                // There might be more than one `impl Trait`.\n+                self.ty_spans.push(t.span);\n+                return;\n+            }\n+        }\n+\n+        hir::intravisit::walk_ty(self, t);\n+    }\n+}\n+\n+// Replace `param` with `replace_ty`\n+struct ReplaceImplTraitFolder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param: &'tcx ty::GenericParamDef,\n+    replace_ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReplaceImplTraitFolder<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Param(ty::ParamTy { index, .. }) = t.kind() {\n+            if self.param.index == *index {\n+                return self.replace_ty;\n+            }\n+        }\n+        t.super_fold_with(self)\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}"}, {"sha": "60682aa3435170215bdc6d6a37ccc4916cdd9d1c", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{\n-    self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n+    self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, IsSuggestable, Ty, TyCtxt,\n };\n use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n use rustc_span::{symbol::kw, Span};"}, {"sha": "b5025b794bb0d2c26890887cdd08028ddfbdd106", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -27,7 +27,9 @@ use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n-use rustc_middle::ty::{self, Const, DefIdTree, EarlyBinder, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, Const, DefIdTree, EarlyBinder, IsSuggestable, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;"}, {"sha": "99c766d54c8aa5cefaafdf48f5221072850e1c2a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -15,7 +15,7 @@ use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Binder, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, ToPredicate, Ty};\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;"}, {"sha": "5f6ddc1e1c94a96469b542ad9d2fdd14377b0491", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -538,10 +538,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 };\n                                 if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                     if let Some(g) = kind.generics() {\n-                                        let key = match g.predicates {\n-                                            [.., pred] => (pred.span().shrink_to_hi(), false),\n-                                            [] => (g.span_for_predicates_or_empty_place(), true),\n-                                        };\n+                                        let key = (\n+                                            g.tail_span_for_predicate_suggestion(),\n+                                            g.add_where_or_trailing_comma(),\n+                                        );\n                                         type_params\n                                             .entry(key)\n                                             .or_insert_with(FxHashSet::default)\n@@ -805,7 +805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .enumerate()\n                         .collect::<Vec<(usize, String)>>();\n \n-                    for ((span, empty_where), obligations) in type_params.into_iter() {\n+                    for ((span, add_where_or_comma), obligations) in type_params.into_iter() {\n                         restrict_type_params = true;\n                         // #74886: Sort here so that the output is always the same.\n                         let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n@@ -817,11 +817,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  trait bound{s}\",\n                                 s = pluralize!(obligations.len())\n                             ),\n-                            format!(\n-                                \"{} {}\",\n-                                if empty_where { \" where\" } else { \",\" },\n-                                obligations.join(\", \")\n-                            ),\n+                            format!(\"{} {}\", add_where_or_comma, obligations.join(\", \")),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }"}, {"sha": "362e034ba54524549e399bf37dcd683957c4abb5", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -421,7 +421,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n \n             let suggestion = format!(\n                 \"{} {}\",\n-                if !gat_item_hir.generics.predicates.is_empty() { \",\" } else { \" where\" },\n+                gat_item_hir.generics.add_where_or_trailing_comma(),\n                 unsatisfied_bounds.join(\", \"),\n             );\n             err.span_suggestion("}, {"sha": "5a70dc1e594a3bc3df2804d8dff5019397057481", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -39,7 +39,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;"}, {"sha": "d613edf0ab0c46a71947eb7456dcd7c9af26358e", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -211,7 +211,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n             Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                generics.where_clause_span()\n+                Some(generics.where_clause_span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -401,14 +401,17 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         .emit();\n                         error = true;\n                     }\n-                    if let Some(sp) = generics.where_clause_span() {\n+                    if generics.has_where_clause_predicates {\n                         struct_span_err!(\n                             tcx.sess,\n-                            sp,\n+                            generics.where_clause_span,\n                             E0647,\n                             \"start function is not allowed to have a `where` clause\"\n                         )\n-                        .span_label(sp, \"start function cannot have a `where` clause\")\n+                        .span_label(\n+                            generics.where_clause_span,\n+                            \"start function cannot have a `where` clause\",\n+                        )\n                         .emit();\n                         error = true;\n                     }"}, {"sha": "84add5799abaea44f3b2725cbdd720aa1d41ab4a", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -6,7 +6,7 @@ LL |     a.iter().map(|a| a*a)\n    |                      |\n    |                      &T\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn func<'a, T>(a: &'a [T]) -> impl Iterator<Item=&'a T> where &T: Mul<&T> {\n    |                                                         +++++++++++++++++"}, {"sha": "34b88b8a866850f8a8af2f79c8500691f52d25e0", "filename": "src/test/ui/partialeq_help.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fpartialeq_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fpartialeq_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpartialeq_help.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -2,6 +2,11 @@ fn foo<T: PartialEq>(a: &T, b: T) {\n     a == b; //~ ERROR E0277\n }\n \n+fn foo2<T: PartialEq>(a: &T, b: T) where {\n+    a == b; //~ ERROR E0277\n+}\n+\n fn main() {\n     foo(&1, 1);\n+    foo2(&1, 1);\n }"}, {"sha": "fdff94f425c8a44dcc9e50772ed3225fbb4e5224", "filename": "src/test/ui/partialeq_help.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpartialeq_help.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -5,11 +5,23 @@ LL |     a == b;\n    |       ^^ no implementation for `&T == T`\n    |\n    = help: the trait `PartialEq<T>` is not implemented for `&T`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn foo<T: PartialEq>(a: &T, b: T) where &T: PartialEq<T> {\n    |                                   ++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error[E0277]: can't compare `&T` with `T`\n+  --> $DIR/partialeq_help.rs:6:7\n+   |\n+LL |     a == b;\n+   |       ^^ no implementation for `&T == T`\n+   |\n+   = help: the trait `PartialEq<T>` is not implemented for `&T`\n+help: consider extending the `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn foo2<T: PartialEq>(a: &T, b: T) where &T: PartialEq<T> {\n+   |                                          ++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "64501c52374196d38223cae6744befe0bf1ee550", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -15,7 +15,7 @@ note: required by a bound in `Foo::Bar`\n    |\n LL |     type Bar: ~const std::ops::Add;\n    |               ^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo::Bar`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | impl const Foo for NonConstAdd where NonConstAdd: ~const Add {\n    |                                +++++++++++++++++++++++++++++"}, {"sha": "7542b81fe2adb0535218acf800dc004f84fd964c", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -14,7 +14,7 @@ note: required by a bound in `foo`\n    |\n LL | const fn foo<T>() where T: ~const Tr {}\n    |                            ^^^^^^^^^ required by this bound in `foo`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | pub trait Foo where (): ~const Tr {\n    |               +++++++++++++++++++"}, {"sha": "91778ed0f4cde599648f77262260685b17caaffa", "filename": "src/test/ui/specialization/default-associated-type-bound-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -20,7 +20,7 @@ note: required by a bound in `X::U`\n    |\n LL |     type U: PartialEq<T>;\n    |             ^^^^^^^^^^^^ required by this bound in `X::U`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | impl<B: 'static, T> X<B> for T where &'static B: PartialEq<B> {\n    |                                ++++++++++++++++++++++++++++++"}, {"sha": "501d083e2bc608edbdba9a0314a004b4d7fbed26", "filename": "src/test/ui/suggestions/derive-macro-missing-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -13,7 +13,7 @@ help: consider annotating `a::Inner<T>` with `#[derive(Debug)]`\n    |\n LL |     #[derive(Debug)]\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL |     struct Outer<T>(Inner<T>) where a::Inner<T>: Debug;\n    |                               ++++++++++++++++++++++++"}, {"sha": "94bd2d41565826bc3576d77ae014067ff055979e", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -15,7 +15,7 @@ help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n    |\n LL | #[derive(PartialEq)]\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | pub fn foo<T>(s: S<T>, t: S<T>) where S<T>: PartialEq {\n    |                                 +++++++++++++++++++++"}, {"sha": "a4c3b1350b891f10ed6c8b0bc0dbf704431f7b7b", "filename": "src/test/ui/suggestions/issue-97677.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -0,0 +1,6 @@\n+fn add_ten<N>(n: N) -> N {\n+    n + 10\n+    //~^ ERROR cannot add `{integer}` to `N`\n+}\n+\n+fn main() {}"}, {"sha": "ea563ea844de57d51c04f285756cd9aede275d6b", "filename": "src/test/ui/suggestions/issue-97677.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -0,0 +1,16 @@\n+error[E0369]: cannot add `{integer}` to `N`\n+  --> $DIR/issue-97677.rs:2:7\n+   |\n+LL |     n + 10\n+   |     - ^ -- {integer}\n+   |     |\n+   |     N\n+   |\n+help: consider restricting type parameter `N`\n+   |\n+LL | fn add_ten<N: std::ops::Add<i32>>(n: N) -> N {\n+   |             ++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "cf9c3c58dca6f8139a562c7979ab20a76c802006", "filename": "src/test/ui/suggestions/issue-97760.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -0,0 +1,9 @@\n+pub fn print_values(values: &impl IntoIterator)\n+where {\n+    for x in values.into_iter() {\n+        println!(\"{x}\");\n+        //~^ ERROR <impl IntoIterator as IntoIterator>::Item` doesn't implement `std::fmt::Display\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "459556bddaee523ad153ffbae283698fb10a5619", "filename": "src/test/ui/suggestions/issue-97760.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97760.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: `<impl IntoIterator as IntoIterator>::Item` doesn't implement `std::fmt::Display`\n+  --> $DIR/issue-97760.rs:4:20\n+   |\n+LL |         println!(\"{x}\");\n+   |                    ^ `<impl IntoIterator as IntoIterator>::Item` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `<impl IntoIterator as IntoIterator>::Item`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL ~ pub fn print_values<I: IntoIterator>(values: &I)\n+LL ~ where <I as IntoIterator>::Item: std::fmt::Display {\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "47dc7c343daebea6ed4ce2b975843e21c609af25", "filename": "src/test/ui/suggestions/suggest-change-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -2,7 +2,7 @@\n \n use std::io::{BufRead, BufReader, Read, Write};\n \n-fn issue_81421<T: Read + Write>(mut stream: T) { //~ HELP consider introducing a `where` bound\n+fn issue_81421<T: Read + Write>(mut stream: T) { //~ HELP consider introducing a `where` clause\n     let initial_message = format!(\"Hello world\");\n     let mut buffer: Vec<u8> = Vec::new();\n     let bytes_written = stream.write_all(initial_message.as_bytes());"}, {"sha": "be549239e36855edd5be8c5a36bfcd7dcf18d6bf", "filename": "src/test/ui/suggestions/suggest-change-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -16,7 +16,7 @@ help: consider removing the leading `&`-reference\n LL -         let mut stream_reader = BufReader::new(&stream);\n LL +         let mut stream_reader = BufReader::new(stream);\n    | \n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn issue_81421<T: Read + Write>(mut stream: T) where &T: std::io::Read {\n    |                                                +++++++++++++++++++++++"}, {"sha": "34fae64e4d20fe9b2d682c78125d25ec812dab79", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -6,7 +6,7 @@ LL |     a * b\n    |     |\n    |     &T\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n    |                                                  ++++++++++++++++++"}, {"sha": "520ee0b5ea73376dfeaa1aae7abfd6edaea9ebb9", "filename": "src/test/ui/traits/suggest-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -49,7 +49,7 @@ error[E0277]: the trait bound `u64: From<T>` is not satisfied\n LL |     <u64 as From<T>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ the trait `From<T>` is not implemented for `u64`\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn check<T: Iterator, U: ?Sized>() where u64: From<T> {\n    |                                    ++++++++++++++++++\n@@ -60,7 +60,7 @@ error[E0277]: the trait bound `u64: From<<T as Iterator>::Item>` is not satisfie\n LL |     <u64 as From<<T as Iterator>::Item>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<<T as Iterator>::Item>` is not implemented for `u64`\n    |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn check<T: Iterator, U: ?Sized>() where u64: From<<T as Iterator>::Item> {\n    |                                    ++++++++++++++++++++++++++++++++++++++"}, {"sha": "198f3e26393d432edde69706efb551918d139701", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37a42258ffe02cfb7107380759e492c64500ab55/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=37a42258ffe02cfb7107380759e492c64500ab55", "patch": "@@ -5,7 +5,7 @@ LL |     (a, a)\n    |         ^ the trait `From<&A>` is not implemented for `&'static B`\n    |\n    = note: required because of the requirements on the impl of `Into<&'static B>` for `&A`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++"}]}