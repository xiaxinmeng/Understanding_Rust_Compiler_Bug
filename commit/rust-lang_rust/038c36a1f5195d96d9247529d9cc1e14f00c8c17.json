{"sha": "038c36a1f5195d96d9247529d9cc1e14f00c8c17", "node_id": "C_kwDOAAsO6NoAKDAzOGMzNmExZjUxOTVkOTZkOTI0NzUyOWQ5Y2MxZTE0ZjAwYzhjMTc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-13T18:03:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-13T18:03:06Z"}, "message": "Simplify `GlobalState::handle_event`", "tree": {"sha": "9775a5ec042caaf7a4a093c042c85c5ea9413de8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9775a5ec042caaf7a4a093c042c85c5ea9413de8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/038c36a1f5195d96d9247529d9cc1e14f00c8c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/038c36a1f5195d96d9247529d9cc1e14f00c8c17", "html_url": "https://github.com/rust-lang/rust/commit/038c36a1f5195d96d9247529d9cc1e14f00c8c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/038c36a1f5195d96d9247529d9cc1e14f00c8c17/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f982c7616196b433bd65a1df1d07ee0d249701c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f982c7616196b433bd65a1df1d07ee0d249701c0", "html_url": "https://github.com/rust-lang/rust/commit/f982c7616196b433bd65a1df1d07ee0d249701c0"}], "stats": {"total": 381, "additions": 192, "deletions": 189}, "files": [{"sha": "92b6be22e762684ba9ec977a8e7ff86d62de041c", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 192, "deletions": 189, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/038c36a1f5195d96d9247529d9cc1e14f00c8c17/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/038c36a1f5195d96d9247529d9cc1e14f00c8c17/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=038c36a1f5195d96d9247529d9cc1e14f00c8c17", "patch": "@@ -9,6 +9,7 @@ use std::{\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n+use flycheck::FlycheckHandle;\n use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n@@ -205,81 +206,14 @@ impl GlobalState {\n                 }\n                 lsp_server::Message::Response(resp) => self.complete_request(resp),\n             },\n-            Event::Task(mut task) => {\n+            Event::Task(task) => {\n                 let _p = profile::span(\"GlobalState::handle_event/task\");\n                 let mut prime_caches_progress = Vec::new();\n-                loop {\n-                    match task {\n-                        Task::Response(response) => self.respond(response),\n-                        Task::Retry(req) => self.on_request(req),\n-                        Task::Diagnostics(diagnostics_per_file) => {\n-                            for (file_id, diagnostics) in diagnostics_per_file {\n-                                self.diagnostics.set_native_diagnostics(file_id, diagnostics)\n-                            }\n-                        }\n-                        Task::PrimeCaches(progress) => match progress {\n-                            PrimeCachesProgress::Begin => prime_caches_progress.push(progress),\n-                            PrimeCachesProgress::Report(_) => {\n-                                match prime_caches_progress.last_mut() {\n-                                    Some(last @ PrimeCachesProgress::Report(_)) => {\n-                                        // Coalesce subsequent update events.\n-                                        *last = progress;\n-                                    }\n-                                    _ => prime_caches_progress.push(progress),\n-                                }\n-                            }\n-                            PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),\n-                        },\n-                        Task::FetchWorkspace(progress) => {\n-                            let (state, msg) = match progress {\n-                                ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n-                                ProjectWorkspaceProgress::Report(msg) => {\n-                                    (Progress::Report, Some(msg))\n-                                }\n-                                ProjectWorkspaceProgress::End(workspaces) => {\n-                                    self.fetch_workspaces_queue.op_completed(workspaces);\n-\n-                                    let old = Arc::clone(&self.workspaces);\n-                                    self.switch_workspaces(\"fetched workspace\".to_string());\n-                                    let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n-\n-                                    if self.config.run_build_scripts() && workspaces_updated {\n-                                        self.fetch_build_data_queue\n-                                            .request_op(format!(\"workspace updated\"));\n-                                    }\n-\n-                                    (Progress::End, None)\n-                                }\n-                            };\n \n-                            self.report_progress(\"Fetching\", state, msg, None);\n-                        }\n-                        Task::FetchBuildData(progress) => {\n-                            let (state, msg) = match progress {\n-                                BuildDataProgress::Begin => (Some(Progress::Begin), None),\n-                                BuildDataProgress::Report(msg) => {\n-                                    (Some(Progress::Report), Some(msg))\n-                                }\n-                                BuildDataProgress::End(build_data_result) => {\n-                                    self.fetch_build_data_queue.op_completed(build_data_result);\n-\n-                                    self.switch_workspaces(\"fetched build data\".to_string());\n-\n-                                    (Some(Progress::End), None)\n-                                }\n-                            };\n-\n-                            if let Some(state) = state {\n-                                self.report_progress(\"Loading\", state, msg, None);\n-                            }\n-                        }\n-                    }\n-\n-                    // Coalesce multiple task events into one loop turn\n-                    task = match self.task_pool.receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    };\n+                self.handle_task(&mut prime_caches_progress, task);\n+                // Coalesce multiple task events into one loop turn\n+                while let Ok(task) = self.task_pool.receiver.try_recv() {\n+                    self.handle_task(&mut prime_caches_progress, task);\n                 }\n \n                 for progress in prime_caches_progress {\n@@ -326,119 +260,20 @@ impl GlobalState {\n                     self.report_progress(\"Indexing\", state, message, Some(fraction));\n                 }\n             }\n-            Event::Vfs(mut task) => {\n+            Event::Vfs(message) => {\n                 let _p = profile::span(\"GlobalState::handle_event/vfs\");\n-                loop {\n-                    match task {\n-                        vfs::loader::Message::Loaded { files } => {\n-                            let vfs = &mut self.vfs.write().0;\n-                            for (path, contents) in files {\n-                                let path = VfsPath::from(path);\n-                                if !self.mem_docs.contains(&path) {\n-                                    vfs.set_file_contents(path, contents);\n-                                }\n-                            }\n-                        }\n-                        vfs::loader::Message::Progress { n_total, n_done, config_version } => {\n-                            always!(config_version <= self.vfs_config_version);\n-\n-                            self.vfs_progress_config_version = config_version;\n-                            self.vfs_progress_n_total = n_total;\n-                            self.vfs_progress_n_done = n_done;\n-\n-                            let state = if n_done == 0 {\n-                                Progress::Begin\n-                            } else if n_done < n_total {\n-                                Progress::Report\n-                            } else {\n-                                assert_eq!(n_done, n_total);\n-                                Progress::End\n-                            };\n-                            self.report_progress(\n-                                \"Roots Scanned\",\n-                                state,\n-                                Some(format!(\"{}/{}\", n_done, n_total)),\n-                                Some(Progress::fraction(n_done, n_total)),\n-                            )\n-                        }\n-                    }\n-                    // Coalesce many VFS event into a single loop turn\n-                    task = match self.loader.receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    }\n+                self.handle_vfs_msg(message);\n+                // Coalesce many VFS event into a single loop turn\n+                while let Ok(message) = self.loader.receiver.try_recv() {\n+                    self.handle_vfs_msg(message);\n                 }\n             }\n-            Event::Flycheck(mut task) => {\n+            Event::Flycheck(message) => {\n                 let _p = profile::span(\"GlobalState::handle_event/flycheck\");\n-                loop {\n-                    match task {\n-                        flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n-                            let snap = self.snapshot();\n-                            let diagnostics =\n-                                crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n-                                    &self.config.diagnostics_map(),\n-                                    &diagnostic,\n-                                    &workspace_root,\n-                                    &snap,\n-                                );\n-                            for diag in diagnostics {\n-                                match url_to_file_id(&self.vfs.read().0, &diag.url) {\n-                                    Ok(file_id) => self.diagnostics.add_check_diagnostic(\n-                                        id,\n-                                        file_id,\n-                                        diag.diagnostic,\n-                                        diag.fix,\n-                                    ),\n-                                    Err(err) => {\n-                                        tracing::error!(\n-                                            \"File with cargo diagnostic not found in VFS: {}\",\n-                                            err\n-                                        );\n-                                    }\n-                                };\n-                            }\n-                        }\n-\n-                        flycheck::Message::Progress { id, progress } => {\n-                            let (state, message) = match progress {\n-                                flycheck::Progress::DidStart => {\n-                                    self.diagnostics.clear_check(id);\n-                                    (Progress::Begin, None)\n-                                }\n-                                flycheck::Progress::DidCheckCrate(target) => {\n-                                    (Progress::Report, Some(target))\n-                                }\n-                                flycheck::Progress::DidCancel => (Progress::End, None),\n-                                flycheck::Progress::DidFinish(result) => {\n-                                    if let Err(err) = result {\n-                                        self.show_and_log_error(\n-                                            \"cargo check failed\".to_string(),\n-                                            Some(err.to_string()),\n-                                        );\n-                                    }\n-                                    (Progress::End, None)\n-                                }\n-                            };\n-\n-                            // When we're running multiple flychecks, we have to include a disambiguator in\n-                            // the title, or the editor complains. Note that this is a user-facing string.\n-                            let title = if self.flycheck.len() == 1 {\n-                                match self.config.flycheck() {\n-                                    Some(config) => format!(\"{}\", config),\n-                                    None => \"cargo check\".to_string(),\n-                                }\n-                            } else {\n-                                format!(\"cargo check (#{})\", id + 1)\n-                            };\n-                            self.report_progress(&title, state, message, None);\n-                        }\n-                    }\n-                    // Coalesce many flycheck updates into a single loop turn\n-                    task = match self.flycheck_receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    }\n+                self.handle_flycheck_msg(message);\n+                // Coalesce many flycheck updates into a single loop turn\n+                while let Ok(message) = self.flycheck_receiver.try_recv() {\n+                    self.handle_flycheck_msg(message);\n                 }\n             }\n         }\n@@ -447,13 +282,13 @@ impl GlobalState {\n         let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n         if self.is_quiescent() {\n-            if !was_quiescent\n-                && !self.fetch_workspaces_queue.op_requested()\n-                && !self.fetch_build_data_queue.op_requested()\n-            {\n-                for flycheck in &self.flycheck {\n-                    flycheck.update();\n-                }\n+            let became_quiescent = !(was_quiescent\n+                || self.fetch_workspaces_queue.op_requested()\n+                || self.fetch_build_data_queue.op_requested());\n+\n+            if became_quiescent {\n+                // Project has loaded properly, kick off initial flycheck\n+                self.flycheck.iter().for_each(FlycheckHandle::update);\n                 if self.config.prefill_caches() {\n                     self.prime_caches_queue.request_op(\"became quiescent\".to_string());\n                 }\n@@ -495,8 +330,9 @@ impl GlobalState {\n                 let url = file_id_to_url(&self.vfs.read().0, file_id);\n                 let mut diagnostics =\n                     self.diagnostics.diagnostics_for(file_id).cloned().collect::<Vec<_>>();\n-                // https://github.com/rust-lang/rust-analyzer/issues/11404\n                 for d in &mut diagnostics {\n+                    // https://github.com/rust-lang/rust-analyzer/issues/11404\n+                    // FIXME: We should move this workaround into the client code\n                     if d.message.is_empty() {\n                         d.message = \" \".to_string();\n                     }\n@@ -575,11 +411,171 @@ impl GlobalState {\n         Ok(())\n     }\n \n+    fn handle_task(&mut self, prime_caches_progress: &mut Vec<PrimeCachesProgress>, task: Task) {\n+        match task {\n+            Task::Response(response) => self.respond(response),\n+            Task::Retry(req) => self.on_request(req),\n+            Task::Diagnostics(diagnostics_per_file) => {\n+                for (file_id, diagnostics) in diagnostics_per_file {\n+                    self.diagnostics.set_native_diagnostics(file_id, diagnostics)\n+                }\n+            }\n+            Task::PrimeCaches(progress) => match progress {\n+                PrimeCachesProgress::Begin => prime_caches_progress.push(progress),\n+                PrimeCachesProgress::Report(_) => {\n+                    match prime_caches_progress.last_mut() {\n+                        Some(last @ PrimeCachesProgress::Report(_)) => {\n+                            // Coalesce subsequent update events.\n+                            *last = progress;\n+                        }\n+                        _ => prime_caches_progress.push(progress),\n+                    }\n+                }\n+                PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),\n+            },\n+            Task::FetchWorkspace(progress) => {\n+                let (state, msg) = match progress {\n+                    ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n+                    ProjectWorkspaceProgress::Report(msg) => (Progress::Report, Some(msg)),\n+                    ProjectWorkspaceProgress::End(workspaces) => {\n+                        self.fetch_workspaces_queue.op_completed(workspaces);\n+\n+                        let old = Arc::clone(&self.workspaces);\n+                        self.switch_workspaces(\"fetched workspace\".to_string());\n+                        let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n+\n+                        if self.config.run_build_scripts() && workspaces_updated {\n+                            self.fetch_build_data_queue.request_op(format!(\"workspace updated\"));\n+                        }\n+\n+                        (Progress::End, None)\n+                    }\n+                };\n+\n+                self.report_progress(\"Fetching\", state, msg, None);\n+            }\n+            Task::FetchBuildData(progress) => {\n+                let (state, msg) = match progress {\n+                    BuildDataProgress::Begin => (Some(Progress::Begin), None),\n+                    BuildDataProgress::Report(msg) => (Some(Progress::Report), Some(msg)),\n+                    BuildDataProgress::End(build_data_result) => {\n+                        self.fetch_build_data_queue.op_completed(build_data_result);\n+\n+                        self.switch_workspaces(\"fetched build data\".to_string());\n+\n+                        (Some(Progress::End), None)\n+                    }\n+                };\n+\n+                if let Some(state) = state {\n+                    self.report_progress(\"Loading\", state, msg, None);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_vfs_msg(&mut self, message: vfs::loader::Message) {\n+        match message {\n+            vfs::loader::Message::Loaded { files } => {\n+                let vfs = &mut self.vfs.write().0;\n+                for (path, contents) in files {\n+                    let path = VfsPath::from(path);\n+                    if !self.mem_docs.contains(&path) {\n+                        vfs.set_file_contents(path, contents);\n+                    }\n+                }\n+            }\n+            vfs::loader::Message::Progress { n_total, n_done, config_version } => {\n+                always!(config_version <= self.vfs_config_version);\n+\n+                self.vfs_progress_config_version = config_version;\n+                self.vfs_progress_n_total = n_total;\n+                self.vfs_progress_n_done = n_done;\n+\n+                let state = if n_done == 0 {\n+                    Progress::Begin\n+                } else if n_done < n_total {\n+                    Progress::Report\n+                } else {\n+                    assert_eq!(n_done, n_total);\n+                    Progress::End\n+                };\n+                self.report_progress(\n+                    \"Roots Scanned\",\n+                    state,\n+                    Some(format!(\"{}/{}\", n_done, n_total)),\n+                    Some(Progress::fraction(n_done, n_total)),\n+                )\n+            }\n+        }\n+    }\n+\n+    fn handle_flycheck_msg(&mut self, message: flycheck::Message) {\n+        match message {\n+            flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n+                let snap = self.snapshot();\n+                let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n+                    &self.config.diagnostics_map(),\n+                    &diagnostic,\n+                    &workspace_root,\n+                    &snap,\n+                );\n+                for diag in diagnostics {\n+                    match url_to_file_id(&self.vfs.read().0, &diag.url) {\n+                        Ok(file_id) => self.diagnostics.add_check_diagnostic(\n+                            id,\n+                            file_id,\n+                            diag.diagnostic,\n+                            diag.fix,\n+                        ),\n+                        Err(err) => {\n+                            tracing::error!(\"File with cargo diagnostic not found in VFS: {}\", err);\n+                        }\n+                    };\n+                }\n+            }\n+\n+            flycheck::Message::Progress { id, progress } => {\n+                let (state, message) = match progress {\n+                    flycheck::Progress::DidStart => {\n+                        self.diagnostics.clear_check(id);\n+                        (Progress::Begin, None)\n+                    }\n+                    flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n+                    flycheck::Progress::DidCancel => (Progress::End, None),\n+                    flycheck::Progress::DidFinish(result) => {\n+                        if let Err(err) = result {\n+                            self.show_and_log_error(\n+                                \"cargo check failed\".to_string(),\n+                                Some(err.to_string()),\n+                            );\n+                        }\n+                        (Progress::End, None)\n+                    }\n+                };\n+\n+                // When we're running multiple flychecks, we have to include a disambiguator in\n+                // the title, or the editor complains. Note that this is a user-facing string.\n+                let title = if self.flycheck.len() == 1 {\n+                    match self.config.flycheck() {\n+                        Some(config) => format!(\"{}\", config),\n+                        None => \"cargo check\".to_string(),\n+                    }\n+                } else {\n+                    format!(\"cargo check (#{})\", id + 1)\n+                };\n+                self.report_progress(&title, state, message, None);\n+            }\n+        }\n+    }\n+\n+    /// Registers and handles a request. This should only be called once per incoming request.\n     fn on_new_request(&mut self, request_received: Instant, req: Request) {\n         self.register_request(&req, request_received);\n         self.on_request(req);\n     }\n \n+    /// Handles a request.\n     fn on_request(&mut self, req: Request) {\n         if self.shutdown_requested {\n             self.respond(lsp_server::Response::new_err(\n@@ -670,6 +666,7 @@ impl GlobalState {\n             .finish();\n     }\n \n+    /// Handles an incoming notification.\n     fn on_notification(&mut self, not: Notification) -> Result<()> {\n         NotificationDispatcher { not: Some(not), global_state: self }\n             .on::<lsp_types::notification::Cancel>(|this, params| {\n@@ -743,6 +740,8 @@ impl GlobalState {\n                 let mut updated = false;\n                 if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n                     let (vfs, _) = &*this.vfs.read();\n+\n+                    // Trigger flychecks for all workspaces that depend on the saved file\n                     if let Some(file_id) = vfs.file_id(&vfs_path) {\n                         let analysis = this.analysis_host.analysis();\n                         // Crates containing or depending on the saved file\n@@ -800,13 +799,17 @@ impl GlobalState {\n                             }\n                         }\n                     }\n+\n+                    // Re-fetch workspaces if a workspace related file has changed\n                     if let Some(abs_path) = vfs_path.as_path() {\n                         if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n                             this.fetch_workspaces_queue\n                                 .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n                         }\n                     }\n                 }\n+\n+                // No specific flycheck was triggered, so let's trigger all of them.\n                 if !updated {\n                     for flycheck in &this.flycheck {\n                         flycheck.update();"}]}