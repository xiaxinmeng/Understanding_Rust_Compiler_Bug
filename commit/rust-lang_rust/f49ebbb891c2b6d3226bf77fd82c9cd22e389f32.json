{"sha": "f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OWViYmI4OTFjMmI2ZDMyMjZiZjc3ZmQ4MmM5Y2QyMmUzODlmMzI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-24T17:34:03Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-30T17:19:41Z"}, "message": "Account for missing lifetime in opaque return type\n\nWhen encountering an opaque closure return type that needs to bound a\nlifetime to the function's arguments, including borrows and type params,\nprovide appropriate suggestions that lead to working code.\n\nGet the user from\n\n```rust\nfn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```\n\nto\n\n```rust\nfn foo<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() +'a\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```", "tree": {"sha": "ce6925e88d2a4ec61aaa28d11a0a757d8ef3a0d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6925e88d2a4ec61aaa28d11a0a757d8ef3a0d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "html_url": "https://github.com/rust-lang/rust/commit/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e80468347471779be6060d8d7d6d04e98e467f", "url": "https://api.github.com/repos/rust-lang/rust/commits/74e80468347471779be6060d8d7d6d04e98e467f", "html_url": "https://github.com/rust-lang/rust/commit/74e80468347471779be6060d8d7d6d04e98e467f"}], "stats": {"total": 428, "additions": 359, "deletions": 69}, "files": [{"sha": "3b98d47778fc14a69105557bb9ceabfa02ddf14d", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 98, "deletions": 42, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "patch": "@@ -1682,49 +1682,70 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n+        let hir = &self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let type_param_span = match (self.in_progress_tables, bound_kind) {\n-            (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table_owner = table.borrow().hir_owner;\n-                table_owner.and_then(|table_owner| {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    // Account for the case where `param` corresponds to `Self`,\n-                    // which doesn't have the expected type argument.\n-                    if !(generics.has_self && param.index == 0) {\n-                        let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir();\n-                        type_param.def_id.as_local().map(|def_id| {\n-                            // Get the `hir::Param` to verify whether it already has any bounds.\n-                            // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n-                            // instead we suggest `T: 'a + 'b` in that case.\n-                            let id = hir.as_local_hir_id(def_id);\n-                            let mut has_bounds = false;\n-                            if let Node::GenericParam(param) = hir.get(id) {\n-                                has_bounds = !param.bounds.is_empty();\n-                            }\n-                            let sp = hir.span(id);\n-                            // `sp` only covers `T`, change it so that it covers\n-                            // `T:` when appropriate\n-                            let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                            let sp = if has_bounds && !is_impl_trait {\n-                                sp.to(self\n-                                    .tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n-                            } else {\n-                                sp\n-                            };\n-                            (sp, has_bounds, is_impl_trait)\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                })\n+        let generics = self\n+            .in_progress_tables\n+            .and_then(|table| table.borrow().hir_owner)\n+            .map(|table_owner| self.tcx.generics_of(table_owner.to_def_id()));\n+        let type_param_span = match (generics, bound_kind) {\n+            (Some(ref generics), GenericKind::Param(ref param)) => {\n+                // Account for the case where `param` corresponds to `Self`,\n+                // which doesn't have the expected type argument.\n+                if !(generics.has_self && param.index == 0) {\n+                    let type_param = generics.type_param(param, self.tcx);\n+                    type_param.def_id.as_local().map(|def_id| {\n+                        // Get the `hir::Param` to verify whether it already has any bounds.\n+                        // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n+                        // instead we suggest `T: 'a + 'b` in that case.\n+                        let id = hir.as_local_hir_id(def_id);\n+                        let mut has_bounds = false;\n+                        if let Node::GenericParam(param) = hir.get(id) {\n+                            has_bounds = !param.bounds.is_empty();\n+                        }\n+                        let sp = hir.span(id);\n+                        // `sp` only covers `T`, change it so that it covers\n+                        // `T:` when appropriate\n+                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n+                        let sp = if has_bounds && !is_impl_trait {\n+                            sp.to(self\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        } else {\n+                            sp\n+                        };\n+                        (sp, has_bounds, is_impl_trait)\n+                    })\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         };\n+        let new_lt = generics\n+            .as_ref()\n+            .and_then(|g| {\n+                let possible = [\"'a\", \"'b\", \"'c\", \"'d\", \"'e\", \"'f\", \"'g\", \"'h\", \"'i\", \"'j\", \"'k\"];\n+                let lts_names = g\n+                    .params\n+                    .iter()\n+                    .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                    .map(|p| p.name.as_str())\n+                    .collect::<Vec<_>>();\n+                let lts = lts_names.iter().map(|s| -> &str { &*s }).collect::<Vec<_>>();\n+                possible.iter().filter(|&candidate| !lts.contains(&*candidate)).next().map(|s| *s)\n+            })\n+            .unwrap_or(\"'lt\");\n+        let add_lt_sugg = generics\n+            .as_ref()\n+            .and_then(|g| g.params.first())\n+            .and_then(|param| param.def_id.as_local())\n+            .map(|def_id| {\n+                (hir.span(hir.as_local_hir_id(def_id)).shrink_to_lo(), format!(\"{}, \", new_lt))\n+            });\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n@@ -1781,6 +1802,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let new_binding_suggestion =\n+            |err: &mut DiagnosticBuilder<'tcx>,\n+             type_param_span: Option<(Span, bool, bool)>,\n+             bound_kind: GenericKind<'tcx>| {\n+                let msg = \"consider introducing an explicit lifetime bound to unify the type \\\n+                    parameter and the output\";\n+                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n+                    let suggestion = if is_impl_trait {\n+                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                    } else {\n+                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n+                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                    };\n+                    let mut sugg =\n+                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                    if let Some(lt) = add_lt_sugg {\n+                        sugg.push(lt);\n+                        sugg.rotate_right(1);\n+                    }\n+                    // `MaybeIncorrect` due to issue #41966.\n+                    err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);\n+                }\n+            };\n+\n         let mut err = match *sub {\n             ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }) => {\n@@ -1822,17 +1867,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                err.help(&format!(\n-                    \"consider adding an explicit lifetime bound for `{}`\",\n-                    bound_kind\n-                ));\n                 note_and_explain_region(\n                     self.tcx,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\",\n                 );\n+                if let Some(infer::RelateParamBound(_, t)) = origin {\n+                    let t = self.resolve_vars_if_possible(&t);\n+                    match t.kind {\n+                        // We've got:\n+                        // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+                        // suggest:\n+                        // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) => {\n+                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                        }\n+                        _ => {\n+                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                        }\n+                    }\n+                }\n                 err\n             }\n         };"}, {"sha": "4ad587db0128d52e428ef1b4febfa690ff08308a", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "patch": "@@ -4,7 +4,7 @@ use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use rustc_errors::{Applicability, ErrorReported};\n-use rustc_middle::ty::{BoundRegion, FreeRegion, RegionKind};\n+use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n@@ -37,13 +37,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n                     }\n \n-                    let lifetime_name = match sup_r {\n-                        RegionKind::ReFree(FreeRegion {\n-                            bound_region: BoundRegion::BrNamed(_, ref name),\n-                            ..\n-                        }) => name.to_string(),\n-                        _ => \"'_\".to_owned(),\n-                    };\n+                    let lifetime_name =\n+                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n                     let fn_return_span = return_ty.unwrap().1;\n                     if let Ok(snippet) =\n                         self.tcx().sess.source_map().span_to_snippet(fn_return_span)\n@@ -54,9 +49,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             err.span_suggestion(\n                                 fn_return_span,\n                                 &format!(\n-                                    \"you can add a bound to the return type to make it last \\\n-                                 less than `'static` and match {}\",\n-                                    lifetime,\n+                                    \"you can add a bound to the return type to make it last less \\\n+                                     than `'static` and match {}\",\n+                                    lifetime\n                                 ),\n                                 format!(\"{} + {}\", snippet, lifetime_name),\n                                 Applicability::Unspecified,"}, {"sha": "968c488bc004eda7b4ae316fae41bf3abb48f0c4", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "patch": "@@ -56,8 +56,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.span_note(\n                     span,\n                     &format!(\n-                        \"...so that the reference type `{}` does not outlive the \\\n-                                        data it points at\",\n+                        \"...so that the reference type `{}` does not outlive the data it points at\",\n                         self.ty_to_string(ty)\n                     ),\n                 );\n@@ -66,8 +65,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.span_note(\n                     span,\n                     &format!(\n-                        \"...so that the type `{}` will meet its required \\\n-                                        lifetime bounds\",\n+                        \"...so that the type `{}` will meet its required lifetime bounds\",\n                         self.ty_to_string(t)\n                     ),\n                 );\n@@ -81,8 +79,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CompareImplMethodObligation { span, .. } => {\n                 err.span_note(\n                     span,\n-                    \"...so that the definition in impl matches the definition from the \\\n-                               trait\",\n+                    \"...so that the definition in impl matches the definition from the trait\",\n                 );\n             }\n         }\n@@ -113,8 +110,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0312,\n-                    \"lifetime of reference outlives lifetime of \\\n-                                                borrowed content...\"\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n@@ -138,8 +134,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime \\\n-                                                of captured variable `{}`...\",\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n                     var_name\n                 );\n                 note_and_explain_region(\n@@ -163,8 +158,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0476,\n-                    \"lifetime of the source pointer does not outlive \\\n-                                                lifetime bound of the object type\"\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n                 );\n                 note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n@@ -181,8 +176,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0477,\n-                    \"the type `{}` does not fulfill the required \\\n-                                                lifetime\",\n+                    \"the type `{}` does not fulfill the required lifetime\",\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n@@ -217,8 +211,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0482,\n-                    \"lifetime of return value does not outlive the \\\n-                                                function call\"\n+                    \"lifetime of return value does not outlive the function call\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "b5f6fdeaa4ed056a290cf55f2f5ca6f2c85a05c1", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "patch": "@@ -0,0 +1,100 @@\n+pub trait Get<T> {\n+    fn get(self) -> T;\n+}\n+\n+struct Foo {\n+    x: usize,\n+}\n+\n+impl Get<usize> for Foo {\n+    fn get(self) -> usize {\n+        self.x\n+    }\n+}\n+\n+fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+where\n+    G: Get<T>\n+{\n+    move || { //~ ERROR cannot infer an appropriate lifetime\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `foo`:\n+fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// After applying suggestion for `bar`:\n+fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ //~ ERROR undeclared lifetime\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `baz`:\n+fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `qux`:\n+// FIXME: we should suggest be suggesting to change `dest` to `&'a mut T`.\n+fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+where\n+    G: Get<T>\n+{\n+    move || { //~ ERROR cannot infer an appropriate lifetime\n+        *dest = g.get();\n+    }\n+}\n+\n+// Potential incorrect attempt:\n+fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:\n+fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:\n+fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d69db90f3bacc14c1df3385aa4195875fabe56d1", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49ebbb891c2b6d3226bf77fd82c9cd22e389f32/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=f49ebbb891c2b6d3226bf77fd82c9cd22e389f32", "patch": "@@ -0,0 +1,146 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n+   |\n+LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                                       ------------- this return type evaluates to the `'static` lifetime...\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ ...but this borrow...\n+   |\n+note: ...can't outlive the anonymous lifetime #1 defined on the function body at 15:1\n+  --> $DIR/missing-lifetimes-in-signature.rs:15:1\n+   |\n+LL | / fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+LL | | where\n+LL | |     G: Get<T>\n+LL | | {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the function body at 15:1\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 25:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:1\n+   |\n+LL | / fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:30:5: 32:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound to unify the type parameter and the output\n+   |\n+LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        ^^^^^                                                   ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 47:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:1\n+   |\n+LL | / fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:52:5: 54:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound to unify the type parameter and the output\n+   |\n+LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n+   |        ^^^     ^^^^^^^                                                  ^^^^\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/missing-lifetimes-in-signature.rs:63:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the function body at 59:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:1\n+   |\n+LL | / fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+LL | | where\n+LL | |     G: Get<T>\n+LL | | {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the types are compatible\n+  --> $DIR/missing-lifetimes-in-signature.rs:63:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   = note: expected  `&mut T`\n+              found  `&mut T`\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 59:8...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:8\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        ^^\n+note: ...so that return value is valid for the call\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:69:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |            -                               ^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n+   |\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:74:5: 76:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:69:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |                                            ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0495.\n+For more information about an error, try `rustc --explain E0261`."}]}