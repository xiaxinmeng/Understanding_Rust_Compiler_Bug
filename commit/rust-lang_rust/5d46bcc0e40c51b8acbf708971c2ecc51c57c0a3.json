{"sha": "5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNDZiY2MwZTQwYzUxYjhhY2JmNzA4OTcxYzJlY2M1MWM1N2MwYTM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-28T14:59:41Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-30T11:06:47Z"}, "message": "Remove vec::{rfind, rfind_between, find_between}, replaced by slices and iterator adapators.", "tree": {"sha": "8ae6c6ebc5a7ec1d56de0b37be8f62333b82a6a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ae6c6ebc5a7ec1d56de0b37be8f62333b82a6a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "html_url": "https://github.com/rust-lang/rust/commit/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fcd8bf5677652f31008cde5f9f9f00fe67d90b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fcd8bf5677652f31008cde5f9f9f00fe67d90b8", "html_url": "https://github.com/rust-lang/rust/commit/6fcd8bf5677652f31008cde5f9f9f00fe67d90b8"}], "stats": {"total": 121, "additions": 1, "deletions": 120}, "files": [{"sha": "90d0ee251976ea435a6095cc31e964442c6b132a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "patch": "@@ -1263,7 +1263,7 @@ pub fn cleanup_and_leave(bcx: block,\n                     let mut skip = 0;\n                     let mut dest = None;\n                     {\n-                        let r = vec::rfind((*inf).cleanup_paths, |cp| cp.target == leave);\n+                        let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n                         for r.iter().advance |cp| {\n                             if cp.size == inf.cleanups.len() {\n                                 Br(bcx, cp.dest);"}, {"sha": "07319cbd148c465329a8eec37ae0d2002d2bcd6b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5d46bcc0e40c51b8acbf708971c2ecc51c57c0a3", "patch": "@@ -652,44 +652,6 @@ pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     false\n }\n \n-/**\n- * Search for the first element that matches a given predicate within a range\n- *\n- * Apply function `f` to each element of `v` within the range\n- * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is returned.\n- */\n-pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                      f: &fn(t: &T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| copy v[*i])\n-}\n-\n-/**\n- * Search for the last element that matches a given predicate\n- *\n- * Apply function `f` to each element of `v` in reverse order. When function\n- * `f` returns true then an option containing the element is returned. If `f`\n- * matches no elements then none is returned.\n- */\n-pub fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n-    rfind_between(v, 0u, v.len(), f)\n-}\n-\n-/**\n- * Search for the last element that matches a given predicate within a range\n- *\n- * Apply function `f` to each element of `v` in reverse order within the range\n- * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is return.\n- */\n-pub fn rfind_between<T:Copy>(v: &[T],\n-                             start: uint,\n-                             end: uint,\n-                             f: &fn(t: &T) -> bool)\n-                          -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| copy v[*i])\n-}\n-\n /// Find the first index containing a matching value\n pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     v.iter().position_(|y| *x == *y)\n@@ -1422,7 +1384,6 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n-    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n@@ -1441,18 +1402,6 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n         filtered(*self, f)\n     }\n \n-    /**\n-     * Search for the last element that matches a given predicate\n-     *\n-     * Apply function `f` to each element of `v` in reverse order. When\n-     * function `f` returns true then an option containing the element is\n-     * returned. If `f` matches no elements then none is returned.\n-     */\n-    #[inline]\n-    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n-        rfind(*self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -2964,34 +2913,6 @@ mod tests {\n         assert!(position_between(v, 4u, 4u, f).is_none());\n     }\n \n-    #[test]\n-    fn test_find_between() {\n-        assert!(find_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(find_between(v, 0u, 0u, f).is_none());\n-        assert!(find_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(find_between(v, 0u, 2u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 0u, 3u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 0u, 4u, f), Some((1, 'b')));\n-\n-        assert!(find_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(find_between(v, 1u, 2u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 1u, 3u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 1u, 4u, f), Some((1, 'b')));\n-\n-        assert!(find_between(v, 2u, 2u, f).is_none());\n-        assert!(find_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(find_between(v, 2u, 4u, f), Some((3, 'b')));\n-\n-        assert!(find_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(find_between(v, 3u, 4u, f), Some((3, 'b')));\n-\n-        assert!(find_between(v, 4u, 4u, f).is_none());\n-    }\n-\n     #[test]\n     fn test_rposition() {\n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n@@ -3030,46 +2951,6 @@ mod tests {\n         assert!(rposition_between(v, 4u, 4u, f).is_none());\n     }\n \n-    #[test]\n-    fn test_rfind() {\n-        assert!(rfind([], f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert_eq!(rfind(v, f), Some((3, 'b')));\n-        assert!(rfind(v, g).is_none());\n-    }\n-\n-    #[test]\n-    fn test_rfind_between() {\n-        assert!(rfind_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(rfind_between(v, 0u, 0u, f).is_none());\n-        assert!(rfind_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(rfind_between(v, 0u, 2u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 0u, 3u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 0u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(rfind_between(v, 1u, 2u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 1u, 3u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 1u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 2u, 2u, f).is_none());\n-        assert!(rfind_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(rfind_between(v, 2u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(rfind_between(v, 3u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 4u, 4u, f).is_none());\n-    }\n-\n     #[test]\n     fn test_bsearch_elem() {\n         assert_eq!(bsearch_elem([1,2,3,4,5], &5), Some(4));"}]}