{"sha": "7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNmE0Y2M5OGJlNmU4MDkxMDU0ZTg0YmQwOTVmY2IwZDVlMGU4ZTc=", "commit": {"author": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-10-26T21:53:17Z"}, "committer": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-10-26T21:53:17Z"}, "message": "simplify shootout-reverse-complement.rs\n\nSimpler, safer and shorter, in the same spirit of the current version, and the\nsame performances.", "tree": {"sha": "634758378cc25e7c32f2d85c9ef434953f994380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/634758378cc25e7c32f2d85c9ef434953f994380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7", "html_url": "https://github.com/rust-lang/rust/commit/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7/comments", "author": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f037452447f5f46deb26e1c483fe88fb51a19198", "url": "https://api.github.com/repos/rust-lang/rust/commits/f037452447f5f46deb26e1c483fe88fb51a19198", "html_url": "https://github.com/rust-lang/rust/commit/f037452447f5f46deb26e1c483fe88fb51a19198"}], "stats": {"total": 288, "additions": 109, "deletions": 179}, "files": [{"sha": "fc7ba2e4369381936e242065765ccca9798dcc7f", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 109, "deletions": 179, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=7c6a4cc98be6e8091054e84bd095fcb0d5e0e8e7", "patch": "@@ -38,185 +38,93 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-// ignore-android doesn't terminate?\n+// ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax, asm, if_let, tuple_indexing)]\n+#![feature(slicing_syntax, unboxed_closures, overloaded_calls)]\n \n extern crate libc;\n \n use std::io::stdio::{stdin_raw, stdout_raw};\n-use std::sync::{Future};\n use std::num::{div_rem};\n use std::ptr::{copy_memory};\n use std::io::{IoResult, EndOfFile};\n-use std::slice::raw::{mut_buf_as_slice};\n \n-use shared_memory::{SharedMemory};\n-\n-mod tables {\n-    use std::sync::{Once, ONCE_INIT};\n-\n-    /// Lookup tables.\n-    static mut CPL16: [u16, ..1 << 16] = [0, ..1 << 16];\n-    static mut CPL8:  [u8,  ..1 << 8]  = [0, ..1 << 8];\n-\n-    /// Generates the tables.\n-    pub fn get() -> Tables {\n-        /// To make sure we initialize the tables only once.\n-        static INIT: Once = ONCE_INIT;\n-        INIT.doit(|| {\n-            unsafe {\n-                for i in range(0, 1 << 8) {\n-                    CPL8[i] = match i as u8 {\n-                        b'A' | b'a' => b'T',\n-                        b'C' | b'c' => b'G',\n-                        b'G' | b'g' => b'C',\n-                        b'T' | b't' => b'A',\n-                        b'U' | b'u' => b'A',\n-                        b'M' | b'm' => b'K',\n-                        b'R' | b'r' => b'Y',\n-                        b'W' | b'w' => b'W',\n-                        b'S' | b's' => b'S',\n-                        b'Y' | b'y' => b'R',\n-                        b'K' | b'k' => b'M',\n-                        b'V' | b'v' => b'B',\n-                        b'H' | b'h' => b'D',\n-                        b'D' | b'd' => b'H',\n-                        b'B' | b'b' => b'V',\n-                        b'N' | b'n' => b'N',\n-                        i => i,\n-                    };\n-                }\n-\n-                for (i, v) in CPL16.iter_mut().enumerate() {\n-                    *v = *CPL8.unsafe_get(i & 255) as u16 << 8 |\n-                         *CPL8.unsafe_get(i >> 8)  as u16;\n-                }\n-            }\n-        });\n-        Tables { _dummy: () }\n-    }\n-\n-    /// Accessor for the static arrays.\n-    ///\n-    /// To make sure that the tables can't be accessed without having been initialized.\n-    pub struct Tables {\n-        _dummy: ()\n-    }\n-\n-    impl Tables {\n-        /// Retreives the complement for `i`.\n-        pub fn cpl8(self, i: u8) -> u8 {\n-            // Not really unsafe.\n-            unsafe { CPL8[i as uint] }\n-        }\n-\n-        /// Retreives the complement for `i`.\n-        pub fn cpl16(self, i: u16) -> u16 {\n-            unsafe { CPL16[i as uint] }\n-        }\n-    }\n+struct Tables {\n+    table8: [u8, ..1 << 8],\n+    table16: [u16, ..1 << 16]\n }\n \n-mod shared_memory {\n-    use std::sync::{Arc};\n-    use std::mem::{transmute};\n-    use std::raw::{Slice};\n-\n-    /// Structure for sharing disjoint parts of a vector mutably across tasks.\n-    pub struct SharedMemory {\n-        ptr: Arc<Vec<u8>>,\n-        start: uint,\n-        len: uint,\n-    }\n-\n-    impl SharedMemory {\n-        pub fn new(ptr: Vec<u8>) -> SharedMemory {\n-            let len = ptr.len();\n-            SharedMemory {\n-                ptr: Arc::new(ptr),\n-                start: 0,\n-                len: len,\n-            }\n+impl Tables {\n+    fn new() -> Tables {\n+        let mut table8 = [0, ..1 << 8];\n+        for (i, v) in table8.iter_mut().enumerate() {\n+            *v = Tables::computed_cpl8(i as u8);\n         }\n-\n-        pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-            unsafe {\n-                transmute(Slice {\n-                    data: self.ptr.as_ptr().offset(self.start as int) as *const u8,\n-                    len: self.len,\n-                })\n-            }\n+        let mut table16 = [0, ..1 << 16];\n+        for (i, v) in table16.iter_mut().enumerate() {\n+            // assume little endian\n+            *v = table8[i & 255] as u16 << 8 |\n+                 table8[i >> 8]  as u16;\n         }\n+        Tables { table8: table8, table16: table16 }\n+    }\n \n-        pub fn len(&self) -> uint {\n-            self.len\n+    fn computed_cpl8(c: u8) -> u8 {\n+        match c {\n+            b'A' | b'a' => b'T',\n+            b'C' | b'c' => b'G',\n+            b'G' | b'g' => b'C',\n+            b'T' | b't' => b'A',\n+            b'U' | b'u' => b'A',\n+            b'M' | b'm' => b'K',\n+            b'R' | b'r' => b'Y',\n+            b'W' | b'w' => b'W',\n+            b'S' | b's' => b'S',\n+            b'Y' | b'y' => b'R',\n+            b'K' | b'k' => b'M',\n+            b'V' | b'v' => b'B',\n+            b'H' | b'h' => b'D',\n+            b'D' | b'd' => b'H',\n+            b'B' | b'b' => b'V',\n+            b'N' | b'n' => b'N',\n+            i => i,\n         }\n+    }\n \n-        pub fn split_at(self, mid: uint) -> (SharedMemory, SharedMemory) {\n-            assert!(mid <= self.len);\n-            let left = SharedMemory {\n-                ptr: self.ptr.clone(),\n-                start: self.start,\n-                len: mid,\n-            };\n-            let right = SharedMemory {\n-                ptr: self.ptr,\n-                start: self.start + mid,\n-                len: self.len - mid,\n-            };\n-            (left, right)\n-        }\n+    /// Retreives the complement for `i`.\n+    fn cpl8(&self, i: u8) -> u8 {\n+        self.table8[i as uint]\n+    }\n \n-        /// Resets the object so that it covers the whole range of the contained vector.\n-        ///\n-        /// You must not call this method if `self` is not the only reference to the\n-        /// shared memory.\n-        ///\n-        /// FIXME: If `Arc` had a method to check if the reference is unique, then we\n-        /// wouldn't need the `unsafe` here.\n-        ///\n-        /// FIXME: If `Arc` had a method to unwrap the contained value, then we could\n-        /// simply unwrap here.\n-        pub unsafe fn reset(self) -> SharedMemory {\n-            let len = self.ptr.len();\n-            SharedMemory {\n-                ptr: self.ptr,\n-                start: 0,\n-                len: len,\n-            }\n-        }\n+    /// Retreives the complement for `i`.\n+    fn cpl16(&self, i: u16) -> u16 {\n+        self.table16[i as uint]\n     }\n }\n \n-\n /// Reads all remaining bytes from the stream.\n fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n+    // FIXME: this method is a temporary workaround for jemalloc on\n+    // linux.  Replace it with Reader::read_to_end() once the jemalloc\n+    // issue has been fixed.\n     const CHUNK: uint = 64 * 1024;\n \n-    let mut vec = Vec::with_capacity(1024 * 1024);\n+    let mut vec = Vec::with_capacity(CHUNK);\n     loop {\n+        // workaround: very fast growing\n         if vec.capacity() - vec.len() < CHUNK {\n             let cap = vec.capacity();\n             let mult = if cap < 256 * 1024 * 1024 {\n-                // FIXME (mahkoh): Temporary workaround for jemalloc on linux. Replace\n-                // this by 2x once the jemalloc preformance issue has been fixed.\n                 16\n             } else {\n                 2\n             };\n             vec.reserve_exact(mult * cap);\n         }\n-        unsafe {\n-            let ptr = vec.as_mut_ptr().offset(vec.len() as int);\n-            match mut_buf_as_slice(ptr, CHUNK, |s| r.read(s)) {\n-                Ok(n) => {\n-                    let len = vec.len();\n-                    vec.set_len(len + n);\n-                },\n-                Err(ref e) if e.kind == EndOfFile => break,\n-                Err(e) => return Err(e),\n-            }\n+        match r.push_at_least(1, CHUNK, &mut vec) {\n+            Ok(_) => {}\n+            Err(ref e) if e.kind == EndOfFile => break,\n+            Err(e) => return Err(e)\n         }\n     }\n     Ok(vec)\n@@ -225,11 +133,8 @@ fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n /// Finds the first position at which `b` occurs in `s`.\n fn memchr(h: &[u8], n: u8) -> Option<uint> {\n     use libc::{c_void, c_int, size_t};\n-    extern {\n-        fn memchr(h: *const c_void, n: c_int, s: size_t) -> *mut c_void;\n-    }\n     let res = unsafe {\n-        memchr(h.as_ptr() as *const c_void, n as c_int, h.len() as size_t)\n+        libc::memchr(h.as_ptr() as *const c_void, n as c_int, h.len() as size_t)\n     };\n     if res.is_null() {\n         None\n@@ -238,13 +143,36 @@ fn memchr(h: &[u8], n: u8) -> Option<uint> {\n     }\n }\n \n+/// A mutable iterator over DNA sequences\n+struct MutDnaSeqs<'a> { s: &'a mut [u8] }\n+fn mut_dna_seqs<'a>(s: &'a mut [u8]) -> MutDnaSeqs<'a> {\n+    MutDnaSeqs { s: s }\n+}\n+impl<'a> Iterator<&'a mut [u8]> for MutDnaSeqs<'a> {\n+    fn next(&mut self) -> Option<&'a mut [u8]> {\n+        let tmp = std::mem::replace(&mut self.s, &mut []);\n+        let tmp = match memchr(tmp, b'\\n') {\n+            Some(i) => tmp.slice_from_mut(i + 1),\n+            None => return None,\n+        };\n+        let (seq, tmp) = match memchr(tmp, b'>') {\n+            Some(i) => tmp.split_at_mut(i),\n+            None => {\n+                let len = tmp.len();\n+                tmp.split_at_mut(len)\n+            }\n+        };\n+        self.s = tmp;\n+        Some(seq)\n+    }\n+}\n+\n /// Length of a normal line without the terminating \\n.\n const LINE_LEN: uint = 60;\n \n /// Compute the reverse complement.\n-fn reverse_complement(mut view: SharedMemory, tables: tables::Tables) {\n-    // Drop the last newline\n-    let seq = view.as_mut_slice().init_mut();\n+fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n+    let seq = seq.init_mut();// Drop the last newline\n     let len = seq.len();\n     let off = LINE_LEN - len % (LINE_LEN + 1);\n     let mut i = LINE_LEN;\n@@ -290,34 +218,36 @@ fn reverse_complement(mut view: SharedMemory, tables: tables::Tables) {\n     }\n }\n \n-fn main() {\n-    let mut data = SharedMemory::new(read_to_end(&mut stdin_raw()).unwrap());\n-    let tables = tables::get();\n-\n-    let mut futures = vec!();\n-    loop {\n-        let (_, mut tmp_data) = match memchr(data.as_mut_slice(), b'\\n') {\n-            Some(i) => data.split_at(i + 1),\n-            _ => break,\n-        };\n-        let (view, tmp_data) = match memchr(tmp_data.as_mut_slice(), b'>') {\n-            Some(i) => tmp_data.split_at(i),\n-            None => {\n-                let len = tmp_data.len();\n-                tmp_data.split_at(len)\n-            },\n-        };\n-        futures.push(Future::spawn(proc() reverse_complement(view, tables)));\n-        data = tmp_data;\n-    }\n-\n-    for f in futures.iter_mut() {\n-        f.get();\n+/// Executes a closure in parallel over the given iterator over mutable slice.\n+/// The closure `f` is run in parallel with an element of `iter`.\n+fn parallel<'a, I, T, F>(mut iter: I, f: F)\n+        where T: Send + Sync,\n+              I: Iterator<&'a mut [T]>,\n+              F: Fn(&'a mut [T]) + Sync {\n+    use std::mem;\n+    use std::raw::Repr;\n+\n+    let (tx, rx) = channel();\n+    for chunk in iter {\n+        let tx = tx.clone();\n+\n+        // Need to convert `f` and `chunk` to something that can cross the task\n+        // boundary.\n+        let f = &f as *const F as *const uint;\n+        let raw = chunk.repr();\n+        spawn(proc() {\n+            let f = f as *const F;\n+            unsafe { (*f)(mem::transmute(raw)) }\n+            drop(tx)\n+        });\n     }\n+    drop(tx);\n+    for () in rx.iter() {}\n+}\n \n-    // Not actually unsafe. If Arc had a way to check uniqueness then we could do that in\n-    // `reset` and it would tell us that, yes, it is unique at this point.\n-    data = unsafe { data.reset() };\n-\n+fn main() {\n+    let mut data = read_to_end(&mut stdin_raw()).unwrap();\n+    let tables = &Tables::new();\n+    parallel(mut_dna_seqs(data[mut]), |&: seq| reverse_complement(seq, tables));\n     stdout_raw().write(data.as_mut_slice()).unwrap();\n }"}]}