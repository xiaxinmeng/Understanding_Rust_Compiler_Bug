{"sha": "cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMmY0M2NiZjQzMzJmZmU5MGI4OTYzZjFiZGJhYTg1ZmViZTFiOTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T15:57:23Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T15:57:23Z"}, "message": "Stop normalizing patterns\n\nThe check for whether a pat_ident is a variant or a binding\nis simple and fast. Normalizing patterns again and again is\nslow and error-prone (several places were forgetting to do it).", "tree": {"sha": "a21b8f284989f9a3fc19fbbff8f971741b2b14d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21b8f284989f9a3fc19fbbff8f971741b2b14d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "html_url": "https://github.com/rust-lang/rust/commit/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3b655f8e3f1a9e84cd6dd4a1d1d2525d7fac7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b655f8e3f1a9e84cd6dd4a1d1d2525d7fac7e7", "html_url": "https://github.com/rust-lang/rust/commit/a3b655f8e3f1a9e84cd6dd4a1d1d2525d7fac7e7"}], "stats": {"total": 605, "additions": 285, "deletions": 320}, "files": [{"sha": "4a04bbff6ffb77a1692823b2fd7f16cc2e553ad1", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -332,7 +332,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     for a: ast::arm in arms {\n         let new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n-        let pat_id_map = pat_util::pat_id_map(cx.tcx, a.pats[0]);\n+        let pat_id_map = pat_util::pat_id_map(cx.tcx.def_map, a.pats[0]);\n         type info = {\n             id: node_id,\n             mutable unsafe_tys: [unsafe_ty],\n@@ -596,13 +596,15 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n     -> [pattern_root] {\n     fn walk(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n-        alt normalize_pat(tcx, pat).node {\n-          ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) {}\n-          ast::pat_ident(nm, sub) {\n+        alt pat.node {\n+          ast::pat_ident(nm, sub)\n+          if !pat_util::pat_is_variant(tcx.def_map, pat) {\n             set += [{id: pat.id, name: path_to_ident(nm), mutbl: mutbl,\n                         span: pat.span}];\n             alt sub { some(p) { walk(tcx, mutbl, p, set); } _ {} }\n           }\n+          ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n+          ast::pat_ident(_, _) {}\n           ast::pat_enum(_, ps) | ast::pat_tup(ps) {\n             for p in ps { walk(tcx, mutbl, p, set); }\n           }"}, {"sha": "aad8afe0b0c3968e143ad7f08f31582c9052f227", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -62,19 +62,25 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-fn map_local(loc: @local, cx: ctx, v: vt) {\n-    pat_util::pat_bindings(loc.node.pat) {|p_id, _s, _p|\n-        cx.map.insert(p_id, node_local(cx.local_id));\n-        cx.local_id += 1u;\n+fn number_pat(cx: ctx, pat: @pat) {\n+    pat_util::walk_pat(pat) {|p|\n+        alt p.node {\n+          pat_ident(_, _) {\n+            cx.map.insert(p.id, node_local(cx.local_id));\n+            cx.local_id += 1u;\n+          }\n+          _ {}\n+        }\n     };\n+}\n+\n+fn map_local(loc: @local, cx: ctx, v: vt) {\n+    number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n fn map_arm(arm: arm, cx: ctx, v: vt) {\n-    pat_util::pat_bindings(arm.pats[0]) {|p_id, _s, _p|\n-        cx.map.insert(p_id, node_local(cx.local_id));\n-        cx.local_id += 1u;\n-    };\n+    number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n "}, {"sha": "894aa6af3710828b8c784a32ad217ecc60d45af7", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -10,19 +10,18 @@ import middle::ty;\n import middle::ty::*;\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    let v =\n-        @{visit_expr: bind check_expr(tcx, _, _, _),\n-          visit_local: bind check_local(tcx, _, _, _)\n-             with *visit::default_visitor::<()>()};\n-    visit::visit_crate(*crate, (), visit::mk_vt(v));\n+    visit::visit_crate(*crate, (), visit::mk_vt(@{\n+        visit_expr: bind check_expr(tcx, _, _, _),\n+        visit_local: bind check_local(tcx, _, _, _)\n+        with *visit::default_visitor::<()>()\n+    }));\n     tcx.sess.abort_if_errors();\n }\n \n fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     alt ex.node {\n       expr_alt(scrut, arms, mode) {\n-        let arms = pat_util::normalize_arms(tcx, arms);\n         check_arms(tcx, arms);\n         /* Check for exhaustiveness */\n         if mode == alt_exhaustive {\n@@ -66,8 +65,6 @@ fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-// Precondition: patterns have been normalized\n-// (not checked statically yet)\n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n     if pats.len() == 0u {\n         tcx.sess.span_err(sp, \"non-exhaustive patterns\");\n@@ -216,11 +213,13 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n \n     alt a.node {\n       pat_ident(_, some(p)) { pattern_supersedes(tcx, p, b) }\n-      pat_wild | pat_ident(_, none) { true }\n-      pat_lit(la) {\n-        alt b.node {\n-          pat_lit(lb) { lit_expr_eq(la, lb) }\n-          _ { false }\n+      pat_wild { true }\n+      pat_ident(_, none) {\n+        let opt_def_a = tcx.def_map.find(a.id);\n+        alt opt_def_a {\n+          some(def_variant(_, _)) { opt_def_a == tcx.def_map.find(b.id) }\n+          // This is a binding\n+          _ { true }\n         }\n       }\n       pat_enum(va, suba) {\n@@ -256,6 +255,12 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n           _ { pattern_supersedes(tcx, suba, b) }\n         }\n       }\n+      pat_lit(la) {\n+        alt b.node {\n+          pat_lit(lb) { lit_expr_eq(la, lb) }\n+          _ { false }\n+        }\n+      }\n       pat_range(begina, enda) {\n         alt b.node {\n           pat_lit(lb) {\n@@ -281,12 +286,19 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n }\n \n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n-    alt normalize_pat(tcx, pat).node {\n+    alt tcx.def_map.find(pat.id) {\n+      some(def_variant(enum_id, var_id)) {\n+        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u { ret true; }\n+      }\n+      _ {}\n+    }\n+\n+    alt pat.node {\n       pat_box(sub) | pat_uniq(sub) | pat_ident(_, some(sub)) {\n         is_refutable(tcx, sub)\n       }\n       pat_wild | pat_ident(_, none) { false }\n-      pat_lit(_) { true }\n+      pat_lit(_) | pat_range(_, _) { true }\n       pat_rec(fields, _) {\n         for it: field_pat in fields {\n             if is_refutable(tcx, it.pat) { ret true; }\n@@ -298,12 +310,9 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n         false\n       }\n       pat_enum(_, args) {\n-        let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if vec::len(*ty::enum_variants(tcx, vdef.enm)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         false\n       }\n-      pat_range(_, _) { true }\n     }\n }\n "}, {"sha": "1a6856e36bfdab9fbedacb04c5f84ab37ad2c13b", "filename": "src/comp/middle/pat_util.rs", "status": "modified", "additions": 42, "deletions": 91, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fpat_util.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -5,115 +5,66 @@ import syntax::fold;\n import syntax::fold::*;\n import syntax::codemap::span;\n \n-export normalize_arms;\n-export normalize_pat;\n-export normalize_pat_def_map;\n-export pat_binding_ids;\n-export pat_bindings;\n-export pat_id_map;\n+export walk_pat;\n+export pat_binding_ids, pat_bindings, pat_id_map;\n+export pat_is_variant;\n export path_to_ident;\n \n-fn normalize_pat_def_map(dm: resolve::def_map, p: @pat) -> @pat {\n-  // have to do it the hard way b/c ast fold doesn't pass around\n-  // node IDs. bother.\n-  alt p.node {\n-      pat_wild { p }\n-      pat_ident(_, none) { normalize_one(dm, p) }\n-      pat_ident(q, some(r)) {\n-        @{node: pat_ident(q, some(normalize_pat_def_map(dm, r)))\n-            with *p}\n-      }\n-      pat_enum(a_path, subs) {\n-        @{node: pat_enum(a_path,\n-           vec::map(subs, {|p| normalize_pat_def_map(dm, p)})) with *p}\n-      }\n-      pat_rec(field_pats, b) {\n-        @{node: pat_rec(vec::map(field_pats,\n-           {|fp| {pat: normalize_pat_def_map(dm, fp.pat) with fp}}), b)\n-            with *p}\n-      }\n-      pat_tup(subs) {\n-        @{node: pat_tup(vec::map(subs, {|p| normalize_pat_def_map(dm, p)}))\n-            with *p}\n-      }\n-      pat_box(q) {\n-        @{node: pat_box(normalize_pat_def_map(dm, q))\n-            with *p}\n-      }\n-      pat_uniq(q) {\n-        @{node: pat_uniq(normalize_pat_def_map(dm, q))\n-            with *p}\n-      }\n-      pat_lit(_) { p }\n-      pat_range(_,_) { p }\n-    }\n-}\n-\n-fn normalize_one(dm: resolve::def_map, p: @pat) -> @pat {\n-    alt dm.find(p.id) {\n-        some(d) {\n-          alt p.node {\n-              pat_ident(enum_path, _) { @{id: p.id,\n-                    node: pat_enum(enum_path, []),\n-                    span: p.span} }\n-              _ { p }\n-          }\n-        }\n-        none { p }\n-    }\n-}\n-\n-fn normalize_pat(tcx: ty::ctxt, p: @pat) -> @pat {\n-  normalize_pat_def_map(tcx.def_map, p)\n-}\n-\n-fn normalize_arms(tcx: ty::ctxt, arms:[arm]) -> [arm] {\n-      vec::map(arms, {|a|\n-            {pats:\n-              vec::map(a.pats, {|p|\n-                    pat_util::normalize_pat(tcx, p)})\n-                with a}})\n-}\n-\n type pat_id_map = std::map::hashmap<str, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n-fn pat_id_map(tcx: ty::ctxt, pat: @pat) -> pat_id_map {\n-    let map = std::map::new_str_hash::<node_id>();\n-    pat_bindings(normalize_pat(tcx, pat)) {|p_id, _s, n|\n+fn pat_id_map(dm: resolve::def_map, pat: @pat) -> pat_id_map {\n+    let map = std::map::new_str_hash();\n+    pat_bindings(dm, pat) {|p_id, _s, n|\n       map.insert(path_to_ident(n), p_id);\n     };\n     ret map;\n }\n \n+fn pat_is_variant(dm: resolve::def_map, pat: @pat) -> bool {\n+    alt pat.node {\n+      pat_enum(_, _) { true }\n+      pat_ident(_, none) {\n+        alt dm.find(pat.id) {\n+          some(def_variant(_, _)) { true }\n+          _ { false }\n+        }\n+      }\n+      _ { false }\n+    }\n+}\n+\n // This does *not* normalize. The pattern should be already normalized\n // if you want to get a normalized pattern out of it.\n // Could return a constrained type in order to express that (future work)\n-fn pat_bindings(pat: @pat, it: fn(node_id, span, @path)) {\n-  alt pat.node {\n-      pat_ident(pth, option::none) { it(pat.id, pat.span, pth); }\n-      pat_ident(pth, option::some(sub)) { it(pat.id, pat.span, pth);\n-        pat_bindings(sub, it); }\n-      pat_enum(_, sub) { for p in sub { pat_bindings(p, it); } }\n-      pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n-      pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n-      pat_box(sub) { pat_bindings(sub, it); }\n-      pat_uniq(sub) { pat_bindings(sub, it); }\n-      pat_wild | pat_lit(_) | pat_range(_, _) { }\n+fn pat_bindings(dm: resolve::def_map, pat: @pat,\n+                it: fn(node_id, span, @path)) {\n+    walk_pat(pat) {|p|\n+        alt p.node {\n+          pat_ident(pth, _) if !pat_is_variant(dm, p) {\n+            it(p.id, p.span, pth);\n+          }\n+          _ {}\n+        }\n     }\n }\n \n-fn pat_binding_ids(pat: @pat) -> [node_id] {\n+fn walk_pat(pat: @pat, it: fn(@pat)) {\n+    it(pat);\n+    alt pat.node {\n+      pat_ident(pth, some(p)) { walk_pat(p, it); }\n+      pat_rec(fields, _) { for f in fields { walk_pat(f.pat, it); } }\n+      pat_enum(_, s) | pat_tup(s) { for p in s { walk_pat(p, it); } }\n+      pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n+      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, none) {}\n+    }\n+}\n+\n+fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id] {\n     let found = [];\n-    pat_bindings(pat) {|b_id, _sp, _pt| found += [b_id]; };\n+    pat_bindings(dm, pat) {|b_id, _sp, _pt| found += [b_id]; };\n     ret found;\n }\n \n-fn path_to_ident(p: @path) -> ident {\n-    alt vec::last(p.node.idents) {\n-        none { // sigh\n-          fail \"Malformed path\"; }\n-      some(i) { ret i; }\n-    }\n-}\n+fn path_to_ident(p: @path) -> ident { vec::last_total(p.node.idents) }"}, {"sha": "413821894a949506019f98005867aec6100f4559", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -624,7 +624,7 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // a single identifier unambiguous (does the pattern \"foo\" refer\n     // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n-      pat_ident(an_ident,_) {\n+      pat_ident(an_ident, _) {\n           // Be sure to pass ns_an_enum to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n           alt lookup_in_scope(*e, sc, loc.span,\n@@ -1139,8 +1139,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<def_id> {\n     let found = none;\n \n-    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, pat))\n-     {|p_id, _sp, n|\n+    pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n         if str::eq(path_to_ident(n), name)\n                     { found = some(local_def(p_id)); }\n     };\n@@ -1776,7 +1775,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n }\n \n fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n-    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, p)) {|_i, p_sp, n|\n+    pat_util::pat_bindings(e.def_map, p) {|_i, p_sp, n|\n        add_name(ch, p_sp, path_to_ident(n));\n     };\n }\n@@ -1823,13 +1822,12 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n                 for loc in locs {\n-                     pat_util::pat_bindings\n-                        (normalize_pat_def_map(e.def_map, loc.node.pat))\n-                            {|_i, p_sp, n|\n-                            let ident = path_to_ident(n);\n-                            add_name(local_values, p_sp, ident);\n-                            check_name(values, p_sp, ident);\n-                          };\n+                     pat_util::pat_bindings(e.def_map, loc.node.pat)\n+                         {|_i, p_sp, n|\n+                         let ident = path_to_ident(n);\n+                         add_name(local_values, p_sp, ident);\n+                         check_name(values, p_sp, ident);\n+                     };\n                 }\n               }\n               ast::decl_item(it) {"}, {"sha": "d461781e7192eaf42d9e06cb767d9237c6a6752d", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 82, "deletions": 91, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -11,6 +11,7 @@ import syntax::ast::def_id;\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n import back::abi;\n+import resolve::def_map;\n \n import common::*;\n \n@@ -63,9 +64,9 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(ccx: crate_ctxt, pat_id: ast::node_id) -> opt {\n-    let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n-    let variants = ty::enum_variants(ccx.tcx, vdef.enm);\n+fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n+    let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n+    let variants = ty::enum_variants(tcx, vdef.enm);\n     for v: ty::variant_info in *variants {\n         if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n@@ -116,73 +117,71 @@ fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n     result\n }\n \n-type enter_pat = fn@(@ast::pat) -> option<[@ast::pat]>;\n+type enter_pat = fn(@ast::pat) -> option<[@ast::pat]>;\n \n-fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n+fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n+               e: enter_pat) -> match {\n     let result = [];\n     for br: match_branch in m {\n         alt e(br.pats[col]) {\n           some(sub) {\n             let pats = sub + vec::slice(br.pats, 0u, col) +\n                 vec::slice(br.pats, col + 1u, br.pats.len());\n-            let new_br = @{pats: pats,\n-                           bound: alt br.pats[col].node {\n-                             ast::pat_ident(name, none) {\n-                                 br.bound + [{ident: path_to_ident(name),\n-                                              val: val}]\n-                             }\n-                             _ { br.bound }\n-                           } with *br};\n-            result += [new_br];\n+            let self = br.pats[col];\n+            let bound = alt self.node {\n+              ast::pat_ident(name, none) if !pat_is_variant(dm, self) {\n+                br.bound + [{ident: path_to_ident(name), val: val}]\n+              }\n+              _ { br.bound }\n+            };\n+            result += [@{pats: pats, bound: bound with *br}];\n           }\n           none { }\n         }\n     }\n     ret result;\n }\n \n-fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n-    fn matches_always(p: @ast::pat) -> bool {\n+fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n+    enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-                ast::pat_wild | ast::pat_rec(_, _) |\n-                ast::pat_ident(_, none) | ast::pat_tup(_) { true }\n-                _ { false }\n+          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some([]) }\n+          ast::pat_ident(_, none) if !pat_is_variant(dm, p) {\n+            some([])\n+          }\n+          _ { none }\n         }\n     }\n-    fn e(p: @ast::pat) -> option<[@ast::pat]> {\n-        ret if matches_always(p) { some([]) } else { none };\n-    }\n-    ret enter_match(m, col, val, e);\n }\n \n-fn enter_opt(ccx: crate_ctxt, m: match, opt: opt, col: uint, enum_size: uint,\n-             val: ValueRef) -> match {\n+fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n+             variant_size: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(ccx: crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n-         p: @ast::pat) -> option<[@ast::pat]> {\n+    enter_match(tcx.def_map, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_enum(ctor, subpats) {\n-            ret if opt_eq(variant_opt(ccx, p.id), opt) {\n-                    some(subpats)\n-                } else { none };\n+          ast::pat_enum(_, subpats) {\n+            if opt_eq(variant_opt(tcx, p.id), opt) { some(subpats) }\n+            else { none }\n+          }\n+          ast::pat_ident(_, none) if pat_is_variant(tcx.def_map, p) {\n+            if opt_eq(variant_opt(tcx, p.id), opt) { some([]) }\n+            else { none }\n           }\n           ast::pat_lit(l) {\n-            ret if opt_eq(lit(l), opt) { some([]) } else { none };\n+            if opt_eq(lit(l), opt) { some([]) } else { none }\n           }\n           ast::pat_range(l1, l2) {\n-            ret if opt_eq(range(l1, l2), opt) { some([]) } else { none };\n+            if opt_eq(range(l1, l2), opt) { some([]) } else { none }\n           }\n-          _ { ret some(vec::init_elt(size, dummy)); }\n+          _ { some(vec::init_elt(variant_size, dummy)) }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(ccx, dummy, opt, enum_size, _));\n }\n \n-fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n-   match {\n+fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident],\n+             val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, fields: [ast::ident], p: @ast::pat) ->\n-       option<[@ast::pat]> {\n+    enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let pats = [];\n@@ -193,65 +192,63 @@ fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n                 }\n                 pats += [pat];\n             }\n-            ret some(pats);\n+            some(pats)\n           }\n-          _ { ret some(vec::init_elt(fields.len(), dummy)); }\n+          _ { some(vec::init_elt(fields.len(), dummy)) }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(dummy, fields, _));\n }\n \n-fn enter_tup(m: match, col: uint, val: ValueRef, n_elts: uint) -> match {\n+fn enter_tup(dm: def_map, m: match, col: uint, val: ValueRef,\n+             n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, n_elts: uint, p: @ast::pat) ->\n-       option<[@ast::pat]> {\n+    enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_tup(elts) { ret some(elts); }\n-          _ { ret some(vec::init_elt(n_elts, dummy)); }\n+          ast::pat_tup(elts) { some(elts) }\n+          _ { some(vec::init_elt(n_elts, dummy)) }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(dummy, n_elts, _));\n }\n \n-fn enter_box(m: match, col: uint, val: ValueRef) -> match {\n+fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, p: @ast::pat) -> option<[@ast::pat]> {\n+    enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_box(sub) { ret some([sub]); }\n-          _ { ret some([dummy]); }\n+          ast::pat_box(sub) { some([sub]) }\n+          _ { some([dummy]) }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n-fn enter_uniq(m: match, col: uint, val: ValueRef) -> match {\n+fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, p: @ast::pat) -> option<[@ast::pat]> {\n+    enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_uniq(sub) { ret some([sub]); }\n-          _ { ret some([dummy]); }\n+          ast::pat_uniq(sub) { some([sub]) }\n+          _ { some([dummy]) }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n fn get_options(ccx: crate_ctxt, m: match, col: uint) -> [opt] {\n     fn add_to_set(&set: [opt], val: opt) {\n-        for l: opt in set { if opt_eq(l, val) { ret; } }\n+        for l in set { if opt_eq(l, val) { ret; } }\n         set += [val];\n     }\n \n     let found = [];\n-    for br: match_branch in m {\n-        alt br.pats[col].node {\n-          ast::pat_lit(l) { add_to_set(found, lit(l)); }\n-          ast::pat_range(l1, l2) {\n-            add_to_set(found, range(l1, l2));\n-          }\n-          ast::pat_enum(_, _) {\n-            add_to_set(found, variant_opt(ccx, br.pats[col].id));\n-          }\n-          _ { }\n+    for br in m {\n+        let cur = br.pats[col];\n+        if pat_is_variant(ccx.tcx.def_map, cur) {\n+            add_to_set(found, variant_opt(ccx.tcx, br.pats[col].id));\n+        } else {\n+            alt cur.node {\n+              ast::pat_lit(l) { add_to_set(found, lit(l)); }\n+              ast::pat_range(l1, l2) {\n+                add_to_set(found, range(l1, l2));\n+              }\n+              _ {}\n+            }\n         }\n     }\n     ret found;\n@@ -362,7 +359,7 @@ fn pick_col(m: match) -> uint {\n \n fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n                     &exits: [exit_node]) {\n-    let bcx = bcx;\n+    let bcx = bcx, tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u { Br(bcx, f()); ret; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n@@ -422,7 +419,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n             rec_vals += [r.val];\n             bcx = r.bcx;\n         }\n-        compile_submatch(bcx, enter_rec(m, col, rec_fields, val),\n+        compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n                          rec_vals + vals_left, f, exits);\n         ret;\n     }\n@@ -440,7 +437,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n             bcx = r.bcx;\n             i += 1u;\n         }\n-        compile_submatch(bcx, enter_tup(m, col, val, n_tup_elts),\n+        compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n                          tup_vals + vals_left, f, exits);\n         ret;\n     }\n@@ -449,14 +446,14 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n         let unboxed = GEPi(bcx, box, [0, abi::box_field_body]);\n-        compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n-                         f, exits);\n+        compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n+                         + vals_left, f, exits);\n         ret;\n     }\n \n     if any_uniq_pat(m, col) {\n         let unboxed = Load(bcx, val);\n-        compile_submatch(bcx, enter_uniq(m, col, val),\n+        compile_submatch(bcx, enter_uniq(dm, m, col, val),\n                          [unboxed] + vals_left, f, exits);\n         ret;\n     }\n@@ -469,7 +466,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n     if opts.len() > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n-            if (*ty::enum_variants(ccx.tcx, vdef.enm)).len() == 1u {\n+            if (*ty::enum_variants(tcx, vdef.enm)).len() == 1u {\n                 kind = single;\n             } else {\n                 let enumptr =\n@@ -512,13 +509,11 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n           single { Br(bcx, opt_cx.llbb); }\n           switch {\n             let res = trans_opt(bcx, opt);\n-            alt res {\n+            alt check res {\n               single_result(r) {\n                 llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                 bcx = r.bcx;\n               }\n-              _ { bcx.tcx().sess.bug(\"Someone forgot to\\\n-                    document an invariant in compile_submatch\"); }\n             }\n           }\n           compare {\n@@ -554,15 +549,15 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n           }\n           lit(_) | range(_, _) { }\n         }\n-        compile_submatch(opt_cx, enter_opt(ccx, m, opt, col, size, val),\n+        compile_submatch(opt_cx, enter_opt(tcx, m, opt, col, size, val),\n                          unpacked + vals_left, f, exits);\n     }\n \n     // Compile the fall-through case\n     if kind == compare { Br(bcx, else_cx.llbb); }\n     if kind != single {\n-        compile_submatch(else_cx, enter_default(m, col, val), vals_left, f,\n-                         exits);\n+        compile_submatch(else_cx, enter_default(dm, m, col, val), vals_left,\n+                         f, exits);\n     }\n }\n \n@@ -625,14 +620,10 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n \n-    // n.b. nothing else in this module should need to normalize,\n-    // b/c of this call\n-    let arms = normalize_arms(tcx, arms);\n-\n     for a in arms {\n         let body = scope_block(bcx, \"case_body\");\n         body.block_span = some(a.body.span);\n-        let id_map = pat_util::pat_id_map(tcx, a.pats[0]);\n+        let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         bodies += [body];\n         for p in a.pats {\n             match += [@{pats: [p],\n@@ -662,8 +653,8 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     let arm_cxs = [], arm_dests = [], i = 0u;\n     for a in arms {\n         let body_cx = bodies[i];\n-        if make_phi_bindings(body_cx, exit_map,\n-                             pat_util::pat_id_map(tcx, a.pats[0])) {\n+        let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n+        if make_phi_bindings(body_cx, exit_map, id_map) {\n             let arm_dest = dup_for_join(dest);\n             arm_dests += [arm_dest];\n             let arm_cx = trans_block(body_cx, a.body, arm_dest);\n@@ -681,8 +672,9 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     let ccx = bcx.fcx.ccx, bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n-    alt normalize_pat(bcx.tcx(), pat).node {\n+    alt pat.node {\n       ast::pat_ident(_,inner) {\n+        if pat_is_variant(bcx.tcx().def_map, pat) { ret bcx; }\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);\n             let llty = type_of::type_of(ccx, ty);\n@@ -698,7 +690,6 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_enum(_, sub) {\n-        if sub.len() == 0u { ret bcx; }\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;"}, {"sha": "a86681da8ce0abfd2a281739d72cc019481d5095", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -3670,33 +3670,31 @@ fn alloc_ty(cx: block, t: ty::t) -> result {\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n     let t = node_id_type(cx, local.node.id);\n-    let p = normalize_pat(cx.tcx(), local.node.pat);\n-    let is_simple = alt p.node {\n-      ast::pat_ident(_, none) { true } _ { false }\n+    let simple_name = alt local.node.pat.node {\n+      ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n+      _ { none }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = cx.ccx();\n-    if is_simple && !ccx.mutbl_map.contains_key(local.node.pat.id) &&\n+    if option::is_some(simple_name) &&\n+       !ccx.mutbl_map.contains_key(local.node.pat.id) &&\n        !ccx.last_uses.contains_key(local.node.pat.id) &&\n        ty::type_is_immediate(t) {\n         alt local.node.init {\n           some({op: ast::init_assign, _}) { ret cx; }\n           _ {}\n         }\n     }\n-    let r = alloc_ty(cx, t);\n-    alt p.node {\n-      ast::pat_ident(pth, none) {\n-        if cx.sess().opts.debuginfo {\n-            let _: () = str::as_buf(path_to_ident(pth), {|buf|\n-                llvm::LLVMSetValueName(r.val, buf)\n+    let {bcx, val} = alloc_ty(cx, t);\n+    if cx.sess().opts.debuginfo {\n+        option::may(simple_name) {|name|\n+            str::as_buf(name, {|buf|\n+                llvm::LLVMSetValueName(val, buf)\n             });\n         }\n-      }\n-      _ { }\n     }\n-    cx.fcx.lllocals.insert(local.node.id, local_mem(r.val));\n-    ret r.bcx;\n+    cx.fcx.lllocals.insert(local.node.id, local_mem(val));\n+    ret bcx;\n }\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)"}, {"sha": "39da8cf2c57d8fa2140390b6a510baf1701e168c", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -686,12 +686,11 @@ fn create_local_var(bcx: block, local: @ast::local)\n       option::none {}\n     }\n \n-    let name = path_to_ident(alt pat_util::normalize_pat(bcx.tcx(),\n-                                           local.node.pat).node {\n-      ast::pat_ident(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n-      _ { bcx.tcx().sess.span_bug(local.span, \"create_local_var: \\\n-             weird pattern in local\"); }\n-     });\n+    let name = alt local.node.pat.node {\n+      ast::pat_ident(pth, _) { pat_util::path_to_ident(pth) }\n+      // FIXME this should be handled\n+      _ { fail \"no single variable name for local\"; }\n+    };\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n     let ty = node_id_type(bcx, local.node.id);"}, {"sha": "d42716931124b6c0b635e0d61568db9201fa3919", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -22,17 +22,18 @@ fn collect_ids_stmt(s: @stmt, rs: @mutable [node_id]) {\n     }\n }\n \n-fn collect_ids_local(l: @local, rs: @mutable [node_id]) {\n-    *rs += pat_binding_ids(l.node.pat);\n+fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mutable [node_id]) {\n+    *rs += pat_binding_ids(tcx.def_map, l.node.pat);\n }\n \n-fn node_ids_in_fn(body: blk, rs: @mutable [node_id]) {\n+fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mutable [node_id]) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n                                    visit_block: bind collect_ids_block(_, rs),\n                                    visit_stmt: bind collect_ids_stmt(_, rs),\n-                                   visit_local: bind collect_ids_local(_, rs)\n-                                      with *visit::default_simple_visitor()});\n+                                   visit_local:\n+                                       bind collect_ids_local(tcx, _, rs)\n+                                   with *visit::default_simple_visitor()});\n     collect_ids.visit_block(body, (), collect_ids);\n }\n \n@@ -45,7 +46,7 @@ fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n \n fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n     let node_ids: @mutable [node_id] = @mutable [];\n-    node_ids_in_fn(body, node_ids);\n+    node_ids_in_fn(ccx.tcx, body, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }"}, {"sha": "60d799a89deff6f816762670a51b434639a68584", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -1056,7 +1056,7 @@ type binding = {lhs: [inst], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let lhs = [];\n-    pat_bindings(pat_util::normalize_pat(tcx, loc.node.pat)) {|p_id, _s, name|\n+    pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n         lhs += [{ident: path_to_ident(name), node: p_id}];\n     };\n     {lhs: lhs, rhs: loc.node.init}"}, {"sha": "9b39814e141fb49d75a62fe5d96ded18c723478d", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -12,8 +12,7 @@ import aux::*;\n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n-    pat_bindings(pat_util::normalize_pat(cx.tcx, loc.node.pat))\n-     {|p_id, _s, id|\n+    pat_bindings(cx.tcx.def_map, loc.node.pat) {|p_id, _s, id|\n        *cx.cs += [respan(loc.span, ninit(p_id, path_to_ident(id)))];\n     };\n     visit::visit_local(loc, cx, v);"}, {"sha": "f46cd39bf6513b80e17833d08d6ad615a16894b8", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -89,7 +89,7 @@ fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n                       id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    pat_bindings(normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p_id, _s, n|\n+    pat_bindings(fcx.ccx.tcx.def_map, l.node.pat) {|p_id, _s, n|\n         let v_init = ninit(p_id, path_to_ident(n));\n         relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n         // Hack: for-loop index variables are frequently ignored,\n@@ -551,7 +551,8 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n                     find_pre_post_expr(fcx, an_init.expr);\n-                    pat_bindings(alocal.node.pat) {|p_id, _s, _n|\n+                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                        {|p_id, _s, _n|\n                         copy_pre_post(fcx.ccx, p_id, an_init.expr);\n                     };\n                     /* Inherit ann from initializer, and add var being\n@@ -564,7 +565,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                       _ { }\n                     }\n \n-                    pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n+                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         {|p_id, _s, n|\n                         let ident = path_to_ident(n);\n                         alt p {\n@@ -592,7 +593,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                                seq_preconds(fcx, [prev_pp, e_pp]));\n                     /* Include the LHSs too, since those aren't in the\n                      postconds of the RHSs themselves */\n-                    pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n+                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         {|pat_id, _s, n|\n                             set_in_postcond(bit_num(fcx,\n                                ninit(pat_id, path_to_ident(n))), prev_pp);\n@@ -601,7 +602,8 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                                    prev_pp.postcondition);\n                   }\n                   none {\n-                      pat_bindings(alocal.node.pat) {|p_id, _s, _n|\n+                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                        {|p_id, _s, _n|\n                         clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n                     };\n                     clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);"}, {"sha": "e9d73ec8e7727a07454f8a005b3bc01449cc583a", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -224,8 +224,7 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     // Make sure the index vars are considered initialized\n     // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n-    pat_bindings(pat_util::normalize_pat(fcx.ccx.tcx, l.node.pat))\n-      {|p_id, _s, n|\n+    pat_bindings(fcx.ccx.tcx.def_map, l.node.pat) {|p_id, _s, n|\n        set_in_poststate_ident(fcx, p_id, path_to_ident(n), index_post);\n     };\n "}, {"sha": "75f3deb670f405b97e11a9869177458905a1a7b6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -1338,12 +1338,15 @@ fn gather_locals(ccx: @crate_ctxt,\n \n     // Add pattern bindings.\n     let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n-        alt normalize_pat(ccx.tcx, p).node {\n-              ast::pat_ident(_, _) { assign(p.id, none); }\n-              _ {/* no-op */ }\n-            }\n-            visit::visit_pat(p, e, v);\n-        };\n+        alt p.node {\n+          ast::pat_ident(_, _)\n+          if !pat_util::pat_is_variant(ccx.tcx.def_map, p) {\n+            assign(p.id, none);\n+          }\n+          _ {}\n+        }\n+        visit::visit_pat(p, e, v);\n+    };\n \n     // Don't descend into fns and items\n     fn visit_fn<T>(_fk: visit::fn_kind, _decl: ast::fn_decl, _body: ast::blk,\n@@ -1380,12 +1383,65 @@ fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n     ast_util::compare_lit_exprs(from, to) <= 0\n }\n \n+fn check_pat_variant(fcx: @fn_ctxt, map: pat_util::pat_id_map,\n+                     pat: @ast::pat, path: @ast::path, subpats: [@ast::pat],\n+                     expected: ty::t) {\n+    // Typecheck the path.\n+    let tcx = fcx.ccx.tcx;\n+    let v_def = lookup_def(fcx, path.span, pat.id);\n+    let v_def_ids = ast_util::variant_def_ids(v_def);\n+    let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n+    instantiate_path(fcx, path, ctor_tpt, pat.span, pat.id);\n+\n+    // Take the enum type params out of `expected`.\n+    alt structure_of(fcx, pat.span, expected) {\n+      ty::ty_enum(_, expected_tps) {\n+        let ctor_ty = ty::node_id_to_type(tcx, pat.id);\n+        demand::with_substs(fcx, pat.span, expected, ctor_ty,\n+                            expected_tps);\n+        // Get the number of arguments in this enum variant.\n+        let arg_types = variant_arg_types(fcx.ccx, pat.span,\n+                                          v_def_ids.var, expected_tps);\n+        let subpats_len = subpats.len(), arg_len = arg_types.len();\n+        if arg_len > 0u {\n+            // N-ary variant.\n+            if arg_len != subpats_len {\n+                let s = #fmt[\"this pattern has %u field%s, but the \\\n+                              corresponding variant has %u field%s\",\n+                             subpats_len,\n+                             if subpats_len == 1u { \"\" } else { \"s\" },\n+                             arg_len,\n+                             if arg_len == 1u { \"\" } else { \"s\" }];\n+                tcx.sess.span_err(pat.span, s);\n+            }\n+\n+            vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n+                check_pat(fcx, map, subpat, arg_ty);\n+            }\n+        } else if subpats_len > 0u {\n+            tcx.sess.span_err\n+                (pat.span, #fmt[\"this pattern has %u field%s, \\\n+                                 but the corresponding variant has no fields\",\n+                                subpats_len,\n+                                if subpats_len == 1u { \"\" }\n+                                else { \"s\" }]);\n+        }\n+      }\n+      _ {\n+        tcx.sess.span_err\n+            (pat.span,\n+             #fmt[\"mismatched types: expected enum but found `%s`\",\n+                  ty_to_str(tcx, expected)]);\n+      }\n+    }\n+}\n+\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n              expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n-    alt normalize_pat(tcx, pat).node {\n+    alt pat.node {\n       ast::pat_wild {\n           alt structure_of(fcx, pat.span, expected) {\n                   ty::ty_enum(_, expected_tps) {\n@@ -1416,7 +1472,8 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         }\n         write_ty(tcx, pat.id, b_ty);\n       }\n-      ast::pat_ident(name, sub) {\n+      ast::pat_ident(name, sub)\n+      if !pat_util::pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n@@ -1431,55 +1488,11 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n           _ {}\n         }\n       }\n+      ast::pat_ident(path, _) {\n+        check_pat_variant(fcx, map, pat, path, [], expected);\n+      }\n       ast::pat_enum(path, subpats) {\n-        // Typecheck the path.\n-        let v_def = lookup_def(fcx, path.span, pat.id);\n-        let v_def_ids = ast_util::variant_def_ids(v_def);\n-        let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n-        instantiate_path(fcx, path, ctor_tpt, pat.span, pat.id);\n-\n-        // Take the enum type params out of `expected`.\n-        alt structure_of(fcx, pat.span, expected) {\n-          ty::ty_enum(_, expected_tps) {\n-            let ctor_ty = ty::node_id_to_type(tcx, pat.id);\n-            demand::with_substs(fcx, pat.span, expected, ctor_ty,\n-                                expected_tps);\n-            // Get the number of arguments in this enum variant.\n-            let arg_types = variant_arg_types(fcx.ccx, pat.span,\n-                                              v_def_ids.var, expected_tps);\n-            let subpats_len = subpats.len(), arg_len = arg_types.len();\n-            if arg_len > 0u {\n-                // N-ary variant.\n-                if arg_len != subpats_len {\n-                    let s = #fmt[\"this pattern has %u field%s, but the \\\n-                                  corresponding variant has %u field%s\",\n-                                 subpats_len,\n-                                 if subpats_len == 1u { \"\" } else { \"s\" },\n-                                 arg_len,\n-                                 if arg_len == 1u { \"\" } else { \"s\" }];\n-                    tcx.sess.span_err(pat.span, s);\n-                }\n-\n-                vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n-                    check_pat(fcx, map, subpat, arg_ty);\n-                }\n-            } else if subpats_len > 0u {\n-                tcx.sess.span_err\n-                    (pat.span, #fmt[\"this pattern has %u field%s, \\\n-                                     but the corresponding \\\n-                                     variant has no fields\",\n-                                    subpats_len,\n-                                    if subpats_len == 1u { \"\" }\n-                                    else { \"s\" }]);\n-            }\n-          }\n-          _ {\n-            tcx.sess.span_err\n-                (pat.span,\n-                 #fmt[\"mismatched types: expected enum but found `%s`\",\n-                      ty_to_str(tcx, expected)]);\n-          }\n-        }\n+        check_pat_variant(fcx, map, pat, path, subpats, expected);\n       }\n       ast::pat_rec(fields, etc) {\n         let ex_fields;\n@@ -2292,7 +2305,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // bindings.\n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm in arms {\n-            let id_map = pat_util::pat_id_map(tcx, arm.pats[0]);\n+            let id_map = pat_util::pat_id_map(tcx.def_map, arm.pats[0]);\n             for p: @ast::pat in arm.pats {\n                 check_pat(fcx, id_map, p, pattern_ty);\n             }\n@@ -2636,7 +2649,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n       }\n       _ {/* fall through */ }\n     }\n-    let id_map = pat_util::pat_id_map(fcx.ccx.tcx, local.node.pat);\n+    let id_map = pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat);\n     check_pat(fcx, id_map, local.node.pat, t);\n     ret bot;\n }"}, {"sha": "262eac3ca010e06afff9f164576373a026144d69", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=cb2f43cbf4332ffe90b8963f1bdbaa85febe1b92", "patch": "@@ -108,9 +108,6 @@ enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    // After the resolution phase, code should never pattern-\n-    // match on a pat directly! Always call pat_util::normalize_pat --\n-    // it turns any pat_idents that refer to nullary enums into pat_enums.\n     pat_ident(@path, option<@pat>),\n     pat_enum(@path, [@pat]),\n     pat_rec([field_pat], bool),"}]}