{"sha": "2bd5993ca25e09b894e4fd6539a2fba64599eee2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZDU5OTNjYTI1ZTA5Yjg5NGU0ZmQ2NTM5YTJmYmE2NDU5OWVlZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-02T20:46:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-02T20:46:49Z"}, "message": "Auto merge of #54343 - blitzerr:master, r=nikomatsakis\n\nFirst shot at #54015\n\nCloses #54015", "tree": {"sha": "ecbbdba45817bf94647cf23af996f42abb608fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecbbdba45817bf94647cf23af996f42abb608fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bd5993ca25e09b894e4fd6539a2fba64599eee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd5993ca25e09b894e4fd6539a2fba64599eee2", "html_url": "https://github.com/rust-lang/rust/commit/2bd5993ca25e09b894e4fd6539a2fba64599eee2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bd5993ca25e09b894e4fd6539a2fba64599eee2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c5e9c68ea6c76fe400528de17ebe03e338bac68", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c5e9c68ea6c76fe400528de17ebe03e338bac68", "html_url": "https://github.com/rust-lang/rust/commit/1c5e9c68ea6c76fe400528de17ebe03e338bac68"}, {"sha": "671e77d60b075ff3a757e1c528e759ac95fc1e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/671e77d60b075ff3a757e1c528e759ac95fc1e13", "html_url": "https://github.com/rust-lang/rust/commit/671e77d60b075ff3a757e1c528e759ac95fc1e13"}], "stats": {"total": 594, "additions": 345, "deletions": 249}, "files": [{"sha": "22b135bee492ac9e6a7e904e8bd4321c1723de1e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 288, "deletions": 225, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -8,22 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::WriteKind;\n-use borrow_check::prefixes::IsPrefixOf;\n use borrow_check::nll::explain_borrow::BorrowExplanation;\n+use borrow_check::prefixes::IsPrefixOf;\n+use borrow_check::WriteKind;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n     LocalDecl, LocalKind, Location, Operand, Place, PlaceProjection, ProjectionElem, Rvalue,\n     Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n@@ -35,6 +35,17 @@ use dataflow::move_paths::indexes::MoveOutIndex;\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n+#[derive(Debug)]\n+struct MoveSite {\n+    /// Index of the \"move out\" that we found. The `MoveData` can\n+    /// then tell us where the move occurred.\n+    moi: MoveOutIndex,\n+\n+    /// True if we traversed a back edge while walking from the point\n+    /// of error to the move site.\n+    traversed_back_edge: bool\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n@@ -45,22 +56,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} place={:?} \\\n-            span={:?} mpi={:?}\",\n+             span={:?} mpi={:?}\",\n             context, desired_action, place, span, mpi\n         );\n \n-        let use_spans = self\n-            .move_spans(place, context.loc)\n+        let use_spans = self.move_spans(place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n-        let mois = self.get_moved_indexes(context, mpi);\n-        debug!(\"report_use_of_moved_or_uninitialized: mois={:?}\", mois);\n+        let move_site_vec = self.get_moved_indexes(context, mpi);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n+            move_site_vec\n+        );\n+        let move_out_indices: Vec<_> = move_site_vec\n+            .iter()\n+            .map(|move_site| move_site.moi)\n+            .collect();\n \n-        if mois.is_empty() {\n+        if move_out_indices.is_empty() {\n             let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n \n-            if self.uninitialized_error_reported.contains(&root_place.clone()) {\n+            if self.uninitialized_error_reported\n+                .contains(&root_place.clone())\n+            {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n@@ -77,8 +96,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n-                &self\n-                    .describe_place_with_options(place, IncludingDowncast(true))\n+                &self.describe_place_with_options(place, IncludingDowncast(true))\n                     .unwrap_or(\"_\".to_owned()),\n                 Origin::Mir,\n             );\n@@ -91,10 +109,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             err.buffer(&mut self.errors_buffer);\n         } else {\n-            if let Some((reported_place, _)) = self.move_error_reported.get(&mois) {\n-                if self.prefixes(&reported_place, PrefixSet::All).any(|p| p == place) {\n-                    debug!(\"report_use_of_moved_or_uninitialized place: error suppressed \\\n-                           mois={:?}\", mois);\n+            if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n+                if self.prefixes(&reported_place, PrefixSet::All)\n+                    .any(|p| p == place)\n+                {\n+                    debug!(\n+                        \"report_use_of_moved_or_uninitialized place: error suppressed \\\n+                         mois={:?}\",\n+                        move_out_indices\n+                    );\n                     return;\n                 }\n             }\n@@ -110,8 +133,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n \n             let mut is_loop_move = false;\n-            for moi in &mois {\n-                let move_out = self.move_data.moves[*moi];\n+            for move_site in &move_site_vec {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n                 let move_spans = self.move_spans(moved_place, move_out.source);\n@@ -126,9 +149,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if span == move_span {\n                     err.span_label(\n                         span,\n-                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n+                        format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                     is_loop_move = true;\n+                } else if move_site.traversed_back_edge {\n+                    err.span_label(\n+                        move_span,\n+                        format!(\n+                            \"value moved{} here, in previous iteration of loop\",\n+                            move_msg\n+                        ),\n+                    );\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n                     move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n@@ -166,13 +197,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 if needs_note {\n-                    let mpi = self.move_data.moves[mois[0]].path;\n+                    let mpi = self.move_data.moves[move_out_indices[0]].path;\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n-                        let note_msg = match self\n-                            .describe_place_with_options(place, IncludingDowncast(true))\n-                        {\n+                        let note_msg = match self.describe_place_with_options(\n+                            place,\n+                            IncludingDowncast(true),\n+                        ) {\n                             Some(name) => format!(\"`{}`\", name),\n                             None => \"value\".to_owned(),\n                         };\n@@ -186,10 +218,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            if let Some((_, mut old_err)) = self.move_error_reported.insert(\n-                mois,\n-                (place.clone(), err)\n-            ) {\n+            if let Some((_, mut old_err)) = self.move_error_reported\n+                .insert(move_out_indices, (place.clone(), err))\n+            {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();\n             }\n@@ -255,8 +286,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             borrow_span,\n-            &self\n-                .describe_place(&borrow.borrowed_place)\n+            &self.describe_place(&borrow.borrowed_place)\n                 .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n@@ -299,8 +329,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"mutable\",\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n-            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => tcx\n-                .cannot_reborrow_already_borrowed(\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+                tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -311,27 +341,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => tcx\n-                .cannot_mutably_borrow_multiply(\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+                tcx.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => tcx\n-                .cannot_uniquely_borrow_by_two_closures(\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n                     issued_span,\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n             (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n             | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n@@ -344,10 +377,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}` in closure\",\n-                        desc_place\n-                    ),\n+                    format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n                 );\n                 err.buffer(&mut self.errors_buffer);\n \n@@ -365,8 +395,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -375,10 +405,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -387,13 +418,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n             (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n             | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _) => {\n                 // Shallow borrows are uses from the user's point of view.\n                 self.report_use_while_mutably_borrowed(context, (place, span), issued_borrow);\n-                return\n+                return;\n             }\n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n             | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n@@ -447,16 +479,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n-        debug!(\"report_borrowed_value_does_not_live_long_enough(\\\n-                {:?}, {:?}, {:?}, {:?}\\\n-                )\",\n-               context, borrow, place_span, kind\n+        debug!(\n+            \"report_borrowed_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, borrow, place_span, kind\n         );\n \n         let drop_span = place_span.1;\n         let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-        let root_place = self\n-            .prefixes(&borrow.borrowed_place, PrefixSet::All)\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();\n \n@@ -468,8 +500,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => drop_span,\n         };\n \n-        if self\n-            .access_place_error_reported\n+        if self.access_place_error_reported\n             .contains(&(root_place.clone(), borrow_span))\n         {\n             debug!(\n@@ -482,28 +513,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        if let StorageDeadOrDrop::Destructor(dropped_ty)\n-            = self.classify_drop_access_kind(&borrow.borrowed_place)\n+        if let StorageDeadOrDrop::Destructor(dropped_ty) =\n+            self.classify_drop_access_kind(&borrow.borrowed_place)\n         {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n                 self.report_borrow_conflicts_with_destructor(\n-                    context,\n-                    borrow,\n-                    place_span,\n-                    kind,\n-                    dropped_ty,\n+                    context, borrow, place_span, kind, dropped_ty,\n                 );\n                 return;\n             }\n         }\n \n         let err = match &self.describe_place(&borrow.borrowed_place) {\n-            Some(_) if self.is_place_thread_local(root_place) =>\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span),\n+            Some(_) if self.is_place_thread_local(root_place) => {\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n+            }\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n                 context,\n                 name,\n@@ -556,16 +584,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             err.span_label(\n                 borrow_span,\n-                format!(\"`{}` would have to be valid for `{}`...\", name, region_name)\n+                format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n             if let Some(fn_node_id) = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id) {\n                 err.span_label(\n                     drop_span,\n                     format!(\n                         \"...but `{}` will be dropped here, when the function `{}` returns\",\n-                        name, self.infcx.tcx.hir.name(fn_node_id),\n-                    )\n+                        name,\n+                        self.infcx.tcx.hir.name(fn_node_id),\n+                    ),\n                 );\n \n                 err.note(\n@@ -579,16 +608,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             } else {\n                 err.span_label(\n                     drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name)\n+                    format!(\"...but `{}` dropped here while still borrowed\", name),\n                 );\n             }\n \n-            if let BorrowExplanation::MustBeValidFor(..) = explanation { } else {\n+            if let BorrowExplanation::MustBeValidFor(..) = explanation {\n+            } else {\n                 explanation.emit(self.infcx.tcx, &mut err);\n             }\n         } else {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-            err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n+            err.span_label(\n+                drop_span,\n+                format!(\"`{}` dropped here while still borrowed\", name),\n+            );\n \n             borrow_spans.args_span_label(&mut err, \"value captured here\");\n \n@@ -616,34 +649,40 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let mut err = self.infcx.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+        let mut err = self.infcx\n+            .tcx\n+            .cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n         let what_was_dropped = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name.as_str()),\n             None => format!(\"temporary value\"),\n         };\n \n         let label = match self.describe_place(&borrow.borrowed_place) {\n-            Some(borrowed) =>\n-                format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n-                         because the type `{T}` implements the `Drop` trait\",\n-                        D=what_was_dropped, T=dropped_ty, B=borrowed),\n-            None =>\n-                format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n-                        D=what_was_dropped, T=dropped_ty),\n+            Some(borrowed) => format!(\n+                \"here, drop of {D} needs exclusive access to `{B}`, \\\n+                 because the type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty,\n+                B = borrowed\n+            ),\n+            None => format!(\n+                \"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty\n+            ),\n         };\n         err.span_label(drop_span, label);\n \n         // Only give this note and suggestion if they could be relevant.\n-        let explanation = self.explain_why_borrow_contains_point(\n-            context, borrow, kind.map(|k| (k, place)),\n-        );\n+        let explanation =\n+            self.explain_why_borrow_contains_point(context, borrow, kind.map(|k| (k, place)));\n         match explanation {\n-            BorrowExplanation::UsedLater {..} |\n-            BorrowExplanation::UsedLaterWhenDropped {..} => {\n+            BorrowExplanation::UsedLater { .. }\n+            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n \n         explanation.emit(self.infcx.tcx, &mut err);\n@@ -663,9 +702,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self.infcx.tcx.thread_local_value_does_not_live_long_enough(\n-            borrow_span, Origin::Mir\n-        );\n+        let mut err = self.infcx\n+            .tcx\n+            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n \n         err.span_label(\n             borrow_span,\n@@ -693,20 +732,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let tcx = self.infcx.tcx;\n-        let mut err =\n-            tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n-        err.span_label(proper_span, \"creates a temporary which is freed while still in use\");\n-        err.span_label(drop_span, \"temporary value is freed at the end of this statement\");\n+        let mut err = tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n+        err.span_label(\n+            proper_span,\n+            \"creates a temporary which is freed while still in use\",\n+        );\n+        err.span_label(\n+            drop_span,\n+            \"temporary value is freed at the end of this statement\",\n+        );\n \n         let explanation = self.explain_why_borrow_contains_point(context, borrow, None);\n         match explanation {\n-            BorrowExplanation::UsedLater(..) |\n-            BorrowExplanation::UsedLaterInLoop(..) |\n-            BorrowExplanation::UsedLaterWhenDropped(..) => {\n+            BorrowExplanation::UsedLater(..)\n+            | BorrowExplanation::UsedLaterInLoop(..)\n+            | BorrowExplanation::UsedLaterWhenDropped(..) => {\n                 // Only give this note and suggestion if it could be relevant.\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n         explanation.emit(self.infcx.tcx, &mut err);\n \n@@ -715,29 +759,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveOutIndex> {\n+    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveSite> {\n         let mir = self.mir;\n \n         let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(context.loc));\n+        stack.extend(mir.predecessor_locations(context.loc).map(|predecessor| {\n+            let is_back_edge = context.loc.dominates(predecessor, &self.dominators);\n+            (predecessor, is_back_edge)\n+        }));\n \n         let mut visited = FxHashSet();\n         let mut result = vec![];\n \n-        'dfs: while let Some(l) = stack.pop() {\n+        'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n             debug!(\n-                \"report_use_of_moved_or_uninitialized: current_location={:?}\",\n-                l\n+                \"report_use_of_moved_or_uninitialized: (current_location={:?}, back_edge={})\",\n+                location, is_back_edge\n             );\n \n-            if !visited.insert(l) {\n+            if !visited.insert(location) {\n                 continue;\n             }\n \n             // check for moves\n-            let stmt_kind = mir[l.block]\n+            let stmt_kind = mir[location.block]\n                 .statements\n-                .get(l.statement_index)\n+                .get(location.statement_index)\n                 .map(|s| &s.kind);\n             if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n                 // this analysis only tries to find moves explicitly\n@@ -756,11 +803,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let move_paths = &self.move_data.move_paths;\n                 mpis.extend(move_paths[mpi].parents(move_paths));\n \n-                for moi in &self.move_data.loc_map[l] {\n+                for moi in &self.move_data.loc_map[location] {\n                     debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n                     if mpis.contains(&self.move_data.moves[*moi].path) {\n                         debug!(\"report_use_of_moved_or_uninitialized: found\");\n-                        result.push(*moi);\n+                        result.push(MoveSite {\n+                            moi: *moi,\n+                            traversed_back_edge: is_back_edge,\n+                        });\n \n                         // Strictly speaking, we could continue our DFS here. There may be\n                         // other moves that can reach the point of error. But it is kind of\n@@ -785,16 +835,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             // check for inits\n             let mut any_match = false;\n-            drop_flag_effects::for_location_inits(self.infcx.tcx, self.mir, self.move_data, l, |m| {\n-                if m == mpi {\n-                    any_match = true;\n-                }\n-            });\n+            drop_flag_effects::for_location_inits(\n+                self.infcx.tcx,\n+                self.mir,\n+                self.move_data,\n+                location,\n+                |m| {\n+                    if m == mpi {\n+                        any_match = true;\n+                    }\n+                },\n+            );\n             if any_match {\n                 continue 'dfs;\n             }\n \n-            stack.extend(mir.predecessor_locations(l));\n+            stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+                let back_edge = location.dominates(predecessor, &self.dominators);\n+                (predecessor, is_back_edge || back_edge)\n+            }));\n         }\n \n         result\n@@ -829,7 +888,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, loan, None).emit(self.infcx.tcx, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None)\n+            .emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1151,7 +1211,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n                     let node_id = self.infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    let freevar = self.infcx.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+                    let freevar = self.infcx\n+                        .tcx\n+                        .with_freevars(node_id, |fv| fv[field.index()]);\n \n                     self.infcx.tcx.hir.name(freevar.var_id()).to_string()\n                 }\n@@ -1218,35 +1280,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n-            Place::Local(_)\n-            | Place::Static(_)\n-            | Place::Promoted(_) => StorageDeadOrDrop::LocalStorageDead,\n+            Place::Local(_) | Place::Static(_) | Place::Promoted(_) => {\n+                StorageDeadOrDrop::LocalStorageDead\n+            }\n             Place::Projection(box PlaceProjection { base, elem }) => {\n                 let base_access = self.classify_drop_access_kind(base);\n                 match elem {\n-                    ProjectionElem::Deref => {\n-                        match base_access {\n-                            StorageDeadOrDrop::LocalStorageDead\n-                            | StorageDeadOrDrop::BoxedStorageDead => {\n-                                assert!(base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n-                                        \"Drop of value behind a reference or raw pointer\");\n-                                StorageDeadOrDrop::BoxedStorageDead\n-                            }\n-                            StorageDeadOrDrop::Destructor(_) => {\n-                                base_access\n-                            }\n+                    ProjectionElem::Deref => match base_access {\n+                        StorageDeadOrDrop::LocalStorageDead\n+                        | StorageDeadOrDrop::BoxedStorageDead => {\n+                            assert!(\n+                                base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                \"Drop of value behind a reference or raw pointer\"\n+                            );\n+                            StorageDeadOrDrop::BoxedStorageDead\n                         }\n-                    }\n-                    ProjectionElem::Field(..)\n-                    | ProjectionElem::Downcast(..) => {\n+                        StorageDeadOrDrop::Destructor(_) => base_access,\n+                    },\n+                    ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n                         let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n                                 match base_access {\n-                                    StorageDeadOrDrop::Destructor(_) => {\n-                                        base_access\n-                                    }\n+                                    StorageDeadOrDrop::Destructor(_) => base_access,\n                                     StorageDeadOrDrop::LocalStorageDead\n                                     | StorageDeadOrDrop::BoxedStorageDead => {\n                                         StorageDeadOrDrop::Destructor(base_ty)\n@@ -1277,13 +1334,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if is_closure {\n                 None\n             } else {\n-                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-                 match ty.sty {\n-                     ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n-                        self.annotate_fn_sig(\n-                            self.mir_def_id,\n-                            self.infcx.tcx.fn_sig(self.mir_def_id)\n-                        ),\n+                let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                match ty.sty {\n+                    ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id,\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n                     _ => None,\n                 }\n             }\n@@ -1296,13 +1352,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // place. If it was, we can add annotations about the function's return type and arguments\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n-        debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        match &self.mir[location.block].statements.get(location.statement_index) {\n+        debug!(\n+            \"annotate_argument_and_return_for_borrow: location={:?}\",\n+            location\n+        );\n+        match &self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n             Some(&Statement {\n                 kind: StatementKind::Assign(ref reservation, _),\n                 ..\n             }) => {\n-                debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                    reservation\n+                );\n                 // Check that the initial assignment of the reserve location is into a temporary.\n                 let mut target = *match reservation {\n                     Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n@@ -1317,21 +1382,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                         target, stmt\n                     );\n-                    if let StatementKind::Assign(\n-                        Place::Local(assigned_to),\n-                        box rvalue,\n-                    ) = &stmt.kind {\n-                        debug!(\"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                               rvalue={:?}\", assigned_to, rvalue);\n+                    if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                    {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                             rvalue={:?}\",\n+                            assigned_to, rvalue\n+                        );\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n-                                box AggregateKind::Closure(def_id, substs),\n-                                operands,\n-                        ) = rvalue {\n+                            box AggregateKind::Closure(def_id, substs),\n+                            operands,\n+                        ) = rvalue\n+                        {\n                             for operand in operands {\n                                 let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) |\n-                                    Operand::Move(assigned_from) => assigned_from,\n+                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                        assigned_from\n+                                    }\n                                     _ => continue,\n                                 };\n                                 debug!(\n@@ -1354,13 +1422,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure = self.annotate_fn_sig(\n                                     *def_id,\n-                                    self.infcx.closure_sig(*def_id, *substs)\n+                                    self.infcx.closure_sig(*def_id, *substs),\n                                 );\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\\n                                      assigned_to={:?}\",\n-                                     annotated_closure, assigned_from_local, assigned_to\n+                                    annotated_closure, assigned_from_local, assigned_to\n                                 );\n \n                                 if *assigned_to == mir::RETURN_PLACE {\n@@ -1382,15 +1450,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let assigned_from = match rvalue {\n                             Rvalue::Ref(_, _, assigned_from) => assigned_from,\n                             Rvalue::Use(operand) => match operand {\n-                                Operand::Copy(assigned_from) |\n-                                Operand::Move(assigned_from) => assigned_from,\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n                                 _ => continue,\n                             },\n                             _ => continue,\n                         };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from={:?}\", assigned_from,\n+                             assigned_from={:?}\",\n+                            assigned_from,\n                         );\n \n                         // Find the local from the rvalue.\n@@ -1400,7 +1470,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?}\", assigned_from_local,\n+                             assigned_from_local={:?}\",\n+                            assigned_from_local,\n                         );\n \n                         // Check if our local matches the target - if so, we've assigned our\n@@ -1414,7 +1485,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n                              assigned_from_local={:?} assigned_to={:?}\",\n-                             assigned_from_local, assigned_to\n+                            assigned_from_local, assigned_to\n                         );\n                         if *assigned_to == mir::RETURN_PLACE {\n                             // If it was then return the annotated closure if there was one,\n@@ -1438,15 +1509,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     destination: Some((Place::Local(assigned_to), _)),\n                     args,\n                     ..\n-                } = &terminator.kind {\n+                } = &terminator.kind\n+                {\n                     debug!(\n                         \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n                         assigned_to, args\n                     );\n                     for operand in args {\n                         let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) |\n-                            Operand::Move(assigned_from) => assigned_from,\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n                             _ => continue,\n                         };\n                         debug!(\n@@ -1460,9 +1533,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 assigned_from_local,\n                             );\n \n-                            if *assigned_to == mir::RETURN_PLACE &&\n-                                assigned_from_local == target\n-                            {\n+                            if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n                                 return annotated_closure.or_else(fallback);\n                             }\n                         }\n@@ -1529,7 +1600,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // With access to the lifetime, we can get\n                                     // the span of it.\n                                     arguments.push((*argument, lifetime.span));\n-                                },\n+                                }\n                                 _ => bug!(\"ty type is a ref but hir type is not\"),\n                             }\n                         }\n@@ -1556,7 +1627,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     return_ty,\n                     return_span,\n                 })\n-            },\n+            }\n             ty::TyKind::Ref(_, _, _) if is_closure => {\n                 // This is case 2 from above but only for closures, return type is anonymous\n                 // reference so we select\n@@ -1577,7 +1648,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 None\n-            },\n+            }\n             ty::TyKind::Ref(_, _, _) => {\n                 // This is also case 2 from above but for functions, return type is still an\n                 // anonymous reference so we select the first argument.\n@@ -1589,7 +1660,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // We expect the first argument to be a reference.\n                 match argument_ty.sty {\n-                    ty::TyKind::Ref(_, _, _) => {},\n+                    ty::TyKind::Ref(_, _, _) => {}\n                     _ => return None,\n                 }\n \n@@ -1599,12 +1670,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     return_ty,\n                     return_span,\n                 })\n-            },\n+            }\n             _ => {\n                 // This is case 3 from above, return type is not a reference so don't highlight\n                 // anything.\n                 None\n-            },\n+            }\n         }\n     }\n }\n@@ -1625,36 +1696,33 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n     Closure {\n         argument_ty: ty::Ty<'tcx>,\n         argument_span: Span,\n-    }\n+    },\n }\n \n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    fn emit(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>\n-    ) -> String {\n+    fn emit(&self, diag: &mut DiagnosticBuilder<'_>) -> String {\n         match self {\n-            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+            AnnotatedBorrowFnSignature::Closure {\n+                argument_ty,\n+                argument_span,\n+            } => {\n                 diag.span_label(\n                     *argument_span,\n                     format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n                 );\n \n                 self.get_region_name_for_ty(argument_ty, 0)\n-            },\n+            }\n             AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n                 let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n-                diag.span_label(\n-                    *argument_span,\n-                    format!(\"has type `{}`\", argument_ty_name)\n-                );\n+                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n                 let return_ty_name = self.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n@@ -1664,7 +1732,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                         \"{}has type `{}`\",\n                         if types_equal { \"also \" } else { \"\" },\n                         return_ty_name,\n-                    )\n+                    ),\n                 );\n \n                 diag.note(\n@@ -1676,7 +1744,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 );\n \n                 self.get_region_name_for_ty(return_ty, 0)\n-            },\n+            }\n             AnnotatedBorrowFnSignature::NamedFunction {\n                 arguments,\n                 return_ty,\n@@ -1685,30 +1753,22 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 // Region of return type and arguments checked to be the same earlier.\n                 let region_name = self.get_region_name_for_ty(return_ty, 0);\n                 for (_, argument_span) in arguments {\n-                    diag.span_label(\n-                        *argument_span,\n-                        format!(\"has lifetime `{}`\", region_name)\n-                    );\n+                    diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }\n \n                 diag.span_label(\n                     *return_span,\n-                    format!(\n-                        \"also has lifetime `{}`\",\n-                        region_name,\n-                    )\n+                    format!(\"also has lifetime `{}`\", region_name,),\n                 );\n \n-                diag.help(\n-                    &format!(\n-                        \"use data from the highlighted arguments which match the `{}` lifetime of \\\n-                         the return type\",\n-                         region_name,\n-                    ),\n-                );\n+                diag.help(&format!(\n+                    \"use data from the highlighted arguments which match the `{}` lifetime of \\\n+                     the return type\",\n+                    region_name,\n+                ));\n \n                 region_name\n-            },\n+            }\n         }\n     }\n \n@@ -1719,9 +1779,10 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n-            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _) |\n-            ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) =>\n-                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n+            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n+            | ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) => {\n+                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty))\n+            }\n             _ => format!(\"{}\", ty),\n         }\n     }\n@@ -1731,11 +1792,11 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n             ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br) |\n-                ty::RegionKind::ReSkolemized(_, br) =>\n-                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region)),\n+                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::ReSkolemized(_, br) => {\n+                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n+                }\n                 _ => format!(\"{}\", region),\n-            }\n+            },\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         }\n     }\n@@ -1828,9 +1889,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 debug!(\"find_closure_move_span: found closure {:?}\", places);\n \n                 if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(\n-                        _, _, _, args_span, _\n-                    ) = self.infcx.tcx.hir.expect_expr(node_id).node {\n+                    if let Closure(_, _, _, args_span, _) =\n+                        self.infcx.tcx.hir.expect_expr(node_id).node\n+                    {\n                         if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n                             for (v, place) in freevars.iter().zip(places) {\n                                 match place {\n@@ -1886,8 +1947,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places))\n-                = stmt.kind {\n+            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind\n+            {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n                     debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n \n@@ -1900,13 +1961,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return OtherUse(use_span);\n                         };\n \n-                        self.infcx.tcx\n+                        self.infcx\n+                            .tcx\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {\n                                         Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l))\n-                                            if local == l =>\n+                                        | Operand::Move(Place::Local(l)) if local == l =>\n                                         {\n                                             debug!(\n                                                 \"find_closure_borrow_span: found captured local \\\n@@ -1919,10 +1980,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     }\n                                 }\n                                 None\n-                            }).map(|var_span| ClosureUse {\n+                            })\n+                            .map(|var_span| ClosureUse {\n                                 args_span,\n                                 var_span,\n-                            }).unwrap_or(OtherUse(use_span))\n+                            })\n+                            .unwrap_or(OtherUse(use_span))\n                     } else {\n                         OtherUse(use_span)\n                     };"}, {"sha": "8d1caec2d72d36392dbd129f0537ecdc55e46538", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -46,9 +46,9 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             },\n             BorrowExplanation::UsedLaterInLoop(is_in_closure, var_or_use_span) => {\n                 let message = if is_in_closure {\n-                    \"borrow captured here by closure in later iteration of loop\"\n+                    \"borrow captured here by closure, in later iteration of loop\"\n                 } else {\n-                    \"borrow used here in later iteration of loop\"\n+                    \"borrow used here, in later iteration of loop\"\n                 };\n                 err.span_label(var_or_use_span, message);\n             },"}, {"sha": "b7803cbc804aecb8fb0b898653ccd69f325ccb56", "filename": "src/test/ui/borrowck/borrowck-for-loop-head-linkage.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -5,7 +5,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               borrow used here in later iteration of loop\n+   |               borrow used here, in later iteration of loop\n LL |         let cap = vector.capacity();\n LL |         vector.extend(repeat(0));      //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n@@ -17,7 +17,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               borrow used here in later iteration of loop\n+   |               borrow used here, in later iteration of loop\n ...\n LL |         vector[1] = 5;   //~ ERROR cannot borrow\n    |         ^^^^^^ mutable borrow occurs here"}, {"sha": "81aa1e2c9602e79672f0ee47d877aa67f035e0a1", "filename": "src/test/ui/borrowck/borrowck-lend-flow-loop.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -8,13 +8,13 @@ LL |         borrow(&*v); //~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n LL |     }\n LL |     *x = box 5;\n-   |     -- borrow used here in later iteration of loop\n+   |     -- borrow used here, in later iteration of loop\n \n error[E0502]: cannot borrow `*v` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-lend-flow-loop.rs:109:16\n    |\n LL |         **x += 1;\n-   |         -------- borrow used here in later iteration of loop\n+   |         -------- borrow used here, in later iteration of loop\n LL |         borrow(&*v); //~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n LL |         if cond2 {"}, {"sha": "19ec9cf7ded60d492d4a009e294760f8c9e40cfc", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    borrow used here in later iteration of loop\n+   |                    borrow used here, in later iteration of loop\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:25:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- borrow used here in later iteration of loop\n+   |                    ---- borrow used here, in later iteration of loop\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "19ec9cf7ded60d492d4a009e294760f8c9e40cfc", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    borrow used here in later iteration of loop\n+   |                    borrow used here, in later iteration of loop\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:25:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- borrow used here in later iteration of loop\n+   |                    ---- borrow used here, in later iteration of loop\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "39efdb6ddb40d0b4c61ae416a951bd80bf0a6869", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -20,7 +20,7 @@ error[E0382]: use of moved value (Mir)\n   --> $DIR/issue-41962.rs:17:21\n    |\n LL |         if let Some(thing) = maybe {\n-   |                     ^^^^^ value moved here in previous iteration of loop\n+   |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n "}, {"sha": "dd445c8c3a06bc242c2ccf41d6574012a141edf7", "filename": "src/test/ui/borrowck/mut-borrow-outside-loop.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -17,7 +17,7 @@ LL |         let inner_second = &mut inner_void; //~ ERROR cannot borrow\n    |                            ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n LL |         inner_second.use_mut();\n LL |         inner_first.use_mut();\n-   |         ----------- borrow used here in later iteration of loop\n+   |         ----------- borrow used here, in later iteration of loop\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a0b90c7a34a7f8cd63479ab7525500dacadff042", "filename": "src/test/ui/issues/issue-12041.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fissues%2Fissue-12041.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fissues%2Fissue-12041.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12041.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tx`\n   --> $DIR/issue-12041.rs:18:22\n    |\n LL |             let tx = tx;\n-   |                      ^^ value moved here in previous iteration of loop\n+   |                      ^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because `tx` has type `std::sync::mpsc::Sender<i32>`, which does not implement the `Copy` trait\n "}, {"sha": "b25b063f3b6fbbf2379676795aa42a94f61416d0", "filename": "src/test/ui/issues/issue-52126-assign-op-invariance.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -5,7 +5,7 @@ LL |         let v: Vec<&str> = line.split_whitespace().collect();\n    |                            ^^^^ borrowed value does not live long enough\n LL |         //~^ ERROR `line` does not live long enough\n LL |         println!(\"accumulator before add_assign {:?}\", acc.map);\n-   |                                                        ------- borrow used here in later iteration of loop\n+   |                                                        ------- borrow used here, in later iteration of loop\n ...\n LL |     }\n    |     - `line` dropped here while still borrowed"}, {"sha": "40add8d51f19e2bfa02abffffcdf233b4be4216a", "filename": "src/test/ui/liveness/liveness-move-call-arg.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -0,0 +1,11 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/liveness-move-call-arg.rs:19:14\n+   |\n+LL |         take(x); //~ ERROR use of moved value: `x`\n+   |              ^ value moved here, in previous iteration of loop\n+   |\n+   = note: move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "e2719256bdfe8cc8eb4aeaebc15e7f13944ed516", "filename": "src/test/ui/liveness/liveness-move-in-loop.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -0,0 +1,11 @@\n+error[E0382]: use of moved value: `y`\n+  --> $DIR/liveness-move-in-loop.rs:21:25\n+   |\n+LL |                     x = y; //~ ERROR use of moved value\n+   |                         ^ value moved here, in previous iteration of loop\n+   |\n+   = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "065e65702b4125b6f14580efdf37cac166bd69e5", "filename": "src/test/ui/liveness/liveness-move-in-while.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -4,7 +4,7 @@ error[E0382]: borrow of moved value: `y`\n LL |         println!(\"{}\", y); //~ ERROR use of moved value: `y`\n    |                        ^ value borrowed here after move\n LL |         while true { while true { while true { x = y; x.clone(); } } }\n-   |                                                    - value moved here\n+   |                                                    - value moved here, in previous iteration of loop\n    |\n    = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n "}, {"sha": "2a53a98c0f265a28bd25f5ba3cdf02104f301a0d", "filename": "src/test/ui/moves/move-in-guard-2.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -0,0 +1,11 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/move-in-guard-2.rs:20:24\n+   |\n+LL |         (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+   |                        ^ value moved here, in previous iteration of loop\n+   |\n+   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "cd7fdbdb6ed1e3477fbf3f5cd080463ce8c7ddf7", "filename": "src/test/ui/nll/closures-in-loops.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `x`\n LL |         || x; //~ ERROR\n    |         ^^ - use occurs due to use in closure\n    |         |\n-   |         value moved into closure here in previous iteration of loop\n+   |         value moved into closure here, in previous iteration of loop\n    |\n    = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n "}, {"sha": "056046aa43aba7414adb755b7415ed1935facfb2", "filename": "src/test/ui/nll/issue-53807.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fnll%2Fissue-53807.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fnll%2Fissue-53807.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53807.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value\n   --> $DIR/issue-53807.rs:14:21\n    |\n LL |         if let Some(thing) = maybe {\n-   |                     ^^^^^ value moved here in previous iteration of loop\n+   |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n "}, {"sha": "626ffad5ba70fd3a3cafd82282a8b2ec5496d373", "filename": "src/test/ui/rfc-2005-default-binding-mode/borrowck-issue-49631.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -7,7 +7,7 @@ LL |         foo.mutate();\n    |         ^^^^^^^^^^^^ mutable borrow occurs here\n LL |         //~^ ERROR cannot borrow `foo` as mutable\n LL |         println!(\"foo={:?}\", *string);\n-   |                              ------- borrow used here in later iteration of loop\n+   |                              ------- borrow used here, in later iteration of loop\n \n error: aborting due to previous error\n "}, {"sha": "a6d86f6797438f65a4473373de70cfd62f960ce0", "filename": "src/test/ui/span/regions-escape-loop-via-variable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -2,7 +2,7 @@ error[E0597]: `x` does not live long enough\n   --> $DIR/regions-escape-loop-via-variable.rs:21:13\n    |\n LL |         let x = 1 + *p;\n-   |                     -- borrow used here in later iteration of loop\n+   |                     -- borrow used here, in later iteration of loop\n LL |         p = &x;\n    |             ^^ borrowed value does not live long enough\n LL |     }"}, {"sha": "2f23a444dccba8ad2688ba51f3197f426b44ddc7", "filename": "src/test/ui/span/regions-escape-loop-via-vec.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -7,7 +7,7 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n    |           ^ use of borrowed `x`\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         _y.push(&mut z);\n-   |         -- borrow used here in later iteration of loop\n+   |         -- borrow used here, in later iteration of loop\n \n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/regions-escape-loop-via-vec.rs:16:21\n@@ -18,15 +18,15 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n    |                     ^ use of borrowed `x`\n LL |         _y.push(&mut z);\n-   |         -- borrow used here in later iteration of loop\n+   |         -- borrow used here, in later iteration of loop\n \n error[E0597]: `z` does not live long enough\n   --> $DIR/regions-escape-loop-via-vec.rs:17:17\n    |\n LL |         _y.push(&mut z);\n    |         --      ^^^^^^ borrowed value does not live long enough\n    |         |\n-   |         borrow used here in later iteration of loop\n+   |         borrow used here, in later iteration of loop\n ...\n LL |     }\n    |     - `z` dropped here while still borrowed\n@@ -38,7 +38,7 @@ LL |     let mut _y = vec![&mut x];\n    |                       ------ borrow of `x` occurs here\n ...\n LL |         _y.push(&mut z);\n-   |         -- borrow used here in later iteration of loop\n+   |         -- borrow used here, in later iteration of loop\n LL |         //~^ ERROR `z` does not live long enough\n LL |         x += 1; //~ ERROR cannot assign\n    |         ^^^^^^ use of borrowed `x`"}, {"sha": "cff263231dde7d7f6ff32d51312487c2c54eded5", "filename": "src/test/ui/vec/vec-mut-iter-borrow.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bd5993ca25e09b894e4fd6539a2fba64599eee2/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr?ref=2bd5993ca25e09b894e4fd6539a2fba64599eee2", "patch": "@@ -5,7 +5,7 @@ LL |     for x in &mut xs {\n    |              -------\n    |              |\n    |              first mutable borrow occurs here\n-   |              borrow used here in later iteration of loop\n+   |              borrow used here, in later iteration of loop\n LL |         xs.push(1) //~ ERROR cannot borrow `xs`\n    |         ^^ second mutable borrow occurs here\n "}]}