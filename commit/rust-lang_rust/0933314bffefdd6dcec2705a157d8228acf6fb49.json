{"sha": "0933314bffefdd6dcec2705a157d8228acf6fb49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MzMzMTRiZmZlZmRkNmRjZWMyNzA1YTE1N2Q4MjI4YWNmNmZiNDk=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T04:36:33Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T04:36:33Z"}, "message": "Rewrite file system tests", "tree": {"sha": "dc52f9c93ab7b4c27536b72ba3541e4f1749e2ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc52f9c93ab7b4c27536b72ba3541e4f1749e2ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0933314bffefdd6dcec2705a157d8228acf6fb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0933314bffefdd6dcec2705a157d8228acf6fb49", "html_url": "https://github.com/rust-lang/rust/commit/0933314bffefdd6dcec2705a157d8228acf6fb49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0933314bffefdd6dcec2705a157d8228acf6fb49/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "html_url": "https://github.com/rust-lang/rust/commit/8216f3c0f35aa948fe96d0eed17b0e5855799bd4"}], "stats": {"total": 134, "additions": 109, "deletions": 25}, "files": [{"sha": "3851a4d45e92beb952ec89e003228089daaeba07", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 109, "deletions": 25, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0933314bffefdd6dcec2705a157d8228acf6fb49/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0933314bffefdd6dcec2705a157d8228acf6fb49/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=0933314bffefdd6dcec2705a157d8228acf6fb49", "patch": "@@ -5,25 +5,23 @@ use std::fs::{File, remove_file, rename};\n use std::io::{Read, Write, ErrorKind, Result, Seek, SeekFrom};\n use std::path::{PathBuf, Path};\n \n-fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n-    // Test that the file metadata is correct.\n-    let metadata = path.metadata()?;\n-    // `path` should point to a file.\n-    assert!(metadata.is_file());\n-    // The size of the file must be equal to the number of written bytes.\n-    assert_eq!(bytes.len() as u64, metadata.len());\n-    Ok(())\n+fn main() {\n+    test_file();\n+    test_file_clone();\n+    test_seek();\n+    test_metadata();\n+    test_symlink();\n+    test_errors();\n+    test_rename();\n }\n \n-fn main() {\n+fn test_file() {\n     let tmp = std::env::temp_dir();\n-    let filename = PathBuf::from(\"miri_test_fs.txt\");\n+    let filename = PathBuf::from(\"miri_test_fs_file.txt\");\n     let path = tmp.join(&filename);\n-    let symlink_path = tmp.join(\"miri_test_fs_symlink.txt\");\n     let bytes = b\"Hello, World!\\n\";\n     // Clean the paths for robustness.\n     remove_file(&path).ok();\n-    remove_file(&symlink_path).ok();\n \n     // Test creating, writing and closing a file (closing is tested when `file` is dropped).\n     let mut file = File::create(&path).unwrap();\n@@ -42,6 +40,21 @@ fn main() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_file_clone() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_file_clone.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n     // Cloning a file should be successful.\n     let file = File::open(&path).unwrap();\n     let mut cloned = file.try_clone().unwrap();\n@@ -50,7 +63,24 @@ fn main() {\n     cloned.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_seek() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_seek.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n     let mut file = File::open(&path).unwrap();\n+    let mut contents = Vec::new();\n+    file.read_to_end(&mut contents).unwrap();\n     // Test that seeking to the beginning and reading until EOF gets the text again.\n     file.seek(SeekFrom::Start(0)).unwrap();\n     let mut contents = Vec::new();\n@@ -68,11 +98,53 @@ fn main() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(&bytes[2..], contents.as_slice());\n \n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn check_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n+    // Test that the file metadata is correct.\n+    let metadata = path.metadata()?;\n+    // `path` should point to a file.\n+    assert!(metadata.is_file());\n+    // The size of the file must be equal to the number of written bytes.\n+    assert_eq!(bytes.len() as u64, metadata.len());\n+    Ok(())\n+}\n+\n+fn test_metadata() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_metadata.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n     // Test that metadata of an absolute path is correct.\n-    test_metadata(bytes, &path).unwrap();\n+    check_metadata(bytes, &path).unwrap();\n     // Test that metadata of a relative path is correct.\n     std::env::set_current_dir(&tmp).unwrap();\n-    test_metadata(bytes, &filename).unwrap();\n+    check_metadata(bytes, &filename).unwrap();\n+\n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_symlink() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_link_target.txt\");\n+    let path = tmp.join(&filename);\n+    let symlink_path = tmp.join(\"miri_test_fs_symlink.txt\");\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+    remove_file(&symlink_path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n \n     // Creating a symbolic link should succeed.\n     std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n@@ -82,18 +154,38 @@ fn main() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n     // Test that metadata of a symbolic link is correct.\n-    test_metadata(bytes, &symlink_path).unwrap();\n+    check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it.\n     assert!(symlink_path.symlink_metadata().unwrap().file_type().is_symlink());\n     // Removing symbolic link should succeed.\n     remove_file(&symlink_path).unwrap();\n \n     // Removing file should succeed.\n     remove_file(&path).unwrap();\n+}\n+\n+fn test_errors() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_errors.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    // The following tests also check that the `__errno_location()` shim is working properly.\n+    // Opening a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n+    // Removing a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n+    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, check_metadata(bytes, &path).unwrap_err().kind());\n+}\n \n+fn test_rename() {\n+    let tmp = std::env::temp_dir();\n     // Renaming a file should succeed.\n-    let path1 = tmp.join(\"rename_source.txt\");\n-    let path2 = tmp.join(\"rename_destination.txt\");\n+    let path1 = tmp.join(\"miri_test_fs_rename_source.txt\");\n+    let path2 = tmp.join(\"miri_test_fs_rename_destination.txt\");\n     // Clean files for robustness.\n     remove_file(&path1).ok();\n     remove_file(&path2).ok();\n@@ -103,12 +195,4 @@ fn main() {\n     assert_eq!(ErrorKind::NotFound, path1.metadata().unwrap_err().kind());\n     assert!(path2.metadata().unwrap().is_file());\n     remove_file(&path2).unwrap();\n-\n-    // The two following tests also check that the `__errno_location()` shim is working properly.\n-    // Opening a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n-    // Removing a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n-    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n }"}]}