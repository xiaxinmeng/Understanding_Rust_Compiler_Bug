{"sha": "d7e2650db200dcb918b5346e137ee6c1e4bc614a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTI2NTBkYjIwMGRjYjkxOGI1MzQ2ZTEzN2VlNmMxZTRiYzYxNGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-21T16:17:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-25T14:53:52Z"}, "message": "miri: avoid a bunch of casts by offering usized-based field indexing", "tree": {"sha": "8d1b7f051612f88970c539ea1b828dd9dcd5dd02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1b7f051612f88970c539ea1b828dd9dcd5dd02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e2650db200dcb918b5346e137ee6c1e4bc614a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e2650db200dcb918b5346e137ee6c1e4bc614a", "html_url": "https://github.com/rust-lang/rust/commit/d7e2650db200dcb918b5346e137ee6c1e4bc614a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e2650db200dcb918b5346e137ee6c1e4bc614a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd15b659c7f20d9b740b3c7b53dde9dcd0132f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd15b659c7f20d9b740b3c7b53dde9dcd0132f9d", "html_url": "https://github.com/rust-lang/rust/commit/cd15b659c7f20d9b740b3c7b53dde9dcd0132f9d"}], "stats": {"total": 174, "additions": 106, "deletions": 68}, "files": [{"sha": "6e7e6f9d34526277f6c6a68cf87f776d62602497", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -1,5 +1,7 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n@@ -37,7 +39,7 @@ pub(crate) fn const_field<'tcx>(\n         Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n     };\n     // then project\n-    let field = ecx.operand_field(down, field.index() as u64).unwrap();\n+    let field = ecx.operand_field(down, field.index()).unwrap();\n     // and finally move back to the const world, always normalizing because\n     // this is not called for statics.\n     op_to_const(&ecx, field)\n@@ -68,10 +70,11 @@ pub(crate) fn destructure_const<'tcx>(\n \n     let variant = ecx.read_discriminant(op).unwrap().1;\n \n+    // We go to `usize` as we cannot allocate anything bigger anyway.\n     let field_count = match val.ty.kind {\n-        ty::Array(_, len) => len.eval_usize(tcx, param_env),\n-        ty::Adt(def, _) => def.variants[variant].fields.len() as u64,\n-        ty::Tuple(substs) => substs.len() as u64,\n+        ty::Array(_, len) => usize::try_from(len.eval_usize(tcx, param_env)).unwrap(),\n+        ty::Adt(def, _) => def.variants[variant].fields.len(),\n+        ty::Tuple(substs) => substs.len(),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n "}, {"sha": "f7327825ca4b76be26a6a59975bd46b5b57f0f6c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -320,11 +320,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let dst_field = self.place_field(dest, i as u64)?;\n+                    let dst_field = self.place_field(dest, i)?;\n                     if dst_field.layout.is_zst() {\n                         continue;\n                     }\n-                    let src_field = self.operand_field(src, i as u64)?;\n+                    let src_field = self.operand_field(src, i)?;\n                     if src_field.layout.ty == dst_field.layout.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {"}, {"sha": "e5f89b10e76ed722432828219f46cac5ebeefad4", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -350,8 +350,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n \n                 for i in 0..len {\n-                    let place = self.place_field(dest, i)?;\n-                    let value = if i == index { elem } else { self.operand_field(input, i)? };\n+                    let place = self.place_index(dest, i)?;\n+                    let value = if i == index { elem } else { self.operand_index(input, i)? };\n                     self.copy_op(value, place)?;\n                 }\n             }\n@@ -370,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"Return type `{}` must match vector element type `{}`\",\n                     dest.layout.ty, e_ty\n                 );\n-                self.copy_op(self.operand_field(args[0], index)?, dest)?;\n+                self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n             _ => return Ok(false),\n         }"}, {"sha": "9c2175dc0e40ace73c70084ac51a808d8ff064a2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -351,7 +351,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn operand_field(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n@@ -362,7 +362,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n             let immediate = Scalar::zst().into();\n@@ -384,6 +383,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n     }\n \n+    pub fn operand_index(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        if let Ok(index) = usize::try_from(index) {\n+            // We can just treat this as a field.\n+            self.operand_field(op, index)\n+        } else {\n+            // Indexing into a big array. This must be an mplace.\n+            let mplace = op.assert_mem_place(self);\n+            Ok(self.mplace_index(mplace, index)?.into())\n+        }\n+    }\n+\n     pub fn operand_downcast(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -406,7 +420,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.operand_field(base, u64::try_from(field.index()).unwrap())?,\n+            Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n@@ -593,7 +607,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // read raw discriminant value\n-        let discr_op = self.operand_field(rval, u64::try_from(discr_index).unwrap())?;\n+        let discr_op = self.operand_field(rval, discr_index)?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);"}, {"sha": "ae754ab4feb26c03f33ef91309e87546d70d3d13", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -386,43 +386,20 @@ where\n         Ok(place)\n     }\n \n-    /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n-    /// possible without allocating, so it can take `&self`. Also return the field's layout.\n+    /// Offset a pointer to project to a field of a struct/union. Unlike `place_field`, this is\n+    /// always possible without allocating, so it can take `&self`. Also return the field's layout.\n     /// This supports both struct and array fields.\n+    ///\n+    /// This also works for arrays, but then the `usize` index type is restricting.\n+    /// For indexing into arrays, use `mplace_index`.\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        // Not using the layout method because we want to compute on u64\n-        let (offset, field_layout) = match base.layout.fields {\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                let field = usize::try_from(field).unwrap();\n-                (offsets[field], base.layout.field(self, field)?)\n-            }\n-            layout::FieldPlacement::Array { stride, .. } => {\n-                let len = base.len(self)?;\n-                if field >= len {\n-                    // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len, index: field });\n-                }\n-                // All fields have the same layout.\n-                (Size::mul(stride, field), base.layout.field(self, 9)?)\n-            }\n-            layout::FieldPlacement::Union(count) => {\n-                let field = usize::try_from(field).unwrap();\n-                assert!(\n-                    field < count,\n-                    \"Tried to access field {} of union {:#?} with {} fields\",\n-                    field,\n-                    base.layout,\n-                    count\n-                );\n-                // Offset is always 0\n-                (Size::from_bytes(0), base.layout.field(self, field)?)\n-            }\n-        };\n+        let offset = base.layout.fields.offset(field);\n+        let field_layout = base.layout.field(self, field)?;\n \n         // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n@@ -452,6 +429,32 @@ where\n         base.offset(offset, meta, field_layout, self)\n     }\n \n+    /// Index into an array.\n+    #[inline(always)]\n+    pub fn mplace_index(\n+        &self,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // Not using the layout method because we want to compute on u64\n+        match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let len = base.len(self)?;\n+                if index >= len {\n+                    // This can only be reached in ConstProp and non-rustc-MIR.\n+                    throw_ub!(BoundsCheckFailed { len, index });\n+                }\n+                let offset = Size::mul(stride, index);\n+                // All fields have the same layout.\n+                let field_layout = base.layout.field(self, 0)?;\n+\n+                assert!(!field_layout.is_unsized());\n+                base.offset(offset, MemPlaceMeta::None, field_layout, self)\n+            }\n+            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+        }\n+    }\n+\n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n     pub(super) fn mplace_array_fields(\n@@ -528,16 +531,19 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.mplace_field(base, u64::try_from(field.index()).unwrap())?,\n+            Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(n)?;\n-                let n = self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?;\n-                self.mplace_field(base, u64::try_from(n).unwrap())?\n+                let n = u64::try_from(\n+                    self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?,\n+                )\n+                .unwrap();\n+                self.mplace_index(base, n)?\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n@@ -555,7 +561,7 @@ where\n                     u64::from(offset)\n                 };\n \n-                self.mplace_field(base, index)?\n+                self.mplace_index(base, index)?\n             }\n \n             Subslice { from, to, from_end } => {\n@@ -571,14 +577,23 @@ where\n     pub fn place_field(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n         Ok(self.mplace_field(mplace, field)?.into())\n     }\n \n+    pub fn place_index(\n+        &mut self,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+        let mplace = self.force_allocation(base)?;\n+        Ok(self.mplace_index(mplace, index)?.into())\n+    }\n+\n     pub fn place_downcast(\n         &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -604,7 +619,7 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.place_field(base, u64::try_from(field.index()).unwrap())?,\n+            Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n@@ -1073,7 +1088,7 @@ where\n                 let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, u64::try_from(discr_index).unwrap())?;\n+                let discr_dest = self.place_field(dest, discr_index)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n@@ -1104,7 +1119,7 @@ where\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, u64::try_from(discr_index).unwrap())?;\n+                    let niche_dest = self.place_field(dest, discr_index)?;\n                     self.write_immediate(*discr_val, niche_dest)?;\n                 }\n             }"}, {"sha": "6ec11d42f52d2176933dc8653f2264a0d94172f0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -2,8 +2,6 @@\n //!\n //! The main entry point is the `step` method.\n \n-use std::convert::TryFrom;\n-\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc::ty::layout::LayoutOf;\n@@ -194,8 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest =\n-                            self.place_field(dest, u64::try_from(field_index).unwrap())?;\n+                        let field_dest = self.place_field(dest, field_index)?;\n                         self.copy_op(op, field_dest)?;\n                     }\n                 }"}, {"sha": "5ce5ba31a0987ddfaec960a952312be4e6c7b549", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -309,7 +309,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                     .map(|&a| Ok(a))\n                                     .chain(\n                                         (0..untuple_arg.layout.fields.count())\n-                                            .map(|i| self.operand_field(untuple_arg, i as u64)),\n+                                            .map(|i| self.operand_field(untuple_arg, i)),\n                                     )\n                                     .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n                                     )?,\n@@ -332,7 +332,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n-                                let dest = self.place_field(dest, i as u64)?;\n+                                let dest = self.place_field(dest, i)?;\n                                 self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n                         } else {"}, {"sha": "fa8d67029dfcce2d6d5fb9e36a9ec5baec956dbd", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -1,3 +1,4 @@\n+use std::convert::TryFrom;\n use std::ops::Mul;\n \n use rustc::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n@@ -56,7 +57,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n-            ptr_size * (3 + methods.len() as u64),\n+            Size::mul(ptr_size, u64::try_from(methods.len()).unwrap().checked_add(3).unwrap()),\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n@@ -172,10 +173,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .expect(\"cannot be a ZST\");\n         let alloc = self.memory.get_raw(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.not_undef()?;\n-        let size = self.force_bits(size, pointer_size)? as u64;\n+        let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align =\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n-        let align = self.force_bits(align, pointer_size)? as u64;\n+        let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout().obj_size_bound() {\n             throw_ub_format!("}, {"sha": "e8a7626406413682e307711179cf35bfe8e289e5", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -1,8 +1,6 @@\n //! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n //! types until we arrive at the leaves, with custom handling for primitive types.\n \n-use std::convert::TryFrom;\n-\n use rustc::mir::interpret::InterpResult;\n use rustc::ty;\n use rustc::ty::layout::{self, TyLayout, VariantIdx};\n@@ -30,7 +28,8 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self>;\n+    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n+    -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n@@ -64,7 +63,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n@@ -98,7 +101,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n     }\n }\n@@ -208,7 +215,7 @@ macro_rules! make_value_visitor {\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n                             (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), u64::try_from(i).unwrap())\n+                                v.project_field(self.ecx(), i)\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;"}, {"sha": "7cf2b690d352da6dc71d60d85ab27d79d4299f92", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2650db200dcb918b5346e137ee6c1e4bc614a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=d7e2650db200dcb918b5346e137ee6c1e4bc614a", "patch": "@@ -3,6 +3,7 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n+use std::convert::TryFrom;\n use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -665,7 +666,7 @@ impl FieldPlacement {\n                 Size::ZERO\n             }\n             FieldPlacement::Array { stride, count } => {\n-                let i = i as u64;\n+                let i = u64::try_from(i).unwrap();\n                 assert!(i < count);\n                 stride * i\n             }"}]}