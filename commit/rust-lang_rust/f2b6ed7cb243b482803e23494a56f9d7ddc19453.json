{"sha": "f2b6ed7cb243b482803e23494a56f9d7ddc19453", "node_id": "C_kwDOAAsO6NoAKGYyYjZlZDdjYjI0M2I0ODI4MDNlMjM0OTRhNTZmOWQ3ZGRjMTk0NTM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T19:03:45Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:24Z"}, "message": "Split out `redundant_pattern_match`", "tree": {"sha": "00981aa4a4b86acb7e6e266b8b41726d2e5c23e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00981aa4a4b86acb7e6e266b8b41726d2e5c23e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2b6ed7cb243b482803e23494a56f9d7ddc19453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b6ed7cb243b482803e23494a56f9d7ddc19453", "html_url": "https://github.com/rust-lang/rust/commit/f2b6ed7cb243b482803e23494a56f9d7ddc19453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2b6ed7cb243b482803e23494a56f9d7ddc19453/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64548250e7c740d0376d638214df65fb2ace35f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/64548250e7c740d0376d638214df65fb2ace35f1", "html_url": "https://github.com/rust-lang/rust/commit/64548250e7c740d0376d638214df65fb2ace35f1"}], "stats": {"total": 883, "additions": 437, "deletions": 446}, "files": [{"sha": "4b09bdb98ecfa8df28a0a245d2a2624d18911c62", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 446, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/f2b6ed7cb243b482803e23494a56f9d7ddc19453/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b6ed7cb243b482803e23494a56f9d7ddc19453/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=f2b6ed7cb243b482803e23494a56f9d7ddc19453", "patch": "@@ -32,6 +32,7 @@ use std::cmp::{max, Ordering};\n \n mod match_like_matches;\n mod match_same_arms;\n+mod redundant_pattern_match;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -1701,452 +1702,6 @@ where\n     None\n }\n \n-mod redundant_pattern_match {\n-    use super::REDUNDANT_PATTERN_MATCHING;\n-    use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::source::snippet;\n-    use clippy_utils::sugg::Sugg;\n-    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n-    use clippy_utils::{higher, match_def_path};\n-    use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n-    use if_chain::if_chain;\n-    use rustc_ast::ast::LitKind;\n-    use rustc_data_structures::fx::FxHashSet;\n-    use rustc_errors::Applicability;\n-    use rustc_hir::LangItem::{OptionNone, PollPending};\n-    use rustc_hir::{\n-        intravisit::{walk_expr, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n-    };\n-    use rustc_lint::LateContext;\n-    use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n-    use rustc_span::sym;\n-\n-    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            if_else,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-        }\n-        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-            find_sugg_for_match(cx, expr, op, arms);\n-        }\n-        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n-        }\n-    }\n-\n-    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n-    /// deallocate memory. For these types, and composites containing them, changing the drop order\n-    /// won't result in any observable side effects.\n-    fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-    }\n-\n-    fn type_needs_ordered_drop_inner<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        ty: Ty<'tcx>,\n-        seen: &mut FxHashSet<Ty<'tcx>>,\n-    ) -> bool {\n-        if !seen.insert(ty) {\n-            return false;\n-        }\n-        if !ty.needs_drop(cx.tcx, cx.param_env) {\n-            false\n-        } else if !cx\n-            .tcx\n-            .lang_items()\n-            .drop_trait()\n-            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-        {\n-            // This type doesn't implement drop, so no side effects here.\n-            // Check if any component type has any.\n-            match ty.kind() {\n-                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n-                ty::Adt(adt, subs) => adt\n-                    .all_fields()\n-                    .map(|f| f.ty(cx.tcx, subs))\n-                    .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                _ => true,\n-            }\n-        }\n-        // Check for std types which implement drop, but only for memory allocation.\n-        else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-            || is_type_diagnostic_item(cx, ty, sym::Rc)\n-            || is_type_diagnostic_item(cx, ty, sym::Arc)\n-            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-            || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-            || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-            || match_type(cx, ty, &paths::WEAK_RC)\n-            || match_type(cx, ty, &paths::WEAK_ARC)\n-        {\n-            // Check all of the generic arguments.\n-            if let ty::Adt(_, subs) = ty.kind() {\n-                subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-            } else {\n-                true\n-            }\n-        } else {\n-            true\n-        }\n-    }\n-\n-    // Extract the generic arguments out of a type\n-    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n-        if_chain! {\n-            if let ty::Adt(_, subs) = ty.kind();\n-            if let Some(sub) = subs.get(index);\n-            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n-            then {\n-                Some(sub_ty)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    // Checks if there are any temporaries created in the given expression for which drop order\n-    // matters.\n-    fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-        struct V<'a, 'tcx> {\n-            cx: &'a LateContext<'tcx>,\n-            res: bool,\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-                match expr.kind {\n-                    // Taking the reference of a value leaves a temporary\n-                    // e.g. In `&String::new()` the string is a temporary value.\n-                    // Remaining fields are temporary values\n-                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                        if !matches!(expr.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(expr);\n-                            }\n-                        }\n-                    },\n-                    // the base type is alway taken by reference.\n-                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                    ExprKind::Index(base, index) => {\n-                        if !matches!(base.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(base);\n-                            }\n-                        }\n-                        self.visit_expr(index);\n-                    },\n-                    // Method calls can take self by reference.\n-                    // e.g. In `String::new().len()` the string is a temporary value.\n-                    ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                            let self_by_ref = self\n-                                .cx\n-                                .typeck_results()\n-                                .type_dependent_def_id(expr.hir_id)\n-                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                            if self_by_ref\n-                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n-                            {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(self_arg);\n-                            }\n-                        }\n-                        args.iter().for_each(|arg| self.visit_expr(arg));\n-                    },\n-                    // Either explicitly drops values, or changes control flow.\n-                    ExprKind::DropTemps(_)\n-                    | ExprKind::Ret(_)\n-                    | ExprKind::Break(..)\n-                    | ExprKind::Yield(..)\n-                    | ExprKind::Block(Block { expr: None, .. }, _)\n-                    | ExprKind::Loop(..) => (),\n-\n-                    // Only consider the final expression.\n-                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                    _ => walk_expr(self, expr),\n-                }\n-            }\n-        }\n-\n-        let mut v = V { cx, res: false };\n-        v.visit_expr(expr);\n-        v.res\n-    }\n-\n-    fn find_sugg_for_if_let<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        expr: &'tcx Expr<'_>,\n-        let_pat: &Pat<'_>,\n-        let_expr: &'tcx Expr<'_>,\n-        keyword: &'static str,\n-        has_else: bool,\n-    ) {\n-        // also look inside refs\n-        // if we have &None for example, peel it so we can detect \"if let None = x\"\n-        let check_pat = match let_pat.kind {\n-            PatKind::Ref(inner, _mutability) => inner,\n-            _ => let_pat,\n-        };\n-        let op_ty = cx.typeck_results().expr_ty(let_expr);\n-        // Determine which function should be used, and the type contained by the corresponding\n-        // variant.\n-        let (good_method, inner_ty) = match check_pat.kind {\n-            PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n-                if let PatKind::Wild = sub_pat.kind {\n-                    let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n-                    let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n-                    let lang_items = cx.tcx.lang_items();\n-                    if Some(id) == lang_items.result_ok_variant() {\n-                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n-                    } else if Some(id) == lang_items.result_err_variant() {\n-                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n-                    } else if Some(id) == lang_items.option_some_variant() {\n-                        (\"is_some()\", op_ty)\n-                    } else if Some(id) == lang_items.poll_ready_variant() {\n-                        (\"is_ready()\", op_ty)\n-                    } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n-                        (\"is_ipv4()\", op_ty)\n-                    } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n-                        (\"is_ipv6()\", op_ty)\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            },\n-            PatKind::Path(ref path) => {\n-                let method = if is_lang_ctor(cx, path, OptionNone) {\n-                    \"is_none()\"\n-                } else if is_lang_ctor(cx, path, PollPending) {\n-                    \"is_pending()\"\n-                } else {\n-                    return;\n-                };\n-                // `None` and `Pending` don't have an inner type.\n-                (method, cx.tcx.types.unit)\n-            },\n-            _ => return,\n-        };\n-\n-        // If this is the last expression in a block or there is an else clause then the whole\n-        // type needs to be considered, not just the inner type of the branch being matched on.\n-        // Note the last expression in a block is dropped after all local bindings.\n-        let check_ty = if has_else\n-            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n-        {\n-            op_ty\n-        } else {\n-            inner_ty\n-        };\n-\n-        // All temporaries created in the scrutinee expression are dropped at the same time as the\n-        // scrutinee would be, so they have to be considered as well.\n-        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n-        // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n-\n-        // check that `while_let_on_iterator` lint does not trigger\n-        if_chain! {\n-            if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n-            if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, let_expr, sym::Iterator);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        let result_expr = match &let_expr.kind {\n-            ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            ExprKind::Unary(UnOp::Deref, deref) => deref,\n-            _ => let_expr,\n-        };\n-\n-        span_lint_and_then(\n-            cx,\n-            REDUNDANT_PATTERN_MATCHING,\n-            let_pat.span,\n-            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-            |diag| {\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                let expr_span = expr.span;\n-\n-                // if/while let ... = ... { ... }\n-                //                 ^^^\n-                let op_span = result_expr.span.source_callsite();\n-\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^\n-                let span = expr_span.until(op_span.shrink_to_hi());\n-\n-                let app = if needs_drop {\n-                    Applicability::MaybeIncorrect\n-                } else {\n-                    Applicability::MachineApplicable\n-                };\n-\n-                let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n-                    .maybe_par()\n-                    .to_string();\n-\n-                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n-\n-                if needs_drop {\n-                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n-                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n-                }\n-            },\n-        );\n-    }\n-\n-    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-        if arms.len() == 2 {\n-            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-            let found_good_method = match node_pair {\n-                (\n-                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n-                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::RESULT_OK,\n-                            &paths::RESULT_ERR,\n-                            \"is_ok()\",\n-                            \"is_err()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::IPADDR_V4,\n-                                &paths::IPADDR_V6,\n-                                \"is_ipv4()\",\n-                                \"is_ipv6()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                    if patterns.len() == 1 =>\n-                {\n-                    if let PatKind::Wild = patterns[0].kind {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::OPTION_SOME,\n-                            &paths::OPTION_NONE,\n-                            \"is_some()\",\n-                            \"is_none()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::POLL_READY,\n-                                &paths::POLL_PENDING,\n-                                \"is_ready()\",\n-                                \"is_pending()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            };\n-\n-            if let Some(good_method) = found_good_method {\n-                let span = expr.span.to(op.span);\n-                let result_expr = match &op.kind {\n-                    ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-                    _ => op,\n-                };\n-                span_lint_and_then(\n-                    cx,\n-                    REDUNDANT_PATTERN_MATCHING,\n-                    expr.span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            span,\n-                            \"try this\",\n-                            format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n-                            Applicability::MaybeIncorrect, // snippet\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n-    #[allow(clippy::too_many_arguments)]\n-    fn find_good_method_for_match<'a>(\n-        cx: &LateContext<'_>,\n-        arms: &[Arm<'_>],\n-        path_left: &QPath<'_>,\n-        path_right: &QPath<'_>,\n-        expected_left: &[&str],\n-        expected_right: &[&str],\n-        should_be_left: &'a str,\n-        should_be_right: &'a str,\n-    ) -> Option<&'a str> {\n-        let left_id = cx\n-            .typeck_results()\n-            .qpath_res(path_left, arms[0].pat.hir_id)\n-            .opt_def_id()?;\n-        let right_id = cx\n-            .typeck_results()\n-            .qpath_res(path_right, arms[1].pat.hir_id)\n-            .opt_def_id()?;\n-        let body_node_pair =\n-            if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-                (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-            } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-                (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-            } else {\n-                return None;\n-            };\n-\n-        match body_node_pair {\n-            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n #[test]\n fn test_overlapping() {\n     use rustc_span::source_map::DUMMY_SP;"}, {"sha": "61c5fa0872f6a4527e3a5ef3db62986fb5d2b191", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/f2b6ed7cb243b482803e23494a56f9d7ddc19453/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b6ed7cb243b482803e23494a56f9d7ddc19453/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=f2b6ed7cb243b482803e23494a56f9d7ddc19453", "patch": "@@ -0,0 +1,436 @@\n+use super::REDUNDANT_PATTERN_MATCHING;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::{higher, match_def_path};\n+use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, PollPending};\n+use rustc_hir::{\n+    intravisit::{walk_expr, Visitor},\n+    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n+use rustc_span::sym;\n+\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let Some(higher::IfLet {\n+        if_else,\n+        let_pat,\n+        let_expr,\n+        ..\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n+    }\n+    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+        find_sugg_for_match(cx, expr, op, arms);\n+    }\n+    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n+    }\n+}\n+\n+/// Checks if the drop order for a type matters. Some std types implement drop solely to\n+/// deallocate memory. For these types, and composites containing them, changing the drop order\n+/// won't result in any observable side effects.\n+fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+}\n+\n+fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+    if !seen.insert(ty) {\n+        return false;\n+    }\n+    if !ty.needs_drop(cx.tcx, cx.param_env) {\n+        false\n+    } else if !cx\n+        .tcx\n+        .lang_items()\n+        .drop_trait()\n+        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    {\n+        // This type doesn't implement drop, so no side effects here.\n+        // Check if any component type has any.\n+        match ty.kind() {\n+            ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Adt(adt, subs) => adt\n+                .all_fields()\n+                .map(|f| f.ty(cx.tcx, subs))\n+                .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            _ => true,\n+        }\n+    }\n+    // Check for std types which implement drop, but only for memory allocation.\n+    else if is_type_diagnostic_item(cx, ty, sym::Vec)\n+        || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+        || is_type_diagnostic_item(cx, ty, sym::Rc)\n+        || is_type_diagnostic_item(cx, ty, sym::Arc)\n+        || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n+        || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n+        || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n+        || match_type(cx, ty, &paths::WEAK_RC)\n+        || match_type(cx, ty, &paths::WEAK_ARC)\n+    {\n+        // Check all of the generic arguments.\n+        if let ty::Adt(_, subs) = ty.kind() {\n+            subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n+        } else {\n+            true\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+// Extract the generic arguments out of a type\n+fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+    if_chain! {\n+        if let ty::Adt(_, subs) = ty.kind();\n+        if let Some(sub) = subs.get(index);\n+        if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+        then {\n+            Some(sub_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Checks if there are any temporaries created in the given expression for which drop order\n+// matters.\n+fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: bool,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            match expr.kind {\n+                // Taking the reference of a value leaves a temporary\n+                // e.g. In `&String::new()` the string is a temporary value.\n+                // Remaining fields are temporary values\n+                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                    if !matches!(expr.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(expr);\n+                        }\n+                    }\n+                },\n+                // the base type is alway taken by reference.\n+                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                ExprKind::Index(base, index) => {\n+                    if !matches!(base.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(base);\n+                        }\n+                    }\n+                    self.visit_expr(index);\n+                },\n+                // Method calls can take self by reference.\n+                // e.g. In `String::new().len()` the string is a temporary value.\n+                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n+                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                        let self_by_ref = self\n+                            .cx\n+                            .typeck_results()\n+                            .type_dependent_def_id(expr.hir_id)\n+                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                        if self_by_ref && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(self_arg);\n+                        }\n+                    }\n+                    args.iter().for_each(|arg| self.visit_expr(arg));\n+                },\n+                // Either explicitly drops values, or changes control flow.\n+                ExprKind::DropTemps(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Break(..)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Block(Block { expr: None, .. }, _)\n+                | ExprKind::Loop(..) => (),\n+\n+                // Only consider the final expression.\n+                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                _ => walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res: false };\n+    v.visit_expr(expr);\n+    v.res\n+}\n+\n+fn find_sugg_for_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    keyword: &'static str,\n+    has_else: bool,\n+) {\n+    // also look inside refs\n+    // if we have &None for example, peel it so we can detect \"if let None = x\"\n+    let check_pat = match let_pat.kind {\n+        PatKind::Ref(inner, _mutability) => inner,\n+        _ => let_pat,\n+    };\n+    let op_ty = cx.typeck_results().expr_ty(let_expr);\n+    // Determine which function should be used, and the type contained by the corresponding\n+    // variant.\n+    let (good_method, inner_ty) = match check_pat.kind {\n+        PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n+            if let PatKind::Wild = sub_pat.kind {\n+                let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n+                let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                let lang_items = cx.tcx.lang_items();\n+                if Some(id) == lang_items.result_ok_variant() {\n+                    (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.result_err_variant() {\n+                    (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.option_some_variant() {\n+                    (\"is_some()\", op_ty)\n+                } else if Some(id) == lang_items.poll_ready_variant() {\n+                    (\"is_ready()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                    (\"is_ipv4()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                    (\"is_ipv6()\", op_ty)\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        PatKind::Path(ref path) => {\n+            let method = if is_lang_ctor(cx, path, OptionNone) {\n+                \"is_none()\"\n+            } else if is_lang_ctor(cx, path, PollPending) {\n+                \"is_pending()\"\n+            } else {\n+                return;\n+            };\n+            // `None` and `Pending` don't have an inner type.\n+            (method, cx.tcx.types.unit)\n+        },\n+        _ => return,\n+    };\n+\n+    // If this is the last expression in a block or there is an else clause then the whole\n+    // type needs to be considered, not just the inner type of the branch being matched on.\n+    // Note the last expression in a block is dropped after all local bindings.\n+    let check_ty = if has_else\n+        || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+    {\n+        op_ty\n+    } else {\n+        inner_ty\n+    };\n+\n+    // All temporaries created in the scrutinee expression are dropped at the same time as the\n+    // scrutinee would be, so they have to be considered as well.\n+    // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+    // for the duration if body.\n+    let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+\n+    // check that `while_let_on_iterator` lint does not trigger\n+    if_chain! {\n+        if keyword == \"while\";\n+        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if method_path.ident.name == sym::next;\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        then {\n+            return;\n+        }\n+    }\n+\n+    let result_expr = match &let_expr.kind {\n+        ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+        ExprKind::Unary(UnOp::Deref, deref) => deref,\n+        _ => let_expr,\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        REDUNDANT_PATTERN_MATCHING,\n+        let_pat.span,\n+        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        |diag| {\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+            let expr_span = expr.span;\n+\n+            // if/while let ... = ... { ... }\n+            //                 ^^^\n+            let op_span = result_expr.span.source_callsite();\n+\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^\n+            let span = expr_span.until(op_span.shrink_to_hi());\n+\n+            let app = if needs_drop {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            };\n+\n+            let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+                .maybe_par()\n+                .to_string();\n+\n+            diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+            if needs_drop {\n+                diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+            }\n+        },\n+    );\n+}\n+\n+fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                PatKind::TupleStruct(ref path_right, patterns_right, _),\n+            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::IPADDR_V4,\n+                            &paths::IPADDR_V6,\n+                            \"is_ipv4()\",\n+                            \"is_ipv6()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+                if patterns.len() == 1 =>\n+            {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::POLL_READY,\n+                            &paths::POLL_PENDING,\n+                            \"is_ready()\",\n+                            \"is_pending()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            let span = expr.span.to(op.span);\n+            let result_expr = match &op.kind {\n+                ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+                _ => op,\n+            };\n+            span_lint_and_then(\n+                cx,\n+                REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |diag| {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n+                        Applicability::MaybeIncorrect, // snippet\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+fn find_good_method_for_match<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    path_left: &QPath<'_>,\n+    path_right: &QPath<'_>,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str,\n+) -> Option<&'a str> {\n+    let left_id = cx\n+        .typeck_results()\n+        .qpath_res(path_left, arms[0].pat.hir_id)\n+        .opt_def_id()?;\n+    let right_id = cx\n+        .typeck_results()\n+        .qpath_res(path_right, arms[1].pat.hir_id)\n+        .opt_def_id()?;\n+    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}]}