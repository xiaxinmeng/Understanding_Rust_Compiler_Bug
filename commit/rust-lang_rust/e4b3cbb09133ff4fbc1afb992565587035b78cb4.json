{"sha": "e4b3cbb09133ff4fbc1afb992565587035b78cb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YjNjYmIwOTEzM2ZmNGZiYzFhZmI5OTI1NjU1ODcwMzViNzhjYjQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-29T16:44:04Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-29T16:44:04Z"}, "message": "Merge pull request #726 from Manishearth/fmt\n\nRustfmt everything", "tree": {"sha": "5312a526dcca4f5a4119442a31bc3ef4f8aaec9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5312a526dcca4f5a4119442a31bc3ef4f8aaec9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4b3cbb09133ff4fbc1afb992565587035b78cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4b3cbb09133ff4fbc1afb992565587035b78cb4", "html_url": "https://github.com/rust-lang/rust/commit/e4b3cbb09133ff4fbc1afb992565587035b78cb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4b3cbb09133ff4fbc1afb992565587035b78cb4/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e256055dc498a887283895dd03ebc7426478b2fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/e256055dc498a887283895dd03ebc7426478b2fe", "html_url": "https://github.com/rust-lang/rust/commit/e256055dc498a887283895dd03ebc7426478b2fe"}, {"sha": "bd45cfd2739babc9350760cc4b5989a729fe447e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd45cfd2739babc9350760cc4b5989a729fe447e", "html_url": "https://github.com/rust-lang/rust/commit/bd45cfd2739babc9350760cc4b5989a729fe447e"}], "stats": {"total": 342, "additions": 138, "deletions": 204}, "files": [{"sha": "9cb11968abcf6926fdabc94b591a5648697ccf6d", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -92,8 +92,7 @@ impl LateLintPass for BlockInIfCondition {\n                                                         snippet_block(cx, then.span, \"..\")));\n                         }\n                     } else {\n-                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span,\n-                                                                   |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if in_macro(cx, span) || differing_macro_contexts(expr.span, span) {\n                             return;\n                         }"}, {"sha": "74397304eda85c870be140c8fac3a8d9447b73b9", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -71,15 +71,13 @@ fn check_if(cx: &LateContext, e: &Expr) {\n                 });\n             }}\n         } else if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n-                       single_stmt_of_block(then) {\n+               single_stmt_of_block(then) {\n             if e.span.expn_id != sp.expn_id {\n                 return;\n             }\n-            span_lint_and_then(cx,\n-                               COLLAPSIBLE_IF,\n-                               e.span,\n-                               \"this if statement can be collapsed\", |db| {\n-                db.span_suggestion(e.span, \"try\",\n+            span_lint_and_then(cx, COLLAPSIBLE_IF, e.span, \"this if statement can be collapsed\", |db| {\n+                db.span_suggestion(e.span,\n+                                   \"try\",\n                                    format!(\"if {} && {} {}\",\n                                            check_to_string(cx, check),\n                                            check_to_string(cx, check_inner),"}, {"sha": "691acad6e9202a96ddebbba3f25c7545be657c0b", "filename": "src/copies.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -91,9 +91,7 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n         h.finish()\n     };\n \n-    let eq: &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool {\n-        SpanlessEq::new(cx).eq_block(lhs, rhs)\n-    };\n+    let eq: &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same(blocks, hash, eq) {\n         span_note_and_lint(cx,"}, {"sha": "8bdcb4b01670a0e865dceb89c26625808700663d", "filename": "src/derive.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -87,13 +87,7 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq(\n-    cx: &LateContext,\n-    span: Span,\n-    trait_ref: &TraitRef,\n-    ty: ty::Ty,\n-    hash_is_automatically_derived: bool\n-) {\n+fn check_hash_peq(cx: &LateContext, span: Span, trait_ref: &TraitRef, ty: ty::Ty, hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n         match_path(&trait_ref.path, &HASH_PATH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n@@ -143,9 +137,7 @@ fn check_hash_peq(\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n-fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>,\n-                              item: &Item,\n-                              trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n     if match_path(&trait_ref.path, &CLONE_TRAIT_PATH) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, &parameter_environment.free_substs);"}, {"sha": "8a4cf37c0acf62cf2fc57ab39df684feae468f32", "filename": "src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -48,7 +48,7 @@ impl LateLintPass for HashMapLint {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = else_block.is_none() &&\n-                        if then_block.expr.is_some() { 1 } else { 0 } + then_block.stmts.len() == 1;\n+                        ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n \n                     let mut visitor = InsertVisitor {\n                         cx: cx,"}, {"sha": "d7bd4742ebb4fc3acc9867b2f959ea6c0a5cedc9", "filename": "src/enum_variants.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_variants.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -31,17 +31,16 @@ fn var2str(var: &Variant) -> InternedString {\n     var.node.name.name.as_str()\n }\n \n-/*\n-FIXME: waiting for https://github.com/rust-lang/rust/pull/31700\n-fn partial_match(pre: &str, name: &str) -> usize {\n-    // skip(1) to ensure that the prefix never takes the whole variant name\n-    pre.chars().zip(name.chars().rev().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n-}\n-\n-fn partial_rmatch(post: &str, name: &str) -> usize {\n-    // skip(1) to ensure that the postfix never takes the whole variant name\n-    post.chars().rev().zip(name.chars().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n-}*/\n+// FIXME: waiting for https://github.com/rust-lang/rust/pull/31700\n+// fn partial_match(pre: &str, name: &str) -> usize {\n+//    // skip(1) to ensure that the prefix never takes the whole variant name\n+//     pre.chars().zip(name.chars().rev().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n+// }\n+//\n+// fn partial_rmatch(post: &str, name: &str) -> usize {\n+//     // skip(1) to ensure that the postfix never takes the whole variant name\n+//     post.chars().rev().zip(name.chars().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n+// }\n \n fn partial_match(pre: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n@@ -99,7 +98,8 @@ impl EarlyLintPass for EnumVariantNames {\n                                item.span,\n                                &format!(\"All variants have the same {}fix: `{}`\", what, value),\n                                &format!(\"remove the {}fixes and use full paths to \\\n-                                         the variants instead of glob imports\", what));\n+                                         the variants instead of glob imports\",\n+                                        what));\n         }\n     }\n }"}, {"sha": "091280de28dae6da6bf65bdfef00d08c25988da9", "filename": "src/formatting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -96,9 +96,11 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n                         span_note_and_lint(cx,\n                                            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n                                            eqop_span,\n-                                           &format!(\"this looks like you are trying to use `.. {op}= ..`, but you really are doing `.. = ({op} ..)`\", op=op),\n+                                           &format!(\"this looks like you are trying to use `.. {op}= ..`, but you \\\n+                                                     really are doing `.. = ({op} ..)`\",\n+                                                    op = op),\n                                            eqop_span,\n-                                           &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op=op));\n+                                           &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op = op));\n                     }\n                 }\n             }\n@@ -109,9 +111,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n /// Implementation of the SUSPICIOUS_ELSE_FORMATTING lint for weird `else if`.\n fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n-        if unsugar_if(else_).is_some() &&\n-        !differing_macro_contexts(then.span, else_.span) &&\n-        !in_macro(cx, then.span) {\n+        if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(cx, then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to the\n             // \u201cif\u201d of the \u201celse if\u201d block (excluding)\n             let else_span = mk_sp(then.span.hi, else_.span.lo);\n@@ -127,7 +127,8 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n                                        else_span,\n                                        \"this is an `else if` but the formatting might hide it\",\n                                        else_span,\n-                                       \"to remove this lint, remove the `else` or remove the new line between `else` and `if`\");\n+                                       \"to remove this lint, remove the `else` or remove the new line between `else` \\\n+                                        and `if`\");\n                 }\n             }\n         }\n@@ -136,10 +137,8 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n-    if !differing_macro_contexts(first.span, second.span) &&\n-    !in_macro(cx, first.span) &&\n-    unsugar_if(first).is_some() &&\n-    unsugar_if(second).is_some() {\n+    if !differing_macro_contexts(first.span, second.span) && !in_macro(cx, first.span) &&\n+       unsugar_if(first).is_some() && unsugar_if(second).is_some() {\n         // where the else would be\n         let else_span = mk_sp(first.span.hi, second.span.lo);\n \n@@ -150,14 +149,15 @@ fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Exp\n                                    else_span,\n                                    \"this looks like an `else if` but the `else` is missing\",\n                                    else_span,\n-                                   \"to remove this lint, add the missing `else` or add a new line before the second `if`\");\n+                                   \"to remove this lint, add the missing `else` or add a new line before the second \\\n+                                    `if`\");\n             }\n         }\n     }\n }\n \n /// Match `if` or `else if` expressions and return the `then` and `else` block.\n-fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)>{\n+fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)> {\n     match expr.node {\n         ast::ExprKind::If(_, ref then, ref else_) |\n         ast::ExprKind::IfLet(_, _, ref then, ref else_) => Some((then, else_)),"}, {"sha": "548a3d92c2c48b69197c16cd623d7a1552eab16e", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -155,17 +155,11 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned{node: LitKind::Int(0, _), ..} = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n-            span_lint_and_then(cx,\n-                               LEN_ZERO,\n-                               span,\n-                               \"length comparison to zero\",\n-                               |db| {\n-                                   db.span_suggestion(span,\n-                                                      \"consider using `is_empty`\",\n-                                                       format!(\"{}{}.is_empty()\",\n-                                                               op,\n-                                                               snippet(cx, args[0].span, \"_\")));\n-                               });\n+            span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n+                db.span_suggestion(span,\n+                                   \"consider using `is_empty`\",\n+                                   format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")));\n+            });\n         }\n     }\n }"}, {"sha": "600f22ea0016054802d6e9707c92dda451f6d150", "filename": "src/loops.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -370,14 +370,14 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                     span_lint(cx,\n                               NEEDLESS_RANGE_LOOP,\n                               expr.span,\n-                              &format!(\"the loop variable `{}` is used to index `{}`. \\\n-                                        Consider using `for ({}, item) in {}.iter().enumerate(){}{}` or similar iterators\",\n-                                        ident.node.name,\n-                                        indexed,\n-                                        ident.node.name,\n-                                        indexed,\n-                                        take,\n-                                        skip));\n+                              &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for ({}, \\\n+                                        item) in {}.iter().enumerate(){}{}` or similar iterators\",\n+                                       ident.node.name,\n+                                       indexed,\n+                                       ident.node.name,\n+                                       indexed,\n+                                       take,\n+                                       skip));\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n                         format!(\"&{}\", indexed)\n@@ -390,9 +390,9 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                               expr.span,\n                               &format!(\"the loop variable `{}` is only used to index `{}`. \\\n                                         Consider using `for item in {}` or similar iterators\",\n-                                        ident.node.name,\n-                                        indexed,\n-                                        repl));\n+                                       ident.node.name,\n+                                       indexed,\n+                                       repl));\n                 }\n             }\n         }\n@@ -447,9 +447,7 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                                                               \"consider using the following if \\\n                                                                you are attempting to iterate \\\n                                                                over this range in reverse\",\n-                                                               format!(\"({}..{}).rev()` \",\n-                                                                       stop_snippet,\n-                                                                       start_snippet));\n+                                                              format!(\"({}..{}).rev()` \", stop_snippet, start_snippet));\n                                        });\n                 } else if eq {\n                     // if they are equal, it's also problematic - this loop\n@@ -744,6 +742,7 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n \n /// Return true if the type of expr is one that provides IntoIterator impls\n /// for &T and &mut T, such as Vec.\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards"}, {"sha": "4eac4dc611387e4b5f449b1b9c6130d5d469f8c5", "filename": "src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -1,10 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use utils::{CLONE_PATH, OPTION_PATH};\n-use utils::{\n-    is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint,\n-    walk_ptrs_ty, walk_ptrs_ty_depth\n-};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint, walk_ptrs_ty,\n+            walk_ptrs_ty_depth};\n \n /// **What it does:** This lint checks for mapping clone() over an iterator.\n ///"}, {"sha": "1b05162c86a87d8c5ff41a23981419130283167a", "filename": "src/matches.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -134,10 +134,11 @@ impl LateLintPass for MatchPass {\n     }\n }\n \n+#[cfg_attr(rustfmt, rustfmt_skip)]\n fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n-       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n+      arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+      arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n         let els = if is_unit_expr(&arms[1].body) {\n             None\n         } else if let ExprBlock(_) = arms[1].body.node {\n@@ -167,28 +168,28 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n                            lint,\n                            expr.span,\n                            \"you seem to be trying to use match for destructuring a single pattern. \\\n-                           Consider using `if let`\", |db| {\n-                db.span_suggestion(expr.span, \"try this\",\n-                                   format!(\"if let {} = {} {}{}\",\n-                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                           snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\"),\n-                                           els_str));\n-            });\n+                           Consider using `if let`\",\n+                           |db| {\n+                               db.span_suggestion(expr.span,\n+                                                  \"try this\",\n+                                                  format!(\"if let {} = {} {}{}\",\n+                                                          snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                          snippet(cx, ex.span, \"..\"),\n+                                                          expr_block(cx, &arms[0].body, None, \"..\"),\n+                                                          els_str));\n+                           });\n     }\n }\n \n fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n-    let candidates = &[\n-        (&COW_PATH, \"Borrowed\"),\n-        (&COW_PATH, \"Cow::Borrowed\"),\n-        (&COW_PATH, \"Cow::Owned\"),\n-        (&COW_PATH, \"Owned\"),\n-        (&OPTION_PATH, \"None\"),\n-        (&RESULT_PATH, \"Err\"),\n-        (&RESULT_PATH, \"Ok\"),\n-    ];\n+    let candidates = &[(&COW_PATH, \"Borrowed\"),\n+                       (&COW_PATH, \"Cow::Borrowed\"),\n+                       (&COW_PATH, \"Cow::Owned\"),\n+                       (&COW_PATH, \"Owned\"),\n+                       (&OPTION_PATH, \"None\"),\n+                       (&RESULT_PATH, \"Err\"),\n+                       (&RESULT_PATH, \"Ok\")];\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, Some(ref inner)) => {"}, {"sha": "94548cf9672df3c6dcef6553c5afd34b2acb90eb", "filename": "src/methods.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -565,7 +565,9 @@ fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr) {\n     let ty = cx.tcx.expr_ty(arg);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) = ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n-            let mut db = span_lint(cx, CLONE_DOUBLE_REF, expr.span,\n+            let mut db = span_lint(cx,\n+                                   CLONE_DOUBLE_REF,\n+                                   expr.span,\n                                    \"using `clone` on a double-reference; \\\n                                     this will copy the reference instead of cloning \\\n                                     the inner type\");\n@@ -583,10 +585,7 @@ fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n     if let Some((span, r)) = derefs_to_slice(cx, &args[1], &arg_ty) {\n-        span_lint(cx,\n-                  EXTEND_FROM_SLICE,\n-                  expr.span,\n-                  \"use of `extend` to extend a Vec by a slice\")\n+        span_lint(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\")\n             .span_suggestion(expr.span,\n                              \"try this\",\n                              format!(\"{}.extend_from_slice({}{})\","}, {"sha": "ffe20d13ceabcf074d3bc1bf9bd9fb490a17d3b1", "filename": "src/print.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -60,9 +60,8 @@ impl LateLintPass for PrintLint {\n                 // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n                 else if args.len() == 2 && match_path(path, &FMT_ARGUMENTV1_NEW_PATH) {\n                     if let ExprPath(None, ref path) = args[1].node {\n-                        if match_path(path, &DEBUG_FMT_METHOD_PATH) &&\n-                            !is_in_debug_impl(cx, expr) &&\n-                            is_expn_of(cx, expr.span, \"panic\").is_none() {\n+                        if match_path(path, &DEBUG_FMT_METHOD_PATH) && !is_in_debug_impl(cx, expr) &&\n+                           is_expn_of(cx, expr.span, \"panic\").is_none() {\n                             span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                         }\n                     }\n@@ -75,8 +74,10 @@ impl LateLintPass for PrintLint {\n fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n     let map = &cx.tcx.map;\n \n-    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) { // `fmt` method\n-        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) { // `Debug` impl\n+    // `fmt` method\n+    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n+        // `Debug` impl\n+        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n             if let ItemImpl(_, _, _, Some(ref tr), _, _) = item.node {\n                 return match_path(&tr.path, &[\"Debug\"]);\n             }"}, {"sha": "e8a71a2cb5a629822033bb63368442b2d1bdafe0", "filename": "src/regex.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -147,7 +147,11 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n         Some((b, _)) => base.lo + BytePos(b as u32),\n         _ => base.hi,\n     };\n-    Span{ lo: lo, hi: lo, ..base }\n+    Span {\n+        lo: lo,\n+        hi: lo,\n+        ..base\n+    }\n }\n \n fn const_str(cx: &LateContext, e: &Expr) -> Option<InternedString> {"}, {"sha": "f4318fc261ae2a6f2d7b5bd7b03ea6de7ea18176", "filename": "src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -144,7 +144,7 @@ impl LateLintPass for StringLitAsBytes {\n                             let msg = format!(\"calling `as_bytes()` on a string literal. \\\n                                                Consider using a byte string literal instead: \\\n                                                `b{}`\",\n-                                               snippet(cx, args[0].span, r#\"\"foo\"\"#));\n+                                              snippet(cx, args[0].span, r#\"\"foo\"\"#));\n                             span_lint(cx, STRING_LIT_AS_BYTES, e.span, &msg);\n                         }\n                     }"}, {"sha": "27c67e78e03a16cd611c3274bab2c3822919b383", "filename": "src/types.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -390,7 +390,8 @@ impl LateLintPass for CastPass {\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty,\n+                                                                                           &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,\n@@ -570,7 +571,7 @@ impl LateLintPass for CharLitAsU8 {\n                                    truncates them\";\n                         let help = format!(\"Consider using a byte literal \\\n                                             instead:\\nb{}\",\n-                                          snippet(cx, e.span, \"'x'\"));\n+                                           snippet(cx, e.span, \"'x'\"));\n                         span_help_and_lint(cx, CHAR_LIT_AS_U8, expr.span, msg, &help);\n                     }\n                 }\n@@ -623,7 +624,10 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n     type Extr<'a> = ExtremeExpr<'a>;\n \n     // Put the expression in the form lhs < rhs or lhs <= rhs.\n-    enum Rel { Lt, Le };\n+    enum Rel {\n+        Lt,\n+        Le,\n+    };\n     let (rel, lhs2, rhs2) = match op {\n         BiLt => (Rel::Lt, lhs, rhs),\n         BiLe => (Rel::Le, lhs, rhs),"}, {"sha": "6231970a0cc2057666b111832c1e6261e8b3ed03", "filename": "src/utils/hir.rs", "status": "modified", "additions": 37, "deletions": 88, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -38,10 +38,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n                 if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n                     // TODO: tys\n-                    l.ty.is_none() && r.ty.is_none() &&\n-                        both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n-                }\n-                else {\n+                    l.ty.is_none() && r.ty.is_none() && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                } else {\n                     false\n                 }\n             }\n@@ -71,95 +69,60 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(lmut, ref le), &ExprAddrOf(rmut, ref re)) => {\n-                lmut == rmut && self.eq_expr(le, re)\n-            }\n-            (&ExprAgain(li), &ExprAgain(ri)) => {\n-                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-            }\n-            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n-                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n-            }\n+            (&ExprAddrOf(lmut, ref le), &ExprAddrOf(rmut, ref re)) => lmut == rmut && self.eq_expr(le, re),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n                 lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n-            (&ExprBreak(li), &ExprBreak(ri)) => {\n-                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-            }\n-            (&ExprBox(ref l), &ExprBox(ref r)) => {\n-                self.eq_expr(l, r)\n-            }\n+            (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-                !self.ignore_fn &&\n-                    self.eq_expr(lfun, rfun) &&\n-                    self.eq_exprs(largs, rargs)\n-            }\n-            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n-                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n+                !self.ignore_fn && self.eq_expr(lfun, rfun) && self.eq_exprs(largs, rargs)\n             }\n+            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n             (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n                 lfident.node == rfident.node && self.eq_expr(lfexp, rfexp)\n             }\n-            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n-                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n-            }\n+            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n-                self.eq_expr(lc, rc) &&\n-                    self.eq_block(lt, rt) &&\n-                    both(le, re, |l, r| self.eq_expr(l, r))\n+                self.eq_expr(lc, rc) && self.eq_block(lt, rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             }\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll), &ExprLoop(ref rb, ref rl)) => {\n-                self.eq_block(lb, rb) &&\n-                    both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n-\n+                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n             }\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n-                ls == rs &&\n-                    self.eq_expr(le, re) &&\n-                    over(la, ra, |l, r| {\n-                        self.eq_expr(&l.body, &r.body) &&\n-                            both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n-                            over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n-                    })\n-            }\n-            (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+                ls == rs && self.eq_expr(le, re) &&\n+                over(la, ra, |l, r| {\n+                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                    over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                })\n+            }\n+            (&ExprMethodCall(ref lname, ref ltys, ref largs),\n+             &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n                 // TODO: tys\n-                !self.ignore_fn &&\n-                    lname.node == rname.node &&\n-                    ltys.is_empty() &&\n-                    rtys.is_empty() &&\n-                    self.eq_exprs(largs, rargs)\n+                !self.ignore_fn && lname.node == rname.node && ltys.is_empty() && rtys.is_empty() &&\n+                self.eq_exprs(largs, rargs)\n             }\n             (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n-                both(lb, rb, |l, r| self.eq_expr(l, r)) &&\n-                both(le, re, |l, r| self.eq_expr(l, r))\n-            }\n-            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n-                self.eq_expr(le, re) && self.eq_expr(ll, rl)\n-            }\n-            (&ExprRet(ref l), &ExprRet(ref r)) => {\n-                both(l, r, |l, r| self.eq_expr(l, r))\n+                both(lb, rb, |l, r| self.eq_expr(l, r)) && both(le, re, |l, r| self.eq_expr(l, r))\n             }\n+            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n+            (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n                 both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n             }\n             (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n-            (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n-                li.node == ri.node && self.eq_expr(le, re)\n-            }\n-            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n-                lop == rop && self.eq_expr(le, re)\n-            }\n+            (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n+            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => lop == rop && self.eq_expr(le, re),\n             (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-                self.eq_expr(lc, rc) &&\n-                    self.eq_block(lb, rb) &&\n-                    both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n             }\n             _ => false,\n         }\n@@ -172,39 +135,25 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     /// Check whether two patterns are the same.\n     pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n-            (&PatKind::Box(ref l), &PatKind::Box(ref r)) => {\n-                self.eq_pat(l, r)\n-            }\n+            (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la), &PatKind::TupleStruct(ref rp, ref ra)) => {\n-                self.eq_path(lp, rp) &&\n-                    both(la, ra, |l, r| {\n-                        over(l, r, |l, r| self.eq_pat(l, r))\n-                    })\n+                self.eq_path(lp, rp) && both(la, ra, |l, r| over(l, r, |l, r| self.eq_pat(l, r)))\n             }\n             (&PatKind::Ident(ref lb, ref li, ref lp), &PatKind::Ident(ref rb, ref ri, ref rp)) => {\n-                lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n-                    both(lp, rp, |l, r| self.eq_pat(l, r))\n-            }\n-            (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => {\n-                self.eq_expr(l, r)\n+                lb == rb && li.node.name.as_str() == ri.node.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n+            (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::QPath(ref ls, ref lp), &PatKind::QPath(ref rs, ref rp)) => {\n                 self.eq_qself(ls, rs) && self.eq_path(lp, rp)\n             }\n-            (&PatKind::Tup(ref l), &PatKind::Tup(ref r)) => {\n-                over(l, r, |l, r| self.eq_pat(l, r))\n-            }\n+            (&PatKind::Tup(ref l), &PatKind::Tup(ref r)) => over(l, r, |l, r| self.eq_pat(l, r)),\n             (&PatKind::Range(ref ls, ref le), &PatKind::Range(ref rs, ref re)) => {\n-                self.eq_expr(ls, rs) &&\n-                    self.eq_expr(le, re)\n-            }\n-            (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => {\n-                lm == rm && self.eq_pat(le, re)\n+                self.eq_expr(ls, rs) && self.eq_expr(le, re)\n             }\n+            (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Vec(ref ls, ref li, ref le), &PatKind::Vec(ref rs, ref ri, ref re)) => {\n-                over(ls, rs, |l, r| self.eq_pat(l, r)) &&\n-                    over(le, re, |l, r| self.eq_pat(l, r)) &&\n-                    both(li, ri, |l, r| self.eq_pat(l, r))\n+                over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r)) &&\n+                both(li, ri, |l, r| self.eq_pat(l, r))\n             }\n             (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,"}, {"sha": "f2b0c1f4db1abf65b110961731d39cfae9a5ddb7", "filename": "src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b3cbb09133ff4fbc1afb992565587035b78cb4/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=e4b3cbb09133ff4fbc1afb992565587035b78cb4", "patch": "@@ -137,8 +137,7 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n \n         iter.inspect(|_| len += 1)\n             .zip(path)\n-            .all(|(nm, p)| nm.name().as_str() == *p)\n-        && len == path.len()\n+            .all(|(nm, p)| nm.name().as_str() == *p) && len == path.len()\n     })\n }\n \n@@ -600,11 +599,10 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n /// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = cx.tcx.sess.codemap().with_expn_info(span.expn_id, |expn| {\n-            expn.map(|ei| {\n-                (ei.callee.name(), ei.call_site)\n-            })\n-        });\n+        let span_name_span = cx.tcx\n+                               .sess\n+                               .codemap()\n+                               .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),"}]}