{"sha": "84b1005bfd22e2cb2a4c13b0b81958fe72628354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YjEwMDViZmQyMmUyY2IyYTRjMTNiMGI4MTk1OGZlNzI2MjgzNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-29T22:55:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-29T22:55:40Z"}, "message": "Auto merge of #85390 - Mark-Simulacrum:fast-bridge, r=petrochenkov\n\nOptimize proc macro bridge\n\nThis optimizes the proc macro bridge code for a win of 0.7% instruction counts on the diesel-check benchmark (non-incr, full). These wins are small, but hopefully not limited to just the diesel benchmark; the code is also not seriously impacted by the changes here.", "tree": {"sha": "c1ad1c3edd2b6b6edd08cb1db973861b48d7030e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1ad1c3edd2b6b6edd08cb1db973861b48d7030e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84b1005bfd22e2cb2a4c13b0b81958fe72628354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84b1005bfd22e2cb2a4c13b0b81958fe72628354", "html_url": "https://github.com/rust-lang/rust/commit/84b1005bfd22e2cb2a4c13b0b81958fe72628354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84b1005bfd22e2cb2a4c13b0b81958fe72628354/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b663c0f4f6ff84a8c9df0f708e1f8d628330d973", "url": "https://api.github.com/repos/rust-lang/rust/commits/b663c0f4f6ff84a8c9df0f708e1f8d628330d973", "html_url": "https://github.com/rust-lang/rust/commit/b663c0f4f6ff84a8c9df0f708e1f8d628330d973"}, {"sha": "8c2080886fa46434e097c503d3d1ee9309eadc7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2080886fa46434e097c503d3d1ee9309eadc7d", "html_url": "https://github.com/rust-lang/rust/commit/8c2080886fa46434e097c503d3d1ee9309eadc7d"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "717201aef102bf60a78b61837adca7d8961f7e25", "filename": "library/proc_macro/src/bridge/buffer.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/84b1005bfd22e2cb2a4c13b0b81958fe72628354/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b1005bfd22e2cb2a4c13b0b81958fe72628354/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs?ref=84b1005bfd22e2cb2a4c13b0b81958fe72628354", "patch": "@@ -39,7 +39,7 @@ pub struct Buffer<T: Copy> {\n     data: *mut T,\n     len: usize,\n     capacity: usize,\n-    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<'_, T>) -> Buffer<T>,\n+    reserve: extern \"C\" fn(Buffer<T>, usize) -> Buffer<T>,\n     drop: extern \"C\" fn(Buffer<T>),\n }\n \n@@ -78,18 +78,44 @@ impl<T: Copy> Buffer<T> {\n         mem::take(self)\n     }\n \n+    // We have the array method separate from extending from a slice. This is\n+    // because in the case of small arrays, codegen can be more efficient\n+    // (avoiding a memmove call). With extend_from_slice, LLVM at least\n+    // currently is not able to make that optimization.\n+    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[T; N]) {\n+        if xs.len() > (self.capacity - self.len) {\n+            let b = self.take();\n+            *self = (b.reserve)(b, xs.len());\n+        }\n+        unsafe {\n+            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n+            self.len += xs.len();\n+        }\n+    }\n+\n     pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n-        // Fast path to avoid going through an FFI call.\n-        if let Some(final_len) = self.len.checked_add(xs.len()) {\n-            if final_len <= self.capacity {\n-                let dst = unsafe { slice::from_raw_parts_mut(self.data, self.capacity) };\n-                dst[self.len..][..xs.len()].copy_from_slice(xs);\n-                self.len = final_len;\n-                return;\n-            }\n+        if xs.len() > (self.capacity - self.len) {\n+            let b = self.take();\n+            *self = (b.reserve)(b, xs.len());\n+        }\n+        unsafe {\n+            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n+            self.len += xs.len();\n+        }\n+    }\n+\n+    pub(super) fn push(&mut self, v: T) {\n+        // The code here is taken from Vec::push, and we know that reserve()\n+        // will panic if we're exceeding isize::MAX bytes and so there's no need\n+        // to check for overflow.\n+        if self.len == self.capacity {\n+            let b = self.take();\n+            *self = (b.reserve)(b, 1);\n+        }\n+        unsafe {\n+            *self.data.add(self.len) = v;\n+            self.len += 1;\n         }\n-        let b = self.take();\n-        *self = (b.extend_from_slice)(b, Slice::from(xs));\n     }\n }\n \n@@ -131,16 +157,16 @@ impl<T: Copy> From<Vec<T>> for Buffer<T> {\n             }\n         }\n \n-        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<'_, T>) -> Buffer<T> {\n+        extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n             let mut v = to_vec(b);\n-            v.extend_from_slice(&xs);\n+            v.reserve(additional);\n             Buffer::from(v)\n         }\n \n         extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n             mem::drop(to_vec(b));\n         }\n \n-        Buffer { data, len, capacity, extend_from_slice, drop }\n+        Buffer { data, len, capacity, reserve, drop }\n     }\n }"}, {"sha": "588e6ded0f48068f937b697b1d206ab3f5046113", "filename": "library/proc_macro/src/bridge/rpc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84b1005bfd22e2cb2a4c13b0b81958fe72628354/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b1005bfd22e2cb2a4c13b0b81958fe72628354/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs?ref=84b1005bfd22e2cb2a4c13b0b81958fe72628354", "patch": "@@ -27,7 +27,7 @@ macro_rules! rpc_encode_decode {\n     (le $ty:ty) => {\n         impl<S> Encode<S> for $ty {\n             fn encode(self, w: &mut Writer, _: &mut S) {\n-                w.write_all(&self.to_le_bytes()).unwrap();\n+                w.extend_from_array(&self.to_le_bytes());\n             }\n         }\n \n@@ -114,7 +114,7 @@ impl<S> DecodeMut<'_, '_, S> for () {\n \n impl<S> Encode<S> for u8 {\n     fn encode(self, w: &mut Writer, _: &mut S) {\n-        w.write_all(&[self]).unwrap();\n+        w.push(self);\n     }\n }\n "}]}