{"sha": "df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNjY1MGYzOGNiMmJlZDQwZmIxYjFmZTVkNmE2ZTA4ZGFiOTYzZTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-28T04:09:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: move `...::<impl ...>` printing into `pretty_path_qualified`.", "tree": {"sha": "191436e32bb20c36daf53c6cae291d07d6d4ea96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/191436e32bb20c36daf53c6cae291d07d6d4ea96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "html_url": "https://github.com/rust-lang/rust/commit/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39fd54a418b08051623505ff5263fe8714f40b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/39fd54a418b08051623505ff5263fe8714f40b4c", "html_url": "https://github.com/rust-lang/rust/commit/39fd54a418b08051623505ff5263fe8714f40b4c"}], "stats": {"total": 91, "additions": 68, "deletions": 23}, "files": [{"sha": "77768975e25a1593cc2ff55f92b4280e3f8a0f24", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "patch": "@@ -173,6 +173,7 @@ pub trait Printer: Sized {\n     #[must_use]\n     fn path_qualified(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_prefix: Option<Self::Path>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n@@ -301,7 +302,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                         parent_generics.has_self && parent_generics.parent_count == 0;\n                     if let (Some(substs), true) = (substs, parent_has_own_self) {\n                         let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n-                        self.path_qualified(trait_ref.self_ty(), Some(trait_ref), ns)\n+                        self.path_qualified(None, trait_ref.self_ty(), Some(trait_ref), ns)\n                     } else {\n                         self.print_def_path(parent_def_id, substs, ns, iter::empty())\n                     }\n@@ -357,21 +358,18 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n         };\n \n-        if !in_self_mod && !in_trait_mod {\n+        let prefix_path = if !in_self_mod && !in_trait_mod {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n-            if let Some(trait_ref) = impl_trait_ref {\n-                return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n-            } else {\n-                return self.path_append(path, &format!(\"<impl {}>\", self_ty));\n-            }\n-        }\n+            Some(self.print_def_path(parent_def_id, None, ns, iter::empty()))\n+        } else {\n+            // Otherwise, try to give a good form that would be valid language\n+            // syntax. Preferably using associated item notation.\n+            None\n+        };\n \n-        // Otherwise, try to give a good form that would be valid language\n-        // syntax. Preferably using associated item notation.\n-        self.path_qualified(self_ty, impl_trait_ref, ns)\n+        self.path_qualified(prefix_path, self_ty, impl_trait_ref, ns)\n     }\n }\n \n@@ -561,10 +559,24 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n \n     pub fn pretty_path_qualified(\n         &mut self,\n+        impl_prefix: Option<P::Path>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> P::Path {\n+        if let Some(prefix) = impl_prefix {\n+            // HACK(eddyb) going through `path_append` means symbol name\n+            // computation gets to handle its equivalent of `::` correctly.\n+            let _ = self.path_append(prefix, \"<impl \")?;\n+            if let Some(trait_ref) = trait_ref {\n+                trait_ref.print_display(self)?;\n+                write!(self.printer, \" for \")?;\n+            }\n+            self_ty.print_display(self)?;\n+            write!(self.printer, \">\")?;\n+            return Ok(PrettyPath { empty: false });\n+        }\n+\n         if trait_ref.is_none() {\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n@@ -774,11 +786,12 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     }\n     fn path_qualified(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_prefix: Option<Self::Path>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> Self::Path {\n-        self.pretty_path_qualified(self_ty, trait_ref, ns)\n+        self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns)\n     }\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,"}, {"sha": "6384a2af8ef009a9854b443f23430ab927982fdc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "patch": "@@ -1007,7 +1007,7 @@ define_print! {\n             Ok(())\n         }\n         debug {\n-            let _ = cx.path_qualified(self.self_ty(), Some(*self), Namespace::TypeNS)?;\n+            let _ = cx.path_qualified(None, self.self_ty(), Some(*self), Namespace::TypeNS)?;\n             Ok(())\n         }\n     }"}, {"sha": "c4de355aa442c3c8fac3aa2813f31968ab072d87", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "patch": "@@ -387,7 +387,7 @@ impl SymbolPath {\n     }\n \n     fn finalize_pending_component(&mut self) {\n-        if !self.keep_within_component && !self.temp_buf.is_empty() {\n+        if !self.temp_buf.is_empty() {\n             let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n             self.temp_buf.clear();\n         }\n@@ -414,6 +414,7 @@ impl Printer for SymbolPath {\n     }\n     fn path_qualified(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_prefix: Option<Self::Path>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n@@ -423,25 +424,51 @@ impl Printer for SymbolPath {\n         match self_ty.sty {\n             ty::Adt(..) | ty::Foreign(_) |\n             ty::Bool | ty::Char | ty::Str |\n-            ty::Int(_) | ty::Uint(_) | ty::Float(_) if trait_ref.is_none() => {\n-                return self.pretty_path_qualified(self_ty, trait_ref, ns);\n+            ty::Int(_) | ty::Uint(_) | ty::Float(_)\n+                if impl_prefix.is_none() && trait_ref.is_none() =>\n+            {\n+                return self.pretty_path_qualified(None, self_ty, trait_ref, ns);\n             }\n             _ => {}\n         }\n \n+        // HACK(eddyb) make sure to finalize the last component of the\n+        // `impl` prefix, to avoid it fusing with the following text.\n+        let impl_prefix = impl_prefix.map(|prefix| {\n+            let mut prefix = self.path_append(prefix, \"\")?;\n+\n+            // HACK(eddyb) also avoid an unnecessary `::`.\n+            prefix.empty = true;\n+\n+            Ok(prefix)\n+        });\n+\n         let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n-        let r = self.pretty_path_qualified(self_ty, trait_ref, ns);\n+        let r = self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns);\n         self.printer.keep_within_component = kept_within_component;\n         r\n     }\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n-        _: Self::Path,\n+        path: Self::Path,\n         text: &str,\n     ) -> Self::Path {\n-        self.printer.finalize_pending_component();\n+        let mut path = path?;\n+\n+        if self.keep_within_component {\n+            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+            if !path.empty {\n+                self.printer.write_str(\"::\")?;\n+            } else {\n+                path.empty = text.is_empty();\n+            }\n+        } else {\n+            self.printer.finalize_pending_component();\n+            path.empty = false;\n+        }\n+\n         self.printer.write_str(text)?;\n-        Ok(PrettyPath { empty: false })\n+        Ok(path)\n     }\n     fn path_generic_args(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,"}, {"sha": "bfc7c7859f5ed005080bc7ce45dcc975c313d193", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "patch": "@@ -4237,16 +4237,21 @@ where F: Fn(DefId) -> Def {\n         }\n         fn path_qualified(\n             self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+            impl_prefix: Option<Self::Path>,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n             _ns: Namespace,\n         ) -> Self::Path {\n+            let mut path = impl_prefix.unwrap_or(vec![]);\n+\n             // This shouldn't ever be needed, but just in case:\n             if let Some(trait_ref) = trait_ref {\n-                vec![format!(\"{:?}\", trait_ref)]\n+                path.push(format!(\"{:?}\", trait_ref));\n             } else {\n-                vec![format!(\"<{}>\", self_ty)]\n+                path.push(format!(\"<{}>\", self_ty));\n             }\n+\n+            path\n         }\n         fn path_append(\n             self: &mut PrintCx<'_, '_, '_, Self>,"}]}