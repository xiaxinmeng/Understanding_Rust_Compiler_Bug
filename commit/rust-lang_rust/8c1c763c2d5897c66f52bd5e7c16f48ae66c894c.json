{"sha": "8c1c763c2d5897c66f52bd5e7c16f48ae66c894c", "node_id": "C_kwDOAAsO6NoAKDhjMWM3NjNjMmQ1ODk3YzY2ZjUyYmQ1ZTdjMTZmNDhhZTY2Yzg5NGM", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-19T18:23:52Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-21T14:16:20Z"}, "message": "clippy: Fix pattern_type_mismatch for loop", "tree": {"sha": "0940794c200a73c4803683fdb77c2edeebc3525c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0940794c200a73c4803683fdb77c2edeebc3525c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c", "html_url": "https://github.com/rust-lang/rust/commit/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e58ffb88e69094b8ee170f15f66fa472ee060752", "url": "https://api.github.com/repos/rust-lang/rust/commits/e58ffb88e69094b8ee170f15f66fa472ee060752", "html_url": "https://github.com/rust-lang/rust/commit/e58ffb88e69094b8ee170f15f66fa472ee060752"}], "stats": {"total": 207, "additions": 43, "deletions": 164}, "files": [{"sha": "018e6d611db77aa1e66744dc9dbb8d45bf3bbc87", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 43, "deletions": 164, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c1c763c2d5897c66f52bd5e7c16f48ae66c894c/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=8c1c763c2d5897c66f52bd5e7c16f48ae66c894c", "patch": "@@ -1,16 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::last_path_segment;\n use rustc_hir::{\n-    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatField, PatKind,\n-    QPath, Stmt, StmtKind,\n+    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, Mutability, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -87,43 +83,28 @@ declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(local) = stmt.kind {\n-            if let Some(init) = &local.init {\n-                if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n-                    let pat = &local.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        return;\n-                    }\n-                    let deref_possible = match local.source {\n-                        LocalSource::Normal => DerefPossible::Possible,\n-                        _ => DerefPossible::Impossible,\n-                    };\n-                    apply_lint(cx, pat, init_ty, deref_possible);\n-                }\n+            if in_external_macro(cx.sess(), local.pat.span) {\n+                return;\n             }\n+            let deref_possible = match local.source {\n+                LocalSource::Normal => DerefPossible::Possible,\n+                _ => DerefPossible::Impossible,\n+            };\n+            apply_lint(cx, local.pat, deref_possible);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n-                'pattern_checks: for arm in arms {\n-                    let pat = &arm.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        continue 'pattern_checks;\n-                    }\n-                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                        break 'pattern_checks;\n-                    }\n+        if let ExprKind::Match(_, arms, _) = expr.kind {\n+            for arm in arms {\n+                let pat = &arm.pat;\n+                if apply_lint(cx, pat, DerefPossible::Possible) {\n+                    break;\n                 }\n             }\n         }\n-        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n-                if in_external_macro(cx.sess(), let_pat.span) {\n-                    return;\n-                }\n-                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n-            }\n+        if let ExprKind::Let(let_pat, ..) = expr.kind {\n+            apply_lint(cx, let_pat, DerefPossible::Possible);\n         }\n     }\n \n@@ -134,12 +115,10 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         _: Span,\n-        hir_id: HirId,\n+        _: HirId,\n     ) {\n-        if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n-            for (param, ty) in iter::zip(body.params, fn_sig.inputs()) {\n-                apply_lint(cx, param.pat, ty, DerefPossible::Impossible);\n-            }\n+        for param in body.params {\n+            apply_lint(cx, param.pat, DerefPossible::Impossible);\n         }\n     }\n }\n@@ -150,8 +129,8 @@ enum DerefPossible {\n     Impossible,\n }\n \n-fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n-    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat);\n     if let Some((span, mutability, level)) = maybe_mismatch {\n         span_lint_and_help(\n             cx,\n@@ -184,132 +163,32 @@ enum Level {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-fn find_first_mismatch<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'_>,\n-    ty: Ty<'tcx>,\n-    level: Level,\n-) -> Option<(Span, Mutability, Level)> {\n-    if let PatKind::Ref(sub_pat, _) = pat.kind {\n-        if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n-            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n-        }\n-    }\n-\n-    if let TyKind::Ref(_, _, mutability) = *ty.kind() {\n-        if is_non_ref_pattern(&pat.kind) {\n-            return Some((pat.span, mutability, level));\n-        }\n-    }\n-\n-    if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n-            }\n+fn find_first_mismatch<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> Option<(Span, Mutability, Level)> {\n+    let mut result = None;\n+    pat.walk(|p| {\n+        if result.is_some() {\n+            return false;\n         }\n-    }\n-\n-    if let PatKind::TupleStruct(ref qpath, pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n-                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n-            }\n-        }\n-    }\n-\n-    if let PatKind::Tuple(pats, _) = pat.kind {\n-        if let TyKind::Tuple(..) = ty.kind() {\n-            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        if in_external_macro(cx.sess(), p.span) {\n+            return true;\n         }\n-    }\n-\n-    if let PatKind::Or(sub_pats) = pat.kind {\n-        for pat in sub_pats {\n-            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n-            if let Some(mismatch) = maybe_mismatch {\n-                return Some(mismatch);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n-    if adt_def.is_struct() {\n-        if let Some(variant) = adt_def.variants.iter().next() {\n-            return Some(variant);\n-        }\n-    }\n-\n-    if adt_def.is_enum() {\n-        let pat_ident = last_path_segment(qpath).ident;\n-        for variant in &adt_def.variants {\n-            if variant.ident == pat_ident {\n-                return Some(variant);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_tuple<'tcx, I>(\n-    cx: &LateContext<'tcx>,\n-    pats: &[Pat<'_>],\n-    ty_iter_src: I,\n-) -> Option<(Span, Mutability, Level)>\n-where\n-    I: IntoIterator<Item = Ty<'tcx>>,\n-{\n-    let mut field_tys = ty_iter_src.into_iter();\n-    'fields: for pat in pats {\n-        let field_ty = if let Some(ty) = field_tys.next() {\n-            ty\n-        } else {\n-            break 'fields;\n+        let adjust_pat = match p.kind {\n+            PatKind::Or([p, ..]) => p,\n+            _ => p,\n         };\n-\n-        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-        if let Some(mismatch) = maybe_mismatch {\n-            return Some(mismatch);\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_struct<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    field_pats: &[PatField<'_>],\n-    field_defs: &[FieldDef],\n-    substs_ref: SubstsRef<'tcx>,\n-) -> Option<(Span, Mutability, Level)> {\n-    for field_pat in field_pats {\n-        'definitions: for field_def in field_defs {\n-            if field_pat.ident == field_def.ident {\n-                let field_ty = field_def.ty(cx.tcx, substs_ref);\n-                let pat = &field_pat.pat;\n-                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-                if let Some(mismatch) = maybe_mismatch {\n-                    return Some(mismatch);\n+        if let Some(adjustments) = cx.typeck_results().pat_adjustments().get(adjust_pat.hir_id) {\n+            if let [first, ..] = **adjustments {\n+                if let ty::Ref(.., mutability) = *first.kind() {\n+                    let level = if p.hir_id == pat.hir_id {\n+                        Level::Top\n+                    } else {\n+                        Level::Lower\n+                    };\n+                    result = Some((p.span, mutability, level));\n                 }\n-                break 'definitions;\n             }\n         }\n-    }\n-\n-    None\n-}\n-\n-fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n-    match pat_kind {\n-        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n-        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n-        _ => false,\n-    }\n+        result.is_none()\n+    });\n+    result\n }"}]}