{"sha": "82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "node_id": "C_kwDOAAsO6NoAKDgyZTlkOWViYWNhMDZiMTlmNWMwN2FmZDljZjhmNDJhODA0NWJkYmI", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2022-04-04T14:53:53Z"}, "committer": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2022-04-04T14:53:53Z"}, "message": "from_u32(0) can just be default()", "tree": {"sha": "d70562ea0182108a7d8c4ba6f4ff5ed90b686f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d70562ea0182108a7d8c4ba6f4ff5ed90b686f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0hoVRXRPubZAqGkYx9jUtSpSe8FAmJLBoEACgkQYx9jUtSp\nSe+Y8w/8D+nUqe18uNi7Axwd3lOytaCtbZyPpW/T2we1t0ubDJCDnfyHV92Ec8eR\n+f8CXruApEcXRd1kjaSkHBcZNJBg01NEOGRFTlsOD8kAk+1VFSqT4RdVL6nigwml\n4iwPcjky+Q4Mqh72Ufr0NOEL1g/IjACaCsm1S3htG72ksyAd4k2If1lrIDg17Xws\nmfI7fGzXu/sVQnj/fYTjumU5H/WDagJZ6Vo5Xr42P/SYLuiu9sQyYSdfY9s1V5p4\nn6Vd2ucjBlOoRpH458RJ86ufSBu8pJaUFRE1t3GCvRMW0NHTs7dT6kV6WqOuAxqd\nwRzKAwvOJz2+8Hyoin4RrjVSesrW0Vul2ONs1QF8XJONuZQXqykjneG1wHsxMy0m\nkFRUxENBeG8BACfBiyiPNErva0m3Q3zgGt4aoB50JmpzIBtIJ0GFx/BMUChujugx\n/tQ8XzdfeX2LbfiVf/jO6cObPGHR+jN8PQvuPlGcNrHU4+9SJGvLhXDXusBiHoad\nSV5wrmL0HfrcanGWfJ0ab3PHpy4CBe27jLt/+9+2mQ+mcbHYBt4CmfJKDh6pAIt+\nN6EkRET6otPULAchGxQLWS5JSTlkt5TaaDe7Tm4d5hLBW2ZakmpXKaPNlFNadap/\nwA1lis4dljZfDJeQr9dpyy4msOzaSrPLLZ9wyiSCxuUQWmZKBK8=\n=Vn1/\n-----END PGP SIGNATURE-----", "payload": "tree d70562ea0182108a7d8c4ba6f4ff5ed90b686f1e\nparent 72a5e7e810cbb2ea6db7ff37a599bc3826adee35\nauthor Giles Cope <gilescope@gmail.com> 1649084033 +0100\ncommitter Giles Cope <gilescope@gmail.com> 1649084033 +0100\n\nfrom_u32(0) can just be default()\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "html_url": "https://github.com/rust-lang/rust/commit/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72a5e7e810cbb2ea6db7ff37a599bc3826adee35", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a5e7e810cbb2ea6db7ff37a599bc3826adee35", "html_url": "https://github.com/rust-lang/rust/commit/72a5e7e810cbb2ea6db7ff37a599bc3826adee35"}], "stats": {"total": 73, "additions": 57, "deletions": 16}, "files": [{"sha": "5bead39a3dba8ebb4381ca9db96feeb4b1a16c9c", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "patch": "@@ -969,9 +969,8 @@ pub enum FpCategory {\n }\n \n #[doc(hidden)]\n-trait FromStrRadixHelper: PartialOrd + Copy {\n+trait FromStrRadixHelper: PartialOrd + Copy + Default {\n     const MIN: Self;\n-    fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n     fn checked_add(&self, other: u32) -> Option<Self>;\n@@ -997,8 +996,6 @@ macro_rules! impl_helper_for {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         const MIN: Self = Self::MIN;\n         #[inline]\n-        fn from_u32(u: u32) -> Self { u as Self }\n-        #[inline]\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n             Self::checked_mul(*self, other as Self)\n         }\n@@ -1035,8 +1032,14 @@ macro_rules! impl_helper_for {\n }\n impl_helper_for! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n \n+/// Determins if a string of text of that length of that radix could be guaranteed to be\n+/// stored in the given type T.\n+/// Note that if the radix is known to the compiler, it is just the check of digits.len that\n+/// is done at runtime.\n+#[doc(hidden)]\n #[inline(always)]\n-pub(crate) fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits:&[u8]) -> bool {\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+pub fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits: &[u8]) -> bool {\n     radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize\n }\n \n@@ -1054,7 +1057,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n         return Err(PIE { kind: Empty });\n     }\n \n-    let is_signed_ty = T::from_u32(0) > T::MIN;\n+    let is_signed_ty = T::default() > T::MIN;\n \n     // all valid digits are ascii, so we will just iterate over the utf8 bytes\n     // and cast them to chars. .to_digit() will safely return None for anything\n@@ -1071,7 +1074,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n         _ => (true, src),\n     };\n \n-    let mut result = T::from_u32(0);\n+    let mut result = T::default();\n \n     if can_not_overflow::<T>(radix, is_signed_ty, digits) {\n         // SAFETY: If the len of the str is short compared to the range of the type\n@@ -1127,11 +1130,3 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     }\n     Ok(result)\n }\n-\n-mod tests {\n-    #[test]\n-    fn test_can_not_overflow() {\n-        assert_eq!(can_not_overflow::<i8>(10, true, \"99\".as_bytes()), true);\n-        assert_eq!(can_not_overflow::<i8>(10, true, \"129\".as_bytes()), false);\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "bc2ab7489a165efa3bf92a5e4dc98c35b846ca6d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "patch": "@@ -55,6 +55,7 @@\n #![feature(numfmt)]\n #![feature(step_trait)]\n #![feature(str_internals)]\n+#![feature(std_internals)]\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]"}, {"sha": "0abc88f21fcbb94162e9f1085a77915364b3fa9b", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "patch": "@@ -2,7 +2,7 @@ use core::cmp::PartialEq;\n use core::convert::{TryFrom, TryInto};\n use core::fmt::Debug;\n use core::marker::Copy;\n-use core::num::{IntErrorKind, ParseIntError, TryFromIntError};\n+use core::num::{can_not_overflow, IntErrorKind, ParseIntError, TryFromIntError};\n use core::ops::{Add, Div, Mul, Rem, Sub};\n use core::option::Option;\n use core::option::Option::None;\n@@ -120,6 +120,51 @@ fn test_int_from_str_overflow() {\n     test_parse::<i64>(\"-9223372036854775809\", Err(IntErrorKind::NegOverflow));\n }\n \n+#[test]\n+fn test_can_not_overflow() {\n+    // Not currently in std lib (issue: #27728)\n+    fn format_radix<T>(mut x: T, radix: T) -> String\n+    where\n+        T: std::ops::Rem<Output = T>,\n+        T: std::ops::Div<Output = T>,\n+        T: std::cmp::PartialEq,\n+        T: std::default::Default,\n+        T: Copy,\n+        T: Default,\n+        u32: TryFrom<T>,\n+    {\n+        let mut result = vec![];\n+\n+        loop {\n+            let m = x % radix;\n+            x = x / radix;\n+            result.push(\n+                std::char::from_digit(m.try_into().ok().unwrap(), radix.try_into().ok().unwrap())\n+                    .unwrap(),\n+            );\n+            if x == T::default() {\n+                break;\n+            }\n+        }\n+        result.into_iter().rev().collect()\n+    }\n+\n+    macro_rules! check {\n+        ($($t:ty)*) => ($(\n+        for base in 2..=36 {\n+            let num = (<$t>::MAX as u128) + 1;\n+\n+           // Calcutate the string length for the smallest overflowing number:\n+           let max_len_string = format_radix(num, base as u128);\n+           // Ensure that that string length is deemed to potentially overflow:\n+           assert_eq!(can_not_overflow::<$t>(base, <$t>::default() > <$t>::MIN, max_len_string.as_bytes()), false);\n+        }\n+        )*)\n+    }\n+\n+    check! { i8 i16 i32 i64 i128 isize usize u8 u16 u32 u64 }\n+}\n+\n #[test]\n fn test_leading_plus() {\n     test_parse::<u8>(\"+127\", Ok(127));"}]}