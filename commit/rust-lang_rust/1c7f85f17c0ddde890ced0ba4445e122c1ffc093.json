{"sha": "1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "node_id": "C_kwDOAAsO6NoAKDFjN2Y4NWYxN2MwZGRkZTg5MGNlZDBiYTQ0NDVlMTIyYzFmZmMwOTM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-12T01:19:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-09T21:47:59Z"}, "message": "Perform indexing during lowering.\n\nDo not access DefId<->HirId maps before they are initialized.", "tree": {"sha": "2ab13a3db430dfb042530e2e8f76fd2723819f1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab13a3db430dfb042530e2e8f76fd2723819f1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "html_url": "https://github.com/rust-lang/rust/commit/1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c09eaea484c8f7a01741188982447eec88b5caa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c09eaea484c8f7a01741188982447eec88b5caa8", "html_url": "https://github.com/rust-lang/rust/commit/c09eaea484c8f7a01741188982447eec88b5caa8"}], "stats": {"total": 286, "additions": 117, "deletions": 169}, "files": [{"sha": "7b0f1caaee1e157c0d6dcc7716d087486137336b", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "renamed", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -1,5 +1,3 @@\n-use crate::hir::map::Map;\n-use crate::hir::{IndexedHir, OwnerNodes, ParentedNode};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -12,16 +10,16 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n \n use std::iter::repeat;\n+use tracing::debug;\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n-    /// The crate\n-    krate: &'hir Crate<'hir>,\n-\n     /// Source map\n     source_map: &'a SourceMap,\n+    bodies: &'a IndexVec<ItemLocalId, Option<&'hir Body<'hir>>>,\n \n-    nodes: OwnerNodes<'hir>,\n+    /// Outputs\n+    nodes: IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>,\n     parenting: FxHashMap<LocalDefId, ItemLocalId>,\n \n     /// The parent of this node\n@@ -42,28 +40,21 @@ fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V\n     map[k] = Some(v);\n }\n \n-pub(super) fn collect<'a, 'hir: 'a>(\n-    sess: &'a Session,\n-    krate: &'hir Crate<'hir>,\n-    definitions: &'a definitions::Definitions,\n-    owner: LocalDefId,\n-) -> Option<IndexedHir<'hir>> {\n-    let info = krate.owners.get(owner)?.as_ref()?;\n-    let item = info.node;\n+pub(super) fn index_hir<'hir>(\n+    sess: &Session,\n+    definitions: &definitions::Definitions,\n+    item: hir::OwnerNode<'hir>,\n+    bodies: &IndexVec<ItemLocalId, Option<&'hir Body<'hir>>>,\n+) -> (IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>, FxHashMap<LocalDefId, ItemLocalId>) {\n     let mut nodes = IndexVec::new();\n     nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: item.into() }));\n     let mut collector = NodeCollector {\n-        krate,\n         source_map: sess.source_map(),\n-        owner,\n-        parent_node: ItemLocalId::new(0),\n         definitions,\n-        nodes: OwnerNodes {\n-            hash: info.hash,\n-            node_hash: info.node_hash,\n-            nodes,\n-            bodies: &info.bodies,\n-        },\n+        owner: item.def_id(),\n+        parent_node: ItemLocalId::new(0),\n+        nodes,\n+        bodies,\n         parenting: FxHashMap::default(),\n     };\n \n@@ -75,7 +66,7 @@ pub(super) fn collect<'a, 'hir: 'a>(\n         OwnerNode::ForeignItem(item) => collector.visit_foreign_item(item),\n     };\n \n-    Some(IndexedHir { nodes: collector.nodes, parenting: collector.parenting })\n+    (collector.nodes, collector.parenting)\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n@@ -87,17 +78,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // owner of that node.\n         if cfg!(debug_assertions) {\n             if hir_id.owner != self.owner {\n-                let node_str = match self.definitions.opt_hir_id_to_local_def_id(hir_id) {\n-                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate_verbose(),\n-                    None => format!(\"{:?}\", node),\n-                };\n-\n-                span_bug!(\n-                    span,\n-                    \"inconsistent DepNode at `{:?}` for `{}`: \\\n+                panic!(\n+                    \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n-                    node_str,\n+                    node,\n                     self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n                     self.owner,\n                     self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n@@ -107,7 +92,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         }\n \n         insert_vec_map(\n-            &mut self.nodes.nodes,\n+            &mut self.nodes,\n             hir_id.local_id,\n             ParentedNode { parent: self.parent_node, node: node },\n         );\n@@ -122,18 +107,12 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     }\n \n     fn insert_nested(&mut self, item: LocalDefId) {\n-        let dk_parent = self.definitions.def_key(item).parent.unwrap();\n-        let dk_parent = LocalDefId { local_def_index: dk_parent };\n-        let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n-        debug_assert_eq!(dk_parent.owner, self.owner, \"Different parents for {:?}\", item);\n-        if dk_parent.local_id != self.parent_node {\n-            self.parenting.insert(item, self.parent_node);\n-        }\n+        self.parenting.insert(item, self.parent_node);\n     }\n }\n \n impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n-    type Map = Map<'hir>;\n+    type Map = !;\n \n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n@@ -161,8 +140,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        let body = self.krate.body(id);\n         debug_assert_eq!(id.hir_id.owner, self.owner);\n+        let body = self.bodies[id.hir_id.local_id].unwrap();\n         self.visit_body(body);\n     }\n ", "previous_filename": "compiler/rustc_middle/src/hir/map/collector.rs"}, {"sha": "d5fa52a341475e67065c2e2526f759bf4d4224a6", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -101,7 +101,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let old_len = self.in_scope_lifetimes.len();\n \n         let parent_generics =\n-            match self.owners[parent_hir_id].as_ref().unwrap().node.expect_item().kind {\n+            match self.owners[parent_hir_id].as_ref().unwrap().node().expect_item().kind {\n                 hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n                 | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n                 _ => &[],"}, {"sha": "a7f1ba8b79198cc13f3444c7fa02069e5e2a0dc9", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -33,6 +33,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(iter_zip)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::token::{self, Token};\n@@ -78,6 +79,7 @@ macro_rules! arena_vec {\n mod asm;\n mod block;\n mod expr;\n+mod index;\n mod item;\n mod pat;\n mod path;\n@@ -434,6 +436,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.local_node_ids.push(owner);\n \n         let item = f(self);\n+        debug_assert_eq!(def_id, item.def_id());\n         let info = self.make_owner_info(item);\n \n         self.attrs = current_attrs;\n@@ -470,8 +473,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         let (hash, node_hash) = self.hash_body(node, &bodies);\n+        let (nodes, parenting) =\n+            index::index_hir(self.sess, self.resolver.definitions(), node, &bodies);\n+        let nodes = hir::OwnerNodes { hash, node_hash, nodes, bodies };\n \n-        hir::OwnerInfo { hash, node_hash, node, attrs, bodies, trait_map }\n+        hir::OwnerInfo { nodes, parenting, attrs, trait_map }\n     }\n \n     /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate"}, {"sha": "1a34dd0442855ffdf2dc06b472c20d3f859c8068", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -37,6 +37,7 @@ macro_rules! arena_types {\n             [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n             [few] mod_: rustc_hir::Mod<$tcx>,\n+            [] owner_info: rustc_hir::OwnerInfo<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,\n             [] pat: rustc_hir::Pat<$tcx>,\n             [] path: rustc_hir::Path<$tcx>,"}, {"sha": "4c8157fee3704764ae55e270e88d55116f7fe640", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -1,5 +1,5 @@\n use crate::def::{CtorKind, DefKind, Res};\n-use crate::def_id::{DefId, CRATE_DEF_ID};\n+use crate::def_id::DefId;\n crate use crate::hir_id::{HirId, ItemLocalId};\n use crate::LangItem;\n \n@@ -663,18 +663,49 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n+/// HIR node coupled with its parent's id in the same HIR owner.\n+///\n+/// The parent is trash when the node is a HIR owner.\n+#[derive(Clone, Debug)]\n+pub struct ParentedNode<'tcx> {\n+    pub parent: ItemLocalId,\n+    pub node: Node<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub struct OwnerNodes<'tcx> {\n+    /// Pre-computed hash of the full HIR.\n+    pub hash: Fingerprint,\n+    /// Pre-computed hash of the top node.\n+    pub node_hash: Fingerprint,\n+    /// Full HIR for the current owner.\n+    // The zeroth node's parent is trash, but is never accessed.\n+    pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n+    /// Content of local bodies.\n+    pub bodies: IndexVec<ItemLocalId, Option<&'tcx Body<'tcx>>>,\n+}\n+\n #[derive(Debug)]\n pub struct OwnerInfo<'hir> {\n-    pub node: OwnerNode<'hir>,\n+    /// Contents of the HIR.\n+    pub nodes: OwnerNodes<'hir>,\n+    /// Map from each nested owner to its parent's local id.\n+    pub parenting: FxHashMap<LocalDefId, ItemLocalId>,\n+\n     pub attrs: BTreeMap<ItemLocalId, &'hir [Attribute]>,\n-    pub bodies: IndexVec<ItemLocalId, Option<&'hir Body<'hir>>>,\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n-    /// Pre-computed hash of the full HIR.\n-    pub hash: Fingerprint,\n-    /// Pre-computed hash of the top node.\n-    pub node_hash: Fingerprint,\n+}\n+\n+impl<'tcx> OwnerInfo<'tcx> {\n+    #[inline]\n+    pub fn node(&self) -> OwnerNode<'tcx> {\n+        use rustc_index::vec::Idx;\n+        let node = self.nodes.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n+        node\n+    }\n }\n \n /// The top-level data structure that stores the entire contents of\n@@ -688,39 +719,6 @@ pub struct Crate<'hir> {\n     pub owners: IndexVec<LocalDefId, Option<OwnerInfo<'hir>>>,\n }\n \n-impl Crate<'hir> {\n-    pub fn module(&self) -> &'hir Mod<'hir> {\n-        let i = self.owners[CRATE_DEF_ID].as_ref().unwrap().node;\n-        if let OwnerNode::Crate(m) = i { m } else { panic!() }\n-    }\n-\n-    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().node.expect_item()\n-    }\n-\n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().node.expect_trait_item()\n-    }\n-\n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().node.expect_impl_item()\n-    }\n-\n-    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().node.expect_foreign_item()\n-    }\n-\n-    pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        let HirId { owner, local_id } = id.hir_id;\n-        self.owners[owner].as_ref().unwrap().bodies[local_id].unwrap()\n-    }\n-\n-    pub fn attrs(&self, id: HirId) -> &'hir [Attribute] {\n-        let HirId { owner, local_id } = id;\n-        &self.owners[owner].as_ref().unwrap().attrs.get(&local_id).map(|la| *la).unwrap_or(&[])\n-    }\n-}\n-\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`."}, {"sha": "3e58af1f167aa628ec650a2a4d6eb546dccec9ff", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -130,6 +130,28 @@ pub trait Map<'hir> {\n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir>;\n }\n \n+// Used when no map is actually available, forcing manual implementation of nested visitors.\n+impl Map<'hir> for ! {\n+    fn find(&self, _: HirId) -> Option<Node<'hir>> {\n+        unreachable!()\n+    }\n+    fn body(&self, _: BodyId) -> &'hir Body<'hir> {\n+        unreachable!()\n+    }\n+    fn item(&self, _: ItemId) -> &'hir Item<'hir> {\n+        unreachable!()\n+    }\n+    fn trait_item(&self, _: TraitItemId) -> &'hir TraitItem<'hir> {\n+        unreachable!()\n+    }\n+    fn impl_item(&self, _: ImplItemId) -> &'hir ImplItem<'hir> {\n+        unreachable!()\n+    }\n+    fn foreign_item(&self, _: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+        unreachable!()\n+    }\n+}\n+\n /// An erased version of `Map<'hir>`, using dynamic dispatch.\n /// NOTE: This type is effectively only usable with `NestedVisitorMap::None`.\n pub struct ErasedMap<'hir>(&'hir dyn Map<'hir>);"}, {"sha": "af8421aeb89a76a6520a478c0864e58cb7145da2", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -6,6 +6,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "ad73e363d7f2e60463cc1aa9ac580a871208f4cb", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, TraitItem,\n-    TraitItemId, Ty, VisibilityKind,\n+    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, OwnerNodes,\n+    TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::DefPathHash;\n@@ -209,3 +209,12 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n         });\n     }\n }\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        // We ignore the `nodes` and `bodies` fields since these refer to information included in\n+        // `hash` which is hashed in the collector and used for the crate hash.\n+        let OwnerNodes { hash, node_hash: _, nodes: _, bodies: _ } = *self;\n+        hash.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "4a027cb7ebe05be3924a4548c2a5431b52921d14", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -92,9 +92,6 @@ macro_rules! arena_types {\n             [] tys: rustc_middle::ty::TyS<$tcx>,\n             [] predicates: rustc_middle::ty::PredicateInner<$tcx>,\n \n-            // HIR query types\n-            [] indexed_hir: rustc_middle::hir::IndexedHir<$tcx>,\n-\n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)"}, {"sha": "834d5f964e187bf105d6eafdf84640b7c75b13c4", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::{IndexedHir, ModuleItems, Owner};\n+use crate::hir::{ModuleItems, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -21,7 +21,6 @@ use rustc_target::spec::abi::Abi;\n use std::collections::VecDeque;\n \n pub mod blocks;\n-mod collector;\n \n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n@@ -164,7 +163,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_ref()?.node {\n+        krate.owners.iter().filter_map(|owner| match owner.as_ref()?.node() {\n             OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n@@ -497,7 +496,7 @@ impl<'hir> Map<'hir> {\n             .owners\n             .iter_enumerated()\n             .flat_map(move |(owner, owner_info)| {\n-                let bodies = &owner_info.as_ref()?.bodies;\n+                let bodies = &owner_info.as_ref()?.nodes.bodies;\n                 Some(bodies.iter_enumerated().filter_map(move |(local_id, body)| {\n                     if body.is_none() {\n                         return None;\n@@ -518,7 +517,7 @@ impl<'hir> Map<'hir> {\n         par_iter(&self.krate().owners.raw).enumerate().for_each(|(owner, owner_info)| {\n             let owner = LocalDefId::new(owner);\n             if let Some(owner_info) = owner_info {\n-                par_iter(&owner_info.bodies.raw).enumerate().for_each(|(local_id, body)| {\n+                par_iter(&owner_info.nodes.bodies.raw).enumerate().for_each(|(local_id, body)| {\n                     if body.is_some() {\n                         let local_id = ItemLocalId::new(local_id);\n                         let hir_id = HirId { owner, local_id };\n@@ -605,7 +604,7 @@ impl<'hir> Map<'hir> {\n     {\n         let krate = self.krate();\n         for owner in krate.owners.iter().filter_map(Option::as_ref) {\n-            match owner.node {\n+            match owner.node() {\n                 OwnerNode::Item(item) => visitor.visit_item(item),\n                 OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n                 OwnerNode::ImplItem(item) => visitor.visit_impl_item(item),\n@@ -621,7 +620,7 @@ impl<'hir> Map<'hir> {\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n         let krate = self.krate();\n-        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref().map(|o| o.node) {\n+        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref().map(OwnerInfo::node) {\n             Some(OwnerNode::Item(item)) => visitor.visit_item(item),\n             Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n             Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n@@ -1065,20 +1064,6 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-pub(super) fn index_hir<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    owner: LocalDefId,\n-) -> Option<&'tcx IndexedHir<'tcx>> {\n-    let map = collector::collect(\n-        tcx.sess,\n-        tcx.untracked_crate,\n-        &tcx.untracked_resolutions.definitions,\n-        owner,\n-    )?;\n-\n-    Some(&*tcx.arena.alloc(map))\n-}\n-\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     debug_assert_eq!(crate_num, LOCAL_CRATE);\n     let mut hir_body_nodes: Vec<_> = tcx\n@@ -1088,7 +1073,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         .all_def_path_hashes_and_def_ids()\n         .filter_map(|(def_path_hash, local_def_index)| {\n             let def_id = LocalDefId { local_def_index };\n-            let hash = tcx.index_hir(def_id).as_ref()?.nodes.hash;\n+            let hash = tcx.hir_crate(()).owners[def_id].as_ref()?.nodes.hash;\n             Some((def_path_hash, hash, def_id))\n         })\n         .collect();"}, {"sha": "70179e73b1975619e1ebef501c7dc244f9eef946", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -10,24 +10,13 @@ use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::*;\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::DUMMY_SP;\n use std::collections::BTreeMap;\n \n-/// Result of HIR indexing for a given HIR owner.\n-#[derive(Debug, HashStable)]\n-pub struct IndexedHir<'hir> {\n-    /// Contents of the HIR.\n-    nodes: OwnerNodes<'hir>,\n-    /// Map from each nested owner to its parent's local id.\n-    parenting: FxHashMap<LocalDefId, ItemLocalId>,\n-}\n-\n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n ///\n@@ -47,38 +36,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     }\n }\n \n-/// HIR node coupled with its parent's id in the same HIR owner.\n-///\n-/// The parent is trash when the node is a HIR owner.\n-#[derive(Clone, Debug)]\n-pub struct ParentedNode<'tcx> {\n-    parent: ItemLocalId,\n-    node: Node<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub struct OwnerNodes<'tcx> {\n-    /// Pre-computed hash of the full HIR.\n-    hash: Fingerprint,\n-    /// Pre-computed hash of the top node.\n-    node_hash: Fingerprint,\n-    /// Full HIR for the current owner.\n-    // The zeroth node's parent is trash, but is never accessed.\n-    nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n-    /// Content of local bodies.\n-    bodies: &'tcx IndexVec<ItemLocalId, Option<&'tcx Body<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        // We ignore the `nodes` and `bodies` fields since these refer to information included in\n-        // `hash` which is hashed in the collector and used for the crate hash.\n-        let OwnerNodes { hash, node_hash: _, nodes: _, bodies: _ } = *self;\n-        hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n /// Attributes owner by a HIR owner.\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct AttributeMap<'tcx> {\n@@ -125,23 +82,23 @@ pub fn provide(providers: &mut Providers) {\n         hir.local_def_id(hir.get_module_parent_node(hir.local_def_id_to_hir_id(id)))\n     };\n     providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n-    providers.index_hir = map::index_hir;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.index_hir(id)?;\n-        let node = owner.nodes.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n-        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n+        let owner = tcx.hir_crate(()).owners[id].as_ref()?;\n+        let node = owner.node();\n         Some(Owner { node, node_hash: owner.nodes.node_hash })\n     };\n-    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(id).map(|i| &i.nodes);\n+    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n         let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n         let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n             let def_id = LocalDefId { local_def_index };\n             let mut parent_hir_id =\n                 tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id);\n-            if let Some(local_id) = tcx.index_hir(parent_hir_id.owner).unwrap().parenting.get(&id) {\n+            if let Some(local_id) =\n+                tcx.hir_crate(()).owners[parent_hir_id.owner].as_ref().unwrap().parenting.get(&id)\n+            {\n                 parent_hir_id.local_id = *local_id;\n             }\n             parent_hir_id"}, {"sha": "e604f59175e8ed505db127f2d5106c9b4e0b2aa1", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7f85f17c0ddde890ced0ba4445e122c1ffc093/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1c7f85f17c0ddde890ced0ba4445e122c1ffc093", "patch": "@@ -40,13 +40,6 @@ rustc_queries! {\n         desc { \"get the crate HIR\" }\n     }\n \n-    /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n-    /// Avoid calling this query directly.\n-    query index_hir(_: LocalDefId) -> Option<&'tcx crate::hir::IndexedHir<'tcx>> {\n-        eval_always\n-        desc { \"index HIR\" }\n-    }\n-\n     /// The items in a module.\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n@@ -76,7 +69,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx crate::hir::OwnerNodes<'tcx>> {\n+    query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx hir::OwnerNodes<'tcx>> {\n         desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n "}]}