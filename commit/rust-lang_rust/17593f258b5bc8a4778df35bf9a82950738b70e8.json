{"sha": "17593f258b5bc8a4778df35bf9a82950738b70e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NTkzZjI1OGI1YmM4YTQ3NzhkZjM1YmY5YTgyOTUwNzM4YjcwZTg=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T00:04:32Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:29Z"}, "message": "refactor: moving Splice into splice.rs", "tree": {"sha": "2d8351596627f9b44a53fc442371119950ba9904", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d8351596627f9b44a53fc442371119950ba9904"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17593f258b5bc8a4778df35bf9a82950738b70e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17593f258b5bc8a4778df35bf9a82950738b70e8", "html_url": "https://github.com/rust-lang/rust/commit/17593f258b5bc8a4778df35bf9a82950738b70e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17593f258b5bc8a4778df35bf9a82950738b70e8/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "434e5d142204d9b3019cfedc049d39b0affd08e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/434e5d142204d9b3019cfedc049d39b0affd08e7", "html_url": "https://github.com/rust-lang/rust/commit/434e5d142204d9b3019cfedc049d39b0affd08e7"}], "stats": {"total": 266, "additions": 138, "deletions": 128}, "files": [{"sha": "924b04a8fe1c850080f5053f8c143a28d4f8c105", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 128, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/17593f258b5bc8a4778df35bf9a82950738b70e8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17593f258b5bc8a4778df35bf9a82950738b70e8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=17593f258b5bc8a4778df35bf9a82950738b70e8", "patch": "@@ -79,6 +79,11 @@ pub use self::drain_filter::DrainFilter;\n \n mod drain_filter;\n \n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub use self::splice::Splice;\n+\n+mod splice;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -3462,131 +3467,3 @@ unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}\n-\n-/// A splicing iterator for `Vec`.\n-///\n-/// This struct is created by [`Vec::splice()`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let new = [7, 8];\n-/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-pub struct Splice<\n-    'a,\n-    I: Iterator + 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    drain: Drain<'a, I::Item, A>,\n-    replace_with: I,\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n-    type Item = I::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.drain.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.drain.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.drain.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n-    fn drop(&mut self) {\n-        self.drain.by_ref().for_each(drop);\n-\n-        unsafe {\n-            if self.drain.tail_len == 0 {\n-                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n-                return;\n-            }\n-\n-            // First fill the range left by drain().\n-            if !self.drain.fill(&mut self.replace_with) {\n-                return;\n-            }\n-\n-            // There may be more elements. Use the lower bound as an estimate.\n-            // FIXME: Is the upper bound a better guess? Or something else?\n-            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n-            if lower_bound > 0 {\n-                self.drain.move_tail(lower_bound);\n-                if !self.drain.fill(&mut self.replace_with) {\n-                    return;\n-                }\n-            }\n-\n-            // Collect any remaining elements.\n-            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n-            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n-            // Now we have an exact count.\n-            if collected.len() > 0 {\n-                self.drain.move_tail(collected.len());\n-                let filled = self.drain.fill(&mut collected);\n-                debug_assert!(filled);\n-                debug_assert_eq!(collected.len(), 0);\n-            }\n-        }\n-        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n-    }\n-}\n-\n-/// Private helper methods for `Splice::drop`\n-impl<T, A: Allocator> Drain<'_, T, A> {\n-    /// The range from `self.vec.len` to `self.tail_start` contains elements\n-    /// that have been moved out.\n-    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n-    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let range_start = vec.len;\n-        let range_end = self.tail_start;\n-        let range_slice = unsafe {\n-            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n-        };\n-\n-        for place in range_slice {\n-            if let Some(new_item) = replace_with.next() {\n-                unsafe { ptr::write(place, new_item) };\n-                vec.len += 1;\n-            } else {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Makes room for inserting more elements before the tail.\n-    unsafe fn move_tail(&mut self, additional: usize) {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let len = self.tail_start + self.tail_len;\n-        vec.buf.reserve(len, additional);\n-\n-        let new_tail_start = self.tail_start + additional;\n-        unsafe {\n-            let src = vec.as_ptr().add(self.tail_start);\n-            let dst = vec.as_mut_ptr().add(new_tail_start);\n-            ptr::copy(src, dst, self.tail_len);\n-        }\n-        self.tail_start = new_tail_start;\n-    }\n-}"}, {"sha": "86b2fa0968ef2ef3c65a690ca1983f34010efab6", "filename": "library/alloc/src/vec/splice.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/17593f258b5bc8a4778df35bf9a82950738b70e8/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17593f258b5bc8a4778df35bf9a82950738b70e8/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=17593f258b5bc8a4778df35bf9a82950738b70e8", "patch": "@@ -0,0 +1,133 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{Vec, Drain};\n+\n+/// A splicing iterator for `Vec`.\n+///\n+/// This struct is created by [`Vec::splice()`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let new = [7, 8];\n+/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub struct Splice<\n+    'a,\n+    I: Iterator + 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    pub(super) drain: Drain<'a, I::Item, A>,\n+    pub(super) replace_with: I,\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.drain.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.drain.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.drain.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n+    fn drop(&mut self) {\n+        self.drain.by_ref().for_each(drop);\n+\n+        unsafe {\n+            if self.drain.tail_len == 0 {\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n+                return;\n+            }\n+\n+            // First fill the range left by drain().\n+            if !self.drain.fill(&mut self.replace_with) {\n+                return;\n+            }\n+\n+            // There may be more elements. Use the lower bound as an estimate.\n+            // FIXME: Is the upper bound a better guess? Or something else?\n+            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n+            if lower_bound > 0 {\n+                self.drain.move_tail(lower_bound);\n+                if !self.drain.fill(&mut self.replace_with) {\n+                    return;\n+                }\n+            }\n+\n+            // Collect any remaining elements.\n+            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n+            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n+            // Now we have an exact count.\n+            if collected.len() > 0 {\n+                self.drain.move_tail(collected.len());\n+                let filled = self.drain.fill(&mut collected);\n+                debug_assert!(filled);\n+                debug_assert_eq!(collected.len(), 0);\n+            }\n+        }\n+        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n+    }\n+}\n+\n+/// Private helper methods for `Splice::drop`\n+impl<T, A: Allocator> Drain<'_, T, A> {\n+    /// The range from `self.vec.len` to `self.tail_start` contains elements\n+    /// that have been moved out.\n+    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let range_start = vec.len;\n+        let range_end = self.tail_start;\n+        let range_slice = unsafe {\n+            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n+        };\n+\n+        for place in range_slice {\n+            if let Some(new_item) = replace_with.next() {\n+                unsafe { ptr::write(place, new_item) };\n+                vec.len += 1;\n+            } else {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Makes room for inserting more elements before the tail.\n+    unsafe fn move_tail(&mut self, additional: usize) {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let len = self.tail_start + self.tail_len;\n+        vec.buf.reserve(len, additional);\n+\n+        let new_tail_start = self.tail_start + additional;\n+        unsafe {\n+            let src = vec.as_ptr().add(self.tail_start);\n+            let dst = vec.as_mut_ptr().add(new_tail_start);\n+            ptr::copy(src, dst, self.tail_len);\n+        }\n+        self.tail_start = new_tail_start;\n+    }\n+}\n\\ No newline at end of file"}]}