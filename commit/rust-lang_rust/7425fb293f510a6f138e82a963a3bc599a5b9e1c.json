{"sha": "7425fb293f510a6f138e82a963a3bc599a5b9e1c", "node_id": "C_kwDOAAsO6NoAKDc0MjVmYjI5M2Y1MTBhNmYxMzhlODJhOTYzYTNiYzU5OWE1YjllMWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T09:20:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T09:20:52Z"}, "message": "Auto merge of #98377 - davidv1992:add-lifetimes-to-argument-temporaries, r=oli-obk\n\nAdded llvm lifetime annotations to function call argument temporaries.\n\nThe goal of this change is to ensure that llvm will do stack slot\noptimization on these temporaries. This ensures that in code like:\n```rust\nconst A: [u8; 1024] = [0; 1024];\n\nfn copy_const() {\n    f(A);\n    f(A);\n}\n```\nwe only use 1024 bytes of stack space, instead of 2048 bytes.\n\nI am new to developing for the rust compiler, and as such not entirely sure, but I believe this should be sufficient to close #98156.\n\nAlso, this does not contain a test case to ensure this keeps working, primarily because I am not sure how to go about testing this. I would love some suggestions as to how that could be approached.", "tree": {"sha": "3bccaeca72855905c8e94128eafb473a64b197e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bccaeca72855905c8e94128eafb473a64b197e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7425fb293f510a6f138e82a963a3bc599a5b9e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7425fb293f510a6f138e82a963a3bc599a5b9e1c", "html_url": "https://github.com/rust-lang/rust/commit/7425fb293f510a6f138e82a963a3bc599a5b9e1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7425fb293f510a6f138e82a963a3bc599a5b9e1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b68106ffb71f853ea32f0e0dc0785d9d647cbbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b68106ffb71f853ea32f0e0dc0785d9d647cbbf", "html_url": "https://github.com/rust-lang/rust/commit/7b68106ffb71f853ea32f0e0dc0785d9d647cbbf"}, {"sha": "259a7a75ae67a7cafcb0db324f66af054e7a3600", "url": "https://api.github.com/repos/rust-lang/rust/commits/259a7a75ae67a7cafcb0db324f66af054e7a3600", "html_url": "https://github.com/rust-lang/rust/commit/259a7a75ae67a7cafcb0db324f66af054e7a3600"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "0503d7232405f4dcd783cb7d8179e435893df417", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7425fb293f510a6f138e82a963a3bc599a5b9e1c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7425fb293f510a6f138e82a963a3bc599a5b9e1c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7425fb293f510a6f138e82a963a3bc599a5b9e1c", "patch": "@@ -132,6 +132,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         llargs: &[Bx::Value],\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n+        copied_constant_arguments: &[PlaceRef<'tcx, <Bx as BackendTypes>::Value>],\n     ) {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n@@ -172,6 +173,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             if let Some((ret_dest, target)) = destination {\n                 bx.switch_to_block(fx.llbb(target));\n                 fx.set_debug_loc(bx, self.terminator.source_info);\n+                for tmp in copied_constant_arguments {\n+                    bx.lifetime_end(tmp.llval, tmp.layout.size);\n+                }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n@@ -186,6 +190,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n \n             if let Some((ret_dest, target)) = destination {\n+                for tmp in copied_constant_arguments {\n+                    bx.lifetime_end(tmp.llval, tmp.layout.size);\n+                }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, llret);\n                 self.funclet_br(fx, bx, target);\n             } else {\n@@ -415,6 +422,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args,\n             Some((ReturnDest::Nothing, target)),\n             unwind,\n+            &[],\n         );\n     }\n \n@@ -492,7 +500,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), lang_item);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup, &[]);\n     }\n \n     fn codegen_abort_terminator(\n@@ -508,7 +516,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), LangItem::PanicNoUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None, &[]);\n     }\n \n     /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n@@ -579,6 +587,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     &[msg.0, msg.1, location],\n                     target.as_ref().map(|bb| (ReturnDest::Nothing, *bb)),\n                     cleanup,\n+                    &[],\n                 );\n             } else {\n                 // a NOP\n@@ -786,6 +795,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             (args, None)\n         };\n \n+        let mut copied_constant_arguments = vec![];\n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n@@ -851,8 +861,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (&mir::Operand::Copy(_), Ref(_, None, _))\n                 | (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n                     let tmp = PlaceRef::alloca(&mut bx, op.layout);\n+                    bx.lifetime_start(tmp.llval, tmp.layout.size);\n                     op.val.store(&mut bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n+                    copied_constant_arguments.push(tmp);\n                 }\n                 _ => {}\n             }\n@@ -925,6 +937,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &llargs,\n                 target.as_ref().map(|&target| (ret_dest, target)),\n                 cleanup,\n+                &copied_constant_arguments,\n             );\n \n             bx.switch_to_block(bb_fail);\n@@ -942,6 +955,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             &llargs,\n             target.as_ref().map(|&target| (ret_dest, target)),\n             cleanup,\n+            &copied_constant_arguments,\n         );\n     }\n "}, {"sha": "12ace5fff6b6eb69285714c2efe6cc9dae5692c4", "filename": "src/test/codegen/issue-98156-const-arg-temp-lifetime.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7425fb293f510a6f138e82a963a3bc599a5b9e1c/src%2Ftest%2Fcodegen%2Fissue-98156-const-arg-temp-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7425fb293f510a6f138e82a963a3bc599a5b9e1c/src%2Ftest%2Fcodegen%2Fissue-98156-const-arg-temp-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-98156-const-arg-temp-lifetime.rs?ref=7425fb293f510a6f138e82a963a3bc599a5b9e1c", "patch": "@@ -0,0 +1,27 @@\n+// This test checks that temporaries for indirectly-passed arguments get lifetime markers.\n+\n+// compile-flags: -O -C no-prepopulate-passes -Zmir-opt-level=0\n+\n+#![crate_type = \"lib\"]\n+\n+extern \"Rust\" {\n+    fn f(x: [u8; 1024]);\n+}\n+\n+const A: [u8; 1024] = [0; 1024];\n+\n+// CHECK-LABEL: @const_arg_indirect\n+#[no_mangle]\n+pub unsafe fn const_arg_indirect() {\n+    // Ensure that the live ranges for the two argument temporaries don't overlap.\n+\n+    // CHECK: call void @llvm.lifetime.start\n+    // CHECK: call void @f\n+    // CHECK: call void @llvm.lifetime.end\n+    // CHECK: call void @llvm.lifetime.start\n+    // CHECK: call void @f\n+    // CHECK: call void @llvm.lifetime.end\n+\n+    f(A);\n+    f(A);\n+}"}]}