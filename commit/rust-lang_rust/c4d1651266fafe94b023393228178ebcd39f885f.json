{"sha": "c4d1651266fafe94b023393228178ebcd39f885f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZDE2NTEyNjZmYWZlOTRiMDIzMzkzMjI4MTc4ZWJjZDM5Zjg4NWY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-14T15:43:03Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-20T09:21:25Z"}, "message": "incr.comp.: Store result fingerprints in DepGraph.", "tree": {"sha": "467ab590a60f23e033e45a5ce67320c9f078a661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467ab590a60f23e033e45a5ce67320c9f078a661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4d1651266fafe94b023393228178ebcd39f885f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d1651266fafe94b023393228178ebcd39f885f", "html_url": "https://github.com/rust-lang/rust/commit/c4d1651266fafe94b023393228178ebcd39f885f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4d1651266fafe94b023393228178ebcd39f885f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25bc69ec20f19232eb0a1f6cac13cdefdf880dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/25bc69ec20f19232eb0a1f6cac13cdefdf880dfe", "html_url": "https://github.com/rust-lang/rust/commit/25bc69ec20f19232eb0a1f6cac13cdefdf880dfe"}], "stats": {"total": 309, "additions": 235, "deletions": 74}, "files": [{"sha": "7c4c87925a0d8315dc55f8889a60457db0ab2040", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -387,6 +387,17 @@ impl DefId {\n     }\n }\n \n+impl DepKind {\n+    #[inline]\n+    pub fn fingerprint_needed_for_crate_hash(self) -> bool {\n+        match self {\n+            DepKind::HirBody |\n+            DepKind::Krate => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n@@ -401,13 +412,13 @@ define_dep_nodes!( <'tcx>\n     // edges yourself for the individual items that you read.\n     [input] Krate,\n \n-    // Represents the HIR node with the given node-id\n-    [input] Hir(DefId),\n-\n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n     [input] HirBody(DefId),\n \n+    // Represents the HIR node with the given node-id\n+    [input] Hir(DefId),\n+\n     // Represents metadata from an extern crate.\n     [input] MetaData(DefId),\n "}, {"sha": "24e190c3fb7a4e73228f9fef109762c0a9265160", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -26,7 +26,8 @@ use super::edges::{DepGraphEdges, DepNodeIndex};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Option<Rc<DepGraphData>>\n+    data: Option<Rc<DepGraphData>>,\n+    fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n }\n \n struct DepGraphData {\n@@ -57,7 +58,8 @@ impl DepGraph {\n                 }))\n             } else {\n                 None\n-            }\n+            },\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n     }\n \n@@ -139,11 +141,27 @@ impl DepGraph {\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n-            let _: Fingerprint = stable_hasher.finish();\n+\n+            assert!(self.fingerprints\n+                        .borrow_mut()\n+                        .insert(key, stable_hasher.finish())\n+                        .is_none());\n \n             (result, dep_node_index)\n         } else {\n-            (task(cx, arg), DepNodeIndex::INVALID)\n+            if key.kind.fingerprint_needed_for_crate_hash() {\n+                let mut hcx = cx.create_stable_hashing_context();\n+                let result = task(cx, arg);\n+                let mut stable_hasher = StableHasher::new();\n+                result.hash_stable(&mut hcx, &mut stable_hasher);\n+                assert!(self.fingerprints\n+                            .borrow_mut()\n+                            .insert(key, stable_hasher.finish())\n+                            .is_none());\n+                (result, DepNodeIndex::INVALID)\n+            } else {\n+                (task(cx, arg), DepNodeIndex::INVALID)\n+            }\n         }\n     }\n \n@@ -195,6 +213,10 @@ impl DepGraph {\n         }\n     }\n \n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+        self.fingerprints.borrow().get(dep_node).cloned()\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "922e67d25c60b561fd9b56a11530541d85ae844e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 142, "deletions": 33, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -16,6 +16,9 @@ use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+\n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n@@ -26,36 +29,99 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     parent_node: NodeId,\n \n     current_dep_node_owner: DefIndex,\n-    current_dep_node_index: DepNodeIndex,\n+    current_signature_dep_index: DepNodeIndex,\n+    current_full_dep_index: DepNodeIndex,\n+    currently_in_body: bool,\n \n     dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n+\n+    hcx: StableHashingContext<'a>,\n+\n+    hir_body_nodes: Vec<DefPathHash>,\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n-                dep_graph: &'a DepGraph,\n-                definitions: &'a definitions::Definitions)\n+                       dep_graph: &'a DepGraph,\n+                       definitions: &'a definitions::Definitions,\n+                       hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n-        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n-        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n+        // Allocate DepNodes for the root module\n+        let (root_mod_sig_dep_index, root_mod_full_dep_index);\n+        {\n+            let Crate {\n+                ref module,\n+                // Crate attributes are not copied over to the root `Mod`, so hash\n+                // them explicitly here.\n+                ref attrs,\n+                span,\n+\n+                // These fields are handled separately:\n+                exported_macros: _,\n+                items: _,\n+                trait_items: _,\n+                impl_items: _,\n+                bodies: _,\n+                trait_impls: _,\n+                trait_default_impl: _,\n+                body_ids: _,\n+            } = *krate;\n+\n+            root_mod_sig_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::Hir),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: false },\n+                identity_fn\n+            ).1;\n+            root_mod_full_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::HirBody),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: true },\n+                identity_fn\n+            ).1;\n+        }\n+\n+        let hir_body_nodes = vec![root_mod_def_path_hash];\n \n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            current_dep_node_index: root_mod_dep_node_index,\n+            current_signature_dep_index: root_mod_sig_dep_index,\n+            current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n+            currently_in_body: false,\n             dep_graph,\n             definitions,\n+            hcx,\n+            hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_sig_dep_index));\n \n         collector\n     }\n \n-    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+    pub(super) fn finalize_and_compute_crate_hash(self,\n+                                                  crate_disambiguator: &str)\n+                                                  -> Vec<MapEntry<'hir>> {\n+        let mut node_hashes: Vec<_> = self\n+            .hir_body_nodes\n+            .iter()\n+            .map(|&def_path_hash| {\n+                let dep_node = def_path_hash.to_dep_node(DepKind::HirBody);\n+                (def_path_hash, self.dep_graph.fingerprint_of(&dep_node))\n+            })\n+            .collect();\n+\n+        node_hashes.sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+\n+        self.dep_graph.with_task(DepNode::new_no_params(DepKind::Krate),\n+                                 &self.hcx,\n+                                 (node_hashes, crate_disambiguator),\n+                                 identity_fn);\n         self.map\n     }\n \n@@ -70,7 +136,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n         let parent = self.parent_node;\n-        let dep_node_index = self.current_dep_node_index;\n+        let dep_node_index = if self.currently_in_body {\n+            self.current_full_dep_index\n+        } else {\n+            self.current_signature_dep_index\n+        };\n \n         let entry = match node {\n             NodeItem(n) => EntryItem(parent, dep_node_index, n),\n@@ -91,6 +161,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n             NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n             NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+            NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -127,22 +198,41 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+                           F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n+                                                 item_like: &T,\n                                                  f: F) {\n         let prev_owner = self.current_dep_node_owner;\n-        let prev_index = self.current_dep_node_index;\n-\n-        // When we enter a new owner (item, impl item, or trait item), we always\n-        // start out again with DepKind::Hir.\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(dep_node_owner)\n-                               .to_dep_node(DepKind::Hir);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_signature_dep_index = self.current_signature_dep_index;\n+        let prev_full_dep_index = self.current_signature_dep_index;\n+        let prev_in_body = self.currently_in_body;\n+\n+        let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n+\n+        self.current_signature_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::Hir),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: false },\n+            identity_fn\n+        ).1;\n+\n+        self.current_full_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::HirBody),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: true },\n+            identity_fn\n+        ).1;\n+\n+        self.hir_body_nodes.push(def_path_hash);\n+\n         self.current_dep_node_owner = dep_node_owner;\n+        self.currently_in_body = false;\n         f(self);\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n         self.current_dep_node_owner = prev_owner;\n+        self.current_full_dep_index = prev_full_dep_index;\n+        self.current_signature_dep_index = prev_signature_dep_index;\n     }\n }\n \n@@ -169,24 +259,17 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        // When we enter a body, we switch to DepKind::HirBody.\n-        // Note that current_dep_node_index might already be DepKind::HirBody,\n-        // e.g. when entering the body of a closure that is already part of a\n-        // surrounding body. That's expected and not a problem.\n-        let prev_index = self.current_dep_node_index;\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(self.current_dep_node_owner)\n-                               .to_dep_node(DepKind::HirBody);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_in_body = self.currently_in_body;\n+        self.currently_in_body = true;\n         self.visit_body(self.krate.body(id));\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n-        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+        self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.id, NodeItem(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n@@ -222,7 +305,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n-        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.id, NodeTraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n@@ -234,7 +317,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n-        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n             this.insert(ii.id, NodeImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n@@ -328,7 +411,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n-        self.insert_entry(macro_def.id, NotPresent);\n+        let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n+\n+        self.with_dep_node_owner(def_index, macro_def, |this| {\n+            this.insert(macro_def.id, NodeMacroDef(macro_def));\n+        });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n@@ -375,3 +462,25 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_impl_item(id);\n     }\n }\n+\n+\n+fn identity_fn<T>(_: &StableHashingContext, item_like: T) -> T {\n+    item_like\n+}\n+\n+struct HirItemLike<T> {\n+    item_like: T,\n+    hash_bodies: bool,\n+}\n+\n+impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+    where T: HashStable<StableHashingContext<'hir>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n+            self.item_like.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "20fce6fb41d7107413300dad61f93bf678cda7ad", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -57,6 +57,7 @@ pub enum Node<'hir> {\n     NodePat(&'hir Pat),\n     NodeBlock(&'hir Block),\n     NodeLocal(&'hir Local),\n+    NodeMacroDef(&'hir MacroDef),\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(&'hir VariantData),\n@@ -93,6 +94,8 @@ enum MapEntry<'hir> {\n     EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n     EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n \n+    EntryMacroDef(DepNodeIndex, &'hir MacroDef),\n+\n     /// Roots for node trees. The DepNodeIndex is the dependency node of the\n     /// crate's root module.\n     RootCrate(DepNodeIndex),\n@@ -127,6 +130,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryLocal(id, _, _) => id,\n \n             NotPresent |\n+            EntryMacroDef(..) |\n             RootCrate(_) => return None,\n         })\n     }\n@@ -151,6 +155,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryTyParam(_, _, n) => NodeTyParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n+            EntryMacroDef(_, n) => NodeMacroDef(n),\n \n             NotPresent |\n             RootCrate(_) => return None\n@@ -285,20 +290,12 @@ impl<'hir> Map<'hir> {\n             EntryVisibility(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n             EntryLocal(_, dep_node_index, _) |\n+            EntryMacroDef(dep_node_index, _) |\n             RootCrate(dep_node_index) => {\n                 self.dep_graph.read_index(dep_node_index);\n             }\n             NotPresent => {\n-                // Some nodes, notably macro definitions, are not\n-                // present in the map for whatever reason, but\n-                // they *do* have def-ids. So if we encounter an\n-                // empty hole, check for that case.\n-                if let Some(def_index) = self.definitions.opt_def_index(id) {\n-                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-                } else {\n-                    bug!(\"called HirMap::read() with invalid NodeId\")\n-                }\n+                bug!(\"called HirMap::read() with invalid NodeId\")\n             }\n         }\n     }\n@@ -875,6 +872,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n+            Some(EntryMacroDef(_, macro_def)) => macro_def.span,\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n@@ -1012,15 +1010,22 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub fn map_crate<'hir>(forest: &'hir mut Forest,\n+pub fn map_crate<'hir>(sess: &::session::Session,\n+                       cstore: &::middle::cstore::CrateStore,\n+                       forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let map = {\n+        let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+\n         let mut collector = NodeCollector::root(&forest.krate,\n                                                 &forest.dep_graph,\n-                                                &definitions);\n+                                                &definitions,\n+                                                hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n-        collector.into_map()\n+\n+        let crate_disambiguator = sess.local_crate_disambiguator().as_str();\n+        collector.finalize_and_compute_crate_hash(&crate_disambiguator)\n     };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n@@ -1103,6 +1108,7 @@ impl<'a> print::State<'a> {\n             // printing.\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n             NodeLocal(a)       => self.print_local_decl(&a),\n+            NodeMacroDef(_)    => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1219,6 +1225,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n+        Some(NodeMacroDef(_)) => {\n+            format!(\"macro {}{}\",  path_str(), id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "e393459027859a741d86de7ff4ec63dd2bcad3a4", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -22,6 +22,7 @@ struct CacheEntry {\n     file_index: usize,\n }\n \n+#[derive(Clone)]\n pub struct CachingCodemapView<'cm> {\n     codemap: &'cm CodeMap,\n     line_cache: [CacheEntry; 3],"}, {"sha": "e7a26e14db5bbb6349a8b3c53295c266390f0987", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -43,6 +43,7 @@ thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n+#[derive(Clone)]\n pub struct StableHashingContext<'gcx> {\n     sess: &'gcx Session,\n     definitions: &'gcx Definitions,\n@@ -264,6 +265,18 @@ impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n     }\n }\n \n+\n+impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n+    type ContextType = StableHashingContext<'gcx>;\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        self.clone()\n+    }\n+}\n+\n+impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+}\n+\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "e6b6267e7c2c3b11c839fd5a2c902e164b88aaca", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -691,7 +691,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref attrs,\n@@ -700,7 +700,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n@@ -725,7 +724,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref vis,\n@@ -736,7 +735,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);"}, {"sha": "55d0c6b4c66a34338337b14eee16eb5da9cd5164", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -310,7 +310,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeVariant(_) |\n             hir_map::NodeStructCtor(_) |\n             hir_map::NodeField(_) |\n-            hir_map::NodeTy(_) => {}\n+            hir_map::NodeTy(_) |\n+            hir_map::NodeMacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "da7743b49fb0696305b1e79b2cf225118a815078", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -1236,6 +1236,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   self.hir.definitions(),\n                                   self.cstore)\n     }\n+\n+    pub fn precompute_in_scope_traits_hashes(self) {\n+        for &def_index in self.trait_map.keys() {\n+            self.in_scope_traits_map(def_index);\n+        }\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "7d06d02de63dc2bfdc2876670605b61363ed2d2b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -175,7 +175,7 @@ pub fn compile_input(sess: &Session,\n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           || hir_map::map_crate(&mut hir_forest, &defs));\n+                           || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();"}, {"sha": "f7ea0a07f3df25321ad0b8159642f05ee197d19f", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::fs::*;\n use super::file_format;\n@@ -28,34 +27,27 @@ use std::fmt::Debug;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    incremental_hashes_map: &'a IncrementalHashesMap,\n     metadata_hashes: FxHashMap<DefId, Fingerprint>,\n     crate_hashes: FxHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               incremental_hashes_map: &'a IncrementalHashesMap)\n-               -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         HashContext {\n             tcx,\n-            incremental_hashes_map,\n             metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n         }\n     }\n \n     pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n         match dep_node.kind {\n-            DepKind::Krate => {\n-                Some(self.incremental_hashes_map[dep_node])\n-            }\n-\n             // HIR nodes (which always come from our crate) are an input:\n+            DepKind::Krate |\n             DepKind::InScopeTraits |\n             DepKind::Hir |\n             DepKind::HirBody => {\n-                Some(self.incremental_hashes_map[dep_node])\n+                Some(self.tcx.dep_graph.fingerprint_of(dep_node).unwrap())\n             }\n \n             // MetaData from other crates is an *input* to us."}, {"sha": "21e0dce7ad688ccb2a12ff84645b02f534c29c65", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -42,6 +42,7 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap) {\n+    tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n         load_dep_graph_if_exists(tcx, incremental_hashes_map);\n@@ -150,7 +151,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Compute the set of nodes from the old graph where some input\n     // has changed or been removed.\n     let dirty_raw_nodes = initial_dirty_nodes(tcx,\n-                                              incremental_hashes_map,\n                                               &serialized_dep_graph.nodes,\n                                               &serialized_dep_graph.hashes);\n     let dirty_raw_nodes = transitive_dirty_nodes(&serialized_dep_graph,\n@@ -202,11 +202,10 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 incremental_hashes_map: &IncrementalHashesMap,\n                                  nodes: &IndexVec<DepNodeIndex, DepNode>,\n                                  serialized_hashes: &[(DepNodeIndex, Fingerprint)])\n                                  -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n+    let mut hcx = HashContext::new(tcx);\n     let mut dirty_nodes = FxHashMap();\n \n     for &(dep_node_index, prev_hash) in serialized_hashes {"}, {"sha": "72f76670ee1ff8e353468e951cb0672524d97d13", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -51,7 +51,7 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n     }\n \n-    let mut hcx = HashContext::new(tcx, &incremental_hashes_map);\n+    let mut hcx = HashContext::new(tcx);\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n "}]}