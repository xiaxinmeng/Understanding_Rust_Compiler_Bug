{"sha": "56fbc63456d204c32e53e82c2277445d31ce983d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZmJjNjM0NTZkMjA0YzMyZTUzZTgyYzIyNzc0NDVkMzFjZTk4M2Q=", "commit": {"author": {"name": "Roman Stoliar", "email": "rizakrko@rambler.ru", "date": "2018-05-08T19:20:41Z"}, "committer": {"name": "Roman Stoliar", "email": "rizakrko@rambler.ru", "date": "2018-05-11T12:12:53Z"}, "message": "unary op filter, dereference hint", "tree": {"sha": "2426a63f99815b88c249d594dc11955a6e6c97f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2426a63f99815b88c249d594dc11955a6e6c97f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56fbc63456d204c32e53e82c2277445d31ce983d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56fbc63456d204c32e53e82c2277445d31ce983d", "html_url": "https://github.com/rust-lang/rust/commit/56fbc63456d204c32e53e82c2277445d31ce983d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56fbc63456d204c32e53e82c2277445d31ce983d/comments", "author": {"login": "rizakrko", "id": 18172179, "node_id": "MDQ6VXNlcjE4MTcyMTc5", "avatar_url": "https://avatars.githubusercontent.com/u/18172179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rizakrko", "html_url": "https://github.com/rizakrko", "followers_url": "https://api.github.com/users/rizakrko/followers", "following_url": "https://api.github.com/users/rizakrko/following{/other_user}", "gists_url": "https://api.github.com/users/rizakrko/gists{/gist_id}", "starred_url": "https://api.github.com/users/rizakrko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rizakrko/subscriptions", "organizations_url": "https://api.github.com/users/rizakrko/orgs", "repos_url": "https://api.github.com/users/rizakrko/repos", "events_url": "https://api.github.com/users/rizakrko/events{/privacy}", "received_events_url": "https://api.github.com/users/rizakrko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rizakrko", "id": 18172179, "node_id": "MDQ6VXNlcjE4MTcyMTc5", "avatar_url": "https://avatars.githubusercontent.com/u/18172179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rizakrko", "html_url": "https://github.com/rizakrko", "followers_url": "https://api.github.com/users/rizakrko/followers", "following_url": "https://api.github.com/users/rizakrko/following{/other_user}", "gists_url": "https://api.github.com/users/rizakrko/gists{/gist_id}", "starred_url": "https://api.github.com/users/rizakrko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rizakrko/subscriptions", "organizations_url": "https://api.github.com/users/rizakrko/orgs", "repos_url": "https://api.github.com/users/rizakrko/repos", "events_url": "https://api.github.com/users/rizakrko/events{/privacy}", "received_events_url": "https://api.github.com/users/rizakrko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f6945c77664eb0575de6f016f24c9f6ced1923f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6945c77664eb0575de6f016f24c9f6ced1923f", "html_url": "https://github.com/rust-lang/rust/commit/2f6945c77664eb0575de6f016f24c9f6ced1923f"}], "stats": {"total": 209, "additions": 131, "deletions": 78}, "files": [{"sha": "69b891af6632784ffd92e14d4a61710d544c9742", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 121, "deletions": 61, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -12,8 +12,8 @@\n \n use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n-use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n-use rustc::ty::TypeVariants::{TyStr, TyRef, TyAdt};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::TypeVariants::{TyRef, TyAdt, TyStr, TyUint, TyNever, TyTuple, TyChar, TyArray};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n@@ -246,39 +246,76 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n-                    if let IsAssign::Yes = is_assign {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0368,\n-                                         \"binary assignment operation `{}=` \\\n-                                          cannot be applied to type `{}`\",\n-                                         op.node.as_str(),\n-                                         lhs_ty)\n-                            .span_label(lhs_expr.span,\n-                                        format!(\"cannot use `{}=` on type `{}`\",\n-                                        op.node.as_str(), lhs_ty))\n-                            .emit();\n-                    } else {\n-                        let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n-                            \"binary operation `{}` cannot be applied to type `{}`\",\n-                            op.node.as_str(),\n-                            lhs_ty);\n-\n-                        if let TypeVariants::TyRef(_, rty, _) = lhs_ty.sty {\n-                            if {\n-                                !self.infcx.type_moves_by_default(self.param_env,\n-                                                                  rty,\n-                                                                  lhs_expr.span) &&\n-                                    self.lookup_op_method(rty,\n-                                                          &[rhs_ty],\n-                                                          Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                            } {\n-                                err.note(\n-                                    &format!(\n-                                        \"this is a reference to a type that `{}` can be applied \\\n-                                        to; you need to dereference this variable once for this \\\n-                                        operation to work\",\n-                                    op.node.as_str()));\n+                    match is_assign{\n+                        IsAssign::Yes => {\n+                            let mut err = struct_span_err!(self.tcx.sess, expr.span, E0368,\n+                                                \"binary assignment operation `{}=` \\\n+                                                cannot be applied to type `{}`\",\n+                                                op.node.as_str(),\n+                                                lhs_ty);\n+                            err.span_label(lhs_expr.span,\n+                                    format!(\"cannot use `{}=` on type `{}`\",\n+                                    op.node.as_str(), lhs_ty));\n+                            let missing_trait = match op.node {\n+                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n+                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n+                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n+                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n+                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n+                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n+                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n+                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n+                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n+                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n+                                _             => None\n+                            };\n+                            let mut suggested_deref = false;\n+                            if let TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                                if {\n+                                    !self.infcx.type_moves_by_default(self.param_env,\n+                                                                        ty_mut.ty,\n+                                                                        lhs_expr.span) &&\n+                                        self.lookup_op_method(ty_mut.ty,\n+                                                                &[rhs_ty],\n+                                                                Op::Binary(op, is_assign))\n+                                            .is_ok()\n+                                } {\n+                                    let codemap = self.tcx.sess.codemap();\n+                                    match codemap.span_to_snippet(lhs_expr.span) {\n+                                        Ok(lstring) =>{\n+                                            let msg = &format!(\n+                                                \"`{}=` can be used on '{}', you can \\\n+                                                dereference `{2}`: `*{2}`\",\n+                                                op.node.as_str(), ty_mut.ty, lstring);\n+                                            err.help(msg);\n+                                            suggested_deref = true;\n+                                        },\n+                                        _ => {}\n+                                    };\n+                                }\n+                            }\n+                            if let Some(missing_trait) = missing_trait {\n+                                if missing_trait == \"std::ops::AddAssign\" &&\n+                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n+                                                            rhs_ty, &mut err) {\n+                                    // This has nothing here because it means we did string\n+                                    // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                    // we don't want the note in the else clause to be emitted\n+                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                    // FIXME: point to span of param\n+                                    err.note(\n+                                        &format!(\"`{}` might need a bound for `{}`\",\n+                                                    lhs_ty, missing_trait));\n+                                } else {\n+                                    if !suggested_deref{\n+                                        err.note(\n+                                            &format!(\"an implementation of `{}` might \\\n+                                                        be missing for `{}`\",\n+                                                        missing_trait, lhs_ty));\n+                                    }\n+                                }\n                             }\n+                            err.emit();\n                         }\n                         IsAssign::No => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n@@ -301,7 +338,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     Some(\"std::cmp::PartialOrd\"),\n                                 _             => None\n                             };\n-                            if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                            let mut suggested_deref = false;\n+                            if let TyRef(_, ref ty_mut) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n                                                                         ty_mut.ty,\n@@ -311,36 +349,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                 Op::Binary(op, is_assign))\n                                             .is_ok()\n                                 } {\n+                                    let codemap = self.tcx.sess.codemap();\n+                                    match codemap.span_to_snippet(lhs_expr.span) {\n+                                        Ok(lstring) =>{\n+                                            let msg = &format!(\n+                                                \"`{}` can be used on '{}', you can \\\n+                                                dereference `{2}`: `*{2}`\",\n+                                                op.node.as_str(), ty_mut.ty, lstring);\n+                                            err.help(msg);\n+                                            suggested_deref = true;\n+                                        },\n+                                        _ =>{}\n+                                    }\n+                                }\n+                            }\n+                            if let Some(missing_trait) = missing_trait {\n+                                if missing_trait == \"std::ops::Add\" &&\n+                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n+                                                            rhs_ty, &mut err) {\n+                                    // This has nothing here because it means we did string\n+                                    // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                    // we don't want the note in the else clause to be emitted\n+                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                    // FIXME: point to span of param\n                                     err.note(\n-                                        &format!(\n-                                                \"this is a reference to a type that `{}` can be \\\n-                                                applied to; you need to dereference this variable \\\n-                                                once for this operation to work\",\n-                                        op.node.as_str()));\n+                                        &format!(\"`{}` might need a bound for `{}`\",\n+                                                    lhs_ty, missing_trait));\n+                                } else {\n+                                    if !suggested_deref{\n+                                        err.note(\n+                                            &format!(\"an implementation of `{}` might \\\n+                                                        be missing for `{}`\",\n+                                                        missing_trait, lhs_ty));\n+                                    }\n                                 }\n                             }\n-                            (err, missing_trait)\n-                        }\n-                    };\n-                    if let Some(missing_trait) = missing_trait {\n-                        if missing_trait == \"std::ops::Add\" &&\n-                            self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                    rhs_ty, &mut err) {\n-                            // This has nothing here because it means we did string\n-                            // concatenation (e.g. \"Hello \" + \"World!\"). This means\n-                            // we don't want the note in the else clause to be emitted\n-                        } else if let ty::TyParam(_) = lhs_ty.sty {\n-                            // FIXME: point to span of param\n-                            err.note(\n-                                &format!(\"`{}` might need a bound for `{}`\",\n-                                            lhs_ty, missing_trait));\n-                        } else {\n-                            err.note(\n-                                &format!(\"an implementation of `{}` might be missing for `{}`\",\n-                                            missing_trait, lhs_ty));\n+                            err.emit();\n                         }\n                     }\n-                    err.emit();\n                 }\n                 self.tcx.types.err\n             }\n@@ -420,13 +466,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let mut err = struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\",\n                                      op.as_str(), actual);\n+                    err.span_label(ex.span, format!(\"cannot apply unary \\\n+                                                    operator `{}`\", op.as_str()));\n                     let missing_trait = match op {\n                         hir::UnNeg => \"std::ops::Neg\",\n                         hir::UnNot => \"std::ops::Not\",\n                         hir::UnDeref => \"std::ops::UnDerf\"\n                     };\n-                    err.note(&format!(\"an implementation of `{}` might be missing for `{}`\",\n+                    match actual.sty{\n+                        TyUint(_) => {\n+                            if op == hir::UnNeg{\n+                                err.note(&format!(\"unsigned values cannot be negated\"));\n+                            }\n+                        },\n+                        TyStr | TyNever | TyChar | TyTuple(_) | TyArray(_,_) => {},\n+                        TyRef(_, ref lty) if lty.ty.sty == TyStr => {},\n+                        _ => {\n+                            err.note(&format!(\"an implementation of `{}` might \\\n+                                                be missing for `{}`\",\n                                              missing_trait, operand_ty));\n+                        }\n+                    }\n                     err.emit();\n                 }\n                 self.tcx.types.err"}, {"sha": "020d74bee52153e730e66e56129611348cf3dd07", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -4,8 +4,7 @@ error[E0369]: binary operation `%` cannot be applied to type `&&{integer}`\n LL |         x % 2 == 0\n    |         ^^^^^\n    |\n-   = note: this is a reference to a type that `%` can be applied to; you need to dereference this variable once for this operation to work\n-   = note: an implementation of `std::ops::Rem` might be missing for `&&{integer}`\n+   = help: `%` can be used on '&{integer}', you can dereference `x`: `*x`\n \n error: aborting due to previous error\n "}, {"sha": "15c159a3b153cf8f8cfcdc586eac03a2dce496ae", "filename": "src/test/ui/codemap_tests/issue-28308.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -2,9 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n   --> $DIR/issue-28308.rs:12:5\n    |\n LL |     assert!(\"foo\");\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: an implementation of `std::ops::Not` might be missing for `&'static str`\n+   |     ^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n \n error: aborting due to previous error\n "}, {"sha": "c29ec4fe6ae76e2f09e9ae53971e886b78deacc9", "filename": "src/test/ui/error-codes/E0600.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -2,9 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n   --> $DIR/E0600.rs:12:5\n    |\n LL |     !\"a\"; //~ ERROR E0600\n-   |     ^^^^\n-   |\n-   = note: an implementation of `std::ops::Not` might be missing for `&'static str`\n+   |     ^^^^ cannot apply unary operator `!`\n \n error: aborting due to previous error\n "}, {"sha": "69f11b4b7c08c33c74af00c7a73a05bd941ec0aa", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -30,7 +30,7 @@ error[E0600]: cannot apply unary operator `!` to type `Question`\n   --> $DIR/error-festival.rs:29:5\n    |\n LL |     !Question::Yes;\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n    |\n    = note: an implementation of `std::ops::Not` might be missing for `Question`\n "}, {"sha": "85e9b56e4af9db3f0caeee55d1621e7421599e08", "filename": "src/test/ui/feature-gate-negate-unsigned.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -2,17 +2,17 @@ error[E0600]: cannot apply unary operator `-` to type `usize`\n   --> $DIR/feature-gate-negate-unsigned.rs:20:23\n    |\n LL |     let _max: usize = -1;\n-   |                       ^^\n+   |                       ^^ cannot apply unary operator `-`\n    |\n-   = note: an implementation of `std::ops::Neg` might be missing for `usize`\n+   = note: unsigned values cannot be negated\n \n error[E0600]: cannot apply unary operator `-` to type `u8`\n   --> $DIR/feature-gate-negate-unsigned.rs:24:14\n    |\n LL |     let _y = -x;\n-   |              ^^\n+   |              ^^ cannot apply unary operator `-`\n    |\n-   = note: an implementation of `std::ops::Neg` might be missing for `u8`\n+   = note: unsigned values cannot be negated\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7ae01fb7d6012996c1e80ebb82038431117b6aaa", "filename": "src/test/ui/issue-5239-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-5239-1.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -6,7 +6,7 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n    |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `&isize`\n+   = help: `+=` can be used on 'isize', you can dereference `x`: `*x`\n \n error: aborting due to previous error\n "}, {"sha": "b889c884fcbb223f66e2eb574dc482cf6c06f908", "filename": "src/test/ui/reachable/expr_unary.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56fbc63456d204c32e53e82c2277445d31ce983d/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr?ref=56fbc63456d204c32e53e82c2277445d31ce983d", "patch": "@@ -2,9 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `!`\n   --> $DIR/expr_unary.rs:17:16\n    |\n LL |     let x: ! = ! { return; }; //~ ERROR unreachable\n-   |                ^^^^^^^^^^^^^\n-   |\n-   = note: an implementation of `std::ops::Not` might be missing for `!`\n+   |                ^^^^^^^^^^^^^ cannot apply unary operator `!`\n \n error: unreachable expression\n   --> $DIR/expr_unary.rs:17:16"}]}