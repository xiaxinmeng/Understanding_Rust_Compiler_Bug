{"sha": "6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMGE3YzdiN2QzMDQxNTdmMzExODliZjM0ZjUwZWY0MDI3ZTFkNjY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-23T14:00:43Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-24T12:34:10Z"}, "message": "libcore: remove @Rng from rand, and use traits instead.\n\nAlso, rename RandRes -> IsaacRng, and make the constructors static\nmethods.", "tree": {"sha": "231628b0d02fbc5dc74cf71ca0a04ce422820243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/231628b0d02fbc5dc74cf71ca0a04ce422820243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "html_url": "https://github.com/rust-lang/rust/commit/6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "706096b31960143fb1eb957a882f170ae4a8b4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/706096b31960143fb1eb957a882f170ae4a8b4e9", "html_url": "https://github.com/rust-lang/rust/commit/706096b31960143fb1eb957a882f170ae4a8b4e9"}], "stats": {"total": 400, "additions": 205, "deletions": 195}, "files": [{"sha": "5c4181c10cf3b42f40af7725627ae8b9645e2249", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -85,7 +85,7 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_flate_round_trip() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n     let mut words = ~[];\n     for 20.times {\n         words.push(r.gen_bytes(r.gen_uint_range(1, 10)));"}, {"sha": "3233207b8bd6ae515c84125753fee2736f853113", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -56,7 +56,7 @@ fn resize_at(capacity: uint) -> uint {\n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n     let r = rand::task_rng();\n-    linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n+    linear_map_with_capacity_and_keys((*r).gen_u64(), (*r).gen_u64(),\n                                       initial_capacity)\n }\n "}, {"sha": "1000fd88b524639c9828a125d1d7a5d71f7ee010", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -1259,7 +1259,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> ~str {\n-        let rng: @rand::Rng = rand::Rng();\n+        let rng = rand::rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert!(getenv(n).is_none());\n         n"}, {"sha": "86509c81eb34dca063131edb9a8bdeebbc79fa93", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 166, "deletions": 158, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -22,95 +22,95 @@ use libc::size_t;\n \n /// A type that can be randomly generated using an RNG\n pub trait Rand {\n-    fn rand(rng: @rand::Rng) -> Self;\n+    fn rand<R: Rng>(rng: &R) -> Self;\n }\n \n impl Rand for int {\n-    fn rand(rng: @rand::Rng) -> int {\n+    fn rand<R: Rng>(rng: &R) -> int {\n         rng.gen_int()\n     }\n }\n \n impl Rand for i8 {\n-    fn rand(rng: @rand::Rng) -> i8 {\n+    fn rand<R: Rng>(rng: &R) -> i8 {\n         rng.gen_i8()\n     }\n }\n \n impl Rand for i16 {\n-    fn rand(rng: @rand::Rng) -> i16 {\n+    fn rand<R: Rng>(rng: &R) -> i16 {\n         rng.gen_i16()\n     }\n }\n \n impl Rand for i32 {\n-    fn rand(rng: @rand::Rng) -> i32 {\n+    fn rand<R: Rng>(rng: &R) -> i32 {\n         rng.gen_i32()\n     }\n }\n \n impl Rand for i64 {\n-    fn rand(rng: @rand::Rng) -> i64 {\n+    fn rand<R: Rng>(rng: &R) -> i64 {\n         rng.gen_i64()\n     }\n }\n \n impl Rand for uint {\n-    fn rand(rng: @rand::Rng) -> uint {\n+    fn rand<R: Rng>(rng: &R) -> uint {\n         rng.gen_uint()\n     }\n }\n \n impl Rand for u8 {\n-    fn rand(rng: @rand::Rng) -> u8 {\n+    fn rand<R: Rng>(rng: &R) -> u8 {\n         rng.gen_u8()\n     }\n }\n \n impl Rand for u16 {\n-    fn rand(rng: @rand::Rng) -> u16 {\n+    fn rand<R: Rng>(rng: &R) -> u16 {\n         rng.gen_u16()\n     }\n }\n \n impl Rand for u32 {\n-    fn rand(rng: @rand::Rng) -> u32 {\n+    fn rand<R: Rng>(rng: &R) -> u32 {\n         rng.gen_u32()\n     }\n }\n \n impl Rand for u64 {\n-    fn rand(rng: @rand::Rng) -> u64 {\n+    fn rand<R: Rng>(rng: &R) -> u64 {\n         rng.gen_u64()\n     }\n }\n \n impl Rand for float {\n-    fn rand(rng: @rand::Rng) -> float {\n+    fn rand<R: Rng>(rng: &R) -> float {\n         rng.gen_float()\n     }\n }\n \n impl Rand for f32 {\n-    fn rand(rng: @rand::Rng) -> f32 {\n+    fn rand<R: Rng>(rng: &R) -> f32 {\n         rng.gen_f32()\n     }\n }\n \n impl Rand for f64 {\n-    fn rand(rng: @rand::Rng) -> f64 {\n+    fn rand<R: Rng>(rng: &R) -> f64 {\n         rng.gen_f64()\n     }\n }\n \n impl Rand for char {\n-    fn rand(rng: @rand::Rng) -> char {\n+    fn rand<R: Rng>(rng: &R) -> char {\n         rng.gen_char()\n     }\n }\n \n impl Rand for bool {\n-    fn rand(rng: @rand::Rng) -> bool {\n+    fn rand<R: Rng>(rng: &R) -> bool {\n         rng.gen_bool()\n     }\n }\n@@ -123,10 +123,10 @@ macro_rules! tuple_impl {\n             $( $tyvar : Rand ),*\n             > Rand for ( $( $tyvar ),* , ) {\n \n-            fn rand (_rng: @Rng) -> ( $( $tyvar ),* , ) {\n+            fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n                 (\n-                    // use the $var's to get the appropriate number of repeats\n-                    // (they're not actually needed)\n+                    // use the $tyvar's to get the appropriate number of\n+                    // repeats (they're not actually needed)\n                     $(\n                         _rng.gen::<$tyvar>()\n                     ),*\n@@ -137,7 +137,7 @@ macro_rules! tuple_impl {\n     }\n }\n \n-impl Rand for () { fn rand(_: @Rng) -> () { () } }\n+impl Rand for () { fn rand<R: Rng>(_: &R) -> () { () } }\n tuple_impl!{A}\n tuple_impl!{A, B}\n tuple_impl!{A, B, C}\n@@ -150,21 +150,21 @@ tuple_impl!{A, B, C, D, E, F, G, H, I}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n-    fn rand(rng: @rand::Rng) -> Option<T> {\n+    fn rand<R: Rng>(rng: &R) -> Option<T> {\n         if rng.gen_bool() {\n-            Some(Rand::rand(rng))\n+            Some(rng.gen())\n         } else {\n             None\n         }\n     }\n }\n \n impl<T: Rand> Rand for ~T {\n-    fn rand(rng: @Rng) -> ~T { ~rng.gen() }\n+    fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n-    fn rand(rng: @Rng) -> @T { @rng.gen() }\n+    fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n }\n \n #[allow(non_camel_case_types)] // runtime type\n@@ -173,7 +173,7 @@ pub enum rust_rng {}\n #[abi = \"cdecl\"]\n pub mod rustrt {\n     use libc::size_t;\n-    use rand::rust_rng;\n+    use super::rust_rng;\n \n     pub extern {\n         unsafe fn rand_seed_size() -> size_t;\n@@ -187,17 +187,18 @@ pub mod rustrt {\n /// A random number generator\n pub trait Rng {\n     /// Return the next random integer\n-    fn next(&self) -> u32;\n+    pub fn next(&self) -> u32;\n }\n \n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     weight: uint,\n     item: T,\n }\n-\n+// this should be in gen_f64, but it causes an ICE there.\n+static scale : f64 = (u32::max_value as f64) + 1.0f64;\n pub trait RngUtil {\n-    /// Return a random value for a Rand type\n+    /// Return a random value of a Rand type\n     fn gen<T:Rand>(&self) -> T;\n     /**\n      * Return a random int\n@@ -209,7 +210,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%d\",rng.gen_int()));\n      * }\n      * ~~~\n@@ -249,7 +250,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%f\",rng.gen_float()));\n      * }\n      * ~~~\n@@ -275,7 +276,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%b\",rng.gen_bool()));\n      * }\n      * ~~~\n@@ -291,7 +292,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%b\",rng.gen_weighted_bool(3)));\n      * }\n      * ~~~\n@@ -307,7 +308,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(rng.gen_str(8));\n      * }\n      * ~~~\n@@ -323,13 +324,12 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%?\",rng.gen_bytes(8)));\n      * }\n      * ~~~\n      */\n     fn gen_bytes(&self, len: uint) -> ~[u8];\n-    ///\n     /**\n      * Choose an item randomly, failing if values is empty\n      *\n@@ -340,7 +340,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%d\",rng.choose([1,2,4,8,16,32])));\n      * }\n      * ~~~\n@@ -359,7 +359,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -379,7 +379,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -399,7 +399,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -418,7 +418,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%?\",rng.shuffle([1,2,3])));\n      * }\n      * ~~~\n@@ -434,7 +434,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let mut y = [1,2,3];\n      *     rng.shuffle_mut(y);\n      *     println(fmt!(\"%?\",y));\n@@ -447,10 +447,10 @@ pub trait RngUtil {\n }\n \n /// Extension methods for random number generators\n-impl RngUtil for @Rng {\n+impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n-    fn gen<T:Rand>(&self) -> T {\n-        Rand::rand(*self)\n+    fn gen<T: Rand>(&self) -> T {\n+        Rand::rand(self)\n     }\n \n     /// Return a random int\n@@ -536,7 +536,7 @@ impl RngUtil for @Rng {\n         let u1 = self.next() as f64;\n         let u2 = self.next() as f64;\n         let u3 = self.next() as f64;\n-        static scale : f64 = (u32::max_value as f64) + 1.0f64;\n+\n         return ((u1 / scale + u2) / scale + u3) / scale;\n     }\n \n@@ -605,7 +605,6 @@ impl RngUtil for @Rng {\n             Some(values[self.gen_uint_range(0u, values.len())])\n         }\n     }\n-\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n@@ -668,36 +667,61 @@ impl RngUtil for @Rng {\n             vec::swap(values, i, self.gen_uint_range(0u, i + 1u));\n         }\n     }\n+}\n \n+/// Create a random number generator with a default algorithm and seed.\n+pub fn rng() -> IsaacRng {\n+    IsaacRng::new()\n }\n \n-struct RandRes {\n-    rng: *rust_rng,\n+pub struct IsaacRng {\n+    priv rng: *rust_rng,\n }\n \n-impl Drop for RandRes {\n+impl Drop for IsaacRng {\n     fn finalize(&self) {\n         unsafe {\n             rustrt::rand_free(self.rng);\n         }\n     }\n }\n \n-fn RandRes(rng: *rust_rng) -> RandRes {\n-    RandRes {\n-        rng: rng\n+pub impl IsaacRng {\n+    priv fn from_rust_rng(rng: *rust_rng) -> IsaacRng {\n+        IsaacRng {\n+            rng: rng\n+        }\n+    }\n+\n+    /// Create an ISAAC random number generator with a system specified seed\n+    fn new() -> IsaacRng {\n+        IsaacRng::new_seeded(seed())\n+    }\n+\n+    /**\n+     * Create a random number generator using the specified seed. A generator\n+     * constructed with a given seed will generate the same sequence of values as\n+     * all other generators constructed with the same seed. The seed may be any\n+     * length.\n+     */\n+    fn new_seeded(seed: &[u8]) -> IsaacRng {\n+        unsafe {\n+            do vec::as_imm_buf(seed) |p, sz| {\n+                IsaacRng::from_rust_rng(rustrt::rand_new_seeded(p, sz as size_t))\n+            }\n+        }\n     }\n }\n \n-impl Rng for @RandRes {\n-    fn next(&self) -> u32 {\n+impl Rng for IsaacRng {\n+    pub fn next(&self) -> u32 {\n         unsafe {\n-            return rustrt::rand_next((*self).rng);\n+            return rustrt::rand_next(self.rng);\n         }\n     }\n }\n \n-/// Create a new random seed for seeded_rng\n+/// Create a new random seed for IsaacRng::new_seeded\n pub fn seed() -> ~[u8] {\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n@@ -709,38 +733,15 @@ pub fn seed() -> ~[u8] {\n     }\n }\n \n-/// Create a random number generator with a system specified seed\n-pub fn Rng() -> @Rng {\n-    seeded_rng(seed())\n-}\n-\n-/**\n- * Create a random number generator using the specified seed. A generator\n- * constructed with a given seed will generate the same sequence of values as\n- * all other generators constructed with the same seed. The seed may be any\n- * length.\n- */\n-pub fn seeded_rng(seed: &[u8]) -> @Rng {\n-    @seeded_randres(seed) as @Rng\n-}\n-\n-fn seeded_randres(seed: &[u8]) -> @RandRes {\n-    unsafe {\n-        do vec::as_imm_buf(seed) |p, sz| {\n-            @RandRes(rustrt::rand_new_seeded(p, sz as size_t))\n-        }\n-    }\n-}\n-\n-struct XorShiftState {\n-    mut x: u32,\n-    mut y: u32,\n-    mut z: u32,\n-    mut w: u32,\n+struct XorShiftRng {\n+    priv mut x: u32,\n+    priv mut y: u32,\n+    priv mut z: u32,\n+    priv mut w: u32,\n }\n \n-impl Rng for XorShiftState {\n-    fn next(&self) -> u32 {\n+impl Rng for XorShiftRng {\n+    pub fn next(&self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -752,38 +753,46 @@ impl Rng for XorShiftState {\n     }\n }\n \n-pub fn xorshift() -> @Rng {\n-    // constants taken from http://en.wikipedia.org/wiki/Xorshift\n-    seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n-}\n+pub impl XorShiftRng {\n+    /// Create an xor shift random number generator with a default seed.\n+    fn new() -> XorShiftRng {\n+        // constants taken from http://en.wikipedia.org/wiki/Xorshift\n+        XorShiftRng::new_seeded(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n+    }\n \n-pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n-    @XorShiftState { x: x, y: y, z: z, w: w } as @Rng\n-}\n+    /**\n+     * Create a random number generator using the specified seed. A generator\n+     * constructed with a given seed will generate the same sequence of values as\n+     * all other generators constructed with the same seed.\n+     */\n+    fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n+        XorShiftRng { x: x, y: y, z: z, w: w }\n+    }\n \n+}\n \n // used to make space in TLS for a random number generator\n-fn tls_rng_state(_v: @RandRes) {}\n+fn tls_rng_state(_v: @IsaacRng) {}\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * task_rng().gen_int().\n  */\n-pub fn task_rng() -> @Rng {\n-    let r : Option<@RandRes>;\n+pub fn task_rng() -> @IsaacRng {\n+    let r : Option<@IsaacRng>;\n     unsafe {\n         r = task::local_data::local_data_get(tls_rng_state);\n     }\n     match r {\n         None => {\n             unsafe {\n-                let rng = seeded_randres(seed());\n+                let rng = @IsaacRng::new_seeded(seed());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n-                @rng as @Rng\n+                rng\n             }\n         }\n-        Some(rng) => @rng as @Rng\n+        Some(rng) => rng\n     }\n }\n \n@@ -792,36 +801,35 @@ pub fn task_rng() -> @Rng {\n  * generator.\n  */\n pub fn random<T: Rand>() -> T {\n-    task_rng().gen()\n+    (*task_rng()).gen()\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use option::{Option, Some};\n-    use rand;\n+    use super::*;\n \n     #[test]\n-    fn rng_seeded() {\n-        let seed = rand::seed();\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+    fn test_rng_seeded() {\n+        let seed = seed();\n+        let ra = IsaacRng::new_seeded(seed);\n+        let rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed() {\n+    fn test_rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+        let ra = IsaacRng::new_seeded(seed);\n+        let rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed2() {\n+    fn test_rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n+        let ra = IsaacRng::new_seeded(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n@@ -830,8 +838,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_int_range() {\n-        let r = rand::Rng();\n+    fn test_gen_int_range() {\n+        let r = rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n         assert!(r.gen_int_range(0, 1) == 0);\n@@ -841,13 +849,13 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_int_from_fail() {\n-        rand::Rng().gen_int_range(5, -2);\n+    fn test_gen_int_from_fail() {\n+        rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn gen_uint_range() {\n-        let r = rand::Rng();\n+    fn test_gen_uint_range() {\n+        let r = rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -857,28 +865,28 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_uint_range_fail() {\n-        rand::Rng().gen_uint_range(5u, 2u);\n+    fn test_gen_uint_range_fail() {\n+        rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    fn gen_float() {\n-        let r = rand::Rng();\n+    fn test_gen_float() {\n+        let r = rng();\n         let a = r.gen_float();\n         let b = r.gen_float();\n         debug!((a, b));\n     }\n \n     #[test]\n-    fn gen_weighted_bool() {\n-        let r = rand::Rng();\n+    fn test_gen_weighted_bool() {\n+        let r = rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n-    fn gen_str() {\n-        let r = rand::Rng();\n+    fn test_gen_str() {\n+        let r = rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -888,91 +896,91 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_bytes() {\n-        let r = rand::Rng();\n+    fn test_gen_bytes() {\n+        let r = rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n-    fn choose() {\n-        let r = rand::Rng();\n+    fn test_choose() {\n+        let r = rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n-    fn choose_option() {\n-        let r = rand::Rng();\n+    fn test_choose_option() {\n+        let r = rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n-    fn choose_weighted() {\n-        let r = rand::Rng();\n+    fn test_choose_weighted() {\n+        let r = rng();\n         assert!(r.choose_weighted(~[\n-            rand::Weighted { weight: 1u, item: 42 },\n+            Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n         assert!(r.choose_weighted(~[\n-            rand::Weighted { weight: 0u, item: 42 },\n-            rand::Weighted { weight: 1u, item: 43 },\n+            Weighted { weight: 0u, item: 42 },\n+            Weighted { weight: 1u, item: 43 },\n         ]) == 43);\n     }\n \n     #[test]\n-    fn choose_weighted_option() {\n-        let r = rand::Rng();\n+    fn test_choose_weighted_option() {\n+        let r = rng();\n         assert!(r.choose_weighted_option(~[\n-            rand::Weighted { weight: 1u, item: 42 },\n+            Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n         assert!(r.choose_weighted_option(~[\n-            rand::Weighted { weight: 0u, item: 42 },\n-            rand::Weighted { weight: 1u, item: 43 },\n+            Weighted { weight: 0u, item: 42 },\n+            Weighted { weight: 1u, item: 43 },\n         ]) == Some(43));\n         let v: Option<int> = r.choose_weighted_option([]);\n         assert!(v.is_none());\n     }\n \n     #[test]\n-    fn weighted_vec() {\n-        let r = rand::Rng();\n+    fn test_weighted_vec() {\n+        let r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n         assert!(r.weighted_vec(~[\n-            rand::Weighted { weight: 0u, item: 3u },\n-            rand::Weighted { weight: 1u, item: 2u },\n-            rand::Weighted { weight: 2u, item: 1u },\n+            Weighted { weight: 0u, item: 3u },\n+            Weighted { weight: 1u, item: 2u },\n+            Weighted { weight: 2u, item: 1u },\n         ]) == ~[2u, 1u, 1u]);\n     }\n \n     #[test]\n-    fn shuffle() {\n-        let r = rand::Rng();\n+    fn test_shuffle() {\n+        let r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n-    fn task_rng() {\n-        let r = rand::task_rng();\n-        r.gen_int();\n-        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n-        assert!(r.gen_uint_range(0u, 1u) == 0u);\n+    fn test_task_rng() {\n+        let r = task_rng();\n+        (*r).gen_int();\n+        assert!((*r).shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        assert!((*r).gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]\n-    fn random() {\n+    fn test_random() {\n         // not sure how to test this aside from just getting some values\n-        let _n : uint = rand::random();\n-        let _f : f32 = rand::random();\n-        let _o : Option<Option<i8>> = rand::random();\n+        let _n : uint = random();\n+        let _f : f32 = random();\n+        let _o : Option<Option<i8>> = random();\n         let _many : ((),\n                      (~uint, @int, ~Option<~(@char, ~(@bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n-                     (f32, (f64, (float,)))) = rand::random();\n+                     (f32, (f64, (float,)))) = random();\n     }\n }\n "}, {"sha": "bc4ec620aa86ad47441a0d94628e8b11f0b348e9", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -62,7 +62,7 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     // give us ownership of the array of functions\n     let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n     // Let's not make any promises about execution order\n-    rand::Rng().shuffle_mut(exit_fns_vec);\n+    rand::rng().shuffle_mut(exit_fns_vec);\n \n     debug!(\"running %u exit functions\", exit_fns_vec.len());\n "}, {"sha": "b35b9face2a8fea9c1a9fee951513fbf10ed8dc8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -78,7 +78,7 @@ mod test {\n \n     // Helper function to create a directory name that doesn't exist\n     pub fn mk_nonexistent(tmpdir: &Path, suffix: &str) -> Path {\n-        let r = rand::Rng();\n+        let r = rand::rng();\n         for 1000.times {\n             let p = tmpdir.push(r.gen_str(16) + suffix);\n             if !os::path_exists(&p) {"}, {"sha": "5f4d507568a103f326160ecfa6d47646edca6823", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -876,6 +876,7 @@ mod tests {\n     use core::uint;\n     use core::vec;\n     use core::rand;\n+    use core::rand::Rng;\n \n     static bench_bits : uint = 1 << 14;\n \n@@ -1424,9 +1425,9 @@ mod tests {\n         assert!(a.capacity() == uint::bits);\n     }\n \n-    fn rng() -> @rand::Rng {\n+    fn rng() -> rand::RandRes {\n         let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::seeded_rng(seed)\n+        rand::IsaacRng::new_seeded(seed)\n     }\n \n     #[bench]"}, {"sha": "be32fb25657559dd6798af21fb5f5e161f12e5fd", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -915,7 +915,7 @@ mod test_tim_sort {\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            let rng = rand::Rng();\n+            let rng = rand::rng();\n             if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n             (*self).val < other.val\n         }\n@@ -964,7 +964,7 @@ mod test_tim_sort {\n     #[should_fail]\n     #[cfg(unix)]\n     fn crash_test() {\n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n         let mut arr = do vec::from_fn(1000) |_i| {\n             let randVal = rng.gen_float();\n             CVal { val: randVal }\n@@ -985,7 +985,7 @@ mod test_tim_sort {\n \n     #[test]\n     fn test_bad_Ord_impl() {\n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n         let mut arr = do vec::from_fn(500) |_i| {\n             let randVal = rng.gen_uint();\n             DVal { val: randVal }\n@@ -1045,7 +1045,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n@@ -1117,7 +1117,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;"}, {"sha": "b92e652b7af9b8f74ec662afb9e9709cbe7719cf", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -16,7 +16,7 @@ use core::rand::RngUtil;\n use core::rand;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n     for 1000.times {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700"}, {"sha": "113d66b30204d9386df936dba7d795e2c93cc4e0", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -705,7 +705,7 @@ pub mod bench {\n         // not met, it may run as long as the Go algorithm.\n         pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n \n-            let rng = rand::Rng();\n+            let rng = rand::rng();\n             let mut magnitude = 10;\n             let mut prev_madp = 0.0;\n "}, {"sha": "f0daf407073afa693fa4610f5fa2cb00214589b0", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -220,7 +220,7 @@ mod test {\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use core::rand::*;\n-                    let rng = Rng();\n+                    let rng = rng();\n                     for iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n@@ -277,7 +277,7 @@ mod test {\n         let hl_loop = uv::global_loop::get();\n \n         for iter::repeat(times as uint) {\n-            let expected = rand::Rng().gen_str(16u);\n+            let expected = rand::rng().gen_str(16u);\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {"}, {"sha": "dbb01b6ce397b21d746c4d675f47166805350d8f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -835,7 +835,7 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let rng = rand::seeded_rng(&[42]);\n+        let rng = rand::IsaacRng::new_seeded(&[42]);\n \n         for 3.times {\n             for 90.times {"}, {"sha": "0c53ccd46e8b7ae9cf49bfca3c3e49aaec3b35db", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -102,7 +102,7 @@ fn main() {\n     let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let rng = core::rand::seeded_rng([1, 1, 1, 1, 1, 1, 1]);\n+        let rng = core::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.next() as uint;"}, {"sha": "2ed3f668684d8fb4341e684e89c21c10859673ea", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -32,7 +32,7 @@ fn timed(result: &mut float, op: &fn()) {\n }\n \n pub impl Results {\n-    fn bench_int<T:Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+    fn bench_int<T:Set<uint>>(&mut self, rng: &rand::Rng, num_keys: uint,\n                                rand_cap: uint, f: &fn() -> T) {\n         {\n             let mut set = f();\n@@ -70,7 +70,7 @@ pub impl Results {\n         }\n     }\n \n-    fn bench_str<T:Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+    fn bench_str<T:Set<~str>>(&mut self, rng: &rand::Rng, num_keys: uint,\n                                f: &fn() -> T) {\n         {\n             let mut set = f();\n@@ -156,23 +156,23 @@ fn main() {\n     let max = 200000;\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || HashSet::new::<uint>());\n-        results.bench_str(rng, num_keys, || HashSet::new::<~str>());\n+        results.bench_int(&rng, num_keys, max, || HashSet::new::<uint>());\n+        results.bench_str(&rng, num_keys, || HashSet::new::<~str>());\n         write_results(\"core::hashmap::HashSet\", &results);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n         results.bench_int(rng, num_keys, max, || TreeSet::new::<uint>());\n         results.bench_str(rng, num_keys, || TreeSet::new::<~str>());\n         write_results(\"std::treemap::TreeSet\", &results);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n         results.bench_int(rng, num_keys, max, || BitvSet::new());\n         write_results(\"std::bitv::BitvSet\", &results);"}, {"sha": "8438759b5c8d3fda13d4612eb3089032bdddfeb5", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -71,7 +71,7 @@ fn read_line() {\n }\n \n fn vec_plus() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n@@ -88,7 +88,7 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n@@ -105,7 +105,7 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     for uint::range(0, 1500) |i| {"}, {"sha": "e84d8abf9790c43917bd2857425984159d28b7f5", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -34,9 +34,9 @@ type graph = ~[~[node_id]];\n type bfs_result = ~[node_id];\n \n fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n-    let r = rand::xorshift();\n+    let r = rand::XorShiftRng::new();\n \n-    fn choose_edge(i: node_id, j: node_id, scale: uint, r: @rand::Rng)\n+    fn choose_edge<R: rand::Rng>(i: node_id, j: node_id, scale: uint, r: &R)\n         -> (node_id, node_id) {\n \n         let A = 0.57;\n@@ -75,7 +75,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n     }\n \n     do vec::from_fn((1u << scale) * edgefactor) |_i| {\n-        choose_edge(0i64, 0i64, scale, r)\n+        choose_edge(0i64, 0i64, scale, &r)\n     }\n }\n \n@@ -105,7 +105,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     let mut keys = HashSet::new();\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());"}, {"sha": "e032274482a02b302ae4e02ea0bd183e9ae7328c", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -13,7 +13,7 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n #[inline(always)]\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n-fn random_gradient(r: @Rng) -> Vec2 {\n+fn random_gradient(r: &Rng) -> Vec2 {\n     let v = r.gen_float() * float::consts::pi * 2.0;\n     Vec2 {\n         x: float::cos(v) as f32,\n@@ -33,9 +33,9 @@ struct Noise2DContext {\n \n pub impl Noise2DContext {\n     fn new() -> Noise2DContext {\n-        let r = rand::Rng();\n+        let r = rand::rng();\n         let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n-        for int::range(0, 256) |i| { rgradients[i] = random_gradient(r); }\n+        for int::range(0, 256) |i| { rgradients[i] = random_gradient(&r); }\n         let mut permutations = [ 0, ..256 ];\n         for int::range(0, 256) |i| { permutations[i] = i; }\n         r.shuffle_mut(permutations);"}, {"sha": "83e1a958d3ca853be079782a7a7e479e0aa173b0", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -63,7 +63,7 @@ fn make_random_fasta(wr: @io::Writer,\n                      genelist: ~[AminoAcids],\n                      n: int) {\n     wr.write_line(~\">\" + id + ~\" \" + desc);\n-    let rng = @mut MyRandom {last: rand::Rng().next()};\n+    let rng = @mut MyRandom {last: rand::rng().next()};\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n         str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),"}, {"sha": "1f908936aef471195c6f0c84d6ba744651e5694a", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a7c7b7d304157f31189bf34f50ef4027e1d66/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=6c0a7c7b7d304157f31189bf34f50ef4027e1d66", "patch": "@@ -54,14 +54,15 @@ fn runtest2(f: extern fn(), frame_backoff: u32, last_stk: *u8) -> u32 {\n }\n \n pub fn main() {\n+    use core::rand::Rng;\n     let fns = ~[\n         calllink01,\n         calllink02,\n         calllink08,\n         calllink09,\n         calllink10\n     ];\n-    let rng = rand::Rng();\n+    let rng = rand::rng();\n     for fns.each |f| {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;"}]}