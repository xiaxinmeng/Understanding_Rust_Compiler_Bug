{"sha": "757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1N2I3YWMyYWJkNjlkOTdiYTE5NmI3NmYwYmJmNzhjMzc3YWFlYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-21T08:14:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-21T08:14:17Z"}, "message": "Auto merge of #43986 - petrochenkov:pubcrate3, r=pnkfelix\n\nrustc: Remove some dead code\n\nExtracted from https://github.com/rust-lang/rust/pull/43192\n\nr? @eddyb", "tree": {"sha": "3c76b7c825867d596c18b62ecb9a54fbe45078b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c76b7c825867d596c18b62ecb9a54fbe45078b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "html_url": "https://github.com/rust-lang/rust/commit/757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06bf94a129931d6e4abadf779af40b95c143b3eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/06bf94a129931d6e4abadf779af40b95c143b3eb", "html_url": "https://github.com/rust-lang/rust/commit/06bf94a129931d6e4abadf779af40b95c143b3eb"}, {"sha": "de4dbe5789d1a4f11c50aa891f9c9cad13860370", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4dbe5789d1a4f11c50aa891f9c9cad13860370", "html_url": "https://github.com/rust-lang/rust/commit/de4dbe5789d1a4f11c50aa891f9c9cad13860370"}], "stats": {"total": 1373, "additions": 64, "deletions": 1309}, "files": [{"sha": "e17fce5a2ec0a276d5409af7ecea393a3edd257b", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(warnings)]\n+\n #![feature(rustc_private)]\n \n extern crate rustc;\n@@ -22,69 +24,58 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         name: \"alloc\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"oom\",\n         inputs: &[AllocatorTy::AllocErr],\n         output: AllocatorTy::Bang,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"dealloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"usable_size\",\n         inputs: &[AllocatorTy::LayoutRef],\n         output: AllocatorTy::UsizePair,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"realloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_zeroed\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_excess\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"realloc_excess\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"grow_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"shrink_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n ];\n \n pub struct AllocatorMethod {\n     pub name: &'static str,\n     pub inputs: &'static [AllocatorTy],\n     pub output: AllocatorTy,\n-    pub is_unsafe: bool,\n }\n \n pub enum AllocatorTy {"}, {"sha": "1b42fa03a4fb621e3957708aac4424e122c4c670", "filename": "src/librustc_back/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_back%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_back%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fdynamic_lib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -12,9 +12,8 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-use std::env;\n-use std::ffi::{CString, OsString};\n-use std::path::{Path, PathBuf};\n+use std::ffi::CString;\n+use std::path::Path;\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -43,24 +42,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Prepends a path to this process's search path for dynamic libraries\n-    pub fn prepend_search_path(path: &Path) {\n-        let mut search_path = DynamicLibrary::search_path();\n-        search_path.insert(0, path.to_path_buf());\n-        env::set_var(DynamicLibrary::envvar(), &DynamicLibrary::create_path(&search_path));\n-    }\n-\n-    /// From a slice of paths, create a new vector which is suitable to be an\n-    /// environment variable for this platforms dylib search path.\n-    pub fn create_path(path: &[PathBuf]) -> OsString {\n-        let mut newvar = OsString::new();\n-        for (i, path) in path.iter().enumerate() {\n-            if i > 0 { newvar.push(DynamicLibrary::separator()); }\n-            newvar.push(path);\n-        }\n-        return newvar;\n-    }\n-\n     /// Returns the environment variable for this process's dynamic library\n     /// search path\n     pub fn envvar() -> &'static str {\n@@ -75,19 +56,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    fn separator() -> &'static str {\n-        if cfg!(windows) { \";\" } else { \":\" }\n-    }\n-\n-    /// Returns the current search path for dynamic libraries being used by this\n-    /// process\n-    pub fn search_path() -> Vec<PathBuf> {\n-        match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => env::split_paths(&var).collect(),\n-            None => Vec::new(),\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on"}, {"sha": "8ffaddd7c29f2634cfd44c6a5fbbdc503b2409e6", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -95,15 +95,6 @@ impl TempDir {\n         self.path.as_ref().unwrap()\n     }\n \n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> io::Result<()> {\n-        self.cleanup_dir()\n-    }\n-\n     fn cleanup_dir(&mut self) -> io::Result<()> {\n         match self.path {\n             Some(ref p) => fs::remove_dir_all(p),"}, {"sha": "24c85429dabfaa015b14d9e0458d2ee03b30ece9", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -113,37 +113,6 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData<'tcx>,\n-                                      _move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                      move_pat: &hir::Pat,\n-                                      cmt: mc::cmt<'tcx>,\n-                                      mode: euv::MatchMode) {\n-    let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={:?}, mode={:?})\",\n-           move_pat.id, cmt, mode);\n-\n-    let opt_lp = opt_loan_path(&cmt);\n-    match opt_lp {\n-        Some(lp) => {\n-            match lp.kind {\n-                LpDowncast(ref base_lp, _) =>\n-                    move_data.add_variant_match(\n-                        tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n-                _ => bug!(\"should only call gather_match_variant \\\n-                           for cat_downcast cmt\"),\n-            }\n-        }\n-        None => {\n-            // We get None when input to match is non-path (e.g.\n-            // temporary result like a function call). Since no\n-            // loan-path is being matched, no need to record a\n-            // downcast.\n-            return;\n-        }\n-    }\n-}\n-\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       move_error_collector: &mut MoveErrorCollector<'tcx>,"}, {"sha": "00ebf5de44af8ad74b2b88e397ce0a2a8679b00b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -94,12 +94,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                matched_pat,\n                cmt,\n                mode);\n-\n-        if let Categorization::Downcast(..) = cmt.cat {\n-            gather_moves::gather_match_variant(\n-                self.bccx, &self.move_data, &mut self.move_error_collector,\n-                matched_pat, cmt, mode);\n-        }\n     }\n \n     fn consume_pat(&mut self,"}, {"sha": "500fae4aff856eb8b6aa0cb768a90ceb51efae96", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -714,15 +714,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    pub fn span_err(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_err(s, m);\n-    }\n-\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, s: S, m: &str)\n-                                              -> DiagnosticBuilder<'a> {\n-        self.tcx.sess.struct_span_err(s, m)\n-    }\n-\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n                                                          s: S,\n                                                          msg: &str,\n@@ -731,10 +722,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, s: S, msg: &str, code: &str) {\n-        self.tcx.sess.span_err_with_code(s, msg, code);\n-    }\n-\n     fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n         let span = err.span.clone();\n "}, {"sha": "217bd6e6ca1ca5294de0d21a7f1b16be99caaf02", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -53,10 +53,6 @@ pub struct MoveData<'tcx> {\n     /// kill move bits.\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n-    /// Enum variant matched within a pattern on some match arm, like\n-    /// `SomeStruct{ f: Variant1(x, y) } => ...`\n-    pub variant_matches: RefCell<Vec<VariantMatch>>,\n-\n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n }\n@@ -161,21 +157,6 @@ pub struct Assignment {\n     pub assignee_id: ast::NodeId,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct VariantMatch {\n-    /// downcast to the variant.\n-    pub path: MovePathIndex,\n-\n-    /// path being downcast to the variant.\n-    pub base_path: MovePathIndex,\n-\n-    /// id where variant's pattern occurs\n-    pub id: ast::NodeId,\n-\n-    /// says if variant established by move (and why), by copy, or by borrow.\n-    pub mode: euv::MatchMode\n-}\n-\n #[derive(Clone, Copy)]\n pub struct MoveDataFlowOperator;\n \n@@ -215,7 +196,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n-            variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n         }\n     }\n@@ -485,31 +465,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         }\n     }\n \n-    /// Adds a new record for a match of `base_lp`, downcast to\n-    /// variant `lp`, that occurs at location `pattern_id`.  (One\n-    /// should be able to recover the span info from the\n-    /// `pattern_id` and the hir_map, I think.)\n-    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             lp: Rc<LoanPath<'tcx>>,\n-                             pattern_id: ast::NodeId,\n-                             base_lp: Rc<LoanPath<'tcx>>,\n-                             mode: euv::MatchMode) {\n-        debug!(\"add_variant_match(lp={:?}, pattern_id={})\",\n-               lp, pattern_id);\n-\n-        let path_index = self.move_path(tcx, lp.clone());\n-        let base_path_index = self.move_path(tcx, base_lp.clone());\n-\n-        let variant_match = VariantMatch {\n-            path: path_index,\n-            base_path: base_path_index,\n-            id: pattern_id,\n-            mode,\n-        };\n-\n-        self.variant_matches.borrow_mut().push(variant_match);\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and"}, {"sha": "7a77939faa3e7a4b430b4205a7f22dba88fc8181", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -37,11 +37,10 @@ extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod borrowck;\n "}, {"sha": "3483752d4ff01854731ae29423e3867f429595db", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -41,7 +41,7 @@ extern crate syntax_pos;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod eval;\n mod _match;"}, {"sha": "b67048939e43eb1592bc6c378aeeb02634b207a2", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -37,13 +37,6 @@ impl ConstFloat {\n         self.ty.ty_to_string()\n     }\n \n-    pub fn is_nan(&self) -> bool {\n-        match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n-        }\n-    }\n-\n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n         match (self.ty, rhs.ty) {"}, {"sha": "6b8bf8df0d33f0832e24aeefc673c946c1276982", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -24,7 +24,7 @@ use std::mem;\n use std::slice;\n \n #[repr(C)]\n-pub struct Blake2bCtx {\n+struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],\n     t: [u64; 2],"}, {"sha": "90670517f5967e5b9d3d0e27a94b1c65e49e1c5f", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -134,56 +134,10 @@ impl<Node: Idx> Dominators<Node> {\n         self.dominators(node).any(|n| n == dom)\n     }\n \n-    pub fn mutual_dominator_node(&self, node1: Node, node2: Node) -> Node {\n-        assert!(self.is_reachable(node1),\n-                \"node {:?} is not reachable\",\n-                node1);\n-        assert!(self.is_reachable(node2),\n-                \"node {:?} is not reachable\",\n-                node2);\n-        intersect::<Node>(&self.post_order_rank,\n-                          &self.immediate_dominators,\n-                          node1,\n-                          node2)\n-    }\n-\n-    pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>\n-        where I: IntoIterator<Item = Node>\n-    {\n-        let mut iter = iter.into_iter();\n-        iter.next()\n-            .map(|dom| iter.fold(dom, |dom, node| self.mutual_dominator_node(dom, node)))\n-    }\n-\n-    pub fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n+    #[cfg(test)]\n+    fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n         &self.immediate_dominators\n     }\n-\n-    pub fn dominator_tree(&self) -> DominatorTree<Node> {\n-        let elem: Vec<Node> = Vec::new();\n-        let mut children: IndexVec<Node, Vec<Node>> =\n-            IndexVec::from_elem_n(elem, self.immediate_dominators.len());\n-        let mut root = None;\n-        for (index, immed_dom) in self.immediate_dominators.iter().enumerate() {\n-            let node = Node::new(index);\n-            match *immed_dom {\n-                None => {\n-                    // node not reachable\n-                }\n-                Some(immed_dom) => {\n-                    if node == immed_dom {\n-                        root = Some(node);\n-                    } else {\n-                        children[immed_dom].push(node);\n-                    }\n-                }\n-            }\n-        }\n-        DominatorTree {\n-            root: root.unwrap(),\n-            children,\n-        }\n-    }\n }\n \n pub struct Iter<'dom, Node: Idx + 'dom> {\n@@ -215,38 +169,9 @@ pub struct DominatorTree<N: Idx> {\n }\n \n impl<Node: Idx> DominatorTree<Node> {\n-    pub fn root(&self) -> Node {\n-        self.root\n-    }\n-\n     pub fn children(&self, node: Node) -> &[Node] {\n         &self.children[node]\n     }\n-\n-    pub fn iter_children_of(&self, node: Node) -> IterChildrenOf<Node> {\n-        IterChildrenOf {\n-            tree: self,\n-            stack: vec![node],\n-        }\n-    }\n-}\n-\n-pub struct IterChildrenOf<'iter, Node: Idx + 'iter> {\n-    tree: &'iter DominatorTree<Node>,\n-    stack: Vec<Node>,\n-}\n-\n-impl<'iter, Node: Idx> Iterator for IterChildrenOf<'iter, Node> {\n-    type Item = Node;\n-\n-    fn next(&mut self) -> Option<Node> {\n-        if let Some(node) = self.stack.pop() {\n-            self.stack.extend(self.tree.children(node));\n-            Some(node)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n impl<Node: Idx> fmt::Debug for DominatorTree<Node> {"}, {"sha": "2d70b4063426d6f983707cc6e2a4cc092b5f7888", "filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -47,22 +47,6 @@ fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n     result.push(node);\n }\n \n-pub fn pre_order_walk<G: ControlFlowGraph>(graph: &G,\n-                                           node: G::Node,\n-                                           result: &mut Vec<G::Node>,\n-                                           visited: &mut IndexVec<G::Node, bool>) {\n-    if visited[node] {\n-        return;\n-    }\n-    visited[node] = true;\n-\n-    result.push(node);\n-\n-    for successor in graph.successors(node) {\n-        pre_order_walk(graph, successor, result, visited);\n-    }\n-}\n-\n pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n     let mut vec = post_order_from(graph, start_node);\n     vec.reverse();"}, {"sha": "100881ddfdd7706f25fc75a11af4fedcc5d09d4b", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::super::test::TestGraph;\n-use super::super::transpose::TransposedGraph;\n \n use super::*;\n \n@@ -20,22 +19,3 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n-\n-\n-#[test]\n-fn rev_post_order_inner_loop() {\n-    // 0 -> 1 ->     2     -> 3 -> 5\n-    //      ^     ^    v      |\n-    //      |     6 <- 4      |\n-    //      +-----------------+\n-    let graph = TestGraph::new(0,\n-                               &[(0, 1), (1, 2), (2, 3), (3, 5), (3, 1), (2, 4), (4, 6), (6, 2)]);\n-\n-    let rev_graph = TransposedGraph::new(&graph);\n-\n-    let result = post_order_from_to(&rev_graph, 6, Some(2));\n-    assert_eq!(result, vec![4, 6]);\n-\n-    let result = post_order_from_to(&rev_graph, 3, Some(1));\n-    assert_eq!(result, vec![4, 6, 2, 3]);\n-}"}, {"sha": "7bf776675c6a0ad4f3482538b8457798e03a22d6", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::indexed_vec::Idx;\n-pub use std::slice::Iter;\n \n pub mod dominators;\n pub mod iterate;\n-pub mod reachable;\n mod reference;\n-pub mod transpose;\n \n #[cfg(test)]\n mod test;"}, {"sha": "24210ebb95d3d14f97724a1cf197014ee9c43244", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=06bf94a129931d6e4abadf779af40b95c143b3eb", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Compute reachability using a simple dataflow propagation.\n-//! Store end-result in a big NxN bit matrix.\n-\n-use super::ControlFlowGraph;\n-use super::super::bitvec::BitVector;\n-use super::iterate::reverse_post_order;\n-use super::super::indexed_vec::{IndexVec, Idx};\n-\n-#[cfg(test)]\n-mod test;\n-\n-pub fn reachable<G: ControlFlowGraph>(graph: &G) -> Reachability<G::Node> {\n-    let reverse_post_order = reverse_post_order(graph, graph.start_node());\n-    reachable_given_rpo(graph, &reverse_post_order)\n-}\n-\n-pub fn reachable_given_rpo<G: ControlFlowGraph>(graph: &G,\n-                                                reverse_post_order: &[G::Node])\n-                                                -> Reachability<G::Node> {\n-    let mut reachability = Reachability::new(graph);\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-        for &node in reverse_post_order.iter().rev() {\n-            // every node can reach itself\n-            changed |= reachability.bits[node].insert(node.index());\n-\n-            // and every pred can reach everything node can reach\n-            for pred in graph.predecessors(node) {\n-                let nodes_bits = reachability.bits[node].clone();\n-                changed |= reachability.bits[pred].insert_all(&nodes_bits);\n-            }\n-        }\n-    }\n-    reachability\n-}\n-\n-pub struct Reachability<Node: Idx> {\n-    bits: IndexVec<Node, BitVector>,\n-}\n-\n-impl<Node: Idx> Reachability<Node> {\n-    fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n-        let num_nodes = graph.num_nodes();\n-        Reachability { bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes) }\n-    }\n-\n-    pub fn can_reach(&self, source: Node, target: Node) -> bool {\n-        let bit: usize = target.index();\n-        self.bits[source].contains(bit)\n-    }\n-}"}, {"sha": "ef45deeaafc78f30268c29af743f4509de58125a", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=06bf94a129931d6e4abadf779af40b95c143b3eb", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::super::test::TestGraph;\n-\n-use super::*;\n-\n-#[test]\n-fn test1() {\n-    // 0 -> 1 -> 2 -> 3\n-    //      ^    v\n-    //      6 <- 4 -> 5\n-    let graph = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (6, 1)]);\n-    let reachable = reachable(&graph);\n-    assert!((0..6).all(|i| reachable.can_reach(0, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(1, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(2, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(4, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(6, i)));\n-    assert!(reachable.can_reach(3, 3));\n-    assert!(!reachable.can_reach(3, 5));\n-    assert!(!reachable.can_reach(5, 3));\n-}\n-\n-/// use bigger indices to cross between words in the bit set\n-#[test]\n-fn test2() {\n-    // 30 -> 31 -> 32 -> 33\n-    //       ^      v\n-    //       36 <- 34 -> 35\n-    let graph = TestGraph::new(30,\n-                               &[(30, 31), (31, 32), (32, 33), (32, 34), (34, 35), (34, 36),\n-                                 (36, 31)]);\n-    let reachable = reachable(&graph);\n-    assert!((30..36).all(|i| reachable.can_reach(30, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(31, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(32, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(34, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(36, i)));\n-    assert!(reachable.can_reach(33, 33));\n-    assert!(!reachable.can_reach(33, 35));\n-    assert!(!reachable.can_reach(35, 33));\n-}"}, {"sha": "163d65c089c33c1ff698b736c44969b06d71302f", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=06bf94a129931d6e4abadf779af40b95c143b3eb", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::*;\n-\n-pub struct TransposedGraph<G: ControlFlowGraph> {\n-    base_graph: G,\n-    start_node: G::Node,\n-}\n-\n-impl<G: ControlFlowGraph> TransposedGraph<G> {\n-    pub fn new(base_graph: G) -> Self {\n-        let start_node = base_graph.start_node();\n-        Self::with_start(base_graph, start_node)\n-    }\n-\n-    pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n-        TransposedGraph {\n-            base_graph,\n-            start_node,\n-        }\n-    }\n-}\n-\n-impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n-    type Node = G::Node;\n-\n-    fn num_nodes(&self) -> usize {\n-        self.base_graph.num_nodes()\n-    }\n-\n-    fn start_node(&self) -> Self::Node {\n-        self.start_node\n-    }\n-\n-    fn predecessors<'graph>(&'graph self,\n-                            node: Self::Node)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter {\n-        self.base_graph.successors(node)\n-    }\n-\n-    fn successors<'graph>(&'graph self,\n-                          node: Self::Node)\n-                          -> <Self as GraphSuccessors<'graph>>::Iter {\n-        self.base_graph.predecessors(node)\n-    }\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphPredecessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphSuccessors<'graph>>::Iter;\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphSuccessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphPredecessors<'graph>>::Iter;\n-}"}, {"sha": "50fd1d802b7ffe8e44ee6b8b148fb9d35f638e1c", "filename": "src/librustc_data_structures/fmt_wrap.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffmt_wrap.rs?ref=06bf94a129931d6e4abadf779af40b95c143b3eb", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-\n-// Provide some more formatting options for some data types (at the moment\n-// that's just `{:x}` for slices of u8).\n-\n-pub struct FmtWrap<T>(pub T);\n-\n-impl<'a> fmt::LowerHex for FmtWrap<&'a [u8]> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        for byte in self.0.iter() {\n-            try!(write!(formatter, \"{:02x}\", byte));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_lower_hex() {\n-    let bytes: &[u8] = &[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n-    assert_eq!(\"0123456789abcdef\", &format!(\"{:x}\", FmtWrap(bytes)));\n-}"}, {"sha": "5bf25437763cc6162ff69d26a5df51e90b2a00e2", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -107,9 +107,3 @@ impl Hasher for FxHasher {\n         self.hash as u64\n     }\n }\n-\n-pub fn hash<T: Hash>(v: &T) -> u64 {\n-    let mut state = FxHasher::default();\n-    v.hash(&mut state);\n-    state.finish()\n-}"}, {"sha": "a5f83ce05f5e5108e84ce29a08ee7668cb18601f", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -106,13 +106,6 @@ impl NodeIndex {\n     }\n }\n \n-impl EdgeIndex {\n-    /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<N: Debug, E: Debug> Graph<N, E> {\n     pub fn new() -> Graph<N, E> {\n         Graph {\n@@ -201,34 +194,10 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         return idx;\n     }\n \n-    pub fn mut_edge_data(&mut self, idx: EdgeIndex) -> &mut E {\n-        &mut self.edges[idx.0].data\n-    }\n-\n-    pub fn edge_data(&self, idx: EdgeIndex) -> &E {\n-        &self.edges[idx.0].data\n-    }\n-\n     pub fn edge(&self, idx: EdgeIndex) -> &Edge<E> {\n         &self.edges[idx.0]\n     }\n \n-    pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the index of the first edge adjacent to `node`.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.nodes[node.0].first_edge[dir.repr]\n-    }\n-\n-    pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the next edge in a given direction.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.edges[edge.0].next_edge[dir.repr]\n-    }\n-\n     // # Iterating over nodes, edges\n \n     pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n@@ -282,25 +251,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    /// A common use for graphs in our compiler is to perform\n-    /// fixed-point iteration. In this case, each edge represents a\n-    /// constraint, and the nodes themselves are associated with\n-    /// variables or other bitsets. This method facilitates such a\n-    /// computation.\n-    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n-        where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n-    {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            for (edge_index, edge) in self.enumerated_edges() {\n-                changed |= op(iteration, edge_index, edge);\n-            }\n-        }\n-    }\n-\n     pub fn depth_traverse<'a>(&'a self,\n                               start: NodeIndex,\n                               direction: Direction)\n@@ -343,35 +293,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         assert_eq!(result.len(), self.len_nodes());\n         result\n     }\n-\n-    /// Whether or not a node can be reached from itself.\n-    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n-        // This is similar to depth traversal below, but we\n-        // can't use that, because depth traversal doesn't show\n-        // the starting node a second time.\n-        let mut visited = BitVector::new(self.len_nodes());\n-        let mut stack = vec![starting_node_index];\n-\n-        while let Some(current_node_index) = stack.pop() {\n-            visited.insert(current_node_index.0);\n-\n-            // Directionality doesn't change the answer,\n-            // so just use outgoing edges.\n-            for (_, edge) in self.outgoing_edges(current_node_index) {\n-                let target_node_index = edge.target();\n-\n-                if target_node_index == starting_node_index {\n-                    return true;\n-                }\n-\n-                if !visited.contains(target_node_index.0) {\n-                    stack.push(target_node_index);\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n }\n \n // # Iterators\n@@ -479,16 +400,6 @@ pub struct DepthFirstTraversal<'g, N, E>\n }\n \n impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n-    pub fn new(graph: &'g Graph<N, E>, direction: Direction) -> Self {\n-        let visited = BitVector::new(graph.len_nodes());\n-        DepthFirstTraversal {\n-            graph,\n-            stack: vec![],\n-            visited,\n-            direction,\n-        }\n-    }\n-\n     pub fn with_start_node(graph: &'g Graph<N, E>,\n                            start_node: NodeIndex,\n                            direction: Direction)\n@@ -503,13 +414,6 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n         }\n     }\n \n-    pub fn reset(&mut self, start_node: NodeIndex) {\n-        self.stack.truncate(0);\n-        self.stack.push(start_node);\n-        self.visited.clear();\n-        self.visited.insert(start_node.node_id());\n-    }\n-\n     fn visit(&mut self, node: NodeIndex) {\n         if self.visited.insert(node.node_id()) {\n             self.stack.push(node);\n@@ -532,19 +436,6 @@ impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     }\n }\n \n-pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F)\n-    where F: FnMut(EdgeIndex) -> bool\n-{\n-    let mut i = 0;\n-    let n = max_edge_index.0;\n-    while i < n {\n-        if !f(EdgeIndex(i)) {\n-            return;\n-        }\n-        i += 1;\n-    }\n-}\n-\n impl<E> Edge<E> {\n     pub fn source(&self) -> NodeIndex {\n         self.source"}, {"sha": "007704357af4fa8c1d6ec4452091f8f53d0bc155", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -43,29 +43,6 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n-fn create_graph_with_cycle() -> TestGraph {\n-    let mut graph = Graph::new();\n-\n-    // Create a graph with a cycle.\n-    //\n-    //    A --> B <-- +\n-    //          |     |\n-    //          v     |\n-    //          C --> D\n-\n-    let a = graph.add_node(\"A\");\n-    let b = graph.add_node(\"B\");\n-    let c = graph.add_node(\"C\");\n-    let d = graph.add_node(\"D\");\n-\n-    graph.add_edge(a, b, \"AB\");\n-    graph.add_edge(b, c, \"BC\");\n-    graph.add_edge(c, d, \"CD\");\n-    graph.add_edge(d, b, \"DB\");\n-\n-    return graph;\n-}\n-\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -82,7 +59,6 @@ fn each_edge() {\n     let graph = create_graph();\n     let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n     graph.each_edge(|idx, edge| {\n-        assert_eq!(&expected[idx.0], graph.edge_data(idx));\n         assert_eq!(expected[idx.0], edge.data);\n         true\n     });\n@@ -97,7 +73,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.incoming_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_incoming.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -117,7 +92,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.outgoing_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_outgoing.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -163,58 +137,3 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n-\n-#[test]\n-fn is_node_cyclic_a() {\n-    let graph = create_graph_with_cycle();\n-    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n-}\n-\n-#[test]\n-fn is_node_cyclic_b() {\n-    let graph = create_graph_with_cycle();\n-    assert!(graph.is_node_cyclic(NodeIndex(1)));\n-}\n-\n-#[test]\n-fn nodes_in_postorder() {\n-    let expected = vec![\n-        (\"A\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"B\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"C\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"D\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"E\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"F\", vec![\"C\", \"E\", \"D\", \"B\", \"F\", \"A\"])\n-    ];\n-\n-    let graph = create_graph();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-\n-    let expected = vec![\n-        (\"A\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"B\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"C\", vec![\"B\", \"D\", \"C\", \"A\"]),\n-        (\"D\", vec![\"C\", \"B\", \"D\", \"A\"]),\n-    ];\n-\n-    let graph = create_graph_with_cycle();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-}"}, {"sha": "de44509ef2fd81c17b0543acf39d2af91cdfa620", "filename": "src/librustc_data_structures/ivar.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bf94a129931d6e4abadf779af40b95c143b3eb/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=06bf94a129931d6e4abadf779af40b95c143b3eb", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-use std::cell::Cell;\n-\n-/// A write-once variable. When constructed, it is empty, and\n-/// can only be set once.\n-///\n-/// Ivars ensure that data that can only be initialized once. A full\n-/// implementation is used for concurrency and blocks on a read of an\n-/// unfulfilled value. This implementation is more minimal and panics\n-/// if you attempt to read the value before it has been set. It is also\n-/// not `Sync`, but may be extended in the future to be usable as a true\n-/// concurrency type.\n-///\n-/// The `T: Copy` bound is not strictly needed, but it is required by\n-/// Cell (so removing it would require using UnsafeCell), and it\n-/// suffices for the current purposes.\n-#[derive(PartialEq)]\n-pub struct Ivar<T: Copy> {\n-    data: Cell<Option<T>>,\n-}\n-\n-impl<T: Copy> Ivar<T> {\n-    pub fn new() -> Ivar<T> {\n-        Ivar { data: Cell::new(None) }\n-    }\n-\n-    pub fn get(&self) -> Option<T> {\n-        self.data.get()\n-    }\n-\n-    pub fn fulfill(&self, value: T) {\n-        assert!(self.data.get().is_none(), \"Value already set!\");\n-        self.data.set(Some(value));\n-    }\n-\n-    pub fn is_fulfilled(&self) -> bool {\n-        self.data.get().is_some()\n-    }\n-\n-    pub fn unwrap(&self) -> T {\n-        self.get().unwrap()\n-    }\n-}\n-\n-impl<T: Copy + fmt::Debug> fmt::Debug for Ivar<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n-            Some(val) => write!(f, \"Ivar({:?})\", val),\n-            None => f.write_str(\"Ivar(<unfulfilled>)\"),\n-        }\n-    }\n-}\n-\n-impl<T: Copy> Clone for Ivar<T> {\n-    fn clone(&self) -> Ivar<T> {\n-        match self.get() {\n-            Some(val) => Ivar { data: Cell::new(Some(val)) },\n-            None => Ivar::new(),\n-        }\n-    }\n-}"}, {"sha": "54eed6dc92a77442c388fc1651aa812076311020", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -52,11 +52,9 @@ pub mod accumulate_vec;\n pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n-pub mod blake2b;\n pub mod bitvec;\n-pub mod fmt_wrap;\n+pub mod blake2b;\n pub mod graph;\n-pub mod ivar;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;"}, {"sha": "02cae52166ac3a4a009a48e72b2a4f586defa8d4", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -57,11 +57,6 @@ pub trait ObligationProcessor {\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n-struct SnapshotData {\n-    node_len: usize,\n-    cache_list_len: usize,\n-}\n-\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -83,14 +78,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n-    snapshots: Vec<SnapshotData>,\n     scratch: Option<Vec<usize>>,\n }\n \n-pub struct Snapshot {\n-    len: usize,\n-}\n-\n #[derive(Debug)]\n struct Node<O> {\n     obligation: O,\n@@ -166,7 +156,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n-            snapshots: vec![],\n             done_cache: FxHashSet(),\n             waiting_cache: FxHashMap(),\n             cache_list: vec![],\n@@ -180,39 +169,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.nodes.len()\n     }\n \n-    pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(SnapshotData {\n-            node_len: self.nodes.len(),\n-            cache_list_len: self.cache_list.len()\n-        });\n-        Snapshot { len: self.snapshots.len() }\n-    }\n-\n-    pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-        assert!(self.nodes.len() >= info.node_len);\n-        assert!(self.cache_list.len() >= info.cache_list_len);\n-    }\n-\n-    pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n-        // Check that we are obeying stack discipline.\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-\n-        for entry in &self.cache_list[info.cache_list_len..] {\n-            self.done_cache.remove(entry);\n-            self.waiting_cache.remove(entry);\n-        }\n-\n-        self.nodes.truncate(info.node_len);\n-        self.cache_list.truncate(info.cache_list_len);\n-    }\n-\n-    pub fn in_snapshot(&self) -> bool {\n-        !self.snapshots.is_empty()\n-    }\n-\n     /// Registers an obligation\n     ///\n     /// This CAN be done in a snapshot\n@@ -262,7 +218,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     ///\n     /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n-        assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             if let NodeState::Pending = self.nodes[index].state.get() {\n@@ -297,7 +252,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n-        assert!(!self.in_snapshot()); // cannot unroll this action\n \n         let mut errors = vec![];\n         let mut stalled = true;\n@@ -528,8 +482,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// on these nodes may be present. This is done by e.g. `process_cycles`.\n     #[inline(never)]\n     fn compress(&mut self) -> Vec<O> {\n-        assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-\n         let nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n         node_rewrites.extend(0..nodes_len);"}, {"sha": "7853bf9478ab8157e9a99ea679349ea171114751", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -275,7 +275,8 @@ impl<'tcx, K: UnifyKey> UnificationTable<K>\n         self.get(id).value\n     }\n \n-    pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n+    #[cfg(test)]\n+    fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n         self.find(a_id) == self.find(b_id)\n     }\n }"}, {"sha": "64f61b65323c05b4f325a14d1e9eeaf502fd0ecc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -102,7 +102,7 @@ use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n-pub mod test;\n+mod test;\n \n pub mod driver;\n pub mod pretty;\n@@ -859,17 +859,17 @@ impl RustcDefaultCalls {\n }\n \n /// Returns a version string such as \"0.12.0-dev\".\n-pub fn release_str() -> Option<&'static str> {\n+fn release_str() -> Option<&'static str> {\n     option_env!(\"CFG_RELEASE\")\n }\n \n /// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n-pub fn commit_hash_str() -> Option<&'static str> {\n+fn commit_hash_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_HASH\")\n }\n \n /// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n-pub fn commit_date_str() -> Option<&'static str> {\n+fn commit_date_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_DATE\")\n }\n "}, {"sha": "0f063542383dce0eeaf9f9ed152b8e9b6b51b131", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -105,10 +105,6 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n     /// Add a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n@@ -278,18 +274,10 @@ impl Diagnostic {\n         self.message.iter().map(|i| i.0.to_owned()).collect::<String>()\n     }\n \n-    pub fn set_message(&mut self, message: &str) {\n-        self.message = vec![(message.to_owned(), Style::NoStyle)];\n-    }\n-\n     pub fn styled_message(&self) -> &Vec<(String, Style)> {\n         &self.message\n     }\n \n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n     /// Used by a lint. Copies over all details *but* the \"main\n     /// message\".\n     pub fn copy_details_not_message(&mut self, from: &Diagnostic) {"}, {"sha": "8d7ce4eb4f6d31edc81f9124a2efc39e75ce3da8", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -183,13 +183,6 @@ impl<'a> DiagnosticBuilder<'a> {\n             diagnostic: Diagnostic::new_with_code(level, code, message)\n         }\n     }\n-\n-    pub fn into_diagnostic(mut self) -> Diagnostic {\n-        // annoyingly, the Drop impl means we can't actually move\n-        let result = self.diagnostic.clone();\n-        self.cancel();\n-        result\n-    }\n }\n \n impl<'a> Debug for DiagnosticBuilder<'a> {"}, {"sha": "12b5ccf483762d6e1f9b76c5ec96d59243b365b5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -38,8 +38,8 @@ use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n \n-pub mod diagnostic;\n-pub mod diagnostic_builder;\n+mod diagnostic;\n+mod diagnostic_builder;\n pub mod emitter;\n mod snippet;\n pub mod registry;\n@@ -111,7 +111,7 @@ impl CodeSuggestion {\n     }\n \n     /// Returns the number of substitutions\n-    pub fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n+    fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n         self.substitution_parts.iter().map(|sub| sub.span)\n     }\n \n@@ -262,7 +262,7 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString, StringPart};\n+pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString};\n pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n@@ -491,7 +491,7 @@ impl Handler {\n         self.bug(&format!(\"unimplemented {}\", msg));\n     }\n \n-    pub fn bump_err_count(&self) {\n+    fn bump_err_count(&self) {\n         self.panic_if_treat_err_as_bug();\n         self.err_count.set(self.err_count.get() + 1);\n     }\n@@ -571,7 +571,7 @@ impl fmt::Display for Level {\n }\n \n impl Level {\n-    pub fn color(self) -> term::color::Color {\n+    fn color(self) -> term::color::Color {\n         match self {\n             Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n             Warning => {\n@@ -598,12 +598,3 @@ impl Level {\n         }\n     }\n }\n-\n-pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T\n-    where M: FnOnce() -> String\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.bug(&msg()),\n-    }\n-}"}, {"sha": "94400890c56411449c999af58b676de2046b6846", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -62,10 +62,6 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn get(&self, k: &DepNode) -> Option<&Fingerprint> {\n-        self.hashes.get(k)\n-    }\n-\n     pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n         assert!(self.hashes.insert(k, v).is_none());\n     }"}, {"sha": "c68153140d97ce171a5404a75b857c8bc599422d", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -44,4 +44,3 @@ pub use persist::save_trans_partition;\n pub use persist::save_work_products;\n pub use persist::in_incr_comp_dir;\n pub use persist::finalize_session_directory;\n-pub use persist::delete_workproduct_files;"}, {"sha": "5c1582daa78fa07119caa53219831e699ed60e88", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -28,4 +28,3 @@ pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;\n-pub use self::work_product::delete_workproduct_files;"}, {"sha": "755370b64659dfee03f2c4d1b3915211a9a5f189", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -45,10 +45,10 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n-pub use rustc::lint;\n-pub use rustc::middle;\n-pub use rustc::session;\n-pub use rustc::util;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::util;\n \n use session::Session;\n use lint::LintId;"}, {"sha": "5f12f561faf45086eeb2572ae03b174252952e6a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -38,9 +38,7 @@ pub use self::TypeKind::*;\n pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n use std::str::FromStr;\n@@ -51,7 +49,7 @@ use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n-pub mod ffi;\n+mod ffi;\n \n pub use ffi::*;\n \n@@ -120,7 +118,7 @@ impl FromStr for ArchiveKind {\n \n #[allow(missing_copy_implementations)]\n pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n /// Appending to a Rust string -- used by RawRustStringOstream.\n@@ -199,8 +197,8 @@ impl Attribute {\n \n // Memory-managed interface to target data.\n \n-pub struct TargetData {\n-    pub lltd: TargetDataRef,\n+struct TargetData {\n+    lltd: TargetDataRef,\n }\n \n impl Drop for TargetData {\n@@ -211,7 +209,7 @@ impl Drop for TargetData {\n     }\n }\n \n-pub fn mk_target_data(string_rep: &str) -> TargetData {\n+fn mk_target_data(string_rep: &str) -> TargetData {\n     let string_rep = CString::new(string_rep).unwrap();\n     TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n }\n@@ -272,7 +270,7 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n-pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n+fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     unsafe {\n         let num_params = LLVMCountParams(llfn);\n         let mut params = Vec::with_capacity(num_params as usize);"}, {"sha": "0ed8ab2bc55968f50abb8f0a24bebb210614391e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -32,7 +32,7 @@ use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n+pub use rustc::middle::cstore::{CrateSource, LibSource};\n \n pub use cstore_impl::{provide, provide_local};\n \n@@ -142,14 +142,6 @@ impl CStore {\n         }\n     }\n \n-    pub fn reset(&self) {\n-        self.metas.borrow_mut().clear();\n-        self.extern_mod_crate_map.borrow_mut().clear();\n-        self.used_libraries.borrow_mut().clear();\n-        self.used_link_args.borrow_mut().clear();\n-        self.statically_included_foreign_items.borrow_mut().clear();\n-    }\n-\n     pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);"}, {"sha": "69fbc9354610d9aabc1d94334069ab86e5249abe", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -100,32 +100,6 @@ impl<'tcx> LazySeq<Index> {\n             Some(Lazy::with_position(position as usize))\n         }\n     }\n-\n-    pub fn iter_enumerated<'a>(&self,\n-                               bytes: &'a [u8])\n-                               -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n-        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        let lo_count = u32::from_le(words[0].get()) as usize;\n-        let lo = &words[1 .. lo_count + 1];\n-        let hi = &words[1 + lo_count ..];\n-\n-        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(pos)))\n-            }\n-        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n-                                    Lazy::with_position(pos)))\n-            }\n-        }))\n-    }\n }\n \n #[repr(packed)]"}, {"sha": "8fd87ae88a88450c7f0bc915a61ba85685f930b4", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -47,8 +47,6 @@ extern crate rustc_data_structures;\n \n mod diagnostics;\n \n-pub use rustc::middle;\n-\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "19f7cb0ee238a72b82e501a0fb7b7462479e3989", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -306,10 +306,6 @@ impl<'a> Context<'a> {\n         self.find_library_crate()\n     }\n \n-    pub fn load_library_crate(&mut self) -> Library {\n-        self.find_library_crate().unwrap_or_else(|| self.report_errs())\n-    }\n-\n     pub fn report_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),"}, {"sha": "a4421b216c311b4d50134c8e4885123d708216e7", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 160, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -14,16 +14,13 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n-use super::move_paths::LookupResult;\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex};\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -204,40 +201,6 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error message may need to report.\n-#[allow(dead_code)]\n-pub struct MovingOutStatements<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n-}\n-\n-impl<'a, 'tcx: 'a> MovingOutStatements<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n-               -> Self\n-    {\n-        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n-    }\n-}\n-\n-impl<'a, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'tcx> {\n-    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n-}\n-\n impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n@@ -432,121 +395,6 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n-    type Idx = MoveOutIndex;\n-    fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.move_data().moves.len()\n-    }\n-\n-    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n-        // no move-statements have been executed prior to function\n-        // execution, so this method has no effect on `_sets`.\n-    }\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<MoveOutIndex>,\n-                        location: Location) {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[location.block].statements[location.statement_index];\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n-\n-        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               stmt, location, &loc_map[location]);\n-        for move_index in &loc_map[location] {\n-            // Every path deinitialized by a *particular move*\n-            // has corresponding bit, \"gen'ed\" (i.e. set)\n-            // here, in dataflow vector\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-        let bits_per_block = self.bits_per_block();\n-        match stmt.kind {\n-            mir::StatementKind::SetDiscriminant { .. } => {\n-                span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n-            }\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                // assigning into this `lvalue` kills all\n-                // MoveOuts from it, and *also* all MoveOuts\n-                // for children and associated fragment sets.\n-                match rvalue.initialization_state() {\n-                    mir::tcx::RvalueInitializationState::Shallow => {\n-                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n-                             for moi in &path_map[mpi] {\n-                                 assert!(moi.index() < bits_per_block);\n-                                 sets.kill_set.add(&moi);\n-                             }\n-                        }\n-                    }\n-                    mir::tcx::RvalueInitializationState::Deep => {\n-                        on_lookup_result_bits(tcx,\n-                                              mir,\n-                                              move_data,\n-                                              rev_lookup.find(lvalue),\n-                                              |mpi| for moi in &path_map[mpi] {\n-                                                  assert!(moi.index() < bits_per_block);\n-                                                  sets.kill_set.add(&moi);\n-                                              });\n-                    }\n-                }\n-            }\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n-            mir::StatementKind::Nop => {}\n-        }\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<MoveOutIndex>,\n-                         location: Location)\n-    {\n-        let (mir, move_data) = (self.mir, self.move_data());\n-        let term = mir[location.block].terminator();\n-        let loc_map = &move_data.loc_map;\n-        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, location, &loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[location] {\n-            assert!(move_index.index() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n-        let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n-\n-        let path_map = &move_data.path_map;\n-        on_lookup_result_bits(self.tcx,\n-                              self.mir,\n-                              move_data,\n-                              move_data.rev_lookup.find(dest_lval),\n-                              |mpi| for moi in &path_map[mpi] {\n-                                  assert!(moi.index() < bits_per_block);\n-                                  in_out.remove(&moi);\n-                              });\n-    }\n-}\n-\n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.index());\n-    assert!(retval);\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n@@ -578,13 +426,6 @@ impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no loans in scope by default\n-    }\n-}\n-\n impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {"}, {"sha": "237795491b18665b674a8df7cd0eadccc7743441", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -25,7 +25,7 @@ use std::path::PathBuf;\n use std::usize;\n \n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n+pub use self::impls::{DefinitelyInitializedLvals};\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -364,8 +364,6 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation\n         DataflowResults(self.flow_state)\n     }\n \n-    pub fn flow_state(&self) -> &DataflowState<O> { &self.flow_state }\n-\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n "}, {"sha": "6b1fe0d2ca9f6b504f2bcceeac11ba6dc2d0a746", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -43,10 +43,10 @@ extern crate rustc_const_math;\n extern crate rustc_const_eval;\n extern crate core; // for NonZero\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n mod build;\n-pub mod dataflow;\n+mod dataflow;\n mod hair;\n mod shim;\n pub mod transform;"}, {"sha": "46e65d355a15baa5c692c304a066b1aa4c6d1962", "filename": "src/librustc_mir/transform/borrow_check.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -27,7 +27,6 @@ use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{MovingOutStatements};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -80,9 +79,6 @@ fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir\n         let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                                        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n                                        |bd, i| &bd.move_data().move_paths[i]);\n-        let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                         MovingOutStatements::new(tcx, mir, &mdpe),\n-                                         |bd, i| &bd.move_data().moves[i]);\n \n         let mut mbcx = MirBorrowckCtxt {\n             tcx: tcx,\n@@ -95,8 +91,7 @@ fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir\n \n         let mut state = InProgress::new(flow_borrows,\n                                         flow_inits,\n-                                        flow_uninits,\n-                                        flow_move_outs);\n+                                        flow_uninits);\n \n         mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n     });\n@@ -119,7 +114,6 @@ pub struct InProgress<'b, 'tcx: 'b> {\n     borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n     inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n     uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n-    move_outs: FlowInProgress<MovingOutStatements<'b, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -511,10 +505,6 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n             if maybe_uninits.curr_state.contains(&mpi) {\n                 // find and report move(s) that could cause this to be uninitialized\n-\n-                // FIXME: for each move in flow_state.move_outs ...\n-                &flow_state.move_outs;\n-\n                 self.report_use_of_moved(context, lvalue_span);\n             } else {\n                 // sanity check: initialized on *some* path, right?\n@@ -1129,13 +1119,12 @@ impl ContextKind {\n impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n                       inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>,\n-                      move_outs: DataflowResults<MovingOutStatements<'b, 'tcx>>) -> Self {\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+                      -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n             inits: FlowInProgress::new(inits),\n             uninits: FlowInProgress::new(uninits),\n-            move_outs: FlowInProgress::new(move_outs),\n         }\n     }\n "}, {"sha": "72092042f8d39a138cf4a1d11e4b6b13a6262e2f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -740,12 +740,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n pub struct TypeckMir;\n \n-impl TypeckMir {\n-    pub fn new() -> Self {\n-        TypeckMir\n-    }\n-}\n-\n impl MirPass for TypeckMir {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "8263e149d84e74fa1b4e5c7459fd2158d10d4990", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -50,10 +50,6 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n         &self.info[local]\n     }\n \n-    pub fn local_info_mut(&mut self, local: Local) -> &mut Info<'tcx> {\n-        &mut self.info[local]\n-    }\n-\n     fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n                                where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n                                                       LvalueContext<'tcx>,"}, {"sha": "6c41aad98d54d64d36fbb26ff856c4aa238a439a", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -36,13 +36,13 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n pub mod ast_validation;\n pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n-pub mod mir_stats;\n+mod mir_stats;\n pub mod no_asm;\n pub mod static_recursion;\n "}, {"sha": "9975082c551351e300c628925bbba9dd91919b50", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -13,7 +13,6 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n@@ -22,9 +21,7 @@ use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n-use rustc::mir::visit::Visitor;\n use rustc::ty::{ClosureSubsts, TyCtxt};\n-use rustc::util::common::to_readable_str;\n use rustc::util::nodemap::{FxHashMap};\n \n struct NodeData {\n@@ -37,21 +34,6 @@ struct StatCollector<'a, 'tcx: 'a> {\n     data: FxHashMap<&'static str, NodeData>,\n }\n \n-pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n-    let mut collector = StatCollector {\n-        _tcx: tcx,\n-        data: FxHashMap(),\n-    };\n-    // For debugging instrumentation like this, we don't need to worry\n-    // about maintaining the dep graph.\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n-        let mir = tcx.optimized_mir(def_id);\n-        collector.visit_mir(&mir);\n-    }\n-    collector.print(title);\n-}\n-\n impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n \n     fn record_with_size(&mut self, label: &'static str, node_size: usize) {\n@@ -67,27 +49,6 @@ impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n     fn record<T>(&mut self, label: &'static str, node: &T) {\n         self.record_with_size(label, ::std::mem::size_of_val(node));\n     }\n-\n-    fn print(&self, title: &str) {\n-        let mut stats: Vec<_> = self.data.iter().collect();\n-\n-        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n-\n-        println!(\"\\n{}\\n\", title);\n-\n-        println!(\"{:<32}{:>18}{:>14}{:>14}\",\n-            \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n-        println!(\"------------------------------------------------------------------------------\");\n-\n-        for (label, data) in stats {\n-            println!(\"{:<32}{:>18}{:>14}{:>14}\",\n-                label,\n-                to_readable_str(data.count * data.size),\n-                to_readable_str(data.count),\n-                to_readable_str(data.size));\n-        }\n-        println!(\"------------------------------------------------------------------------------\");\n-    }\n }\n \n impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {"}, {"sha": "1020cec9a86a55edabfb180d5bf6b47543127d9c", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -80,7 +80,7 @@ extern crate rustc_errors as errors;\n \n pub use self::registry::Registry;\n \n-pub mod diagnostics;\n+mod diagnostics;\n pub mod registry;\n pub mod load;\n pub mod build;"}, {"sha": "eb82dddaf56fb6a4bd0f0a468017a8547f40c9c8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -41,7 +41,7 @@ use std::cmp;\n use std::mem::replace;\n use std::rc::Rc;\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Visitor used to determine if pub(restricted) is used anywhere in the crate."}, {"sha": "bfc76ee2f74f67204495d8b0decc56d368496019", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -782,8 +782,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     }\n }\n \n-pub type ErrorMessage = Option<(Span, String)>;\n-\n #[derive(Copy, Clone)]\n enum TypeParameters<'a, 'b> {\n     NoTypeParameters,\n@@ -915,7 +913,7 @@ pub struct ModuleData<'a> {\n     expansion: Mark,\n }\n \n-pub type Module<'a> = &'a ModuleData<'a>;\n+type Module<'a> = &'a ModuleData<'a>;\n \n impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n@@ -3031,31 +3029,6 @@ impl<'a> Resolver<'a> {\n         return def;\n     }\n \n-    // Calls `f` with a `Resolver` whose current lexical scope is `module`'s lexical scope,\n-    // i.e. the module's items and the prelude (unless the module is `#[no_implicit_prelude]`).\n-    // FIXME #34673: This needs testing.\n-    pub fn with_module_lexical_scope<T, F>(&mut self, module: Module<'a>, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'a>) -> T,\n-    {\n-        self.with_empty_ribs(|this| {\n-            this.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            this.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-            f(this)\n-        })\n-    }\n-\n-    fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'a>) -> T,\n-    {\n-        let ribs = replace(&mut self.ribs, PerNS::<Vec<Rib>>::default());\n-        let label_ribs = replace(&mut self.label_ribs, Vec::new());\n-\n-        let result = f(self);\n-        self.ribs = ribs;\n-        self.label_ribs = label_ribs;\n-        result\n-    }\n-\n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n                                         ident: Ident,\n                                         ns: Namespace,"}, {"sha": "ee14171e9a49876600f1700dfe9937012b77ad36", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -51,7 +51,7 @@ use std::env;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n+use syntax::ast::{self, NodeId, PatKind, Attribute};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -80,8 +80,6 @@ pub struct SaveContext<'l, 'tcx: 'l> {\n \n #[derive(Debug)]\n pub enum Data {\n-    /// Data about a macro use.\n-    MacroUseData(MacroRef),\n     RefData(Ref),\n     DefData(Def),\n     RelationData(Relation),\n@@ -759,11 +757,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n-        self.tcx.hir.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n-    }\n-\n     fn docs_for_attrs(&self, attrs: &[Attribute]) -> String {\n         let mut result = String::new();\n "}, {"sha": "0d39db9e10a70894a3bbb50bb853eec4f4b5ae2c", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -10,7 +10,7 @@\n \n //! A helper class for dealing with static archives\n \n-use std::ffi::{CString, CStr, OsString};\n+use std::ffi::{CString, CStr};\n use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n@@ -28,8 +28,6 @@ pub struct ArchiveConfig<'a> {\n     pub dst: PathBuf,\n     pub src: Option<PathBuf>,\n     pub lib_search_paths: Vec<PathBuf>,\n-    pub ar_prog: String,\n-    pub command_path: OsString,\n }\n \n /// Helper for adding many files to an archive with a single invocation of"}, {"sha": "338f3bb08aa97a5825342e84d31d9f753065e44d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -138,12 +138,6 @@ pub fn msvc_link_exe_cmd(_sess: &Session) -> (Command, Vec<(OsString, OsString)>\n     (Command::new(\"link.exe\"), vec![])\n }\n \n-pub fn get_ar_prog(sess: &Session) -> String {\n-    sess.opts.cg.ar.clone().unwrap_or_else(|| {\n-        sess.target.target.options.ar.clone()\n-    })\n-}\n-\n fn command_path(sess: &Session) -> OsString {\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n@@ -383,8 +377,6 @@ fn archive_config<'a>(sess: &'a Session,\n         dst: output.to_path_buf(),\n         src: input.map(|p| p.to_path_buf()),\n         lib_search_paths: archive_search_paths(sess),\n-        ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n     }\n }\n "}, {"sha": "3f9b28d3d610cc3d07bd8b9982f1f59394f87690", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -785,8 +785,6 @@ pub fn start_async_translation(sess: &Session,\n         crate_name,\n         link,\n         metadata,\n-        exported_symbols,\n-        no_builtins,\n         windows_subsystem,\n         linker_info,\n         no_integrated_as,\n@@ -1801,8 +1799,6 @@ pub struct OngoingCrateTranslation {\n     crate_name: Symbol,\n     link: LinkMeta,\n     metadata: EncodedMetadata,\n-    exported_symbols: Arc<ExportedSymbols>,\n-    no_builtins: bool,\n     windows_subsystem: Option<String>,\n     linker_info: LinkerInfo,\n     no_integrated_as: bool,\n@@ -1852,13 +1848,10 @@ impl OngoingCrateTranslation {\n             crate_name: self.crate_name,\n             link: self.link,\n             metadata: self.metadata,\n-            exported_symbols: self.exported_symbols,\n-            no_builtins: self.no_builtins,\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n \n             modules: compiled_modules.modules,\n-            metadata_module: compiled_modules.metadata_module,\n             allocator_module: compiled_modules.allocator_module,\n         };\n "}, {"sha": "f2b07cf6a58310811accc34baf50e0769f350a91", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -27,10 +27,9 @@ use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -39,7 +38,6 @@ use std::iter;\n use std::str;\n use std::sync::Arc;\n use std::marker::PhantomData;\n-use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n use abi::Abi;\n@@ -124,12 +122,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// Cache of emitted const globals (value -> global)\n     const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n-    /// Cache of emitted const values\n-    const_values: RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n-\n-    /// Cache of external const values\n-    extern_const_values: RefCell<DefIdMap<ValueRef>>,\n-\n     /// Mapping from static definitions to their DefId's.\n     statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n@@ -144,7 +136,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n@@ -157,9 +148,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n \n     intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n-    /// Depth of the current type-of computation - used to bail out\n-    type_of_depth: Cell<usize>,\n-\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n \n@@ -406,13 +394,10 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n                 const_unsized: RefCell::new(FxHashMap()),\n                 const_globals: RefCell::new(FxHashMap()),\n-                const_values: RefCell::new(FxHashMap()),\n-                extern_const_values: RefCell::new(DefIdMap()),\n                 statics: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n@@ -421,7 +406,6 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n-                type_of_depth: Cell::new(0),\n                 local_gen_sym_counter: Cell::new(0),\n                 placeholder: PhantomData,\n             };\n@@ -545,15 +529,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n-                                                               ValueRef>> {\n-        &self.local().const_values\n-    }\n-\n-    pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.local().extern_const_values\n-    }\n-\n     pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n         &self.local().statics\n     }\n@@ -570,10 +545,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().lltypes\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n-        &self.local().type_hashcodes\n-    }\n-\n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.local().stats\n     }\n@@ -582,10 +553,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().int_type\n     }\n \n-    pub fn opaque_vec_type(&self) -> Type {\n-        self.local().opaque_vec_type\n-    }\n-\n     pub fn str_slice_type(&self) -> Type {\n         self.local().str_slice_type\n     }\n@@ -602,27 +569,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().intrinsics\n     }\n \n-    pub fn obj_size_bound(&self) -> u64 {\n-        self.tcx().data_layout.obj_size_bound()\n-    }\n-\n-    pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n-        self.sess().fatal(\n-            &format!(\"the type `{:?}` is too big for the current architecture\",\n-                    obj))\n-    }\n-\n-    pub fn enter_type_of(&self, ty: Ty<'tcx>) -> TypeOfDepthLock<'b, 'tcx> {\n-        let current_depth = self.local().type_of_depth.get();\n-        debug!(\"enter_type_of({:?}) at depth {:?}\", ty, current_depth);\n-        if current_depth > self.sess().recursion_limit.get() {\n-            self.sess().fatal(\n-                &format!(\"overflow representing the type `{}`\", ty))\n-        }\n-        self.local().type_of_depth.set(current_depth + 1);\n-        TypeOfDepthLock(self.local())\n-    }\n-\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n@@ -631,12 +577,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    /// Given the def-id of some item that has no type parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        self.tcx().empty_substs_for_def_id(item_def_id)\n-    }\n-\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -776,14 +716,6 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     }\n }\n \n-pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);\n-\n-impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {\n-    fn drop(&mut self) {\n-        self.0.type_of_depth.set(self.0.type_of_depth.get() - 1);\n-    }\n-}\n-\n /// Declare any llvm intrinsics that you might need\n fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {"}, {"sha": "6da42caf75bef1480a2543da48ef29f02275fe45", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -36,7 +36,6 @@\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n-use std::sync::Arc;\n \n extern crate flate2;\n extern crate libc;\n@@ -46,7 +45,7 @@ extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;\n-pub extern crate rustc_llvm as llvm;\n+extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n #[macro_use]\n@@ -78,7 +77,7 @@ pub mod back {\n     pub(crate) mod symbol_export;\n     pub(crate) mod symbol_names;\n     pub mod write;\n-    pub mod rpath;\n+    mod rpath;\n }\n \n mod diagnostics;\n@@ -138,8 +137,8 @@ pub struct ModuleTranslation {\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n-    pub name: String,\n-    pub symbol_name_hash: u64,\n+    name: String,\n+    symbol_name_hash: u64,\n     pub source: ModuleSource,\n     pub kind: ModuleKind,\n }\n@@ -206,7 +205,7 @@ pub enum ModuleSource {\n \n #[derive(Copy, Clone, Debug)]\n pub struct ModuleLlvm {\n-    pub llcx: llvm::ContextRef,\n+    llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }\n \n@@ -216,14 +215,11 @@ unsafe impl Sync for ModuleTranslation { }\n pub struct CrateTranslation {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,\n-    pub metadata_module: CompiledModule,\n-    pub allocator_module: Option<CompiledModule>,\n+    allocator_module: Option<CompiledModule>,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n-    pub exported_symbols: Arc<back::symbol_export::ExportedSymbols>,\n-    pub no_builtins: bool,\n-    pub windows_subsystem: Option<String>,\n-    pub linker_info: back::linker::LinkerInfo\n+    windows_subsystem: Option<String>,\n+    linker_info: back::linker::LinkerInfo\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "b8a8068d36af7ef33f59a467410525be44cac9ca", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -237,19 +237,6 @@ impl Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n-    pub fn is_aggregate(&self) -> bool {\n-        match self.kind() {\n-            TypeKind::Struct | TypeKind::Array => true,\n-            _ =>  false\n-        }\n-    }\n-\n-    pub fn is_packed(&self) -> bool {\n-        unsafe {\n-            llvm::LLVMIsPackedStruct(self.to_ref()) == True\n-        }\n-    }\n-\n     pub fn element_type(&self) -> Type {\n         unsafe {\n             Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n@@ -263,12 +250,6 @@ impl Type {\n         }\n     }\n \n-    pub fn array_length(&self) -> usize {\n-        unsafe {\n-            llvm::LLVMGetArrayLength(self.to_ref()) as usize\n-        }\n-    }\n-\n     pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n             let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as usize;\n@@ -282,10 +263,6 @@ impl Type {\n         }\n     }\n \n-    pub fn return_type(&self) -> Type {\n-        ty!(llvm::LLVMGetReturnType(self.to_ref()))\n-    }\n-\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n@@ -324,13 +301,4 @@ impl Type {\n             I128 => Type::i128(cx),\n         }\n     }\n-\n-    pub fn from_primitive(ccx: &CrateContext, p: layout::Primitive) -> Type {\n-        match p {\n-            layout::Int(i) => Type::from_integer(ccx, i),\n-            layout::F32 => Type::f32(ccx),\n-            layout::F64 => Type::f64(ccx),\n-            layout::Pointer => bug!(\"It is not possible to convert Pointer directly to Type.\")\n-        }\n-    }\n }"}, {"sha": "819f48a1b57e80855c4a314c43c056af34a84729", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -27,8 +27,6 @@ use rustc::hir;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n-pub use self::suggest::AllTraitsVec;\n-\n mod confirm;\n pub mod probe;\n mod suggest;"}, {"sha": "294429b5b3671de74b66c86128edc4dd53a740c5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757b7ac2abd69d97ba196b76f0bbf78c377aaea9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "patch": "@@ -95,12 +95,11 @@ extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n-pub use rustc::dep_graph;\n-pub use rustc::hir;\n-pub use rustc::lint;\n-pub use rustc::middle;\n-pub use rustc::session;\n-pub use rustc::util;\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::util;\n \n use hir::map as hir_map;\n use rustc::infer::InferOk;\n@@ -118,7 +117,7 @@ use syntax_pos::Span;\n use std::iter;\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod check;\n mod check_unused;\n@@ -130,8 +129,8 @@ mod coherence;\n mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub ty: Ty<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    ty: Ty<'tcx>,\n }\n \n fn require_c_abi_if_variadic(tcx: TyCtxt,"}]}