{"sha": "5a7773a18098be712d7e1ce4fded36aed8c3c311", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNzc3M2ExODA5OGJlNzEyZDdlMWNlNGZkZWQzNmFlZDhjM2MzMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-29T10:28:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-29T10:28:01Z"}, "message": "Auto merge of #35100 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #34258, #34894, #35050, #35062, #35066, #35072, #35087\n- Failed merges:", "tree": {"sha": "d7b3dd11aef8190cbf57272e2a72b22745336b45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b3dd11aef8190cbf57272e2a72b22745336b45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7773a18098be712d7e1ce4fded36aed8c3c311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7773a18098be712d7e1ce4fded36aed8c3c311", "html_url": "https://github.com/rust-lang/rust/commit/5a7773a18098be712d7e1ce4fded36aed8c3c311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7773a18098be712d7e1ce4fded36aed8c3c311/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1523a5480a8abb717f9afcffe5b149579d8e5d3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1523a5480a8abb717f9afcffe5b149579d8e5d3c", "html_url": "https://github.com/rust-lang/rust/commit/1523a5480a8abb717f9afcffe5b149579d8e5d3c"}, {"sha": "5f5fdf64f1f673d70dfa28f77da13f9acd5b9af7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5fdf64f1f673d70dfa28f77da13f9acd5b9af7", "html_url": "https://github.com/rust-lang/rust/commit/5f5fdf64f1f673d70dfa28f77da13f9acd5b9af7"}], "stats": {"total": 233, "additions": 206, "deletions": 27}, "files": [{"sha": "24fcf886ef03df82e371de0e175f2c8bef770220", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -291,9 +291,9 @@ isn\u2019t interesting. The next part is:\n #   some_closure(1) }\n ```\n \n-Because `Fn` is a trait, we can bound our generic with it. In this case, our\n-closure takes a `i32` as an argument and returns an `i32`, and so the generic\n-bound we use is `Fn(i32) -> i32`.\n+Because `Fn` is a trait, we can use it as a bound for our generic type. In\n+this case, our closure takes a `i32` as an argument and returns an `i32`, and\n+so the generic bound we use is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a\n trait, this will get monomorphized, and therefore, we\u2019ll be doing static"}, {"sha": "ca104ff29ace3377c7ccb9efb5d53b7c350963a8", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -575,16 +575,69 @@ against `libc` and `libm` by default.\n \n # The \"nullable pointer optimization\"\n \n-Certain types are defined to not be NULL. This includes references (`&T`,\n-`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`).\n-When interfacing with C, pointers that might be NULL are often used.\n-As a special case, a generic `enum` that contains exactly two variants, one of\n-which contains no data and the other containing a single field, is eligible\n-for the \"nullable pointer optimization\". When such an enum is instantiated\n-with one of the non-nullable types, it is represented as a single pointer,\n-and the non-data variant is represented as the NULL pointer. So\n-`Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n-function pointer using the C ABI.\n+Certain Rust types are defined to never be `null`. This includes references (`&T`,\n+`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\n+interfacing with C, pointers that might be `null` are often used, which would seem to\n+require some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types.\n+However, the language provides a workaround.\n+\n+As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\n+exactly two variants, one of which contains no data and the other contains a field of one of the\n+non-nullable types listed above.  This means no extra space is required for a discriminant; rather,\n+the empty variant is represented by putting a `null` value into the non-nullable field. This is\n+called an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\n+types.\n+\n+The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\n+where `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\n+to represent a nullable function pointer using the C ABI (corresponding to the C type\n+`int (*)(int)`).\n+\n+Here is a contrived example. Let's say some C library has a facility for registering a\n+callback, which gets called in certain situations. The callback is passed a function pointer\n+and an integer and it is supposed to run the function with the integer as a parameter. So\n+we have function pointers flying across the FFI boundary in both directions.\n+\n+```rust\n+# #![feature(libc)]\n+extern crate libc;\n+use libc::c_int;\n+\n+# #[cfg(hidden)]\n+extern \"C\" {\n+    /// Register the callback.\n+    fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n+}\n+# unsafe fn register(_: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>,\n+#                                            c_int) -> c_int>)\n+# {}\n+\n+/// This fairly useless function receives a function pointer and an integer\n+/// from C, and returns the result of calling the function with the integer.\n+/// In case no function is provided, it squares the integer by default.\n+extern \"C\" fn apply(process: Option<extern \"C\" fn(c_int) -> c_int>, int: c_int) -> c_int {\n+    match process {\n+        Some(f) => f(int),\n+        None    => int * int\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        register(Some(apply));\n+    }\n+}\n+```\n+\n+And the code on the C side looks like this:\n+\n+```c\n+void register(void (*f)(void (*)(int), int)) {\n+    ...\n+}\n+```\n+\n+No `transmute` required!\n \n # Calling Rust code from C\n "}, {"sha": "be0ef85d6b114aad2c2c975774bc209af7311fac", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -434,37 +434,31 @@\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!\n-//! For example, these:\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n //!\n //! ```\n-//! // Hello {arg 0 (x)} is {arg 1 (0.01) with precision specified inline (5)}\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n //! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n //!\n-//! // Hello {arg 1 (x)} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n //! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n //!\n-//! // Hello {arg 0 (x)} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n //! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {second of next two args (0.01) with precision\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n //! //                          specified in first of next two args (5)}\n //! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {arg 2 (0.01) with precision\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n //! //                          specified in its predecessor (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {arg \"number\" (0.01) with precision specified\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n //! //                          in arg \"prec\" (5)}\n //! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n //! ```\n //!\n-//! All print the same thing:\n-//!\n-//! ```text\n-//! Hello x is 0.01000\n-//! ```\n-//!\n //! While these:\n //!\n //! ```"}, {"sha": "b0c79a3a88547b0551436df2d562bc4ea6d0c6d9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -35,6 +35,17 @@ macro_rules! panic {\n /// This will invoke the `panic!` macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n+/// Assertions are always checked in both debug and release builds, and cannot\n+/// be disabled. See `debug_assert!` for assertions that are not enabled in\n+/// release builds by default.\n+///\n+/// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+/// violated could lead to unsafety.\n+///\n+/// Other use-cases of `assert!` include\n+/// [testing](https://doc.rust-lang.org/book/testing.html) and enforcing\n+/// run-time invariants in safe code (whose violation cannot result in unsafety).\n+///\n /// This macro has a second version, where a custom panic message can be provided.\n ///\n /// # Examples\n@@ -123,6 +134,13 @@ macro_rules! assert_eq {\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// An unchecked assertion allows a program in an inconsistent state to keep\n+/// running, which might have unexpected consequences but does not introduce\n+/// unsafety as long as this only happens in safe code. The performance cost\n+/// of assertions, is however, not measurable in general. Replacing `assert!`\n+/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n+/// more importantly, only in safe code!\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "fdcadd43a0fb64deeda403b43c42ebf3a74c4277", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -459,6 +459,19 @@ impl<'a> Chars<'a> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut chars = \"abc\".chars();\n+    ///\n+    /// assert_eq!(chars.as_str(), \"abc\");\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"bc\");\n+    /// chars.next();\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"\");\n+    /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {"}, {"sha": "2284a9bbb73e124bcc32db89160180acf3def2c3", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -108,7 +108,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n                 }\n             }\n         }\n-        // Ip is not present in the table.  This should not hapen... but it does: issie #35011.\n+        // Ip is not present in the table.  This should not happen... but it does: issue #35011.\n         // So rather than returning EHAction::Terminate, we do this.\n         EHAction::None\n     } else {"}, {"sha": "38fd93501a528520f7b1ea951780f5209b966dba", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -694,6 +694,23 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// if let Ok(time) = metadata.modified() {\n+    ///     println!(\"{:?}\", time);\n+    /// } else {\n+    ///     println!(\"Not supported on this platform\");\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         self.0.modified().map(FromInner::from_inner)\n@@ -712,6 +729,23 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// if let Ok(time) = metadata.accessed() {\n+    ///     println!(\"{:?}\", time);\n+    /// } else {\n+    ///     println!(\"Not supported on this platform\");\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         self.0.accessed().map(FromInner::from_inner)\n@@ -726,6 +760,23 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// if let Ok(time) = metadata.created() {\n+    ///     println!(\"{:?}\", time);\n+    /// } else {\n+    ///     println!(\"Not supported on this platform\");\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         self.0.created().map(FromInner::from_inner)"}, {"sha": "77587918ac94b0e83d9edb6f912d3227c54f719c", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7773a18098be712d7e1ce4fded36aed8c3c311/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=5a7773a18098be712d7e1ce4fded36aed8c3c311", "patch": "@@ -25,15 +25,53 @@ use sys::platform::fs::MetadataExt as UnixMetadataExt;\n pub trait PermissionsExt {\n     /// Returns the underlying raw `mode_t` bits that are the standard Unix\n     /// permissions for this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let permissions = metadata.permissions();\n+    ///\n+    /// println!(\"permissions: {}\", permissions.mode());\n+    /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n \n     /// Sets the underlying raw bits for this set of permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let mut permissions = metadata.permissions();\n+    ///\n+    /// permissions.set_mode(0o644); // Read/write for owner and read for others.\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn set_mode(&mut self, mode: u32);\n \n     /// Creates a new instance of `Permissions` from the given set of Unix\n     /// permission bits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::Permissions;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// // Read/write for owner and read for others.\n+    /// let permissions = Permissions::from_mode(0o644);\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn from_mode(mode: u32) -> Self;\n }\n@@ -63,6 +101,18 @@ pub trait OpenOptionsExt {\n     /// If no `mode` is set, the default of `0o666` will be used.\n     /// The operating system masks out bits with the systems `umask`, to produce\n     /// the final permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(0o644); // Give read/write for owner and read for others.\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n "}]}