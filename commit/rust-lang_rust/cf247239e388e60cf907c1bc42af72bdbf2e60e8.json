{"sha": "cf247239e388e60cf907c1bc42af72bdbf2e60e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMjQ3MjM5ZTM4OGU2MGNmOTA3YzFiYzQyYWY3MmJkYmYyZTYwZTg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-13T03:16:25Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-13T03:16:25Z"}, "message": "Simplify the common case of type_size and type_layout.", "tree": {"sha": "2d3254f672ae7bd2256fadee70fc16a192bb73c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3254f672ae7bd2256fadee70fc16a192bb73c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf247239e388e60cf907c1bc42af72bdbf2e60e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf247239e388e60cf907c1bc42af72bdbf2e60e8", "html_url": "https://github.com/rust-lang/rust/commit/cf247239e388e60cf907c1bc42af72bdbf2e60e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf247239e388e60cf907c1bc42af72bdbf2e60e8/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a3be9c7eea77d544f32abb26c059dfb9bb816f", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a3be9c7eea77d544f32abb26c059dfb9bb816f", "html_url": "https://github.com/rust-lang/rust/commit/25a3be9c7eea77d544f32abb26c059dfb9bb816f"}], "stats": {"total": 74, "additions": 42, "deletions": 32}, "files": [{"sha": "bb3d15f9e182ff15d53db02eff4fe0fe2f7b2cce", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cf247239e388e60cf907c1bc42af72bdbf2e60e8/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf247239e388e60cf907c1bc42af72bdbf2e60e8/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=cf247239e388e60cf907c1bc42af72bdbf2e60e8", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n-                let size = self.type_size(ty, substs);\n+                let size = self.type_size_with_substs(ty, substs);\n                 Some(self.memory.allocate(size))\n             }\n             ty::FnDiverging => None,\n@@ -307,11 +307,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n+        self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_layout(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n+        self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    }\n+\n+    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n+        self.type_layout_with_substs(ty, self.substs())\n+    }\n+\n+    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n@@ -334,7 +342,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n         let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            let size = self.type_size(ty, substs);\n+            let size = self.type_size_with_substs(ty, substs);\n             self.memory.allocate(size)\n         }).collect();\n \n@@ -377,7 +385,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_size = self\n-                    .type_layout(self.lvalue_ty(discr), self.substs())\n+                    .type_layout(self.lvalue_ty(discr))\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n                 let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n@@ -428,7 +436,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let name = self.tcx.item_name(def_id).as_str();\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n+                                        let size = self.type_size(ty);\n                                         let ret = return_ptr.unwrap();\n                                         self.call_intrinsic(&name, substs, args, ret, size)?\n                                     }\n@@ -439,7 +447,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Abi::C => {\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n+                                        let size = self.type_size(ty);\n                                         self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n                                     }\n                                     ty::FnDiverging => unimplemented!(),\n@@ -469,7 +477,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let last_arg = args.last().unwrap();\n                                     let last = self.eval_operand(last_arg)?;\n                                     let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty, self.substs());\n+                                    let last_layout = self.type_layout(last_ty);\n                                     match (&last_ty.sty, last_layout) {\n                                         (&ty::TyTuple(fields),\n                                          &Layout::Univariant { ref variant, .. }) => {\n@@ -566,15 +574,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         // Filling drop.\n         // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n-        let size = self.type_size(ty, self.substs());\n+        let size = self.type_size(ty);\n         self.memory.drop_fill(ptr, size)?;\n \n         Ok(())\n     }\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty, self.substs());\n+        let adt_layout = self.type_layout(adt_ty);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, .. } => {\n@@ -627,7 +635,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -641,7 +649,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n-                let elem_size = self.type_size(elem_ty, self.substs());\n+                let elem_size = self.type_size(elem_ty);\n                 let src = self.memory.read_ptr(args[0])?;\n                 let dest = self.memory.read_ptr(args[1])?;\n                 let count = self.memory.read_isize(args[2])?;\n@@ -657,7 +665,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n-                let arg_size = self.type_size(arg_ty, self.substs());\n+                let arg_size = self.type_size(arg_ty);\n                 self.memory.drop_fill(args[0], arg_size)?;\n             }\n \n@@ -676,7 +684,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -688,7 +696,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                let pointee_size = self.type_size(pointee_ty, self.substs()) as isize;\n+                let pointee_size = self.type_size(pointee_ty) as isize;\n                 let ptr_arg = args[0];\n                 let offset = self.memory.read_isize(args[1])?;\n \n@@ -709,7 +717,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let n = left.wrapping_sub(right);\n@@ -718,20 +726,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs()) as u64;\n+                let size = self.type_size(ty) as u64;\n                 self.memory.write_uint(dest, size, dest_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty, self.substs()) as u64;\n+                    let size = self.type_size(ty) as u64;\n                     self.memory.write_uint(dest, size, dest_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty, self.substs()) as u64;\n+                            let elem_size = self.type_size(elem_ty) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n                             let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n                             self.memory.write_uint(dest, n * elem_size, dest_size)?;\n@@ -810,7 +818,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_int(dest, result, dest_size)?;\n             }\n \n-            _ => return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name))),\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n         }\n \n         // Since we pushed no stack frame, the main loop will act\n@@ -839,7 +849,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty, self.substs());\n+        let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -876,7 +886,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 // FIXME(solson): Find the result type size properly. Perhaps refactor out\n                 // Projection calculations so we can do the equivalent of `dest.1` here.\n-                let s = self.type_size(left_ty, self.substs());\n+                let s = self.type_size(left_ty);\n                 self.memory.write_bool(dest.offset(s as isize), false)?;\n             }\n \n@@ -898,7 +908,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty, self.substs()) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n                             _ => panic!(\"tried to assign {:?} to non-array type {:?}\",\n                                         kind, dest_ty),\n                         };\n@@ -976,7 +986,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_size, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty, self.substs()), n),\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n@@ -1017,7 +1027,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Box(ty) => {\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let ptr = self.memory.allocate(size);\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n@@ -1045,8 +1055,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Misc => {\n                         // FIXME(solson): Wrong for almost everything.\n-                        let dest_size = self.type_size(dest_ty, self.substs());\n-                        let src_size = self.type_size(src_ty, self.substs());\n+                        let dest_size = self.type_size(dest_ty);\n+                        let src_size = self.type_size(src_ty);\n                         if dest_size == src_size {\n                             warn!(\"performing fishy cast from {:?} to {:?}\", src_ty, dest_ty);\n                             self.memory.copy(src, dest, dest_size)?;\n@@ -1116,7 +1126,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n-        let layout = self.type_layout(ty, self.substs());\n+        let layout = self.type_layout(ty);\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -1187,7 +1197,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let base_layout = self.type_layout(base_ty, self.substs());\n+                let base_layout = self.type_layout(base_ty);\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n@@ -1248,7 +1258,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n                             ty::TyArray(elem_ty, _) |\n-                            ty::TySlice(elem_ty) => self.type_size(elem_ty, self.substs()),\n+                            ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => panic!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n                         let n_ptr = self.eval_operand(operand)?;\n@@ -1274,7 +1284,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n-        let size = self.type_size(ty, self.substs());\n+        let size = self.type_size(ty);\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n             self.memory.drop_fill(src, size)?;"}]}