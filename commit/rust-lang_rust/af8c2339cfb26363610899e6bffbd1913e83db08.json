{"sha": "af8c2339cfb26363610899e6bffbd1913e83db08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmOGMyMzM5Y2ZiMjYzNjM2MTA4OTllNmJmZmJkMTkxM2U4M2RiMDg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-27T23:43:59Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-03T00:21:13Z"}, "message": "fix handling of borrows at a function's end", "tree": {"sha": "8f59f02f5d2d4bd793b5531bdafac15a8837ae89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f59f02f5d2d4bd793b5531bdafac15a8837ae89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af8c2339cfb26363610899e6bffbd1913e83db08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af8c2339cfb26363610899e6bffbd1913e83db08", "html_url": "https://github.com/rust-lang/rust/commit/af8c2339cfb26363610899e6bffbd1913e83db08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af8c2339cfb26363610899e6bffbd1913e83db08/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9b0897c5d42a4dfa425db799073c6feb21b0178", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b0897c5d42a4dfa425db799073c6feb21b0178", "html_url": "https://github.com/rust-lang/rust/commit/f9b0897c5d42a4dfa425db799073c6feb21b0178"}], "stats": {"total": 106, "additions": 76, "deletions": 30}, "files": [{"sha": "ee48d1d369d53e8aba1edec3dcd8f1d16d7d9dbc", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/af8c2339cfb26363610899e6bffbd1913e83db08/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af8c2339cfb26363610899e6bffbd1913e83db08/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=af8c2339cfb26363610899e6bffbd1913e83db08", "patch": "@@ -384,33 +384,23 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n                 let domain = flow_state.borrows.base_results.operator();\n-                for borrow in domain.borrows() {\n-                    let root_place = self.prefixes(\n-                        &borrow.place,\n-                        PrefixSet::All\n-                    ).last().unwrap();\n-                    match root_place {\n-                        Place::Static(_) => {\n-                            self.access_place(\n-                                ContextKind::StorageDead.new(loc),\n-                                (&root_place, self.mir.source_info(borrow.location).span),\n-                                (Deep, Write(WriteKind::StorageDeadOrDrop)),\n-                                LocalMutationIsAllowed::Yes,\n-                                flow_state\n-                            );\n-                        }\n-                        Place::Local(_) => {\n-                            self.access_place(\n-                                ContextKind::StorageDead.new(loc),\n-                                (&root_place, self.mir.source_info(borrow.location).span),\n-                                (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n-                                LocalMutationIsAllowed::Yes,\n-                                flow_state\n-                            );\n-                        }\n-                        Place::Projection(_) => ()\n+                let data = domain.borrows();\n+                flow_state.borrows.with_elems_outgoing(|borrows| for i in borrows {\n+                    let borrow = &data[i];\n+\n+                    if self.place_is_invalidated_at_exit(&borrow.place) {\n+                        debug!(\"borrow conflicts at exit {:?}\", borrow);\n+                        let borrow_span = self.mir.source_info(borrow.location).span;\n+                        // FIXME: should be talking about the region lifetime instead\n+                        // of just a span here.\n+                        let end_span = domain.opt_region_end_span(&borrow.region);\n+\n+                        self.report_borrowed_value_does_not_live_long_enough(\n+                            ContextKind::StorageDead.new(loc),\n+                            (&borrow.place, borrow_span),\n+                            end_span)\n                     }\n-                }\n+                });\n             }\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Unreachable |\n@@ -594,7 +584,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     context, common_prefix, place_span, bk,\n                                     &borrow, end_issued_loan_span)\n                             }\n-                             WriteKind::StorageDeadOrDrop => {\n+                            WriteKind::StorageDeadOrDrop => {\n                                 let end_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n@@ -751,6 +741,50 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Operand::Constant(_) => {}\n         }\n     }\n+\n+    /// Returns whether a borrow of this place is invalidated when the function\n+    /// exits\n+    fn place_is_invalidated_at_exit(&self, place: &Place<'tcx>) -> bool {\n+        debug!(\"place_is_invalidated_at_exit({:?})\", place);\n+        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n+\n+        // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n+        // we just know that all locals are dropped at function exit (otherwise\n+        // we'll have a memory leak) and assume that all statics have a destructor.\n+        let (might_be_alive, will_be_dropped) = match root_place {\n+            Place::Static(statik) => {\n+                // Thread-locals might be dropped after the function exits, but\n+                // \"true\" statics will never be.\n+                let is_thread_local = self.tcx.get_attrs(statik.def_id).iter().any(|attr| {\n+                    attr.check_name(\"thread_local\")\n+                });\n+\n+                (true, is_thread_local)\n+            }\n+            Place::Local(_) => {\n+                // Locals are always dropped at function exit, and if they\n+                // have a destructor it would've been called already.\n+                (false, true)\n+            }\n+            Place::Projection(..) => bug!(\"root of {:?} is a projection ({:?})?\",\n+                                           place, root_place)\n+        };\n+\n+        if !will_be_dropped {\n+            debug!(\"place_is_invalidated_at_exit({:?}) - won't be dropped\", place);\n+            return false;\n+        }\n+\n+        // FIXME: replace this with a proper borrow_conflicts_with_place when\n+        // that is merged.\n+        let prefix_set = if might_be_alive {\n+            PrefixSet::Supporting\n+        } else {\n+            PrefixSet::Shallow\n+        };\n+\n+        self.prefixes(place, prefix_set).any(|prefix| prefix == root_place)\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -1667,13 +1701,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_borrowed_value_does_not_live_long_enough(&mut self,\n                                                        _: Context,\n-                                                       (place, span): (&Place, Span),\n+                                                       (place, span): (&Place<'tcx>, Span),\n                                                        end_span: Option<Span>) {\n-        let proper_span = match *place {\n+        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n+        let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => span\n         };\n-\n         let mut err = self.tcx.path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value created here\");\n         err.span_label(span, \"temporary value dropped here while still borrowed\");\n@@ -2162,4 +2196,12 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n         let univ = self.base_results.sets().bits_per_block();\n         self.curr_state.elems(univ)\n     }\n+\n+    fn with_elems_outgoing<F>(&self, f: F) where F: FnOnce(indexed_set::Elems<BD::Idx>) {\n+        let mut curr_state = self.curr_state.clone();\n+        curr_state.union(&self.stmt_gen);\n+        curr_state.subtract(&self.stmt_kill);\n+        let univ = self.base_results.sets().bits_per_block();\n+        f(curr_state.elems(univ));\n+    }\n }"}, {"sha": "c87e91b5e6361a86d910e0a97e669ff843cc3343", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af8c2339cfb26363610899e6bffbd1913e83db08/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af8c2339cfb26363610899e6bffbd1913e83db08/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=af8c2339cfb26363610899e6bffbd1913e83db08", "patch": "@@ -132,6 +132,10 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n+    pub fn nonlexical_regioncx(&self) -> Option<&'a RegionInferenceContext<'tcx>> {\n+        self.nonlexical_regioncx\n+    }\n+\n     /// Returns the span for the \"end point\" given region. This will\n     /// return `None` if NLL is enabled, since that concept has no\n     /// meaning there.  Otherwise, return region span if it exists and"}]}