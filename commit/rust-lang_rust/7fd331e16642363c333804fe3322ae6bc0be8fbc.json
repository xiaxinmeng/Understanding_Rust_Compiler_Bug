{"sha": "7fd331e16642363c333804fe3322ae6bc0be8fbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZDMzMWUxNjY0MjM2M2MzMzM4MDRmZTMzMjJhZTZiYzBiZThmYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-05T04:50:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-05T04:50:05Z"}, "message": "Auto merge of #32328 - jseyfried:coherence, r=nikomatsakis\n\nresolve: Improve import failure detection and lay groundwork for RFC 1422\n\nThis PR improves import failure detection and lays some groundwork for RFC 1422.\nMore specifically, it\n - Avoids recomputing the resolution of an import directive's module path.\n - Refactors code in `resolve_imports` that does not scale to the arbitrarily many levels of visibility that will be required by RFC 1422.\n  - Replaces `ModuleS`'s fields `public_glob_count`, `private_glob_count`, and `resolved_globs` with a list of glob import directives `globs`.\n  - Replaces `NameResolution`'s fields `pub_outstanding_references` and `outstanding_references` with a field `single_imports` of a newly defined type `SingleImports`.\n - Improves import failure detection by detecting cycles that include single imports (currently, only cycles of globs are detected). This fixes #32119.\n\nr? @nikomatsakis", "tree": {"sha": "ab72c2b72f95ed18e4cc801ce7e22cec04007e13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab72c2b72f95ed18e4cc801ce7e22cec04007e13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fd331e16642363c333804fe3322ae6bc0be8fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd331e16642363c333804fe3322ae6bc0be8fbc", "html_url": "https://github.com/rust-lang/rust/commit/7fd331e16642363c333804fe3322ae6bc0be8fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fd331e16642363c333804fe3322ae6bc0be8fbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "600dc3552ffcdff014cc770e98a67b674496d10a", "url": "https://api.github.com/repos/rust-lang/rust/commits/600dc3552ffcdff014cc770e98a67b674496d10a", "html_url": "https://github.com/rust-lang/rust/commit/600dc3552ffcdff014cc770e98a67b674496d10a"}, {"sha": "6f09deaa32ba8a4f26a46c28ffecbb3efc3d165e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f09deaa32ba8a4f26a46c28ffecbb3efc3d165e", "html_url": "https://github.com/rust-lang/rust/commit/6f09deaa32ba8a4f26a46c28ffecbb3efc3d165e"}], "stats": {"total": 414, "additions": 207, "deletions": 207}, "files": [{"sha": "7eb7d8cafe707c0c8a604a3b7a6bba37d2ffd903", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 42, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7fd331e16642363c333804fe3322ae6bc0be8fbc", "patch": "@@ -14,8 +14,7 @@\n //! any imports resolved.\n \n use DefModifiers;\n-use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind};\n@@ -28,7 +27,7 @@ use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::VariantKind;\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -152,8 +151,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n \n                         let subclass = ImportDirectiveSubclass::single(binding, source_name);\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     subclass,\n                                                     view_path.span,\n                                                     item.id,\n@@ -203,8 +202,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                 }\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            self.build_import_directive(parent,\n-                                                        module_path,\n+                            self.unresolved_imports += 1;\n+                            parent.add_import_directive(module_path,\n                                                         subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n@@ -213,8 +212,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     GlobImport,\n                                                     view_path.span,\n                                                     item.id,\n@@ -521,39 +520,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n     }\n \n-    /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(&mut self,\n-                              module_: Module<'b>,\n-                              module_path: Vec<Name>,\n-                              subclass: ImportDirectiveSubclass,\n-                              span: Span,\n-                              id: NodeId,\n-                              is_public: bool,\n-                              is_prelude: bool) {\n-        // Bump the reference count on the name. Or, if this is a glob, set\n-        // the appropriate flag.\n-\n-        match subclass {\n-            SingleImport { target, .. } => {\n-                module_.increment_outstanding_references_for(target, ValueNS, is_public);\n-                module_.increment_outstanding_references_for(target, TypeNS, is_public);\n-            }\n-            GlobImport if !is_prelude => {\n-                // Set the glob flag. This tells us that we don't know the\n-                // module's exports ahead of time.\n-                module_.inc_glob_count(is_public)\n-            }\n-            // Prelude imports are not included in the glob counts since they do not get added to\n-            // `resolved_globs` -- they are handled separately in `resolve_imports`.\n-            GlobImport => {}\n-        }\n-\n-        let directive =\n-            ImportDirective::new(module_path, subclass, span, id, is_public, is_prelude);\n-        module_.add_import_directive(directive);\n-        self.unresolved_imports += 1;\n-    }\n-\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {"}, {"sha": "98e40d73133278be38e91f8708f07295c6d55242", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7fd331e16642363c333804fe3322ae6bc0be8fbc", "patch": "@@ -828,8 +828,8 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n-    unresolved_imports: RefCell<Vec<&'a ImportDirective>>,\n+    resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // The module children of this node, including normal modules and anonymous modules.\n     // Anonymous children are pseudo-modules that are implicitly created around items\n@@ -849,14 +849,8 @@ pub struct ModuleS<'a> {\n \n     prelude: RefCell<Option<Module<'a>>>,\n \n-    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective)>>,\n-    resolved_globs: RefCell<(Vec<Module<'a>> /* public */, Vec<Module<'a>> /* private */)>,\n-\n-    // The number of public glob imports in this module.\n-    public_glob_count: Cell<usize>,\n-\n-    // The number of private glob imports in this module.\n-    private_glob_count: Cell<usize>,\n+    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n+    globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -884,22 +878,15 @@ impl<'a> ModuleS<'a> {\n             module_children: RefCell::new(NodeMap()),\n             prelude: RefCell::new(None),\n             glob_importers: RefCell::new(Vec::new()),\n-            resolved_globs: RefCell::new((Vec::new(), Vec::new())),\n-            public_glob_count: Cell::new(0),\n-            private_glob_count: Cell::new(0),\n+            globs: RefCell::new((Vec::new())),\n             populated: Cell::new(!external),\n             arenas: arenas\n         }\n     }\n \n-    fn add_import_directive(&self, import_directive: ImportDirective) {\n-        let import_directive = self.arenas.alloc_import_directive(import_directive);\n-        self.unresolved_imports.borrow_mut().push(import_directive);\n-    }\n-\n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n         for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.binding.map(|binding| f(name, ns, binding));\n+            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n         }\n     }\n \n@@ -929,11 +916,6 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n-\n-    fn inc_glob_count(&self, is_public: bool) {\n-        let glob_count = if is_public { &self.public_glob_count } else { &self.private_glob_count };\n-        glob_count.set(glob_count.get() + 1);\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n@@ -1135,7 +1117,8 @@ pub struct Resolver<'a, 'tcx: 'a> {\n struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<ImportDirective>,\n+    import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1145,9 +1128,13 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(&'a self, import_directive: ImportDirective) -> &'a ImportDirective {\n+    fn alloc_import_directive(&'a self, import_directive: ImportDirective<'a>)\n+                              -> &'a ImportDirective {\n         self.import_directives.alloc(import_directive)\n     }\n+    fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n+        self.name_resolutions.alloc(Default::default())\n+    }\n }\n \n #[derive(PartialEq)]\n@@ -1216,6 +1203,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             modules: arena::TypedArena::new(),\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n+            name_resolutions: arena::TypedArena::new(),\n         }\n     }\n "}, {"sha": "2aa8925fb54b58be6ce79fa23e7f30f34b457a3e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 174, "deletions": 133, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7fd331e16642363c333804fe3322ae6bc0be8fbc", "patch": "@@ -30,7 +30,7 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -57,38 +57,21 @@ impl ImportDirectiveSubclass {\n \n /// One import directive.\n #[derive(Debug,Clone)]\n-pub struct ImportDirective {\n+pub struct ImportDirective<'a> {\n     module_path: Vec<Name>,\n+    target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n-impl ImportDirective {\n-    pub fn new(module_path: Vec<Name>,\n-               subclass: ImportDirectiveSubclass,\n-               span: Span,\n-               id: NodeId,\n-               is_public: bool,\n-               is_prelude: bool)\n-               -> ImportDirective {\n-        ImportDirective {\n-            module_path: module_path,\n-            subclass: subclass,\n-            span: span,\n-            id: id,\n-            is_public: is_public,\n-            is_prelude: is_prelude,\n-        }\n-    }\n-\n+impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import<'a>(&self,\n-                  binding: &'a NameBinding<'a>,\n-                  privacy_error: Option<Box<PrivacyError<'a>>>) -> NameBinding<'a> {\n+    fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n+              -> NameBinding<'a> {\n         let mut modifiers = match self.is_public {\n             true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n             false => DefModifiers::empty(),\n@@ -110,17 +93,52 @@ impl ImportDirective {\n }\n \n #[derive(Clone, Default)]\n-/// Records information about the resolution of a name in a module.\n+/// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n-    /// The number of unresolved single imports of any visibility that could define the name.\n-    outstanding_references: u32,\n-    /// The number of unresolved `pub` single imports that could define the name.\n-    pub_outstanding_references: u32,\n+    /// The single imports that define the name in the namespace.\n+    single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n+#[derive(Clone, Debug)]\n+enum SingleImports<'a> {\n+    /// No single imports can define the name in the namespace.\n+    None,\n+    /// Only the given single import can define the name in the namespace.\n+    MaybeOne(&'a ImportDirective<'a>),\n+    /// At least one single import will define the name in the namespace.\n+    AtLeastOne,\n+}\n+\n+impl<'a> Default for SingleImports<'a> {\n+    fn default() -> Self {\n+        SingleImports::None\n+    }\n+}\n+\n+impl<'a> SingleImports<'a> {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+        match *self {\n+            SingleImports::None => *self = SingleImports::MaybeOne(directive),\n+            // If two single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise both would have to define only one\n+            // namespace, leading to a duplicate error.\n+            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::AtLeastOne => {}\n+        };\n+    }\n+\n+    fn directive_failed(&mut self) {\n+        match *self {\n+            SingleImports::None => unreachable!(),\n+            SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::AtLeastOne => {}\n+        }\n+    }\n+}\n+\n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n         if let Some(old_binding) = self.binding {\n@@ -139,40 +157,54 @@ impl<'a> NameResolution<'a> {\n         Ok(())\n     }\n \n+    // Returns the binding for the name if it is known or None if it not known.\n+    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+        self.binding.and_then(|binding| match self.single_imports {\n+            SingleImports::None => Some(binding),\n+            _ if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Some(binding),\n+            _ => None, // The binding could be shadowed by a single import, so it is not known.\n+        })\n+    }\n+\n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n-    fn try_result(&self, allow_private_imports: bool)\n+    fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match self.binding {\n             Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n-                Some(Success(binding)),\n-            // If (1) we don't allow private imports, (2) no public single import can define the\n-            // name, and (3) no public glob has defined the name, the resolution depends on globs.\n-            _ if !allow_private_imports && self.pub_outstanding_references == 0 &&\n-                 !self.binding.map(NameBinding::is_public).unwrap_or(false) => None,\n-            _ if self.outstanding_references > 0 => Some(Indeterminate),\n-            Some(binding) => Some(Success(binding)),\n-            None => None,\n-        }\n-    }\n-\n-    fn increment_outstanding_references(&mut self, is_public: bool) {\n-        self.outstanding_references += 1;\n-        if is_public {\n-            self.pub_outstanding_references += 1;\n-        }\n-    }\n-\n-    fn decrement_outstanding_references(&mut self, is_public: bool) {\n-        let decrement_references = |count: &mut _| {\n-            assert!(*count > 0);\n-            *count -= 1;\n+                return Some(Success(binding)),\n+            _ => {} // Items and single imports are not shadowable\n         };\n \n-        decrement_references(&mut self.outstanding_references);\n-        if is_public {\n-            decrement_references(&mut self.pub_outstanding_references);\n+        // Check if a single import can still define the name.\n+        match self.single_imports {\n+            SingleImports::None => {},\n+            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::MaybeOne(directive) => {\n+                // If (1) we don't allow private imports, (2) no public single import can define\n+                // the name, and (3) no public glob has defined the name, the resolution depends\n+                // on whether more globs can define the name.\n+                if !allow_private_imports && !directive.is_public &&\n+                   !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n+                    return None;\n+                }\n+\n+                let target_module = match directive.target_module.get() {\n+                    Some(target_module) => target_module,\n+                    None => return Some(Indeterminate),\n+                };\n+                let name = match directive.subclass {\n+                    SingleImport { source, .. } => source,\n+                    GlobImport => unreachable!(),\n+                };\n+                match target_module.resolve_name(name, ns, false) {\n+                    Failed(_) => {}\n+                    _ => return Some(Indeterminate),\n+                }\n+            }\n         }\n+\n+        self.binding.map(Success)\n     }\n \n     fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n@@ -195,45 +227,36 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> ::ModuleS<'a> {\n+    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions.borrow_mut().entry((name, ns))\n+             .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n                         -> ResolveResult<&'a NameBinding<'a>> {\n-        let resolutions = match self.resolutions.borrow_state() {\n-            ::std::cell::BorrowState::Unused => self.resolutions.borrow(),\n-            _ => return Failed(None), // This happens when there is a cycle of glob imports\n+        let resolution = self.resolution(name, ns);\n+        let resolution = match resolution.borrow_state() {\n+            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n+            _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        let resolution = resolutions.get(&(name, ns)).cloned().unwrap_or_default();\n-        if let Some(result) = resolution.try_result(allow_private_imports) {\n+        if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n             // If the resolution doesn't depend on glob definability, check privacy and return.\n             return result.and_then(|binding| {\n                 let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n                 if allowed { Success(binding) } else { Failed(None) }\n             });\n         }\n \n-        let (ref mut public_globs, ref mut private_globs) = *self.resolved_globs.borrow_mut();\n-\n-        // Check if the public globs are determined\n-        if public_globs.len() < self.public_glob_count.get() {\n-            return Indeterminate;\n-        }\n-        for module in public_globs.iter() {\n-            if let Indeterminate = module.resolve_name(name, ns, false) {\n-                return Indeterminate;\n-            }\n-        }\n-\n-        if !allow_private_imports {\n-            return Failed(None);\n-        }\n-\n-        // Check if the private globs are determined\n-        if private_globs.len() < self.private_glob_count.get() {\n-            return Indeterminate;\n-        }\n-        for module in private_globs.iter() {\n-            if let Indeterminate = module.resolve_name(name, ns, false) {\n-                return Indeterminate;\n+        // Check if the globs are determined\n+        for directive in self.globs.borrow().iter() {\n+            if !allow_private_imports && !directive.is_public { continue }\n+            match directive.target_module.get() {\n+                None => return Indeterminate,\n+                Some(target_module) => match target_module.resolve_name(name, ns, false) {\n+                    Indeterminate => return Indeterminate,\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -243,7 +266,7 @@ impl<'a> ::ModuleS<'a> {\n     // Invariant: this may not be called until import resolution is complete.\n     pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n                                          -> Option<&'a NameBinding<'a>> {\n-        self.resolutions.borrow().get(&(name, ns)).and_then(|resolution| resolution.binding)\n+        self.resolution(name, ns).borrow().binding\n             .or_else(|| self.prelude.borrow().and_then(|prelude| {\n                 prelude.resolve_name(name, ns, false).success()\n             }))\n@@ -258,23 +281,49 @@ impl<'a> ::ModuleS<'a> {\n         })\n     }\n \n-    pub fn increment_outstanding_references_for(&self, name: Name, ns: Namespace, is_public: bool) {\n-        self.resolutions.borrow_mut().entry((name, ns)).or_insert_with(Default::default)\n-            .increment_outstanding_references(is_public);\n+    pub fn add_import_directive(&self,\n+                                module_path: Vec<Name>,\n+                                subclass: ImportDirectiveSubclass,\n+                                span: Span,\n+                                id: NodeId,\n+                                is_public: bool,\n+                                is_prelude: bool) {\n+        let directive = self.arenas.alloc_import_directive(ImportDirective {\n+            module_path: module_path,\n+            target_module: Cell::new(None),\n+            subclass: subclass,\n+            span: span,\n+            id: id,\n+            is_public: is_public,\n+            is_prelude: is_prelude,\n+        });\n+\n+        self.unresolved_imports.borrow_mut().push(directive);\n+        match directive.subclass {\n+            SingleImport { target, .. } => {\n+                for &ns in &[ValueNS, TypeNS] {\n+                    self.resolution(target, ns).borrow_mut().single_imports\n+                                                            .add_directive(directive);\n+                }\n+            }\n+            // We don't add prelude imports to the globs since they only affect lexical scopes,\n+            // which are not relevant to import resolution.\n+            GlobImport if directive.is_prelude => {}\n+            GlobImport => self.globs.borrow_mut().push(directive),\n+        }\n     }\n \n     // Use `update` to mutate the resolution for the name.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n         where F: FnOnce(&mut NameResolution<'a>) -> T\n     {\n-        let mut resolutions = self.resolutions.borrow_mut();\n-        let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n-        let was_success = resolution.try_result(false).and_then(ResolveResult::success).is_some();\n+        let mut resolution = &mut *self.resolution(name, ns).borrow_mut();\n+        let was_known = resolution.binding().is_some();\n \n         let t = update(resolution);\n-        if !was_success {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+        if !was_known {\n+            if let Some(binding) = resolution.binding() {\n                 self.define_in_glob_importers(name, ns, binding);\n             }\n         }\n@@ -292,7 +341,7 @@ impl<'a> ::ModuleS<'a> {\n struct ImportResolvingError<'a> {\n     /// Module where the error happened\n     source_module: Module<'a>,\n-    import_directive: &'a ImportDirective,\n+    import_directive: &'a ImportDirective<'a>,\n     span: Span,\n     help: String,\n }\n@@ -424,46 +473,36 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective) -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n                module_to_string(self.resolver.current_module));\n \n-        let target_module = match self.resolver.resolve_module_path(&directive.module_path,\n-                                                                    DontUseLexicalScope,\n-                                                                    directive.span) {\n-            Success(module) => module,\n-            Indeterminate => return Indeterminate,\n-            Failed(err) => return Failed(err),\n+        let target_module = match directive.target_module.get() {\n+            Some(module) => module,\n+            _ => match self.resolver.resolve_module_path(&directive.module_path,\n+                                                         DontUseLexicalScope,\n+                                                         directive.span) {\n+                Success(module) => module,\n+                Indeterminate => return Indeterminate,\n+                Failed(err) => return Failed(err),\n+            },\n         };\n \n+        directive.target_module.set(Some(target_module));\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n                 (source, target, value_determined, type_determined),\n             GlobImport => return self.resolve_glob_import(target_module, directive),\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let module_ = self.resolver.current_module;\n-        let (value_result, type_result) = {\n-            let mut resolve_in_ns = |ns, determined: bool| {\n-                // Temporarily count the directive as determined so that the resolution fails\n-                // (as opposed to being indeterminate) when it can only be defined by the directive.\n-                if !determined {\n-                    module_.resolutions.borrow_mut().get_mut(&(target, ns)).unwrap()\n-                           .decrement_outstanding_references(directive.is_public);\n-                }\n-                let result =\n-                    self.resolver.resolve_name_in_module(target_module, source, ns, false, true);\n-                if !determined {\n-                    module_.increment_outstanding_references_for(target, ns, directive.is_public)\n-                }\n-                result\n-            };\n-            (resolve_in_ns(ValueNS, value_determined.get()),\n-             resolve_in_ns(TypeNS, type_determined.get()))\n-        };\n+        let value_result =\n+            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n+        let type_result =\n+            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n+        let module_ = self.resolver.current_module;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n             if determined.get() { continue }\n@@ -488,18 +527,24 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let binding = &directive.import(binding, None);\n                     self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n                 }\n+            } else {\n+                module_.update_resolution(target, ns, |resolution| {\n+                    resolution.single_imports.directive_failed();\n+                });\n             }\n-\n-            module_.update_resolution(target, ns, |resolution| {\n-                resolution.decrement_outstanding_references(directive.is_public);\n-            })\n         }\n \n         match (&value_result, &type_result) {\n             (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n             (&Failed(_), &Failed(_)) => {\n-                let children = target_module.resolutions.borrow();\n-                let names = children.keys().map(|&(ref name, _)| name);\n+                let resolutions = target_module.resolutions.borrow();\n+                let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n+                    match *resolution.borrow() {\n+                        NameResolution { binding: Some(_), .. } => Some(name),\n+                        NameResolution { single_imports: SingleImports::None, .. } => None,\n+                        _ => Some(name),\n+                    }\n+                });\n                 let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n@@ -579,7 +624,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective)\n+    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n                            -> ResolveResult<()> {\n         if let Some(Def::Trait(_)) = target_module.def {\n             self.resolver.session.span_err(directive.span, \"items in traits are not importable.\");\n@@ -598,15 +643,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             return Success(());\n         }\n \n-        // Add to target_module's glob_importers and module_'s resolved_globs\n+        // Add to target_module's glob_importers\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n-        match *module_.resolved_globs.borrow_mut() {\n-            (ref mut public_globs, _) if directive.is_public => public_globs.push(target_module),\n-            (_, ref mut private_globs) => private_globs.push(target_module),\n-        }\n \n         for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+            if let Some(binding) = resolution.borrow().binding() {\n                 if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n                     let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n                 }\n@@ -630,11 +671,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // reporting conflicts, reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n     fn finalize_resolutions(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n         // Since import resolution is finished, globs will not define any more names.\n-        module.public_glob_count.set(0); module.private_glob_count.set(0);\n-        *module.resolved_globs.borrow_mut() = (Vec::new(), Vec::new());\n+        *module.globs.borrow_mut() = Vec::new();\n \n         let mut reexports = Vec::new();\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+            let resolution = resolution.borrow();\n             resolution.report_conflicts(|b1, b2| {\n                 self.resolver.report_conflict(module, name, ns, b1, b2)\n             });"}, {"sha": "4743b779ef63ee825778259a6435ff8c084a302f", "filename": "src/test/compile-fail/issue-32119.rs", "status": "renamed", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd331e16642363c333804fe3322ae6bc0be8fbc/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs?ref=7fd331e16642363c333804fe3322ae6bc0be8fbc", "patch": "@@ -9,15 +9,20 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n-#![allow(unused_imports)]\n \n-pub type Type = i32;\n+pub type T = ();\n+mod foo { pub use super::T; }\n+mod bar { pub use super::T; }\n \n-mod one { use super::Type; }\n-pub use self::one::*;\n+pub use foo::*;\n+pub use bar::*;\n \n-mod two { use super::Type; }\n-pub use self::two::*;\n+mod baz {\n+    pub type T = ();\n+    mod foo { pub use super::T as S; }\n+    mod bar { pub use super::foo::S as T; }\n+    pub use self::bar::*;\n+}\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail/issue-32089.rs"}]}