{"sha": "5f1a0afd22c7f1e26782467503d32d026c55fc0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMWEwYWZkMjJjN2YxZTI2NzgyNDY3NTAzZDMyZDAyNmM1NWZjMGM=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-10-21T01:46:04Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-11-03T14:03:21Z"}, "message": "Allow foreign exceptions to unwind through Rust code", "tree": {"sha": "7e7fc14e9dadb4770e40294ec56cdc54642e7db4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e7fc14e9dadb4770e40294ec56cdc54642e7db4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f1a0afd22c7f1e26782467503d32d026c55fc0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1a0afd22c7f1e26782467503d32d026c55fc0c", "html_url": "https://github.com/rust-lang/rust/commit/5f1a0afd22c7f1e26782467503d32d026c55fc0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f1a0afd22c7f1e26782467503d32d026c55fc0c/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a8bb3a26e8a058be64a0d778b3b168bc9b74caa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a8bb3a26e8a058be64a0d778b3b168bc9b74caa", "html_url": "https://github.com/rust-lang/rust/commit/9a8bb3a26e8a058be64a0d778b3b168bc9b74caa"}], "stats": {"total": 589, "additions": 333, "deletions": 256}, "files": [{"sha": "60fdc6c7b69bad11ebfac5f42d9b87fb3221631e", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -249,9 +249,8 @@ the source code.\n - Runtime\n   - `start`: `libstd/rt.rs`\n   - `eh_personality`: `libpanic_unwind/emcc.rs` (EMCC)\n-  - `eh_personality`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_personality`: `libpanic_unwind/gcc.rs` (GNU)\n   - `eh_personality`: `libpanic_unwind/seh.rs` (SEH)\n-  - `eh_unwind_resume`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n   - `eh_unwind_resume`: `libpanic_unwind/gcc.rs` (GCC)\n   - `msvc_try_filter`: `libpanic_unwind/seh.rs` (SEH)\n   - `panic`: `libcore/panicking.rs`"}, {"sha": "1e9e7e4b8359ce393f72d5e7ac32e61708e4d93c", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -51,7 +51,7 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>, foreign_exception: bool)\n     -> Result<EHAction, ()>\n {\n     if lsda.is_null() {\n@@ -96,7 +96,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n                     return Ok(EHAction::None)\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return Ok(interpret_cs_action(cs_action, lpad))\n+                    return Ok(interpret_cs_action(cs_action, lpad, foreign_exception))\n                 }\n             }\n         }\n@@ -121,16 +121,23 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return Ok(interpret_cs_action(cs_action, lpad))\n+                return Ok(interpret_cs_action(cs_action, lpad, foreign_exception))\n             }\n         }\n     }\n }\n \n-fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n+fn interpret_cs_action(cs_action: u64, lpad: usize, foreign_exception: bool) -> EHAction {\n     if cs_action == 0 {\n+        // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n+        // for both Rust panics and foriegn exceptions.\n         EHAction::Cleanup(lpad)\n+    } else if foreign_exception {\n+        // catch_unwind should not catch foreign exceptions, only Rust panics.\n+        // Instead just continue unwinding.\n+        EHAction::None\n     } else {\n+        // Stop unwinding Rust panics at catch_unwind.\n         EHAction::Catch(lpad)\n     }\n }"}, {"sha": "4f572fe21b30baeb36ded4232fba107fdc38465e", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 160, "deletions": 117, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -133,133 +133,176 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n \n-// The personality routine for most of our targets, except ARM, which has a slightly different ABI\n-// (however, iOS goes here as it uses SjLj unwinding).  Also, the 64-bit Windows implementation\n-// lives in seh64_gnu.rs\n-#[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\"))))]\n-#[lang = \"eh_personality\"]\n-#[no_mangle]\n-#[allow(unused)]\n-unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n-                                         actions: uw::_Unwind_Action,\n-                                         exception_class: uw::_Unwind_Exception_Class,\n-                                         exception_object: *mut uw::_Unwind_Exception,\n-                                         context: *mut uw::_Unwind_Context)\n-                                         -> uw::_Unwind_Reason_Code {\n-    if version != 1 {\n-        return uw::_URC_FATAL_PHASE1_ERROR;\n-    }\n-    let eh_action = match find_eh_action(context) {\n-        Ok(action) => action,\n-        Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n-    };\n-    if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n-        match eh_action {\n-            EHAction::None |\n-            EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n-        }\n-    } else {\n-        match eh_action {\n-            EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Cleanup(lpad) |\n-            EHAction::Catch(lpad) => {\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                uw::_Unwind_SetIP(context, lpad);\n-                uw::_URC_INSTALL_CONTEXT\n-            }\n-            EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n-        }\n-    }\n-}\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"netbsd\")))] {\n+        // ARM EHABI personality routine.\n+        // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n+        //\n+        // iOS uses the default routine instead since it uses SjLj unwinding.\n+        #[lang = \"eh_personality\"]\n+        #[no_mangle]\n+        unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n+                                                 exception_object: *mut uw::_Unwind_Exception,\n+                                                 context: *mut uw::_Unwind_Context)\n+                                                 -> uw::_Unwind_Reason_Code {\n+            let state = state as c_int;\n+            let action = state & uw::_US_ACTION_MASK as c_int;\n+            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+                // Backtraces on ARM will call the personality routine with\n+                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+                // we want to continue unwinding the stack, otherwise all our backtraces\n+                // would end at __rust_try\n+                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+                    return continue_unwind(exception_object, context);\n+                }\n+                true\n+            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+                false\n+            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+                return continue_unwind(exception_object, context);\n+            } else {\n+                return uw::_URC_FAILURE;\n+            };\n \n-// ARM EHABI personality routine.\n-// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"netbsd\")))]\n-#[lang = \"eh_personality\"]\n-#[no_mangle]\n-unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                         exception_object: *mut uw::_Unwind_Exception,\n-                                         context: *mut uw::_Unwind_Context)\n-                                         -> uw::_Unwind_Reason_Code {\n-    let state = state as c_int;\n-    let action = state & uw::_US_ACTION_MASK as c_int;\n-    let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n-        // Backtraces on ARM will call the personality routine with\n-        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-        // we want to continue unwinding the stack, otherwise all our backtraces\n-        // would end at __rust_try\n-        if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-            return continue_unwind(exception_object, context);\n-        }\n-        true\n-    } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n-        false\n-    } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n-        return continue_unwind(exception_object, context);\n-    } else {\n-        return uw::_URC_FAILURE;\n-    };\n+            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+            // and LSDA pointers, however ARM EHABI places them into the exception object.\n+            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+            // take only the context pointer, GCC personality routines stash a pointer to\n+            // exception_object in the context, using location reserved for ARM's\n+            // \"scratch register\" (r12).\n+            uw::_Unwind_SetGR(context,\n+                              uw::UNWIND_POINTER_REG,\n+                              exception_object as uw::_Unwind_Ptr);\n+            // ...A more principled approach would be to provide the full definition of ARM's\n+            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n+            // directly, bypassing DWARF compatibility functions.\n \n-    // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n-    // and LSDA pointers, however ARM EHABI places them into the exception object.\n-    // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n-    // take only the context pointer, GCC personality routines stash a pointer to exception_object\n-    // in the context, using location reserved for ARM's \"scratch register\" (r12).\n-    uw::_Unwind_SetGR(context,\n-                      uw::UNWIND_POINTER_REG,\n-                      exception_object as uw::_Unwind_Ptr);\n-    // ...A more principled approach would be to provide the full definition of ARM's\n-    // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n-    // bypassing DWARF compatibility functions.\n+            let exception_class = (*exception_object).exception_class;\n+            let foreign_exception = exception_class != rust_exception_class();\n+            let eh_action = match find_eh_action(context, foreign_exception) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FAILURE,\n+            };\n+            if search_phase {\n+                match eh_action {\n+                    EHAction::None |\n+                    EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n+                    EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) |\n+                    EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n+                                          exception_object as uintptr_t);\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        return uw::_URC_INSTALL_CONTEXT;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            }\n \n-    let eh_action = match find_eh_action(context) {\n-        Ok(action) => action,\n-        Err(_) => return uw::_URC_FAILURE,\n-    };\n-    if search_phase {\n-        match eh_action {\n-            EHAction::None |\n-            EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n-            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => return uw::_URC_FAILURE,\n+            // On ARM EHABI the personality routine is responsible for actually\n+            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+            unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code {\n+                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+                    uw::_URC_CONTINUE_UNWIND\n+                } else {\n+                    uw::_URC_FAILURE\n+                }\n+            }\n+            // defined in libgcc\n+            extern \"C\" {\n+                fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code;\n+            }\n         }\n     } else {\n-        match eh_action {\n-            EHAction::None => return continue_unwind(exception_object, context),\n-            EHAction::Cleanup(lpad) |\n-            EHAction::Catch(lpad) => {\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                uw::_Unwind_SetIP(context, lpad);\n-                return uw::_URC_INSTALL_CONTEXT;\n+        // Default personality routine, which is used directly on most targets\n+        // and indirectly on Windows x86_64 via SEH.\n+        unsafe extern \"C\" fn rust_eh_personality_impl(version: c_int,\n+                                                      actions: uw::_Unwind_Action,\n+                                                      exception_class: uw::_Unwind_Exception_Class,\n+                                                      exception_object: *mut uw::_Unwind_Exception,\n+                                                      context: *mut uw::_Unwind_Context)\n+                                                      -> uw::_Unwind_Reason_Code {\n+            if version != 1 {\n+                return uw::_URC_FATAL_PHASE1_ERROR;\n+            }\n+            let foreign_exception = exception_class != rust_exception_class();\n+            let eh_action = match find_eh_action(context, foreign_exception) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+            };\n+            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+                match eh_action {\n+                    EHAction::None |\n+                    EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) |\n+                    EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t);\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        uw::_URC_INSTALL_CONTEXT\n+                    }\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n+                }\n             }\n-            EHAction::Terminate => return uw::_URC_FAILURE,\n         }\n-    }\n \n-    // On ARM EHABI the personality routine is responsible for actually\n-    // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n-    unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n-                              context: *mut uw::_Unwind_Context)\n-                              -> uw::_Unwind_Reason_Code {\n-        if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n-            uw::_URC_CONTINUE_UNWIND\n-        } else {\n-            uw::_URC_FAILURE\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n+                // handler data (aka LSDA) uses GCC-compatible encoding.\n+                #[lang = \"eh_personality\"]\n+                #[no_mangle]\n+                #[allow(nonstandard_style)]\n+                unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut uw::EXCEPTION_RECORD,\n+                        establisherFrame: uw::LPVOID,\n+                        contextRecord: *mut uw::CONTEXT,\n+                        dispatcherContext: *mut uw::DISPATCHER_CONTEXT)\n+                        -> uw::EXCEPTION_DISPOSITION {\n+                    uw::_GCC_specific_handler(exceptionRecord,\n+                                             establisherFrame,\n+                                             contextRecord,\n+                                             dispatcherContext,\n+                                             rust_eh_personality_impl)\n+                }\n+            } else {\n+                // The personality routine for most of our targets.\n+                #[lang = \"eh_personality\"]\n+                #[no_mangle]\n+                unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                        actions: uw::_Unwind_Action,\n+                        exception_class: uw::_Unwind_Exception_Class,\n+                        exception_object: *mut uw::_Unwind_Exception,\n+                        context: *mut uw::_Unwind_Context)\n+                        -> uw::_Unwind_Reason_Code {\n+                    rust_eh_personality_impl(version,\n+                                             actions,\n+                                             exception_class,\n+                                             exception_object,\n+                                             context)\n+                }\n+            }\n         }\n     }\n-    // defined in libgcc\n-    extern \"C\" {\n-        fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                              context: *mut uw::_Unwind_Context)\n-                              -> uw::_Unwind_Reason_Code;\n-    }\n }\n \n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context, foreign_exception: bool)\n     -> Result<EHAction, ()>\n {\n     let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n@@ -273,11 +316,11 @@ unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n         get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n         get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n     };\n-    eh::find_eh_action(lsda, &eh_context)\n+    eh::find_eh_action(lsda, &eh_context, foreign_exception)\n }\n \n // See docs in the `unwind` module.\n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+#[cfg(all(target_os=\"windows\", any(target_arch = \"x86\", target_arch = \"x86_64\"), target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind(allowed)]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {"}, {"sha": "50d067b56e442093d2ec42684ac6dc669264eeeb", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -5,9 +5,8 @@\n //! essentially gets categorized into three buckets currently:\n //!\n //! 1. MSVC targets use SEH in the `seh.rs` file.\n-//! 2. The 64-bit MinGW target half-uses SEH and half-use gcc-like information\n-//!    in the `seh64_gnu.rs` module.\n-//! 3. All other targets use libunwind/libgcc in the `gcc/mod.rs` module.\n+//! 2. Emscripten uses C++ exceptions in the `emcc.rs` file.\n+//! 3. All other targets use libunwind/libgcc in the `gcc.rs` file.\n //!\n //! More documentation about each implementation can be found in the respective\n //! module.\n@@ -52,9 +51,6 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_env = \"msvc\")] {\n         #[path = \"seh.rs\"]\n         mod imp;\n-    } else if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n-        #[path = \"seh64_gnu.rs\"]\n-        mod imp;\n     } else {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n         #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]"}, {"sha": "16b699a44379979f7eda4031937e072e7b8d4d8c", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9a8bb3a26e8a058be64a0d778b3b168bc9b74caa/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a8bb3a26e8a058be64a0d778b3b168bc9b74caa/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=9a8bb3a26e8a058be64a0d778b3b168bc9b74caa", "patch": "@@ -1,127 +0,0 @@\n-//! Unwinding implementation of top of native Win64 SEH,\n-//! however the unwind handler data (aka LSDA) uses GCC-compatible encoding.\n-\n-#![allow(nonstandard_style)]\n-#![allow(private_no_mangle_fns)]\n-\n-use alloc::boxed::Box;\n-\n-use core::any::Any;\n-use core::intrinsics;\n-use core::ptr;\n-use crate::dwarf::eh::{EHContext, EHAction, find_eh_action};\n-use crate::windows as c;\n-\n-// Define our exception codes:\n-// according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,\n-//    [31:30] = 3 (error), 2 (warning), 1 (info), 0 (success)\n-//    [29]    = 1 (user-defined)\n-//    [28]    = 0 (reserved)\n-// we define bits:\n-//    [24:27] = type\n-//    [0:23]  = magic\n-const ETYPE: c::DWORD = 0b1110_u32 << 28;\n-const MAGIC: c::DWORD = 0x525354; // \"RST\"\n-\n-const RUST_PANIC: c::DWORD = ETYPE | (1 << 24) | MAGIC;\n-\n-#[repr(C)]\n-struct PanicData {\n-    data: Box<dyn Any + Send>,\n-}\n-\n-pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n-    let panic_ctx = Box::new(PanicData { data });\n-    let params = [Box::into_raw(panic_ctx) as c::ULONG_PTR];\n-    c::RaiseException(RUST_PANIC,\n-                      c::EXCEPTION_NONCONTINUABLE,\n-                      params.len() as c::DWORD,\n-                      &params as *const c::ULONG_PTR);\n-    u32::max_value()\n-}\n-\n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n-\n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n-    panic_ctx.data\n-}\n-\n-// SEH doesn't support resuming unwinds after calling a landing pad like\n-// libunwind does. For this reason, MSVC compiler outlines landing pads into\n-// separate functions that can be called directly from the personality function\n-// but are nevertheless able to find and modify stack frame of the \"parent\"\n-// function.\n-//\n-// Since this cannot be done with libdwarf-style landing pads,\n-// rust_eh_personality instead catches RUST_PANICs, runs the landing pad, then\n-// reraises the exception.\n-//\n-// Note that it makes certain assumptions about the exception:\n-//\n-// 1. That RUST_PANIC is non-continuable, so no lower stack frame may choose to\n-//    resume execution.\n-// 2. That the first parameter of the exception is a pointer to an extra data\n-//    area (PanicData).\n-// Since these assumptions do not generally hold true for foreign exceptions\n-// (system faults, C++ exceptions, etc), we make no attempt to invoke our\n-// landing pads (and, thus, destructors!) for anything other than RUST_PANICs.\n-// This is considered acceptable, because the behavior of throwing exceptions\n-// through a C ABI boundary is undefined.\n-\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut c::EXCEPTION_RECORD,\n-                                         establisherFrame: c::LPVOID,\n-                                         contextRecord: *mut c::CONTEXT,\n-                                         dispatcherContext: *mut c::DISPATCHER_CONTEXT)\n-                                         -> c::EXCEPTION_DISPOSITION {\n-    let er = &*exceptionRecord;\n-    let dc = &*dispatcherContext;\n-\n-    if er.ExceptionFlags & c::EXCEPTION_UNWIND == 0 {\n-        // we are in the dispatch phase\n-        if er.ExceptionCode == RUST_PANIC {\n-            if let Some(lpad) = find_landing_pad(dc) {\n-                c::RtlUnwindEx(establisherFrame,\n-                               lpad as c::LPVOID,\n-                               exceptionRecord,\n-                               er.ExceptionInformation[0] as c::LPVOID, // pointer to PanicData\n-                               contextRecord,\n-                               dc.HistoryTable);\n-            }\n-        }\n-    }\n-    c::ExceptionContinueSearch\n-}\n-\n-#[lang = \"eh_unwind_resume\"]\n-#[unwind(allowed)]\n-unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n-    let params = [panic_ctx as c::ULONG_PTR];\n-    c::RaiseException(RUST_PANIC,\n-                      c::EXCEPTION_NONCONTINUABLE,\n-                      params.len() as c::DWORD,\n-                      &params as *const c::ULONG_PTR);\n-    intrinsics::abort();\n-}\n-\n-unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n-    let eh_ctx = EHContext {\n-        // The return address points 1 byte past the call instruction,\n-        // which could be in the next IP range in LSDA range table.\n-        ip: dc.ControlPc as usize - 1,\n-        func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n-        get_text_start: &|| dc.ImageBase as usize,\n-        get_data_start: &|| unimplemented!(),\n-    };\n-    match find_eh_action(dc.HandlerData, &eh_ctx) {\n-        Err(_) |\n-        Ok(EHAction::None) => None,\n-        Ok(EHAction::Cleanup(lpad)) |\n-        Ok(EHAction::Catch(lpad)) => Some(lpad),\n-        Ok(EHAction::Terminate) => intrinsics::abort(),\n-    }\n-}"}, {"sha": "0b39503c0d03453b08da3bf2a5f0420b6433747b", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -244,3 +244,30 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     }\n }\n } // cfg_if!\n+\n+cfg_if::cfg_if! {\n+if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+    // We declare these as opaque types. This is fine since you just need to\n+    // pass them to _GCC_specific_handler and forget about them.\n+    pub enum EXCEPTION_RECORD {}\n+    pub type LPVOID = *mut c_void;\n+    pub enum CONTEXT {}\n+    pub enum DISPATCHER_CONTEXT {}\n+    pub type EXCEPTION_DISPOSITION = c_int;\n+    type PersonalityFn = unsafe extern \"C\" fn(version: c_int,\n+                                              actions: _Unwind_Action,\n+                                              exception_class: _Unwind_Exception_Class,\n+                                              exception_object: *mut _Unwind_Exception,\n+                                              context: *mut _Unwind_Context)\n+                                              -> _Unwind_Reason_Code;\n+\n+    extern \"C\" {\n+        pub fn _GCC_specific_handler(exceptionRecord: *mut EXCEPTION_RECORD,\n+                                establisherFrame: LPVOID,\n+                                contextRecord: *mut CONTEXT,\n+                                dispatcherContext: *mut DISPATCHER_CONTEXT,\n+                                personality: PersonalityFn)\n+                                -> EXCEPTION_DISPOSITION;\n+    }\n+}\n+} // cfg_if!"}, {"sha": "fd15db9f15176e25e21eb79337f438cbdff5401a", "filename": "src/test/run-make-fulldeps/foreign-exceptions/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all: foo\n+\t$(call RUN,foo)\n+\n+foo: foo.rs $(call NATIVE_STATICLIB,foo)\n+\t$(RUSTC) $< -lfoo $(EXTRACXXFLAGS)\n+\n+$(TMPDIR)/libfoo.o: foo.cpp\n+\t$(call COMPILE_OBJ_CXX,$@,$<)"}, {"sha": "9a6fab49f496fb1061e3dce2ef3bb493481635b2", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.cpp", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -0,0 +1,59 @@\n+#include <assert.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+void println(const char* s) {\n+    puts(s);\n+    fflush(stdout);\n+}\n+\n+struct exception {};\n+\n+struct drop_check {\n+    bool* ok;\n+    ~drop_check() {\n+        println(\"~drop_check\");\n+\n+        if (ok)\n+            *ok = true;\n+    }\n+};\n+\n+extern \"C\" {\n+    void rust_catch_callback(void (*cb)(), bool* rust_ok);\n+\n+    static void callback() {\n+        println(\"throwing C++ exception\");\n+        throw exception();\n+    }\n+\n+    void throw_cxx_exception() {\n+        bool rust_ok = false;\n+        try {\n+            rust_catch_callback(callback, &rust_ok);\n+            assert(false && \"unreachable\");\n+        } catch (exception e) {\n+            println(\"caught C++ exception\");\n+            assert(rust_ok);\n+            return;\n+        }\n+        assert(false && \"did not catch thrown C++ exception\");\n+    }\n+\n+    void cxx_catch_callback(void (*cb)(), bool* cxx_ok) {\n+        drop_check x;\n+        x.ok = NULL;\n+        try {\n+            cb();\n+        } catch (exception e) {\n+            assert(false && \"shouldn't be able to catch a rust panic\");\n+        } catch (...) {\n+            println(\"caught foreign exception in catch (...)\");\n+            // Foreign exceptions are caught by catch (...). We only set the ok\n+            // flag if we successfully caught the panic. The destructor of\n+            // drop_check will then set the flag to true if it is executed.\n+            x.ok = cxx_ok;\n+            throw;\n+        }\n+    }\n+}"}, {"sha": "83adf000d9efe2776b55adbf680b911e406d4c09", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1a0afd22c7f1e26782467503d32d026c55fc0c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs?ref=5f1a0afd22c7f1e26782467503d32d026c55fc0c", "patch": "@@ -0,0 +1,63 @@\n+// Tests that C++ exceptions can unwind through Rust code, run destructors and\n+// are ignored by catch_unwind. Also tests that Rust panics can unwind through\n+// C++ code.\n+\n+#![feature(unwind_attributes)]\n+\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+struct DropCheck<'a>(&'a mut bool);\n+impl<'a> Drop for DropCheck<'a> {\n+    fn drop(&mut self) {\n+        println!(\"DropCheck::drop\");\n+        *self.0 = true;\n+    }\n+}\n+\n+extern \"C\" {\n+    fn throw_cxx_exception();\n+\n+    #[unwind(allowed)]\n+    fn cxx_catch_callback(cb: extern \"C\" fn(), ok: *mut bool);\n+}\n+\n+#[no_mangle]\n+#[unwind(allowed)]\n+extern \"C\" fn rust_catch_callback(cb: extern \"C\" fn(), rust_ok: &mut bool) {\n+    let _caught_unwind = catch_unwind(AssertUnwindSafe(|| {\n+        let _drop = DropCheck(rust_ok);\n+        cb();\n+        unreachable!(\"should have unwound instead of returned\");\n+    }));\n+    unreachable!(\"catch_unwind should not have caught foreign exception\");\n+}\n+\n+fn throw_rust_panic() {\n+    #[unwind(allowed)]\n+    extern \"C\" fn callback() {\n+        println!(\"throwing rust panic\");\n+        panic!(1234i32);\n+    }\n+\n+    let mut dropped = false;\n+    let mut cxx_ok = false;\n+    let caught_unwind = catch_unwind(AssertUnwindSafe(|| {\n+        let _drop = DropCheck(&mut dropped);\n+        unsafe {\n+            cxx_catch_callback(callback, &mut cxx_ok);\n+        }\n+        unreachable!(\"should have unwound instead of returned\");\n+    }));\n+    println!(\"caught rust panic\");\n+    assert!(dropped);\n+    assert!(caught_unwind.is_err());\n+    let panic_obj = caught_unwind.unwrap_err();\n+    let panic_int = *panic_obj.downcast_ref::<i32>().unwrap();\n+    assert_eq!(panic_int, 1234);\n+    assert!(cxx_ok);\n+}\n+\n+fn main() {\n+    unsafe { throw_cxx_exception() };\n+    throw_rust_panic();\n+}"}]}