{"sha": "d7b0eb0f39861c47e2dce615197039e197417f17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YjBlYjBmMzk4NjFjNDdlMmRjZTYxNTE5NzAzOWUxOTc0MTdmMTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-10T19:53:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-01T14:42:37Z"}, "message": "build up a set of node-ids that we can construct def-ids from", "tree": {"sha": "967799d797ab69b3d091f00775f789b86d309f6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967799d797ab69b3d091f00775f789b86d309f6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7b0eb0f39861c47e2dce615197039e197417f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b0eb0f39861c47e2dce615197039e197417f17", "html_url": "https://github.com/rust-lang/rust/commit/d7b0eb0f39861c47e2dce615197039e197417f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7b0eb0f39861c47e2dce615197039e197417f17/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0dc2d9a292189f1642f1d856203509a3019225b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0dc2d9a292189f1642f1d856203509a3019225b", "html_url": "https://github.com/rust-lang/rust/commit/a0dc2d9a292189f1642f1d856203509a3019225b"}], "stats": {"total": 608, "additions": 371, "deletions": 237}, "files": [{"sha": "0dd51b4ec8a5db56e55efb3d965ea275ae17da3f", "filename": "src/librustc/front/map/collector.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -0,0 +1,292 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use super::MapEntry::*;\n+\n+use rustc_front::hir::*;\n+use rustc_front::util;\n+use rustc_front::visit::{self, Visitor};\n+use std::iter::repeat;\n+use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::codemap::Span;\n+use util::nodemap::NodeSet;\n+\n+/// A Visitor that walks over an AST and collects Node's into an AST\n+/// Map.\n+pub struct NodeCollector<'ast> {\n+    pub map: Vec<MapEntry<'ast>>,\n+    pub definitions_map: NodeSet,\n+    pub parent_node: NodeId,\n+}\n+\n+impl<'ast> NodeCollector<'ast> {\n+    pub fn root() -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            map: vec![],\n+            definitions_map: NodeSet(),\n+            parent_node: CRATE_NODE_ID,\n+        };\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+        collector.create_def(CRATE_NODE_ID);\n+        collector.create_def(DUMMY_NODE_ID);\n+        collector\n+    }\n+\n+    pub fn extend(parent: &'ast InlinedParent,\n+                  parent_node: NodeId,\n+                  map: Vec<MapEntry<'ast>>,\n+                  definitions_map: NodeSet)\n+                  -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            map: map,\n+            definitions_map: definitions_map,\n+            parent_node: parent_node\n+        };\n+        collector.insert_entry(parent_node, RootInlinedParent(parent));\n+\n+        collector\n+    }\n+\n+    fn create_def(&mut self, node: NodeId) {\n+        let is_new = self.definitions_map.insert(node);\n+        assert!(is_new,\n+                \"two entries for node id `{}` -- previous is `{:?}`\",\n+                node, node);\n+    }\n+\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n+        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n+        let len = self.map.len();\n+        if id as usize >= len {\n+            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        }\n+        self.map[id as usize] = entry;\n+    }\n+\n+    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+        let entry = MapEntry::from_node(self.parent_node, node);\n+        self.insert_entry(id, entry);\n+    }\n+\n+    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n+        for a in &decl.inputs {\n+            self.insert(a.id, NodeArg(&*a.pat));\n+        }\n+    }\n+}\n+\n+impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        self.insert(i.id, NodeItem(i));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n+\n+        self.create_def(i.id);\n+\n+        match i.node {\n+            ItemImpl(..) => { }\n+            ItemEnum(ref enum_definition, _) => {\n+                for v in &enum_definition.variants {\n+                    self.insert(v.node.id, NodeVariant(&**v));\n+                    self.create_def(v.node.id);\n+\n+                    match v.node.kind {\n+                        TupleVariantKind(ref args) => {\n+                            for arg in args {\n+                                self.create_def(arg.id);\n+                            }\n+                        }\n+                        StructVariantKind(ref def) => {\n+                            for field in &def.fields {\n+                                self.create_def(field.node.id);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            ItemForeignMod(..) => {}\n+            ItemStruct(ref struct_def, _) => {\n+                // If this is a tuple-like struct, register the constructor.\n+                match struct_def.ctor_id {\n+                    Some(ctor_id) => {\n+                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n+                        self.create_def(ctor_id);\n+                    }\n+                    None => {}\n+                }\n+\n+                for field in &struct_def.fields {\n+                    self.create_def(field.node.id);\n+                }\n+            }\n+            ItemTrait(_, _, ref bounds, _) => {\n+                for b in bounds.iter() {\n+                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                    }\n+                }\n+            }\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths {\n+                            self.insert(path.node.id(), NodeItem(i));\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_item(self, i);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n+        self.create_def(foreign_item.id);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = foreign_item.id;\n+        visit::walk_foreign_item(self, foreign_item);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id);\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n+        }\n+\n+        visit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        self.insert(ti.id, NodeTraitItem(ti));\n+        self.create_def(ti.id);\n+\n+        match ti.node {\n+            ConstTraitItem(_, Some(ref expr)) => {\n+                self.create_def(expr.id);\n+            }\n+            _ => { }\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n+        visit::walk_trait_item(self, ti);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        self.insert(ii.id, NodeImplItem(ii));\n+        self.create_def(ii.id);\n+\n+        match ii.node {\n+            ConstImplItem(_, ref expr) => {\n+                self.create_def(expr.id);\n+            }\n+            _ => { }\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n+        visit::walk_impl_item(self, ii);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let maybe_binding = match pat.node {\n+            PatIdent(..) => true,\n+            _ => false\n+        };\n+\n+        self.insert(pat.id,\n+                    if maybe_binding {NodeLocal(pat)} else {NodePat(pat)});\n+\n+        if maybe_binding {\n+            self.create_def(pat.id);\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = pat.id;\n+        visit::walk_pat(self, pat);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.insert(expr.id, NodeExpr(expr));\n+\n+        match expr.node {\n+            ExprClosure(..) => self.create_def(expr.id),\n+            _ => (),\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = expr.id;\n+        visit::walk_expr(self, expr);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        let id = util::stmt_id(stmt);\n+        self.insert(id, NodeStmt(stmt));\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n+        visit::walk_stmt(self, stmt);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n+        self.visit_fn_decl(fd);\n+        visit::walk_fn(self, fk, fd, b, s);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = ty.id;\n+        match ty.node {\n+            TyBareFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.insert(block.id, NodeBlock(block));\n+        let parent_node = self.parent_node;\n+        self.parent_node = block.id;\n+        visit::walk_block(self, block);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        self.insert(lifetime.id, NodeLifetime(lifetime));\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id);\n+        self.visit_lifetime(&def.lifetime);\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id);\n+    }\n+}\n+"}, {"sha": "0486fd3a0d1bb1cf9d2c79ff6ec7cb9132444e2f", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 44, "deletions": 214, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -11,32 +11,34 @@\n pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n+use self::collector::NodeCollector;\n \n use metadata::cstore::LOCAL_CRATE;\n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n+use util::nodemap::NodeSet;\n \n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n use rustc_front::hir::*;\n use rustc_front::fold::Folder;\n-use rustc_front::visit::{self, Visitor};\n-use rustc_front::util;\n+use rustc_front::visit;\n use rustc_front::print::pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n use std::io;\n-use std::iter::{self, repeat};\n+use std::iter;\n use std::mem;\n use std::slice;\n \n pub mod blocks;\n+mod collector;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum PathElem {\n@@ -131,7 +133,7 @@ pub enum Node<'ast> {\n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-enum MapEntry<'ast> {\n+pub enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n@@ -264,22 +266,46 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry<'ast>>>\n+    map: RefCell<Vec<MapEntry<'ast>>>,\n+\n+    definitions_map: RefCell<NodeSet>,\n }\n \n impl<'ast> Map<'ast> {\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n-        DefId::xxx_local(node)\n+        self.opt_local_def_id(node).unwrap_or_else(|| {\n+            panic!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n+                   node, self.find_entry(node))\n+        })\n+    }\n+\n+    pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n+        if self.definitions_map.borrow().contains(&node) {\n+            Some(DefId::xxx_local(node))\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n+            assert!(self.definitions_map.borrow().contains(&def_id.xxx_node));\n             Some(def_id.xxx_node)\n         } else {\n             None\n         }\n     }\n \n+    /// for default methods, we create a fake node-id; this method\n+    /// adds that fake node-id to the def-id tables\n+    pub fn synthesize_default_method_def_id(&self,\n+                                            _impl_def_id: DefId,\n+                                            new_method_id: NodeId)\n+                                            -> DefId {\n+        self.definitions_map.borrow_mut().insert(new_method_id);\n+        DefId::xxx_local(new_method_id)\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.borrow().len()\n     }\n@@ -762,194 +788,10 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-/// A Visitor that walks over an AST and collects Node's into an AST Map.\n-struct NodeCollector<'ast> {\n-    map: Vec<MapEntry<'ast>>,\n-    parent_node: NodeId,\n-}\n-\n-impl<'ast> NodeCollector<'ast> {\n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n-        let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n-        }\n-        self.map[id as usize] = entry;\n-    }\n-\n-    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n-        self.insert_entry(id, entry);\n-    }\n-\n-    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n-        for a in &decl.inputs {\n-            self.insert(a.id, NodeArg(&*a.pat));\n-        }\n-    }\n-}\n-\n-impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n-    fn visit_item(&mut self, i: &'ast Item) {\n-        self.insert(i.id, NodeItem(i));\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n-\n-        match i.node {\n-            ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for ii in impl_items {\n-                    self.insert(ii.id, NodeImplItem(ii));\n-                }\n-            }\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    self.insert(v.node.id, NodeVariant(&**v));\n-                }\n-            }\n-            ItemForeignMod(ref nm) => {\n-                for nitem in &nm.items {\n-                    self.insert(nitem.id, NodeForeignItem(&**nitem));\n-                }\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                match struct_def.ctor_id {\n-                    Some(ctor_id) => {\n-                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n-                    }\n-                    None => {}\n-                }\n-            }\n-            ItemTrait(_, _, ref bounds, ref trait_items) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n-                    }\n-                }\n-\n-                for ti in trait_items {\n-                    self.insert(ti.id, NodeTraitItem(ti));\n-                }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, i);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.insert(ty_param.id, NodeTyParam(ty_param));\n-        }\n-\n-        visit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n-        visit::walk_trait_item(self, ti);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n-\n-        visit::walk_impl_item(self, ii);\n-\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n-        self.insert(pat.id, match pat.node {\n-            // Note: this is at least *potentially* a pattern...\n-            PatIdent(..) => NodeLocal(pat),\n-            _ => NodePat(pat)\n-        });\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = pat.id;\n-        visit::walk_pat(self, pat);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n-        self.insert(expr.id, NodeExpr(expr));\n-        let parent_node = self.parent_node;\n-        self.parent_node = expr.id;\n-        visit::walk_expr(self, expr);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        let id = util::stmt_id(stmt);\n-        self.insert(id, NodeStmt(stmt));\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        visit::walk_stmt(self, stmt);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        self.visit_fn_decl(fd);\n-        visit::walk_fn(self, fk, fd, b, s);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast Ty) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ty.id;\n-        match ty.node {\n-            TyBareFn(ref fd) => {\n-                self.visit_fn_decl(&*fd.decl);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_block(&mut self, block: &'ast Block) {\n-        self.insert(block.id, NodeBlock(block));\n-        let parent_node = self.parent_node;\n-        self.parent_node = block.id;\n-        visit::walk_block(self, block);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n-        self.insert(lifetime.id, NodeLifetime(lifetime));\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n-    let mut collector = NodeCollector {\n-        map: vec![],\n-        parent_node: CRATE_NODE_ID,\n-    };\n-    collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+    let mut collector = NodeCollector::root();\n     visit::walk_crate(&mut collector, &forest.krate);\n-    let map = collector.map;\n+    let NodeCollector { map, definitions_map, .. } = collector;\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -969,7 +811,8 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n \n     Map {\n         forest: forest,\n-        map: RefCell::new(map)\n+        map: RefCell::new(map),\n+        definitions_map: RefCell::new(definitions_map),\n     }\n }\n \n@@ -1001,29 +844,16 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     });\n \n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-    let mut collector = NodeCollector {\n-        map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-        parent_node: ii_parent_id,\n-    };\n-    collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n+    let mut collector =\n+        NodeCollector::extend(ii_parent,\n+                              ii_parent_id,\n+                              mem::replace(&mut *map.map.borrow_mut(), vec![]),\n+                              mem::replace(&mut *map.definitions_map.borrow_mut(), NodeSet()));\n     ii_parent.ii.visit(&mut collector);\n \n-    // Methods get added to the AST map when their impl is visited.  Since we\n-    // don't decode and instantiate the impl, but just the method, we have to\n-    // add it to the table now. Likewise with foreign items.\n-    match ii_parent.ii {\n-        II::Item(_) => {}\n-        II::TraitItem(_, ref ti) => {\n-            collector.insert(ti.id, NodeTraitItem(ti));\n-        }\n-        II::ImplItem(_, ref ii) => {\n-            collector.insert(ii.id, NodeImplItem(ii));\n-        }\n-        II::Foreign(ref i) => {\n-            collector.insert(i.id, NodeForeignItem(i));\n-        }\n-    }\n     *map.map.borrow_mut() = collector.map;\n+    *map.definitions_map.borrow_mut() = collector.definitions_map;\n+\n     &ii_parent.ii\n }\n "}, {"sha": "02bd9951d341a3e0427f7b425e54f54de0921108", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -957,12 +957,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = tcx.map.local_def_id(id);\n-    if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n-        rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n-        })\n+    let opt_def_id = tcx.map.opt_local_def_id(id);\n+    if let Some(lid) = opt_def_id {\n+        if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n+            rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n+                rbml_w.id(id);\n+                rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n+            })\n+        }\n     }\n \n     if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n@@ -1003,18 +1005,22 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&tcx.map.local_def_id(id)) {\n-        rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_closure_type(ecx, closure_type);\n-        })\n+    if let Some(def_id) = opt_def_id {\n+        if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&def_id) {\n+            rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n+                rbml_w.id(id);\n+                rbml_w.emit_closure_type(ecx, closure_type);\n+            })\n+        }\n     }\n \n-    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&tcx.map.local_def_id(id)) {\n-        rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_closure_kind(rbml_w, *closure_kind)\n-        })\n+    if let Some(def_id) = opt_def_id {\n+        if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&def_id) {\n+            rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n+                rbml_w.id(id);\n+                encode_closure_kind(rbml_w, *closure_kind)\n+            })\n+        }\n     }\n \n     if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {"}, {"sha": "de356e54699c182cdfc21776f0023a59e13e1f99", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -27,7 +27,7 @@ use std::fmt;\n use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;\n-use syntax::ast::DUMMY_NODE_ID;\n+use syntax::ast::{CRATE_NODE_ID};\n use rustc_front::hir;\n \n pub fn verbose() -> bool {\n@@ -232,7 +232,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.map.local_def_id(DUMMY_NODE_ID), name)\n+                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID), name)\n             }\n         })\n     }).0;"}, {"sha": "d05b5b3e8606a84e65b7fc1de900264f6a7d8b1f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -248,8 +248,11 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                     return false;\n                 }\n                 let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n-                let def_id = cx.tcx.map.local_def_id(fieldpat.node.pat.id);\n-                def == Some(def::DefLocal(def_id, fieldpat.node.pat.id))\n+                if let Some(def_id) = cx.tcx.map.opt_local_def_id(fieldpat.node.pat.id) {\n+                    def == Some(def::DefLocal(def_id, fieldpat.node.pat.id))\n+                } else {\n+                    false\n+                }\n             });\n             for fieldpat in field_pats {\n                 if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {"}, {"sha": "dab4056b4af8153db5c3b2e8789a5d08f5bed501", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(hir::Public),\n                     stability: None,\n-                    def_id: cx.map.local_def_id(prim.to_node_id()),\n+                    def_id: DefId::xxx_local(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n                 });\n             }"}, {"sha": "264656835a384a649e7f1a157f94c70c1ab6df9a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b0eb0f39861c47e2dce615197039e197417f17/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d7b0eb0f39861c47e2dce615197039e197417f17", "patch": "@@ -62,8 +62,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx_opt().and_then(\n-            |tcx| stability::lookup(tcx, self.cx.map.local_def_id(id)).map(|x| x.clone()))\n+        self.cx.tcx_opt().and_then(|tcx| {\n+            self.cx.map.opt_local_def_id(id)\n+                       .and_then(|def_id| stability::lookup(tcx, def_id))\n+                       .cloned()\n+        })\n     }\n \n     pub fn visit(&mut self, krate: &hir::Crate) {"}]}