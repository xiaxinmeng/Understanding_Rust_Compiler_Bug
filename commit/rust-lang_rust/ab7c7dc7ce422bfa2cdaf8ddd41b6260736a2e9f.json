{"sha": "ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "node_id": "C_kwDOAAsO6NoAKGFiN2M3ZGM3Y2U0MjJiZmEyY2RhZjhkZGQ0MWI2MjYwNzM2YTJlOWY", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-08-24T20:41:51Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-27T18:29:18Z"}, "message": "Migrate more diagnostics in rustc_parse to diagnostic structs", "tree": {"sha": "bda0f9c1e3db30140dc0e39fb8e5f7395728fce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda0f9c1e3db30140dc0e39fb8e5f7395728fce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "html_url": "https://github.com/rust-lang/rust/commit/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d02892acfdb43490db815010d718bd324f853ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d02892acfdb43490db815010d718bd324f853ad", "html_url": "https://github.com/rust-lang/rust/commit/4d02892acfdb43490db815010d718bd324f853ad"}], "stats": {"total": 685, "additions": 465, "deletions": 220}, "files": [{"sha": "2a0d16f58a574e1b293a0b1b24eceb235262aacf", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -71,6 +71,8 @@ parser_field_expression_with_generic = field expressions cannot have generic arg\n parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n \n parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n \n parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n     .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n@@ -161,3 +163,62 @@ parser_use_eq_instead = unexpected `==`\n \n parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n     .suggestion = try using { \"`{}`\" } instead\n+\n+parser_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$typename}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n+\n+parser_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$typename}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n+\n+parser_found_expr_would_be_stmt = expected expression, found `{$token}`\n+    .label = expected expression\n+\n+parser_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n+\n+parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$name}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$name}` is a function, use the arguments directly\n+\n+parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+    .suggestion = wrap the expression in parentheses\n+\n+parser_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n+\n+parser_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+\n+parser_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n+\n+parser_invalid_interpolated_expression = invalid interpolated expression\n+\n+parser_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+parser_octal_float_literal_not_supported = octal float literal is not supported\n+parser_binary_float_literal_not_supported = binary float literal is not supported\n+parser_not_supported = not supported\n+\n+parser_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n+\n+parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter"}, {"sha": "d8e1382d7432a0f8bf9996fe2527c7852fb7a2bd", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 247, "deletions": 3, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -21,6 +21,7 @@ use rustc_errors::{\n };\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n@@ -487,11 +488,24 @@ pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n #[diag(parser::unexpected_token_after_label)]\n-pub(crate) struct UnexpectedTokenAfterLabel(\n+pub(crate) struct UnexpectedTokenAfterLabel {\n     #[primary_span]\n     #[label(parser::unexpected_token_after_label)]\n-    pub Span,\n-);\n+    pub span: Span,\n+    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n+    pub remove_label: Option<Span>,\n+    #[subdiagnostic]\n+    pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n+pub(crate) struct UnexpectedTokenAfterLabelSugg {\n+    #[suggestion_part(code = \"{{ \")]\n+    pub left: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub right: Span,\n+}\n \n #[derive(Diagnostic)]\n #[diag(parser::require_colon_after_labeled_expression)]\n@@ -753,6 +767,236 @@ pub(crate) struct UseEmptyBlockNotSemi {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parser::comparison_interpreted_as_generic)]\n+pub(crate) struct ComparisonInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub comparison: Span,\n+    pub typename: String,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::shift_interpreted_as_generic)]\n+pub(crate) struct ShiftInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub shift: Span,\n+    pub typename: String,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::found_expr_would_be_stmt)]\n+pub(crate) struct FoundExprWouldBeStmt {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub token: String,\n+    #[subdiagnostic]\n+    pub suggestion: ExprParenthesesNeeded,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::leading_plus_not_supported)]\n+pub(crate) struct LeadingPlusNotSupported {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[suggestion_verbose(\n+        parser::suggestion_remove_plus,\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub remove_plus: Option<Span>,\n+    #[subdiagnostic]\n+    pub add_parentheses: Option<ExprParenthesesNeeded>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::parentheses_with_struct_fields)]\n+pub(crate) struct ParenthesesWithStructFields {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub braces_for_struct: BracesForStructLiteral,\n+    #[subdiagnostic]\n+    pub no_fields_for_fn: NoFieldsForFnCall,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n+pub(crate) struct BracesForStructLiteral {\n+    #[suggestion_part(code = \" {{ \")]\n+    pub first: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub second: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n+pub(crate) struct NoFieldsForFnCall {\n+    #[suggestion_part(code = \"\")]\n+    pub fields: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::labeled_loop_in_break)]\n+pub(crate) struct LabeledLoopInBreak {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: LabeledLoopInBreakSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct LabeledLoopInBreakSub {\n+    #[suggestion_part(code = \"(\")]\n+    pub first: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub second: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::array_brackets_instead_of_braces)]\n+pub(crate) struct ArrayBracketsInsteadOfSpaces {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: ArrayBracketsInsteadOfSpacesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n+pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n+    #[suggestion_part(code = \"[\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \"]\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::match_arm_body_without_braces)]\n+pub(crate) struct MatchArmBodyWithoutBraces {\n+    #[primary_span]\n+    #[label(parser::label_statements)]\n+    pub statements: Span,\n+    #[label(parser::label_arrow)]\n+    pub arrow: Span,\n+    pub num_statements: usize,\n+    #[subdiagnostic]\n+    pub sub: MatchArmBodyWithoutBracesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MatchArmBodyWithoutBracesSugg {\n+    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n+    AddBraces {\n+        #[suggestion_part(code = \"{{ \")]\n+        left: Span,\n+        #[suggestion_part(code = \" }}\")]\n+        right: Span,\n+    },\n+    #[suggestion(\n+        parser::suggestion_use_comma_not_semicolon,\n+        code = \",\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    UseComma {\n+        #[primary_span]\n+        semicolon: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::struct_literal_not_allowed_here)]\n+pub(crate) struct StructLiteralNotAllowedHere {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: StructLiteralNotAllowedHereSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct StructLiteralNotAllowedHereSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_interpolated_expression)]\n+pub(crate) struct InvalidInterpolatedExpression {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::hexadecimal_float_literal_not_supported)]\n+pub(crate) struct HexadecimalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::octal_float_literal_not_supported)]\n+pub(crate) struct OctalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::binary_float_literal_not_supported)]\n+pub(crate) struct BinaryFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::non_string_abi_literal)]\n+pub(crate) struct NonStringAbiLiteral {\n+    #[primary_span]\n+    #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::mismatched_closing_delimiter)]\n+pub(crate) struct MismatchedClosingDelimiter {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub delimiter: String,\n+    #[label(parser::label_unmatched)]\n+    pub unmatched: Span,\n+    #[label(parser::label_opening_candidate)]\n+    pub opening_candidate: Option<Span>,\n+    #[label(parser::label_unclosed)]\n+    pub unclosed: Option<Span>,\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped."}, {"sha": "6e77475fbe61fd55281ca503ac4dca7647a0c1f3", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 139, "deletions": 188, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -1,14 +1,19 @@\n use super::diagnostics::{\n-    CatchAfterTry, CommaAfterBaseStruct, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, BracesForStructLiteral,\n+    CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n+    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n     ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n-    FloatLiteralRequiresIntegerPart, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n-    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n-    InvalidComparisonOperatorSub, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n-    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n-    MalformedLoopLabel, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NotAsNegationOperator, NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse,\n-    RequireColonAfterLabeledExpression, SnapshotParser, TildeAsUnaryOperator,\n-    UnexpectedTokenAfterLabel,\n+    FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt, IfExpressionMissingCondition,\n+    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment,\n+    InvalidComparisonOperator, InvalidComparisonOperatorSub, InvalidInterpolatedExpression,\n+    InvalidLogicalOperator, InvalidLogicalOperatorSub, LabeledLoopInBreak, LeftArrowOperator,\n+    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n+    MatchArmBodyWithoutBraces, MissingInInForLoop, MissingInInForLoopSub,\n+    MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n+    NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, SnapshotParser,\n+    StructLiteralNotAllowedHere, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n+    UnexpectedTokenAfterLabelSugg,\n };\n use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n@@ -18,9 +23,11 @@ use super::{\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use crate::parser::diagnostics::{\n-    IntLiteralTooLarge, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n-    InvalidIntLiteralWidth, InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix,\n-    MissingCommaAfterMatchArm,\n+    BinaryFloatLiteralNotSupported, HexadecimalFloatLiteralNotSupported, IntLiteralTooLarge,\n+    InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n+    InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix, LabeledLoopInBreakSub,\n+    LeadingPlusNotSupported, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n+    OctalFloatLiteralNotSupported, StructLiteralNotAllowedHereSugg,\n };\n \n use core::mem;\n@@ -38,6 +45,7 @@ use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::IntoDiagnostic;\n use rustc_errors::{Applicability, Diagnostic, PResult};\n+use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n@@ -421,13 +429,12 @@ impl<'a> Parser<'a> {\n     /// but the next token implies this should be parsed as an expression.\n     /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n     fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n-        let mut err = self.struct_span_err(\n-            self.token.span,\n-            &format!(\"expected expression, found `{}`\", pprust::token_to_string(&self.token),),\n-        );\n-        err.span_label(self.token.span, \"expected expression\");\n-        self.sess.expr_parentheses_needed(&mut err, lhs.span);\n-        err.emit();\n+        self.sess.emit_err(FoundExprWouldBeStmt {\n+            span: self.token.span,\n+            // FIXME(#100717)\n+            token: pprust::token_to_string(&self.token).to_string(),\n+            suggestion: ExprParenthesesNeeded::surrounding(lhs.span),\n+        });\n     }\n \n     /// Possibly translate the current token to an associative operator.\n@@ -578,21 +585,16 @@ impl<'a> Parser<'a> {\n                 make_it!(this, attrs, |this, _| this.parse_borrow_expr(lo))\n             }\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n-                let mut err = this.struct_span_err(lo, \"leading `+` is not supported\");\n-                err.span_label(lo, \"unexpected `+`\");\n+                let mut err =\n+                    LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n \n                 // a block on the LHS might have been intended to be an expression instead\n                 if let Some(sp) = this.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n-                    this.sess.expr_parentheses_needed(&mut err, *sp);\n+                    err.add_parentheses = Some(ExprParenthesesNeeded::surrounding(*sp));\n                 } else {\n-                    err.span_suggestion_verbose(\n-                        lo,\n-                        \"try removing the `+`\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    err.remove_plus = Some(lo);\n                 }\n-                err.emit();\n+                this.sess.emit_err(err);\n \n                 this.bump();\n                 this.parse_prefix_expr(None)\n@@ -755,9 +757,33 @@ impl<'a> Parser<'a> {\n \n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n-                        let (op_noun, op_verb) = match self.token.kind {\n-                            token::Lt => (\"comparison\", \"comparing\"),\n-                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n+                        let typename = pprust::path_to_string(&path);\n+\n+                        let span_after_type = parser_snapshot_after_type.token.span;\n+                        let expr =\n+                            mk_expr(self, lhs, self.mk_ty(path.span, TyKind::Path(None, path)));\n+\n+                        let args_span = self.look_ahead(1, |t| t.span).to(span_after_type);\n+                        let suggestion = ComparisonOrShiftInterpretedAsGenericSugg {\n+                            left: expr.span.shrink_to_lo(),\n+                            right: expr.span.shrink_to_hi(),\n+                        };\n+\n+                        match self.token.kind {\n+                            token::Lt => self.sess.emit_err(ComparisonInterpretedAsGeneric {\n+                                comparison: self.token.span,\n+                                typename,\n+                                args: args_span,\n+                                suggestion,\n+                            }),\n+                            token::BinOp(token::Shl) => {\n+                                self.sess.emit_err(ShiftInterpretedAsGeneric {\n+                                    shift: self.token.span,\n+                                    typename,\n+                                    args: args_span,\n+                                    suggestion,\n+                                })\n+                            }\n                             _ => {\n                                 // We can end up here even without `<` being the next token, for\n                                 // example because `parse_ty_no_plus` returns `Err` on keywords,\n@@ -771,33 +797,7 @@ impl<'a> Parser<'a> {\n                         // Successfully parsed the type path leaving a `<` yet to parse.\n                         type_err.cancel();\n \n-                        // Report non-fatal diagnostics, keep `x as usize` as an expression\n-                        // in AST and continue parsing.\n-                        let msg = format!(\n-                            \"`<` is interpreted as a start of generic arguments for `{}`, not a {}\",\n-                            pprust::path_to_string(&path),\n-                            op_noun,\n-                        );\n-                        let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr =\n-                            mk_expr(self, lhs, self.mk_ty(path.span, TyKind::Path(None, path)));\n-\n-                        self.struct_span_err(self.token.span, &msg)\n-                            .span_label(\n-                                self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                \"interpreted as generic arguments\",\n-                            )\n-                            .span_label(self.token.span, format!(\"not interpreted as {op_noun}\"))\n-                            .multipart_suggestion(\n-                                &format!(\"try {op_verb} the cast value\"),\n-                                vec![\n-                                    (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                    (expr.span.shrink_to_hi(), \")\".to_string()),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n-\n+                        // Keep `x as usize` as an expression in AST and continue parsing.\n                         expr\n                     }\n                     Err(path_err) => {\n@@ -1208,29 +1208,25 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            let replacement_err = self.struct_span_err(\n+                            let mut replacement_err = ParenthesesWithStructFields {\n                                 span,\n-                                \"invalid `struct` delimiters or `fn` call arguments\",\n-                            );\n-                            mem::replace(err, replacement_err).cancel();\n-\n-                            err.multipart_suggestion(\n-                                &format!(\"if `{name}` is a struct, use braces as delimiters\"),\n-                                vec![\n-                                    (open_paren, \" { \".to_string()),\n-                                    (close_paren, \" }\".to_string()),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.multipart_suggestion(\n-                                &format!(\"if `{name}` is a function, use the arguments directly\"),\n-                                fields\n-                                    .into_iter()\n-                                    .map(|field| (field.span.until(field.expr.span), String::new()))\n-                                    .collect(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.emit();\n+                                name,\n+                                braces_for_struct: BracesForStructLiteral {\n+                                    first: open_paren,\n+                                    second: close_paren,\n+                                },\n+                                no_fields_for_fn: NoFieldsForFnCall {\n+                                    fields: fields\n+                                        .into_iter()\n+                                        .map(|field| field.span.until(field.expr.span))\n+                                        .collect(),\n+                                },\n+                            }\n+                            .into_diagnostic(&self.sess.span_diagnostic);\n+                            replacement_err.emit();\n+\n+                            let old_err = mem::replace(err, replacement_err);\n+                            old_err.cancel();\n                         } else {\n                             err.emit();\n                         }\n@@ -1537,15 +1533,19 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            self.sess.emit_err(UnexpectedTokenAfterLabel(self.token.span));\n+            self.sess.emit_err(UnexpectedTokenAfterLabel {\n+                span: self.token.span,\n+                remove_label: None,\n+                enclose_in_block: None,\n+            });\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n-            // FIXME: use UnexpectedTokenAfterLabel, needs multipart suggestions\n-            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-\n-            let mut err = self.struct_span_err(self.token.span, msg);\n-            err.span_label(self.token.span, msg);\n+            let mut err = UnexpectedTokenAfterLabel {\n+                span: self.token.span,\n+                remove_label: None,\n+                enclose_in_block: None,\n+            };\n \n             // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n             let expr = self.parse_expr().map(|expr| {\n@@ -1572,36 +1572,23 @@ impl<'a> Parser<'a> {\n                 // If there are no breaks that may use this label, suggest removing the label and\n                 // recover to the unmodified expression.\n                 if !found_labeled_breaks {\n-                    let msg = \"consider removing the label\";\n-                    err.span_suggestion_verbose(\n-                        lo.until(span),\n-                        msg,\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    err.remove_label = Some(lo.until(span));\n \n                     return expr;\n                 }\n \n-                let sugg_msg = \"consider enclosing expression in a block\";\n-                let suggestions = vec![\n-                    (span.shrink_to_lo(), \"{ \".to_owned()),\n-                    (span.shrink_to_hi(), \" }\".to_owned()),\n-                ];\n-\n-                err.multipart_suggestion_verbose(\n-                    sugg_msg,\n-                    suggestions,\n-                    Applicability::MachineApplicable,\n-                );\n+                err.enclose_in_block = Some(UnexpectedTokenAfterLabelSugg {\n+                    left: span.shrink_to_lo(),\n+                    right: span.shrink_to_hi(),\n+                });\n \n                 // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to suppress future errors about `break 'label`.\n                 let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n                 let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n                 self.mk_expr(span, ExprKind::Block(blk, label))\n             });\n \n-            err.emit();\n+            self.sess.emit_err(err);\n             expr\n         }?;\n \n@@ -1672,19 +1659,13 @@ impl<'a> Parser<'a> {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n             let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n-            self.struct_span_err(\n-                lexpr.span,\n-                \"parentheses are required around this expression to avoid confusion with a labeled break expression\",\n-            )\n-            .multipart_suggestion(\n-                \"wrap the expression in parentheses\",\n-                vec![\n-                    (lexpr.span.shrink_to_lo(), \"(\".to_string()),\n-                    (lexpr.span.shrink_to_hi(), \")\".to_string()),\n-                ],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(LabeledLoopInBreak {\n+                span: lexpr.span,\n+                sub: LabeledLoopInBreakSub {\n+                    first: lexpr.span.shrink_to_lo(),\n+                    second: lexpr.span.shrink_to_hi(),\n+                },\n+            });\n             Some(lexpr)\n         } else if self.token != token::OpenDelim(Delimiter::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n@@ -1756,9 +1737,8 @@ impl<'a> Parser<'a> {\n                 };\n                 if let Some(expr) = expr {\n                     if matches!(expr.kind, ExprKind::Err) {\n-                        let mut err = self\n-                            .diagnostic()\n-                            .struct_span_err(self.token.span, \"invalid interpolated expression\");\n+                        let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                            .into_diagnostic(&self.sess.span_diagnostic);\n                         err.downgrade_to_delayed_bug();\n                         return err;\n                     }\n@@ -1790,7 +1770,10 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.error_float_lits_must_have_int_part(&token);\n+                self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+                    span: token.span,\n+                    correct: pprust::token_to_string(token).into_owned(),\n+                });\n             }\n         }\n \n@@ -1818,13 +1801,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn error_float_lits_must_have_int_part(&self, token: &Token) {\n-        self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n-            span: token.span,\n-            correct: pprust::token_to_string(token).into_owned(),\n-        });\n-    }\n-\n     fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n         // Checks if `s` looks like i32 or u1234 etc.\n         fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -1883,15 +1859,12 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             LitError::NonDecimalFloat(base) => {\n-                let descr = match base {\n-                    16 => \"hexadecimal\",\n-                    8 => \"octal\",\n-                    2 => \"binary\",\n+                match base {\n+                    16 => self.sess.emit_err(HexadecimalFloatLiteralNotSupported { span }),\n+                    8 => self.sess.emit_err(OctalFloatLiteralNotSupported { span }),\n+                    2 => self.sess.emit_err(BinaryFloatLiteralNotSupported { span }),\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(span, &format!(\"{descr} float literal is not supported\"))\n-                    .span_label(span, \"not supported\")\n-                    .emit();\n             }\n             LitError::IntTooLarge => {\n                 self.sess.emit_err(IntLiteralTooLarge { span });\n@@ -1964,14 +1937,13 @@ impl<'a> Parser<'a> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n         match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n-                let hi = snapshot.prev_token.span;\n-                self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n-                    .multipart_suggestion(\n-                        \"to make an array, use square brackets instead of curly braces\",\n-                        vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(ArrayBracketsInsteadOfSpaces {\n+                    span: arr.span,\n+                    sub: ArrayBracketsInsteadOfSpacesSugg {\n+                        left: lo,\n+                        right: snapshot.prev_token.span,\n+                    },\n+                });\n \n                 self.restore_snapshot(snapshot);\n                 Some(self.mk_expr_err(arr.span))\n@@ -2515,39 +2487,22 @@ impl<'a> Parser<'a> {\n         self.bump(); // `;`\n         let mut stmts =\n             vec![self.mk_stmt(first_expr.span, ast::StmtKind::Expr(first_expr.clone()))];\n-        let err = |this: &mut Parser<'_>, stmts: Vec<ast::Stmt>| {\n+        let err = |this: &Parser<'_>, stmts: Vec<ast::Stmt>| {\n             let span = stmts[0].span.to(stmts[stmts.len() - 1].span);\n-            let mut err = this.struct_span_err(span, \"`match` arm body without braces\");\n-            let (these, s, are) =\n-                if stmts.len() > 1 { (\"these\", \"s\", \"are\") } else { (\"this\", \"\", \"is\") };\n-            err.span_label(\n-                span,\n-                &format!(\n-                    \"{these} statement{s} {are} not surrounded by a body\",\n-                    these = these,\n-                    s = s,\n-                    are = are\n-                ),\n-            );\n-            err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n-            if stmts.len() > 1 {\n-                err.multipart_suggestion(\n-                    &format!(\"surround the statement{s} with a body\"),\n-                    vec![\n-                        (span.shrink_to_lo(), \"{ \".to_string()),\n-                        (span.shrink_to_hi(), \" }\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_suggestion(\n-                    semi_sp,\n-                    \"use a comma to end a `match` arm expression\",\n-                    \",\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n+\n+            this.sess.emit_err(MatchArmBodyWithoutBraces {\n+                statements: span,\n+                arrow: arrow_span,\n+                num_statements: stmts.len(),\n+                sub: if stmts.len() > 1 {\n+                    MatchArmBodyWithoutBracesSugg::AddBraces {\n+                        left: span.shrink_to_lo(),\n+                        right: span.shrink_to_hi(),\n+                    }\n+                } else {\n+                    MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n+                },\n+            });\n             this.mk_expr_err(span)\n         };\n         // We might have either a `,` -> `;` typo, or a block without braces. We need\n@@ -2836,23 +2791,19 @@ impl<'a> Parser<'a> {\n             let expr = self.parse_struct_expr(qself.cloned(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n-                self.error_struct_lit_not_allowed_here(path.span, expr.span);\n+                self.sess.emit_err(StructLiteralNotAllowedHere {\n+                    span: expr.span,\n+                    sub: StructLiteralNotAllowedHereSugg {\n+                        left: path.span.shrink_to_lo(),\n+                        right: expr.span.shrink_to_hi(),\n+                    },\n+                });\n             }\n             return Some(expr);\n         }\n         None\n     }\n \n-    fn error_struct_lit_not_allowed_here(&self, lo: Span, sp: Span) {\n-        self.struct_span_err(sp, \"struct literals are not allowed here\")\n-            .multipart_suggestion(\n-                \"surround the struct literal with parentheses\",\n-                vec![(lo.shrink_to_lo(), \"(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-    }\n-\n     pub(super) fn parse_struct_fields(\n         &mut self,\n         pth: ast::Path,"}, {"sha": "f2f6f1feda3f438021e8cce2efa1b2d1ddc02c20", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -32,7 +32,8 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::PResult;\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic,\n+    MultiSpan,\n };\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n@@ -41,6 +42,8 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use std::ops::Range;\n use std::{cmp, mem, slice};\n \n+use self::diagnostics::{MismatchedClosingDelimiter, NonStringAbiLiteral};\n+\n bitflags::bitflags! {\n     struct Restrictions: u8 {\n         const STMT_EXPR         = 1 << 0;\n@@ -1384,14 +1387,7 @@ impl<'a> Parser<'a> {\n             Err(Some(lit)) => match lit.kind {\n                 ast::LitKind::Err => None,\n                 _ => {\n-                    self.struct_span_err(lit.span, \"non-string ABI literal\")\n-                        .span_suggestion(\n-                            lit.span,\n-                            \"specify the ABI with a string literal\",\n-                            \"\\\"C\\\"\",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(NonStringAbiLiteral { span: lit.span });\n                     None\n                 }\n             },\n@@ -1432,25 +1428,18 @@ pub(crate) fn make_unclosed_delims_error(\n     // `None` here means an `Eof` was found. We already emit those errors elsewhere, we add them to\n     // `unmatched_braces` only for error recovery in the `Parser`.\n     let found_delim = unmatched.found_delim?;\n-    let span: MultiSpan = if let Some(sp) = unmatched.unclosed_span {\n-        vec![unmatched.found_span, sp].into()\n-    } else {\n-        unmatched.found_span.into()\n-    };\n-    let mut err = sess.span_diagnostic.struct_span_err(\n-        span,\n-        &format!(\n-            \"mismatched closing delimiter: `{}`\",\n-            pprust::token_kind_to_string(&token::CloseDelim(found_delim)),\n-        ),\n-    );\n-    err.span_label(unmatched.found_span, \"mismatched closing delimiter\");\n-    if let Some(sp) = unmatched.candidate_span {\n-        err.span_label(sp, \"closing delimiter possibly meant for this\");\n-    }\n+    let mut spans = vec![unmatched.found_span];\n     if let Some(sp) = unmatched.unclosed_span {\n-        err.span_label(sp, \"unclosed delimiter\");\n-    }\n+        spans.push(sp);\n+    };\n+    let err = MismatchedClosingDelimiter {\n+        spans,\n+        delimiter: pprust::token_kind_to_string(&token::CloseDelim(found_delim)).to_string(),\n+        unmatched: unmatched.found_span,\n+        opening_candidate: unmatched.candidate_span,\n+        unclosed: unmatched.unclosed_span,\n+    }\n+    .into_diagnostic(&sess.span_diagnostic);\n     Some(err)\n }\n "}, {"sha": "b1d69dcd862605131a98083700b0692142dd0d54", "filename": "src/test/ui/issues/issue-22644.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -29,7 +29,7 @@ fn main() {\n                    < //~ ERROR `<` is interpreted as a start of generic\n                    5);\n \n-    println!(\"{}\", a as usize << long_name); //~ ERROR `<` is interpreted as a start of generic\n+    println!(\"{}\", a as usize << long_name); //~ ERROR `<<` is interpreted as a start of generic\n \n     println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n }"}, {"sha": "45027afa7b62b0b04c318df78150ee1d635308a5", "filename": "src/test/ui/issues/issue-22644.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr?ref=ab7c7dc7ce422bfa2cdaf8ddd41b6260736a2e9f", "patch": "@@ -95,7 +95,7 @@ LL |\n LL ~                    usize)\n    |\n \n-error: `<` is interpreted as a start of generic arguments for `usize`, not a shift\n+error: `<<` is interpreted as a start of generic arguments for `usize`, not a shift\n   --> $DIR/issue-22644.rs:32:31\n    |\n LL |     println!(\"{}\", a as usize << long_name);"}]}