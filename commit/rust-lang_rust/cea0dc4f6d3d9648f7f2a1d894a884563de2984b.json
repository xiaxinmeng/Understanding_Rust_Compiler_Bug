{"sha": "cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYTBkYzRmNmQzZDk2NDhmN2YyYTFkODk0YTg4NDU2M2RlMjk4NGI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-27T12:45:20Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T18:08:29Z"}, "message": "Part of #27023: Put drop flag at end of a type's representation.\n\nThis is trickier than it sounds (because the DST code was written\nassuming that one could divide the sized and unsized portions of a\ntype strictly into a sized prefix and unsized suffix, when it reality\nit is more like a sized prefix and sized suffix that surround the\nsingle unsized field).\n\nI chose to put in a pretty hack-ish approach to this because\ndrop-flags are scheduled to go away anyway, so its not really worth\nthe effort to to make an infrastructure that sounds as general as the\nprevious paragraph indicates.\n\nAlso, I have written notes of other fixes that need to be made to\nreally finish fixing #27023, namely more work needs to be done to\naccount for alignment when computing the size of a value.", "tree": {"sha": "891584631e28c21313ca1ff388de02f8af21dc68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/891584631e28c21313ca1ff388de02f8af21dc68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "html_url": "https://github.com/rust-lang/rust/commit/cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cea0dc4f6d3d9648f7f2a1d894a884563de2984b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39ec9f850b05bafd6af7e1d3c143bc56b21f7742", "url": "https://api.github.com/repos/rust-lang/rust/commits/39ec9f850b05bafd6af7e1d3c143bc56b21f7742", "html_url": "https://github.com/rust-lang/rust/commit/39ec9f850b05bafd6af7e1d3c143bc56b21f7742"}], "stats": {"total": 151, "additions": 128, "deletions": 23}, "files": [{"sha": "1a5eebfa77ae4ed0f4148e51cb295abd63f2b49f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 94, "deletions": 17, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cea0dc4f6d3d9648f7f2a1d894a884563de2984b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea0dc4f6d3d9648f7f2a1d894a884563de2984b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "patch": "@@ -67,6 +67,31 @@ use trans::type_of;\n \n type Hint = attr::ReprAttr;\n \n+// Representation of the context surrounding an unsized type. I want\n+// to be able to track the drop flags that are injected by trans.\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub struct TypeContext {\n+    prefix: Type,\n+    needs_drop_flag: bool,\n+}\n+\n+impl TypeContext {\n+    pub fn prefix(&self) -> Type { self.prefix }\n+    pub fn needs_drop_flag(&self) -> bool { self.needs_drop_flag }\n+\n+    fn direct(t: Type) -> TypeContext {\n+        TypeContext { prefix: t, needs_drop_flag: false }\n+    }\n+    fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n+        TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n+    }\n+    pub fn to_string(self) -> String {\n+        let TypeContext { prefix, needs_drop_flag } = self;\n+        format!(\"TypeContext {{ prefix: {}, needs_drop_flag: {} }}\",\n+                prefix.to_string(), needs_drop_flag)\n+    }\n+}\n+\n /// Representations.\n #[derive(Eq, PartialEq, Debug)]\n pub enum Repr<'tcx> {\n@@ -125,7 +150,7 @@ pub struct Struct<'tcx> {\n     pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n-    pub fields: Vec<Ty<'tcx>>\n+    pub fields: Vec<Ty<'tcx>>,\n }\n \n /// Convenience for `represent_type`.  There should probably be more or\n@@ -681,18 +706,30 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n-    generic_type_of(cx, r, None, false, false)\n+    let c = generic_type_of(cx, r, None, false, false, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n }\n+\n+\n // Pass dst=true if the type you are passing is a DST. Yes, we could figure\n // this out, but if you call this on an unsized type without realising it, you\n // are going to get the wrong type (it will not include the unsized parts of it).\n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, dst: bool) -> Type {\n-    generic_type_of(cx, r, None, true, dst)\n+    let c = generic_type_of(cx, r, None, true, dst, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n+}\n+pub fn sizing_type_context_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        r: &Repr<'tcx>, dst: bool) -> TypeContext {\n+    generic_type_of(cx, r, None, true, dst, true)\n }\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     r: &Repr<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, r, Some(name), false, false)\n+    let c = generic_type_of(cx, r, Some(name), false, false, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n }\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n@@ -708,20 +745,50 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              r: &Repr<'tcx>,\n                              name: Option<&str>,\n                              sizing: bool,\n-                             dst: bool) -> Type {\n+                             dst: bool,\n+                             delay_drop_flag: bool) -> TypeContext {\n+    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {} delay_drop_flag: {}\",\n+           r, name, sizing, dst, delay_drop_flag);\n     match *r {\n-        CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n-        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n+        CEnum(ity, _, _) => TypeContext::direct(ll_inttype(cx, ity)),\n+        RawNullablePointer { nnty, .. } =>\n+            TypeContext::direct(type_of::sizing_type_of(cx, nnty)),\n+        StructWrappedNullablePointer { nonnull: ref st, .. } => {\n+            match name {\n+                None => {\n+                    TypeContext::direct(\n+                        Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n+                                      st.packed))\n+                }\n+                Some(name) => {\n+                    assert_eq!(sizing, false);\n+                    TypeContext::direct(Type::named_struct(cx, name))\n+                }\n+            }\n+        }\n+        Univariant(ref st, dtor_needed) => {\n+            let dtor_needed = dtor_needed != 0;\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n-                                  st.packed)\n+                    let mut fields = struct_llfields(cx, st, sizing, dst);\n+                    if delay_drop_flag && dtor_needed {\n+                        fields.pop();\n+                    }\n+                    TypeContext::may_need_drop_flag(\n+                        Type::struct_(cx, &fields,\n+                                      st.packed),\n+                        delay_drop_flag && dtor_needed)\n+                }\n+                Some(name) => {\n+                    // Hypothesis: named_struct's can never need a\n+                    // drop flag. (... needs validation.)\n+                    assert_eq!(sizing, false);\n+                    TypeContext::direct(Type::named_struct(cx, name))\n                 }\n-                Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n             }\n         }\n-        General(ity, ref sts, _) => {\n+        General(ity, ref sts, dtor_needed) => {\n+            let dtor_needed = dtor_needed != 0;\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -753,15 +820,25 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(align_s % discr_size, 0);\n-            let fields = [discr_ty,\n-                          Type::array(&discr_ty, align_s / discr_size - 1),\n-                          fill_ty];\n+            let mut fields: Vec<Type> =\n+                [discr_ty,\n+                 Type::array(&discr_ty, align_s / discr_size - 1),\n+                 fill_ty].iter().cloned().collect();\n+            if delay_drop_flag && dtor_needed {\n+                fields.pop();\n+            }\n             match name {\n-                None => Type::struct_(cx, &fields[..], false),\n+                None => {\n+                    TypeContext::may_need_drop_flag(\n+                        Type::struct_(cx, &fields[..], false),\n+                        delay_drop_flag && dtor_needed)\n+                }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&fields[..], false);\n-                    llty\n+                    TypeContext::may_need_drop_flag(\n+                        llty,\n+                        delay_drop_flag && dtor_needed)\n                 }\n             }\n         }"}, {"sha": "526c7277a665e6d6ab773c8d6fbbc704f62ddd35", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cea0dc4f6d3d9648f7f2a1d894a884563de2984b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea0dc4f6d3d9648f7f2a1d894a884563de2984b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=cea0dc4f6d3d9648f7f2a1d894a884563de2984b", "patch": "@@ -406,8 +406,12 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n            t, bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n-        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n+        let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n+        let align = align_of(bcx.ccx(), t);\n+        debug!(\"size_and_align_of_dst t={} info={} size: {} align: {}\",\n+               t, bcx.val_to_string(info), size, align);\n+        let size = C_uint(bcx.ccx(), size);\n+        let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n     }\n     match t.sty {\n@@ -417,9 +421,14 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd(bcx.tcx()));\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n-            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n-            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type));\n+            let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n+            debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n+            let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n+            let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n+            debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                   t, sized_size, sized_align);\n+            let sized_size = C_uint(ccx, sized_size);\n+            let sized_align = C_uint(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -428,8 +437,22 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let field_ty = last_field.mt.ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n+            // #27023 FIXME: We should be adding any necessary padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`.\n+\n             // Return the sum of sizes and max of aligns.\n-            let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n+            let mut size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n+\n+            // Issue #27023: If there is a drop flag, *now* we add 1\n+            // to the size.  (We can do this without adding any\n+            // padding because drop flags do not have any alignment\n+            // constraints.)\n+            if sizing_type.needs_drop_flag() {\n+                size = Add(bcx, size, C_uint(bcx.ccx(), 1_u64), DebugLoc::None);\n+            }\n+\n             let align = Select(bcx,\n                                ICmp(bcx,\n                                     llvm::IntULT,\n@@ -438,6 +461,11 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n                                     DebugLoc::None),\n                                sized_align,\n                                unsized_align);\n+\n+            // #27023 FIXME: We should be adding any necessary padding\n+            // to `size` (to make it a multiple of `align`) before\n+            // returning it.\n+\n             (size, align)\n         }\n         ty::TyTrait(..) => {"}]}