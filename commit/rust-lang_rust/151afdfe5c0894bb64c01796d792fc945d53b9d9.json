{"sha": "151afdfe5c0894bb64c01796d792fc945d53b9d9", "node_id": "C_kwDOAAsO6NoAKDE1MWFmZGZlNWMwODk0YmI2NGMwMTc5NmQ3OTJmYzk0NWQ1M2I5ZDk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T14:29:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T14:49:03Z"}, "message": "Remove inherent methods from ast node that carry semantic meaning", "tree": {"sha": "46c715a88b1214a44f99f7d06b6ee8176b384956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c715a88b1214a44f99f7d06b6ee8176b384956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/151afdfe5c0894bb64c01796d792fc945d53b9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/151afdfe5c0894bb64c01796d792fc945d53b9d9", "html_url": "https://github.com/rust-lang/rust/commit/151afdfe5c0894bb64c01796d792fc945d53b9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/151afdfe5c0894bb64c01796d792fc945d53b9d9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13da3d93f9be7200dda0635b0822e56b965194c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/13da3d93f9be7200dda0635b0822e56b965194c5", "html_url": "https://github.com/rust-lang/rust/commit/13da3d93f9be7200dda0635b0822e56b965194c5"}], "stats": {"total": 757, "additions": 392, "deletions": 365}, "files": [{"sha": "6f694210022919fb0bf39120b95320828f8e50f8", "filename": "crates/ide/src/folding_ranges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffolding_ranges.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,3 +1,4 @@\n+use ide_db::helpers::node_ext::vis_eq;\n use rustc_hash::FxHashSet;\n \n use syntax::{\n@@ -198,7 +199,7 @@ where\n fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n     match (vis0, vis1) {\n         (None, None) => true,\n-        (Some(vis0), Some(vis1)) => vis0.is_eq_to(&vis1),\n+        (Some(vis0), Some(vis1)) => vis_eq(&vis0, &vis1),\n         _ => false,\n     }\n }"}, {"sha": "d305f82fcb0003aee835fb0c2d55eb9ae726367e", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -2,7 +2,7 @@ use hir::Semantics;\n use ide_db::{\n     base_db::FilePosition,\n     defs::{Definition, NameClass, NameRefClass},\n-    helpers::{for_each_break_expr, for_each_tail_expr, pick_best_token},\n+    helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n@@ -122,7 +122,7 @@ fn highlight_exit_points(\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n-        body.walk(&mut |expr| match expr {\n+        walk_expr(&body, &mut |expr| match expr {\n             ast::Expr::ReturnExpr(expr) => {\n                 if let Some(token) = expr.return_token() {\n                     highlights.push(HighlightedRange { access: None, range: token.text_range() });\n@@ -243,7 +243,7 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         let mut highlights =\n             vec![HighlightedRange { access: None, range: async_token?.text_range() }];\n         if let Some(body) = body {\n-            body.walk(&mut |expr| {\n+            walk_expr(&body, &mut |expr| {\n                 if let ast::Expr::AwaitExpr(expr) = expr {\n                     if let Some(token) = expr.await_token() {\n                         highlights"}, {"sha": "8eb2e493590a9b3763bf0c930fa185e034e373ed", "filename": "crates/ide/src/join_lines.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,6 +1,7 @@\n use std::convert::TryFrom;\n \n use ide_assists::utils::extract_trivial_expression;\n+use ide_db::helpers::node_ext::expr_as_name_ref;\n use itertools::Itertools;\n use syntax::{\n     ast::{self, AstNode, AstToken, IsString},\n@@ -263,7 +264,7 @@ fn join_assignments(\n         return None;\n     }\n     let lhs = bin_expr.lhs()?;\n-    let name_ref = lhs.name_ref()?;\n+    let name_ref = expr_as_name_ref(&lhs)?;\n \n     if name_ref.to_string() != let_ident_pat.syntax().to_string() {\n         cov_mark::hit!(join_assignments_mismatch);"}, {"sha": "169bb0cbf4f34ee21d79817dee18c21587d3254e", "filename": "crates/ide_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,4 +1,5 @@\n use hir::HirDisplay;\n+use ide_db::helpers::node_ext::walk_ty;\n use syntax::ast::{self, AstNode, LetStmt, Param};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -46,7 +47,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     // Don't enable the assist if there is a type ascription without any placeholders\n     if let Some(ty) = &ascribed_ty {\n         let mut contains_infer_ty = false;\n-        ty.walk(&mut |ty| contains_infer_ty |= matches!(ty, ast::Type::InferType(_)));\n+        walk_ty(ty, &mut |ty| contains_infer_ty |= matches!(ty, ast::Type::InferType(_)));\n         if !contains_infer_ty {\n             cov_mark::hit!(add_explicit_type_not_applicable_if_ty_already_specified);\n             return None;"}, {"sha": "e7939269ad3ce1f5645977a8f22e0468a48bc085", "filename": "crates/ide_assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,6 +1,10 @@\n use hir::{known, AsAssocItem, Semantics};\n use ide_db::{\n-    helpers::{for_each_tail_expr, FamousDefs},\n+    helpers::{\n+        for_each_tail_expr,\n+        node_ext::{block_as_lone_tail, preorder_expr},\n+        FamousDefs,\n+    },\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -218,7 +222,7 @@ fn is_invalid_body(\n     expr: &ast::Expr,\n ) -> bool {\n     let mut invalid = false;\n-    expr.preorder(&mut |e| {\n+    preorder_expr(expr, &mut |e| {\n         invalid |=\n             matches!(e, syntax::WalkEvent::Enter(ast::Expr::TryExpr(_) | ast::Expr::ReturnExpr(_)));\n         invalid\n@@ -252,7 +256,7 @@ fn block_is_none_variant(\n     block: &ast::BlockExpr,\n     none_variant: hir::Variant,\n ) -> bool {\n-    block.as_lone_tail().and_then(|e| match e {\n+    block_as_lone_tail(block).and_then(|e| match e {\n         ast::Expr::PathExpr(pat) => match sema.resolve_path(&pat.path()?)? {\n             hir::PathResolution::Def(hir::ModuleDef::Variant(v)) => Some(v),\n             _ => None,"}, {"sha": "328d172cb8bb4c70be333c974372b4c2273ba134", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -5,6 +5,7 @@ use either::Either;\n use hir::{HirDisplay, InFile, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n+    helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n@@ -478,7 +479,7 @@ impl FunctionBody {\n \n     fn walk_expr(&self, cb: &mut dyn FnMut(ast::Expr)) {\n         match self {\n-            FunctionBody::Expr(expr) => expr.walk(cb),\n+            FunctionBody::Expr(expr) => walk_expr(expr, cb),\n             FunctionBody::Span { parent, text_range } => {\n                 parent\n                     .statements()\n@@ -488,20 +489,20 @@ impl FunctionBody {\n                         ast::Stmt::Item(_) => None,\n                         ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n                     })\n-                    .for_each(|expr| expr.walk(cb));\n+                    .for_each(|expr| walk_expr(&expr, cb));\n                 if let Some(expr) = parent\n                     .tail_expr()\n                     .filter(|it| text_range.contains_range(it.syntax().text_range()))\n                 {\n-                    expr.walk(cb);\n+                    walk_expr(&expr, cb);\n                 }\n             }\n         }\n     }\n \n     fn preorder_expr(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n         match self {\n-            FunctionBody::Expr(expr) => expr.preorder(cb),\n+            FunctionBody::Expr(expr) => preorder_expr(expr, cb),\n             FunctionBody::Span { parent, text_range } => {\n                 parent\n                     .statements()\n@@ -511,45 +512,45 @@ impl FunctionBody {\n                         ast::Stmt::Item(_) => None,\n                         ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n                     })\n-                    .for_each(|expr| expr.preorder(cb));\n+                    .for_each(|expr| preorder_expr(&expr, cb));\n                 if let Some(expr) = parent\n                     .tail_expr()\n                     .filter(|it| text_range.contains_range(it.syntax().text_range()))\n                 {\n-                    expr.preorder(cb);\n+                    preorder_expr(&expr, cb);\n                 }\n             }\n         }\n     }\n \n     fn walk_pat(&self, cb: &mut dyn FnMut(ast::Pat)) {\n         match self {\n-            FunctionBody::Expr(expr) => expr.walk_patterns(cb),\n+            FunctionBody::Expr(expr) => walk_patterns_in_expr(expr, cb),\n             FunctionBody::Span { parent, text_range } => {\n                 parent\n                     .statements()\n                     .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))\n                     .for_each(|stmt| match stmt {\n                         ast::Stmt::ExprStmt(expr_stmt) => {\n                             if let Some(expr) = expr_stmt.expr() {\n-                                expr.walk_patterns(cb)\n+                                walk_patterns_in_expr(&expr, cb)\n                             }\n                         }\n                         ast::Stmt::Item(_) => (),\n                         ast::Stmt::LetStmt(stmt) => {\n                             if let Some(pat) = stmt.pat() {\n-                                pat.walk(cb);\n+                                walk_pat(&pat, cb);\n                             }\n                             if let Some(expr) = stmt.initializer() {\n-                                expr.walk_patterns(cb);\n+                                walk_patterns_in_expr(&expr, cb);\n                             }\n                         }\n                     });\n                 if let Some(expr) = parent\n                     .tail_expr()\n                     .filter(|it| text_range.contains_range(it.syntax().text_range()))\n                 {\n-                    expr.walk_patterns(cb);\n+                    walk_patterns_in_expr(&expr, cb);\n                 }\n             }\n         }"}, {"sha": "a2dd23b58bb6d63b933b82d07fd0672b3a30d09a", "filename": "crates/ide_assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,4 +1,5 @@\n use either::Either;\n+use ide_db::helpers::node_ext::walk_ty;\n use itertools::Itertools;\n use syntax::{\n     ast::{self, edit::IndentLevel, AstNode, GenericParamsOwner, NameOwner},\n@@ -120,7 +121,7 @@ fn collect_used_generics<'gp>(\n     }\n \n     let mut generics = Vec::new();\n-    ty.walk(&mut |ty| match ty {\n+    walk_ty(ty, &mut |ty| match ty {\n         ast::Type::PathType(ty) => {\n             if let Some(path) = ty.path() {\n                 if let Some(name_ref) = path.as_single_name_ref() {"}, {"sha": "c510a5f965442b3a303e5d466f322b34ed6bfaf4", "filename": "crates/ide_assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,6 +1,6 @@\n use std::iter;\n \n-use ide_db::helpers::{for_each_tail_expr, FamousDefs};\n+use ide_db::helpers::{for_each_tail_expr, node_ext::walk_expr, FamousDefs};\n use syntax::{\n     ast::{self, make, Expr},\n     match_ast, AstNode,\n@@ -54,7 +54,7 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n \n             let mut exprs_to_wrap = Vec::new();\n             let tail_cb = &mut |e: &_| tail_cb_impl(&mut exprs_to_wrap, e);\n-            body.walk(&mut |expr| {\n+            walk_expr(&body, &mut |expr| {\n                 if let Expr::ReturnExpr(ret_expr) = expr {\n                     if let Some(ret_expr_arg) = &ret_expr.expr() {\n                         for_each_tail_expr(ret_expr_arg, tail_cb);"}, {"sha": "c92893716fb11940b871de876e29f6b3d0ac713c", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 7, "deletions": 120, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,22 +1,26 @@\n //! A module with ide helpers for high-level ide features.\n+pub mod famous_defs;\n+pub mod generated_lints;\n pub mod import_assets;\n pub mod insert_use;\n pub mod merge_imports;\n+pub mod node_ext;\n pub mod rust_doc;\n-pub mod generated_lints;\n \n use std::collections::VecDeque;\n \n use base_db::FileId;\n use either::Either;\n-use hir::{Crate, Enum, ItemInNs, MacroDef, Module, ModuleDef, Name, ScopeDef, Semantics, Trait};\n+use hir::{ItemInNs, MacroDef, ModuleDef, Name, Semantics};\n use syntax::{\n     ast::{self, make, LoopBodyOwner},\n     AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n };\n \n use crate::RootDatabase;\n \n+pub use self::famous_defs::FamousDefs;\n+\n pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n     match item {\n         ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).name(db),\n@@ -27,7 +31,7 @@ pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n \n /// Resolves the path at the cursor token as a derive macro if it inside a token tree of a derive attribute.\n pub fn try_resolve_derive_input_at(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &hir::Semantics<RootDatabase>,\n     derive_attr: &ast::Attr,\n     cursor: &SyntaxToken,\n ) -> Option<MacroDef> {\n@@ -113,123 +117,6 @@ pub fn visit_file_defs(\n     module.impl_defs(db).into_iter().for_each(|impl_| cb(Either::Right(impl_)));\n }\n \n-/// Helps with finding well-know things inside the standard library. This is\n-/// somewhat similar to the known paths infra inside hir, but it different; We\n-/// want to make sure that IDE specific paths don't become interesting inside\n-/// the compiler itself as well.\n-///\n-/// Note that, by default, rust-analyzer tests **do not** include core or std\n-/// libraries. If you are writing tests for functionality using [`FamousDefs`],\n-/// you'd want to include minicore (see `test_utils::MiniCore`) declaration at\n-/// the start of your tests:\n-///\n-/// ```\n-/// //- minicore: iterator, ord, derive\n-/// ```\n-pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Option<Crate>);\n-\n-#[allow(non_snake_case)]\n-impl FamousDefs<'_, '_> {\n-    pub fn std(&self) -> Option<Crate> {\n-        self.find_crate(\"std\")\n-    }\n-\n-    pub fn core(&self) -> Option<Crate> {\n-        self.find_crate(\"core\")\n-    }\n-\n-    pub fn core_cmp_Ord(&self) -> Option<Trait> {\n-        self.find_trait(\"core:cmp:Ord\")\n-    }\n-\n-    pub fn core_convert_From(&self) -> Option<Trait> {\n-        self.find_trait(\"core:convert:From\")\n-    }\n-\n-    pub fn core_convert_Into(&self) -> Option<Trait> {\n-        self.find_trait(\"core:convert:Into\")\n-    }\n-\n-    pub fn core_option_Option(&self) -> Option<Enum> {\n-        self.find_enum(\"core:option:Option\")\n-    }\n-\n-    pub fn core_result_Result(&self) -> Option<Enum> {\n-        self.find_enum(\"core:result:Result\")\n-    }\n-\n-    pub fn core_default_Default(&self) -> Option<Trait> {\n-        self.find_trait(\"core:default:Default\")\n-    }\n-\n-    pub fn core_iter_Iterator(&self) -> Option<Trait> {\n-        self.find_trait(\"core:iter:traits:iterator:Iterator\")\n-    }\n-\n-    pub fn core_iter_IntoIterator(&self) -> Option<Trait> {\n-        self.find_trait(\"core:iter:traits:collect:IntoIterator\")\n-    }\n-\n-    pub fn core_iter(&self) -> Option<Module> {\n-        self.find_module(\"core:iter\")\n-    }\n-\n-    pub fn core_ops_Deref(&self) -> Option<Trait> {\n-        self.find_trait(\"core:ops:Deref\")\n-    }\n-\n-    fn find_trait(&self, path: &str) -> Option<Trait> {\n-        match self.find_def(path)? {\n-            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    fn find_enum(&self, path: &str) -> Option<Enum> {\n-        match self.find_def(path)? {\n-            hir::ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(it))) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    fn find_module(&self, path: &str) -> Option<Module> {\n-        match self.find_def(path)? {\n-            hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    fn find_crate(&self, name: &str) -> Option<Crate> {\n-        let krate = self.1?;\n-        let db = self.0.db;\n-        let res =\n-            krate.dependencies(db).into_iter().find(|dep| dep.name.to_string() == name)?.krate;\n-        Some(res)\n-    }\n-\n-    fn find_def(&self, path: &str) -> Option<ScopeDef> {\n-        let db = self.0.db;\n-        let mut path = path.split(':');\n-        let trait_ = path.next_back()?;\n-        let std_crate = path.next()?;\n-        let std_crate = self.find_crate(std_crate)?;\n-        let mut module = std_crate.root_module(db);\n-        for segment in path {\n-            module = module.children(db).find_map(|child| {\n-                let name = child.name(db)?;\n-                if name.to_string() == segment {\n-                    Some(child)\n-                } else {\n-                    None\n-                }\n-            })?;\n-        }\n-        let def =\n-            module.scope(db, None).into_iter().find(|(name, _def)| name.to_string() == trait_)?.1;\n-        Some(def)\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct SnippetCap {\n     _private: (),"}, {"sha": "7c59bc28d75562ee60d90ccd555ef5fba21d4345", "filename": "crates/ide_db/src/helpers/famous_defs.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -0,0 +1,121 @@\n+//! See [`FamousDefs`].\n+use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n+\n+use crate::RootDatabase;\n+\n+/// Helps with finding well-know things inside the standard library. This is\n+/// somewhat similar to the known paths infra inside hir, but it different; We\n+/// want to make sure that IDE specific paths don't become interesting inside\n+/// the compiler itself as well.\n+///\n+/// Note that, by default, rust-analyzer tests **do not** include core or std\n+/// libraries. If you are writing tests for functionality using [`FamousDefs`],\n+/// you'd want to include minicore (see `test_utils::MiniCore`) declaration at\n+/// the start of your tests:\n+///\n+/// ```\n+/// //- minicore: iterator, ord, derive\n+/// ```\n+pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Option<Crate>);\n+\n+#[allow(non_snake_case)]\n+impl FamousDefs<'_, '_> {\n+    pub fn std(&self) -> Option<Crate> {\n+        self.find_crate(\"std\")\n+    }\n+\n+    pub fn core(&self) -> Option<Crate> {\n+        self.find_crate(\"core\")\n+    }\n+\n+    pub fn core_cmp_Ord(&self) -> Option<Trait> {\n+        self.find_trait(\"core:cmp:Ord\")\n+    }\n+\n+    pub fn core_convert_From(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:From\")\n+    }\n+\n+    pub fn core_convert_Into(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:Into\")\n+    }\n+\n+    pub fn core_option_Option(&self) -> Option<Enum> {\n+        self.find_enum(\"core:option:Option\")\n+    }\n+\n+    pub fn core_result_Result(&self) -> Option<Enum> {\n+        self.find_enum(\"core:result:Result\")\n+    }\n+\n+    pub fn core_default_Default(&self) -> Option<Trait> {\n+        self.find_trait(\"core:default:Default\")\n+    }\n+\n+    pub fn core_iter_Iterator(&self) -> Option<Trait> {\n+        self.find_trait(\"core:iter:traits:iterator:Iterator\")\n+    }\n+\n+    pub fn core_iter_IntoIterator(&self) -> Option<Trait> {\n+        self.find_trait(\"core:iter:traits:collect:IntoIterator\")\n+    }\n+\n+    pub fn core_iter(&self) -> Option<Module> {\n+        self.find_module(\"core:iter\")\n+    }\n+\n+    pub fn core_ops_Deref(&self) -> Option<Trait> {\n+        self.find_trait(\"core:ops:Deref\")\n+    }\n+\n+    fn find_trait(&self, path: &str) -> Option<Trait> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_enum(&self, path: &str) -> Option<Enum> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_module(&self, path: &str) -> Option<Module> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_crate(&self, name: &str) -> Option<Crate> {\n+        let krate = self.1?;\n+        let db = self.0.db;\n+        let res =\n+            krate.dependencies(db).into_iter().find(|dep| dep.name.to_string() == name)?.krate;\n+        Some(res)\n+    }\n+\n+    fn find_def(&self, path: &str) -> Option<ScopeDef> {\n+        let db = self.0.db;\n+        let mut path = path.split(':');\n+        let trait_ = path.next_back()?;\n+        let std_crate = path.next()?;\n+        let std_crate = self.find_crate(std_crate)?;\n+        let mut module = std_crate.root_module(db);\n+        for segment in path {\n+            module = module.children(db).find_map(|child| {\n+                let name = child.name(db)?;\n+                if name.to_string() == segment {\n+                    Some(child)\n+                } else {\n+                    None\n+                }\n+            })?;\n+        }\n+        let def =\n+            module.scope(db, None).into_iter().find(|(name, _def)| name.to_string() == trait_)?.1;\n+        Some(def)\n+    }\n+}"}, {"sha": "6f130e99b42221780e0766ccb116487daaf931a1", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -7,6 +7,8 @@ use syntax::{\n     ted,\n };\n \n+use crate::helpers::node_ext::vis_eq;\n+\n /// What type of merges are allowed.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum MergeBehavior {\n@@ -292,7 +294,7 @@ fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n pub fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n     match (vis0, vis1) {\n         (None, None) => true,\n-        (Some(vis0), Some(vis1)) => vis0.is_eq_to(&vis1),\n+        (Some(vis0), Some(vis1)) => vis_eq(&vis0, &vis1),\n         _ => false,\n     }\n }"}, {"sha": "24f853737b89fc88382c83e7e01af9455f49dff8", "filename": "crates/ide_db/src/helpers/node_ext.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -0,0 +1,212 @@\n+//! Various helper functions to work with SyntaxNodes.\n+use syntax::{\n+    ast::{self, PathSegmentKind, VisibilityKind},\n+    AstNode, WalkEvent,\n+};\n+\n+pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {\n+    if let ast::Expr::PathExpr(expr) = expr {\n+        let path = expr.path()?;\n+        let segment = path.segment()?;\n+        let name_ref = segment.name_ref()?;\n+        if path.qualifier().is_none() {\n+            return Some(name_ref);\n+        }\n+    }\n+    None\n+}\n+\n+pub fn block_as_lone_tail(block: &ast::BlockExpr) -> Option<ast::Expr> {\n+    block.statements().next().is_none().then(|| block.tail_expr()).flatten()\n+}\n+/// Preorder walk all the expression's child expressions.\n+pub fn walk_expr(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {\n+    preorder_expr(expr, &mut |ev| {\n+        if let WalkEvent::Enter(expr) = ev {\n+            cb(expr);\n+        }\n+        false\n+    })\n+}\n+\n+/// Preorder walk all the expression's child expressions preserving events.\n+/// If the callback returns true on an [`WalkEvent::Enter`], the subtree of the expression will be skipped.\n+/// Note that the subtree may already be skipped due to the context analysis this function does.\n+pub fn preorder_expr(expr: &ast::Expr, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n+    let mut preorder = expr.syntax().preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(node) => {\n+                if let Some(expr) = ast::Expr::cast(node) {\n+                    cb(WalkEvent::Leave(expr));\n+                }\n+                continue;\n+            }\n+        };\n+        match ast::Stmt::cast(node.clone()) {\n+            // recursively walk the initializer, skipping potential const pat expressions\n+            // let statements aren't usually nested too deeply so this is fine to recurse on\n+            Some(ast::Stmt::LetStmt(l)) => {\n+                if let Some(expr) = l.initializer() {\n+                    preorder_expr(&expr, cb);\n+                }\n+                preorder.skip_subtree();\n+            }\n+            // Don't skip subtree since we want to process the expression child next\n+            Some(ast::Stmt::ExprStmt(_)) => (),\n+            // This might be an expression\n+            Some(ast::Stmt::Item(ast::Item::MacroCall(mcall))) => {\n+                cb(WalkEvent::Enter(ast::Expr::MacroCall(mcall)));\n+                preorder.skip_subtree();\n+            }\n+            // skip inner items which might have their own expressions\n+            Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+            None => {\n+                // skip const args, those expressions are a different context\n+                if ast::GenericArg::can_cast(node.kind()) {\n+                    preorder.skip_subtree();\n+                } else if let Some(expr) = ast::Expr::cast(node) {\n+                    let is_different_context = match &expr {\n+                        ast::Expr::EffectExpr(effect) => {\n+                            matches!(\n+                                effect.effect(),\n+                                ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n+                            )\n+                        }\n+                        ast::Expr::ClosureExpr(_) => true,\n+                        _ => false,\n+                    };\n+                    let skip = cb(WalkEvent::Enter(expr));\n+                    if skip || is_different_context {\n+                        preorder.skip_subtree();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Preorder walk all the expression's child patterns.\n+pub fn walk_patterns_in_expr(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Pat)) {\n+    let mut preorder = expr.syntax().preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(_) => continue,\n+        };\n+        match ast::Stmt::cast(node.clone()) {\n+            Some(ast::Stmt::LetStmt(l)) => {\n+                if let Some(pat) = l.pat() {\n+                    walk_pat(&pat, cb);\n+                }\n+                if let Some(expr) = l.initializer() {\n+                    walk_patterns_in_expr(&expr, cb);\n+                }\n+                preorder.skip_subtree();\n+            }\n+            // Don't skip subtree since we want to process the expression child next\n+            Some(ast::Stmt::ExprStmt(_)) => (),\n+            // skip inner items which might have their own patterns\n+            Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+            None => {\n+                // skip const args, those are a different context\n+                if ast::GenericArg::can_cast(node.kind()) {\n+                    preorder.skip_subtree();\n+                } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n+                    let is_different_context = match &expr {\n+                        ast::Expr::EffectExpr(effect) => match effect.effect() {\n+                            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_) => {\n+                                true\n+                            }\n+                            ast::Effect::Unsafe(_) | ast::Effect::Label(_) => false,\n+                        },\n+                        ast::Expr::ClosureExpr(_) => true,\n+                        _ => false,\n+                    };\n+                    if is_different_context {\n+                        preorder.skip_subtree();\n+                    }\n+                } else if let Some(pat) = ast::Pat::cast(node) {\n+                    preorder.skip_subtree();\n+                    walk_pat(&pat, cb);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Preorder walk all the pattern's sub patterns.\n+pub fn walk_pat(pat: &ast::Pat, cb: &mut dyn FnMut(ast::Pat)) {\n+    let mut preorder = pat.syntax().preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(_) => continue,\n+        };\n+        let kind = node.kind();\n+        match ast::Pat::cast(node) {\n+            Some(pat @ ast::Pat::ConstBlockPat(_)) => {\n+                preorder.skip_subtree();\n+                cb(pat);\n+            }\n+            Some(pat) => {\n+                cb(pat);\n+            }\n+            // skip const args\n+            None if ast::GenericArg::can_cast(kind) => {\n+                preorder.skip_subtree();\n+            }\n+            None => (),\n+        }\n+    }\n+}\n+\n+/// Preorder walk all the type's sub types.\n+pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type)) {\n+    let mut preorder = ty.syntax().preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(_) => continue,\n+        };\n+        let kind = node.kind();\n+        match ast::Type::cast(node) {\n+            Some(ty @ ast::Type::MacroType(_)) => {\n+                preorder.skip_subtree();\n+                cb(ty)\n+            }\n+            Some(ty) => {\n+                cb(ty);\n+            }\n+            // skip const args\n+            None if ast::ConstArg::can_cast(kind) => {\n+                preorder.skip_subtree();\n+            }\n+            None => (),\n+        }\n+    }\n+}\n+\n+pub fn vis_eq(this: &ast::Visibility, other: &ast::Visibility) -> bool {\n+    match (this.kind(), other.kind()) {\n+        (VisibilityKind::In(this), VisibilityKind::In(other)) => {\n+            stdx::iter_eq_by(this.segments(), other.segments(), |lhs, rhs| {\n+                lhs.kind().zip(rhs.kind()).map_or(false, |it| match it {\n+                    (PathSegmentKind::CrateKw, PathSegmentKind::CrateKw)\n+                    | (PathSegmentKind::SelfKw, PathSegmentKind::SelfKw)\n+                    | (PathSegmentKind::SuperKw, PathSegmentKind::SuperKw) => true,\n+                    (PathSegmentKind::Name(lhs), PathSegmentKind::Name(rhs)) => {\n+                        lhs.text() == rhs.text()\n+                    }\n+                    _ => false,\n+                })\n+            })\n+        }\n+        (VisibilityKind::PubSelf, VisibilityKind::PubSelf)\n+        | (VisibilityKind::PubSuper, VisibilityKind::PubSuper)\n+        | (VisibilityKind::PubCrate, VisibilityKind::PubCrate)\n+        | (VisibilityKind::Pub, VisibilityKind::Pub) => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "a5dca509feb1819280128c972f8e722c681a65bf", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -34,6 +34,7 @@ use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     defs::Definition,\n+    helpers::node_ext::expr_as_name_ref,\n     search::FileReference,\n     source_change::{FileSystemEdit, SourceChange},\n     RootDatabase,\n@@ -339,7 +340,7 @@ fn source_edit_from_name_ref(\n     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_expr = record_field.expr();\n-        match &(rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+        match &(rcf_name_ref, rcf_expr.and_then(|it| expr_as_name_ref(&it))) {\n             // field: init-expr, check if we can use a field init shorthand\n             (Some(field_name), Some(init)) => {\n                 if field_name == name_ref {"}, {"sha": "9d78cb226fd4f067cd5f123f738d7ca4cde9f9c3", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 3, "deletions": 135, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,6 +1,6 @@\n //! Various extension methods to ast Expr Nodes, which are hard to code-generate.\n-\n-use rowan::WalkEvent;\n+//!\n+//! These methods should only do simple, shallow tasks related to the syntax of the node itself.\n \n use crate::{\n     ast::{\n@@ -28,139 +28,6 @@ impl ast::Expr {\n                 | ast::Expr::EffectExpr(_)\n         )\n     }\n-\n-    pub fn name_ref(&self) -> Option<ast::NameRef> {\n-        if let ast::Expr::PathExpr(expr) = self {\n-            let path = expr.path()?;\n-            let segment = path.segment()?;\n-            let name_ref = segment.name_ref()?;\n-            if path.qualifier().is_none() {\n-                return Some(name_ref);\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Preorder walk all the expression's child expressions.\n-    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n-        self.preorder(&mut |ev| {\n-            if let WalkEvent::Enter(expr) = ev {\n-                cb(expr);\n-            }\n-            false\n-        })\n-    }\n-\n-    /// Preorder walk all the expression's child expressions preserving events.\n-    /// If the callback returns true on an [`WalkEvent::Enter`], the subtree of the expression will be skipped.\n-    /// Note that the subtree may already be skipped due to the context analysis this function does.\n-    pub fn preorder(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(node) => {\n-                    if let Some(expr) = ast::Expr::cast(node) {\n-                        cb(WalkEvent::Leave(expr));\n-                    }\n-                    continue;\n-                }\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                // recursively walk the initializer, skipping potential const pat expressions\n-                // let statements aren't usually nested too deeply so this is fine to recurse on\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(expr) = l.initializer() {\n-                        expr.preorder(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // This might be an expression\n-                Some(ast::Stmt::Item(ast::Item::MacroCall(mcall))) => {\n-                    cb(WalkEvent::Enter(ast::Expr::MacroCall(mcall)));\n-                    preorder.skip_subtree();\n-                }\n-                // skip inner items which might have their own expressions\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those expressions are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        let skip = cb(WalkEvent::Enter(expr));\n-                        if skip || is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Preorder walk all the expression's child patterns.\n-    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(pat) = l.pat() {\n-                        pat.walk(cb);\n-                    }\n-                    if let Some(expr) = l.initializer() {\n-                        expr.walk_patterns(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // skip inner items which might have their own patterns\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        if is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    } else if let Some(pat) = ast::Pat::cast(node) {\n-                        preorder.skip_subtree();\n-                        pat.walk(cb);\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -374,6 +241,7 @@ impl ast::Literal {\n             .and_then(|e| e.into_token())\n             .unwrap()\n     }\n+\n     pub fn kind(&self) -> LiteralKind {\n         let token = self.token();\n "}, {"sha": "ab47d4ece9190dba2b7c69848d7020a3582f0f07", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 12, "deletions": 85, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151afdfe5c0894bb64c01796d792fc945d53b9d9/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=151afdfe5c0894bb64c01796d792fc945d53b9d9", "patch": "@@ -1,11 +1,13 @@\n //! Various extension methods to ast Nodes, which are hard to code-generate.\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n+//!\n+//! These methods should only do simple, shallow tasks related to the syntax of the node itself.\n \n use std::{borrow::Cow, fmt, iter::successors};\n \n use itertools::Itertools;\n use parser::SyntaxKind;\n-use rowan::{GreenNodeData, GreenTokenData, WalkEvent};\n+use rowan::{GreenNodeData, GreenTokenData};\n \n use crate::{\n     ast::{\n@@ -56,66 +58,6 @@ impl ast::BlockExpr {\n     pub fn is_empty(&self) -> bool {\n         self.statements().next().is_none() && self.tail_expr().is_none()\n     }\n-\n-    pub fn as_lone_tail(&self) -> Option<ast::Expr> {\n-        self.statements().next().is_none().then(|| self.tail_expr()).flatten()\n-    }\n-}\n-\n-impl ast::Pat {\n-    /// Preorder walk all the pattern's sub patterns.\n-    pub fn walk(&self, cb: &mut dyn FnMut(ast::Pat)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            let kind = node.kind();\n-            match ast::Pat::cast(node) {\n-                Some(pat @ ast::Pat::ConstBlockPat(_)) => {\n-                    preorder.skip_subtree();\n-                    cb(pat);\n-                }\n-                Some(pat) => {\n-                    cb(pat);\n-                }\n-                // skip const args\n-                None if ast::GenericArg::can_cast(kind) => {\n-                    preorder.skip_subtree();\n-                }\n-                None => (),\n-            }\n-        }\n-    }\n-}\n-\n-impl ast::Type {\n-    /// Preorder walk all the type's sub types.\n-    pub fn walk(&self, cb: &mut dyn FnMut(ast::Type)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            let kind = node.kind();\n-            match ast::Type::cast(node) {\n-                Some(ty @ ast::Type::MacroType(_)) => {\n-                    preorder.skip_subtree();\n-                    cb(ty)\n-                }\n-                Some(ty) => {\n-                    cb(ty);\n-                }\n-                // skip const args\n-                None if ast::ConstArg::can_cast(kind) => {\n-                    preorder.skip_subtree();\n-                }\n-                None => (),\n-            }\n-        }\n-    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n@@ -443,7 +385,15 @@ impl ast::RecordExprField {\n         if let Some(name_ref) = self.name_ref() {\n             return Some(name_ref);\n         }\n-        self.expr()?.name_ref()\n+        if let ast::Expr::PathExpr(expr) = self.expr()? {\n+            let path = expr.path()?;\n+            let segment = path.segment()?;\n+            let name_ref = segment.name_ref()?;\n+            if path.qualifier().is_none() {\n+                return Some(name_ref);\n+            }\n+        }\n+        None\n     }\n }\n \n@@ -721,29 +671,6 @@ impl ast::Visibility {\n             None => VisibilityKind::Pub,\n         }\n     }\n-\n-    pub fn is_eq_to(&self, other: &Self) -> bool {\n-        match (self.kind(), other.kind()) {\n-            (VisibilityKind::In(this), VisibilityKind::In(other)) => {\n-                stdx::iter_eq_by(this.segments(), other.segments(), |lhs, rhs| {\n-                    lhs.kind().zip(rhs.kind()).map_or(false, |it| match it {\n-                        (PathSegmentKind::CrateKw, PathSegmentKind::CrateKw)\n-                        | (PathSegmentKind::SelfKw, PathSegmentKind::SelfKw)\n-                        | (PathSegmentKind::SuperKw, PathSegmentKind::SuperKw) => true,\n-                        (PathSegmentKind::Name(lhs), PathSegmentKind::Name(rhs)) => {\n-                            lhs.text() == rhs.text()\n-                        }\n-                        _ => false,\n-                    })\n-                })\n-            }\n-            (VisibilityKind::PubSelf, VisibilityKind::PubSelf)\n-            | (VisibilityKind::PubSuper, VisibilityKind::PubSuper)\n-            | (VisibilityKind::PubCrate, VisibilityKind::PubCrate)\n-            | (VisibilityKind::Pub, VisibilityKind::Pub) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n impl ast::LifetimeParam {"}]}