{"sha": "ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOGZiODg0ZTk0OTc1ZWQ2ZDgyYTRjYzBlYTBhMDY0YTRiNzE1NWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-13T01:14:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-24T20:31:34Z"}, "message": "Remove usage of the #[merge] hack with int modules", "tree": {"sha": "da60056094a97e33f736fb620a09bd12e361dcd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da60056094a97e33f736fb620a09bd12e361dcd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "html_url": "https://github.com/rust-lang/rust/commit/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5ab1012f1f5786f550e511ba1302a22c85fcd71", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ab1012f1f5786f550e511ba1302a22c85fcd71", "html_url": "https://github.com/rust-lang/rust/commit/b5ab1012f1f5786f550e511ba1302a22c85fcd71"}], "stats": {"total": 2090, "additions": 941, "deletions": 1149}, "files": [{"sha": "3d5f0fb849356e4e6c0aab6ee3f195b842f92228", "filename": "src/libstd/core.rc", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -88,34 +88,24 @@ pub mod prelude;\n \n /* Primitive types */\n \n-#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/int.rs\"]\n-pub mod int;\n-#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i8.rs\"]\n-pub mod i8;\n-#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i16.rs\"]\n-pub mod i16;\n-#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i32.rs\"]\n-pub mod i32;\n-#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i64.rs\"]\n-pub mod i64;\n-#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/uint.rs\"]\n-pub mod uint;\n-\n-#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u8.rs\"]\n-pub mod u8;\n-#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u16.rs\"]\n-pub mod u16;\n-#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u32.rs\"]\n-pub mod u32;\n-#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u64.rs\"]\n-pub mod u64;\n-\n-#[path = \"num/float.rs\"]\n-pub mod float;\n-#[path = \"num/f32.rs\"]\n-pub mod f32;\n-#[path = \"num/f64.rs\"]\n-pub mod f64;\n+#[path = \"num/int_macros.rs\"]   mod int_macros;\n+#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+\n+#[path = \"num/int.rs\"]  pub mod int;\n+#[path = \"num/i8.rs\"]   pub mod i8;\n+#[path = \"num/i16.rs\"]  pub mod i16;\n+#[path = \"num/i32.rs\"]  pub mod i32;\n+#[path = \"num/i64.rs\"]  pub mod i64;\n+\n+#[path = \"num/uint.rs\"] pub mod uint;\n+#[path = \"num/u8.rs\"]   pub mod u8;\n+#[path = \"num/u16.rs\"]  pub mod u16;\n+#[path = \"num/u32.rs\"]  pub mod u32;\n+#[path = \"num/u64.rs\"]  pub mod u64;\n+\n+#[path = \"num/float.rs\"] pub mod float;\n+#[path = \"num/f32.rs\"]   pub mod f32;\n+#[path = \"num/f64.rs\"]   pub mod f64;\n \n pub mod nil;\n pub mod bool;"}, {"sha": "9977247b249b58462a0e21128407f0c95acf4880", "filename": "src/libstd/num/i16.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `i16`\n+\n+use num::BitCount;\n+use unstable::intrinsics;\n+\n+pub use self::generated::*;\n+\n+int_module!(i16, 16)\n+\n+impl BitCount for i16 {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n+}"}, {"sha": "0115f306e4e0ee1020c363e482784995c602aa52", "filename": "src/libstd/num/i32.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `i32`\n+\n+use num::BitCount;\n+use unstable::intrinsics;\n+\n+pub use self::generated::*;\n+\n+int_module!(i32, 32)\n+\n+impl BitCount for i32 {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n+}"}, {"sha": "4e280f01f2720bedfc23109ac064de85424352af", "filename": "src/libstd/num/i64.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `i64`\n+\n+use num::BitCount;\n+use unstable::intrinsics;\n+\n+pub use self::generated::*;\n+\n+int_module!(i64, 64)\n+\n+impl BitCount for i64 {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n+}"}, {"sha": "939965b9691856c5e825c09e02e8f90d12fc0f31", "filename": "src/libstd/num/i8.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `i8`\n+\n+use num::BitCount;\n+use unstable::intrinsics;\n+\n+pub use self::generated::*;\n+\n+int_module!(i8, 8)\n+\n+impl BitCount for i8 {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n+}"}, {"sha": "282633785553bf26e6362e8e46b266043f935887", "filename": "src/libstd/num/int-template/i16.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template%2Fi16.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `i16`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = i16;\n-    pub static bits: uint = ::u16::bits;\n-\n-    impl Primitive for i16 {\n-        #[inline(always)]\n-        fn bits() -> uint { 16 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<i16>() / 8 }\n-    }\n-\n-    impl BitCount for i16 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n-    }\n-}"}, {"sha": "959cf8f7d77cac26cb66f9993c2444e77f94cb26", "filename": "src/libstd/num/int-template/i32.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template%2Fi32.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `i32`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = i32;\n-    pub static bits: uint = ::u32::bits;\n-\n-    impl Primitive for i32 {\n-        #[inline(always)]\n-        fn bits() -> uint { 32 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<i32>() / 8 }\n-    }\n-\n-    impl BitCount for i32 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n-    }\n-}"}, {"sha": "3b51c70be12e52bc2f684b7e85fb198a9de160ca", "filename": "src/libstd/num/int-template/i64.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template%2Fi64.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `i64`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = i64;\n-    pub static bits: uint = ::u64::bits;\n-\n-    impl Primitive for i64 {\n-        #[inline(always)]\n-        fn bits() -> uint { 64 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<i64>() / 8 }\n-    }\n-\n-    impl BitCount for i64 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n-    }\n-}"}, {"sha": "896fb4dbf50f822bafd99e9207e66db73c3b10fb", "filename": "src/libstd/num/int-template/i8.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template%2Fi8.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `i8`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = i8;\n-    pub static bits: uint = ::u8::bits;\n-\n-    impl Primitive for i8 {\n-        #[inline(always)]\n-        fn bits() -> uint { 8 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<i8>() / 8 }\n-    }\n-\n-    impl BitCount for i8 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n-    }\n-}"}, {"sha": "64f6f2d2a9a9bc22d979a48913e6a7a4bcf5d725", "filename": "src/libstd/num/int-template/int.rs", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint-template%2Fint.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,104 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `int`\n-\n-pub use self::inst::pow;\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-\n-    pub type T = int;\n-    pub static bits: uint = ::uint::bits;\n-\n-    impl Primitive for int {\n-        #[cfg(target_word_size = \"32\")]\n-        #[inline(always)]\n-        fn bits() -> uint { 32 }\n-\n-        #[cfg(target_word_size = \"64\")]\n-        #[inline(always)]\n-        fn bits() -> uint { 64 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<int>() / 8 }\n-    }\n-\n-    #[cfg(target_word_size = \"32\")]\n-    #[inline(always)]\n-    impl BitCount for int {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> int { (*self as i32).population_count() as int }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n-    #[inline(always)]\n-    impl BitCount for int {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> int { (*self as i64).population_count() as int }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n-    }\n-\n-    /// Returns `base` raised to the power of `exponent`\n-    pub fn pow(base: int, exponent: uint) -> int {\n-        if exponent == 0u {\n-            //Not mathemtically true if ~[base == 0]\n-            return 1;\n-        }\n-        if base == 0 { return 0; }\n-        let mut my_pow  = exponent;\n-        let mut acc     = 1;\n-        let mut multiplier = base;\n-        while(my_pow > 0u) {\n-            if my_pow % 2u == 1u {\n-                acc *= multiplier;\n-            }\n-            my_pow     /= 2u;\n-            multiplier *= multiplier;\n-        }\n-        return acc;\n-    }\n-\n-    #[test]\n-    fn test_pow() {\n-        assert_eq!(pow(0, 0u), 1);\n-        assert_eq!(pow(0, 1u), 0);\n-        assert_eq!(pow(0, 2u), 0);\n-        assert_eq!(pow(-1, 0u), 1);\n-        assert_eq!(pow(1, 0u), 1);\n-        assert_eq!(pow(-3, 2u), 9);\n-        assert_eq!(pow(-3, 3u), -27);\n-        assert_eq!(pow(4, 9u), 262144);\n-    }\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!((::int::max_value > 0));\n-        assert!((::int::min_value <= 0));\n-        assert_eq!(::int::min_value + ::int::max_value + 1, 0);\n-    }\n-}"}, {"sha": "96ef7e9e3412cbc8fa831a39e68fd3ccfb237cae", "filename": "src/libstd/num/int.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `int`\n+\n+use num::BitCount;\n+\n+pub use self::generated::*;\n+\n+#[cfg(target_word_size = \"32\")] pub static bits: uint = 32;\n+#[cfg(target_word_size = \"64\")] pub static bits: uint = 64;\n+\n+int_module!(int, super::bits)\n+\n+#[cfg(target_word_size = \"32\")]\n+impl BitCount for int {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> int { (*self as i32).population_count() as int }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl BitCount for int {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> int { (*self as i64).population_count() as int }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n+}\n+\n+/// Returns `base` raised to the power of `exponent`\n+pub fn pow(base: int, exponent: uint) -> int {\n+    if exponent == 0u {\n+        //Not mathemtically true if ~[base == 0]\n+        return 1;\n+    }\n+    if base == 0 { return 0; }\n+    let mut my_pow  = exponent;\n+    let mut acc     = 1;\n+    let mut multiplier = base;\n+    while(my_pow > 0u) {\n+        if my_pow % 2u == 1u {\n+            acc *= multiplier;\n+        }\n+        my_pow     /= 2u;\n+        multiplier *= multiplier;\n+    }\n+    return acc;\n+}\n+\n+#[test]\n+fn test_pow() {\n+    assert!((pow(0, 0u) == 1));\n+    assert!((pow(0, 1u) == 0));\n+    assert!((pow(0, 2u) == 0));\n+    assert!((pow(-1, 0u) == 1));\n+    assert!((pow(1, 0u) == 1));\n+    assert!((pow(-3, 2u) == 9));\n+    assert!((pow(-3, 3u) == -27));\n+    assert!((pow(4, 9u) == 262144));\n+}\n+\n+#[test]\n+fn test_overflows() {\n+    assert!((::int::max_value > 0));\n+    assert!((::int::min_value <= 0));\n+    assert!((::int::min_value + ::int::max_value + 1 == 0));\n+}"}, {"sha": "6fde30fdb50c5723621da7970818935d566d1838", "filename": "src/libstd/num/int_macros.rs", "status": "renamed", "additions": 247, "deletions": 243, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -8,28 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use T = self::inst::T;\n+// FIXME(#4375): this shouldn't have to be a nested module named 'generated'\n+\n+#[macro_escape];\n+\n+macro_rules! int_module (($T:ty, $bits:expr) => (mod generated {\n \n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmp::{min, max};\n \n-pub static bits : uint = inst::bits;\n-pub static bytes : uint = (inst::bits / 8);\n+pub static bits : uint = $bits;\n+pub static bytes : uint = ($bits / 8);\n \n-pub static min_value: T = (-1 as T) << (bits - 1);\n-pub static max_value: T = min_value - 1 as T;\n+pub static min_value: $T = (-1 as $T) << (bits - 1);\n+pub static max_value: $T = min_value - 1 as $T;\n \n #[inline(always)]\n-pub fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: $T, y: $T) -> $T { x + y }\n #[inline(always)]\n-pub fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: $T, y: $T) -> $T { x - y }\n #[inline(always)]\n-pub fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: $T, y: $T) -> $T { x * y }\n #[inline(always)]\n-pub fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: $T, y: $T) -> $T { x / y }\n \n ///\n /// Returns the remainder of y / x.\n@@ -52,20 +56,20 @@ pub fn div(x: T, y: T) -> T { x / y }\n ///\n ///\n #[inline(always)]\n-pub fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n #[inline(always)]\n-pub fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: $T, y: $T) -> bool { x < y }\n #[inline(always)]\n-pub fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: $T, y: $T) -> bool { x <= y }\n #[inline(always)]\n-pub fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: $T, y: $T) -> bool { x == y }\n #[inline(always)]\n-pub fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: $T, y: $T) -> bool { x != y }\n #[inline(always)]\n-pub fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: $T, y: $T) -> bool { x >= y }\n #[inline(always)]\n-pub fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n ///\n /// Iterate over the range [`lo`..`hi`)\n@@ -85,11 +89,10 @@ pub fn gt(x: T, y: T) -> bool { x > y }\n /// ~~~\n ///\n #[inline(always)]\n-/// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub fn _range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n+pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n-        fail!(\"range_step called with step == 0\");\n+        fail!(~\"range_step called with step == 0\");\n     } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { return false; }\n@@ -108,109 +111,101 @@ pub fn _range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n     return true;\n }\n \n-pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n-    _range_step(start, stop, step, it)\n-}\n-\n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n-    range_step(lo, hi, 1 as T, it)\n+pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as $T, it)\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n-    range_step(hi, lo, -1 as T, it)\n+pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as $T, it)\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub fn compl(i: T) -> T {\n-    -1 as T ^ i\n+pub fn compl(i: $T) -> $T {\n+    -1 as $T ^ i\n }\n \n /// Computes the absolute value\n #[inline(always)]\n-pub fn abs(i: T) -> T { i.abs() }\n+pub fn abs(i: $T) -> $T { i.abs() }\n \n-impl Num for T {}\n+impl Num for $T {}\n \n #[cfg(not(test))]\n-impl Ord for T {\n+impl Ord for $T {\n     #[inline(always)]\n-    fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n+    fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n     #[inline(always)]\n-    fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n+    fn le(&self, other: &$T) -> bool { return (*self) <= (*other); }\n     #[inline(always)]\n-    fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n+    fn ge(&self, other: &$T) -> bool { return (*self) >= (*other); }\n     #[inline(always)]\n-    fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n+    fn gt(&self, other: &$T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(not(test))]\n-impl Eq for T {\n+impl Eq for $T {\n     #[inline(always)]\n-    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n-impl Orderable for T {\n+impl Orderable for $T {\n     #[inline(always)]\n-    fn min(&self, other: &T) -> T {\n+    fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n     #[inline(always)]\n-    fn max(&self, other: &T) -> T {\n+    fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n     #[inline(always)]\n-    fn clamp(&self, mn: &T, mx: &T) -> T {\n-        cond!(\n-            (*self > *mx) { *mx   }\n-            (*self < *mn) { *mn   }\n-            _             { *self }\n-        )\n+    fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n+        if *self > *mx { *mx } else\n+        if *self < *mn { *mn } else { *self }\n     }\n }\n \n-impl Zero for T {\n+impl Zero for $T {\n     #[inline(always)]\n-    fn zero() -> T { 0 }\n+    fn zero() -> $T { 0 }\n \n     #[inline(always)]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n-impl One for T {\n+impl One for $T {\n     #[inline(always)]\n-    fn one() -> T { 1 }\n+    fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n-impl Add<T,T> for T {\n+impl Add<$T,$T> for $T {\n     #[inline(always)]\n-    fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n-impl Sub<T,T> for T {\n+impl Sub<$T,$T> for $T {\n     #[inline(always)]\n-    fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n-impl Mul<T,T> for T {\n+impl Mul<$T,$T> for $T {\n     #[inline(always)]\n-    fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n #[cfg(not(test))]\n-impl Div<T,T> for T {\n+impl Div<$T,$T> for $T {\n     ///\n     /// Integer division, truncated towards 0. As this behaviour reflects the underlying\n     /// machine implementation it is more efficient than `Integer::div_floor`.\n@@ -230,11 +225,11 @@ impl Div<T,T> for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n #[cfg(not(test))]\n-impl Rem<T,T> for T {\n+impl Rem<$T,$T> for $T {\n     ///\n     /// Returns the integer remainder after division, satisfying:\n     ///\n@@ -257,19 +252,19 @@ impl Rem<T,T> for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn rem(&self, other: &T) -> T { *self % *other }\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n-impl Neg<T> for T {\n+impl Neg<$T> for $T {\n     #[inline(always)]\n-    fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> $T { -*self }\n }\n \n-impl Signed for T {\n+impl Signed for $T {\n     /// Computes the absolute value\n     #[inline(always)]\n-    fn abs(&self) -> T {\n+    fn abs(&self) -> $T {\n         if self.is_negative() { -*self } else { *self }\n     }\n \n@@ -278,7 +273,7 @@ impl Signed for T {\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n     #[inline(always)]\n-    fn abs_sub(&self, other: &T) -> T {\n+    fn abs_sub(&self, other: &$T) -> $T {\n         if *self <= *other { 0 } else { *self - *other }\n     }\n \n@@ -290,7 +285,7 @@ impl Signed for T {\n     /// - `-1` if the number is negative\n     ///\n     #[inline(always)]\n-    fn signum(&self) -> T {\n+    fn signum(&self) -> $T {\n         match *self {\n             n if n > 0 =>  1,\n             0          =>  0,\n@@ -307,7 +302,7 @@ impl Signed for T {\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n-impl Integer for T {\n+impl Integer for $T {\n     ///\n     /// Floored integer division\n     ///\n@@ -326,7 +321,7 @@ impl Integer for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn div_floor(&self, other: &T) -> T {\n+    fn div_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.div_rem(other) {\n@@ -358,7 +353,7 @@ impl Integer for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn mod_floor(&self, other: &T) -> T {\n+    fn mod_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match *self % *other {\n@@ -370,7 +365,7 @@ impl Integer for T {\n \n     /// Calculates `div_floor` and `mod_floor` simultaneously\n     #[inline(always)]\n-    fn div_mod_floor(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.div_rem(other) {\n@@ -382,7 +377,7 @@ impl Integer for T {\n \n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn div_rem(&self, other: &T) -> (T,T) {\n+    fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n@@ -392,7 +387,7 @@ impl Integer for T {\n     /// The result is always positive\n     ///\n     #[inline(always)]\n-    fn gcd(&self, other: &T) -> T {\n+    fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut m = *self, n = *other;\n         while m != 0 {\n@@ -407,13 +402,13 @@ impl Integer for T {\n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     ///\n     #[inline(always)]\n-    fn lcm(&self, other: &T) -> T {\n+    fn lcm(&self, other: &$T) -> $T {\n         ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn is_multiple_of(&self, other: &T) -> bool { *self % *other == 0 }\n+    fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n@@ -424,87 +419,95 @@ impl Integer for T {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n-impl Bitwise for T {}\n+impl Bitwise for $T {}\n \n #[cfg(not(test))]\n-impl BitOr<T,T> for T {\n+impl BitOr<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitor(&self, other: &T) -> T { *self | *other }\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n-impl BitAnd<T,T> for T {\n+impl BitAnd<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitand(&self, other: &T) -> T { *self & *other }\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n-impl BitXor<T,T> for T {\n+impl BitXor<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitxor(&self, other: &T) -> T { *self ^ *other }\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n-impl Shl<T,T> for T {\n+impl Shl<$T,$T> for $T {\n     #[inline(always)]\n-    fn shl(&self, other: &T) -> T { *self << *other }\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n-impl Shr<T,T> for T {\n+impl Shr<$T,$T> for $T {\n     #[inline(always)]\n-    fn shr(&self, other: &T) -> T { *self >> *other }\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n-impl Not<T> for T {\n+impl Not<$T> for $T {\n     #[inline(always)]\n-    fn not(&self) -> T { !*self }\n+    fn not(&self) -> $T { !*self }\n }\n \n-impl Bounded for T {\n+impl Bounded for $T {\n     #[inline(always)]\n-    fn min_value() -> T { min_value }\n+    fn min_value() -> $T { min_value }\n \n     #[inline(always)]\n-    fn max_value() -> T { max_value }\n+    fn max_value() -> $T { max_value }\n }\n \n-impl Int for T {}\n+impl Int for $T {}\n+\n+impl Primitive for $T {\n+    #[inline(always)]\n+    fn bits() -> uint { bits }\n+\n+    #[inline(always)]\n+    fn bytes() -> uint { bits / 8 }\n+}\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, true, false, false,\n                                strconv::ExpNone, false, false)\n }\n \n-impl FromStr for T {\n+impl FromStr for $T {\n     #[inline(always)]\n-    fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n-impl FromStrRadix for T {\n+impl FromStrRadix for $T {\n     #[inline(always)]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -513,36 +516,36 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub fn to_str(num: T) -> ~str {\n+pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n-impl ToStr for T {\n+impl ToStr for $T {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n-impl ToStrRadix for T {\n+impl ToStrRadix for $T {\n     #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n@@ -552,62 +555,61 @@ impl ToStrRadix for T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use super::inst::T;\n     use prelude::*;\n \n     #[test]\n     fn test_num() {\n-        num::test_num(10 as T, 2 as T);\n+        num::test_num(10 as $T, 2 as $T);\n     }\n \n     #[test]\n     fn test_orderable() {\n-        assert_eq!((1 as T).min(&(2 as T)), 1 as T);\n-        assert_eq!((2 as T).min(&(1 as T)), 1 as T);\n-        assert_eq!((1 as T).max(&(2 as T)), 2 as T);\n-        assert_eq!((2 as T).max(&(1 as T)), 2 as T);\n-        assert_eq!((1 as T).clamp(&(2 as T), &(4 as T)), 2 as T);\n-        assert_eq!((8 as T).clamp(&(2 as T), &(4 as T)), 4 as T);\n-        assert_eq!((3 as T).clamp(&(2 as T), &(4 as T)), 3 as T);\n+        assert_eq!((1 as $T).min(&(2 as $T)), 1 as $T);\n+        assert_eq!((2 as $T).min(&(1 as $T)), 1 as $T);\n+        assert_eq!((1 as $T).max(&(2 as $T)), 2 as $T);\n+        assert_eq!((2 as $T).max(&(1 as $T)), 2 as $T);\n+        assert_eq!((1 as $T).clamp(&(2 as $T), &(4 as $T)), 2 as $T);\n+        assert_eq!((8 as $T).clamp(&(2 as $T), &(4 as $T)), 4 as $T);\n+        assert_eq!((3 as $T).clamp(&(2 as $T), &(4 as $T)), 3 as $T);\n     }\n \n     #[test]\n     pub fn test_abs() {\n-        assert_eq!((1 as T).abs(), 1 as T);\n-        assert_eq!((0 as T).abs(), 0 as T);\n-        assert_eq!((-1 as T).abs(), 1 as T);\n+        assert_eq!((1 as $T).abs(), 1 as $T);\n+        assert_eq!((0 as $T).abs(), 0 as $T);\n+        assert_eq!((-1 as $T).abs(), 1 as $T);\n     }\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-1 as T).abs_sub(&(1 as T)), 0 as T);\n-        assert_eq!((1 as T).abs_sub(&(1 as T)), 0 as T);\n-        assert_eq!((1 as T).abs_sub(&(0 as T)), 1 as T);\n-        assert_eq!((1 as T).abs_sub(&(-1 as T)), 2 as T);\n+        assert_eq!((-1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(0 as $T)), 1 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(-1 as $T)), 2 as $T);\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!((1 as T).signum(), 1 as T);\n-        assert_eq!((0 as T).signum(), 0 as T);\n-        assert_eq!((-0 as T).signum(), 0 as T);\n-        assert_eq!((-1 as T).signum(), -1 as T);\n+        assert_eq!((1 as $T).signum(), 1 as $T);\n+        assert_eq!((0 as $T).signum(), 0 as $T);\n+        assert_eq!((-0 as $T).signum(), 0 as $T);\n+        assert_eq!((-1 as $T).signum(), -1 as $T);\n     }\n \n     #[test]\n     fn test_is_positive() {\n-        assert!((1 as T).is_positive());\n-        assert!(!(0 as T).is_positive());\n-        assert!(!(-0 as T).is_positive());\n-        assert!(!(-1 as T).is_positive());\n+        assert!((1 as $T).is_positive());\n+        assert!(!(0 as $T).is_positive());\n+        assert!(!(-0 as $T).is_positive());\n+        assert!(!(-1 as $T).is_positive());\n     }\n \n     #[test]\n     fn test_is_negative() {\n-        assert!(!(1 as T).is_negative());\n-        assert!(!(0 as T).is_negative());\n-        assert!(!(-0 as T).is_negative());\n-        assert!((-1 as T).is_negative());\n+        assert!(!(1 as $T).is_negative());\n+        assert!(!(0 as $T).is_negative());\n+        assert!(!(-0 as $T).is_negative());\n+        assert!((-1 as $T).is_negative());\n     }\n \n     ///\n@@ -618,13 +620,13 @@ mod tests {\n     /// - `qr`: quotient and remainder\n     ///\n     #[cfg(test)]\n-    fn test_division_rule((n,d): (T,T), (q,r): (T,T)) {\n+    fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n         assert_eq!(d * q + r, n);\n     }\n \n     #[test]\n     fn test_div_rem() {\n-        fn test_nd_dr(nd: (T,T), qr: (T,T)) {\n+        fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n             let (n,d) = nd;\n             let separate_div_rem = (n / d, n % d);\n             let combined_div_rem = n.div_rem(&d);\n@@ -649,7 +651,7 @@ mod tests {\n \n     #[test]\n     fn test_div_mod_floor() {\n-        fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n+        fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n             let (n,d) = nd;\n             let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n             let combined_div_mod_floor = n.div_mod_floor(&d);\n@@ -674,135 +676,135 @@ mod tests {\n \n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(&2), 2 as T);\n-        assert_eq!((10 as T).gcd(&3), 1 as T);\n-        assert_eq!((0 as T).gcd(&3), 3 as T);\n-        assert_eq!((3 as T).gcd(&3), 3 as T);\n-        assert_eq!((56 as T).gcd(&42), 14 as T);\n-        assert_eq!((3 as T).gcd(&-3), 3 as T);\n-        assert_eq!((-6 as T).gcd(&3), 3 as T);\n-        assert_eq!((-4 as T).gcd(&-2), 2 as T);\n+        assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+        assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+        assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+        assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+        assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+        assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n+        assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n+        assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(&0), 0 as T);\n-        assert_eq!((0 as T).lcm(&1), 0 as T);\n-        assert_eq!((1 as T).lcm(&1), 1 as T);\n-        assert_eq!((-1 as T).lcm(&1), 1 as T);\n-        assert_eq!((1 as T).lcm(&-1), 1 as T);\n-        assert_eq!((-1 as T).lcm(&-1), 1 as T);\n-        assert_eq!((8 as T).lcm(&9), 72 as T);\n-        assert_eq!((11 as T).lcm(&5), 55 as T);\n+        assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+        assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+        assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+        assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n+        assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n+        assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n+        assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+        assert_eq!((11 as $T).lcm(&5), 55 as $T);\n     }\n \n     #[test]\n     fn test_bitwise() {\n-        assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n-        assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n-        assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n-        assert_eq!(0b1110 as T, (0b0111 as T).shl(&(1 as T)));\n-        assert_eq!(0b0111 as T, (0b1110 as T).shr(&(1 as T)));\n-        assert_eq!(-(0b11 as T) - (1 as T), (0b11 as T).not());\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n+        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n     }\n \n     #[test]\n     fn test_multiple_of() {\n-        assert!((6 as T).is_multiple_of(&(6 as T)));\n-        assert!((6 as T).is_multiple_of(&(3 as T)));\n-        assert!((6 as T).is_multiple_of(&(1 as T)));\n-        assert!((-8 as T).is_multiple_of(&(4 as T)));\n-        assert!((8 as T).is_multiple_of(&(-1 as T)));\n-        assert!((-8 as T).is_multiple_of(&(-2 as T)));\n+        assert!((6 as $T).is_multiple_of(&(6 as $T)));\n+        assert!((6 as $T).is_multiple_of(&(3 as $T)));\n+        assert!((6 as $T).is_multiple_of(&(1 as $T)));\n+        assert!((-8 as $T).is_multiple_of(&(4 as $T)));\n+        assert!((8 as $T).is_multiple_of(&(-1 as $T)));\n+        assert!((-8 as $T).is_multiple_of(&(-2 as $T)));\n     }\n \n     #[test]\n     fn test_even() {\n-        assert_eq!((-4 as T).is_even(), true);\n-        assert_eq!((-3 as T).is_even(), false);\n-        assert_eq!((-2 as T).is_even(), true);\n-        assert_eq!((-1 as T).is_even(), false);\n-        assert_eq!((0 as T).is_even(), true);\n-        assert_eq!((1 as T).is_even(), false);\n-        assert_eq!((2 as T).is_even(), true);\n-        assert_eq!((3 as T).is_even(), false);\n-        assert_eq!((4 as T).is_even(), true);\n+        assert_eq!((-4 as $T).is_even(), true);\n+        assert_eq!((-3 as $T).is_even(), false);\n+        assert_eq!((-2 as $T).is_even(), true);\n+        assert_eq!((-1 as $T).is_even(), false);\n+        assert_eq!((0 as $T).is_even(), true);\n+        assert_eq!((1 as $T).is_even(), false);\n+        assert_eq!((2 as $T).is_even(), true);\n+        assert_eq!((3 as $T).is_even(), false);\n+        assert_eq!((4 as $T).is_even(), true);\n     }\n \n     #[test]\n     fn test_odd() {\n-        assert_eq!((-4 as T).is_odd(), false);\n-        assert_eq!((-3 as T).is_odd(), true);\n-        assert_eq!((-2 as T).is_odd(), false);\n-        assert_eq!((-1 as T).is_odd(), true);\n-        assert_eq!((0 as T).is_odd(), false);\n-        assert_eq!((1 as T).is_odd(), true);\n-        assert_eq!((2 as T).is_odd(), false);\n-        assert_eq!((3 as T).is_odd(), true);\n-        assert_eq!((4 as T).is_odd(), false);\n+        assert_eq!((-4 as $T).is_odd(), false);\n+        assert_eq!((-3 as $T).is_odd(), true);\n+        assert_eq!((-2 as $T).is_odd(), false);\n+        assert_eq!((-1 as $T).is_odd(), true);\n+        assert_eq!((0 as $T).is_odd(), false);\n+        assert_eq!((1 as $T).is_odd(), true);\n+        assert_eq!((2 as $T).is_odd(), false);\n+        assert_eq!((3 as $T).is_odd(), true);\n+        assert_eq!((4 as $T).is_odd(), false);\n     }\n \n     #[test]\n     fn test_bitcount() {\n-        assert_eq!((0b010101 as T).population_count(), 3);\n+        assert_eq!((0b010101 as $T).population_count(), 3);\n     }\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<T>(), sys::size_of::<T>() * 8);\n-        assert_eq!(Primitive::bytes::<T>(), sys::size_of::<T>());\n+        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n     }\n \n     #[test]\n     fn test_from_str() {\n-        assert_eq!(from_str(\"0\"), Some(0 as T));\n-        assert_eq!(from_str(\"3\"), Some(3 as T));\n-        assert_eq!(from_str(\"10\"), Some(10 as T));\n-        assert_eq!(i32::from_str(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str(\"00100\"), Some(100 as T));\n+        assert_eq!(from_str(~\"0\"), Some(0 as $T));\n+        assert_eq!(from_str(~\"3\"), Some(3 as $T));\n+        assert_eq!(from_str(~\"10\"), Some(10 as $T));\n+        assert_eq!(i32::from_str(~\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str(~\"00100\"), Some(100 as $T));\n \n-        assert_eq!(from_str(\"-1\"), Some(-1 as T));\n-        assert_eq!(from_str(\"-3\"), Some(-3 as T));\n-        assert_eq!(from_str(\"-10\"), Some(-10 as T));\n-        assert_eq!(i32::from_str(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str(\"-00100\"), Some(-100 as T));\n+        assert_eq!(from_str(~\"-1\"), Some(-1 as $T));\n+        assert_eq!(from_str(~\"-3\"), Some(-3 as $T));\n+        assert_eq!(from_str(~\"-10\"), Some(-10 as $T));\n+        assert_eq!(i32::from_str(~\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str(~\"-00100\"), Some(-100 as $T));\n \n-        assert!(from_str(\" \").is_none());\n-        assert!(from_str(\"x\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n     }\n \n     #[test]\n     fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83 as T));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"123\"), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"FFFF\"), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"Z\"), 36u), Some(35 as T));\n-\n-        assert_eq!(parse_bytes(to_bytes(\"-123\"), 10u), Some(-123 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"-1001\"), 2u), Some(-9 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"-123\"), 8u), Some(-83 as T));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-123\"), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-ffff\"), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-FFFF\"), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(\"-z\"), 36u), Some(-35 as T));\n-        assert_eq!(parse_bytes(to_bytes(\"-Z\"), 36u), Some(-35 as T));\n-\n-        assert!(parse_bytes(to_bytes(\"Z\"), 35u).is_none());\n-        assert!(parse_bytes(to_bytes(\"-9\"), 2u).is_none());\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83 as $T));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"123\"), 16u), Some(291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u), Some(65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"Z\"), 36u), Some(35 as $T));\n+\n+        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 10u), Some(-123 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-1001\"), 2u), Some(-9 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 8u), Some(-83 as $T));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-123\"), 16u), Some(-291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u), Some(-65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u), Some(-65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(~\"-z\"), 36u), Some(-35 as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-Z\"), 36u), Some(-35 as $T));\n+\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n     }\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!(to_str_radix(0 as T, 10u), ~\"0\");\n-        assert_eq!(to_str_radix(1 as T, 10u), ~\"1\");\n-        assert_eq!(to_str_radix(-1 as T, 10u), ~\"-1\");\n-        assert_eq!(to_str_radix(127 as T, 16u), ~\"7f\");\n-        assert_eq!(to_str_radix(100 as T, 10u), ~\"100\");\n+        assert_eq!(to_str_radix(0 as $T, 10u), ~\"0\");\n+        assert_eq!(to_str_radix(1 as $T, 10u), ~\"1\");\n+        assert_eq!(to_str_radix(-1 as $T, 10u), ~\"-1\");\n+        assert_eq!(to_str_radix(127 as $T, 16u), ~\"7f\");\n+        assert_eq!(to_str_radix(100 as $T, 10u), ~\"100\");\n \n     }\n \n@@ -836,36 +838,36 @@ mod tests {\n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8::from_str(\"127\"), Some(i8_val));\n-        assert!(i8::from_str(\"128\").is_none());\n+        assert_eq!(i8::from_str(~\"127\"), Some(i8_val));\n+        assert!(i8::from_str(~\"128\").is_none());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8::from_str(\"-128\"), Some(i8_val));\n-        assert!(i8::from_str(\"-129\").is_none());\n+        assert_eq!(i8::from_str(~\"-128\"), Some(i8_val));\n+        assert!(i8::from_str(~\"-129\").is_none());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16::from_str(\"32767\"), Some(i16_val));\n-        assert!(i16::from_str(\"32768\").is_none());\n+        assert_eq!(i16::from_str(~\"32767\"), Some(i16_val));\n+        assert!(i16::from_str(~\"32768\").is_none());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16::from_str(\"-32768\"), Some(i16_val));\n-        assert!(i16::from_str(\"-32769\").is_none());\n+        assert_eq!(i16::from_str(~\"-32768\"), Some(i16_val));\n+        assert!(i16::from_str(~\"-32769\").is_none());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32::from_str(\"2147483647\"), Some(i32_val));\n-        assert!(i32::from_str(\"2147483648\").is_none());\n+        assert_eq!(i32::from_str(~\"2147483647\"), Some(i32_val));\n+        assert!(i32::from_str(~\"2147483648\").is_none());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32::from_str(\"-2147483648\"), Some(i32_val));\n-        assert!(i32::from_str(\"-2147483649\").is_none());\n+        assert_eq!(i32::from_str(~\"-2147483648\"), Some(i32_val));\n+        assert!(i32::from_str(~\"-2147483649\").is_none());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64::from_str(\"9223372036854775807\"), Some(i64_val));\n-        assert!(i64::from_str(\"9223372036854775808\").is_none());\n+        assert_eq!(i64::from_str(~\"9223372036854775807\"), Some(i64_val));\n+        assert!(i64::from_str(~\"9223372036854775808\").is_none());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64::from_str(\"-9223372036854775808\"), Some(i64_val));\n-        assert!(i64::from_str(\"-9223372036854775809\").is_none());\n+        assert_eq!(i64::from_str(~\"-9223372036854775808\"), Some(i64_val));\n+        assert!(i64::from_str(~\"-9223372036854775809\").is_none());\n     }\n \n     #[test]\n@@ -907,16 +909,16 @@ mod tests {\n \n         // None of the `fail`s should execute.\n         for range(10,0) |_i| {\n-            fail!(\"unreachable\");\n+            fail!(~\"unreachable\");\n         }\n         for range_rev(0,10) |_i| {\n-            fail!(\"unreachable\");\n+            fail!(~\"unreachable\");\n         }\n         for range_step(10,0,1) |_i| {\n-            fail!(\"unreachable\");\n+            fail!(~\"unreachable\");\n         }\n         for range_step(0,10,-1) |_i| {\n-            fail!(\"unreachable\");\n+            fail!(~\"unreachable\");\n         }\n     }\n \n@@ -927,3 +929,5 @@ mod tests {\n         for range_step(0,10,0) |_i| {}\n     }\n }\n+\n+}))", "previous_filename": "src/libstd/num/int-template.rs"}, {"sha": "3a4c2420f9ed504ce5b2d911dbd9ddb9513b7a03", "filename": "src/libstd/num/u16.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `u16`\n+\n+pub use self::generated::*;\n+uint_module!(u16, i16, 16)"}, {"sha": "f87fa7fcd426bb70ec22167af3d563a7ec16c9bc", "filename": "src/libstd/num/u32.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `u32`\n+\n+pub use self::generated::*;\n+uint_module!(u32, i32, 32)"}, {"sha": "792db1555695ac0b18180f165016c672bd757b58", "filename": "src/libstd/num/u64.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `u64`\n+\n+pub use self::generated::*;\n+uint_module!(u64, i64, 64)"}, {"sha": "e21e80f840678c81c9eb2f58aa9b2920019711be", "filename": "src/libstd/num/u8.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `u8`\n+\n+pub use self::generated::*;\n+uint_module!(u8, i8, 8)"}, {"sha": "cc262f6b4dee7100385e9b7784383173265c8d5e", "filename": "src/libstd/num/uint-template/u16.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template%2Fu16.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `u16`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = u16;\n-    #[allow(non_camel_case_types)]\n-    pub type T_SIGNED = i16;\n-    pub static bits: uint = 16;\n-\n-    impl Primitive for u16 {\n-        #[inline(always)]\n-        fn bits() -> uint { 16 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<u16>() / 8 }\n-    }\n-\n-    impl BitCount for u16 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> u16 { unsafe { intrinsics::ctpop16(*self as i16) as u16 } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> u16 { unsafe { intrinsics::ctlz16(*self as i16) as u16 } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> u16 { unsafe { intrinsics::cttz16(*self as i16) as u16 } }\n-    }\n-}"}, {"sha": "7d7c8e3be302e3589b6d72f5e3fbd5f77296647a", "filename": "src/libstd/num/uint-template/u32.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template%2Fu32.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `u32`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = u32;\n-    #[allow(non_camel_case_types)]\n-    pub type T_SIGNED = i32;\n-    pub static bits: uint = 32;\n-\n-    impl Primitive for u32 {\n-        #[inline(always)]\n-        fn bits() -> uint { 32 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<u32>() / 8 }\n-    }\n-\n-    impl BitCount for u32 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> u32 { unsafe { intrinsics::ctpop32(*self as i32) as u32 } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlp` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> u32 { unsafe { intrinsics::ctlz32(*self as i32) as u32 } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttp` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> u32 { unsafe { intrinsics::cttz32(*self as i32) as u32 } }\n-    }\n-}"}, {"sha": "756c29950c35b062b2fdf4dd902c6924e5e88a9f", "filename": "src/libstd/num/uint-template/u64.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template%2Fu64.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `u64`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = u64;\n-    #[allow(non_camel_case_types)]\n-    pub type T_SIGNED = i64;\n-    pub static bits: uint = 64;\n-\n-    impl Primitive for u64 {\n-        #[inline(always)]\n-        fn bits() -> uint { 64 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<u64>() / 8 }\n-    }\n-\n-    impl BitCount for u64 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> u64 { unsafe { intrinsics::ctpop64(*self as i64) as u64 } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> u64 { unsafe { intrinsics::ctlz64(*self as i64) as u64 } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> u64 { unsafe { intrinsics::cttz64(*self as i64) as u64 } }\n-    }\n-}"}, {"sha": "5ac860c0359c547fd7217162a1245b169e6f49c8", "filename": "src/libstd/num/uint-template/u8.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template%2Fu8.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `u8`\n-\n-mod inst {\n-    use num::{Primitive, BitCount};\n-    use unstable::intrinsics;\n-\n-    pub type T = u8;\n-    #[allow(non_camel_case_types)]\n-    pub type T_SIGNED = i8;\n-    pub static bits: uint = 8;\n-\n-    impl Primitive for u8 {\n-        #[inline(always)]\n-        fn bits() -> uint { 8 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<u8>() / 8 }\n-    }\n-\n-    impl BitCount for u8 {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> u8 { unsafe { intrinsics::ctpop8(*self as i8) as u8 } }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> u8 { unsafe { intrinsics::ctlz8(*self as i8) as u8 } }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> u8 { unsafe { intrinsics::cttz8(*self as i8) as u8 } }\n-    }\n-}"}, {"sha": "763c305f2214941b462d960ed2e8abf072d3c34a", "filename": "src/libstd/num/uint-template/uint.rs", "status": "removed", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab1012f1f5786f550e511ba1302a22c85fcd71/src%2Flibstd%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint-template%2Fuint.rs?ref=b5ab1012f1f5786f550e511ba1302a22c85fcd71", "patch": "@@ -1,256 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `uint`\n-\n-pub use self::inst::{\n-    div_ceil, div_round, div_floor, iterate,\n-    next_power_of_two\n-};\n-\n-pub mod inst {\n-    use iter;\n-    use num::{Primitive, BitCount};\n-    use sys;\n-\n-    pub type T = uint;\n-    #[allow(non_camel_case_types)]\n-    pub type T_SIGNED = int;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    pub static bits: uint = 32;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub static bits: uint = 64;\n-\n-    impl Primitive for uint {\n-        #[cfg(target_word_size = \"32\")]\n-        #[inline(always)]\n-        fn bits() -> uint { 32 }\n-\n-        #[cfg(target_word_size = \"64\")]\n-        #[inline(always)]\n-        fn bits() -> uint { 64 }\n-\n-        #[inline(always)]\n-        fn bytes() -> uint { Primitive::bits::<uint>() / 8 }\n-    }\n-\n-    #[cfg(target_word_size = \"32\")]\n-    #[inline(always)]\n-    impl BitCount for uint {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> uint { (*self as i32).population_count() as uint }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> uint { (*self as i32).leading_zeros() as uint }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> uint { (*self as i32).trailing_zeros() as uint }\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n-    #[inline(always)]\n-    impl BitCount for uint {\n-        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-        #[inline(always)]\n-        fn population_count(&self) -> uint { (*self as i64).population_count() as uint }\n-\n-        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-        #[inline(always)]\n-        fn leading_zeros(&self) -> uint { (*self as i64).leading_zeros() as uint }\n-\n-        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-        #[inline(always)]\n-        fn trailing_zeros(&self) -> uint { (*self as i64).trailing_zeros() as uint }\n-    }\n-\n-    ///\n-    /// Divide two numbers, return the result, rounded up.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * x - an integer\n-    /// * y - an integer distinct from 0u\n-    ///\n-    /// # Return value\n-    ///\n-    /// The smallest integer `q` such that `x/y <= q`.\n-    ///\n-    pub fn div_ceil(x: uint, y: uint) -> uint {\n-        let div = x / y;\n-        if x % y == 0u { div }\n-        else { div + 1u }\n-    }\n-\n-    ///\n-    /// Divide two numbers, return the result, rounded to the closest integer.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * x - an integer\n-    /// * y - an integer distinct from 0u\n-    ///\n-    /// # Return value\n-    ///\n-    /// The integer `q` closest to `x/y`.\n-    ///\n-    pub fn div_round(x: uint, y: uint) -> uint {\n-        let div = x / y;\n-        if x % y * 2u  < y { div }\n-        else { div + 1u }\n-    }\n-\n-    ///\n-    /// Divide two numbers, return the result, rounded down.\n-    ///\n-    /// Note: This is the same function as `div`.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * x - an integer\n-    /// * y - an integer distinct from 0u\n-    ///\n-    /// # Return value\n-    ///\n-    /// The smallest integer `q` such that `x/y <= q`. This\n-    /// is either `x/y` or `x/y + 1`.\n-    ///\n-    pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n-\n-    ///\n-    /// Iterate over the range [`lo`..`hi`), or stop when requested\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * lo - The integer at which to start the loop (included)\n-    /// * hi - The integer at which to stop the loop (excluded)\n-    /// * it - A block to execute with each consecutive integer of the range.\n-    ///        Return `true` to continue, `false` to stop.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `true` If execution proceeded correctly, `false` if it was interrupted,\n-    /// that is if `it` returned `false` at any point.\n-    ///\n-    pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n-        let mut i = lo;\n-        while i < hi {\n-            if (!it(i)) { return false; }\n-            i += 1u;\n-        }\n-        return true;\n-    }\n-\n-    impl iter::Times for uint {\n-        #[inline(always)]\n-        ///\n-        /// A convenience form for basic iteration. Given a uint `x`,\n-        /// `for x.times { ... }` executes the given block x times.\n-        ///\n-        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n-        ///\n-        /// Not defined on all integer types to permit unambiguous\n-        /// use with integer literals of inferred integer-type as\n-        /// the self-value (eg. `for 100.times { ... }`).\n-        ///\n-        fn times(&self, it: &fn() -> bool) -> bool {\n-            let mut i = *self;\n-            while i > 0 {\n-                if !it() { return false; }\n-                i -= 1;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /// Returns the smallest power of 2 greater than or equal to `n`\n-    #[inline(always)]\n-    pub fn next_power_of_two(n: uint) -> uint {\n-        let halfbits: uint = sys::size_of::<uint>() * 4u;\n-        let mut tmp: uint = n - 1u;\n-        let mut shift: uint = 1u;\n-        while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-        return tmp + 1u;\n-    }\n-\n-    #[test]\n-    fn test_next_power_of_two() {\n-        assert_eq!(next_power_of_two(0u), 0u);\n-        assert_eq!(next_power_of_two(1u), 1u);\n-        assert_eq!(next_power_of_two(2u), 2u);\n-        assert_eq!(next_power_of_two(3u), 4u);\n-        assert_eq!(next_power_of_two(4u), 4u);\n-        assert_eq!(next_power_of_two(5u), 8u);\n-        assert_eq!(next_power_of_two(6u), 8u);\n-        assert_eq!(next_power_of_two(7u), 8u);\n-        assert_eq!(next_power_of_two(8u), 8u);\n-        assert_eq!(next_power_of_two(9u), 16u);\n-        assert_eq!(next_power_of_two(10u), 16u);\n-        assert_eq!(next_power_of_two(11u), 16u);\n-        assert_eq!(next_power_of_two(12u), 16u);\n-        assert_eq!(next_power_of_two(13u), 16u);\n-        assert_eq!(next_power_of_two(14u), 16u);\n-        assert_eq!(next_power_of_two(15u), 16u);\n-        assert_eq!(next_power_of_two(16u), 16u);\n-        assert_eq!(next_power_of_two(17u), 32u);\n-        assert_eq!(next_power_of_two(18u), 32u);\n-        assert_eq!(next_power_of_two(19u), 32u);\n-        assert_eq!(next_power_of_two(20u), 32u);\n-        assert_eq!(next_power_of_two(21u), 32u);\n-        assert_eq!(next_power_of_two(22u), 32u);\n-        assert_eq!(next_power_of_two(23u), 32u);\n-        assert_eq!(next_power_of_two(24u), 32u);\n-        assert_eq!(next_power_of_two(25u), 32u);\n-        assert_eq!(next_power_of_two(26u), 32u);\n-        assert_eq!(next_power_of_two(27u), 32u);\n-        assert_eq!(next_power_of_two(28u), 32u);\n-        assert_eq!(next_power_of_two(29u), 32u);\n-        assert_eq!(next_power_of_two(30u), 32u);\n-        assert_eq!(next_power_of_two(31u), 32u);\n-        assert_eq!(next_power_of_two(32u), 32u);\n-        assert_eq!(next_power_of_two(33u), 64u);\n-        assert_eq!(next_power_of_two(34u), 64u);\n-        assert_eq!(next_power_of_two(35u), 64u);\n-        assert_eq!(next_power_of_two(36u), 64u);\n-        assert_eq!(next_power_of_two(37u), 64u);\n-        assert_eq!(next_power_of_two(38u), 64u);\n-        assert_eq!(next_power_of_two(39u), 64u);\n-    }\n-\n-    #[test]\n-    fn test_overflows() {\n-        use uint;\n-        assert!((uint::max_value > 0u));\n-        assert!((uint::min_value <= 0u));\n-        assert_eq!(uint::min_value + uint::max_value + 1u, 0u);\n-    }\n-\n-    #[test]\n-    fn test_div() {\n-        assert_eq!(div_floor(3u, 4u), 0u);\n-        assert_eq!(div_ceil(3u, 4u), 1u);\n-        assert_eq!(div_round(3u, 4u), 1u);\n-    }\n-\n-    #[test]\n-    pub fn test_times() {\n-        use iter::Times;\n-        let ten = 10 as uint;\n-        let mut accum = 0;\n-        for ten.times { accum += 1; }\n-        assert_eq!(accum, 10);\n-    }\n-}"}, {"sha": "bcb97ff5a07f6c4d5d41ecd6568a48b3849b1a29", "filename": "src/libstd/num/uint.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for `uint`\n+\n+use iter;\n+use sys;\n+\n+pub use self::generated::*;\n+\n+uint_module!(uint, int, ::int::bits)\n+\n+///\n+/// Divide two numbers, return the result, rounded up.\n+///\n+/// # Arguments\n+///\n+/// * x - an integer\n+/// * y - an integer distinct from 0u\n+///\n+/// # Return value\n+///\n+/// The smallest integer `q` such that `x/y <= q`.\n+///\n+pub fn div_ceil(x: uint, y: uint) -> uint {\n+    let div = x / y;\n+    if x % y == 0u { div }\n+    else { div + 1u }\n+}\n+\n+///\n+/// Divide two numbers, return the result, rounded to the closest integer.\n+///\n+/// # Arguments\n+///\n+/// * x - an integer\n+/// * y - an integer distinct from 0u\n+///\n+/// # Return value\n+///\n+/// The integer `q` closest to `x/y`.\n+///\n+pub fn div_round(x: uint, y: uint) -> uint {\n+    let div = x / y;\n+    if x % y * 2u  < y { div }\n+    else { div + 1u }\n+}\n+\n+///\n+/// Divide two numbers, return the result, rounded down.\n+///\n+/// Note: This is the same function as `div`.\n+///\n+/// # Arguments\n+///\n+/// * x - an integer\n+/// * y - an integer distinct from 0u\n+///\n+/// # Return value\n+///\n+/// The smallest integer `q` such that `x/y <= q`. This\n+/// is either `x/y` or `x/y + 1`.\n+///\n+pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+\n+///\n+/// Iterate over the range [`lo`..`hi`), or stop when requested\n+///\n+/// # Arguments\n+///\n+/// * lo - The integer at which to start the loop (included)\n+/// * hi - The integer at which to stop the loop (excluded)\n+/// * it - A block to execute with each consecutive integer of the range.\n+///        Return `true` to continue, `false` to stop.\n+///\n+/// # Return value\n+///\n+/// `true` If execution proceeded correctly, `false` if it was interrupted,\n+/// that is if `it` returned `false` at any point.\n+///\n+pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    let mut i = lo;\n+    while i < hi {\n+        if (!it(i)) { return false; }\n+        i += 1u;\n+    }\n+    return true;\n+}\n+\n+impl iter::Times for uint {\n+    #[inline(always)]\n+    ///\n+    /// A convenience form for basic iteration. Given a uint `x`,\n+    /// `for x.times { ... }` executes the given block x times.\n+    ///\n+    /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n+    ///\n+    /// Not defined on all integer types to permit unambiguous\n+    /// use with integer literals of inferred integer-type as\n+    /// the self-value (eg. `for 100.times { ... }`).\n+    ///\n+    fn times(&self, it: &fn() -> bool) -> bool {\n+        let mut i = *self;\n+        while i > 0 {\n+            if !it() { return false; }\n+            i -= 1;\n+        }\n+        return true;\n+    }\n+}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`\n+#[inline(always)]\n+pub fn next_power_of_two(n: uint) -> uint {\n+    let halfbits: uint = sys::size_of::<uint>() * 4u;\n+    let mut tmp: uint = n - 1u;\n+    let mut shift: uint = 1u;\n+    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+    return tmp + 1u;\n+}\n+\n+#[test]\n+fn test_next_power_of_two() {\n+    assert!((next_power_of_two(0u) == 0u));\n+    assert!((next_power_of_two(1u) == 1u));\n+    assert!((next_power_of_two(2u) == 2u));\n+    assert!((next_power_of_two(3u) == 4u));\n+    assert!((next_power_of_two(4u) == 4u));\n+    assert!((next_power_of_two(5u) == 8u));\n+    assert!((next_power_of_two(6u) == 8u));\n+    assert!((next_power_of_two(7u) == 8u));\n+    assert!((next_power_of_two(8u) == 8u));\n+    assert!((next_power_of_two(9u) == 16u));\n+    assert!((next_power_of_two(10u) == 16u));\n+    assert!((next_power_of_two(11u) == 16u));\n+    assert!((next_power_of_two(12u) == 16u));\n+    assert!((next_power_of_two(13u) == 16u));\n+    assert!((next_power_of_two(14u) == 16u));\n+    assert!((next_power_of_two(15u) == 16u));\n+    assert!((next_power_of_two(16u) == 16u));\n+    assert!((next_power_of_two(17u) == 32u));\n+    assert!((next_power_of_two(18u) == 32u));\n+    assert!((next_power_of_two(19u) == 32u));\n+    assert!((next_power_of_two(20u) == 32u));\n+    assert!((next_power_of_two(21u) == 32u));\n+    assert!((next_power_of_two(22u) == 32u));\n+    assert!((next_power_of_two(23u) == 32u));\n+    assert!((next_power_of_two(24u) == 32u));\n+    assert!((next_power_of_two(25u) == 32u));\n+    assert!((next_power_of_two(26u) == 32u));\n+    assert!((next_power_of_two(27u) == 32u));\n+    assert!((next_power_of_two(28u) == 32u));\n+    assert!((next_power_of_two(29u) == 32u));\n+    assert!((next_power_of_two(30u) == 32u));\n+    assert!((next_power_of_two(31u) == 32u));\n+    assert!((next_power_of_two(32u) == 32u));\n+    assert!((next_power_of_two(33u) == 64u));\n+    assert!((next_power_of_two(34u) == 64u));\n+    assert!((next_power_of_two(35u) == 64u));\n+    assert!((next_power_of_two(36u) == 64u));\n+    assert!((next_power_of_two(37u) == 64u));\n+    assert!((next_power_of_two(38u) == 64u));\n+    assert!((next_power_of_two(39u) == 64u));\n+}\n+\n+#[test]\n+fn test_overflows() {\n+    use uint;\n+    assert!((uint::max_value > 0u));\n+    assert!((uint::min_value <= 0u));\n+    assert!((uint::min_value + uint::max_value + 1u == 0u));\n+}\n+\n+#[test]\n+fn test_div() {\n+    assert!((div_floor(3u, 4u) == 0u));\n+    assert!((div_ceil(3u, 4u)  == 1u));\n+    assert!((div_round(3u, 4u) == 1u));\n+}\n+\n+#[test]\n+pub fn test_times() {\n+    use iter::Times;\n+    let ten = 10 as uint;\n+    let mut accum = 0;\n+    for ten.times { accum += 1; }\n+    assert!((accum == 10));\n+}"}, {"sha": "3448314c4369267d5b1c4245544b7009104a3dfd", "filename": "src/libstd/num/uint_macros.rs", "status": "renamed", "additions": 208, "deletions": 182, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ec8fb884e94975ed6d82a4cc0ea0a064a4b7155f", "patch": "@@ -8,53 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use T = self::inst::T;\n-use T_SIGNED = self::inst::T_SIGNED;\n+// FIXME(#4375): this shouldn't have to be a nested module named 'generated'\n \n+#[macro_escape];\n+\n+macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (mod generated {\n+\n+use num::BitCount;\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmp::{min, max};\n \n-pub static bits : uint = inst::bits;\n-pub static bytes : uint = (inst::bits / 8);\n+pub static bits : uint = $bits;\n+pub static bytes : uint = ($bits / 8);\n \n-pub static min_value: T = 0 as T;\n-pub static max_value: T = 0 as T - 1 as T;\n+pub static min_value: $T = 0 as $T;\n+pub static max_value: $T = 0 as $T - 1 as $T;\n \n #[inline(always)]\n-pub fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: $T, y: $T) -> $T { x + y }\n #[inline(always)]\n-pub fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: $T, y: $T) -> $T { x - y }\n #[inline(always)]\n-pub fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: $T, y: $T) -> $T { x * y }\n #[inline(always)]\n-pub fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: $T, y: $T) -> $T { x / y }\n #[inline(always)]\n-pub fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n #[inline(always)]\n-pub fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: $T, y: $T) -> bool { x < y }\n #[inline(always)]\n-pub fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: $T, y: $T) -> bool { x <= y }\n #[inline(always)]\n-pub fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: $T, y: $T) -> bool { x == y }\n #[inline(always)]\n-pub fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: $T, y: $T) -> bool { x != y }\n #[inline(always)]\n-pub fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: $T, y: $T) -> bool { x >= y }\n #[inline(always)]\n-pub fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n #[inline(always)]\n ///\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n ///\n-pub fn _range_step(start: T,\n-                   stop: T,\n-                   step: T_SIGNED,\n-                   it: &fn(T) -> bool) -> bool {\n+pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(\"range_step called with step == 0\");\n@@ -63,78 +64,74 @@ pub fn _range_step(start: T,\n         while i < stop {\n             if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n-            if i > max_value - (step as T) { return true; }\n-            i += step as T;\n+            if i > max_value - (step as $T) { return true; }\n+            i += step as $T;\n         }\n     } else {\n         while i > stop {\n             if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n-            if i < min_value + ((-step) as T) { return true; }\n-            i -= -step as T;\n+            if i < min_value + ((-step) as $T) { return true; }\n+            i -= -step as $T;\n         }\n     }\n     return true;\n }\n \n-pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) -> bool {\n-    _range_step(start, stop, step, it)\n-}\n-\n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n-    range_step(lo, hi, 1 as T_SIGNED, it)\n+pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as $T_SIGNED, it)\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n-    range_step(hi, lo, -1 as T_SIGNED, it)\n+pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as $T_SIGNED, it)\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub fn compl(i: T) -> T {\n+pub fn compl(i: $T) -> $T {\n     max_value ^ i\n }\n \n-impl Num for T {}\n+impl Num for $T {}\n \n #[cfg(not(test))]\n-impl Ord for T {\n+impl Ord for $T {\n     #[inline(always)]\n-    fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &$T) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &$T) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &$T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(not(test))]\n-impl Eq for T {\n+impl Eq for $T {\n     #[inline(always)]\n-    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n-impl Orderable for T {\n+impl Orderable for $T {\n     #[inline(always)]\n-    fn min(&self, other: &T) -> T {\n+    fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n     #[inline(always)]\n-    fn max(&self, other: &T) -> T {\n+    fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     #[inline(always)]\n-    fn clamp(&self, mn: &T, mx: &T) -> T {\n+    fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n         cond!(\n             (*self > *mx) { *mx   }\n             (*self < *mn) { *mn   }\n@@ -143,81 +140,81 @@ impl Orderable for T {\n     }\n }\n \n-impl Zero for T {\n+impl Zero for $T {\n     #[inline(always)]\n-    fn zero() -> T { 0 }\n+    fn zero() -> $T { 0 }\n \n     #[inline(always)]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n-impl One for T {\n+impl One for $T {\n     #[inline(always)]\n-    fn one() -> T { 1 }\n+    fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n-impl Add<T,T> for T {\n+impl Add<$T,$T> for $T {\n     #[inline(always)]\n-    fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n-impl Sub<T,T> for T {\n+impl Sub<$T,$T> for $T {\n     #[inline(always)]\n-    fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n-impl Mul<T,T> for T {\n+impl Mul<$T,$T> for $T {\n     #[inline(always)]\n-    fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n #[cfg(not(test))]\n-impl Div<T,T> for T {\n+impl Div<$T,$T> for $T {\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n #[cfg(not(test))]\n-impl Rem<T,T> for T {\n+impl Rem<$T,$T> for $T {\n     #[inline(always)]\n-    fn rem(&self, other: &T) -> T { *self % *other }\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n-impl Neg<T> for T {\n+impl Neg<$T> for $T {\n     #[inline(always)]\n-    fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> $T { -*self }\n }\n \n-impl Unsigned for T {}\n+impl Unsigned for $T {}\n \n-impl Integer for T {\n+impl Integer for $T {\n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn div_rem(&self, other: &T) -> (T,T) {\n+    fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Unsigned integer division. Returns the same result as `div` (`/`).\n     #[inline(always)]\n-    fn div_floor(&self, other: &T) -> T { *self / *other }\n+    fn div_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n     #[inline(always)]\n-    fn mod_floor(&self, other: &T) -> T { *self / *other }\n+    fn mod_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Calculates `div_floor` and `modulo_floor` simultaneously\n     #[inline(always)]\n-    fn div_mod_floor(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n     #[inline(always)]\n-    fn gcd(&self, other: &T) -> T {\n+    fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut m = *self, n = *other;\n         while m != 0 {\n@@ -230,13 +227,13 @@ impl Integer for T {\n \n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     #[inline(always)]\n-    fn lcm(&self, other: &T) -> T {\n+    fn lcm(&self, other: &$T) -> $T {\n         (*self * *other) / self.gcd(other)\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn is_multiple_of(&self, other: &T) -> bool { *self % *other == 0 }\n+    fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n@@ -247,87 +244,87 @@ impl Integer for T {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n-impl Bitwise for T {}\n+impl Bitwise for $T {}\n \n #[cfg(not(test))]\n-impl BitOr<T,T> for T {\n+impl BitOr<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitor(&self, other: &T) -> T { *self | *other }\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n-impl BitAnd<T,T> for T {\n+impl BitAnd<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitand(&self, other: &T) -> T { *self & *other }\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n-impl BitXor<T,T> for T {\n+impl BitXor<$T,$T> for $T {\n     #[inline(always)]\n-    fn bitxor(&self, other: &T) -> T { *self ^ *other }\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n-impl Shl<T,T> for T {\n+impl Shl<$T,$T> for $T {\n     #[inline(always)]\n-    fn shl(&self, other: &T) -> T { *self << *other }\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n-impl Shr<T,T> for T {\n+impl Shr<$T,$T> for $T {\n     #[inline(always)]\n-    fn shr(&self, other: &T) -> T { *self >> *other }\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n-impl Not<T> for T {\n+impl Not<$T> for $T {\n     #[inline(always)]\n-    fn not(&self) -> T { !*self }\n+    fn not(&self) -> $T { !*self }\n }\n \n-impl Bounded for T {\n+impl Bounded for $T {\n     #[inline(always)]\n-    fn min_value() -> T { min_value }\n+    fn min_value() -> $T { min_value }\n \n     #[inline(always)]\n-    fn max_value() -> T { max_value }\n+    fn max_value() -> $T { max_value }\n }\n \n-impl Int for T {}\n+impl Int for $T {}\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, false, false, false,\n                                    strconv::ExpNone, false, false)\n }\n \n-impl FromStr for T {\n+impl FromStr for $T {\n     #[inline(always)]\n-    fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n-impl FromStrRadix for T {\n+impl FromStrRadix for $T {\n     #[inline(always)]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -336,165 +333,192 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub fn to_str(num: T) -> ~str {\n+pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n-impl ToStr for T {\n+impl ToStr for $T {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n-impl ToStrRadix for T {\n+impl ToStrRadix for $T {\n     #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }\n \n+impl Primitive for $T {\n+    #[inline(always)]\n+    fn bits() -> uint { bits }\n+\n+    #[inline(always)]\n+    fn bytes() -> uint { bits / 8 }\n+}\n+\n+impl BitCount for $T {\n+    /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+    #[inline(always)]\n+    fn population_count(&self) -> $T {\n+        (*self as $T_SIGNED).population_count() as $T\n+    }\n+\n+    /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+    #[inline(always)]\n+    fn leading_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).leading_zeros() as $T\n+    }\n+\n+    /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+    #[inline(always)]\n+    fn trailing_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).trailing_zeros() as $T\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use super::inst::T;\n     use prelude::*;\n \n     #[test]\n     fn test_num() {\n-        num::test_num(10 as T, 2 as T);\n+        num::test_num(10 as $T, 2 as $T);\n     }\n \n     #[test]\n     fn test_orderable() {\n-        assert_eq!((1 as T).min(&(2 as T)), 1 as T);\n-        assert_eq!((2 as T).min(&(1 as T)), 1 as T);\n-        assert_eq!((1 as T).max(&(2 as T)), 2 as T);\n-        assert_eq!((2 as T).max(&(1 as T)), 2 as T);\n-        assert_eq!((1 as T).clamp(&(2 as T), &(4 as T)), 2 as T);\n-        assert_eq!((8 as T).clamp(&(2 as T), &(4 as T)), 4 as T);\n-        assert_eq!((3 as T).clamp(&(2 as T), &(4 as T)), 3 as T);\n+        assert_eq!((1 as $T).min(&(2 as $T)), 1 as $T);\n+        assert_eq!((2 as $T).min(&(1 as $T)), 1 as $T);\n+        assert_eq!((1 as $T).max(&(2 as $T)), 2 as $T);\n+        assert_eq!((2 as $T).max(&(1 as $T)), 2 as $T);\n+        assert_eq!((1 as $T).clamp(&(2 as $T), &(4 as $T)), 2 as $T);\n+        assert_eq!((8 as $T).clamp(&(2 as $T), &(4 as $T)), 4 as $T);\n+        assert_eq!((3 as $T).clamp(&(2 as $T), &(4 as $T)), 3 as $T);\n     }\n \n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(&2), 2 as T);\n-        assert_eq!((10 as T).gcd(&3), 1 as T);\n-        assert_eq!((0 as T).gcd(&3), 3 as T);\n-        assert_eq!((3 as T).gcd(&3), 3 as T);\n-        assert_eq!((56 as T).gcd(&42), 14 as T);\n+        assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+        assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+        assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+        assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+        assert_eq!((56 as $T).gcd(&42), 14 as $T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(&0), 0 as T);\n-        assert_eq!((0 as T).lcm(&1), 0 as T);\n-        assert_eq!((1 as T).lcm(&1), 1 as T);\n-        assert_eq!((8 as T).lcm(&9), 72 as T);\n-        assert_eq!((11 as T).lcm(&5), 55 as T);\n-        assert_eq!((99 as T).lcm(&17), 1683 as T);\n+        assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+        assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+        assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+        assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+        assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+        assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n     }\n \n     #[test]\n     fn test_multiple_of() {\n-        assert!((6 as T).is_multiple_of(&(6 as T)));\n-        assert!((6 as T).is_multiple_of(&(3 as T)));\n-        assert!((6 as T).is_multiple_of(&(1 as T)));\n+        assert!((6 as $T).is_multiple_of(&(6 as $T)));\n+        assert!((6 as $T).is_multiple_of(&(3 as $T)));\n+        assert!((6 as $T).is_multiple_of(&(1 as $T)));\n     }\n \n     #[test]\n     fn test_even() {\n-        assert_eq!((0 as T).is_even(), true);\n-        assert_eq!((1 as T).is_even(), false);\n-        assert_eq!((2 as T).is_even(), true);\n-        assert_eq!((3 as T).is_even(), false);\n-        assert_eq!((4 as T).is_even(), true);\n+        assert_eq!((0 as $T).is_even(), true);\n+        assert_eq!((1 as $T).is_even(), false);\n+        assert_eq!((2 as $T).is_even(), true);\n+        assert_eq!((3 as $T).is_even(), false);\n+        assert_eq!((4 as $T).is_even(), true);\n     }\n \n     #[test]\n     fn test_odd() {\n-        assert_eq!((0 as T).is_odd(), false);\n-        assert_eq!((1 as T).is_odd(), true);\n-        assert_eq!((2 as T).is_odd(), false);\n-        assert_eq!((3 as T).is_odd(), true);\n-        assert_eq!((4 as T).is_odd(), false);\n+        assert_eq!((0 as $T).is_odd(), false);\n+        assert_eq!((1 as $T).is_odd(), true);\n+        assert_eq!((2 as $T).is_odd(), false);\n+        assert_eq!((3 as $T).is_odd(), true);\n+        assert_eq!((4 as $T).is_odd(), false);\n     }\n \n     #[test]\n     fn test_bitwise() {\n-        assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n-        assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n-        assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n-        assert_eq!(0b1110 as T, (0b0111 as T).shl(&(1 as T)));\n-        assert_eq!(0b0111 as T, (0b1110 as T).shr(&(1 as T)));\n-        assert_eq!(max_value - (0b1011 as T), (0b1011 as T).not());\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n+        assert_eq!(max_value - (0b1011 as $T), (0b1011 as $T).not());\n     }\n \n     #[test]\n     fn test_bitcount() {\n-        assert_eq!((0b010101 as T).population_count(), 3);\n+        assert_eq!((0b010101 as $T).population_count(), 3);\n     }\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<T>(), sys::size_of::<T>() * 8);\n-        assert_eq!(Primitive::bytes::<T>(), sys::size_of::<T>());\n+        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n     }\n \n     #[test]\n     pub fn test_to_str() {\n-        assert_eq!(to_str_radix(0 as T, 10u), ~\"0\");\n-        assert_eq!(to_str_radix(1 as T, 10u), ~\"1\");\n-        assert_eq!(to_str_radix(2 as T, 10u), ~\"2\");\n-        assert_eq!(to_str_radix(11 as T, 10u), ~\"11\");\n-        assert_eq!(to_str_radix(11 as T, 16u), ~\"b\");\n-        assert_eq!(to_str_radix(255 as T, 16u), ~\"ff\");\n-        assert_eq!(to_str_radix(0xff as T, 10u), ~\"255\");\n+        assert_eq!(to_str_radix(0 as $T, 10u), ~\"0\");\n+        assert_eq!(to_str_radix(1 as $T, 10u), ~\"1\");\n+        assert_eq!(to_str_radix(2 as $T, 10u), ~\"2\");\n+        assert_eq!(to_str_radix(11 as $T, 10u), ~\"11\");\n+        assert_eq!(to_str_radix(11 as $T, 16u), ~\"b\");\n+        assert_eq!(to_str_radix(255 as $T, 16u), ~\"ff\");\n+        assert_eq!(to_str_radix(0xff as $T, 10u), ~\"255\");\n     }\n \n     #[test]\n     pub fn test_from_str() {\n-        assert_eq!(from_str(\"0\"), Some(0u as T));\n-        assert_eq!(from_str(\"3\"), Some(3u as T));\n-        assert_eq!(from_str(\"10\"), Some(10u as T));\n-        assert_eq!(u32::from_str(\"123456789\"), Some(123456789 as u32));\n-        assert_eq!(from_str(\"00100\"), Some(100u as T));\n+        assert_eq!(from_str(~\"0\"), Some(0u as $T));\n+        assert_eq!(from_str(~\"3\"), Some(3u as $T));\n+        assert_eq!(from_str(~\"10\"), Some(10u as $T));\n+        assert_eq!(u32::from_str(~\"123456789\"), Some(123456789 as u32));\n+        assert_eq!(from_str(~\"00100\"), Some(100u as $T));\n \n-        assert!(from_str(\"\").is_none());\n-        assert!(from_str(\" \").is_none());\n-        assert!(from_str(\"x\").is_none());\n+        assert!(from_str(~\"\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n     }\n \n     #[test]\n     pub fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123u as T));\n-        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9u as T));\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83u as T));\n-        assert_eq!(u16::parse_bytes(to_bytes(\"123\"), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35u as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123u as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9u as $T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83u as $T));\n+        assert_eq!(u16::parse_bytes(to_bytes(~\"123\"), 16u), Some(291u as u16));\n+        assert_eq!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535u as u16));\n+        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35u as $T));\n \n-        assert!(parse_bytes(to_bytes(\"Z\"), 10u).is_none());\n-        assert!(parse_bytes(to_bytes(\"_\"), 2u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n     }\n \n     #[test]\n@@ -527,36 +551,36 @@ mod tests {\n     #[test]\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8::from_str(\"255\"), Some(u8_val));\n-        assert!(u8::from_str(\"256\").is_none());\n+        assert_eq!(u8::from_str(~\"255\"), Some(u8_val));\n+        assert!(u8::from_str(~\"256\").is_none());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8::from_str(\"0\"), Some(u8_val));\n-        assert!(u8::from_str(\"-1\").is_none());\n+        assert_eq!(u8::from_str(~\"0\"), Some(u8_val));\n+        assert!(u8::from_str(~\"-1\").is_none());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16::from_str(\"65535\"), Some(u16_val));\n-        assert!(u16::from_str(\"65536\").is_none());\n+        assert_eq!(u16::from_str(~\"65535\"), Some(u16_val));\n+        assert!(u16::from_str(~\"65536\").is_none());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16::from_str(\"0\"), Some(u16_val));\n-        assert!(u16::from_str(\"-1\").is_none());\n+        assert_eq!(u16::from_str(~\"0\"), Some(u16_val));\n+        assert!(u16::from_str(~\"-1\").is_none());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32::from_str(\"4294967295\"), Some(u32_val));\n-        assert!(u32::from_str(\"4294967296\").is_none());\n+        assert_eq!(u32::from_str(~\"4294967295\"), Some(u32_val));\n+        assert!(u32::from_str(~\"4294967296\").is_none());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32::from_str(\"0\"), Some(u32_val));\n-        assert!(u32::from_str(\"-1\").is_none());\n+        assert_eq!(u32::from_str(~\"0\"), Some(u32_val));\n+        assert!(u32::from_str(~\"-1\").is_none());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64::from_str(\"18446744073709551615\"), Some(u64_val));\n-        assert!(u64::from_str(\"18446744073709551616\").is_none());\n+        assert_eq!(u64::from_str(~\"18446744073709551615\"), Some(u64_val));\n+        assert!(u64::from_str(~\"18446744073709551616\").is_none());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64::from_str(\"0\"), Some(u64_val));\n-        assert!(u64::from_str(\"-1\").is_none());\n+        assert_eq!(u64::from_str(~\"0\"), Some(u64_val));\n+        assert!(u64::from_str(~\"-1\").is_none());\n     }\n \n     #[test]\n@@ -639,3 +663,5 @@ mod tests {\n         for range_step(0,-10,0) |_i| {}\n     }\n }\n+\n+}))", "previous_filename": "src/libstd/num/uint-template.rs"}]}