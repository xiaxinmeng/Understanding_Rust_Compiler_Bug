{"sha": "4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMDRlMzZmOTRjNGI4NWI2MTNhMmQ1ZmU1Yzk1MTEwNTNjYmRlYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-22T20:11:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-22T20:11:04Z"}, "message": "Auto merge of #36651 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 7 pull requests\n\n- Successful merges: #36330, #36423, #36539, #36571, #36589, #36600, #36632\n- Failed merges:", "tree": {"sha": "f64b8be295c1dbf85c95dbf4411f1b8b9dcd0d88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f64b8be295c1dbf85c95dbf4411f1b8b9dcd0d88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "html_url": "https://github.com/rust-lang/rust/commit/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458f41121374291ac1c0d84dd24123d5edcb2967", "url": "https://api.github.com/repos/rust-lang/rust/commits/458f41121374291ac1c0d84dd24123d5edcb2967", "html_url": "https://github.com/rust-lang/rust/commit/458f41121374291ac1c0d84dd24123d5edcb2967"}, {"sha": "c1e39380fbb04691cdcf6c58e2c0054110fa698c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e39380fbb04691cdcf6c58e2c0054110fa698c", "html_url": "https://github.com/rust-lang/rust/commit/c1e39380fbb04691cdcf6c58e2c0054110fa698c"}], "stats": {"total": 600, "additions": 401, "deletions": 199}, "files": [{"sha": "e0f635f195bcd770bbb147440b3f20090320746f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 310, "deletions": 160, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -10,90 +10,138 @@\n \n #![allow(deprecated)]\n \n-//! Unsynchronized reference-counted boxes (the `Rc<T>` type) which are usable\n-//! only within a single thread.\n+//! Single-threaded reference-counting pointers.\n //!\n-//! The `Rc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as non-sendable because it avoids the overhead of atomic\n-//! reference counting.\n+//! The type [`Rc<T>`][rc] provides shared ownership of a value, allocated\n+//! in the heap. Invoking [`clone`][clone] on `Rc` produces a new pointer\n+//! to the same value in the heap. When the last `Rc` pointer to a given\n+//! value is destroyed, the pointed-to value is also destroyed.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n+//! Shared pointers in Rust disallow mutation by default, and `Rc` is no\n+//! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n+//! [`RefCell`][refcell].\n //!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Rc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! `Rc` uses non-atomic reference counting. This means that overhead is very\n+//! low, but an `Rc` cannot be sent between threads, and consequently `Rc`\n+//! does not implement [`Send`][send]. As a result, the Rust compiler\n+//! will check *at compile time* that you are not sending `Rc`s between\n+//! threads. If you need multi-threaded, atomic reference counting, use\n+//! [`sync::Arc`][arc].\n+//!\n+//! The [`downgrade`][downgrade] method can be used to create a non-owning\n+//! [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n+//! to an `Rc`, but this will return [`None`][option] if the value has\n+//! already been dropped.\n+//!\n+//! A cycle between `Rc` pointers will never be deallocated. For this reason,\n+//! `Weak` is used to break cycles. For example, a tree could have strong\n+//! `Rc` pointers from parent nodes to children, and `Weak` pointers from\n+//! children back to their parents.\n+//!\n+//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+//! so you can call `T`'s methods on a value of type `Rc<T>`. To avoid name\n+//! clashes with `T`'s methods, the methods of `Rc<T>` itself are [associated\n+//! functions][assoc], called using function-like syntax:\n+//!\n+//! ```\n+//! # use std::rc::Rc;\n+//! # let my_rc = Rc::new(());\n+//! Rc::downgrade(&my_rc);\n+//! ```\n+//!\n+//! `Weak<T>` does not auto-dereference to `T`, because the value may have\n+//! already been destroyed.\n+//!\n+//! [rc]: struct.Rc.html\n+//! [weak]: struct.Weak.html\n+//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+//! [cell]: ../../std/cell/struct.Cell.html\n+//! [refcell]: ../../std/cell/struct.RefCell.html\n+//! [send]: ../../std/marker/trait.Send.html\n+//! [arc]: ../../std/sync/struct.Arc.html\n+//! [deref]: ../../std/ops/trait.Deref.html\n+//! [downgrade]: struct.Rc.html#method.downgrade\n+//! [upgrade]: struct.Weak.html#method.upgrade\n+//! [option]: ../../std/option/enum.Option.html\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n //!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n //! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n //! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s,\n+//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s,\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //!\n //! struct Owner {\n-//!     name: String\n+//!     name: String,\n //!     // ...other fields\n //! }\n //!\n //! struct Gadget {\n //!     id: i32,\n-//!     owner: Rc<Owner>\n+//!     owner: Rc<Owner>,\n //!     // ...other fields\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n-//!         Owner { name: String::from(\"Gadget Man\") }\n+//!     // Create a reference-counted `Owner`.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n+//!         Owner {\n+//!             name: \"Gadget Man\".to_string(),\n+//!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner. To increment the reference\n-//!     // count we clone the `Rc<T>` object.\n-//!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n-//!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+//!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n+//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // the reference count in the process.\n+//!     let gadget1 = Gadget {\n+//!         id: 1,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n+//!     let gadget2 = Gadget {\n+//!         id: 2,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n //!\n+//!     // Dispose of our local variable `gadget_owner`.\n //!     drop(gadget_owner);\n //!\n-//!     // Despite dropping gadget_owner, we're still able to print out the name\n-//!     // of the Owner of the Gadgets. This is because we've only dropped the\n-//!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other `Rc<T>` objects pointing at the same Owner, it will remain\n-//!     // allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets\n-//!     // automatically dereferenced for us.\n+//!     // Despite dropping `gadget_owner`, we're still able to print out the name\n+//!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n+//!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n+//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n+//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n //!\n-//!     // At the end of the method, gadget1 and gadget2 get destroyed, and with\n-//!     // them the last counted references to our Owner. Gadget Man now gets\n-//!     // destroyed as well.\n+//!     // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n+//!     // with them the last counted references to our `Owner`. Gadget Man now\n+//!     // gets destroyed as well.\n //! }\n //! ```\n //!\n //! If our requirements change, and we also need to be able to traverse from\n-//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc<T>` pointer from Owner\n-//! \u2192\u00a0Gadget introduces a cycle between the objects. This means that their\n-//! reference counts can never reach 0, and the objects will remain allocated: a\n-//! memory leak. In order to get around this, we can use `Weak<T>` pointers.\n-//! These pointers don't contribute to the total count.\n+//! `Owner` to\u00a0`Gadget`, we will run into problems. An `Rc` pointer from `Owner`\n+//! to `Gadget` introduces a cycle between the values. This means that their\n+//! reference counts can never reach 0, and the values will remain allocated\n+//! forever: a memory leak. In order to get around this, we can use `Weak`\n+//! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n-//! place: in order to end up with two objects that point at each other, one of\n-//! them needs to be mutable. This is problematic because `Rc<T>` enforces\n-//! memory safety by only giving out shared references to the object it wraps,\n+//! place. In order to end up with two values that point at each other, one of\n+//! them needs to be mutable. This is difficult because `Rc` enforces\n+//! memory safety by only giving out shared references to the value it wraps,\n //! and these don't allow direct mutation. We need to wrap the part of the\n-//! object we wish to mutate in a `RefCell`, which provides *interior\n+//! value we wish to mutate in a [`RefCell`][refcell], which provides *interior\n //! mutability*: a method to achieve mutability through a shared reference.\n-//! `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell`\n-//! documentation for more details on interior mutability.\n+//! `RefCell` enforces Rust's borrowing rules at runtime.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //! use std::rc::Weak;\n //! use std::cell::RefCell;\n@@ -111,41 +159,58 @@\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner. Note the fact that we've put the\n-//!     // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n-//!     // through a shared reference.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n+//!     // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n+//!     // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n+//!     // a shared reference.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n //!         Owner {\n //!             name: \"Gadget Man\".to_string(),\n-//!             gadgets: RefCell::new(Vec::new()),\n+//!             gadgets: RefCell::new(vec![]),\n //!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner as before.\n-//!     let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n-//!     let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+//!     // Create `Gadget`s belonging to `gadget_owner`, as before.\n+//!     let gadget1 = Rc::new(\n+//!         Gadget {\n+//!             id: 1,\n+//!             owner: gadget_owner.clone(),\n+//!         }\n+//!     );\n+//!     let gadget2 = Rc::new(\n+//!         Gadget {\n+//!             id: 2,\n+//!             owner: gadget_owner.clone(),\n+//!         }\n+//!     );\n+//!\n+//!     // Add the `Gadget`s to their `Owner`.\n+//!     {\n+//!         let mut gadgets = gadget_owner.gadgets.borrow_mut();\n+//!         gadgets.push(Rc::downgrade(&gadget1));\n+//!         gadgets.push(Rc::downgrade(&gadget2));\n //!\n-//!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n-//!     // the RefCell holding the Owner's Gadgets.\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));\n+//!         // `RefCell` dynamic borrow ends here.\n+//!     }\n //!\n-//!     // Iterate over our Gadgets, printing their details out\n-//!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+//!     // Iterate over our `Gadget`s, printing their details out.\n+//!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n-//!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still allocated, we need to call upgrade()\n-//!         // on them to turn them into a strong reference. This returns an\n-//!         // Option, which contains a reference to our object if it still\n-//!         // exists.\n-//!         let gadget = gadget_opt.upgrade().unwrap();\n+//!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n+//!         // guarantee the value is still allocated, we need to call\n+//!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n+//!         //\n+//!         // In this case we know the value still exists, so we simply\n+//!         // `unwrap` the `Option`. In a more complicated program, you might\n+//!         // need graceful error handling for a `None` result.\n+//!\n+//!         let gadget = gadget_weak.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n //!\n-//!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-//!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n-//!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n-//!     // reference count on Gadget Man, they get destroyed as well.\n+//!     // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n+//!     // are destroyed. There are now no strong (`Rc`) pointers to the\n+//!     // gadgets, so they are destroyed. This zeroes the reference count on\n+//!     // Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n \n@@ -179,15 +244,14 @@ struct RcBox<T: ?Sized> {\n }\n \n \n-/// A reference-counted pointer type over an immutable value.\n+/// A single-threaded reference-counting pointer.\n ///\n-/// See the [module level documentation](./index.html) for more details.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// Note: the inherent methods defined on `Rc<T>` are all associated functions,\n-/// which means that you have to call them as e.g. `Rc::get_mut(&value)` instead\n-/// of `value.get_mut()`.  This is so that there are no conflicts with methods\n-/// on the inner type `T`, which are what you want to call in the majority of\n-/// cases.\n+/// The inherent methods of `Rc` are all associated functions, which means\n+/// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n+/// `value.get_mut()`.  This avoids conflicts with methods of the inner\n+/// type `T`.\n #[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n@@ -229,9 +293,9 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Unwraps the contained value if the `Rc<T>` has exactly one strong reference.\n+    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Rc<T>`.\n+    /// Otherwise, an `Err` is returned with the same `Rc` that was passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n@@ -245,7 +309,7 @@ impl<T> Rc<T> {\n     ///\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -268,7 +332,7 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks if `Rc::try_unwrap` would return `Ok`.\n+    /// Checks whether `Rc::try_unwrap` would return `Ok`.\n     ///\n     /// # Examples\n     ///\n@@ -284,7 +348,7 @@ impl<T> Rc<T> {\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n     /// assert!(!Rc::would_unwrap(&x));\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[unstable(feature = \"rc_would_unwrap\",\n                reason = \"just added for niche usecase\",\n@@ -295,7 +359,9 @@ impl<T> Rc<T> {\n }\n \n impl<T: ?Sized> Rc<T> {\n-    /// Creates a new `Weak<T>` reference from this value.\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -312,24 +378,54 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Get the number of weak references to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _weak_five = Rc::downgrade(&five);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.weak() - 1\n     }\n \n-    /// Get the number of strong references to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _also_five = five.clone();\n+    ///\n+    /// assert_eq!(2, Rc::strong_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n-    /// the same inner value.\n+    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// this inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -349,10 +445,19 @@ impl<T: ?Sized> Rc<T> {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the contained value if the `Rc<T>` has\n-    /// one strong reference and no weak references.\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n     ///\n-    /// Returns `None` if the `Rc<T>` is not unique.\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Rc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///\n     /// # Examples\n     ///\n@@ -381,8 +486,8 @@ impl<T: ?Sized> Rc<T> {\n     #[unstable(feature = \"ptr_eq\",\n                reason = \"newly added\",\n                issue = \"36497\")]\n-    /// Return whether two `Rc` references point to the same value\n-    /// (not just values that compare equal).\n+    /// Returns true if the two `Rc`s point to the same value (not\n+    /// just values that compare as equal).\n     ///\n     /// # Examples\n     ///\n@@ -406,11 +511,17 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n-    /// data if the `Rc<T>` doesn't have one strong reference and no weak\n-    /// references.\n+    /// Makes a mutable reference into the given `Rc`.\n+    ///\n+    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n     ///\n-    /// This is also referred to as a copy-on-write.\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -419,16 +530,15 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// let mut data = Rc::new(5);\n     ///\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// let mut other_data = data.clone(); // Won't clone inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Clones inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// *Rc::make_mut(&mut other_data) *= 2;       // Won't clone anything\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// let mut other_data = data.clone();    // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Note: data and other_data now point to different numbers\n+    /// // Now `data` and `other_data` point to different values.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -470,30 +580,30 @@ impl<T: ?Sized> Deref for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n-    /// Drops the `Rc<T>`.\n+    /// Drops the `Rc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n+    /// count reaches zero then the only other references (if any) are `Weak`,\n+    /// so we `drop` the inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n+    /// struct Foo;\n     ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n     ///\n-    ///     // stuff\n+    /// let foo  = Rc::new(Foo);\n+    /// let foo2 = foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -519,10 +629,10 @@ impl<T: ?Sized> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n-    /// Makes a clone of the `Rc<T>`.\n+    /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n-    /// increase the strong reference counter.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n     ///\n     /// # Examples\n     ///\n@@ -550,6 +660,7 @@ impl<T: Default> Default for Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// let x: Rc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n     /// ```\n     #[inline]\n     fn default() -> Rc<T> {\n@@ -559,9 +670,9 @@ impl<T: Default> Default for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n-    /// Equality for two `Rc<T>`s.\n+    /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are equal if their inner value are equal.\n+    /// Two `Rc`s are equal if their inner values are equal.\n     ///\n     /// # Examples\n     ///\n@@ -570,16 +681,16 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five == Rc::new(5);\n+    /// assert!(five == Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         **self == **other\n     }\n \n-    /// Inequality for two `Rc<T>`s.\n+    /// Inequality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are unequal if their inner value are unequal.\n+    /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n     /// # Examples\n     ///\n@@ -588,7 +699,7 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five != Rc::new(5);\n+    /// assert!(five != Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool {\n@@ -601,25 +712,26 @@ impl<T: ?Sized + Eq> Eq for Rc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n-    /// Partial comparison for two `Rc<T>`s.\n+    /// Partial comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Rc::new(6)));\n     /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n-    /// Less-than comparison for two `Rc<T>`s.\n+    /// Less-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<` on their inner values.\n     ///\n@@ -630,14 +742,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five < Rc::new(5);\n+    /// assert!(five < Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool {\n         **self < **other\n     }\n \n-    /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Less than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<=` on their inner values.\n     ///\n@@ -648,14 +760,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five <= Rc::new(5);\n+    /// assert!(five <= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool {\n         **self <= **other\n     }\n \n-    /// Greater-than comparison for two `Rc<T>`s.\n+    /// Greater-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>` on their inner values.\n     ///\n@@ -666,14 +778,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five > Rc::new(5);\n+    /// assert!(five > Rc::new(4));\n     /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool {\n         **self > **other\n     }\n \n-    /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Greater than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>=` on their inner values.\n     ///\n@@ -684,7 +796,7 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five >= Rc::new(5);\n+    /// assert!(five >= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool {\n@@ -694,18 +806,19 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Rc<T> {\n-    /// Comparison for two `Rc<T>`s.\n+    /// Comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Ordering::Less, five.cmp(&Rc::new(6)));\n     /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering {\n@@ -748,12 +861,18 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n-/// A weak version of `Rc<T>`.\n+/// A weak version of [`Rc`][rc].\n+///\n+/// `Weak` pointers do not count towards determining if the inner value\n+/// should be dropped.\n+///\n+/// The typical way to obtain a `Weak` pointer is to call\n+/// [`Rc::downgrade`][downgrade].\n ///\n-/// Weak references do not count when determining if the inner value should be\n-/// dropped.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// See the [module level documentation](./index.html) for more.\n+/// [rc]: struct.Rc.html\n+/// [downgrade]: struct.Rc.html#method.downgrade\n #[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n@@ -769,17 +888,22 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n     ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Weak;\n     ///\n     /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n@@ -796,12 +920,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n+    /// Upgrades the `Weak` pointer to an [`Rc`][rc], if possible.\n     ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    /// Returns [`None`][option] if the strong count has reached zero and the\n+    /// inner value was destroyed.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// [rc]: struct.Rc.html\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -813,6 +938,13 @@ impl<T: ?Sized> Weak<T> {\n     /// let weak_five = Rc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n@@ -827,7 +959,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n+    /// Drops the `Weak` pointer.\n     ///\n     /// This will decrement the weak reference count.\n     ///\n@@ -836,21 +968,22 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(weak_five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n     ///\n-    ///     // stuff\n+    /// let foo = Rc::new(Foo);\n+    /// let weak_foo = Rc::downgrade(&foo);\n+    /// let other_weak_foo = weak_foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n+    ///\n+    /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n@@ -868,9 +1001,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n+    /// Makes a clone of the `Weak` pointer.\n     ///\n-    /// This increases the weak reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// weak reference count.\n     ///\n     /// # Examples\n     ///\n@@ -897,7 +1031,23 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Creates a new `Weak<T>`.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    ///\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n     fn default() -> Weak<T> {\n         Weak::new()\n     }"}, {"sha": "54dc7ec06da16b9661bf7f9547ad6eaaf9ba49b9", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -1037,7 +1037,7 @@ impl<T> [T] {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    /// Sorts the slice, in place, using `key` to extract a key by which to\n+    /// Sorts the slice, in place, using `f` to extract a key by which to\n     /// order the sort by.\n     ///\n     /// This sort is stable and `O(n log n)` worst-case but allocates"}, {"sha": "a21d1229d358be89a4c57be74bdc03c48caf5bc2", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -800,7 +800,7 @@ pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter>\n \n /// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(PartialEq, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n pub struct InvalidSequence(());\n \n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]"}, {"sha": "ec7add9c3759f9d61969d6303aa0d6363186923e", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -31,7 +31,7 @@ pub struct FormatSpec {\n }\n \n /// Possible alignments that can be requested as part of a formatting directive.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n     Left,"}, {"sha": "eee3e9250fe816a2778afbc3616cd76c9aba6efa", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -155,13 +155,13 @@ from_str_float_impl!(f64);\n /// [`FromStr`]: ../str/trait.FromStr.html\n /// [`f32`]: ../../std/primitive.f32.html\n /// [`f64`]: ../../std/primitive.f64.html\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n     kind: FloatErrorKind\n }\n \n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum FloatErrorKind {\n     Empty,\n     Invalid,"}, {"sha": "72529d3da01d11b0325827f103096b9b2356c779", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -21,7 +21,7 @@ use num::dec2flt::rawfp::RawFloat;\n /// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n ///   round to the original value. The range is inclusive only when\n ///   `inclusive` is true.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Decoded {\n     /// The scaled mantissa.\n     pub mant: u64,\n@@ -38,7 +38,7 @@ pub struct Decoded {\n }\n \n /// Decoded unsigned value.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum FullDecoded {\n     /// Not-a-number.\n     Nan,"}, {"sha": "7b797631dfd5742b1455720c978a3c940652c1ae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -2401,7 +2401,7 @@ impl usize {\n /// assert_eq!(nan.classify(), FpCategory::Nan);\n /// assert_eq!(sub.classify(), FpCategory::Subnormal);\n /// ```\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero.\n@@ -2744,11 +2744,11 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n /// on the primitive integer types, such as [`i8::from_str_radix()`].\n ///\n /// [`i8::from_str_radix()`]: ../../std/primitive.i8.html#method.from_str_radix\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseIntError { kind: IntErrorKind }\n \n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum IntErrorKind {\n     Empty,\n     InvalidDigit,"}, {"sha": "cb18feff7342240e6fdd8c6569f2078124cd078b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -296,16 +296,14 @@ impl<T> Option<T> {\n \n     /// Moves the value `v` out of the `Option<T>` if it is `Some(v)`.\n     ///\n-    /// # Panics\n-    ///\n-    /// Panics if the self value equals `None`.\n-    ///\n-    /// # Safety note\n-    ///\n     /// In general, because this function may panic, its use is discouraged.\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the self value equals `None`.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "d63d2d64fe1018fc40d8065cb3cf018973586730", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -101,7 +101,7 @@ impl FromStr for bool {\n }\n \n /// An error returned when parsing a `bool` from a string fails.\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }\n "}, {"sha": "e406807b51c315bd17a9e5635fc0f3f297e227fa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -3099,7 +3099,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(field_name) = Self::suggest_field_name(variant,\n                                                            &field.name,\n                                                            skip_fields.collect()) {\n-            err.span_label(field.name.span,&format!(\"did you mean `{}`?\",field_name));\n+            err.span_label(field.name.span,\n+                           &format!(\"field does not exist - did you mean `{}`?\", field_name));\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(adt, ..) if adt.is_enum() => {\n+                    err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n+                                                             ty, variant.name.as_str()));\n+                }\n+                _ => {\n+                    err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));\n+                }\n+            }\n         };\n         err.emit();\n     }"}, {"sha": "28081367cede49b682003c5d472aaaf939ec7c29", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -146,19 +146,19 @@ pub struct CStr {\n \n /// An error returned from `CString::new` to indicate that a nul byte was found\n /// in the vector provided.\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n /// An error returned from `CStr::from_bytes_with_nul` to indicate that a nul\n /// byte was found too early in the slice provided or one wasn't found at all.\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub struct FromBytesWithNulError { _a: () }\n \n /// An error returned from `CString::into_string` to indicate that a UTF-8 error\n /// was encountered during the conversion.\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n     inner: CString,"}, {"sha": "4ff8c6ac128bd9872fdc8b546914d2327cc252be", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -216,8 +216,8 @@ impl<R: Seek> Seek for BufReader<R> {\n     ///\n     /// Seeking always discards the internal buffer, even if the seek position\n     /// would otherwise fall within it. This guarantees that calling\n-    /// `.unwrap()` immediately after a seek yields the underlying reader at\n-    /// the same position.\n+    /// `.into_inner()` immediately after a seek yields the underlying reader\n+    /// at the same position.\n     ///\n     /// See `std::io::Seek` for more details.\n     ///"}, {"sha": "ad2fe3c1c0dbc8874e093328a1c530d6bec47aab", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -38,7 +38,7 @@ mod parser;\n ///\n /// [`shutdown`]: struct.TcpStream.html#method.shutdown\n /// [`TcpStream`]: struct.TcpStream.html\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Shutdown {\n     /// Indicates that the reading portion of this stream/socket should be shut"}, {"sha": "ed4af471f2f56ce1d621d5f7bd50209259b820f0", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -370,7 +370,7 @@ impl FromStr for SocketAddr {\n \n /// An error returned when parsing an IP address or a socket address.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct AddrParseError(());\n \n #[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]"}, {"sha": "51b08bd75c4bc3475548171cf9dd1ec018619629", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -103,7 +103,7 @@ pub struct Handle<'rx, T:Send+'rx> {\n struct Packets { cur: *mut Handle<'static, ()> }\n \n #[doc(hidden)]\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Eq)]\n pub enum StartResult {\n     Installed,\n     Abort,"}, {"sha": "9eac024edb17eeccedcb829c2564ea46840b592a", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -125,8 +125,8 @@ impl<'a> Parser<'a> {\n \n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let meta_item = self.parse_meta_item()?;\n-                let hi = self.last_span.hi;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n+                let hi = self.last_span.hi;\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }"}, {"sha": "fa6c885843e4c1768e5991873a76d02df55edf2e", "filename": "src/test/compile-fail/E0559.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2FE0559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2FE0559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0559.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -15,5 +15,5 @@ enum Field {\n fn main() {\n     let s = Field::Fool { joke: 0 };\n     //~^ ERROR E0559\n-    //~| NOTE did you mean `x`?\n+    //~| NOTE field does not exist - did you mean `x`?\n }"}, {"sha": "c6326a0f97740d954318ae126b3b9b4329674618", "filename": "src/test/compile-fail/E0560.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2FE0560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2FE0560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0560.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -13,5 +13,7 @@ struct Simba {\n }\n \n fn main() {\n-    let s = Simba { mother: 1, father: 0 }; //~ ERROR E0560\n+    let s = Simba { mother: 1, father: 0 };\n+    //~^ ERROR E0560\n+    //~| NOTE `Simba` does not have this field\n }", "previous_filename": "src/test/compile-fail/E560.rs"}, {"sha": "d7b2f2b3f991ec4760d110568c99057b3da26d65", "filename": "src/test/compile-fail/issue-19922.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -15,4 +15,5 @@ enum Homura {\n fn main() {\n     let homura = Homura::Akemi { kaname: () };\n     //~^ ERROR variant `Homura::Akemi` has no field named `kaname`\n+    //~| NOTE field does not exist - did you mean `madoka`?\n }"}, {"sha": "a67707257d2f2ac44a1bd757c1142f07839a70b0", "filename": "src/test/compile-fail/numeric-fields.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -13,8 +13,12 @@\n struct S(u8, u16);\n \n fn main() {\n-    let s = S{0b1: 10, 0: 11}; //~ ERROR struct `S` has no field named `0b1`\n+    let s = S{0b1: 10, 0: 11};\n+    //~^ ERROR struct `S` has no field named `0b1`\n+    //~| NOTE field does not exist - did you mean `1`?\n     match s {\n-        S{0: a, 0x1: b, ..} => {} //~ ERROR does not have a field named `0x1`\n+        S{0: a, 0x1: b, ..} => {}\n+        //~^ ERROR does not have a field named `0x1`\n+        //~| NOTE struct `S::{{constructor}}` does not have field `0x1`\n     }\n }"}, {"sha": "de78503d9044f55666f432c94914e746255e6077", "filename": "src/test/compile-fail/struct-fields-hints-no-dupe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -19,7 +19,7 @@ fn main() {\n         foo : 5,\n         bar : 42,\n         //~^ ERROR struct `A` has no field named `bar`\n-        //~| NOTE did you mean `barr`?\n+        //~| NOTE field does not exist - did you mean `barr`?\n         car : 9,\n     };\n }"}, {"sha": "628f03f3272cae15d30f7e5719c14a4cc7aa5c81", "filename": "src/test/compile-fail/struct-fields-hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -19,6 +19,6 @@ fn main() {\n         foo : 5,\n         bar : 42,\n         //~^ ERROR struct `A` has no field named `bar`\n-        //~| NOTE did you mean `car`?\n+        //~| NOTE field does not exist - did you mean `car`?\n     };\n }"}, {"sha": "0848ada731a651bcd208471fc8ea985b6de5b2c1", "filename": "src/test/compile-fail/struct-fields-too-many.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -15,6 +15,8 @@ struct BuildData {\n fn main() {\n     let foo = BuildData {\n         foo: 0,\n-        bar: 0 //~ ERROR struct `BuildData` has no field named `bar`\n+        bar: 0\n+        //~^ ERROR struct `BuildData` has no field named `bar`\n+        //~| NOTE `BuildData` does not have this field\n     };\n }"}, {"sha": "3672e0e90c2a2d8888bed10428e3dff2e3049417", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -24,18 +24,18 @@ fn main () {\n     let k = B {\n         aa: 20,\n         //~^ ERROR struct `xc::B` has no field named `aa`\n-        //~| NOTE did you mean `a`?\n+        //~| NOTE field does not exist - did you mean `a`?\n         bb: 20,\n         //~^ ERROR struct `xc::B` has no field named `bb`\n-        //~| NOTE did you mean `a`?\n+        //~| NOTE field does not exist - did you mean `a`?\n     };\n     // local crate struct\n     let l = A {\n         aa: 20,\n         //~^ ERROR struct `A` has no field named `aa`\n-        //~| NOTE did you mean `a`?\n+        //~| NOTE field does not exist - did you mean `a`?\n         bb: 20,\n         //~^ ERROR struct `A` has no field named `bb`\n-        //~| NOTE did you mean `b`?\n+        //~| NOTE field does not exist - did you mean `b`?\n     };\n }"}, {"sha": "3ee95c2ef4258b2e7834d506646da569f5f5292e", "filename": "src/test/compile-fail/union/union-fields.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -21,6 +21,7 @@ fn main() {\n     let u = U { a: 0, b: 1 }; //~ ERROR union expressions should have exactly one field\n     let u = U { a: 0, b: 1, c: 2 }; //~ ERROR union expressions should have exactly one field\n                                     //~^ ERROR union `U` has no field named `c`\n+                                    //~| NOTE `U` does not have this field\n     let u = U { ..u }; //~ ERROR union expressions should have exactly one field\n                        //~^ ERROR functional record update syntax requires a struct\n \n@@ -29,6 +30,7 @@ fn main() {\n     let U { a, b } = u; //~ ERROR union patterns should have exactly one field\n     let U { a, b, c } = u; //~ ERROR union patterns should have exactly one field\n                            //~^ ERROR union `U` does not have a field named `c`\n+                           //~| NOTE union `U` does not have field `c`\n     let U { .. } = u; //~ ERROR union patterns should have exactly one field\n                       //~^ ERROR `..` cannot be used in union patterns\n     let U { a, .. } = u; //~ ERROR `..` cannot be used in union patterns"}, {"sha": "ce421428d883be4e11ae879ff0b76376d61338a4", "filename": "src/test/compile-fail/union/union-suggest-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -21,7 +21,7 @@ impl U {\n fn main() {\n     let u = U { principle: 0 };\n     //~^ ERROR union `U` has no field named `principle`\n-    //~| NOTE did you mean `principal`?\n+    //~| NOTE field does not exist - did you mean `principal`?\n     let w = u.principial; //~ ERROR attempted access of field `principial` on type `U`\n                           //~^ HELP did you mean `principal`?\n "}, {"sha": "893c2168c2e1631f6035671b1c79ad024552fd65", "filename": "src/test/ui/span/issue-36530.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[foo]\n+mod foo {\n+    #![foo]\n+}"}, {"sha": "dc6190c2e76b0f28afee368623308f022d13cb96", "filename": "src/test/ui/span/issue-36530.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "patch": "@@ -0,0 +1,18 @@\n+error: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/issue-36530.rs:11:1\n+   |\n+11 | #[foo]\n+   | ^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/issue-36530.rs:13:5\n+   |\n+13 |     #![foo]\n+   |     ^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}]}