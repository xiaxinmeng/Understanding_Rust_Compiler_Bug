{"sha": "9a59d693239915aa37bd08ca194a8ba2857db25a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTlkNjkzMjM5OTE1YWEzN2JkMDhjYTE5NGE4YmEyODU3ZGIyNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-28T16:36:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-28T16:36:03Z"}, "message": "Auto merge of #43076 - Zoxc:gen, r=arielb1\n\nGenerator support\n\nThis adds experimental support for generators intended to land once https://github.com/rust-lang/rfcs/pull/2033 is approved.\n\nThis is not yet ready to be merged. Things to do:\n- [x] Make closure arguments on generators an error\n- [x] Spot FIXMEs\n- [x] Pass make tidy\n- [x] Write tests\n- [x] Document the current syntax and semantics for generators somewhere\n- [x] Use proper error message numbers\n- [x] ~~Make the implicit argument type default to `()`~~", "tree": {"sha": "f0852037daee472f22814b2206285fee3733703d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0852037daee472f22814b2206285fee3733703d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a59d693239915aa37bd08ca194a8ba2857db25a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a59d693239915aa37bd08ca194a8ba2857db25a", "html_url": "https://github.com/rust-lang/rust/commit/9a59d693239915aa37bd08ca194a8ba2857db25a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a59d693239915aa37bd08ca194a8ba2857db25a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5caca6fa0213cadca1584db43dd71fb5f82b41b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caca6fa0213cadca1584db43dd71fb5f82b41b9", "html_url": "https://github.com/rust-lang/rust/commit/5caca6fa0213cadca1584db43dd71fb5f82b41b9"}, {"sha": "a996d5eec70ba6733e23f2e56e762f58e60bb4ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a996d5eec70ba6733e23f2e56e762f58e60bb4ff", "html_url": "https://github.com/rust-lang/rust/commit/a996d5eec70ba6733e23f2e56e762f58e60bb4ff"}], "stats": {"total": 5524, "additions": 5053, "deletions": 471}, "files": [{"sha": "cb55fb602e3c74e87894a2362ff78d309c5595c9", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1181,7 +1181,7 @@ dependencies = [\n  \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.2.2 (git+https://github.com/rust-lang-nursery/rustfmt?branch=yield)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1648,7 +1648,7 @@ dependencies = [\n [[package]]\n name = \"rustfmt-nightly\"\n version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+source = \"git+https://github.com/rust-lang-nursery/rustfmt?branch=yield#6f56783c8cfd5f06d9b77873a3d4feb56c8d843f\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2287,7 +2287,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd34691a510938bb67fe0444fb363103c73ffb31c121d1e16bc92d8945ea8ff\"\n \"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustfmt-nightly 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6eea0d0590ae793fc4d281df56e01dc7531575c8ed9a72fadf5fdc7305a0d32f\"\n+\"checksum rustfmt-nightly 0.2.2 (git+https://github.com/rust-lang-nursery/rustfmt?branch=yield)\" = \"<none>\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\""}, {"sha": "3b7b77e2c3ed81a4339cb8669103523c0885c154", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,245 @@\n+# `generators`\n+\n+The tracking issue for this feature is: [#43122]\n+\n+[#34511]: https://github.com/rust-lang/rust/issues/43122\n+\n+------------------------\n+\n+The `generators` feature gate in Rust allows you to define generator or\n+coroutine literals. A generator is a \"resumable function\" that syntactically\n+resembles a closure but compiles to much different semantics in the compiler\n+itself. The primary feature of a generator is that it can be suspended during\n+execution to be resumed at a later date. Generators use the `yield` keyword to\n+\"return\", and then the caller can `resume` a generator to resume execution just\n+after the `yield` keyword.\n+\n+Generators are an extra-unstable feature in the compiler right now. Added in\n+[RFC 2033] they're mostly intended right now as a information/constraint\n+gathering phase. The intent is that experimentation can happen on the nightly\n+compiler before actual stabilization. A further RFC will be required to\n+stabilize generators/coroutines and will likely contain at least a few small\n+tweaks to the overall design.\n+\n+[RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n+\n+A syntactical example of a generator is:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+\n+fn main() {\n+    let mut generator = || {\n+        yield 1;\n+        return \"foo\"\n+    };\n+\n+    match generator.resume() {\n+        GeneratorState::Yielded(1) => {}\n+        _ => panic!(\"unexpected value from resume\"),\n+    }\n+    match generator.resume() {\n+        GeneratorState::Complete(\"foo\") => {}\n+        _ => panic!(\"unexpected value from resume\"),\n+    }\n+}\n+```\n+\n+Generators are closure-like literals which can contain a `yield` statement. The\n+`yield` statement takes an optional expression of a value to yield out of the\n+generator. All generator literals implement the `Generator` trait in the\n+`std::ops` module. The `Generator` trait has one main method, `resume`, which\n+resumes execution of the generator at the previous suspension point.\n+\n+An example of the control flow of generators is that the following example\n+prints all numbers in order:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let mut generator = || {\n+        println!(\"2\");\n+        yield;\n+        println!(\"4\");\n+    };\n+\n+    println!(\"1\");\n+    generator.resume();\n+    println!(\"3\");\n+    generator.resume();\n+    println!(\"5\");\n+}\n+```\n+\n+At this time the main intended use case of generators is an implementation\n+primitive for async/await syntax, but generators will likely be extended to\n+ergonomic implementations of iterators and other primitives in the future.\n+Feedback on the design and usage is always appreciated!\n+\n+### The `Generator` trait\n+\n+The `Generator` trait in `std::ops` currently looks like:\n+\n+```\n+# #![feature(generator_trait)]\n+# use std::ops::GeneratorState;\n+\n+pub trait Generator {\n+    type Yield;\n+    type Return;\n+    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+}\n+```\n+\n+The `Generator::Yield` type is the type of values that can be yielded with the\n+`yield` statement. The `Generator::Return` type is the returned type of the\n+generator. This is typically the last expression in a generator's definition or\n+any value passed to `return` in a generator. The `resume` function is the entry\n+point for executing the `Generator` itself.\n+\n+The return value of `resume`, `GeneratorState`, looks like:\n+\n+```\n+pub enum GeneratorState<Y, R> {\n+    Yielded(Y),\n+    Complete(R),\n+}\n+```\n+\n+The `Yielded` variant indicates that the generator can later be resumed. This\n+corresponds to a `yield` point in a generator. The `Complete` variant indicates\n+that the generator is complete and cannot be resumed again. Calling `resume`\n+after a generator has returned `Complete` will likely result in a panic of the\n+program.\n+\n+### Closure-like semantics\n+\n+The closure-like syntax for generators alludes to the fact that they also have\n+closure-like semantics. Namely:\n+\n+* When created, a generator executes no code. A closure literal does not\n+  actually execute any of the closure's code on construction, and similarly a\n+  generator literal does not execute any code inside the generator when\n+  constructed.\n+\n+* Generators can capture outer variables by reference or by move, and this can\n+  be tweaked with the `move` keyword at the beginning of the closure. Like\n+  closures all generators will have an implicit environment which is inferred by\n+  the compiler. Outer variables can be moved into a generator for use as the\n+  generator progresses.\n+\n+* Generator literals produce a value with a unique type which implements the\n+  `std::ops::Generator` trait. This allows actual execution of the generator\n+  through the `Generator::resume` method as well as also naming it in return\n+  types and such.\n+\n+* Traits like `Send` and `Sync` are automatically implemented for a `Generator`\n+  depending on the captured variables of the environment. Unlike closures though\n+  generators also depend on variables live across suspension points. This means\n+  that although the ambient environment may be `Send` or `Sync`, the generator\n+  itself may not be due to internal variables live across `yield` points being\n+  not-`Send` or not-`Sync`. Note, though, that generators, like closures, do\n+  not implement traits like `Copy` or `Clone` automatically.\n+\n+* Whenever a generator is dropped it will drop all captured environment\n+  variables.\n+\n+Note that unlike closures generators at this time cannot take any arguments.\n+That is, generators must always look like `|| { ... }`. This restriction may be\n+lifted at a future date, the design is ongoing!\n+\n+### Generators as state machines\n+\n+In the compiler generators are currently compiled as state machines. Each\n+`yield` expression will correspond to a different state that stores all live\n+variables over that suspension point. Resumption of a generator will dispatch on\n+the current state and then execute internally until a `yield` is reached, at\n+which point all state is saved off in the generator and a value is returned.\n+\n+Let's take a look at an example to see what's going on here:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let ret = \"foo\";\n+    let mut generator = move || {\n+        yield 1;\n+        return ret\n+    };\n+\n+    generator.resume();\n+    generator.resume();\n+}\n+```\n+\n+This generator literal will compile down to something similar to:\n+\n+```rust\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+\n+fn main() {\n+    let ret = \"foo\";\n+    let mut generator = {\n+        enum __Generator {\n+            Start(&'static str),\n+            Yield1(&'static str),\n+            Done,\n+        }\n+\n+        impl Generator for __Generator {\n+            type Yield = i32;\n+            type Return = &'static str;\n+\n+            fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n+                use std::mem;\n+                match mem::replace(self, __Generator::Done) {\n+                    __Generator::Start(s) => {\n+                        *self = __Generator::Yield1(s);\n+                        GeneratorState::Yielded(1)\n+                    }\n+\n+                    __Generator::Yield1(s) => {\n+                        *self = __Generator::Done;\n+                        GeneratorState::Complete(s)\n+                    }\n+\n+                    __Generator::Done => {\n+                        panic!(\"generator resumed after completion\")\n+                    }\n+                }\n+            }\n+        }\n+\n+        __Generator::Start(ret)\n+    };\n+\n+    generator.resume();\n+    generator.resume();\n+}\n+```\n+\n+Notably here we can see that the compiler is generating a fresh type,\n+`__Generator` in this case. This type has a number of states (represented here\n+as an `enum`) corresponding to each of the conceptual states of the generator.\n+At the beginning we're closing over our outer variable `foo` and then that\n+variable is also live over the `yield` point, so it's stored in both states.\n+\n+When the generator starts it'll immediately yield 1, but it saves off its state\n+just before it does so indicating that it has reached the yield point. Upon\n+resuming again we'll execute the `return ret` which returns the `Complete`\n+state.\n+\n+Here we can also note that the `Done` state, if resumed, panics immediately as\n+it's invalid to resume a completed generator. It's also worth noting that this\n+is just a rough desugaring, not a normative specification for what the compiler\n+does."}, {"sha": "d9f4a2217db4e8a5443bceb4db97f77e8d7705ea", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -66,7 +66,7 @@ use core::hash::{self, Hash};\n use core::iter::FusedIterator;\n use core::marker::{self, Unsize};\n use core::mem;\n-use core::ops::{CoerceUnsized, Deref, DerefMut};\n+use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n use core::ptr::{self, Unique};\n use core::convert::From;\n@@ -784,3 +784,14 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n         &mut **self\n     }\n }\n+\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<T> Generator for Box<T>\n+    where T: Generator + ?Sized\n+{\n+    type Yield = T::Yield;\n+    type Return = T::Return;\n+    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+        (**self).resume()\n+    }\n+}"}, {"sha": "d959331eb55dbdf0ac03e71f6312909eb5a1fee5", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -80,6 +80,7 @@\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(slice_rotate))]\n+#![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]\n #![feature(box_patterns)]"}, {"sha": "798c182bc6e3870090f677de808fc1620cc92131", "filename": "src/libcore/ops/generator.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The result of a generator resumption.\n+///\n+/// This enum is returned from the `Generator::resume` method and indicates the\n+/// possible return values of a generator. Currently this corresponds to either\n+/// a suspension point (`Yielded`) or a termination point (`Complete`).\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[cfg_attr(not(stage0), lang = \"generator_state\")]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+pub enum GeneratorState<Y, R> {\n+    /// The generator suspended with a value.\n+    ///\n+    /// This state indicates that a generator has been suspended, and typically\n+    /// corresponds to a `yield` statement. The value provided in this variant\n+    /// corresponds to the expression passed to `yield` and allows generators to\n+    /// provide a value each time they yield.\n+    Yielded(Y),\n+\n+    /// The generator completed with a return value.\n+    ///\n+    /// This state indicates that a generator has finished execution with the\n+    /// provided value. Once a generator has returned `Complete` it is\n+    /// considered a programmer error to call `resume` again.\n+    Complete(R),\n+}\n+\n+/// The trait implemented by builtin generator types.\n+///\n+/// Generators, also commonly referred to as coroutines, are currently an\n+/// experimental language feature in Rust. Added in [RFC 2033] generators are\n+/// currently intended to primarily provide a building block for async/await\n+/// syntax but will likely extend to also providing an ergonomic definition for\n+/// iterators and other primitives.\n+///\n+/// The syntax and semantics for generators is unstable and will require a\n+/// further RFC for stabilization. At this time, though, the syntax is\n+/// closure-like:\n+///\n+/// ```rust\n+/// #![feature(generators, generator_trait)]\n+///\n+/// use std::ops::{Generator, GeneratorState};\n+///\n+/// fn main() {\n+///     let mut generator = || {\n+///         yield 1;\n+///         return \"foo\"\n+///     };\n+///\n+///     match generator.resume() {\n+///         GeneratorState::Yielded(1) => {}\n+///         _ => panic!(\"unexpected return from resume\"),\n+///     }\n+///     match generator.resume() {\n+///         GeneratorState::Complete(\"foo\") => {}\n+///         _ => panic!(\"unexpected return from resume\"),\n+///     }\n+/// }\n+/// ```\n+///\n+/// More documentation of generators can be found in the unstable book.\n+///\n+/// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n+#[cfg_attr(not(stage0), lang = \"generator\")]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+#[fundamental]\n+pub trait Generator {\n+    /// The type of value this generator yields.\n+    ///\n+    /// This associated type corresponds to the `yield` expression and the\n+    /// values which are allowed to be returned each time a generator yields.\n+    /// For example an iterator-as-a-generator would likely have this type as\n+    /// `T`, the type being iterated over.\n+    type Yield;\n+\n+    /// The type of value this generator returns.\n+    ///\n+    /// This corresponds to the type returned from a generator either with a\n+    /// `return` statement or implicitly as the last expression of a generator\n+    /// literal. For example futures would use this as `Result<T, E>` as it\n+    /// represents a completed future.\n+    type Return;\n+\n+    /// Resumes the execution of this generator.\n+    ///\n+    /// This function will resume execution of the generator or start execution\n+    /// if it hasn't already. This call will return back into the generator's\n+    /// last suspension point, resuming execution from the latest `yield`. The\n+    /// generator will continue executing until it either yields or returns, at\n+    /// which point this function will return.\n+    ///\n+    /// # Return value\n+    ///\n+    /// The `GeneratorState` enum returned from this function indicates what\n+    /// state the generator is in upon returning. If the `Yielded` variant is\n+    /// returned then the generator has reached a suspension point and a value\n+    /// has been yielded out. Generators in this state are available for\n+    /// resumption at a later point.\n+    ///\n+    /// If `Complete` is returned then the generator has completely finished\n+    /// with the value provided. It is invalid for the generator to be resumed\n+    /// again.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function may panic if it is called after the `Complete` variant has\n+    /// been returned previously. While generator literals in the language are\n+    /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n+    /// for all implementations of the `Generator` trait.\n+    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+}\n+\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<'a, T> Generator for &'a mut T\n+    where T: Generator + ?Sized\n+{\n+    type Yield = T::Yield;\n+    type Return = T::Return;\n+    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+        (**self).resume()\n+    }\n+}"}, {"sha": "8975b680ca7fac1e6526c1a923d3d9078c47ce98", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -159,6 +159,7 @@ mod bit;\n mod deref;\n mod drop;\n mod function;\n+mod generator;\n mod index;\n mod place;\n mod range;\n@@ -196,6 +197,9 @@ pub use self::range::{RangeInclusive, RangeToInclusive};\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::try::Try;\n \n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+pub use self::generator::{Generator, GeneratorState};\n+\n #[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n "}, {"sha": "e7e2c84fc4efa3c99ffb85e50cc5a4674e8dbcb5", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -389,6 +389,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n             hir::ExprTupField(ref e, _) |\n+            hir::ExprYield(ref e) |\n             hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }"}, {"sha": "9a80db472dbd7cfab812fd7a7a7151cee03d0eb8", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -434,6 +434,7 @@ define_dep_nodes!( <'tcx>\n     [] ImplPolarity(DefId),\n     [] ClosureKind(DefId),\n     [] FnSignature(DefId),\n+    [] GenSignature(DefId),\n     [] CoerceUnsizedInfo(DefId),\n \n     [] ItemVarianceConstraints(DefId),"}, {"sha": "f027dd34f29b4be3d2a3964e02ce3a5b42a1a8a9", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -2045,4 +2045,5 @@ register_diagnostics! {\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n+    E0628, // generators cannot have explicit arguments\n }"}, {"sha": "880605ee377f7ffbd01d9c7f7a96956f4b54ec31", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -979,7 +979,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, body, _fn_decl_span) => {\n+        ExprClosure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n@@ -1043,6 +1043,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(input)\n             }\n         }\n+        ExprYield(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n     }\n }\n "}, {"sha": "f6ded6468b102d80f439406ef8b20151b4d39f45", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -93,6 +93,8 @@ pub struct LoweringContext<'a> {\n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n \n+    is_generator: bool,\n+\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n@@ -145,6 +147,7 @@ pub fn lower_crate(sess: &Session,\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n         item_local_id_counters: NodeMap(),\n         node_id_to_hir_id: IndexVec::new(),\n+        is_generator: false,\n     }.lower_crate(krate)\n }\n \n@@ -393,6 +396,7 @@ impl<'a> LoweringContext<'a> {\n             arguments: decl.map_or(hir_vec![], |decl| {\n                 decl.inputs.iter().map(|x| self.lower_arg(x)).collect()\n             }),\n+            is_generator: self.is_generator,\n             value,\n         };\n         let id = body.id();\n@@ -453,6 +457,16 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n+        where F: FnOnce(&mut LoweringContext) -> hir::Expr\n+    {\n+        let prev = mem::replace(&mut self.is_generator, false);\n+        let result = f(self);\n+        let r = self.record_body(result, decl);\n+        self.is_generator = prev;\n+        return r\n+    }\n+\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -637,13 +651,12 @@ impl<'a> LoweringContext<'a> {\n                 })))\n             }\n             TyKind::Array(ref ty, ref length) => {\n-                let length = self.lower_expr(length);\n-                hir::TyArray(self.lower_ty(ty),\n-                             self.record_body(length, None))\n+                let length = self.lower_body(None, |this| this.lower_expr(length));\n+                hir::TyArray(self.lower_ty(ty), length)\n             }\n             TyKind::Typeof(ref expr) => {\n-                let expr = self.lower_expr(expr);\n-                hir::TyTypeof(self.record_body(expr, None))\n+                let expr = self.lower_body(None, |this| this.lower_expr(expr));\n+                hir::TyTypeof(expr)\n             }\n             TyKind::TraitObject(ref bounds) => {\n                 let mut lifetime_bound = None;\n@@ -700,8 +713,7 @@ impl<'a> LoweringContext<'a> {\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| {\n-                    let e = self.lower_expr(e);\n-                    self.record_body(e, None)\n+                    self.lower_body(None, |this| this.lower_expr(e))\n                 }),\n             },\n             span: v.span,\n@@ -1368,21 +1380,21 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let value = self.lower_expr(e);\n+                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                self.record_body(value, None))\n+                                value)\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let value = self.lower_expr(e);\n-                hir::ItemConst(self.lower_ty(t),\n-                               self.record_body(value, None))\n+                let value = self.lower_body(None, |this| this.lower_expr(e));\n+                hir::ItemConst(self.lower_ty(t), value)\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.with_new_scopes(|this| {\n-                    let body = this.lower_block(body, false);\n-                    let body = this.expr_block(body, ThinVec::new());\n-                    let body_id = this.record_body(body, Some(decl));\n+                    let body_id = this.lower_body(Some(decl), |this| {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    });\n                     hir::ItemFn(this.lower_fn_decl(decl),\n                                               this.lower_unsafety(unsafety),\n                                               this.lower_constness(constness),\n@@ -1478,8 +1490,7 @@ impl<'a> LoweringContext<'a> {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::TraitItemKind::Const(this.lower_ty(ty),\n                                                   default.as_ref().map(|x| {\n-                            let value = this.lower_expr(x);\n-                            this.record_body(value, None)\n+                            this.lower_body(None, |this| this.lower_expr(x))\n                         }))\n                     }\n                     TraitItemKind::Method(ref sig, None) => {\n@@ -1488,9 +1499,10 @@ impl<'a> LoweringContext<'a> {\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                        let body = this.lower_block(body, false);\n-                        let expr = this.expr_block(body, ThinVec::new());\n-                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n+                            let body = this.lower_block(body, false);\n+                            this.expr_block(body, ThinVec::new())\n+                        });\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n                                                    hir::TraitMethod::Provided(body_id))\n                     }\n@@ -1542,14 +1554,14 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        let value = this.lower_expr(expr);\n-                        let body_id = this.record_body(value, None);\n+                        let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n-                        let body = this.lower_block(body, false);\n-                        let expr = this.expr_block(body, ThinVec::new());\n-                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n+                            let body = this.lower_block(body, false);\n+                            this.expr_block(body, ThinVec::new())\n+                        });\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n@@ -1928,8 +1940,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = P(self.lower_expr(expr));\n-                let count = self.lower_expr(count);\n-                hir::ExprRepeat(expr, self.record_body(count, None))\n+                let count = self.lower_body(None, |this| this.lower_expr(count));\n+                hir::ExprRepeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n@@ -2027,11 +2039,22 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                 self.with_new_scopes(|this| {\n                     this.with_parent_def(e.id, |this| {\n-                        let expr = this.lower_expr(body);\n+                        let mut is_generator = false;\n+                        let body_id = this.lower_body(Some(decl), |this| {\n+                            let e = this.lower_expr(body);\n+                            is_generator = this.is_generator;\n+                            e\n+                        });\n+                        if is_generator && !decl.inputs.is_empty() {\n+                            span_err!(this.sess, fn_decl_span, E0628,\n+                                      \"generators cannot have explicit arguments\");\n+                            this.sess.abort_if_errors();\n+                        }\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.record_body(expr, Some(decl)),\n-                                         fn_decl_span)\n+                                         body_id,\n+                                         fn_decl_span,\n+                                         is_generator)\n                     })\n                 })\n             }\n@@ -2172,6 +2195,14 @@ impl<'a> LoweringContext<'a> {\n                 return ex;\n             }\n \n+            ExprKind::Yield(ref opt_expr) => {\n+                self.is_generator = true;\n+                let expr = opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| {\n+                    self.expr(e.span, hir::ExprTup(hir_vec![]), ThinVec::new())\n+                });\n+                hir::ExprYield(P(expr))\n+            }\n+\n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n             ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {"}, {"sha": "d2888dcf6aaa4fa1350179641cc9d5077c9253c4", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -264,7 +264,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n+                ast::ExprClosure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "31b0b5c820e3d39c39f529f8a1fd9aa191762ed9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -151,7 +151,9 @@ impl<'hir> MapEntry<'hir> {\n             EntryTyParam(_, _, n) => NodeTyParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n-            _ => return None\n+\n+            NotPresent |\n+            RootCrate(_) => return None\n         })\n     }\n \n@@ -184,7 +186,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, _, expr) => {\n                 match expr.node {\n-                    ExprClosure(.., body, _) => Some(body),\n+                    ExprClosure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n             }"}, {"sha": "46b8cb0a2e2c80b5638d21b9a81305dd5f06bcc5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -929,7 +929,8 @@ pub struct BodyId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n-    pub value: Expr\n+    pub value: Expr,\n+    pub is_generator: bool,\n }\n \n impl Body {\n@@ -1007,7 +1008,10 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span),\n+    ///\n+    /// This may also be a generator literal, indicated by the final boolean,\n+    /// in that case there is an GeneratorClause.\n+    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, bool),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1052,6 +1056,9 @@ pub enum Expr_ {\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     ExprRepeat(P<Expr>, BodyId),\n+\n+    /// A suspension point for generators. This is `yield <expr>` in Rust.\n+    ExprYield(P<Expr>),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension."}, {"sha": "80269592bb78e676cf08a54ffb2e5ba0204335b3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1312,7 +1312,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span) => {\n+            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n@@ -1461,6 +1461,10 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n+            hir::ExprYield(ref expr) => {\n+                self.s.word(\"yield\")?;\n+                self.print_expr(&expr)?;\n+            }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n         self.end()"}, {"sha": "411f5e26e4d059e54c93c549c69112cc90154744", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -569,6 +569,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                 hir::ExprBreak(..)      |\n                 hir::ExprAgain(..)      |\n                 hir::ExprRet(..)        |\n+                hir::ExprYield(..)    |\n                 hir::ExprInlineAsm(..)  |\n                 hir::ExprRepeat(..)     |\n                 hir::ExprTup(..)        => {\n@@ -633,7 +634,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprWhile(cond, body, label),\n     ExprLoop(body, label, loop_src),\n     ExprMatch(matchee, arms, match_src),\n-    ExprClosure(capture_clause, decl, body_id, span),\n+    ExprClosure(capture_clause, decl, body_id, span, gen),\n     ExprBlock(blk),\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n@@ -647,7 +648,8 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprRet(val),\n     ExprInlineAsm(asm, inputs, outputs),\n     ExprStruct(path, fields, base),\n-    ExprRepeat(val, times)\n+    ExprRepeat(val, times),\n+    ExprYield(val)\n });\n \n impl_stable_hash_for!(enum hir::LocalSource {\n@@ -1024,7 +1026,8 @@ impl_stable_hash_for!(struct hir::Arg {\n \n impl_stable_hash_for!(struct hir::Body {\n     arguments,\n-    value\n+    value,\n+    is_generator\n });\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {"}, {"sha": "7ee2cc3b650c5c59a9bc069b9c40ba390e23c803", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::mem;\n \n-\n+impl_stable_hash_for!(struct mir::GeneratorLayout<'tcx> { fields });\n impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n@@ -27,6 +27,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     ty,\n     name,\n     source_info,\n+    internal,\n     is_user_variable\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n@@ -54,9 +55,11 @@ for mir::Terminator<'gcx> {\n             mir::TerminatorKind::SwitchInt { .. } |\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable |\n             mir::TerminatorKind::Drop { .. } |\n             mir::TerminatorKind::DropAndReplace { .. } |\n+            mir::TerminatorKind::Yield { .. } |\n             mir::TerminatorKind::Call { .. } => false,\n         };\n \n@@ -146,6 +149,7 @@ for mir::TerminatorKind<'gcx> {\n             }\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable => {}\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 location.hash_stable(hcx, hasher);\n@@ -161,6 +165,13 @@ for mir::TerminatorKind<'gcx> {\n                 target.hash_stable(hcx, hasher);\n                 unwind.hash_stable(hcx, hasher);\n             }\n+            mir::TerminatorKind::Yield { ref value,\n+                                        resume,\n+                                        drop } => {\n+                value.hash_stable(hcx, hasher);\n+                resume.hash_stable(hcx, hasher);\n+                drop.hash_stable(hcx, hasher);\n+            }\n             mir::TerminatorKind::Call { ref func,\n                                         ref args,\n                                         ref destination,\n@@ -200,6 +211,8 @@ for mir::AssertMessage<'gcx> {\n             mir::AssertMessage::Math(ref const_math_err) => {\n                 const_math_err.hash_stable(hcx, hasher);\n             }\n+            mir::AssertMessage::GeneratorResumedAfterReturn => (),\n+            mir::AssertMessage::GeneratorResumedAfterPanic => (),\n         }\n     }\n }\n@@ -433,6 +446,11 @@ for mir::AggregateKind<'gcx> {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n+            mir::AggregateKind::Generator(def_id, ref substs, ref interior) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                interior.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }"}, {"sha": "c9e3c8cc3e0cadb90f585ecc2bef051f72c9b369", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -147,6 +147,11 @@ for ty::UpvarCapture<'gcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n+    yield_ty,\n+    return_ty\n+});\n+\n impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     inputs_and_output,\n     variadic,\n@@ -321,6 +326,8 @@ for ::middle::const_val::ConstVal<'gcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n+impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });\n+\n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n     predicates\n@@ -546,6 +553,12 @@ for ty::TypeVariants<'gcx>\n                 def_id.hash_stable(hcx, hasher);\n                 closure_substs.hash_stable(hcx, hasher);\n             }\n+            TyGenerator(def_id, closure_substs, interior)\n+             => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_substs.hash_stable(hcx, hasher);\n+                interior.hash_stable(hcx, hasher);\n+            }\n             TyTuple(inner_tys, from_diverging_type_var) => {\n                 inner_tys.hash_stable(hcx, hasher);\n                 from_diverging_type_var.hash_stable(hcx, hasher);\n@@ -625,6 +638,7 @@ impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n     TupleSimplifiedType(size),\n     TraitSimplifiedType(def_id),\n     ClosureSimplifiedType(def_id),\n+    GeneratorSimplifiedType(def_id),\n     AnonSimplifiedType(def_id),\n     FunctionSimplifiedType(params),\n     ParameterSimplifiedType"}, {"sha": "b8b5a55f57806eaf9cee92cb70e7be71175fc771", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -166,6 +166,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) |\n             ty::TyDynamic(..) |\n             ty::TyClosure(..) |\n+            ty::TyGenerator(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |"}, {"sha": "27c6a4c5cf291546b6412f590897870674c79d26", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1363,6 +1363,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.fn_sig(def_id)\n     }\n+\n+    pub fn generator_sig(&self, def_id: DefId) -> Option<ty::PolyGenSig<'tcx>> {\n+        if let Some(tables) = self.in_progress_tables {\n+            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                if let Some(&ty) = tables.borrow().generator_sigs().get(hir_id) {\n+                    return ty.map(|t| ty::Binder(t));\n+                }\n+            }\n+        }\n+\n+        self.tcx.generator_sig(def_id)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "e36e1f470eb699ed015568e68ff9025fe921f0a9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -517,13 +517,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprClosure(.., fn_decl_span) => {\n+            hir::ExprClosure(.., fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span)\n             }\n \n             hir::ExprBox(ref base) => {\n                 self.consume_expr(&base);\n             }\n+\n+            hir::ExprYield(ref value) => {\n+                self.consume_expr(&value);\n+            }\n         }\n     }\n "}, {"sha": "ae3e3a30f371ebb85d1229270491e436c005222e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -316,6 +316,9 @@ language_item_table! {\n     FnMutTraitLangItem,              \"fn_mut\",                  fn_mut_trait;\n     FnOnceTraitLangItem,             \"fn_once\",                 fn_once_trait;\n \n+    GeneratorStateLangItem,          \"generator_state\",         gen_state;\n+    GeneratorTraitLangItem,          \"generator\",               gen_trait;\n+\n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n "}, {"sha": "6910a21ca5526dc7bcfc75b976160303ffa1b010", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -460,7 +460,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n+      hir::ExprInlineAsm(..) | hir::ExprBox(..) | hir::ExprYield(..) |\n       hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n@@ -881,7 +881,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n-\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n           }\n@@ -894,7 +893,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., blk_id, _) => {\n+          hir::ExprClosure(.., blk_id, _, _) => {\n               debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               /*\n@@ -1116,6 +1115,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n           hir::ExprUnary(_, ref e) |\n+          hir::ExprYield(ref e) |\n           hir::ExprRepeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n@@ -1224,18 +1224,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n+    fn access_var(&mut self, id: NodeId, nid: NodeId, succ: LiveNode, acc: u32, span: Span)\n+                  -> LiveNode {\n+        let ln = self.live_node(id, span);\n+        if acc != 0 {\n+            self.init_from_succ(ln, succ);\n+            let var = self.variable(nid, span);\n+            self.acc(ln, var, acc);\n+        }\n+        ln\n+    }\n+\n     fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match path.def {\n           Def::Local(def_id) => {\n             let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n-            let ln = self.live_node(id, path.span);\n-            if acc != 0 {\n-                self.init_from_succ(ln, succ);\n-                let var = self.variable(nid, path.span);\n-                self.acc(ln, var, acc);\n-            }\n-            ln\n+            self.access_var(id, nid, succ, acc, path.span)\n           }\n           _ => succ\n         }\n@@ -1398,7 +1403,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(_) |\n+      hir::ExprClosure(..) | hir::ExprPath(_) | hir::ExprYield(..) |\n       hir::ExprBox(..) | hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }"}, {"sha": "034861131e86e9fbf5b7b9eddee1ef51a5504d45", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -625,7 +625,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n           hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n           hir::ExprClosure(..) | hir::ExprRet(..) |\n-          hir::ExprUnary(..) |\n+          hir::ExprUnary(..) | hir::ExprYield(..) |\n           hir::ExprMethodCall(..) | hir::ExprCast(..) |\n           hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n           hir::ExprBinary(..) | hir::ExprWhile(..) |\n@@ -725,9 +725,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.tables.closure_kinds().get(fn_hir_id) {\n-            Some(&(kind, _)) => kind,\n-            None => span_bug!(span, \"missing closure kind\")\n+        let kind = match self.node_ty(fn_hir_id)?.sty {\n+            ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n+            _ => {\n+                match self.tables.closure_kinds().get(fn_hir_id) {\n+                    Some(&(kind, _)) => kind,\n+                    None => span_bug!(span, \"missing closure kind\"),\n+                }\n+            }\n         };\n \n         let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;"}, {"sha": "3efc696f2a50a4877ac2e8884c7e9518d3582b71", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeExpr(&hir::Expr { node: hir::ExprClosure(.., body, _), .. }) => {\n+            hir_map::NodeExpr(&hir::Expr { node: hir::ExprClosure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these"}, {"sha": "944d03737d37d0eb48dfa595ca8b1d9178a76284", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -24,6 +24,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n use syntax::ast;\n+use syntax::ast::NodeId;\n use syntax_pos::Span;\n use ty::TyCtxt;\n use ty::maps::Providers;\n@@ -32,6 +33,7 @@ use hir;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use hir::map::Node;\n use mir::transform::MirSource;\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -789,7 +791,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n-        hir::ExprClosure(.., body, _) => {\n+        hir::ExprClosure(.., body, _, _) => {\n             let body = visitor.tcx.hir.body(body);\n             visitor.visit_body(body);\n         }\n@@ -1166,6 +1168,102 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     Rc::new(maps)\n }\n \n+struct YieldFinder<'a> {\n+    cache: &'a mut FxHashMap<NodeId, Option<Span>>,\n+    result: Option<Span>,\n+}\n+\n+impl<'a> YieldFinder<'a> {\n+    fn lookup<F: FnOnce(&mut Self)>(&mut self, id: NodeId, f: F) {\n+        // Don't traverse further if we found a yield expression\n+        if self.result.is_some() {\n+            return;\n+        }\n+\n+        // See if there's an entry in the cache\n+        if let Some(result) = self.cache.get(&id) {\n+            self.result = *result;\n+            return;\n+        }\n+\n+        // Otherwise calculate the result and insert it into the cache\n+        f(self);\n+        self.cache.insert(id, self.result);\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for YieldFinder<'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprYield(..) = expr.node {\n+            self.result = Some(expr.span);\n+            return;\n+        }\n+\n+        self.lookup(expr.id, |this| {\n+            intravisit::walk_expr(this, expr);\n+        });\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        self.lookup(block.id, |this| {\n+            intravisit::walk_block(this, block);\n+        });\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// returns `Some(span)` with the span of a yield we found.\n+    pub fn yield_in_extent(self,\n+                          extent: CodeExtent,\n+                          cache: &mut FxHashMap<NodeId, Option<Span>>) -> Option<Span> {\n+        let mut finder = YieldFinder {\n+            cache,\n+            result: None,\n+        };\n+\n+        match extent {\n+            CodeExtent::DestructionScope(node_id) |\n+            CodeExtent::Misc(node_id) => {\n+                match self.hir.get(node_id) {\n+                    Node::NodeItem(_) |\n+                    Node::NodeTraitItem(_) |\n+                    Node::NodeImplItem(_) => {\n+                        let body = self.hir.body(self.hir.body_owned_by(node_id));\n+                        finder.visit_body(body);\n+                    }\n+                    Node::NodeExpr(expr) => finder.visit_expr(expr),\n+                    Node::NodeStmt(stmt) => finder.visit_stmt(stmt),\n+                    Node::NodeBlock(block) => finder.visit_block(block),\n+                    _ => bug!(),\n+                }\n+            }\n+\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => {\n+                finder.visit_body(self.hir.body(body_id))\n+            }\n+\n+            CodeExtent::Remainder(r) => {\n+                if let Node::NodeBlock(block) = self.hir.get(r.block) {\n+                    for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n+                        finder.visit_stmt(stmt);\n+                    }\n+                    block.expr.as_ref().map(|e| finder.visit_expr(e));\n+                } else {\n+                    bug!()\n+                }\n+            }\n+        }\n+\n+        finder.result\n+    }\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         region_maps,"}, {"sha": "802bcf7dab8b24267305d16d0967de563f62938a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 160, "deletions": 8, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n+use ty::{self, AdtDef, ClosureSubsts, Region, Ty, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n use rustc_back::slice;\n@@ -104,6 +104,15 @@ pub struct Mir<'tcx> {\n     /// Return type of the function.\n     pub return_ty: Ty<'tcx>,\n \n+    /// Yield type of the function, if it is a generator.\n+    pub yield_ty: Option<Ty<'tcx>>,\n+\n+    /// Generator drop glue\n+    pub generator_drop: Option<Box<Mir<'tcx>>>,\n+\n+    /// The layout of a generator. Produced by the state transformation.\n+    pub generator_layout: Option<GeneratorLayout<'tcx>>,\n+\n     /// Declarations of locals.\n     ///\n     /// The first local is the return value pointer, followed by `arg_count`\n@@ -144,6 +153,7 @@ impl<'tcx> Mir<'tcx> {\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                return_ty: Ty<'tcx>,\n+               yield_ty: Option<Ty<'tcx>>,\n                local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n                arg_count: usize,\n                upvar_decls: Vec<UpvarDecl>,\n@@ -159,6 +169,9 @@ impl<'tcx> Mir<'tcx> {\n             visibility_scopes,\n             promoted,\n             return_ty,\n+            yield_ty,\n+            generator_drop: None,\n+            generator_layout: None,\n             local_decls,\n             arg_count,\n             upvar_decls,\n@@ -270,6 +283,9 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     visibility_scopes,\n     promoted,\n     return_ty,\n+    yield_ty,\n+    generator_drop,\n+    generator_layout,\n     local_decls,\n     arg_count,\n     upvar_decls,\n@@ -395,6 +411,22 @@ pub struct LocalDecl<'tcx> {\n     /// True if this corresponds to a user-declared local variable.\n     pub is_user_variable: bool,\n \n+    /// True if this is an internal local\n+    ///\n+    /// These locals are not based on types in the source code and are only used\n+    /// for drop flags at the moment.\n+    ///\n+    /// The generator transformation will sanity check the locals which are live\n+    /// across a suspension point against the type components of the generator\n+    /// which type checking knows are live across a suspension point. We need to\n+    /// flag drop flags to avoid triggering this check as they are introduced\n+    /// after typeck.\n+    ///\n+    /// This should be sound because the drop flags are fully algebraic, and\n+    /// therefore don't affect the OIBIT or outlives properties of the\n+    /// generator.\n+    pub internal: bool,\n+\n     /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n@@ -420,6 +452,23 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            internal: false,\n+            is_user_variable: false\n+        }\n+    }\n+\n+    /// Create a new `LocalDecl` for a internal temporary.\n+    #[inline]\n+    pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n+        LocalDecl {\n+            mutability: Mutability::Mut,\n+            ty,\n+            name: None,\n+            source_info: SourceInfo {\n+                span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            internal: true,\n             is_user_variable: false\n         }\n     }\n@@ -436,6 +485,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            internal: false,\n             name: None,     // FIXME maybe we do want some name here?\n             is_user_variable: false\n         }\n@@ -567,7 +617,20 @@ pub enum TerminatorKind<'tcx> {\n         msg: AssertMessage<'tcx>,\n         target: BasicBlock,\n         cleanup: Option<BasicBlock>\n-    }\n+    },\n+\n+    /// A suspend point\n+    Yield {\n+        /// The value to return\n+        value: Operand<'tcx>,\n+        /// Where to resume to\n+        resume: BasicBlock,\n+        /// Cleanup to be done if the generator is dropped at this suspend point\n+        drop: Option<BasicBlock>,\n+    },\n+\n+    /// Indicates the end of the dropping of a generator\n+    GeneratorDrop,\n }\n \n impl<'tcx> Terminator<'tcx> {\n@@ -597,14 +660,16 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n             SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n-            Resume => (&[]).into_cow(),\n+            Resume | GeneratorDrop => (&[]).into_cow(),\n             Return => (&[]).into_cow(),\n             Unreachable => (&[]).into_cow(),\n             Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n             Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n                 slice::ref_slice(t).into_cow(),\n             Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n             Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n+            Yield { resume: t, drop: Some(c), .. } => vec![t, c].into_cow(),\n+            Yield { resume: ref t, drop: None, .. } => slice::ref_slice(t).into_cow(),\n             DropAndReplace { target, unwind: Some(unwind), .. } |\n             Drop { target, unwind: Some(unwind), .. } => {\n                 vec![target, unwind].into_cow()\n@@ -625,13 +690,15 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Goto { target: ref mut b } => vec![b],\n             SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n-            Resume => Vec::new(),\n+            Resume | GeneratorDrop => Vec::new(),\n             Return => Vec::new(),\n             Unreachable => Vec::new(),\n             Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n             Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n             Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Yield { resume: ref mut t, drop: Some(ref mut c), .. } => vec![t, c],\n+            Yield { resume: ref mut t, drop: None, .. } => vec![t],\n             DropAndReplace { ref mut target, unwind: Some(ref mut unwind), .. } |\n             Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n             DropAndReplace { ref mut target, unwind: None, .. } |\n@@ -664,6 +731,14 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn terminator_mut(&mut self) -> &mut Terminator<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n+\n+    pub fn retain_statements<F>(&mut self, mut f: F) where F: FnMut(&mut Statement) -> bool {\n+        for s in &mut self.statements {\n+            if !f(s) {\n+                s.kind = StatementKind::Nop;\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Debug for TerminatorKind<'tcx> {\n@@ -703,7 +778,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => write!(fmt, \"goto\"),\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n+            GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n+            Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n             DropAndReplace { ref location, ref value, .. } =>\n@@ -737,6 +814,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     AssertMessage::Math(ref err) => {\n                         write!(fmt, \"{:?}\", err.description())?;\n                     }\n+                    AssertMessage::GeneratorResumedAfterReturn => {\n+                        write!(fmt, \"{:?}\", \"generator resumed after completion\")?;\n+                    }\n+                    AssertMessage::GeneratorResumedAfterPanic => {\n+                        write!(fmt, \"{:?}\", \"generator resumed after panicking\")?;\n+                    }\n                 }\n \n                 write!(fmt, \")\")\n@@ -748,7 +831,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Return | Resume | Unreachable => vec![],\n+            Return | Resume | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, .. } => {\n                 values.iter()\n@@ -765,6 +848,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n             Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Yield { drop: Some(_), .. } =>\n+                vec![\"resume\".into_cow(), \"drop\".into_cow()],\n+            Yield { drop: None, .. } => vec![\"resume\".into_cow()],\n             DropAndReplace { unwind: None, .. } |\n             Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n             DropAndReplace { unwind: Some(_), .. } |\n@@ -784,7 +870,9 @@ pub enum AssertMessage<'tcx> {\n         len: Operand<'tcx>,\n         index: Operand<'tcx>\n     },\n-    Math(ConstMathErr)\n+    Math(ConstMathErr),\n+    GeneratorResumedAfterReturn,\n+    GeneratorResumedAfterPanic,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -1178,6 +1266,7 @@ pub enum AggregateKind<'tcx> {\n     /// number and is present only for union expressions.\n     Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n+    Generator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -1339,6 +1428,31 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             write!(fmt, \"[closure]\")\n                         }\n                     }),\n+\n+                    AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n+                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir.span(node_id));\n+                            let mut struct_fmt = fmt.debug_struct(&name);\n+\n+                            tcx.with_freevars(node_id, |freevars| {\n+                                for (freevar, lv) in freevars.iter().zip(lvs) {\n+                                    let def_id = freevar.def.def_id();\n+                                    let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                                    let var_name = tcx.local_var_name_str(var_id);\n+                                    struct_fmt.field(&var_name, lv);\n+                                }\n+                                struct_fmt.field(\"$state\", &lvs[freevars.len()]);\n+                                for i in (freevars.len() + 1)..lvs.len() {\n+                                    struct_fmt.field(&format!(\"${}\", i - freevars.len() - 1),\n+                                                     &lvs[i]);\n+                                }\n+                            });\n+\n+                            struct_fmt.finish()\n+                        } else {\n+                            write!(fmt, \"[generator]\")\n+                        }\n+                    }),\n                 }\n             }\n         }\n@@ -1483,6 +1597,11 @@ impl Location {\n     }\n }\n \n+/// The layout of generator state\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct GeneratorLayout<'tcx> {\n+    pub fields: Vec<LocalDecl<'tcx>>,\n+}\n \n /*\n  * TypeFoldable implementations for MIR types\n@@ -1495,6 +1614,9 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n             visibility_scopes: self.visibility_scopes.clone(),\n             promoted: self.promoted.fold_with(folder),\n             return_ty: self.return_ty.fold_with(folder),\n+            yield_ty: self.yield_ty.fold_with(folder),\n+            generator_drop: self.generator_drop.fold_with(folder),\n+            generator_layout: self.generator_layout.fold_with(folder),\n             local_decls: self.local_decls.fold_with(folder),\n             arg_count: self.arg_count,\n             upvar_decls: self.upvar_decls.clone(),\n@@ -1506,12 +1628,27 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.basic_blocks.visit_with(visitor) ||\n+        self.generator_drop.visit_with(visitor) ||\n+        self.generator_layout.visit_with(visitor) ||\n+        self.yield_ty.visit_with(visitor) ||\n         self.promoted.visit_with(visitor)     ||\n         self.return_ty.visit_with(visitor)    ||\n         self.local_decls.visit_with(visitor)\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        GeneratorLayout {\n+            fields: self.fields.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.fields.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         LocalDecl {\n@@ -1638,6 +1775,11 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 target,\n                 unwind,\n             },\n+            Yield { ref value, resume, drop } => Yield {\n+                value: value.fold_with(folder),\n+                resume: resume,\n+                drop: drop,\n+            },\n             Call { ref func, ref args, ref destination, cleanup } => {\n                 let dest = destination.as_ref().map(|&(ref loc, dest)| {\n                     (loc.fold_with(folder), dest)\n@@ -1667,6 +1809,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     cleanup,\n                 }\n             },\n+            GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n             Return => Return,\n             Unreachable => Unreachable,\n@@ -1686,6 +1829,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Drop { ref location, ..} => location.visit_with(visitor),\n             DropAndReplace { ref location, ref value, ..} =>\n                 location.visit_with(visitor) || value.visit_with(visitor),\n+            Yield { ref value, ..} =>\n+                value.visit_with(visitor),\n             Call { ref func, ref args, ref destination, .. } => {\n                 let dest = if let Some((ref loc, _)) = *destination {\n                     loc.visit_with(visitor)\n@@ -1706,6 +1851,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Goto { .. } |\n             Resume |\n             Return |\n+            GeneratorDrop |\n             Unreachable => false\n         }\n     }\n@@ -1751,7 +1897,11 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Adt(def, v, substs, n) =>\n                         AggregateKind::Adt(def, v, substs.fold_with(folder), n),\n                     AggregateKind::Closure(id, substs) =>\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                        AggregateKind::Closure(id, substs.fold_with(folder)),\n+                    AggregateKind::Generator(id, substs, interior) =>\n+                        AggregateKind::Generator(id,\n+                                                 substs.fold_with(folder),\n+                                                 interior.fold_with(folder)),\n                 };\n                 Aggregate(kind, fields.fold_with(folder))\n             }\n@@ -1777,7 +1927,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Array(ty) => ty.visit_with(visitor),\n                     AggregateKind::Tuple => false,\n                     AggregateKind::Adt(_, _, substs, _) => substs.visit_with(visitor),\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor)\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs, interior) => substs.visit_with(visitor) ||\n+                        interior.visit_with(visitor),\n                 }) || fields.visit_with(visitor)\n             }\n         }"}, {"sha": "eb403442f46399de4b82d559a70e7562afb4b4f4", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -207,6 +207,9 @@ impl<'tcx> Rvalue<'tcx> {\n                     AggregateKind::Closure(did, substs) => {\n                         tcx.mk_closure_from_closure_substs(did, substs)\n                     }\n+                    AggregateKind::Generator(did, substs, interior) => {\n+                        tcx.mk_generator(did, substs, interior)\n+                    }\n                 }\n             }\n         }"}, {"sha": "f29405e6650518bced752cc45950d6699cdf61d7", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -33,7 +33,10 @@ pub enum MirSource {\n     Static(NodeId, hir::Mutability),\n \n     /// Promoted rvalues within a function.\n-    Promoted(NodeId, Promoted)\n+    Promoted(NodeId, Promoted),\n+\n+    /// Drop glue for a generator.\n+    GeneratorDrop(NodeId),\n }\n \n impl<'a, 'tcx> MirSource {\n@@ -70,6 +73,7 @@ impl<'a, 'tcx> MirSource {\n         match *self {\n             MirSource::Fn(id) |\n             MirSource::Const(id) |\n+            MirSource::GeneratorDrop(id) |\n             MirSource::Static(id, _) |\n             MirSource::Promoted(id, _) => id\n         }"}, {"sha": "6589e824187fd5b730c11b12166d249ef5aae044", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -11,7 +11,7 @@\n use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{ClosureSubsts, Region, Ty};\n+use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n use mir::*;\n use rustc_const_math::ConstUsize;\n use syntax_pos::Span;\n@@ -226,6 +226,12 @@ macro_rules! make_mir_visitor {\n                 self.super_closure_substs(substs);\n             }\n \n+            fn visit_generator_interior(&mut self,\n+                                    interior: & $($mutability)* GeneratorInterior<'tcx>,\n+                                    _: Location) {\n+                self.super_generator_interior(interior);\n+            }\n+\n             fn visit_const_val(&mut self,\n                                const_val: & $($mutability)* ConstVal,\n                                _: Location) {\n@@ -249,6 +255,10 @@ macro_rules! make_mir_visitor {\n                 self.super_local_decl(local_decl);\n             }\n \n+            fn visit_local(&mut self,\n+                                _local: & $($mutability)* Local) {\n+            }\n+\n             fn visit_visibility_scope(&mut self,\n                                       scope: & $($mutability)* VisibilityScope) {\n                 self.super_visibility_scope(scope);\n@@ -415,6 +425,7 @@ macro_rules! make_mir_visitor {\n \n                     TerminatorKind::Resume |\n                     TerminatorKind::Return |\n+                    TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable => {\n                     }\n \n@@ -461,6 +472,15 @@ macro_rules! make_mir_visitor {\n                         self.visit_branch(block, target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n+\n+                    TerminatorKind::Yield { ref $($mutability)* value,\n+                                              resume,\n+                                              drop } => {\n+                        self.visit_operand(value, source_location);\n+                        self.visit_branch(block, resume);\n+                        drop.map(|t| self.visit_branch(block, t));\n+                    }\n+\n                 }\n             }\n \n@@ -475,7 +495,9 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(len, location);\n                         self.visit_operand(index, location);\n                     }\n-                    AssertMessage::Math(_) => {}\n+                    AssertMessage::Math(_) => {},\n+                    AssertMessage::GeneratorResumedAfterReturn => {},\n+                    AssertMessage::GeneratorResumedAfterPanic => {},\n                 }\n             }\n \n@@ -553,6 +575,13 @@ macro_rules! make_mir_visitor {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n+                            AggregateKind::Generator(ref $($mutability)* def_id,\n+                                                   ref $($mutability)* closure_substs,\n+                                                   ref $($mutability)* interior) => {\n+                                self.visit_def_id(def_id, location);\n+                                self.visit_closure_substs(closure_substs, location);\n+                                self.visit_generator_interior(interior, location);\n+                            }\n                         }\n \n                         for operand in operands {\n@@ -580,7 +609,8 @@ macro_rules! make_mir_visitor {\n                             context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n-                    Lvalue::Local(_) => {\n+                    Lvalue::Local(ref $($mutability)* local) => {\n+                        self.visit_local(local);\n                     }\n                     Lvalue::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);\n@@ -651,6 +681,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* ty,\n                     name: _,\n                     ref $($mutability)* source_info,\n+                    internal: _,\n                     is_user_variable: _,\n                 } = *local_decl;\n \n@@ -719,6 +750,10 @@ macro_rules! make_mir_visitor {\n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n             }\n \n+            fn super_generator_interior(&mut self,\n+                                    _interior: & $($mutability)* GeneratorInterior<'tcx>) {\n+            }\n+\n             fn super_closure_substs(&mut self,\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }"}, {"sha": "431bd8ee88f709883aa72813689aa76cee731c72", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -301,7 +301,7 @@ fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n             true\n         }\n \n-        ty::TyClosure(..) | ty::TyAnon(..) => {\n+        ty::TyClosure(..) | ty::TyGenerator(..) | ty::TyAnon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "0e7bfc8cd0d86cd9d408997ec623cdef5890bf8b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -251,6 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     AdtKind::Union => Some(16),\n                     AdtKind::Enum => Some(17),\n                 },\n+                ty::TyGenerator(..) => Some(18),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "228c9761756a8e99079552737b7775ccf6c4178f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -310,6 +310,9 @@ pub enum Vtable<'tcx, N> {\n \n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -329,6 +332,15 @@ pub struct VtableImplData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n+#[derive(Clone, PartialEq, Eq)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: ty::ClosureSubsts<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>\n+}\n+\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n@@ -743,6 +755,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableBuiltin(i) => i.nested,\n             VtableDefaultImpl(d) => d.nested,\n             VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n             VtableObject(d) => d.nested,\n             VtableFnPointer(d) => d.nested,\n         }\n@@ -754,6 +767,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             &mut VtableParam(ref mut n) => n,\n             &mut VtableBuiltin(ref mut i) => &mut i.nested,\n             &mut VtableDefaultImpl(ref mut d) => &mut d.nested,\n+            &mut VtableGenerator(ref mut c) => &mut c.nested,\n             &mut VtableClosure(ref mut c) => &mut c.nested,\n             &mut VtableObject(ref mut d) => &mut d.nested,\n             &mut VtableFnPointer(ref mut d) => &mut d.nested,\n@@ -784,6 +798,11 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n             VtableClosure(c) => VtableClosure(VtableClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,"}, {"sha": "ebb6466aa32d004cf104f4b4fd0247c4eeca7317", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -19,6 +19,7 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n+use super::VtableGeneratorData;\n use super::VtableFnPointerData;\n use super::VtableImplData;\n use super::util;\n@@ -882,6 +883,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n \n         match vtable {\n             super::VtableClosure(_) |\n+            super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n             super::VtableObject(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n@@ -1041,6 +1043,8 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),\n+        super::VtableGenerator(data) =>\n+            confirm_generator_candidate(selcx, obligation, data),\n         super::VtableClosure(data) =>\n             confirm_closure_candidate(selcx, obligation, data),\n         super::VtableFnPointer(data) =>\n@@ -1123,6 +1127,60 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     confirm_param_env_candidate(selcx, obligation, env_predicate)\n }\n \n+fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n+{\n+    let gen_sig = selcx.infcx().generator_sig(vtable.closure_def_id).unwrap()\n+        .subst(selcx.tcx(), vtable.substs.substs);\n+    let Normalized {\n+        value: gen_sig,\n+        obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &gen_sig);\n+\n+    debug!(\"confirm_generator_candidate: obligation={:?},gen_sig={:?},obligations={:?}\",\n+           obligation,\n+           gen_sig,\n+           obligations);\n+\n+    let tcx = selcx.tcx();\n+\n+    let gen_def_id = tcx.lang_items.gen_trait().unwrap();\n+\n+    // Note: we unwrap the binder here but re-create it below (1)\n+    let ty::Binder((trait_ref, yield_ty, return_ty)) =\n+        tcx.generator_trait_ref_and_outputs(gen_def_id,\n+                                            obligation.predicate.self_ty(),\n+                                            gen_sig);\n+\n+    let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n+    let ty = if name == Symbol::intern(\"Return\") {\n+        return_ty\n+    } else if name == Symbol::intern(\"Yield\") {\n+        yield_ty\n+    } else {\n+        bug!()\n+    };\n+\n+    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n+        projection_ty: ty::ProjectionTy {\n+            substs: trait_ref.substs,\n+            item_def_id: obligation.predicate.item_def_id,\n+        },\n+        ty: ty\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "68f8c20b0f77ee82dd2be9bcd6e15add1a75b819", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 140, "deletions": 12, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -24,9 +24,9 @@ use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure, VtableGenerator,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n-use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData, VtableGeneratorData,\n             VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n@@ -43,6 +43,7 @@ use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n+use std::iter;\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n@@ -197,6 +198,10 @@ enum SelectionCandidate<'tcx> {\n     /// confirmation step what ClosureKind obligation to emit.\n     ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n \n+    /// Implementation of a `Generator` trait by one of the anonymous types\n+    /// generated for a generator.\n+    GeneratorCandidate(/* function / closure */ DefId, ty::ClosureSubsts<'tcx>),\n+\n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n@@ -228,6 +233,11 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n             ParamCandidate(ref trait_ref) => {\n                 return tcx.lift(trait_ref).map(ParamCandidate);\n             }\n+            GeneratorCandidate(def_id, ref substs) => {\n+                return tcx.lift(substs).map(|substs| {\n+                    GeneratorCandidate(def_id, substs)\n+                });\n+            }\n             ClosureCandidate(def_id, ref substs, kind) => {\n                 return tcx.lift(substs).map(|substs| {\n                     ClosureCandidate(def_id, substs, kind)\n@@ -1296,14 +1306,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n-            if self.tcx().lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n-                // types have builtin support for `Clone`.\n-                let clone_conditions = self.copy_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n-            }\n-\n+             if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+                 // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                 // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                 // types have builtin support for `Clone`.\n+                 let clone_conditions = self.copy_conditions(obligation);\n+                 self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+             }\n+\n+             self.assemble_generator_candidates(obligation, &mut candidates)?;\n              self.assemble_closure_candidates(obligation, &mut candidates)?;\n              self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n              self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n@@ -1488,6 +1499,38 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n+    fn assemble_generator_candidates(&mut self,\n+                                   obligation: &TraitObligation<'tcx>,\n+                                   candidates: &mut SelectionCandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n+    {\n+        if self.tcx().lang_items.gen_trait() != Some(obligation.predicate.def_id()) {\n+            return Ok(());\n+        }\n+\n+        // ok to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyGenerator(id, substs, _) => (id, substs),\n+            ty::TyInfer(ty::TyVar(_)) => {\n+                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+                return Ok(());\n+            }\n+            _ => { return Ok(()); }\n+        };\n+\n+        debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+               self_ty,\n+               obligation);\n+\n+        candidates.vec.push(GeneratorCandidate(closure_def_id, substs));\n+\n+        Ok(())\n+    }\n+\n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is a closure type.\n     ///\n@@ -1854,6 +1897,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n                 ImplCandidate(..) |\n                 ClosureCandidate(..) |\n+                GeneratorCandidate(..) |\n                 FnPointerCandidate |\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n@@ -1934,7 +1978,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) |\n+            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n             ty::TyArray(..) | ty::TyClosure(..) | ty::TyNever |\n             ty::TyError => {\n                 // safe for everything\n@@ -1986,7 +2030,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n-            ty::TyClosure(..) |\n+            ty::TyClosure(..) | ty::TyGenerator(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n             }\n@@ -2087,6 +2131,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n+            ty::TyGenerator(def_id, ref substs, interior) => {\n+                let witness = iter::once(interior.witness);\n+                substs.upvar_tys(def_id, self.tcx()).chain(witness).collect()\n+            }\n+\n             // for `PhantomData<T>`, we pass `T`\n             ty::TyAdt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n@@ -2196,6 +2245,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n+            GeneratorCandidate(closure_def_id, substs) => {\n+                let vtable_generator =\n+                    self.confirm_generator_candidate(obligation, closure_def_id, substs)?;\n+                Ok(VtableGenerator(vtable_generator))\n+            }\n+\n             BuiltinObjectCandidate => {\n                 // This indicates something like `(Trait+Send) :\n                 // Send`. In this case, we know that this holds\n@@ -2528,6 +2583,40 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n+    fn confirm_generator_candidate(&mut self,\n+                                 obligation: &TraitObligation<'tcx>,\n+                                 closure_def_id: DefId,\n+                                 substs: ty::ClosureSubsts<'tcx>)\n+                                 -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+                                           SelectionError<'tcx>>\n+    {\n+        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\",\n+               obligation,\n+               closure_def_id,\n+               substs);\n+\n+        let Normalized {\n+            value: trait_ref,\n+            obligations\n+        } = self.generator_trait_ref(obligation, closure_def_id, substs);\n+\n+        debug!(\"confirm_generator_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+               closure_def_id,\n+               trait_ref,\n+               obligations);\n+\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n+                                     obligation.predicate.to_poly_trait_ref(),\n+                                     trait_ref)?;\n+\n+        Ok(VtableGeneratorData {\n+            closure_def_id: closure_def_id,\n+            substs: substs.clone(),\n+            nested: obligations\n+        })\n+    }\n+\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: DefId,\n@@ -3029,6 +3118,45 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                              &trait_ref)\n     }\n \n+    fn generator_trait_ref_unnormalized(&mut self,\n+                                      obligation: &TraitObligation<'tcx>,\n+                                      closure_def_id: DefId,\n+                                      substs: ty::ClosureSubsts<'tcx>)\n+                                      -> ty::PolyTraitRef<'tcx>\n+    {\n+        let gen_sig = self.infcx.generator_sig(closure_def_id).unwrap()\n+            .subst(self.tcx(), substs.substs);\n+        let ty::Binder((trait_ref, ..)) =\n+            self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n+                                                       obligation.predicate.0.self_ty(), // (1)\n+                                                       gen_sig);\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an generator type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        ty::Binder(trait_ref)\n+    }\n+\n+    fn generator_trait_ref(&mut self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: DefId,\n+                         substs: ty::ClosureSubsts<'tcx>)\n+                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n+    {\n+        let trait_ref = self.generator_trait_ref_unnormalized(\n+            obligation, closure_def_id, substs);\n+\n+        // A generator signature can contain associated types which\n+        // must be normalized.\n+        normalize_with_depth(self,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &trait_ref)\n+    }\n+\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}, {"sha": "674da297cd959ba5abaf6da8c9d42b62adbe3a6b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -53,6 +53,9 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n             super::VtableClosure(ref d) =>\n                 write!(f, \"{:?}\", d),\n \n+            super::VtableGenerator(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n             super::VtableFnPointer(ref d) =>\n                 write!(f, \"VtableFnPointer({:?})\", d),\n \n@@ -77,6 +80,15 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableGenerator(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n@@ -278,6 +290,19 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 })\n             }\n             traits::VtableDefaultImpl(t) => Some(traits::VtableDefaultImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                closure_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableGenerator(traits::VtableGeneratorData {\n+                        closure_def_id: closure_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n             traits::VtableClosure(traits::VtableClosureData {\n                 closure_def_id,\n                 substs,\n@@ -351,6 +376,20 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n     }\n }\n \n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::VtableGeneratorData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableClosureData {\n@@ -422,6 +461,9 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n+            traits::VtableGenerator(ref d) => {\n+                traits::VtableGenerator(d.fold_with(folder))\n+            }\n             traits::VtableClosure(ref d) => {\n                 traits::VtableClosure(d.fold_with(folder))\n             }\n@@ -438,6 +480,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n         match *self {\n             traits::VtableImpl(ref v) => v.visit_with(visitor),\n             traits::VtableDefaultImpl(ref t) => t.visit_with(visitor),\n+            traits::VtableGenerator(ref d) => d.visit_with(visitor),\n             traits::VtableClosure(ref d) => d.visit_with(visitor),\n             traits::VtableFnPointer(ref d) => d.visit_with(visitor),\n             traits::VtableParam(ref n) => n.visit_with(visitor),"}, {"sha": "28abd1577dadea39ff7b126f582a3a0329a2a031", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -513,6 +513,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::Binder((trait_ref, sig.skip_binder().output()))\n     }\n \n+    pub fn generator_trait_ref_and_outputs(self,\n+        fn_trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        sig: ty::PolyGenSig<'tcx>)\n+        -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)>\n+    {\n+        let trait_ref = ty::TraitRef {\n+            def_id: fn_trait_def_id,\n+            substs: self.mk_substs_trait(self_ty, &[]),\n+        };\n+        ty::Binder((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+    }\n+\n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n         match self.hir.as_local_node_id(node_item_def_id) {\n             Some(node_id) => {"}, {"sha": "1fe53882c70d339ad15d1c7659b71b9c5d742458", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -32,7 +32,7 @@ use ty::ReprOptions;\n use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n use hir::FreevarMap;\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n@@ -340,6 +340,10 @@ pub struct TypeckTables<'tcx> {\n     /// that caused the closure to be this kind.\n     closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n+    generator_sigs: ItemLocalMap<Option<ty::GenSig<'tcx>>>,\n+\n+    generator_interiors: ItemLocalMap<ty::GeneratorInterior<'tcx>>,\n+\n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n@@ -381,6 +385,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             adjustments: ItemLocalMap(),\n             pat_binding_modes: ItemLocalMap(),\n             upvar_capture_map: FxHashMap(),\n+            generator_sigs: ItemLocalMap(),\n+            generator_interiors: ItemLocalMap(),\n             closure_tys: ItemLocalMap(),\n             closure_kinds: ItemLocalMap(),\n             liberated_fn_sigs: ItemLocalMap(),\n@@ -634,6 +640,42 @@ impl<'tcx> TypeckTables<'tcx> {\n             data: &mut self.cast_kinds\n         }\n     }\n+\n+    pub fn generator_sigs(&self)\n+        -> LocalTableInContext<Option<ty::GenSig<'tcx>>>\n+    {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.generator_sigs,\n+        }\n+    }\n+\n+    pub fn generator_sigs_mut(&mut self)\n+        -> LocalTableInContextMut<Option<ty::GenSig<'tcx>>>\n+    {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.generator_sigs,\n+        }\n+    }\n+\n+    pub fn generator_interiors(&self)\n+        -> LocalTableInContext<ty::GeneratorInterior<'tcx>>\n+    {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.generator_interiors,\n+        }\n+    }\n+\n+    pub fn generator_interiors_mut(&mut self)\n+        -> LocalTableInContextMut<ty::GeneratorInterior<'tcx>>\n+    {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.generator_interiors,\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n@@ -658,6 +700,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Typeck\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,\n+            ref generator_sigs,\n+            ref generator_interiors,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -691,6 +735,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Typeck\n             ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n             ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n             ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, generator_sigs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, generator_interiors);\n \n             ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n                 hcx.def_path_hash(*def_id)\n@@ -1364,7 +1410,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr, TyGenerator,\n             TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n@@ -1719,6 +1765,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n+    pub fn mk_generator(self,\n+                        id: DefId,\n+                        closure_substs: ClosureSubsts<'tcx>,\n+                        interior: GeneratorInterior<'tcx>)\n+                        -> Ty<'tcx> {\n+        self.mk_ty(TyGenerator(id, closure_substs, interior))\n+    }\n+\n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }"}, {"sha": "802994ae0948ab452c89afbc75cf6dfff9177315", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -213,6 +213,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n+            ty::TyGenerator(..) => \"generator\".to_string(),\n             ty::TyTuple(..) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),"}, {"sha": "353a1cd5355b9b14ca427f16fc65e5930e09bb3b", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -30,6 +30,7 @@ pub enum SimplifiedType {\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n+    GeneratorSimplifiedType(DefId),\n     AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n@@ -72,6 +73,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n+        ty::TyGenerator(def_id, _, _) => {\n+            Some(GeneratorSimplifiedType(def_id))\n+        }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))"}, {"sha": "27b8d245396c9fdb7ec2c51bba4c275fb71608a8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -85,6 +85,13 @@ impl FlagComputation {\n                 }\n             }\n \n+            &ty::TyGenerator(_, ref substs, ref interior) => {\n+                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                self.add_substs(&substs.substs);\n+                self.add_ty(interior.witness);\n+            }\n+\n             &ty::TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);"}, {"sha": "eadf80871fc95e3ee2742c5971f575235b7347de", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -345,6 +345,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n \n         ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n+        ty::TyGenerator(def_id, _, _) => Some(def_id),\n \n         ty::TyBool |\n         ty::TyChar |"}, {"sha": "cf21a66d51538f9d66147b9185783030d17e7cfe", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1226,7 +1226,17 @@ impl<'a, 'tcx> Layout {\n                 Univariant { variant: unit, non_zero: false }\n             }\n \n-            // Tuples and closures.\n+            // Tuples, generators and closures.\n+            ty::TyGenerator(def_id, ref substs, _) => {\n+                let tys = substs.field_tys(def_id, tcx);\n+                let st = Struct::new(dl,\n+                    &tys.map(|ty| ty.layout(tcx, param_env))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &ReprOptions::default(),\n+                    StructKind::AlwaysSizedUnivariant, ty)?;\n+                Univariant { variant: st, non_zero: false }\n+            }\n+\n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 let st = Struct::new(dl,\n@@ -2240,11 +2250,15 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TySlice(element) => element,\n             ty::TyStr => tcx.types.u8,\n \n-            // Tuples and closures.\n+            // Tuples, generators and closures.\n             ty::TyClosure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n+            ty::TyGenerator(def_id, ref substs, _) => {\n+                substs.field_tys(def_id, tcx).nth(i).unwrap()\n+            }\n+\n             ty::TyTuple(tys, _) => tys[i],\n \n             // SIMD vector types."}, {"sha": "03e093c5a50ef5b2d05d54450d4b0570b101bef7", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -597,8 +597,15 @@ macro_rules! define_maps {\n \n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n-                match *self {\n-                    $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => {\n+                        (queries::$name::describe(tcx, key), stringify!($name))\n+                    })*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name)\n+                } else {\n+                    r\n                 }\n             }\n         }\n@@ -1006,6 +1013,10 @@ define_maps! { <'tcx>\n     /// The signature of functions and closures.\n     [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n+    /// Records the signature of each generator. The def ID is the ID of the\n+    /// expression defining the closure.\n+    [] generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+\n     /// Caches CoerceUnsized kinds for impls on custom types.\n     [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,"}, {"sha": "8cabb88ee988d531f28517dca3e3e877d611b64c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -25,6 +25,7 @@ use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use middle::region::CodeExtent;\n use mir::Mir;\n+use mir::GeneratorLayout;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n@@ -59,9 +60,9 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n use hir;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{FnSig, PolyFnSig};\n+pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n-pub use self::sty::{ClosureSubsts, TypeAndMut};\n+pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n@@ -409,6 +410,8 @@ bitflags! {\n         const HAS_FREE_REGIONS   = 1 << 6,\n         const HAS_TY_ERR         = 1 << 7,\n         const HAS_PROJECTION     = 1 << 8,\n+\n+        // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9,\n \n         // true if there are \"names\" of types and regions and so forth\n@@ -1706,7 +1709,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyClosure(..) | TyNever => {\n+            TyArray(..) | TyClosure(..) | TyGenerator(..) | TyNever => {\n                 vec![]\n             }\n \n@@ -2039,6 +2042,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprBox(..) |\n             hir::ExprAddrOf(..) |\n             hir::ExprBinary(..) |\n+            hir::ExprYield(..) |\n             hir::ExprCast(..) => {\n                 false\n             }\n@@ -2271,6 +2275,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.trait_def(trait_def_id).has_default_impl\n     }\n \n+    pub fn generator_layout(self, def_id: DefId) -> &'tcx GeneratorLayout<'tcx> {\n+        self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n+    }\n+\n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {"}, {"sha": "657ed4077911c8cd0dd1ea353cce5b366c230fe6", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -115,6 +115,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            ty::TyGenerator(def_id, ref substs, ref interior) => {\n+                // Same as the closure case\n+                for upvar_ty in substs.upvar_tys(def_id, *self) {\n+                    self.compute_components(upvar_ty, out);\n+                }\n+\n+                // But generators can have additional interior types\n+                self.compute_components(interior.witness, out);\n+            }\n+\n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck.\n             ty::TyParam(p) => {"}, {"sha": "0ff3199689c192193f0bfe697efe8b6cf2ac97ff", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -389,6 +389,18 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n+        (&ty::TyGenerator(a_id, a_substs, a_interior),\n+         &ty::TyGenerator(b_id, b_substs, b_interior))\n+            if a_id == b_id =>\n+        {\n+            // All TyGenerator types with the same id represent\n+            // the (anonymous) type of the same generator expression. So\n+            // all of their regions should be equated.\n+            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let interior = relation.relate(&a_interior, &b_interior)?;\n+            Ok(tcx.mk_generator(a_id, substs, interior))\n+        }\n+\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n@@ -512,6 +524,18 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::GeneratorInterior<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::GeneratorInterior<'tcx>,\n+                           b: &ty::GeneratorInterior<'tcx>)\n+                           -> RelateResult<'tcx, ty::GeneratorInterior<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        let interior = relation.relate(&a.witness, &b.witness)?;\n+        Ok(ty::GeneratorInterior::new(interior))\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &&'tcx Substs<'tcx>,"}, {"sha": "6353c5e0dd0e015020dee1f9bab637bb03402cd4", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -29,6 +29,15 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     }\n }\n \n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n+    type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| {\n+            tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n+        })\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -220,6 +229,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorInterior<'a> {\n+    type Lifted = ty::GeneratorInterior<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.witness).map(|witness| {\n+            ty::GeneratorInterior { witness }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -283,6 +301,19 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n+    type Lifted = ty::GenSig<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.yield_ty, self.return_ty))\n+            .map(|(yield_ty, return_ty)| {\n+                ty::GenSig {\n+                    yield_ty,\n+                    return_ty,\n+                }\n+            })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -539,6 +570,9 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRef(ref r, tm) => {\n                 ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n+            ty::TyGenerator(did, substs, interior) => {\n+                ty::TyGenerator(did, substs.fold_with(folder), interior.fold_with(folder))\n+            }\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -570,6 +604,9 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n+            ty::TyGenerator(_did, ref substs, ref interior) => {\n+                substs.visit_with(visitor) || interior.visit_with(visitor)\n+            }\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n@@ -594,6 +631,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::GenSig<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GenSig {\n+            yield_ty: self.yield_ty.fold_with(folder),\n+            return_ty: self.return_ty.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.yield_ty.visit_with(visitor) ||\n+        self.return_ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let inputs_and_output = self.inputs_and_output.fold_with(folder);\n@@ -684,6 +735,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GeneratorInterior::new(self.witness.fold_with(folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.witness.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::adjustment::Adjustment {"}, {"sha": "4a3b5a02ae7fa962eb6150b35a25770c1c57f58c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -135,6 +135,10 @@ pub enum TypeVariants<'tcx> {\n     /// `|a| a`.\n     TyClosure(DefId, ClosureSubsts<'tcx>),\n \n+    /// The anonymous type of a generator. Used to represent the type of\n+    /// `|a| yield a`.\n+    TyGenerator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n+\n     /// The never type `!`\n     TyNever,\n \n@@ -261,6 +265,51 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n+    /// This returns the types of the MIR locals which had to be stored across suspension points.\n+    /// It is calculated in rustc_mir::transform::generator::StateTransform.\n+    /// All the types here must be in the tuple in GeneratorInterior.\n+    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'a\n+    {\n+        let state = tcx.generator_layout(def_id).fields.iter();\n+        state.map(move |d| d.ty.subst(tcx, self.substs))\n+    }\n+\n+    /// This is the types of all the fields stored in a generator.\n+    /// It includes the upvars, state types and the state discriminant which is u32.\n+    pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'a\n+    {\n+        let upvars = self.upvar_tys(def_id, tcx);\n+        let state = self.state_tys(def_id, tcx);\n+        upvars.chain(iter::once(tcx.types.u32)).chain(state)\n+    }\n+}\n+\n+/// This describes the types that can be contained in a generator.\n+/// It will be a type variable initially and unified in the last stages of typeck of a body.\n+/// It contains a tuple of all the types that could end up on a generator frame.\n+/// The state transformation MIR pass may only produce layouts which mention types in this tuple.\n+/// Upvars are not counted here.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct GeneratorInterior<'tcx> {\n+    pub witness: Ty<'tcx>,\n+}\n+\n+impl<'tcx> GeneratorInterior<'tcx> {\n+    pub fn new(witness: Ty<'tcx>) -> GeneratorInterior<'tcx> {\n+        GeneratorInterior { witness }\n+    }\n+\n+    pub fn as_slice(&self) -> &'tcx Slice<Ty<'tcx>> {\n+        match self.witness.sty {\n+            ty::TyTuple(s, _) => s,\n+            _ => bug!(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// e.g. Iterator\n@@ -579,6 +628,22 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct GenSig<'tcx> {\n+    pub yield_ty: Ty<'tcx>,\n+    pub return_ty: Ty<'tcx>,\n+}\n+\n+pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n+\n+impl<'tcx> PolyGenSig<'tcx> {\n+    pub fn yield_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|sig| sig.yield_ty)\n+    }\n+    pub fn return_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|sig| sig.return_ty)\n+    }\n+}\n \n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n@@ -1379,7 +1444,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyAdt(_, substs) | TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }\n-            TyClosure(_, ref substs) => {\n+            TyClosure(_, ref substs) | TyGenerator(_, ref substs, _) => {\n                 substs.substs.regions().collect()\n             }\n             TyProjection(ref data) => {"}, {"sha": "4e4c7b107c4292132378bfb6e4f025295a4da809", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -27,6 +27,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use std::cmp;\n+use std::iter;\n use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n@@ -573,6 +574,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect()\n             }\n \n+            ty::TyGenerator(def_id, substs, interior) => {\n+                substs.upvar_tys(def_id, self).chain(iter::once(interior.witness)).map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n             ty::TyAdt(def, substs) => {\n                 let ty::DtorckConstraint {\n                     dtorck_types, outlives\n@@ -694,6 +701,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n+            TyGenerator(def_id, _, _) |\n             TyAnon(def_id, _) |\n             TyFnDef(def_id, _) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n@@ -1120,6 +1128,11 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n \n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass\n+        ty::TyGenerator(..) => true,\n+\n         ty::TyTuple(ref tys, _) => tys.iter().cloned().any(needs_drop),\n \n         // unions don't have destructors regardless of the child types"}, {"sha": "bfabacdb1721496be8eb7bbcd18ff84b5312ac6d", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -112,6 +112,10 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyClosure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n+        ty::TyGenerator(_, ref substs, ref interior) => {\n+            stack.extend(substs.substs.types().rev());\n+            stack.push(interior.witness);\n+        }\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }"}, {"sha": "3516f7dfb25b0e1e538b8d8a076dc9288ca67196", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -281,8 +281,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyClosure(..) => {\n-                    // the types in a closure are always the types of\n+                ty::TyGenerator(..) | ty::TyClosure(..) => {\n+                    // the types in a closure or generator are always the types of\n                     // local variables (or possibly references to local\n                     // variables), we'll walk those.\n                     //"}, {"sha": "a5642467474b3bbb5d68e52c9265c7774f6417cb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -17,7 +17,7 @@ use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::{TyClosure, TyProjection, TyAnon};\n+use ty::{TyClosure, TyGenerator, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n@@ -715,6 +715,12 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.witness.fmt(f)\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -813,6 +819,41 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 })\n             }\n             TyStr => write!(f, \"str\"),\n+            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                let upvar_tys = substs.upvar_tys(did, tcx);\n+                write!(f, \"[generator\")?;\n+\n+                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                    let mut sep = \" \";\n+                    tcx.with_freevars(node_id, |freevars| {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                            let def_id = freevar.def.def_id();\n+                            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                            write!(f,\n+                                        \"{}{}:{}\",\n+                                        sep,\n+                                        tcx.local_var_name_str(node_id),\n+                                        upvar_ty)?;\n+                            sep = \", \";\n+                        }\n+                        Ok(())\n+                    })?\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in trans bug reports, I imagine.\n+                    write!(f, \"@{:?}\", did)?;\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                write!(f, \" {}\", interior)?;\n+\n+                write!(f, \"]\")\n+            }),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 let upvar_tys = substs.upvar_tys(did, tcx);\n                 write!(f, \"[closure\")?;"}, {"sha": "68bffb90f4da829a43a06282af47485ecaaa2eb8", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -48,9 +48,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    let body = glcx.bccx.tcx.hir.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n-        .consume_body(body);\n+        .consume_body(bccx.body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -127,7 +126,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-\n         self.guarantee_valid(borrow_id,\n                              borrow_span,\n                              cmt,"}, {"sha": "eca713a98df57ce99cd1ddf2085e49e4508fb4c3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 234, "deletions": 156, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -36,7 +36,7 @@ use rustc::middle::region::{self, RegionMaps};\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-\n+use rustc::util::nodemap::FxHashMap;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::fmt;\n@@ -100,9 +100,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n-    let bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n-\n-    let body = bccx.tcx.hir.body(body_id);\n+    let body = tcx.hir.body(body_id);\n+    let bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be\n@@ -139,10 +138,9 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let body = tcx.hir.body(body_id);\n     let id_range = {\n         let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir);\n-        visitor.visit_body(body);\n+        visitor.visit_body(this.body);\n         visitor.result()\n     };\n     let (all_loans, move_data) =\n@@ -163,7 +161,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n-                             Some(body),\n+                             Some(this.body),\n                              cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n@@ -174,13 +172,13 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                            loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n-    loan_dfcx.propagate(cfg, body);\n+    loan_dfcx.propagate(cfg, this.body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this,\n                                                       cfg,\n                                                       id_range,\n-                                                      body);\n+                                                      this.body);\n \n     Some(AnalysisData { all_loans,\n                         loans: loan_dfcx,\n@@ -199,7 +197,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n-    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n+    let body = tcx.hir.body(body_id);\n+    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n     (bccx, dataflow_data.unwrap())\n@@ -218,6 +217,8 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     region_maps: Rc<RegionMaps>,\n \n     owner_def_id: DefId,\n+\n+    body: &'tcx hir::Body,\n }\n \n impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n@@ -349,7 +350,7 @@ fn closure_to_block(closure_id: DefIndex,\n     let closure_id = tcx.hir.def_index_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., body_id, _) => {\n+            hir::ExprClosure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n             _ => {\n@@ -549,9 +550,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             _ => { }\n         }\n \n-        let mut db = self.bckerr_to_diag(&err);\n-        self.note_and_explain_bckerr(&mut db, err);\n-        db.emit();\n+        self.report_bckerr(&err);\n     }\n \n     pub fn report_use_of_moved_value(&self,\n@@ -652,7 +651,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::Captured =>\n                 (match self.tcx.hir.expect_expr(the_move.id).node {\n-                    hir::ExprClosure(.., fn_decl_span) => fn_decl_span,\n+                    hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n@@ -722,8 +721,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n-        let span = err.span.clone();\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, s: S, msg: &str, code: &str) {\n+        self.tcx.sess.span_err_with_code(s, msg, code);\n+    }\n+\n+    fn report_bckerr(&self, err: &BckError<'tcx>) {\n+        let error_span = err.span.clone();\n \n         match err.code {\n             err_mutbl => {\n@@ -747,12 +750,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                match err.cause {\n+                let mut db = match err.cause {\n                     MutabilityViolation => {\n-                        struct_span_err!(self.tcx.sess, span, E0594, \"cannot assign to {}\", descr)\n+                        struct_span_err!(self.tcx.sess,\n+                                         error_span,\n+                                         E0594,\n+                                         \"cannot assign to {}\",\n+                                         descr)\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, span, E0595,\n+                        struct_span_err!(self.tcx.sess, error_span, E0595,\n                                          \"closure cannot assign to {}\", descr)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n@@ -762,30 +769,228 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, span, E0596,\n+                        struct_span_err!(self.tcx.sess, error_span, E0596,\n                                          \"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }\n-                }\n+                };\n+\n+                self.note_and_explain_mutbl_error(&mut db, &err, &error_span);\n+                self.note_immutability_blame(&mut db, err.cmt.immutability_blame());\n+                db.emit();\n             }\n-            err_out_of_scope(..) => {\n+            err_out_of_scope(super_scope, sub_scope, cause) => {\n                 let msg = match opt_loan_path(&err.cmt) {\n                     None => \"borrowed value\".to_string(),\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n                     }\n                 };\n-                struct_span_err!(self.tcx.sess, span, E0597, \"{} does not live long enough\", msg)\n+\n+                // When you have a borrow that lives across a yield,\n+                // that reference winds up captured in the generator\n+                // type. Regionck then constraints it to live as long\n+                // as the generator itself. If that borrow is borrowing\n+                // data owned by the generator, this winds up resulting in\n+                // an `err_out_of_scope` error:\n+                //\n+                // ```\n+                // {\n+                //     let g = || {\n+                //         let a = &3; // this borrow is forced to ... -+\n+                //         yield ();          //                        |\n+                //         println!(\"{}\", a); //                        |\n+                //     };                     //                        |\n+                // } <----------------------... live until here --------+\n+                // ```\n+                //\n+                // To detect this case, we look for cases where the\n+                // `super_scope` (lifetime of the value) is within the\n+                // body, but the `sub_scope` is not.\n+                debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n+                       self.body.is_generator);\n+                let maybe_borrow_across_yield = if self.body.is_generator {\n+                    let body_extent = region::CodeExtent::Misc(self.body.id().node_id);\n+                    debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n+                    debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n+                    debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n+                    match (super_scope, sub_scope) {\n+                        (&ty::RegionKind::ReScope(value_extent),\n+                         &ty::RegionKind::ReScope(loan_extent)) => {\n+                            if {\n+                                // value_extent <= body_extent &&\n+                                self.region_maps.is_subscope_of(value_extent, body_extent) &&\n+                                    // body_extent <= loan_extent\n+                                    self.region_maps.is_subscope_of(body_extent, loan_extent)\n+                            } {\n+                                // We now know that this is a case\n+                                // that fits the bill described above:\n+                                // a borrow of something whose scope\n+                                // is within the generator, but the\n+                                // borrow is for a scope outside the\n+                                // generator.\n+                                //\n+                                // Now look within the scope of the of\n+                                // the value being borrowed (in the\n+                                // example above, that would be the\n+                                // block remainder that starts with\n+                                // `let a`) for a yield. We can cite\n+                                // that for the user.\n+                                self.tcx.yield_in_extent(value_extent, &mut FxHashMap())\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                };\n+\n+                if let Some(yield_span) = maybe_borrow_across_yield {\n+                    debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n+                    struct_span_err!(self.tcx.sess,\n+                                     error_span,\n+                                     E0626,\n+                                     \"borrow may still be in use when generator yields\")\n+                        .span_label(yield_span, \"possible yield occurs here\")\n+                        .emit();\n+                    return;\n+                }\n+\n+                let mut db = struct_span_err!(self.tcx.sess,\n+                                              error_span,\n+                                              E0597,\n+                                              \"{} does not live long enough\",\n+                                              msg);\n+\n+                let (value_kind, value_msg) = match err.cmt.cat {\n+                    mc::Categorization::Rvalue(..) =>\n+                        (\"temporary value\", \"temporary value created here\"),\n+                    _ =>\n+                        (\"borrowed value\", \"borrow occurs here\")\n+                };\n+\n+                let is_closure = match cause {\n+                    euv::ClosureCapture(s) => {\n+                        // The primary span starts out as the closure creation point.\n+                        // Change the primary span here to highlight the use of the variable\n+                        // in the closure, because it seems more natural. Highlight\n+                        // closure creation point as a secondary span.\n+                        match db.span.primary_span() {\n+                            Some(primary) => {\n+                                db.span = MultiSpan::from_span(s);\n+                                db.span_label(primary, \"capture occurs here\");\n+                                db.span_label(s, \"does not live long enough\");\n+                                true\n+                            }\n+                            None => false\n+                        }\n+                    }\n+                    _ => {\n+                        db.span_label(error_span, \"does not live long enough\");\n+                        false\n+                    }\n+                };\n+\n+                let sub_span = self.region_end_span(sub_scope);\n+                let super_span = self.region_end_span(super_scope);\n+\n+                match (sub_span, super_span) {\n+                    (Some(s1), Some(s2)) if s1 == s2 => {\n+                        if !is_closure {\n+                            db.span = MultiSpan::from_span(s1);\n+                            db.span_label(error_span, value_msg);\n+                            let msg = match opt_loan_path(&err.cmt) {\n+                                None => value_kind.to_string(),\n+                                Some(lp) => {\n+                                    format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                                }\n+                            };\n+                            db.span_label(s1,\n+                                          format!(\"{} dropped here while still borrowed\", msg));\n+                        } else {\n+                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n+                        }\n+                        db.note(\"values in a scope are dropped in the opposite order \\\n+                                they are created\");\n+                    }\n+                    (Some(s1), Some(s2)) if !is_closure => {\n+                        db.span = MultiSpan::from_span(s2);\n+                        db.span_label(error_span, value_msg);\n+                        let msg = match opt_loan_path(&err.cmt) {\n+                            None => value_kind.to_string(),\n+                            Some(lp) => {\n+                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                            }\n+                        };\n+                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n+                    }\n+                    _ => {\n+                        match sub_span {\n+                            Some(s) => {\n+                                db.span_label(s, format!(\"{} needs to live until here\",\n+                                                          value_kind));\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    &mut db,\n+                                    \"borrowed value must be valid for \",\n+                                    sub_scope,\n+                                    \"...\");\n+                            }\n+                        }\n+                        match super_span {\n+                            Some(s) => {\n+                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    &mut db,\n+                                    \"...but borrowed value is only valid for \",\n+                                    super_scope,\n+                                    \"\");\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n+                    db.note(\"consider using a `let` binding to increase its lifetime\");\n+                }\n+\n+                db.emit();\n             }\n-            err_borrowed_pointer_too_short(..) => {\n+            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                struct_span_err!(self.tcx.sess, span, E0598,\n-                                 \"lifetime of {} is too short to guarantee \\\n-                                  its contents can be safely reborrowed\",\n-                                 descr)\n+                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n+                                              \"lifetime of {} is too short to guarantee \\\n+                                               its contents can be safely reborrowed\",\n+                                              descr);\n+\n+                let descr = match opt_loan_path(&err.cmt) {\n+                    Some(lp) => {\n+                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                    }\n+                    None => self.cmt_to_string(&err.cmt),\n+                };\n+                self.tcx.note_and_explain_region(\n+                    &mut db,\n+                    &format!(\"{} would have to be valid for \",\n+                            descr),\n+                    loan_scope,\n+                    \"...\");\n+                self.tcx.note_and_explain_region(\n+                    &mut db,\n+                    &format!(\"...but {} is only valid for \", descr),\n+                    ptr_scope,\n+                    \"\");\n+\n+                db.emit();\n             }\n         }\n     }\n@@ -1048,133 +1253,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n-        let error_span = err.span.clone();\n-        match err.code {\n-            err_mutbl => {\n-                self.note_and_explain_mutbl_error(db, &err, &error_span);\n-                self.note_immutability_blame(db, err.cmt.immutability_blame());\n-            }\n-            err_out_of_scope(super_scope, sub_scope, cause) => {\n-                let (value_kind, value_msg) = match err.cmt.cat {\n-                    mc::Categorization::Rvalue(..) =>\n-                        (\"temporary value\", \"temporary value created here\"),\n-                    _ =>\n-                        (\"borrowed value\", \"borrow occurs here\")\n-                };\n-\n-                let is_closure = match cause {\n-                    euv::ClosureCapture(s) => {\n-                        // The primary span starts out as the closure creation point.\n-                        // Change the primary span here to highlight the use of the variable\n-                        // in the closure, because it seems more natural. Highlight\n-                        // closure creation point as a secondary span.\n-                        match db.span.primary_span() {\n-                            Some(primary) => {\n-                                db.span = MultiSpan::from_span(s);\n-                                db.span_label(primary, \"capture occurs here\");\n-                                db.span_label(s, \"does not live long enough\");\n-                                true\n-                            }\n-                            None => false\n-                        }\n-                    }\n-                    _ => {\n-                        db.span_label(error_span, \"does not live long enough\");\n-                        false\n-                    }\n-                };\n-\n-                let sub_span = self.region_end_span(sub_scope);\n-                let super_span = self.region_end_span(super_scope);\n-\n-                match (sub_span, super_span) {\n-                    (Some(s1), Some(s2)) if s1 == s2 => {\n-                        if !is_closure {\n-                            db.span = MultiSpan::from_span(s1);\n-                            db.span_label(error_span, value_msg);\n-                            let msg = match opt_loan_path(&err.cmt) {\n-                                None => value_kind.to_string(),\n-                                Some(lp) => {\n-                                    format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                                }\n-                            };\n-                            db.span_label(s1,\n-                                          format!(\"{} dropped here while still borrowed\", msg));\n-                        } else {\n-                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n-                        }\n-                        db.note(\"values in a scope are dropped in the opposite order \\\n-                                they are created\");\n-                    }\n-                    (Some(s1), Some(s2)) if !is_closure => {\n-                        db.span = MultiSpan::from_span(s2);\n-                        db.span_label(error_span, value_msg);\n-                        let msg = match opt_loan_path(&err.cmt) {\n-                            None => value_kind.to_string(),\n-                            Some(lp) => {\n-                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                            }\n-                        };\n-                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n-                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n-                    }\n-                    _ => {\n-                        match sub_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} needs to live until here\",\n-                                                          value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    db,\n-                                    \"borrowed value must be valid for \",\n-                                    sub_scope,\n-                                    \"...\");\n-                            }\n-                        }\n-                        match super_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    db,\n-                                    \"...but borrowed value is only valid for \",\n-                                    super_scope,\n-                                    \"\");\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n-                    db.note(\"consider using a `let` binding to increase its lifetime\");\n-                }\n-            }\n-\n-            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n-                let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                    }\n-                    None => self.cmt_to_string(&err.cmt),\n-                };\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    &format!(\"{} would have to be valid for \",\n-                            descr),\n-                    loan_scope,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    &format!(\"...but {} is only valid for \", descr),\n-                    ptr_scope,\n-                    \"\");\n-            }\n-        }\n-    }\n-\n     fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'tcx>,\n                                     error_span: &Span) {\n         match err.cmt.note {"}, {"sha": "74133c821f0fa6a0f6c87a41b8e3751f9a446f4d", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -652,6 +652,92 @@ x.x = Some(&y);\n ```\n \"##,\n \n+E0626: r##\"\n+This error occurs because a borrow in a generator persists across a\n+yield point.\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = &String::new(); // <-- This borrow...\n+    yield (); // ...is still in scope here, when the yield occurs.\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+At present, it is not permitted to have a yield that occurs while a\n+borrow is still in scope. To resolve this error, the borrow must\n+either be \"contained\" to a smaller scope that does not overlap the\n+yield or else eliminated in another way. So, for example, we might\n+resolve the previous example by removing the borrow and just storing\n+the integer by value:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = 3;\n+    yield ();\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+This is a very simple case, of course. In more complex cases, we may\n+wish to have more than one reference to the value that was borrowed --\n+in those cases, something like the `Rc` or `Arc` types may be useful.\n+\n+This error also frequently arises with iteration:\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for &x in &v { // <-- borrow of `v` is still in scope...\n+    yield x; // ...when this yield occurs.\n+  }\n+};\n+b.resume();\n+```\n+\n+Such cases can sometimes be resolved by iterating \"by value\" (or using\n+`into_iter()`) to avoid borrowing:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for x in v { // <-- Take ownership of the values instead!\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+```\n+\n+If taking ownership is not an option, using indices can work too:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  let len = v.len(); // (*)\n+  for i in 0..len {\n+    let x = v[i]; // (*)\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+\n+// (*) -- Unfortunately, these temporaries are currently required.\n+// See <https://github.com/rust-lang/rust/issues/43122>.\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "47fa21e3bf0b2bf6a1e47f4d6c78b94c1aca9246", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n use std::fmt;\n+use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::ops::{Deref, DerefMut, Range};\n+use std::slice;\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract};\n use indexed_vec::Idx;\n@@ -21,6 +23,7 @@ use indexed_vec::Idx;\n ///\n /// In other words, `T` is the type used to index into the bitvector\n /// this type uses to represent the set of object it holds.\n+#[derive(Eq, PartialEq)]\n pub struct IdxSetBuf<T: Idx> {\n     _pd: PhantomData<fn(&T)>,\n     bits: Vec<Word>,\n@@ -109,6 +112,13 @@ impl<T: Idx> IdxSet<T> {\n         }\n     }\n \n+    /// Removes all elements\n+    pub fn clear(&mut self) {\n+        for b in &mut self.bits {\n+            *b = 0;\n+        }\n+    }\n+\n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n         self.bits.clear_bit(elem.index())\n@@ -154,6 +164,14 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n \n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n+            cur: None,\n+            iter: self.words().iter().enumerate(),\n+            _pd: PhantomData,\n+        }\n+    }\n+\n     /// Calls `f` on each index value held in this set, up to the\n     /// bound `max_bits` on the size of universe of indexes.\n     pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n@@ -218,3 +236,32 @@ fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: Fn\n         }\n     }\n }\n+\n+pub struct Iter<'a, T: Idx> {\n+    cur: Option<(Word, usize)>,\n+    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    _pd: PhantomData<fn(&T)>,\n+}\n+\n+impl<'a, T: Idx> Iterator for Iter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let word_bits = mem::size_of::<Word>() * 8;\n+        loop {\n+            if let Some((ref mut word, offset)) = self.cur {\n+                let bit_pos = word.trailing_zeros() as usize;\n+                if bit_pos != word_bits {\n+                    let bit = 1 << bit_pos;\n+                    *word ^= bit;\n+                    return Some(T::new(bit_pos + offset))\n+                }\n+            }\n+\n+            match self.iter.next() {\n+                Some((i, word)) => self.cur = Some((*word, word_bits * i)),\n+                None => return None,\n+            }\n+        }\n+    }\n+}"}, {"sha": "1d0e88ee328556cb6000c96750b2afd70bfd6f9d", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -38,7 +38,7 @@ impl Idx for u32 {\n     fn index(self) -> usize { self as usize }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<Fn(&I)>"}, {"sha": "33c4a041cff882dcf186050450d3ad1097a27b79", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -292,6 +292,15 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     }\n }\n \n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "000d89241a427b756ba8b578d7c0b6ea94b3d9c9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1015,6 +1015,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyLocals);\n+\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::generator::StateTransform);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n "}, {"sha": "daf7d743e1235209f1309fd50a0d917d0db88615", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -607,6 +607,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyInfer(..) |\n             ty::TyError |\n             ty::TyClosure(..) |\n+            ty::TyGenerator(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n             ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),"}, {"sha": "56138955e8e66e6c50cdeb8b8a3e25d9d05eafc6", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -105,6 +105,7 @@ provide! { <'tcx> tcx, def_id, cdata,\n \n         mir\n     }\n+    generator_sig => { cdata.generator_sig(def_id.index, tcx) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }"}, {"sha": "72058747a76d284f7046bb8ca89521eb264d2b4a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -438,6 +438,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::DefaultImpl(_) |\n             EntryKind::Field |\n+            EntryKind::Generator(_) |\n             EntryKind::Closure(_) => return None,\n         })\n     }\n@@ -1100,6 +1101,23 @@ impl<'a, 'tcx> CrateMetadata {\n         sig.decode((self, tcx))\n     }\n \n+    fn get_generator_data(&self,\n+                      id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> Option<GeneratorData<'tcx>> {\n+        match self.entry(id).kind {\n+            EntryKind::Generator(data) => Some(data.decode((self, tcx))),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn generator_sig(&self,\n+                      id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> Option<ty::PolyGenSig<'tcx>> {\n+        self.get_generator_data(id, tcx).map(|d| d.sig)\n+    }\n+\n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.def_path_table.def_key(index)"}, {"sha": "be3ac51ccb3bfcdb473b2cc637a613a20c12558e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1213,13 +1213,23 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let data = ClosureData {\n-            kind: tcx.closure_kind(def_id),\n-            sig: self.lazy(&tcx.fn_sig(def_id)),\n+        let kind = if let Some(sig) = self.tcx.generator_sig(def_id) {\n+            let layout = self.tcx.generator_layout(def_id);\n+            let data = GeneratorData {\n+                sig,\n+                layout: layout.clone(),\n+            };\n+            EntryKind::Generator(self.lazy(&data))\n+        } else {\n+            let data = ClosureData {\n+                kind: tcx.closure_kind(def_id),\n+                sig: self.lazy(&tcx.fn_sig(def_id)),\n+            };\n+            EntryKind::Closure(self.lazy(&data))\n         };\n \n         Entry {\n-            kind: EntryKind::Closure(self.lazy(&data)),\n+            kind,\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),"}, {"sha": "d065a0fc21c6c1f59714645af5f41d157127352f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -353,6 +353,7 @@ pub enum EntryKind<'tcx> {\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n+    Generator(Lazy<GeneratorData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n@@ -401,6 +402,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryK\n             EntryKind::MacroDef(ref macro_def) => {\n                 macro_def.hash_stable(hcx, hasher);\n             }\n+            EntryKind::Generator(data) => {\n+                data.hash_stable(hcx, hasher);\n+            }\n             EntryKind::Closure(closure_data) => {\n                 closure_data.hash_stable(hcx, hasher);\n             }\n@@ -564,3 +568,10 @@ pub struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n impl_stable_hash_for!(struct ClosureData<'tcx> { kind, sig });\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct GeneratorData<'tcx> {\n+    pub sig: ty::PolyGenSig<'tcx>,\n+    pub layout: mir::GeneratorLayout<'tcx>,\n+}\n+impl_stable_hash_for!(struct GeneratorData<'tcx> { sig, layout });"}, {"sha": "0224393c3fe5caa8ced7f76728c006ee37f2494e", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -279,12 +279,20 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                                              (index, span), flow_state);\n                     }\n                     AssertMessage::Math(_/*const_math_err*/) => {}\n+                    AssertMessage::GeneratorResumedAfterReturn => {}\n+                    AssertMessage::GeneratorResumedAfterPanic => {}\n                 }\n             }\n \n+            TerminatorKind::Yield { ref value, resume: _, drop: _} => {\n+                self.consume_operand(ContextKind::Yield.new(loc),\n+                                     Consume, (value, span), flow_state);\n+            }\n+\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n+            TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable => {\n                 // no data used, thus irrelevant to borrowck\n             }\n@@ -1102,6 +1110,7 @@ enum ContextKind {\n     CallDest,\n     Assert,\n     StorageDead,\n+    Yield,\n }\n \n impl ContextKind {"}, {"sha": "72eeaca8b101f3fe92ac5cea2c3d9bf5b1f3bfe8", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -118,6 +118,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Return { .. } |\n             ExprKind::Literal { .. } |\n             ExprKind::InlineAsm { .. } |\n+            ExprKind::Yield { .. } |\n             ExprKind::Call { .. } => {\n                 // these are not lvalues, so we need to make a temporary.\n                 debug_assert!(match Category::of(&expr.kind) {"}, {"sha": "da375e791bc4b1f7ce59f7edf52dc59cf5ce5e4f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -185,12 +185,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars } => { // see (*) above\n-                let upvars =\n+            ExprKind::Closure { closure_id, substs, upvars, interior } => { // see (*) above\n+                let mut operands: Vec<_> =\n                     upvars.into_iter()\n                           .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n                           .collect();\n-                block.and(Rvalue::Aggregate(box AggregateKind::Closure(closure_id, substs), upvars))\n+                let result = if let Some(interior) = interior {\n+                    // Add the state operand since it follows the upvars in the generator\n+                    // struct. See librustc_mir/transform/generator.rs for more details.\n+                    operands.push(Operand::Constant(box Constant {\n+                        span: expr_span,\n+                        ty: this.hir.tcx().types.u32,\n+                        literal: Literal::Value {\n+                            value: ConstVal::Integral(ConstInt::U32(0)),\n+                        },\n+                    }));\n+                    box AggregateKind::Generator(closure_id, substs, interior)\n+                } else {\n+                    box AggregateKind::Closure(closure_id, substs)\n+                };\n+                block.and(Rvalue::Aggregate(result, operands))\n             }\n             ExprKind::Adt {\n                 adt_def, variant_index, substs, fields, base\n@@ -232,6 +246,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block = unpack!(this.stmt_expr(block, expr));\n                 block.and(this.unit_rvalue())\n             }\n+            ExprKind::Yield { value } => {\n+                let value = unpack!(block = this.as_operand(block, scope, value));\n+                let resume = this.cfg.start_new_block();\n+                let cleanup = this.generator_drop_cleanup();\n+                this.cfg.terminate(block, source_info, TerminatorKind::Yield {\n+                    value: value,\n+                    resume: resume,\n+                    drop: cleanup,\n+                });\n+                resume.and(this.unit_rvalue())\n+            }\n             ExprKind::Literal { .. } |\n             ExprKind::Block { .. } |\n             ExprKind::Match { .. } |"}, {"sha": "f05411aacab19801c427e9b2cd8d992240394054", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -77,6 +77,7 @@ impl Category {\n             ExprKind::Borrow { .. } |\n             ExprKind::Assign { .. } |\n             ExprKind::AssignOp { .. } |\n+            ExprKind::Yield { .. } |\n             ExprKind::InlineAsm { .. } =>\n                 Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n "}, {"sha": "f8db2c820829b4985ad0487ca8b5c9a055e4131d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -284,6 +284,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Index { .. } |\n             ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n+            ExprKind::Yield { .. } |\n             ExprKind::Field { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,"}, {"sha": "fb345e944969af1c56b388baf09e098f5cbcd0d5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -712,6 +712,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n+            internal: false,\n             is_user_variable: true,\n         });\n         self.var_indices.insert(var_id, var);"}, {"sha": "65bbf098cbe174c49bec2a62cf02ffa68466e259", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -71,7 +71,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // Assume that everything other than closures\n             // is a constant \"initializer\" expression.\n             match expr.node {\n-                hir::ExprClosure(_, _, body, _) => body,\n+                hir::ExprClosure(_, _, body, _, _) => body,\n                 _ => hir::BodyId { node_id: expr.id }\n             }\n         }\n@@ -95,13 +95,18 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n-            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n-                // HACK(eddyb) Avoid having RustCall on closures,\n-                // as it adds unnecessary (and wrong) auto-tupling.\n-                abi = Abi::Rust;\n-                Some((closure_self_ty(tcx, id, body_id), None))\n-            } else {\n-                None\n+            let implicit_argument = match ty.sty {\n+                ty::TyClosure(..) => {\n+                    // HACK(eddyb) Avoid having RustCall on closures,\n+                    // as it adds unnecessary (and wrong) auto-tupling.\n+                    abi = Abi::Rust;\n+                    Some((closure_self_ty(tcx, id, body_id), None))\n+                }\n+                ty::TyGenerator(..) => {\n+                    let gen_ty =  tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n+                    Some((gen_ty, None))\n+                }\n+                _ => None,\n             };\n \n             let body = tcx.hir.body(body_id);\n@@ -114,7 +119,15 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+\n+            let (yield_ty, return_ty) = if body.is_generator {\n+                let gen_sig = cx.tables().generator_sigs()[fn_hir_id].clone().unwrap();\n+                (Some(gen_sig.yield_ty), gen_sig.return_ty)\n+            } else {\n+                (None, fn_sig.output())\n+            };\n+\n+            build::construct_fn(cx, id, arguments, abi, return_ty, yield_ty, body)\n         } else {\n             build::construct_const(cx, body_id)\n         };\n@@ -199,7 +212,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n@@ -328,6 +341,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    arguments: A,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n+                                   yield_ty: Option<Ty<'gcx>>,\n                                    body: &'gcx hir::Body)\n                                    -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n@@ -336,7 +350,10 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n-    let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n+    let mut builder = Builder::new(hir.clone(),\n+        span,\n+        arguments.len(),\n+        return_ty);\n \n     let call_site_extent = CodeExtent::CallSiteScope(body.id());\n     let arg_extent = CodeExtent::ParameterScope(body.id());\n@@ -391,7 +408,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         }).collect()\n     });\n \n-    let mut mir = builder.finish(upvar_decls, return_ty);\n+    let mut mir = builder.finish(upvar_decls, return_ty, yield_ty);\n     mir.spread_arg = spread_arg;\n     mir\n }\n@@ -416,7 +433,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Constants can't `return` so a return block should not be created.\n     assert_eq!(builder.cached_return_block, None);\n \n-    builder.finish(vec![], ty)\n+    builder.finish(vec![], ty, None)\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n@@ -427,7 +444,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir, span, 0, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(vec![], ty)\n+    builder.finish(vec![], ty, None)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -462,7 +479,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              return_ty: Ty<'tcx>)\n+              return_ty: Ty<'tcx>,\n+              yield_ty: Option<Ty<'tcx>>)\n               -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n@@ -474,6 +492,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                  self.visibility_scopes,\n                  IndexVec::new(),\n                  return_ty,\n+                 yield_ty,\n                  self.local_decls,\n                  self.arg_count,\n                  upvar_decls,\n@@ -506,6 +525,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: pattern.map_or(self.fn_span, |pat| pat.span)\n                 },\n                 name,\n+                internal: false,\n                 is_user_variable: false,\n             });\n         }"}, {"sha": "c32e7b247634a60ed123b89ebfe10c00622937ea", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 125, "deletions": 21, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -126,6 +126,9 @@ pub struct Scope<'tcx> {\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+\n+    /// The cache for drop chain on \"generator drop\" exit.\n+    cached_generator_drop: Option<BasicBlock>,\n }\n \n #[derive(Debug)]\n@@ -140,14 +143,22 @@ struct DropData<'tcx> {\n     kind: DropKind\n }\n \n+#[derive(Debug, Default, Clone, Copy)]\n+struct CachedBlock {\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains code to run the current drop and all the preceding\n+    /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n+    /// array)\n+    unwind: Option<BasicBlock>,\n+\n+    /// The cached block for unwinds during cleanups-on-generator-drop path\n+    generator_drop: Option<BasicBlock>,\n+}\n+\n #[derive(Debug)]\n enum DropKind {\n     Value {\n-        /// The cached block for the cleanups-on-diverge path. This block\n-        /// contains code to run the current drop and all the preceding\n-        /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n-        /// array)\n-        cached_block: Option<BasicBlock>\n+        cached_block: CachedBlock,\n     },\n     Storage\n }\n@@ -166,6 +177,29 @@ pub struct BreakableScope<'tcx> {\n     pub break_destination: Lvalue<'tcx>,\n }\n \n+impl CachedBlock {\n+    fn invalidate(&mut self) {\n+        self.generator_drop = None;\n+        self.unwind = None;\n+    }\n+\n+    fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n+        if generator_drop {\n+            self.generator_drop\n+        } else {\n+            self.unwind\n+        }\n+    }\n+\n+    fn ref_mut(&mut self, generator_drop: bool) -> &mut Option<BasicBlock> {\n+        if generator_drop {\n+            &mut self.generator_drop\n+        } else {\n+            &mut self.unwind\n+        }\n+    }\n+}\n+\n impl DropKind {\n     fn may_panic(&self) -> bool {\n         match *self {\n@@ -187,7 +221,7 @@ impl<'tcx> Scope<'tcx> {\n         if !unwind { return; }\n         for dropdata in &mut self.drops {\n             if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n-                *cached_block = None;\n+                cached_block.invalidate();\n             }\n         }\n     }\n@@ -196,10 +230,12 @@ impl<'tcx> Scope<'tcx> {\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n-    fn cached_block(&self) -> Option<BasicBlock> {\n+    fn cached_block(&self, generator_drop: bool) -> Option<BasicBlock> {\n         let mut drops = self.drops.iter().rev().filter_map(|data| {\n             match data.kind {\n-                DropKind::Value { cached_block } => Some(cached_block),\n+                DropKind::Value { cached_block } => {\n+                    Some(cached_block.get(generator_drop))\n+                }\n                 DropKind::Storage => None\n             }\n         });\n@@ -294,6 +330,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent_span: extent.1.span,\n             needs_cleanup: false,\n             drops: vec![],\n+            cached_generator_drop: None,\n             cached_exits: FxHashMap()\n         });\n     }\n@@ -319,7 +356,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                           &scope,\n                                           &self.scopes,\n                                           block,\n-                                          self.arg_count));\n+                                          self.arg_count,\n+                                          false));\n \n         self.cfg.push_end_region(block, extent.1, scope.extent);\n         block.unit()\n@@ -370,7 +408,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               scope,\n                                               rest,\n                                               block,\n-                                              self.arg_count));\n+                                              self.arg_count,\n+                                              false));\n \n             // End all regions for scopes out of which we are breaking.\n             self.cfg.push_end_region(block, extent.1, scope.extent);\n@@ -381,6 +420,55 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            TerminatorKind::Goto { target: target });\n     }\n \n+    /// Creates a path that performs all required cleanup for dropping a generator.\n+    ///\n+    /// This path terminates in GeneratorDrop. Returns the start of the path.\n+    /// None indicates there\u2019s no cleanup to do at this point.\n+    pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n+        if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n+            return None;\n+        }\n+\n+        // Fill in the cache\n+        self.diverge_cleanup_gen(true);\n+\n+        let src_info = self.scopes[0].source_info(self.fn_span);\n+        let mut block = self.cfg.start_new_block();\n+        let result = block;\n+        let mut rest = &mut self.scopes[..];\n+\n+        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n+            rest = rest_;\n+            if !scope.needs_cleanup {\n+                continue;\n+            }\n+            block = if let Some(b) = scope.cached_generator_drop {\n+                self.cfg.terminate(block, src_info,\n+                                   TerminatorKind::Goto { target: b });\n+                return Some(result);\n+            } else {\n+                let b = self.cfg.start_new_block();\n+                scope.cached_generator_drop = Some(b);\n+                self.cfg.terminate(block, src_info,\n+                                   TerminatorKind::Goto { target: b });\n+                b\n+            };\n+            unpack!(block = build_scope_drops(&mut self.cfg,\n+                                              scope,\n+                                              rest,\n+                                              block,\n+                                              self.arg_count,\n+                                              true));\n+\n+            // End all regions for scopes out of which we are breaking.\n+            self.cfg.push_end_region(block, src_info, scope.extent);\n+        }\n+\n+        self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n+\n+        Some(result)\n+    }\n+\n     /// Creates a new visibility scope, nested in the current one.\n     pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n         let parent = self.visibility_scope;\n@@ -465,7 +553,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 None,\n             MirSource::Fn(_) =>\n                 Some(self.topmost_scope()),\n-            MirSource::Promoted(..) =>\n+            MirSource::Promoted(..) |\n+            MirSource::GeneratorDrop(..) =>\n                 bug!(),\n         }\n     }\n@@ -481,7 +570,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n         let drop_kind = if needs_drop {\n-            DropKind::Value { cached_block: None }\n+            DropKind::Value { cached_block: CachedBlock::default() }\n         } else {\n             // Only temps and vars need their storage dead.\n             match *lvalue {\n@@ -567,6 +656,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n     pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n+        self.diverge_cleanup_gen(false)\n+    }\n+\n+    fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> Option<BasicBlock> {\n         if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n             return None;\n         }\n@@ -599,7 +692,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in scopes.iter_mut() {\n-            target = build_diverge_scope(cfg, scope.extent_span, scope, target);\n+            target = build_diverge_scope(cfg, scope.extent_span, scope, target, generator_drop);\n         }\n         Some(target)\n     }\n@@ -676,7 +769,8 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            scope: &Scope<'tcx>,\n                            earlier_scopes: &[Scope<'tcx>],\n                            mut block: BasicBlock,\n-                           arg_count: usize)\n+                           arg_count: usize,\n+                           generator_drop: bool)\n                            -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n     let mut iter = scope.drops.iter().rev().peekable();\n@@ -688,16 +782,20 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                 // for us to diverge into in case the drop panics.\n                 let on_diverge = iter.peek().iter().filter_map(|dd| {\n                     match dd.kind {\n-                        DropKind::Value { cached_block: None } =>\n-                            span_bug!(drop_data.span, \"cached block not present?\"),\n-                        DropKind::Value { cached_block } => cached_block,\n+                        DropKind::Value { cached_block } => {\n+                            let result = cached_block.get(generator_drop);\n+                            if result.is_none() {\n+                                span_bug!(drop_data.span, \"cached block not present?\")\n+                            }\n+                            result\n+                        },\n                         DropKind::Storage => None\n                     }\n                 }).next();\n                 // If there\u2019s no `cached_block`s within current scope,\n                 // we must look for one in the enclosing scope.\n                 let on_diverge = on_diverge.or_else(|| {\n-                    earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n+                    earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n                 });\n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n@@ -710,6 +808,11 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             DropKind::Storage => {}\n         }\n \n+        // We do not need to emit StorageDead for generator drops\n+        if generator_drop {\n+            continue\n+        }\n+\n         // Drop the storage for both value and storage drops.\n         // Only temps and vars need their storage dead.\n         match drop_data.location {\n@@ -728,7 +831,8 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n                                        span: Span,\n                                        scope: &mut Scope<'tcx>,\n-                                       mut target: BasicBlock)\n+                                       mut target: BasicBlock,\n+                                       generator_drop: bool)\n                                        -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n@@ -742,7 +846,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n     // The code in this function reads from right to left. At each\n     // point, we check for cached blocks representing the\n     // remainder. If everything is cached, we'll just walk right to\n-    // left reading the cached results but never created anything.\n+    // left reading the cached results but never create anything.\n \n     let visibility_scope = scope.visibility_scope;\n     let source_info = |span| SourceInfo {\n@@ -764,7 +868,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n         let cached_block = match drop_data.kind {\n-            DropKind::Value { ref mut cached_block } => cached_block,\n+            DropKind::Value { ref mut cached_block } => cached_block.ref_mut(generator_drop),\n             DropKind::Storage => continue\n         };\n         target = if let Some(cached_block) = *cached_block {"}, {"sha": "9f9909a8f57a99f9b1d4cf74e5319d0432fcb254", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -653,15 +653,21 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n         match bb_data.terminator().kind {\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable => {}\n             mir::TerminatorKind::Goto { ref target } |\n             mir::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n+            mir::TerminatorKind::Yield { resume: ref target, drop: None, .. } |\n             mir::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n             mir::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: None\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n+            mir::TerminatorKind::Yield { resume: ref target, drop: Some(ref drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, drop);\n+            }\n             mir::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n             mir::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n             mir::TerminatorKind::DropAndReplace {"}, {"sha": "86298c3b83e29ce63a07876f88d0c49f6f610bbf", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -263,6 +263,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n+            TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n@@ -274,6 +275,10 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 // branching terminators - these don't move anything\n             }\n \n+            TerminatorKind::Yield { ref value, .. } => {\n+                self.gather_operand(loc, value);\n+            }\n+\n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n                 self.gather_move(loc, location);\n             }"}, {"sha": "553da2c978fe728ba37bc80d3eb6acaa916f6aa9", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -432,8 +432,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprClosure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n-            let (def_id, substs) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, substs),\n+            let (def_id, substs, interior) = match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) => (def_id, substs, None),\n+                ty::TyGenerator(def_id, substs, interior) => (def_id, substs, Some(interior)),\n                 _ => {\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n@@ -448,6 +449,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 closure_id: def_id,\n                 substs,\n                 upvars,\n+                interior,\n             }\n         }\n \n@@ -567,6 +569,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n         hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+\n+        hir::ExprYield(ref v) => ExprKind::Yield { value: v.to_ref() },\n     };\n \n     Expr {\n@@ -703,56 +707,65 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(closure_def_id) {\n-                ty::ClosureKind::Fn => {\n-                    let ref_closure_ty = cx.tcx.mk_ref(region,\n-                                                       ty::TypeAndMut {\n-                                                           ty: closure_ty,\n-                                                           mutbl: hir::MutImmutable,\n-                                                       });\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::Deref {\n-                            arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef,\n-                            }\n-                            .to_ref(),\n-                        },\n+            let self_expr = if let ty::TyClosure(..) = closure_ty.sty {\n+                match cx.tcx.closure_kind(closure_def_id) {\n+                    ty::ClosureKind::Fn => {\n+                        let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                           ty::TypeAndMut {\n+                                                               ty: closure_ty,\n+                                                               mutbl: hir::MutImmutable,\n+                                                           });\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime: temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::Deref {\n+                                arg: Expr {\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                            },\n+                        }\n                     }\n-                }\n-                ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty = cx.tcx.mk_ref(region,\n-                                                       ty::TypeAndMut {\n-                                                           ty: closure_ty,\n-                                                           mutbl: hir::MutMutable,\n-                                                       });\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::Deref {\n-                            arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef,\n-                            }.to_ref(),\n-                        },\n+                    ty::ClosureKind::FnMut => {\n+                        let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                           ty::TypeAndMut {\n+                                                               ty: closure_ty,\n+                                                               mutbl: hir::MutMutable,\n+                                                           });\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::Deref {\n+                                arg: Expr {\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }.to_ref(),\n+                            },\n+                        }\n                     }\n-                }\n-                ty::ClosureKind::FnOnce => {\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::SelfRef,\n+                    ty::ClosureKind::FnOnce => {\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::SelfRef,\n+                        }\n                     }\n                 }\n+            } else {\n+                Expr {\n+                    ty: closure_ty,\n+                    temp_lifetime,\n+                    span: expr.span,\n+                    kind: ExprKind::SelfRef,\n+                }\n             };\n \n             // at this point we have `self.n`, which loads up the upvar"}, {"sha": "46df40e42871db1f5f6f47623e6612832d71922c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -61,6 +61,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n+            MirSource::GeneratorDrop(..) => hir::Constness::NotConst,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.hir.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())"}, {"sha": "9bd5df16a14e9ff31f88cc38f844f6d5c3cd157d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n+use rustc::ty::{self, AdtDef, ClosureSubsts, Region, Ty, GeneratorInterior};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -238,6 +238,7 @@ pub enum ExprKind<'tcx> {\n         closure_id: DefId,\n         substs: ClosureSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n+        interior: Option<GeneratorInterior<'tcx>>,\n     },\n     Literal {\n         literal: Literal<'tcx>,\n@@ -247,6 +248,9 @@ pub enum ExprKind<'tcx> {\n         outputs: Vec<ExprRef<'tcx>>,\n         inputs: Vec<ExprRef<'tcx>>\n     },\n+    Yield {\n+        value: ExprRef<'tcx>,\n+    },\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "1e0858d686451a36a3f29adac7985006bee724b6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -140,6 +140,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     LocalDecl {\n         mutability, ty, name: None,\n         source_info: SourceInfo { scope: ARGUMENT_VISIBILITY_SCOPE, span },\n+        internal: false,\n         is_user_variable: false\n     }\n }\n@@ -160,6 +161,12 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n+    // Check if this is a generator, if so, return the drop glue for it\n+    if let Some(&ty::TyS { sty: ty::TyGenerator(gen_def_id, substs, _), .. }) = ty {\n+        let mir = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n+        return mir.subst(tcx, substs.substs);\n+    }\n+\n     let substs = if let Some(ty) = ty {\n         tcx.mk_substs(iter::once(Kind::from(ty)))\n     } else {\n@@ -190,6 +197,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n         vec![],\n@@ -225,10 +233,10 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-    patch: MirPatch<'tcx>,\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub mir: &'a Mir<'tcx>,\n+    pub patch: MirPatch<'tcx>,\n+    pub tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> fmt::Debug for DropShimElaborator<'a, 'tcx> {\n@@ -327,6 +335,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ),\n             IndexVec::new(),\n             self.sig.output(),\n+            None,\n             self.local_decls,\n             self.sig.inputs().len(),\n             vec![],\n@@ -770,6 +779,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls,\n         sig.inputs().len(),\n         vec![],\n@@ -841,6 +851,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls,\n         sig.inputs().len(),\n         vec![],"}, {"sha": "186c465f6010585dfba38137541f1df31ceebf7b", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -60,6 +60,7 @@ impl MirPass for CopyPropagation {\n                     return\n                 }\n             }\n+            MirSource::GeneratorDrop(_) => (),\n         }\n \n         // We only run when the MIR optimization level is > 1."}, {"sha": "417083c4ff8011645b693ce8d4de965cd99761f8", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -96,42 +96,42 @@ fn find_dead_unwinds<'a, 'tcx>(\n                            MaybeInitializedLvals::new(tcx, mir, &env),\n                            |bd, p| &bd.move_data().move_paths[p]);\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-        match bb_data.terminator().kind {\n+        let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. } |\n-            TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => {\n-                let mut init_data = InitializationData {\n-                    live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n-                    dead: IdxSetBuf::new_empty(env.move_data.move_paths.len()),\n-                };\n-                debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n-                       bb, bb_data, init_data.live);\n-                for stmt in 0..bb_data.statements.len() {\n-                    let loc = Location { block: bb, statement_index: stmt };\n-                    init_data.apply_location(tcx, mir, env, loc);\n-                }\n+            TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => location,\n+            _ => continue,\n+        };\n \n-                let path = match env.move_data.rev_lookup.find(location) {\n-                    LookupResult::Exact(e) => e,\n-                    LookupResult::Parent(..) => {\n-                        debug!(\"find_dead_unwinds: has parent; skipping\");\n-                        continue\n-                    }\n-                };\n+        let mut init_data = InitializationData {\n+            live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n+            dead: IdxSetBuf::new_empty(env.move_data.move_paths.len()),\n+        };\n+        debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n+               bb, bb_data, init_data.live);\n+        for stmt in 0..bb_data.statements.len() {\n+            let loc = Location { block: bb, statement_index: stmt };\n+            init_data.apply_location(tcx, mir, env, loc);\n+        }\n+\n+        let path = match env.move_data.rev_lookup.find(location) {\n+            LookupResult::Exact(e) => e,\n+            LookupResult::Parent(..) => {\n+                debug!(\"find_dead_unwinds: has parent; skipping\");\n+                continue\n+            }\n+        };\n \n-                debug!(\"find_dead_unwinds @ {:?}: path({:?})={:?}\", bb, location, path);\n+        debug!(\"find_dead_unwinds @ {:?}: path({:?})={:?}\", bb, location, path);\n \n-                let mut maybe_live = false;\n-                on_all_drop_children_bits(tcx, mir, &env, path, |child| {\n-                    let (child_maybe_live, _) = init_data.state(child);\n-                    maybe_live |= child_maybe_live;\n-                });\n+        let mut maybe_live = false;\n+        on_all_drop_children_bits(tcx, mir, &env, path, |child| {\n+            let (child_maybe_live, _) = init_data.state(child);\n+            maybe_live |= child_maybe_live;\n+        });\n \n-                debug!(\"find_dead_unwinds @ {:?}: maybe_live={}\", bb, maybe_live);\n-                if !maybe_live {\n-                    dead_unwinds.add(&bb);\n-                }\n-            }\n-            _ => {}\n+        debug!(\"find_dead_unwinds @ {:?}: maybe_live={}\", bb, maybe_live);\n+        if !maybe_live {\n+            dead_unwinds.add(&bb);\n         }\n     }\n \n@@ -314,7 +314,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let patch = &mut self.patch;\n         debug!(\"create_drop_flag({:?})\", self.mir.span);\n         self.drop_flags.entry(index).or_insert_with(|| {\n-            patch.new_temp(tcx.types.bool, span)\n+            patch.new_internal(tcx.types.bool, span)\n         });\n     }\n "}, {"sha": "9bc572c66b6f87c17897250617fe518f3d671720", "filename": "src/librustc_mir/transform/generator.rs", "status": "added", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,786 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is the implementation of the pass which transforms generators into state machines.\n+//!\n+//! MIR generation for generators creates a function which has a self argument which\n+//! passes by value. This argument is effectively a generator type which only contains upvars and\n+//! is only used for this argument inside the MIR for the generator.\n+//! It is passed by value to enable upvars to be moved out of it. Drop elaboration runs on that\n+//! MIR before this pass and creates drop flags for MIR locals.\n+//! It will also drop the generator argument (which only consists of upvars) if any of the upvars\n+//! are moved out of. This pass elaborates the drops of upvars / generator argument in the case\n+//! that none of the upvars were moved out of. This is because we cannot have any drops of this\n+//! generator in the MIR, since it is used to create the drop glue for the generator. We'd get\n+//! infinite recursion otherwise.\n+//!\n+//! This pass creates the implementation for the Generator::resume function and the drop shim\n+//! for the generator based on the MIR input. It converts the generator argument from Self to\n+//! &mut Self adding derefs in the MIR as needed. It computes the final layout of the generator\n+//! struct which looks like this:\n+//!     First upvars are stored\n+//!     It is followed by the generator state field.\n+//!     Then finally the MIR locals which are live across a suspension point are stored.\n+//!\n+//!     struct Generator {\n+//!         upvars...,\n+//!         state: u32,\n+//!         mir_locals...,\n+//!     }\n+//!\n+//! This pass computes the meaning of the state field and the MIR locals which are live\n+//! across a suspension point. There are however two hardcoded generator states:\n+//!     0 - Generator have not been resumed yet\n+//!     1 - Generator has been poisoned\n+//!\n+//! It also rewrites `return x` and `yield y` as setting a new generator state and returning\n+//! GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n+//! MIR locals which are live across a suspension point are moved to the generator struct\n+//! with references to them being updated with references to the generator struct.\n+//!\n+//! The pass creates two functions which have a switch on the generator state giving\n+//! the action to take.\n+//!\n+//! One of them is the implementation of Generator::resume.\n+//! For generators which have already returned it panics.\n+//! For generators with state 0 (unresumed) it starts the execution of the generator.\n+//! For generators with state 1 (poisoned) it panics.\n+//! Otherwise it continues the execution from the last suspension point.\n+//!\n+//! The other function is the drop glue for the generator.\n+//! For generators which have already returned it does nothing.\n+//! For generators with state 0 (unresumed) it drops the upvars of the generator.\n+//! For generators with state 1 (poisoned) it does nothing.\n+//! Otherwise it drops all the values in scope at the last suspension point.\n+\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::*;\n+use rustc::mir::transform::{MirPass, MirSource};\n+use rustc::mir::visit::{LvalueContext, MutVisitor};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n+use rustc::ty::subst::{Kind, Substs};\n+use util::dump_mir;\n+use util::liveness;\n+use rustc_const_math::ConstInt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::HashMap;\n+use std::borrow::Cow;\n+use std::iter::once;\n+use std::mem;\n+use transform::simplify;\n+use transform::no_landing_pads::no_landing_pads;\n+\n+pub struct StateTransform;\n+\n+struct RenameLocalVisitor {\n+    from: Local,\n+    to: Local,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n+    fn visit_local(&mut self,\n+                        local: &mut Local) {\n+        if *local == self.from {\n+            *local = self.to;\n+        }\n+    }\n+}\n+\n+struct DerefArgVisitor;\n+\n+impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if *lvalue == Lvalue::Local(self_arg()) {\n+            *lvalue = Lvalue::Projection(Box::new(Projection {\n+                base: lvalue.clone(),\n+                elem: ProjectionElem::Deref,\n+            }));\n+        } else {\n+            self.super_lvalue(lvalue, context, location);\n+        }\n+    }\n+}\n+\n+fn self_arg() -> Local {\n+    Local::new(1)\n+}\n+\n+struct TransformVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    state_adt_ref: &'tcx AdtDef,\n+    state_substs: &'tcx Substs<'tcx>,\n+\n+    // The index of the generator state in the generator struct\n+    state_field: usize,\n+\n+    // Mapping from Local to (type of local, generator struct index)\n+    remap: HashMap<Local, (Ty<'tcx>, usize)>,\n+\n+    // The number of generator states. 0 is unresumed, 1 is poisoned. So this is initialized to 2\n+    bb_target_count: u32,\n+\n+    // Map from a (which block to resume execution at, which block to use to drop the generator)\n+    // to a generator state\n+    bb_targets: HashMap<(BasicBlock, Option<BasicBlock>), u32>,\n+\n+    // The original RETURN_POINTER local\n+    new_ret_local: Local,\n+\n+    // The block to resume execution when for Return\n+    return_block: BasicBlock,\n+}\n+\n+impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+    // Make a GeneratorState rvalue\n+    fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n+        let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n+        Rvalue::Aggregate(box adt, vec![val])\n+    }\n+\n+    // Create a Lvalue referencing a generator struct field\n+    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n+        let base = Lvalue::Local(self_arg());\n+        let field = Projection {\n+            base: base,\n+            elem: ProjectionElem::Field(Field::new(idx), ty),\n+        };\n+        Lvalue::Projection(Box::new(field))\n+    }\n+\n+    // Create a statement which changes the generator state\n+    fn set_state(&self, state_disc: u32, source_info: SourceInfo) -> Statement<'tcx> {\n+        let state = self.make_field(self.state_field, self.tcx.types.u32);\n+        let val = Operand::Constant(box Constant {\n+            span: source_info.span,\n+            ty: self.tcx.types.u32,\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::U32(state_disc)),\n+            },\n+        });\n+        Statement {\n+            source_info,\n+            kind: StatementKind::Assign(state, Rvalue::Use(val)),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Lvalue::Local(l) = *lvalue {\n+            // Replace an Local in the remap with a generator struct access\n+            if let Some(&(ty, idx)) = self.remap.get(&l) {\n+                *lvalue = self.make_field(idx, ty);\n+            }\n+        } else {\n+            self.super_lvalue(lvalue, context, location);\n+        }\n+    }\n+\n+    fn visit_basic_block_data(&mut self,\n+                              block: BasicBlock,\n+                              data: &mut BasicBlockData<'tcx>) {\n+        // Remove StorageLive and StorageDead statements for remapped locals\n+        data.retain_statements(|s| {\n+            match s.kind {\n+                StatementKind::StorageLive(ref l) | StatementKind::StorageDead(ref l) => {\n+                    if let Lvalue::Local(l) = *l {\n+                        !self.remap.contains_key(&l)\n+                    } else {\n+                        true\n+                    }\n+                }\n+                _ => true\n+            }\n+        });\n+\n+        let ret_val = match data.terminator().kind {\n+            TerminatorKind::Return => Some((1,\n+                self.return_block,\n+                Operand::Consume(Lvalue::Local(self.new_ret_local)),\n+                None)),\n+            TerminatorKind::Yield { ref value, resume, drop } => Some((0,\n+                resume,\n+                value.clone(),\n+                drop)),\n+            _ => None\n+        };\n+\n+        if let Some((state_idx, resume, v, drop)) = ret_val {\n+            let bb_idx = {\n+                let bb_targets = &mut self.bb_targets;\n+                let bb_target = &mut self.bb_target_count;\n+                *bb_targets.entry((resume, drop)).or_insert_with(|| {\n+                    let target = *bb_target;\n+                    *bb_target = target.checked_add(1).unwrap();\n+                    target\n+                })\n+            };\n+            let source_info = data.terminator().source_info;\n+            data.statements.push(self.set_state(bb_idx, source_info));\n+            data.statements.push(Statement {\n+                source_info,\n+                kind: StatementKind::Assign(Lvalue::Local(RETURN_POINTER),\n+                    self.make_state(state_idx, v)),\n+            });\n+            data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n+        }\n+\n+        self.super_basic_block_data(block, data);\n+    }\n+}\n+\n+fn make_generator_state_argument_indirect<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                def_id: DefId,\n+                mir: &mut Mir<'tcx>) {\n+    let gen_ty = mir.local_decls.raw[1].ty;\n+\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: def_id,\n+        bound_region: ty::BoundRegion::BrEnv,\n+    });\n+\n+    let region = tcx.mk_region(region);\n+\n+    let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty: gen_ty,\n+        mutbl: hir::MutMutable\n+    });\n+\n+    // Replace the by value generator argument\n+    mir.local_decls.raw[1].ty = ref_gen_ty;\n+\n+    // Add a deref to accesses of the generator state\n+    DerefArgVisitor.visit_mir(mir);\n+}\n+\n+fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n+                            mir: &mut Mir<'tcx>) -> Local {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let new_ret = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: ret_ty,\n+        name: None,\n+        source_info,\n+        internal: false,\n+        is_user_variable: false,\n+    };\n+    let new_ret_local = Local::new(mir.local_decls.len());\n+    mir.local_decls.push(new_ret);\n+    mir.local_decls.swap(0, new_ret_local.index());\n+\n+    RenameLocalVisitor {\n+        from: RETURN_POINTER,\n+        to: new_ret_local,\n+    }.visit_mir(mir);\n+\n+    new_ret_local\n+}\n+\n+fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               mir: &Mir<'tcx>,\n+                                               source: MirSource) -> liveness::LocalSet {\n+    let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n+    let result = liveness::liveness_of_locals(mir);\n+    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &result);\n+\n+    for (block, data) in mir.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::Yield { .. } = data.terminator().kind {\n+            set.union(&result.outs[block]);\n+        }\n+    }\n+\n+    // The generator argument is ignored\n+    set.remove(&self_arg());\n+\n+    set\n+}\n+\n+fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            source: MirSource,\n+                            interior: GeneratorInterior<'tcx>,\n+                            mir: &mut Mir<'tcx>)\n+    -> (HashMap<Local, (Ty<'tcx>, usize)>, GeneratorLayout<'tcx>)\n+{\n+    // Use a liveness analysis to compute locals which are live across a suspension point\n+    let live_locals = locals_live_across_suspend_points(tcx, mir, source);\n+\n+    // Erase regions from the types passed in from typeck so we can compare them with\n+    // MIR types\n+    let allowed = tcx.erase_regions(&interior.as_slice());\n+\n+    for (local, decl) in mir.local_decls.iter_enumerated() {\n+        // Ignore locals which are internal or not live\n+        if !live_locals.contains(&local) || decl.internal {\n+            continue;\n+        }\n+\n+        // Sanity check that typeck knows about the type of locals which are\n+        // live across a suspension point\n+        if !allowed.contains(&decl.ty) {\n+            span_bug!(mir.span,\n+                      \"Broken MIR: generator contains type {} in MIR, \\\n+                       but typeck only knows about {}\",\n+                      decl.ty,\n+                      interior);\n+        }\n+    }\n+\n+    let upvar_len = mir.upvar_decls.len();\n+    let dummy_local = LocalDecl::new_internal(tcx.mk_nil(), mir.span);\n+\n+    // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n+    // to avoid changing local indices\n+    let live_decls = live_locals.iter().map(|local| {\n+        let var = mem::replace(&mut mir.local_decls[local], dummy_local.clone());\n+        (local, var)\n+    });\n+\n+    // Create a map from local indices to generator struct indices.\n+    // These are offset by (upvar_len + 1) because of fields which comes before locals.\n+    // We also create a vector of the LocalDecls of these locals.\n+    let (remap, vars) = live_decls.enumerate().map(|(idx, (local, var))| {\n+        ((local, (var.ty, upvar_len + 1 + idx)), var)\n+    }).unzip();\n+\n+    let layout = GeneratorLayout {\n+        fields: vars\n+    };\n+\n+    (remap, layout)\n+}\n+\n+fn insert_entry_point<'tcx>(mir: &mut Mir<'tcx>,\n+                            block: BasicBlockData<'tcx>) {\n+    mir.basic_blocks_mut().raw.insert(0, block);\n+\n+    let blocks = mir.basic_blocks_mut().iter_mut();\n+\n+    for target in blocks.flat_map(|b| b.terminator_mut().successors_mut()) {\n+        *target = BasicBlock::new(target.index() + 1);\n+    }\n+}\n+\n+fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       def_id: DefId,\n+                                       mir: &mut Mir<'tcx>) {\n+    use util::elaborate_drops::{elaborate_drop, Unwind};\n+    use util::patch::MirPatch;\n+    use shim::DropShimElaborator;\n+\n+    // Note that `elaborate_drops` only drops the upvars of a generator, and\n+    // this is ok because `open_drop` can only be reached within that own\n+    // generator's resume function.\n+\n+    let param_env = tcx.param_env(def_id);\n+    let gen = self_arg();\n+\n+    for block in mir.basic_blocks().indices() {\n+        let (target, unwind, source_info) = match mir.basic_blocks()[block].terminator() {\n+            &Terminator {\n+                source_info,\n+                kind: TerminatorKind::Drop {\n+                    location: Lvalue::Local(local),\n+                    target,\n+                    unwind\n+                }\n+            } if local == gen => (target, unwind, source_info),\n+            _ => continue,\n+        };\n+        let unwind = if let Some(unwind) = unwind {\n+            Unwind::To(unwind)\n+        } else {\n+            Unwind::InCleanup\n+        };\n+        let patch = {\n+            let mut elaborator = DropShimElaborator {\n+                mir: &mir,\n+                patch: MirPatch::new(mir),\n+                tcx,\n+                param_env\n+            };\n+            elaborate_drop(\n+                &mut elaborator,\n+                source_info,\n+                &Lvalue::Local(gen),\n+                (),\n+                target,\n+                unwind,\n+                block\n+            );\n+            elaborator.patch\n+        };\n+        patch.apply(mir);\n+    }\n+}\n+\n+fn create_generator_drop_shim<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                transform: &TransformVisitor<'a, 'tcx>,\n+                def_id: DefId,\n+                source: MirSource,\n+                gen_ty: Ty<'tcx>,\n+                mir: &Mir<'tcx>,\n+                drop_clean: BasicBlock) -> Mir<'tcx> {\n+    let mut mir = mir.clone();\n+\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let return_block = BasicBlock::new(mir.basic_blocks().len());\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    let mut cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(_, u), &s)| {\n+        u.map(|d| (s, d))\n+    }).collect();\n+\n+    cases.insert(0, (0, drop_clean));\n+\n+    // The poisoned state 1 falls through to the default case which is just to return\n+\n+    let switch = TerminatorKind::SwitchInt {\n+        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        switch_ty: tcx.types.u32,\n+        values: Cow::from(cases.iter().map(|&(i, _)| {\n+                ConstInt::U32(i)\n+            }).collect::<Vec<_>>()),\n+        targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n+    };\n+\n+    insert_entry_point(&mut mir, BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: switch,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    for block in mir.basic_blocks_mut() {\n+        let kind = &mut block.terminator_mut().kind;\n+        if let TerminatorKind::GeneratorDrop = *kind {\n+            *kind = TerminatorKind::Return;\n+        }\n+    }\n+\n+    // Replace the return variable\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    mir.return_ty = tcx.mk_nil();\n+    mir.local_decls[RETURN_POINTER] = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: tcx.mk_nil(),\n+        name: None,\n+        source_info,\n+        internal: false,\n+        is_user_variable: false,\n+    };\n+\n+    make_generator_state_argument_indirect(tcx, def_id, &mut mir);\n+\n+    // Change the generator argument from &mut to *mut\n+    mir.local_decls[self_arg()] = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: tcx.mk_ptr(ty::TypeAndMut {\n+            ty: gen_ty,\n+            mutbl: hir::Mutability::MutMutable,\n+        }),\n+        name: None,\n+        source_info,\n+        internal: false,\n+        is_user_variable: false,\n+    };\n+\n+    no_landing_pads(tcx, &mut mir);\n+\n+    // Make sure we remove dead blocks to remove\n+    // unrelated code from the resume part of the function\n+    simplify::remove_dead_blocks(&mut mir);\n+\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir);\n+\n+    mir\n+}\n+\n+fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        mir: &mut Mir<'tcx>) {\n+    let assert_block = BasicBlock::new(mir.basic_blocks().len());\n+    let term = TerminatorKind::Assert {\n+        cond: Operand::Constant(box Constant {\n+            span: mir.span,\n+            ty: tcx.types.bool,\n+            literal: Literal::Value {\n+                value: ConstVal::Bool(false),\n+            },\n+        }),\n+        expected: true,\n+        msg: AssertMessage::GeneratorResumedAfterReturn,\n+        target: assert_block,\n+        cleanup: None,\n+    };\n+\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+}\n+\n+fn create_generator_resume_function<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mut transform: TransformVisitor<'a, 'tcx>,\n+        def_id: DefId,\n+        source: MirSource,\n+        mir: &mut Mir<'tcx>) {\n+    // Poison the generator when it unwinds\n+    for block in mir.basic_blocks_mut() {\n+        let source_info = block.terminator().source_info;\n+        if let &TerminatorKind::Resume = &block.terminator().kind {\n+            block.statements.push(transform.set_state(1, source_info));\n+        }\n+    }\n+\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let poisoned_block = BasicBlock::new(mir.basic_blocks().len());\n+\n+    let term = TerminatorKind::Assert {\n+        cond: Operand::Constant(box Constant {\n+            span: mir.span,\n+            ty: tcx.types.bool,\n+            literal: Literal::Value {\n+                value: ConstVal::Bool(false),\n+            },\n+        }),\n+        expected: true,\n+        msg: AssertMessage::GeneratorResumedAfterPanic,\n+        target: transform.return_block,\n+        cleanup: None,\n+    };\n+\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    transform.bb_targets.insert((poisoned_block, None), 1);\n+\n+    let switch = TerminatorKind::SwitchInt {\n+        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        switch_ty: tcx.types.u32,\n+        values: Cow::from(transform.bb_targets.values().map(|&i| {\n+                ConstInt::U32(i)\n+            }).collect::<Vec<_>>()),\n+        targets: transform.bb_targets.keys()\n+            .map(|&(k, _)| k)\n+            .chain(once(transform.return_block))\n+            .collect(),\n+    };\n+\n+    insert_entry_point(mir, BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: switch,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    make_generator_state_argument_indirect(tcx, def_id, mir);\n+\n+    no_landing_pads(tcx, mir);\n+\n+    // Make sure we remove dead blocks to remove\n+    // unrelated code from the drop part of the function\n+    simplify::remove_dead_blocks(mir);\n+\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n+}\n+\n+fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let return_block = BasicBlock::new(mir.basic_blocks().len());\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n+    let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n+    let term = TerminatorKind::Drop {\n+        location: Lvalue::Local(self_arg()),\n+        target: return_block,\n+        unwind: None,\n+    };\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    drop_clean\n+}\n+\n+impl MirPass for StateTransform {\n+    fn run_pass<'a, 'tcx>(&self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    source: MirSource,\n+                    mir: &mut Mir<'tcx>) {\n+        let yield_ty = if let Some(yield_ty) = mir.yield_ty {\n+            yield_ty\n+        } else {\n+            // This only applies to generators\n+            return\n+        };\n+\n+        assert!(mir.generator_drop.is_none());\n+\n+        let node_id = source.item_id();\n+        let def_id = tcx.hir.local_def_id(source.item_id());\n+        let hir_id = tcx.hir.node_to_hir_id(node_id);\n+\n+        // Get the interior types which typeck computed\n+        let interior = *tcx.typeck_tables_of(def_id).generator_interiors().get(hir_id).unwrap();\n+\n+        // The first argument is the generator type passed by value\n+        let gen_ty = mir.local_decls.raw[1].ty;\n+\n+        // Compute GeneratorState<yield_ty, return_ty>\n+        let state_did = tcx.lang_items.gen_state().unwrap();\n+        let state_adt_ref = tcx.adt_def(state_did);\n+        let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n+            Kind::from(mir.return_ty)].iter());\n+        let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+        // We rename RETURN_POINTER which has type mir.return_ty to new_ret_local\n+        // RETURN_POINTER then is a fresh unused local with type ret_ty.\n+        let new_ret_local = replace_result_variable(ret_ty, mir);\n+\n+        // Extract locals which are live across suspension point into `layout`\n+        // `remap` gives a mapping from local indices onto generator struct indices\n+        let (remap, layout) = compute_layout(tcx, source, interior, mir);\n+\n+        let state_field = mir.upvar_decls.len();\n+\n+        let mut bb_targets = HashMap::new();\n+\n+        // If we jump to the entry point, we should go to the initial 0 generator state.\n+        // FIXME: Could this result in the need for destruction for state 0?\n+        bb_targets.insert((BasicBlock::new(0), None), 0);\n+\n+        // Run the transformation which converts Lvalues from Local to generator struct\n+        // accesses for locals in `remap`.\n+        // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n+        // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n+        let mut transform = TransformVisitor {\n+            tcx,\n+            state_adt_ref,\n+            state_substs,\n+            remap,\n+            bb_target_count: 2,\n+            bb_targets,\n+            new_ret_local,\n+            state_field,\n+\n+            // For returns we will resume execution at the next added basic block.\n+            // This happens in `insert_panic_on_resume_after_return`\n+            return_block: BasicBlock::new(mir.basic_blocks().len()),\n+        };\n+        transform.visit_mir(mir);\n+\n+        // Update our MIR struct to reflect the changed we've made\n+        mir.return_ty = ret_ty;\n+        mir.yield_ty = None;\n+        mir.arg_count = 1;\n+        mir.spread_arg = None;\n+        mir.generator_layout = Some(layout);\n+\n+        // Panic if we resumed after returning\n+        insert_panic_on_resume_after_return(tcx, mir);\n+\n+        // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n+        // the unresumed (0) state.\n+        // This is expanded to a drop ladder in `elaborate_generator_drops`.\n+        let drop_clean = insert_clean_drop(mir);\n+\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n+\n+        // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n+        // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n+        // However we need to also elaborate the code generated by `insert_clean_drop`.\n+        elaborate_generator_drops(tcx, def_id, mir);\n+\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n+\n+        // Create a copy of our MIR and use it to create the drop shim for the generator\n+        let drop_shim = create_generator_drop_shim(tcx,\n+            &transform,\n+            def_id,\n+            source,\n+            gen_ty,\n+            &mir,\n+            drop_clean);\n+\n+        mir.generator_drop = Some(box drop_shim);\n+\n+        // Create the Generator::resume function\n+        create_generator_resume_function(tcx, transform, def_id, source, mir);\n+    }\n+}"}, {"sha": "124a1ef946e2bf85f9b876f9831ea7deb0718b01", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -180,6 +180,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n+        // Cannot inline generators which haven't been transformed yet\n+        if callee_mir.yield_ty.is_some() {\n+            return false;\n+        }\n \n         let attrs = tcx.get_attrs(callsite.callee);\n         let hint = attr::find_inline_attr(None, &attrs[..]);\n@@ -657,6 +661,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, loc);\n \n         match *kind {\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Yield { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target} => {\n                 *target = self.update_target(*target);\n             }"}, {"sha": "e0f2a40ab073276544aa3f3db2e22a3cb9ac6d8a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -40,6 +40,7 @@ pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n+pub mod generator;\n pub mod inline;\n pub mod nll;\n "}, {"sha": "fa6bb644871dced4e11184f0bfa68d6f9eac738c", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -43,6 +43,8 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n             TerminatorKind::Unreachable |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Yield { .. } |\n             TerminatorKind::SwitchInt { .. } => {\n                 /* nothing to do */\n             },"}, {"sha": "3e136fb9e9c49fc2a9c8f0c0c0394208b0d7c76b", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -392,6 +392,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 }).into_iter().collect(),\n                 IndexVec::new(),\n                 ty,\n+                None,\n                 initial_locals,\n                 0,\n                 vec![],"}, {"sha": "9126949156cf3be73c8c2f71bd4d87e3d90069c4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -375,6 +375,8 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |\n                 TerminatorKind::Resume |\n+                TerminatorKind::GeneratorDrop |\n+                TerminatorKind::Yield { .. } |\n                 TerminatorKind::Unreachable => None,\n \n                 TerminatorKind::Return => {\n@@ -978,6 +980,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::GeneratorDrop(_) |\n             MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };"}, {"sha": "59cf5903aa9a0037b0d6399f7223252732a6134f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -34,7 +34,10 @@ fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         mirbug($context.tcx(), $context.last_span,\n-               &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*)))\n+               &format!(\"broken MIR in {:?} ({:?}): {}\",\n+                        $context.body_id,\n+                        $elem,\n+                        format_args!($($message)*)))\n     })\n }\n \n@@ -60,6 +63,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n+    body_id: ast::NodeId,\n     errors_reported: bool\n }\n \n@@ -108,8 +112,9 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n-            cx,\n             mir,\n+            body_id: cx.body_id,\n+            cx,\n             last_span: mir.span,\n             errors_reported: false\n         }\n@@ -297,6 +302,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         })\n                     }\n                 }\n+                ty::TyGenerator(def_id, substs, _) => {\n+                    // Try upvars first. `field_tys` requires final optimized MIR.\n+                    if let Some(ty) = substs.upvar_tys(def_id, tcx).nth(field.index()) {\n+                        return Ok(ty);\n+                    }\n+\n+                    return match substs.field_tys(def_id, tcx).nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: substs.field_tys(def_id, tcx).count() + 1\n+                        })\n+                    }\n+                }\n                 ty::TyTuple(tys, _) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n@@ -428,6 +446,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n+            TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable |\n             TerminatorKind::Drop { .. } => {\n                 // no checks needed for these\n@@ -494,6 +513,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            TerminatorKind::Yield { ref value, .. } => {\n+                let value_ty = value.ty(mir, tcx);\n+                match mir.yield_ty {\n+                    None => span_mirbug!(self, term, \"yield in non-generator\"),\n+                    Some(ty) => {\n+                        if let Err(terr) = self.sub_types(value_ty, ty) {\n+                            span_mirbug!(self,\n+                                term,\n+                                \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n+                                value_ty,\n+                                ty,\n+                                terr);\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -620,6 +655,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_mirbug!(self, block, \"return on cleanup block\")\n                 }\n             }\n+            TerminatorKind::GeneratorDrop { .. } => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block, \"generator_drop in cleanup block\")\n+                }\n+            }\n+            TerminatorKind::Yield { resume, drop, .. } => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block, \"yield in cleanup block\")\n+                }\n+                self.assert_iscleanup(mir, block, resume, is_cleanup);\n+                if let Some(drop) = drop {\n+                    self.assert_iscleanup(mir, block, drop, is_cleanup);\n+                }\n+            }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |"}, {"sha": "41618960337be7a0d0b9ee50c13ecf930f42fc31", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -752,7 +752,14 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.lvalue_ty(self.lvalue);\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) |\n+            // Note that `elaborate_drops` only drops the upvars of a generator,\n+            // and this is ok because `open_drop` here can only be reached\n+            // within that own generator's resume function.\n+            // This should only happen for the self argument on the resume function.\n+            // It effetively only contains upvars until the generator transformation runs.\n+            // See librustc_mir/transform/generator.rs for more details.\n+            ty::TyGenerator(def_id, substs, _) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }"}, {"sha": "fd15c90dc901360ab6c684f2770b014e08bd8062", "filename": "src/librustc_mir/util/liveness.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Liveness analysis which computes liveness of MIR local variables at the boundary of basic blocks\n+//!\n+//! This analysis considers references as being used only at the point of the\n+//! borrow. This means that this does not track uses because of references that\n+//! already exist:\n+//!\n+//! ```Rust\n+//!     fn foo() {\n+//!         x = 0;\n+//!         // `x` is live here\n+//!         GLOBAL = &x: *const u32;\n+//!         // but not here, even while it can be accessed through `GLOBAL`.\n+//!         foo();\n+//!         x = 1;\n+//!         // `x` is live again here, because it is assigned to `OTHER_GLOBAL`\n+//!         OTHER_GLOBAL = &x: *const u32;\n+//!         // ...\n+//!     }\n+//! ```\n+//!\n+//! This means that users of this analysis still have to check whether\n+//! pre-existing references can be used to access the value (e.g. at movable\n+//! generator yield points, all pre-existing references are invalidated, so this\n+//! doesn't matter).\n+\n+use rustc::mir::*;\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n+use util::pretty::{write_basic_block, dump_enabled, write_mir_intro};\n+use rustc::mir::transform::MirSource;\n+use rustc::ty::item_path;\n+use std::path::{PathBuf, Path};\n+use std::fs;\n+use rustc::ty::TyCtxt;\n+use std::io::{self, Write};\n+\n+pub type LocalSet = IdxSetBuf<Local>;\n+\n+#[derive(Eq, PartialEq, Clone)]\n+struct BlockInfo {\n+    defs: LocalSet,\n+    uses: LocalSet,\n+}\n+\n+struct BlockInfoVisitor {\n+    pre_defs: LocalSet,\n+    defs: LocalSet,\n+    uses: LocalSet,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Lvalue::Local(local) = *lvalue {\n+            match context {\n+                LvalueContext::Store |\n+\n+                // We let Call defined the result in both the success and unwind cases.\n+                // This may not be right.\n+                LvalueContext::Call |\n+\n+                // Storage live and storage dead aren't proper defines, but we can ignore\n+                // values that come before them.\n+                LvalueContext::StorageLive |\n+                LvalueContext::StorageDead => {\n+                    self.defs.add(&local);\n+                }\n+                LvalueContext::Projection(..) |\n+\n+                // Borrows only consider their local used at the point of the borrow.\n+                // This won't affect the results since we use this analysis for generators\n+                // and we only care about the result at suspension points. Borrows cannot\n+                // cross suspension points so this behavior is unproblematic.\n+                LvalueContext::Borrow { .. } |\n+\n+                LvalueContext::Inspect |\n+                LvalueContext::Consume |\n+                LvalueContext::Validate |\n+\n+                // We consider drops to always be uses of locals.\n+                // Drop eloboration should be run before this analysis otherwise\n+                // the results might be too pessimistic.\n+                LvalueContext::Drop => {\n+                    // Ignore uses which are already defined in this block\n+                    if !self.pre_defs.contains(&local) {\n+                        self.uses.add(&local);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> BlockInfo {\n+    let mut visitor = BlockInfoVisitor {\n+        pre_defs: LocalSet::new_empty(locals),\n+        defs: LocalSet::new_empty(locals),\n+        uses: LocalSet::new_empty(locals),\n+    };\n+\n+    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n+\n+    for statement in &b.statements {\n+        visitor.visit_statement(BasicBlock::new(0), statement, dummy_location);\n+        visitor.pre_defs.union(&visitor.defs);\n+    }\n+    visitor.visit_terminator(BasicBlock::new(0), b.terminator(), dummy_location);\n+\n+    BlockInfo {\n+        defs: visitor.defs,\n+        uses: visitor.uses,\n+    }\n+}\n+\n+// This gives the result of the liveness analysis at the boundary of basic blocks\n+pub struct LivenessResult {\n+    pub ins: IndexVec<BasicBlock, LocalSet>,\n+    pub outs: IndexVec<BasicBlock, LocalSet>,\n+}\n+\n+pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n+    let locals = mir.local_decls.len();\n+    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n+        block(b, locals)\n+    }).collect();\n+\n+    let copy = |from: &IndexVec<BasicBlock, LocalSet>, to: &mut IndexVec<BasicBlock, LocalSet>| {\n+        for (i, set) in to.iter_enumerated_mut() {\n+            set.clone_from(&from[i]);\n+        }\n+    };\n+\n+    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n+        .indices()\n+        .map(|_| LocalSet::new_empty(locals)).collect();\n+    let mut outs = ins.clone();\n+\n+    let mut ins_ = ins.clone();\n+    let mut outs_ = outs.clone();\n+\n+    loop {\n+        copy(&ins, &mut ins_);\n+        copy(&outs, &mut outs_);\n+\n+        for b in mir.basic_blocks().indices().rev() {\n+            // out = \u222a {ins of successors}\n+            outs[b].clear();\n+            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+                outs[b].union(&ins[successor]);\n+            }\n+\n+            // in = use \u222a (out - def)\n+            ins[b].clone_from(&outs[b]);\n+            ins[b].subtract(&def_use[b].defs);\n+            ins[b].union(&def_use[b].uses);\n+        }\n+\n+        if ins_ == ins && outs_ == outs {\n+            break;\n+        }\n+    }\n+\n+    LivenessResult {\n+        ins,\n+        outs,\n+    }\n+}\n+\n+pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          pass_name: &str,\n+                          source: MirSource,\n+                          mir: &Mir<'tcx>,\n+                          result: &LivenessResult) {\n+    if !dump_enabled(tcx, pass_name, source) {\n+        return;\n+    }\n+    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+        tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n+    });\n+    dump_matched_mir_node(tcx, pass_name, &node_path,\n+                          source, mir, result);\n+}\n+\n+fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   pass_name: &str,\n+                                   node_path: &str,\n+                                   source: MirSource,\n+                                   mir: &Mir<'tcx>,\n+                                   result: &LivenessResult) {\n+    let mut file_path = PathBuf::new();\n+    if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n+        let p = Path::new(file_dir);\n+        file_path.push(p);\n+    };\n+    let file_name = format!(\"rustc.node{}{}-liveness.mir\",\n+                            source.item_id(), pass_name);\n+    file_path.push(&file_name);\n+    let _ = fs::File::create(&file_path).and_then(|mut file| {\n+        writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n+        writeln!(file, \"// pass_name = {}\", pass_name)?;\n+        writeln!(file, \"\")?;\n+        write_mir_fn(tcx, source, mir, &mut file, result)?;\n+        Ok(())\n+    });\n+}\n+\n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              src: MirSource,\n+                              mir: &Mir<'tcx>,\n+                              w: &mut Write,\n+                              result: &LivenessResult)\n+                              -> io::Result<()> {\n+    write_mir_intro(tcx, src, mir, w)?;\n+    for block in mir.basic_blocks().indices() {\n+        let print = |w: &mut Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n+            let live: Vec<String> = mir.local_decls.indices()\n+                .filter(|i| result[block].contains(i))\n+                .map(|i| format!(\"{:?}\", i))\n+                .collect();\n+            writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n+        };\n+        print(w, \"   \", &result.ins)?;\n+        write_basic_block(tcx, block, mir, w)?;\n+        print(w, \"   \", &result.outs)?;\n+        if block.index() + 1 != mir.basic_blocks().len() {\n+            writeln!(w, \"\")?;\n+        }\n+    }\n+\n+    writeln!(w, \"}}\")?;\n+    Ok(())\n+}\n+"}, {"sha": "4b6da96824dcd9ac126247f25713b4e7fbb36205", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -15,6 +15,7 @@ pub mod patch;\n \n mod graphviz;\n mod pretty;\n+pub mod liveness;\n \n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n pub use self::graphviz::{write_mir_graphviz};"}, {"sha": "66607a9e0986f0e6f6b3803dd46eb4a52bdd7c23", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -101,6 +101,13 @@ impl<'tcx> MirPatch<'tcx> {\n         Local::new(index as usize)\n     }\n \n+    pub fn new_internal(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n+        let index = self.next_local;\n+        self.next_local += 1;\n+        self.new_locals.push(LocalDecl::new_internal(ty, span));\n+        Local::new(index as usize)\n+    }\n+\n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n         let block = BasicBlock::new(self.patch_map.len());\n         debug!(\"MirPatch: new_block: {:?}: {:?}\", block, data);"}, {"sha": "0811783a9e57f7b75c211652c2398cc84b346c81", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -94,6 +94,7 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    mir: &Mir<'tcx>) {\n     let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n+        MirSource::GeneratorDrop(_) => format!(\"-drop\"),\n         _ => String::new()\n     };\n \n@@ -120,6 +121,9 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n+        if let Some(ref layout) = mir.generator_layout {\n+            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n+        }\n         writeln!(file, \"\")?;\n         write_mir_fn(tcx, source, mir, &mut file)?;\n         Ok(())\n@@ -176,7 +180,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block(tcx: TyCtxt,\n+pub fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write)\n@@ -274,7 +278,7 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              src: MirSource,\n                              mir: &Mir,\n                              w: &mut Write)\n@@ -322,28 +326,34 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         MirSource::Const(_) => write!(w, \"const\")?,\n         MirSource::Static(_, hir::MutImmutable) => write!(w, \"static\")?,\n         MirSource::Static(_, hir::MutMutable) => write!(w, \"static mut\")?,\n-        MirSource::Promoted(_, i) => write!(w, \"{:?} in\", i)?\n+        MirSource::Promoted(_, i) => write!(w, \"{:?} in\", i)?,\n+        MirSource::GeneratorDrop(_) => write!(w, \"drop_glue\")?,\n     }\n \n     item_path::with_forced_impl_filename_line(|| { // see notes on #41697 elsewhere\n         write!(w, \" {}\", tcx.node_path_str(src.item_id()))\n     })?;\n \n-    if let MirSource::Fn(_) = src {\n-        write!(w, \"(\")?;\n-\n-        // fn argument types.\n-        for (i, arg) in mir.args_iter().enumerate() {\n-            if i != 0 {\n-                write!(w, \", \")?;\n+    match src {\n+        MirSource::Fn(_) | MirSource::GeneratorDrop(_) => {\n+            write!(w, \"(\")?;\n+\n+            // fn argument types.\n+            for (i, arg) in mir.args_iter().enumerate() {\n+                if i != 0 {\n+                    write!(w, \", \")?;\n+                }\n+                write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n             }\n-            write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n-        }\n \n-        write!(w, \") -> {}\", mir.return_ty)\n-    } else {\n-        assert_eq!(mir.arg_count, 0);\n-        write!(w, \": {} =\", mir.return_ty)\n+            write!(w, \") -> {}\", mir.return_ty)\n+        }\n+        MirSource::Const(..) |\n+        MirSource::Static(..) |\n+        MirSource::Promoted(..) => {\n+            assert_eq!(mir.arg_count, 0);\n+            write!(w, \": {} =\", mir.return_ty)\n+        }\n     }\n }\n "}, {"sha": "918be14ce9d6e5c5b45e9cc4987fec36196b1aa4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -435,6 +435,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprAgain(_) |\n         hir::ExprRet(_) |\n \n+        // Generator expressions\n+        hir::ExprYield(_) |\n+\n         // Expressions with side-effects.\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |"}, {"sha": "c23f28fe2205f943d4cfec7fc727d1993141dc13", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprLoop(ref b, _, source) => {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n-            hir::ExprClosure(.., b, _) => {\n+            hir::ExprClosure(.., b, _, _) => {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {"}, {"sha": "3273d66dd4f516ff6f316738de6963b7619d6bc1", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -120,6 +120,8 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             TerminatorKind::DropAndReplace { .. } => \"TerminatorKind::DropAndReplace\",\n             TerminatorKind::Call { .. } => \"TerminatorKind::Call\",\n             TerminatorKind::Assert { .. } => \"TerminatorKind::Assert\",\n+            TerminatorKind::GeneratorDrop => \"TerminatorKind::GeneratorDrop\",\n+            TerminatorKind::Yield { .. } => \"TerminatorKind::Yield\",\n         }, kind);\n         self.super_terminator_kind(block, kind, location);\n     }\n@@ -131,6 +133,12 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match *msg {\n             AssertMessage::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n             AssertMessage::Math(..) => \"AssertMessage::Math\",\n+            AssertMessage::GeneratorResumedAfterReturn => {\n+                \"AssertMessage::GeneratorResumedAfterReturn\"\n+            }\n+            AssertMessage::GeneratorResumedAfterPanic => {\n+                \"AssertMessage::GeneratorResumedAfterPanic\"\n+            }\n         }, msg);\n         self.super_assert_message(msg, location);\n     }\n@@ -158,6 +166,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                     AggregateKind::Tuple => \"AggregateKind::Tuple\",\n                     AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n                     AggregateKind::Closure(..) => \"AggregateKind::Closure\",\n+                    AggregateKind::Generator(..) => \"AggregateKind::Generator\",\n                 }, kind);\n \n                 \"Rvalue::Aggregate\""}, {"sha": "11db23732fba3e2dd5f5ed5abd31d66c95f3f089", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -77,6 +77,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n             if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n             substs.upvar_tys(def_id, cx.tcx()).collect()\n         },\n+        ty::TyGenerator(def_id, substs, _) => {\n+            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n+            substs.field_tys(def_id, cx.tcx()).map(|t| {\n+                cx.tcx().normalize_associated_type(&t)\n+            }).collect()\n+        },\n         _ => bug!(\"{} is not a type that can have fields.\", t)\n     }\n }"}, {"sha": "8b864a7fdcfbbf782c592448fdd8668fb34929cf", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -629,6 +629,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::Unreachable |\n             mir::TerminatorKind::Assert { .. } => {}\n+            mir::TerminatorKind::GeneratorDrop |\n+            mir::TerminatorKind::Yield { .. } => bug!(),\n         }\n \n         self.super_terminator_kind(block, kind, location);"}, {"sha": "261792735dcab86650df299b4329dfad4f5571fc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -28,12 +28,13 @@ use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, LayoutTyper};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n use std::iter;\n \n+use syntax::abi::Abi;\n use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n@@ -91,6 +92,16 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                 }\n             }))\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let mut tys = substs.field_tys(def_id, ccx.tcx());\n+            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n+                if tys.next().is_some() {\n+                    None\n+                } else {\n+                    Some([first_ty, second_ty])\n+                }\n+            }))\n+        }\n         ty::TyTuple(tys, _) => {\n             if tys.len() != 2 {\n                 return None;\n@@ -511,6 +522,28 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 sig.abi\n             ))\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let tcx = ccx.tcx();\n+            let sig = tcx.generator_sig(def_id).unwrap().subst(tcx, substs.substs);\n+\n+            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+            sig.map_bound(|sig| {\n+                let state_did = tcx.lang_items.gen_state().unwrap();\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.mk_substs([Kind::from(sig.yield_ty),\n+                    Kind::from(sig.return_ty)].iter());\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                tcx.mk_fn_sig(iter::once(env_ty),\n+                    ret_ty,\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust\n+                )\n+            })\n+        }\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }\n }"}, {"sha": "bcc6aca6149bd05b7fac3046f848585160038c4e", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -580,6 +580,16 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx()).map(|t| {\n+                cx.tcx().normalize_associated_type(&t)\n+            }).collect();\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   &upvar_tys,\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n+        }\n         ty::TyAdt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n                 prepare_struct_metadata(cx,"}, {"sha": "5dd1c15fd2d6ed88aec2783fd009fcdc512d207f", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -165,6 +165,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyClosure(..) => {\n             output.push_str(\"closure\");\n         }\n+        ty::TyGenerator(..) => {\n+            output.push_str(\"generator\");\n+        }\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |"}, {"sha": "a17ddabb1a7cdade098131471633a1e615b865bd", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -216,8 +216,10 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n                 TerminatorKind::Goto { .. } |\n                 TerminatorKind::Resume |\n                 TerminatorKind::Return |\n+                TerminatorKind::GeneratorDrop |\n                 TerminatorKind::Unreachable |\n-                TerminatorKind::SwitchInt { .. } => {\n+                TerminatorKind::SwitchInt { .. } |\n+                TerminatorKind::Yield { .. }  => {\n                     /* nothing to do */\n                 }\n                 TerminatorKind::Call { cleanup: unwind, .. } |"}, {"sha": "57709b18c3b1c851e515193629bd881fcee6aa9a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -374,6 +374,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                          vec![msg_file_line_col],\n                          Some(ErrKind::Math(err.clone())))\n                     }\n+                    mir::AssertMessage::GeneratorResumedAfterReturn |\n+                    mir::AssertMessage::GeneratorResumedAfterPanic => {\n+                        let str = if let mir::AssertMessage::GeneratorResumedAfterReturn = *msg {\n+                            \"generator resumed after completion\"\n+                        } else {\n+                            \"generator resumed after panicking\"\n+                        };\n+                        let msg_str = Symbol::intern(str).as_str();\n+                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n+                        let msg_file_line = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line],\n+                                                     false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n+                        let msg_file_line = consts::addr_of(bcx.ccx,\n+                                                            msg_file_line,\n+                                                            align,\n+                                                            \"panic_loc\");\n+                        (lang_items::PanicFnLangItem,\n+                         vec![msg_file_line],\n+                         None)\n+                    }\n                 };\n \n                 // If we know we always panic, and the error message\n@@ -557,6 +578,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n                         cleanup);\n             }\n+            mir::TerminatorKind::GeneratorDrop |\n+            mir::TerminatorKind::Yield { .. } => bug!(\"generator ops in trans\"),\n         }\n     }\n "}, {"sha": "65b9fec7eff498d83fc53b6d85f169bdbf21c6c6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -336,6 +336,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             mir::AssertMessage::Math(ref err) => {\n                                 ErrKind::Math(err.clone())\n                             }\n+                            mir::AssertMessage::GeneratorResumedAfterReturn |\n+                            mir::AssertMessage::GeneratorResumedAfterPanic =>\n+                                span_bug!(span, \"{:?} should not appear in constants?\", msg),\n                         };\n \n                         let err = ConstEvalErr { span: span, kind: err };\n@@ -579,6 +582,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     mir::AggregateKind::Adt(..) |\n                     mir::AggregateKind::Closure(..) |\n+                    mir::AggregateKind::Generator(..) |\n                     mir::AggregateKind::Tuple => {\n                         Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n                     }"}, {"sha": "53cecea3d010174c939f8524fafda4799cd8fd1f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -524,15 +524,15 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n \n             // Or is it the closure environment?\n-            let (closure_ty, env_ref) = if let ty::TyRef(_, mt) = arg_ty.sty {\n-                (mt.ty, true)\n-            } else {\n-                (arg_ty, false)\n+            let (closure_ty, env_ref) = match arg_ty.sty {\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (mt.ty, true),\n+                _ => (arg_ty, false)\n             };\n-            let upvar_tys = if let ty::TyClosure(def_id, substs) = closure_ty.sty {\n-                substs.upvar_tys(def_id, tcx)\n-            } else {\n-                bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n+\n+            let upvar_tys = match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) |\n+                ty::TyGenerator(def_id, substs, _) => substs.upvar_tys(def_id, tcx),\n+                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty)\n             };\n \n             // Store the pointer to closure data in an alloca for debuginfo"}, {"sha": "4989ca8cc938c24460eb24aa2415635961858c24", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -125,6 +125,12 @@ fn resolve_associated_item<'a, 'tcx>(\n             let substs = tcx.erase_regions(&substs);\n             ty::Instance::new(def_id, substs)\n         }\n+        traits::VtableGenerator(closure_data) => {\n+            Instance {\n+                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n+                substs: closure_data.substs.substs\n+            }\n+        }\n         traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n             resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,"}, {"sha": "672fa32aa8591466047e0fee1ff8d00cc19db3da", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -504,6 +504,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     self.push_type_name(sig.output(), output);\n                 }\n             },\n+            ty::TyGenerator(def_id, ref closure_substs, _) |\n             ty::TyClosure(def_id, ref closure_substs) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));"}, {"sha": "38c49833e0d75e305521e4a09e42a32ee436ee0a", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -133,6 +133,11 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // fill it in *after* placing it into the type cache.\n           adt::incomplete_type_of(cx, t, \"closure\")\n       }\n+      ty::TyGenerator(..) => {\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache.\n+          adt::incomplete_type_of(cx, t, \"generator\")\n+      }\n \n       ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n       ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n@@ -197,7 +202,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() && !t.is_box() => {\n+        ty::TyAdt(..) | ty::TyClosure(..) | ty::TyGenerator(..) if !t.is_simd() && !t.is_box() => {\n             adt::finish_type_of(cx, t, &mut llty);\n         }\n         _ => ()"}, {"sha": "a768271f3b8254651aa2a3260bfdb66e942a5d16", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -70,22 +70,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference phase (`upvar.rs`).\n         let base_substs = Substs::identity_for_item(self.tcx,\n             self.tcx.closure_base_def_id(expr_def_id));\n-        let closure_type = self.tcx.mk_closure(expr_def_id,\n-            base_substs.extend_to(self.tcx, expr_def_id,\n+        let substs = base_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n                 |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n-            )\n         );\n \n-        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n-\n         let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id,\n                                                             self.param_env,\n                                                             &fn_sig);\n \n-        check_fn(self, self.param_env, fn_sig, decl, expr.id, body);\n+        let interior = check_fn(self, self.param_env, fn_sig, decl, expr.id, body, true).1;\n+\n+        if let Some(interior) = interior {\n+            let closure_substs = ty::ClosureSubsts {\n+                substs: substs,\n+            };\n+            return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n+        }\n+\n+        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n+\n+        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "e9d400c64393b5ac7d60f0bb79137cbbe74cb689", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This calculates the types which has storage which lives across a suspension point in a\n+//! generator from the perspective of typeck. The actual types used at runtime\n+//! is calculated in `rustc_mir::transform::generator` and may be a subset of the\n+//! types computed here.\n+\n+use log;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::{self, Body, Pat, PatKind, Expr};\n+use rustc::middle::region::{RegionMaps, CodeExtent};\n+use rustc::ty::Ty;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+use std::rc::Rc;\n+use super::FnCtxt;\n+use util::nodemap::FxHashMap;\n+\n+struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    cache: FxHashMap<NodeId, Option<Span>>,\n+    types: FxHashMap<Ty<'tcx>, usize>,\n+    region_maps: Rc<RegionMaps>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n+    fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n+        use syntax_pos::DUMMY_SP;\n+\n+        let live_across_yield = scope.map(|s| {\n+            self.fcx.tcx.yield_in_extent(s, &mut self.cache).is_some()\n+        }).unwrap_or(true);\n+\n+        if live_across_yield {\n+            let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n+\n+            if log_enabled!(log::LogLevel::Debug) {\n+                let span = scope.map(|s| s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP));\n+                debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n+                       expr, scope, ty, span);\n+            }\n+\n+            // Map the type to the number of types added before it\n+            let entries = self.types.len();\n+            self.types.entry(&ty).or_insert(entries);\n+        } else {\n+            debug!(\"no type in expr = {:?}, span = {:?}\", expr, expr.map(|e| e.span));\n+        }\n+    }\n+}\n+\n+pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+                                        def_id: DefId,\n+                                        body_id: hir::BodyId,\n+                                        witness: Ty<'tcx>) {\n+    let body = fcx.tcx.hir.body(body_id);\n+    let mut visitor = InteriorVisitor {\n+        fcx,\n+        types: FxHashMap(),\n+        cache: FxHashMap(),\n+        region_maps: fcx.tcx.region_maps(def_id),\n+    };\n+    intravisit::walk_body(&mut visitor, body);\n+\n+    let mut types: Vec<_> = visitor.types.drain().collect();\n+\n+    // Sort types by insertion order\n+    types.sort_by_key(|t| t.1);\n+\n+    // Extract type components\n+    let types: Vec<_> = types.into_iter().map(|t| t.0).collect();\n+\n+    let tuple = fcx.tcx.intern_tup(&types, false);\n+\n+    debug!(\"Types in generator {:?}, span = {:?}\", tuple, body.value.span);\n+\n+    // Unify the tuple with the witness\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(witness, tuple) {\n+        Ok(ok) => fcx.register_infer_ok_obligations(ok),\n+        _ => bug!(),\n+   }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_body(&mut self, _body: &'tcx Body) {\n+        // Closures inside are not considered part of the generator interior\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+        if let PatKind::Binding(..) = pat.node {\n+            let scope = self.region_maps.var_scope(pat.id);\n+            let ty = self.fcx.tables.borrow().pat_ty(pat);\n+            self.record(ty, Some(scope), None);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        let scope = self.region_maps.temporary_scope(expr.id);\n+        let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n+        self.record(ty, scope, Some(expr));\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "5e5a27f2ba13719a7b640fb69d9df737856cbbb7", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -726,6 +726,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             self.assemble_closure_candidates(import_id, trait_def_id, item.clone())?;\n \n+            self.assemble_generator_candidates(import_id, trait_def_id, item.clone())?;\n+\n             self.assemble_projection_candidates(import_id, trait_def_id, item.clone());\n \n             self.assemble_where_clause_candidates(import_id, trait_def_id, item.clone());\n@@ -909,6 +911,48 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    fn assemble_generator_candidates(&mut self,\n+                                   import_id: Option<ast::NodeId>,\n+                                   trait_def_id: DefId,\n+                                   item: ty::AssociatedItem)\n+                                   -> Result<(), MethodError<'tcx>> {\n+        // Check if this is the Generator trait.\n+        let tcx = self.tcx;\n+        if Some(trait_def_id) != tcx.lang_items.gen_trait() {\n+            return Ok(());\n+        }\n+\n+        // Check if there is an generator self-type in the list of receivers.\n+        // If so, add \"synthetic impls\".\n+        let steps = self.steps.clone();\n+        for step in steps.iter() {\n+            match step.self_ty.sty {\n+                ty::TyGenerator(..) => (),\n+                _ => continue,\n+            };\n+\n+            // create some substitutions for the argument/return type;\n+            // for the purposes of our method lookup, we only take\n+            // receiver type into account, so we can just substitute\n+            // fresh types here to use during substitution and subtyping.\n+            let substs = Substs::for_item(self.tcx,\n+                                          trait_def_id,\n+                                          |def, _| self.region_var_for_def(self.span, def),\n+                                          |def, substs| {\n+                if def.index == 0 {\n+                    step.self_ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n+\n+            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+        }\n+\n+        Ok(())\n+    }\n+\n     fn assemble_projection_candidates(&mut self,\n                                       import_id: Option<ast::NodeId>,\n                                       trait_def_id: DefId,"}, {"sha": "3a18eddaad347f69e613638ef228e3193c38096e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 83, "deletions": 25, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -146,6 +146,7 @@ mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n+mod generator_interior;\n mod intrinsic;\n mod op;\n \n@@ -205,6 +206,8 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+\n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n@@ -503,6 +506,8 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,\n \n+    yield_ty: Option<Ty<'tcx>>,\n+\n     ps: RefCell<UnsafetyState>,\n \n     /// Whether the last checked node generates a divergence (e.g.,\n@@ -614,6 +619,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n+            deferred_generator_interiors: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(NodeMap()),\n             implicit_region_bound,\n             body_id,\n@@ -734,11 +740,20 @@ pub fn provide(providers: &mut Providers) {\n         typeck_tables_of,\n         has_typeck_tables,\n         closure_kind,\n+        generator_sig,\n         adt_destructor,\n         ..*providers\n     };\n }\n \n+fn generator_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> Option<ty::PolyGenSig<'tcx>> {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    tcx.typeck_tables_of(def_id).generator_sigs()[hir_id].map(|s| ty::Binder(s))\n+}\n+\n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n@@ -865,7 +880,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   param_env,\n                                                   &fn_sig);\n \n-            check_fn(&inh, param_env, fn_sig, decl, id, body)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, false).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n             let expected_type = tcx.type_of(def_id);\n@@ -887,6 +902,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n+        fcx.resolve_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n \n         if fn_decl.is_some() {\n@@ -986,8 +1002,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n-                            body: &'gcx hir::Body)\n-                            -> FnCtxt<'a, 'gcx, 'tcx>\n+                            body: &'gcx hir::Body,\n+                            can_be_generator: bool)\n+                            -> (FnCtxt<'a, 'gcx, 'tcx>, Option<ty::GeneratorInterior<'tcx>>)\n {\n     let mut fn_sig = fn_sig.clone();\n \n@@ -1010,6 +1027,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fn_sig.abi\n     );\n \n+    let span = body.value.span;\n+\n+    if body.is_generator && can_be_generator {\n+        fcx.yield_ty = Some(fcx.next_ty_var(TypeVariableOrigin::TypeInference(span)));\n+    }\n+\n     GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n \n     // Add formal parameters.\n@@ -1029,6 +1052,24 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n \n     let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n+    let gen_ty = if can_be_generator && body.is_generator {\n+        let gen_sig = ty::GenSig {\n+            yield_ty: fcx.yield_ty.unwrap(),\n+            return_ty: ret_ty,\n+        };\n+        inherited.tables.borrow_mut().generator_sigs_mut().insert(fn_hir_id, Some(gen_sig));\n+\n+        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), witness));\n+        let interior = ty::GeneratorInterior::new(witness);\n+\n+        inherited.tables.borrow_mut().generator_interiors_mut().insert(fn_hir_id, interior);\n+\n+        Some(interior)\n+    } else {\n+        inherited.tables.borrow_mut().generator_sigs_mut().insert(fn_hir_id, None);\n+        None\n+    };\n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n@@ -1060,11 +1101,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n-            TypeVariableOrigin::DivergingFn(body.value.span));\n+            TypeVariableOrigin::DivergingFn(span));\n     }\n-    fcx.demand_suptype(body.value.span, ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n-    fcx\n+    (fcx, gen_ty)\n }\n \n fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1700,6 +1741,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            yield_ty: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n@@ -2089,6 +2131,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn resolve_generator_interiors(&self, def_id: DefId) {\n+        let mut deferred_generator_interiors = self.deferred_generator_interiors.borrow_mut();\n+        for (body_id, witness) in deferred_generator_interiors.drain(..) {\n+            generator_interior::resolve_interior(self, def_id, body_id, witness);\n+        }\n+    }\n+\n     /// Apply \"fallbacks\" to some types\n     /// unconstrained types get replaced with ! or  () (depending on whether\n     /// feature(never_type) is enabled), unconstrained ints with i32, and\n@@ -3114,8 +3163,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if tuple_like {\n             type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n-                               \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n-                               idx.node, expr_t).emit();\n+                \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n+                idx.node, expr_t).emit();\n         } else {\n             self.no_such_field_err(expr.span, idx.node, expr_t).emit();\n         }\n@@ -3193,7 +3242,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let adt_ty_hint =\n             self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n-            .get(0).cloned().unwrap_or(adt_ty);\n+                .get(0).cloned().unwrap_or(adt_ty);\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n@@ -3231,10 +3280,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_happened = true;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                   field.name.span,\n-                                                   E0062,\n-                                                   \"field `{}` specified more than once\",\n-                                                   field.name.node);\n+                                                field.name.span,\n+                                                E0062,\n+                                                \"field `{}` specified more than once\",\n+                                                field.name.node);\n \n                     err.span_label(field.name.span, \"used more than once\");\n \n@@ -3287,10 +3336,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              remaining_fields_names,\n                              truncated_fields_error,\n                              adt_ty)\n-                            .span_label(span, format!(\"missing {}{}\",\n-                                        remaining_fields_names,\n-                                        truncated_fields_error))\n-                            .emit();\n+                .span_label(span, format!(\"missing {}{}\",\n+                                          remaining_fields_names,\n+                                          truncated_fields_error))\n+                .emit();\n         }\n     }\n \n@@ -3725,13 +3774,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Only check this if not in an `if` condition, as the\n                     // mistyped comparison help is more appropriate.\n                     if !self.tcx.expr_is_lval(&lhs) {\n-                        struct_span_err!(\n-                            self.tcx.sess, expr.span, E0070,\n-                            \"invalid left-hand side expression\")\n-                        .span_label(\n-                            expr.span,\n-                            \"left-hand of expression not valid\")\n-                        .emit();\n+                        struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                         \"invalid left-hand side expression\")\n+                            .span_label(expr.span, \"left-hand of expression not valid\")\n+                            .emit();\n                     }\n                 }\n             }\n@@ -3806,7 +3852,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n-          hir::ExprClosure(capture, ref decl, body_id, _) => {\n+          hir::ExprClosure(capture, ref decl, body_id, _, _) => {\n               self.check_expr_closure(expr, capture, &decl, body_id, expected)\n           }\n           hir::ExprBlock(ref body) => {\n@@ -3997,6 +4043,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n               }\n            }\n+          hir::ExprYield(ref value) => {\n+            match self.yield_ty {\n+                Some(ty) => {\n+                    self.check_expr_coercable_to_type(&value, ty);\n+                }\n+                None => {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0627,\n+                                 \"yield statement outside of generator literal\").emit();\n+                }\n+            }\n+            tcx.mk_nil()\n+          }\n         }\n     }\n "}, {"sha": "377908b1ab9d40e2f2059f74f9f09de29b58ff51", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -825,7 +825,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., body_id, _) => {\n+            hir::ExprClosure(.., body_id, _, _) => {\n                 self.check_expr_fn_block(expr, body_id);\n             }\n "}, {"sha": "77e597b30c8ee6031667e29cfc3b7788fe5a9be5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -76,10 +76,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _) => {\n+            hir::ExprClosure(cc, _, body_id, _, is_generator) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure((expr.id, expr.hir_id), expr.span, body, cc);\n+                self.fcx.analyze_closure((expr.id, expr.hir_id),\n+                                         expr.span,\n+                                         body,\n+                                         cc,\n+                                         is_generator);\n             }\n \n             _ => { }\n@@ -94,22 +98,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        (closure_node_id, closure_hir_id): (ast::NodeId, hir::HirId),\n                        span: Span,\n                        body: &hir::Body,\n-                       capture_clause: hir::CaptureClause) {\n+                       capture_clause: hir::CaptureClause,\n+                       gen: bool) {\n         /*!\n          * Analysis starting point.\n          */\n \n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n \n-        let infer_kind = match self.tables\n-                                   .borrow_mut()\n-                                   .closure_kinds_mut()\n-                                   .entry(closure_hir_id) {\n-            Entry::Occupied(_) => false,\n-            Entry::Vacant(entry) => {\n-                debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n-                entry.insert((ty::ClosureKind::Fn, None));\n-                true\n+        let infer_kind = if gen {\n+            false\n+        } else {\n+            match self.tables\n+                      .borrow_mut()\n+                      .closure_kinds_mut()\n+                      .entry(closure_hir_id) {\n+                Entry::Occupied(_) => false,\n+                Entry::Vacant(entry) => {\n+                    debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n+                    entry.insert((ty::ClosureKind::Fn, None));\n+                    true\n+                }\n             }\n         };\n \n@@ -184,7 +193,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Extract the type variables UV0...UVn.\n         let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) => (def_id, substs),\n+            ty::TyClosure(def_id, substs) |\n+            ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,"}, {"sha": "7810d9049e10e87c62ac0b08d4474c86bf0ee63b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -45,6 +45,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n+        wbcx.visit_generator_sigs();\n+        wbcx.visit_generator_interiors();\n \n         let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               DefIdSet());\n@@ -164,7 +166,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n \n-        if let hir::ExprClosure(_, _, body, _) = e.node {\n+        if let hir::ExprClosure(_, _, body, _, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n                 self.visit_node_id(e.span, arg.hir_id);\n@@ -357,6 +359,33 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_generator_interiors(&mut self) {\n+        let common_local_id_root = self.fcx.tables.borrow().local_id_root.unwrap();\n+        for (&id, interior) in self.fcx.tables.borrow().generator_interiors().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            let interior = self.resolve(interior, &hir_id);\n+            self.tables.generator_interiors_mut().insert(hir_id, interior);\n+        }\n+    }\n+\n+    fn visit_generator_sigs(&mut self) {\n+        let common_local_id_root = self.fcx.tables.borrow().local_id_root.unwrap();\n+        for (&id, gen_sig) in self.fcx.tables.borrow().generator_sigs().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            let gen_sig = gen_sig.map(|s| ty::GenSig {\n+                yield_ty: self.resolve(&s.yield_ty, &hir_id),\n+                return_ty: self.resolve(&s.return_ty, &hir_id),\n+            });\n+            self.tables.generator_sigs_mut().insert(hir_id, gen_sig);\n+        }\n+    }\n+\n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);"}, {"sha": "c177623af48fb82eed1552fe4cbf174897e2fe26", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1153,7 +1153,12 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., is_generator), .. }) => {\n+            if is_generator {\n+                let hir_id = tcx.hir.node_to_hir_id(node_id);\n+                return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n+            }\n+\n             tcx.mk_closure(def_id, Substs::for_item(\n                 tcx, def_id,\n                 |def, _| {"}, {"sha": "375099350444261d097ab92df3a24a367dbdd887", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -4721,4 +4721,5 @@ register_diagnostics! {\n     E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n+    E0627, // yield statement outside of generator literal\n }"}, {"sha": "70b989b6ab21c88fba210865f898c563462cfdbb", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -294,6 +294,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyFnDef(..) |\n+            ty::TyGenerator(..) |\n             ty::TyClosure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }"}, {"sha": "662064fd37e17bf6be88097b6ac1e89b6603b51e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1984,7 +1984,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 }).collect())\n             }\n \n-            ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::TyClosure(..) | ty::TyGenerator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::TyInfer(..) => panic!(\"TyInfer\"),\n             ty::TyError => panic!(\"TyError\"),"}, {"sha": "c1c2faaef0b32bae49aff453f18c35844479a51c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1016,6 +1016,9 @@ pub enum ExprKind {\n \n     /// `expr?`\n     Try(P<Expr>),\n+\n+    /// A `yield`, with an optional value to be yielded\n+    Yield(Option<P<Expr>>),\n }\n \n /// The explicit Self type in a \"qualified path\". The actual"}, {"sha": "40e210d02ca7f94f5afd088483b8dec4d6778abd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -366,6 +366,10 @@ declare_features! (\n     // Allows unsized tuple coercion.\n     (active, unsized_tuple_coercion, \"1.20.0\", Some(42877)),\n \n+    // Generators\n+    (active, generators, \"1.21.0\", None),\n+\n+\n     // global allocators and their internals\n     (active, global_allocator, \"1.20.0\", None),\n     (active, allocator_internals, \"1.20.0\", None),\n@@ -1410,6 +1414,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::InPlace(..) => {\n                 gate_feature_post!(&self, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n             }\n+            ast::ExprKind::Yield(..) => {\n+                gate_feature_post!(&self, generators,\n+                                  e.span,\n+                                  \"yield syntax is experimental\");\n+            }\n             ast::ExprKind::Lit(ref lit) => {\n                 if let ast::LitKind::Int(_, ref ty) = lit.node {\n                     match *ty {"}, {"sha": "d9f453a93ad567fd5a155870747837ceb1b6dd8f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1311,6 +1311,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                     attrs: fold_attrs(attrs.into(), folder).into(),\n                 };\n             }\n+            ExprKind::Yield(ex) => ExprKind::Yield(ex.map(|x| folder.fold_expr(x))),\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n             ExprKind::Catch(body) => ExprKind::Catch(folder.fold_block(body)),\n         },"}, {"sha": "d2bf943ec172c3f9fda4656f37ceb07e84ada3f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -2222,6 +2222,14 @@ impl<'a> Parser<'a> {\n                     };\n                     ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span;\n+                } else if self.eat_keyword(keywords::Yield) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Yield(Some(e));\n+                    } else {\n+                        ex = ExprKind::Yield(None);\n+                    }\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression"}, {"sha": "d39f11bc3eef163af0a1e5484332f53802101f41", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -106,6 +106,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n         keywords::True.name(),\n         keywords::Unsafe.name(),\n         keywords::While.name(),\n+        keywords::Yield.name(),\n     ].contains(&ident.name)\n }\n "}, {"sha": "70b0277929bb8b181aa61dde93cbb335234e2595", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -2281,6 +2281,16 @@ impl<'a> State<'a> {\n                 self.print_expr(e)?;\n                 self.pclose()?;\n             },\n+            ast::ExprKind::Yield(ref e) => {\n+                self.s.word(\"yield\")?;\n+                match *e {\n+                    Some(ref expr) => {\n+                        self.s.space()?;\n+                        self.print_expr(&expr)?;\n+                    }\n+                    _ => ()\n+                }\n+            }\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr(e)?;\n                 self.s.word(\"?\")?"}, {"sha": "05077d42a0bedb6886ee60069cc03490f6513c26", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -784,6 +784,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 visitor.visit_expr(&output.expr)\n             }\n         }\n+        ExprKind::Yield(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n         ExprKind::Try(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "3754f92d8cde28abfc3033b8fa89b3076e599af8", "filename": "src/test/compile-fail/feature-gate-generators.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    yield true; //~ ERROR yield syntax is experimental\n+}"}, {"sha": "f6878e64fbf93627c4779fab123eeedd6ee51682", "filename": "src/test/run-pass/generator/auxiliary/xcrate.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait, conservative_impl_trait)]\n+\n+use std::ops::Generator;\n+\n+pub fn foo() -> impl Generator<Yield = (), Return = ()> {\n+    || {\n+        if false {\n+            yield;\n+        }\n+    }\n+}\n+\n+pub fn bar<T: 'static>(t: T) -> Box<Generator<Yield = T, Return = ()>> {\n+    Box::new(|| {\n+        yield t;\n+    })\n+}"}, {"sha": "8329684e1a39b8ad343a49ba97b9dbe39ca59e5a", "filename": "src/test/run-pass/generator/conditional-drop.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct B;\n+\n+impl Drop for B {\n+    fn drop(&mut self) {\n+        A.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+\n+fn test() -> bool { true }\n+fn test2() -> bool { false }\n+\n+fn main() {\n+    t1();\n+    t2();\n+}\n+\n+fn t1() {\n+    let mut a = || {\n+        let b = B;\n+        if test() {\n+            drop(b);\n+        }\n+        yield;\n+    };\n+\n+    let n = A.load(Ordering::SeqCst);\n+    a.resume();\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+    a.resume();\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+}\n+\n+fn t2() {\n+    let mut a = || {\n+        let b = B;\n+        if test2() {\n+            drop(b);\n+        }\n+        yield;\n+    };\n+\n+    let n = A.load(Ordering::SeqCst);\n+    a.resume();\n+    assert_eq!(A.load(Ordering::SeqCst), n);\n+    a.resume();\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+}"}, {"sha": "60a00b4e467569ebac0f00e18a7f86fdc70c3d20", "filename": "src/test/run-pass/generator/control-flow.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+\n+fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n+    where T: Generator<Yield = ()>\n+{\n+    loop {\n+        match t.resume() {\n+            GeneratorState::Yielded(()) => amt = amt.checked_sub(1).unwrap(),\n+            GeneratorState::Complete(ret) => {\n+                assert_eq!(amt, 0);\n+                return ret\n+            }\n+        }\n+    }\n+\n+}\n+\n+fn main() {\n+    finish(1, || yield);\n+    finish(8, || {\n+        for _ in 0..8 {\n+            yield;\n+        }\n+    });\n+    finish(1, || {\n+        if true {\n+            yield;\n+        } else {\n+        }\n+    });\n+    finish(1, || {\n+        if false {\n+        } else {\n+            yield;\n+        }\n+    });\n+    finish(2, || {\n+        if { yield; false } {\n+            yield;\n+            panic!()\n+        }\n+        yield\n+    });\n+}"}, {"sha": "ac42a25899dbbc7a3f2be339e789c518c9f7de1a", "filename": "src/test/run-pass/generator/drop-env.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct B;\n+\n+impl Drop for B {\n+    fn drop(&mut self) {\n+        A.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    t1();\n+    t2();\n+    t3();\n+}\n+\n+fn t1() {\n+    let b = B;\n+    let mut foo = || {\n+        yield;\n+        drop(b);\n+    };\n+\n+    let n = A.load(Ordering::SeqCst);\n+    drop(foo.resume());\n+    assert_eq!(A.load(Ordering::SeqCst), n);\n+    drop(foo);\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+}\n+\n+fn t2() {\n+    let b = B;\n+    let mut foo = || {\n+        yield b;\n+    };\n+\n+    let n = A.load(Ordering::SeqCst);\n+    drop(foo.resume());\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+    drop(foo);\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+}\n+\n+fn t3() {\n+    let b = B;\n+    let foo = || {\n+        yield;\n+        drop(b);\n+    };\n+\n+    let n = A.load(Ordering::SeqCst);\n+    assert_eq!(A.load(Ordering::SeqCst), n);\n+    drop(foo);\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n+}"}, {"sha": "9afe95f9e865cf957031b841b77cb4775a9db06c", "filename": "src/test/run-pass/generator/iterator-count.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait, conservative_impl_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+\n+struct W<T>(T);\n+\n+impl<T: Generator<Return = ()>> Iterator for W<T> {\n+    type Item = T::Yield;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.0.resume() {\n+            GeneratorState::Complete(..) => None,\n+            GeneratorState::Yielded(v) => Some(v),\n+        }\n+    }\n+}\n+\n+fn test() -> impl Generator<Return=(), Yield=u8> {\n+    || {\n+        for i in 1..6 {\n+            yield i\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let end = 11;\n+\n+    let closure_test = |start| {\n+        move || {\n+            for i in start..end {\n+                yield i\n+            }\n+        }\n+    };\n+\n+    assert!(W(test()).chain(W(closure_test(6))).eq(1..11));\n+}"}, {"sha": "53cd3235d9d0ceb51d8b4abaf27751a413364a2c", "filename": "src/test/run-pass/generator/panic-drops.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::panic;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct B;\n+\n+impl Drop for B {\n+    fn drop(&mut self) {\n+        A.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn bool_true() -> bool {\n+    true\n+}\n+\n+fn main() {\n+    let b = B;\n+    let mut foo = || {\n+        if bool_true() {\n+            panic!();\n+        }\n+        drop(b);\n+        yield;\n+    };\n+\n+    assert_eq!(A.load(Ordering::SeqCst), 0);\n+    let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        foo.resume()\n+    }));\n+    assert!(res.is_err());\n+    assert_eq!(A.load(Ordering::SeqCst), 1);\n+\n+    let mut foo = || {\n+        if bool_true() {\n+            panic!();\n+        }\n+        drop(B);\n+        yield;\n+    };\n+\n+    assert_eq!(A.load(Ordering::SeqCst), 1);\n+    let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        foo.resume()\n+    }));\n+    assert!(res.is_err());\n+    assert_eq!(A.load(Ordering::SeqCst), 1);\n+}"}, {"sha": "a583f42b93d8c52c67decee88c7178fd75cb6b7f", "filename": "src/test/run-pass/generator/panic-safe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::panic;\n+\n+fn main() {\n+    let mut foo = || {\n+        if true {\n+            panic!();\n+        }\n+        yield;\n+    };\n+\n+    let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        foo.resume()\n+    }));\n+    assert!(res.is_err());\n+\n+    for _ in 0..10 {\n+        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+            foo.resume()\n+        }));\n+        assert!(res.is_err());\n+    }\n+}"}, {"sha": "b2e2a3e7e9d5b558ebd5534615448e7fb2e373c7", "filename": "src/test/run-pass/generator/resume-after-return.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::panic;\n+\n+fn main() {\n+    let mut foo = || {\n+        if true {\n+            return\n+        }\n+        yield;\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+\n+    match panic::catch_unwind(move || foo.resume()) {\n+        Ok(_) => panic!(\"generator successfully resumed\"),\n+        Err(_) => {}\n+    }\n+}"}, {"sha": "e9bdfbf28ea9ca0128119cdcfb117e92f8ca47c0", "filename": "src/test/run-pass/generator/smoke.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,181 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+// compile-flags: --test\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::thread;\n+\n+#[test]\n+fn simple() {\n+    let mut foo = || {\n+        if false {\n+            yield;\n+        }\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn return_capture() {\n+    let a = String::from(\"foo\");\n+    let mut foo = || {\n+        if false {\n+            yield;\n+        }\n+        a\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn simple_yield() {\n+    let mut foo = || {\n+        yield;\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Yielded(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn yield_capture() {\n+    let b = String::from(\"foo\");\n+    let mut foo = || {\n+        yield b;\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Yielded(ref s) if *s == \"foo\" => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn simple_yield_value() {\n+    let mut foo = || {\n+        yield String::from(\"bar\");\n+        return String::from(\"foo\")\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Yielded(ref s) if *s == \"bar\" => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+    match foo.resume() {\n+        GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn return_after_yield() {\n+    let a = String::from(\"foo\");\n+    let mut foo = || {\n+        yield;\n+        return a\n+    };\n+\n+    match foo.resume() {\n+        GeneratorState::Yielded(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+    match foo.resume() {\n+        GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}\n+\n+#[test]\n+fn send_and_sync() {\n+    assert_send_sync(|| {\n+        yield\n+    });\n+    assert_send_sync(|| {\n+        yield String::from(\"foo\");\n+    });\n+    assert_send_sync(|| {\n+        yield;\n+        return String::from(\"foo\");\n+    });\n+    let a = 3;\n+    assert_send_sync(|| {\n+        yield a;\n+        return\n+    });\n+    let a = 3;\n+    assert_send_sync(move || {\n+        yield a;\n+        return\n+    });\n+    let a = String::from(\"a\");\n+    assert_send_sync(|| {\n+        yield ;\n+        drop(a);\n+        return\n+    });\n+    let a = String::from(\"a\");\n+    assert_send_sync(move || {\n+        yield ;\n+        drop(a);\n+        return\n+    });\n+\n+    fn assert_send_sync<T: Send + Sync>(_: T) {}\n+}\n+\n+#[test]\n+fn send_over_threads() {\n+    let mut foo = || { yield };\n+    thread::spawn(move || {\n+        match foo.resume() {\n+            GeneratorState::Yielded(()) => {}\n+            s => panic!(\"bad state: {:?}\", s),\n+        }\n+        match foo.resume() {\n+            GeneratorState::Complete(()) => {}\n+            s => panic!(\"bad state: {:?}\", s),\n+        }\n+    }).join().unwrap();\n+\n+    let a = String::from(\"a\");\n+    let mut foo = || { yield a };\n+    thread::spawn(move || {\n+        match foo.resume() {\n+            GeneratorState::Yielded(ref s) if *s == \"a\" => {}\n+            s => panic!(\"bad state: {:?}\", s),\n+        }\n+        match foo.resume() {\n+            GeneratorState::Complete(()) => {}\n+            s => panic!(\"bad state: {:?}\", s),\n+        }\n+    }).join().unwrap();\n+}"}, {"sha": "dc7a6fdef9c7e76a4320f3b9b4fd3f4c9fcf647b", "filename": "src/test/run-pass/generator/xcrate.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate.rs\n+\n+#![feature(generators, generator_trait)]\n+\n+extern crate xcrate;\n+\n+use std::ops::{GeneratorState, Generator};\n+\n+fn main() {\n+    let mut foo = xcrate::foo();\n+\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+\n+    let mut foo = xcrate::bar(3);\n+\n+    match foo.resume() {\n+        GeneratorState::Yielded(3) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}"}, {"sha": "5ff070f311e01e781f794537f5c9054abf917efa", "filename": "src/test/run-pass/generator/yield-subtype.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn bar<'a>() {\n+    let a: &'static str = \"hi\";\n+    let b: &'a str = a;\n+\n+    || {\n+        yield a;\n+        yield b;\n+    };\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "de10bdef4aee0585d496f20f497fd07c1b773638", "filename": "src/test/ui/generator/borrowing.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let _b = {\n+        let a = 3;\n+        (|| yield &a).resume()\n+        //~^ ERROR: `a` does not live long enough\n+    };\n+\n+    let _b = {\n+        let a = 3;\n+        || {\n+            yield &a\n+            //~^ ERROR: `a` does not live long enough\n+        }\n+    };\n+}\n+"}, {"sha": "0ed7e1f99027d64e717775e2f9dc3764bf5e1dfc", "filename": "src/test/ui/generator/borrowing.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,29 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/borrowing.rs:18:20\n+   |\n+18 |         (|| yield &a).resume()\n+   |          --        ^ does not live long enough\n+   |          |\n+   |          capture occurs here\n+19 |         //~^ ERROR: `a` does not live long enough\n+20 |     };\n+   |     - borrowed value only lives until here\n+...\n+29 | }\n+   | - borrowed value needs to live until here\n+\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/borrowing.rs:25:20\n+   |\n+24 |         || {\n+   |         -- capture occurs here\n+25 |             yield &a\n+   |                    ^ does not live long enough\n+...\n+28 |     };\n+   |     - borrowed value only lives until here\n+29 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a7e98fe4509278a699b3cff9e03dcd2832297fd1", "filename": "src/test/ui/generator/no-arguments-on-generators.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    let gen = |start| { //~ ERROR generators cannot have explicit arguments\n+        yield;\n+    };\n+}"}, {"sha": "4d2e228685ae3ab4e6f773b995e690b5d1148785", "filename": "src/test/ui/generator/no-arguments-on-generators.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,8 @@\n+error[E0628]: generators cannot have explicit arguments\n+  --> $DIR/no-arguments-on-generators.rs:14:15\n+   |\n+14 |     let gen = |start| { //~ ERROR generators cannot have explicit arguments\n+   |               ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0419758d8ea17ac32e4befab15d0578efcee18f4", "filename": "src/test/ui/generator/not-send-sync.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+use std::cell::Cell;\n+\n+fn main() {\n+    fn assert_sync<T: Sync>(_: T) {}\n+    fn assert_send<T: Send>(_: T) {}\n+\n+    assert_sync(|| {\n+        //~^ ERROR: Sync` is not satisfied\n+        let a = Cell::new(2);\n+        yield;\n+    });\n+\n+    let a = Cell::new(2);\n+    assert_send(|| {\n+        //~^ ERROR: Sync` is not satisfied\n+        drop(&a);\n+        yield;\n+    });\n+}"}, {"sha": "e0c32a95e0d9bd9561a8c5b7db767ea378898b6d", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied\n+  --> $DIR/not-send-sync.rs:26:5\n+   |\n+26 |     assert_send(|| {\n+   |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `&std::cell::Cell<i32>`\n+   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:26:17: 30:6 a:&std::cell::Cell<i32> _]`\n+   = note: required by `main::assert_send`\n+\n+error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+  --> $DIR/not-send-sync.rs:19:5\n+   |\n+19 |     assert_sync(|| {\n+   |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n+   |\n+   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n+   = note: required because it appears within the type `((), std::cell::Cell<i32>)`\n+   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+   = note: required by `main::assert_sync`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "87edbb22baae1661d998d2891d6ab9c6ebf2a725", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::cell::Cell;\n+\n+fn foo(x: &i32) {\n+    // In this case, a reference to `b` escapes the generator, but not\n+    // because of a yield. We see that there is no yield in the scope of\n+    // `b` and give the more generic error message.\n+    let mut a = &3;\n+    let mut b = move || {\n+        yield();\n+        let b = 5;\n+        a = &b; //~ ERROR\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "e30d28c2db83bcc7d40b346edb73084fb952a663", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,12 @@\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/ref-escapes-but-not-over-yield.rs:25:5\n+   |\n+24 |         a = &b; //~ ERROR\n+   |              - borrow occurs here\n+25 |     };\n+   |     ^ `b` dropped here while still borrowed\n+26 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "fb0e68136f544f151efbc3a13f910ba66659d6f1", "filename": "src/test/ui/generator/yield-in-args-rev.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn foo(_a: (), _b: &bool) {}\n+\n+// Some examples that probably *could* be accepted, but which we reject for now.\n+\n+fn bar() {\n+    || {\n+        let b = true;\n+        foo(yield, &b); //~ ERROR\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "157f896820906fac6b5891061f6c080cf165f87d", "filename": "src/test/ui/generator/yield-in-args-rev.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,10 @@\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-in-args-rev.rs:20:21\n+   |\n+20 |         foo(yield, &b); //~ ERROR\n+   |             -----   ^\n+   |             |\n+   |             possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "faeb4b1feb28ded8ca89d9989e56d132fd22f062", "filename": "src/test/ui/generator/yield-in-args.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn foo(_b: &bool, _a: ()) {}\n+\n+fn main() {\n+    || {\n+        let b = true;\n+        foo(&b, yield); //~ ERROR\n+    };\n+}"}, {"sha": "06561853dee8cbc3019d5587531111ba31f7811a", "filename": "src/test/ui/generator/yield-in-args.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,8 @@\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-in-args.rs:18:14\n+   |\n+18 |         foo(&b, yield); //~ ERROR\n+   |              ^  ----- possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "e166d2651597565eca1ae0d4917acee885905080", "filename": "src/test/ui/generator/yield-in-const.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+const A: u8 = { yield 3u8; 3u8};\n+//~^ ERROR yield statement outside"}, {"sha": "8a265c065b988509086e85f42067b505af98c12f", "filename": "src/test/ui/generator/yield-in-const.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,10 @@\n+error[E0601]: main function not found\n+\n+error[E0627]: yield statement outside of generator literal\n+  --> $DIR/yield-in-const.rs:13:17\n+   |\n+13 | const A: u8 = { yield 3u8; 3u8};\n+   |                 ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2f6c5a9ef754c317390f4356d8c7eed132828498", "filename": "src/test/ui/generator/yield-in-function.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() { yield; }\n+//~^ ERROR yield statement outside"}, {"sha": "c6ee3b8e9e7e1cd155f5b36fe47ee9412e6df1e7", "filename": "src/test/ui/generator/yield-in-function.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,8 @@\n+error[E0627]: yield statement outside of generator literal\n+  --> $DIR/yield-in-function.rs:13:13\n+   |\n+13 | fn main() { yield; }\n+   |             ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "823a2aa425e2cfdfeff4db50ca127bd8e094e2f0", "filename": "src/test/ui/generator/yield-in-static.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+static B: u8 = { yield 3u8; 3u8};\n+//~^ ERROR yield statement outside"}, {"sha": "d0575a0e47b3af0b04718c8e5872cc93b26d7c30", "filename": "src/test/ui/generator/yield-in-static.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,10 @@\n+error[E0601]: main function not found\n+\n+error[E0627]: yield statement outside of generator literal\n+  --> $DIR/yield-in-static.rs:13:18\n+   |\n+13 | static B: u8 = { yield 3u8; 3u8};\n+   |                  ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bc53448cb08e6d2ba02588aa1ebf91275bb599d2", "filename": "src/test/ui/generator/yield-while-iterating.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::cell::Cell;\n+\n+fn yield_during_iter_owned_data(x: Vec<i32>) {\n+    // The generator owns `x`, so we error out when yielding with a\n+    // reference to it.  This winds up becoming a rather confusing\n+    // regionck error -- in particular, we would freeze with the\n+    // reference in scope, and it doesn't live long enough.\n+    let _b = move || {\n+        for p in &x { //~ ERROR\n+            yield();\n+        }\n+    };\n+}\n+\n+fn yield_during_iter_borrowed_slice(x: &[i32]) {\n+    let _b = move || {\n+        for p in x {\n+            yield();\n+        }\n+    };\n+}\n+\n+fn yield_during_iter_borrowed_slice_2() {\n+    let mut x = vec![22_i32];\n+    let _b = || {\n+        for p in &x {\n+            yield();\n+        }\n+    };\n+    println!(\"{:?}\", x);\n+}\n+\n+fn yield_during_iter_borrowed_slice_3() {\n+    // OK to take a mutable ref to `x` and yield\n+    // up pointers from it:\n+    let mut x = vec![22_i32];\n+    let mut b = || {\n+        for p in &mut x {\n+            yield p;\n+        }\n+    };\n+    b.resume();\n+}\n+\n+fn yield_during_iter_borrowed_slice_4() {\n+    // ...but not OK to do that while reading\n+    // from `x` too\n+    let mut x = vec![22_i32];\n+    let mut b = || {\n+        for p in &mut x {\n+            yield p;\n+        }\n+    };\n+    println!(\"{}\", x[0]); //~ ERROR\n+    b.resume();\n+}\n+\n+fn yield_during_range_iter() {\n+    // Should be OK.\n+    let mut b = || {\n+        let v = vec![1,2,3];\n+        let len = v.len();\n+        for i in 0..len {\n+            let x = v[i];\n+            yield x;\n+        }\n+    };\n+    b.resume();\n+}\n+\n+fn main() { }"}, {"sha": "ea55e032e47611d84e2ff80320ca9f7c5ee21d77", "filename": "src/test/ui/generator/yield-while-iterating.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,24 @@\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-iterating.rs:22:19\n+   |\n+22 |         for p in &x { //~ ERROR\n+   |                   ^\n+23 |             yield();\n+   |             ------- possible yield occurs here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/yield-while-iterating.rs:67:20\n+   |\n+62 |     let mut b = || {\n+   |                 -- mutable borrow occurs here\n+63 |         for p in &mut x {\n+   |                       - previous borrow occurs due to use of `x` in closure\n+...\n+67 |     println!(\"{}\", x[0]); //~ ERROR\n+   |                    ^ immutable borrow occurs here\n+68 |     b.resume();\n+69 | }\n+   | - mutable borrow ends here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d21c86e88681e156a293fcffbcbdb00db9b119a2", "filename": "src/test/ui/generator/yield-while-local-borrowed.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::cell::Cell;\n+\n+fn borrow_local_inline() {\n+    // Not OK to yield with a borrow of a temporary.\n+    //\n+    // (This error occurs because the region shows up in the type of\n+    // `b` and gets extended by region inference.)\n+    let mut b = move || {\n+        let a = &3; //~ ERROR\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn borrow_local_inline_done() {\n+    // No error here -- `a` is not in scope at the point of `yield`.\n+    let mut b = move || {\n+        {\n+            let a = &3;\n+        }\n+        yield();\n+    };\n+    b.resume();\n+}\n+\n+fn borrow_local() {\n+    // Not OK to yield with a borrow of a temporary.\n+    //\n+    // (This error occurs because the region shows up in the type of\n+    // `b` and gets extended by region inference.)\n+    let mut b = move || {\n+        let a = 3;\n+        {\n+            let b = &a; //~ ERROR\n+            yield();\n+            println!(\"{}\", b);\n+        }\n+    };\n+    b.resume();\n+}\n+\n+fn main() { }"}, {"sha": "2fe6c686ce366317a27899548f9503632d714116", "filename": "src/test/ui/generator/yield-while-local-borrowed.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,10 @@\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-local-borrowed.rs:48:22\n+   |\n+48 |             let b = &a; //~ ERROR\n+   |                      ^\n+49 |             yield();\n+   |             ------- possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "b9c963ae740777a55a2cc5163da6dec4edecb1b9", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{GeneratorState, Generator};\n+use std::cell::Cell;\n+\n+fn reborrow_shared_ref(x: &i32) {\n+    // This is OK -- we have a borrow live over the yield, but it's of\n+    // data that outlives the generator.\n+    let mut b = move || {\n+        let a = &*x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn reborrow_mutable_ref(x: &mut i32) {\n+    // This is OK -- we have a borrow live over the yield, but it's of\n+    // data that outlives the generator.\n+    let mut b = move || {\n+        let a = &mut *x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn reborrow_mutable_ref_2(x: &mut i32) {\n+    // ...but not OK to go on using `x`.\n+    let mut b = || {\n+        let a = &mut *x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    println!(\"{}\", x); //~ ERROR\n+    b.resume();\n+}\n+\n+fn main() { }"}, {"sha": "7269f72973701004734c26b94408d435db728dd1", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -0,0 +1,16 @@\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/yield-while-ref-reborrowed.rs:45:20\n+   |\n+40 |     let mut b = || {\n+   |                 -- closure construction occurs here\n+41 |         let a = &mut *x;\n+   |                       - previous borrow occurs due to use of `x` in closure\n+...\n+45 |     println!(\"{}\", x); //~ ERROR\n+   |                    ^ borrow occurs here\n+46 |     b.resume();\n+47 | }\n+   | - borrow from closure ends here\n+\n+error: aborting due to previous error\n+"}, {"sha": "281c21f6f85eeee1fd4b9198a4ddfae81615eff5", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a59d693239915aa37bd08ca194a8ba2857db25a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -28,11 +28,11 @@ error: expected expression, found `;`\n 14 |     foo(bar(;\n    |             ^\n \n-error: expected one of `)`, `,`, `.`, `<`, `?`, `break`, `continue`, `false`, `for`, `if`, `loop`, `match`, `move`, `return`, `true`, `unsafe`, `while`, or an operator, found `;`\n+error: expected one of `)`, `,`, `.`, `<`, `?`, `break`, `continue`, `false`, `for`, `if`, `loop`, `match`, `move`, `return`, `true`, `unsafe`, `while`, `yield`, or an operator, found `;`\n   --> $DIR/token-error-correct.rs:14:13\n    |\n 14 |     foo(bar(;\n-   |             ^ expected one of 18 possible tokens here\n+   |             ^ expected one of 19 possible tokens here\n \n error: expected expression, found `)`\n   --> $DIR/token-error-correct.rs:23:1"}, {"sha": "144ce17f4d13fe10f386d42e3735956e9549167e", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=9a59d693239915aa37bd08ca194a8ba2857db25a", "patch": "@@ -1 +1 @@\n-Subproject commit 25ffb3a3d7809b4fa112f3e04e926eb539dd5e90\n+Subproject commit 144ce17f4d13fe10f386d42e3735956e9549167e"}]}