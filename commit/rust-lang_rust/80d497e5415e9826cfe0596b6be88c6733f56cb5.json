{"sha": "80d497e5415e9826cfe0596b6be88c6733f56cb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZDQ5N2U1NDE1ZTk4MjZjZmUwNTk2YjZiZTg4YzY3MzNmNTZjYjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-18T09:23:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-18T09:23:54Z"}, "message": "Merge #8081\n\n8081: Reorganize mbe tests r=edwin0cheng a=edwin0cheng\n\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f6611126ae81a874f139e04f9756f6c9fe808b28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6611126ae81a874f139e04f9756f6c9fe808b28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80d497e5415e9826cfe0596b6be88c6733f56cb5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUxwqCRBK7hj4Ov3rIwAAdHIIAFSPgygyC/hO4/MJQM0cZ359\njLr28QqSwDHxfNYNcwHyiVeDFPZuhLk2n3zdc146JbdpQJeqn4kEuvcnpnIL7GxJ\ndYufzyRtoIuzLfxEKNoibwf8GhpNqDXPHNOM/eqxHxRoci/1+mKRomxHFIUIIIxD\nL5TraGxNSCfKNvyZ2hHl9Vz6F1xGtoraYXNojZjS9t6p5A/6chiU3y3qT5sBM2ee\n9UGKUFZXF9vnf5VPnULMsvGazKanz5THjrY9GlyLiYto6Lgxi1LSxvaEHoy5764n\nHRDvL0kgN3TJCPMVoEhzSh2Cxr9hS5sBTpmxhOVl4tG99iH2ubRcNUUHif4kfv8=\n=LC1k\n-----END PGP SIGNATURE-----\n", "payload": "tree f6611126ae81a874f139e04f9756f6c9fe808b28\nparent d704750ba982153d92ccff90cf236121641b9da3\nparent 49b876de094db571d1ae10577ce2405909d3bd3e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616059434 +0000\ncommitter GitHub <noreply@github.com> 1616059434 +0000\n\nMerge #8081\n\n8081: Reorganize mbe tests r=edwin0cheng a=edwin0cheng\n\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80d497e5415e9826cfe0596b6be88c6733f56cb5", "html_url": "https://github.com/rust-lang/rust/commit/80d497e5415e9826cfe0596b6be88c6733f56cb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80d497e5415e9826cfe0596b6be88c6733f56cb5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d704750ba982153d92ccff90cf236121641b9da3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d704750ba982153d92ccff90cf236121641b9da3", "html_url": "https://github.com/rust-lang/rust/commit/d704750ba982153d92ccff90cf236121641b9da3"}, {"sha": "49b876de094db571d1ae10577ce2405909d3bd3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/49b876de094db571d1ae10577ce2405909d3bd3e", "html_url": "https://github.com/rust-lang/rust/commit/49b876de094db571d1ae10577ce2405909d3bd3e"}], "stats": {"total": 3911, "additions": 1952, "deletions": 1959}, "files": [{"sha": "6da18ecf4ec47a2962cb02b1fa908e7c0cf64946", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 35, "deletions": 1959, "changes": 1994, "blob_url": "https://github.com/rust-lang/rust/blob/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=80d497e5415e9826cfe0596b6be88c6733f56cb5", "patch": "@@ -1,1775 +1,14 @@\n+mod expand;\n+mod rule;\n+\n use std::fmt::Write;\n \n use ::parser::FragmentKind;\n-use syntax::{\n-    ast, AstNode, NodeOrToken,\n-    SyntaxKind::{ERROR, IDENT},\n-    SyntaxNode, WalkEvent, T,\n-};\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxNode, WalkEvent};\n use test_utils::assert_eq_text;\n \n use super::*;\n \n-mod rule_parsing {\n-    use syntax::{ast, AstNode};\n-\n-    use crate::ast_to_token_tree;\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_valid_arms() {\n-        fn check(macro_body: &str) {\n-            let m = parse_macro_arm(macro_body);\n-            m.unwrap();\n-        }\n-\n-        check(\"($i:ident) => ()\");\n-        check(\"($($i:ident)*) => ($_)\");\n-        check(\"($($true:ident)*) => ($true)\");\n-        check(\"($($false:ident)*) => ($false)\");\n-        check(\"($) => ($)\");\n-    }\n-\n-    #[test]\n-    fn test_invalid_arms() {\n-        fn check(macro_body: &str, err: ParseError) {\n-            let m = parse_macro_arm(macro_body);\n-            assert_eq!(m, Err(err));\n-        }\n-        check(\"invalid\", ParseError::Expected(\"expected subtree\".into()));\n-\n-        check(\"$i:ident => ()\", ParseError::Expected(\"expected subtree\".into()));\n-        check(\"($i:ident) ()\", ParseError::Expected(\"expected `=`\".into()));\n-        check(\"($($i:ident)_) => ()\", ParseError::InvalidRepeat);\n-\n-        check(\"($i) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-        check(\"($i:) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-    }\n-\n-    fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {\n-        let macro_definition = format!(\" macro_rules! m {{ {} }} \", arm_definition);\n-        let source_file = ast::SourceFile::parse(&macro_definition).ok().unwrap();\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-        let (definition_tt, _) =\n-            ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n-        crate::MacroRules::parse(&definition_tt)\n-    }\n-}\n-\n-// Good first issue (although a slightly challenging one):\n-//\n-// * Pick a random test from here\n-//   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n-// * Port the test to rust and add it to this module\n-// * Make it pass :-)\n-\n-#[test]\n-fn test_token_id_shift() {\n-    let expansion = parse_macro(\n-        r#\"\n-macro_rules! foobar {\n-    ($e:ident) => { foo bar $e }\n-}\n-\"#,\n-    )\n-    .expand_tt(\"foobar!(baz);\");\n-\n-    fn get_id(t: &tt::TokenTree) -> Option<u32> {\n-        if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n-            return Some(ident.id.0);\n-        }\n-        None\n-    }\n-\n-    assert_eq!(expansion.token_trees.len(), 3);\n-    // {($e:ident) => { foo bar $e }}\n-    // 012345      67 8 9   T   12\n-    assert_eq!(get_id(&expansion.token_trees[0]), Some(9));\n-    assert_eq!(get_id(&expansion.token_trees[1]), Some(10));\n-\n-    // The input args of macro call include parentheses:\n-    // (baz)\n-    // So baz should be 12+1+1\n-    assert_eq!(get_id(&expansion.token_trees[2]), Some(14));\n-}\n-\n-#[test]\n-fn test_token_map() {\n-    let expanded = parse_macro(\n-        r#\"\n-macro_rules! foobar {\n-    ($e:ident) => { fn $e() {} }\n-}\n-\"#,\n-    )\n-    .expand_tt(\"foobar!(baz);\");\n-\n-    let (node, token_map) = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap();\n-    let content = node.syntax_node().to_string();\n-\n-    let get_text = |id, kind| -> String {\n-        content[token_map.range_by_token(id).unwrap().by_kind(kind).unwrap()].to_string()\n-    };\n-\n-    assert_eq!(expanded.token_trees.len(), 4);\n-    // {($e:ident) => { fn $e() {} }}\n-    // 012345      67 8 9  T12  3\n-\n-    assert_eq!(get_text(tt::TokenId(9), IDENT), \"fn\");\n-    assert_eq!(get_text(tt::TokenId(12), T!['(']), \"(\");\n-    assert_eq!(get_text(tt::TokenId(13), T!['{']), \"{\");\n-}\n-\n-#[test]\n-fn test_convert_tt() {\n-    parse_macro(r#\"\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\"#)\n-        .assert_expand_tt(\n-            \"impl_froms!(TokenTree: Leaf, Subtree);\",\n-            \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n-             impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n-        );\n-}\n-\n-#[test]\n-fn test_convert_tt2() {\n-    parse_macro(\n-        r#\"\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\"#,\n-    )\n-    .assert_expand(\n-        \"impl_froms!(TokenTree: Leaf, Subtree);\",\n-        r#\"\n-SUBTREE $\n-  IDENT   impl 20\n-  IDENT   From 21\n-  PUNCH   < [joint] 22\n-  IDENT   Leaf 53\n-  PUNCH   > [alone] 25\n-  IDENT   for 26\n-  IDENT   TokenTree 51\n-  SUBTREE {} 29\n-    IDENT   fn 30\n-    IDENT   from 31\n-    SUBTREE () 32\n-      IDENT   it 33\n-      PUNCH   : [alone] 34\n-      IDENT   Leaf 53\n-    PUNCH   - [joint] 37\n-    PUNCH   > [alone] 38\n-    IDENT   TokenTree 51\n-    SUBTREE {} 41\n-      IDENT   TokenTree 51\n-      PUNCH   : [joint] 44\n-      PUNCH   : [joint] 45\n-      IDENT   Leaf 53\n-      SUBTREE () 48\n-        IDENT   it 49\n-  IDENT   impl 20\n-  IDENT   From 21\n-  PUNCH   < [joint] 22\n-  IDENT   Subtree 55\n-  PUNCH   > [alone] 25\n-  IDENT   for 26\n-  IDENT   TokenTree 51\n-  SUBTREE {} 29\n-    IDENT   fn 30\n-    IDENT   from 31\n-    SUBTREE () 32\n-      IDENT   it 33\n-      PUNCH   : [alone] 34\n-      IDENT   Subtree 55\n-    PUNCH   - [joint] 37\n-    PUNCH   > [alone] 38\n-    IDENT   TokenTree 51\n-    SUBTREE {} 41\n-      IDENT   TokenTree 51\n-      PUNCH   : [joint] 44\n-      PUNCH   : [joint] 45\n-      IDENT   Subtree 55\n-      SUBTREE () 48\n-        IDENT   it 49\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_lifetime_split() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($($t:tt)*) => { $($t)*}\n-}\n-\"#,\n-    )\n-    .assert_expand(\n-        r#\"foo!(static bar: &'static str = \"hello\";);\"#,\n-        r#\"\n-SUBTREE $\n-  IDENT   static 17\n-  IDENT   bar 18\n-  PUNCH   : [alone] 19\n-  PUNCH   & [alone] 20\n-  PUNCH   ' [joint] 21\n-  IDENT   static 22\n-  IDENT   str 23\n-  PUNCH   = [alone] 24\n-  LITERAL \"hello\" 25\n-  PUNCH   ; [joint] 26\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_expr_order() {\n-    let expanded = parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:expr) => {\n-                 fn bar() { $ i * 2; }\n-            }\n-        }\n-\"#,\n-    )\n-    .expand_items(\"foo! { 1 + 1}\");\n-\n-    let dump = format!(\"{:#?}\", expanded);\n-    assert_eq_text!(\n-        r#\"MACRO_ITEMS@0..15\n-  FN@0..15\n-    FN_KW@0..2 \"fn\"\n-    NAME@2..5\n-      IDENT@2..5 \"bar\"\n-    PARAM_LIST@5..7\n-      L_PAREN@5..6 \"(\"\n-      R_PAREN@6..7 \")\"\n-    BLOCK_EXPR@7..15\n-      L_CURLY@7..8 \"{\"\n-      EXPR_STMT@8..14\n-        BIN_EXPR@8..13\n-          BIN_EXPR@8..11\n-            LITERAL@8..9\n-              INT_NUMBER@8..9 \"1\"\n-            PLUS@9..10 \"+\"\n-            LITERAL@10..11\n-              INT_NUMBER@10..11 \"1\"\n-          STAR@11..12 \"*\"\n-          LITERAL@12..13\n-            INT_NUMBER@12..13 \"2\"\n-        SEMICOLON@13..14 \";\"\n-      R_CURLY@14..15 \"}\"\"#,\n-        dump.trim()\n-    );\n-}\n-\n-#[test]\n-fn test_fail_match_pattern_by_first_token() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            (= $ i:ident) => (\n-                fn $ i() {}\n-            );\n-            (+ $ i:ident) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n-    .assert_expand_items(\"foo! { = bar }\", \"fn bar () {}\")\n-    .assert_expand_items(\"foo! { + Baz }\", \"struct Baz ;\");\n-}\n-\n-#[test]\n-fn test_fail_match_pattern_by_last_token() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            ($ i:ident =) => (\n-                fn $ i() {}\n-            );\n-            ($ i:ident +) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n-    .assert_expand_items(\"foo! { bar = }\", \"fn bar () {}\")\n-    .assert_expand_items(\"foo! { Baz + }\", \"struct Baz ;\");\n-}\n-\n-#[test]\n-fn test_fail_match_pattern_by_word_token() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            (spam $ i:ident) => (\n-                fn $ i() {}\n-            );\n-            (eggs $ i:ident) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n-    .assert_expand_items(\"foo! { spam bar }\", \"fn bar () {}\")\n-    .assert_expand_items(\"foo! { eggs Baz }\", \"struct Baz ;\");\n-}\n-\n-#[test]\n-fn test_match_group_pattern_by_separator_token() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ($ (\n-                mod $ i {}\n-            )*);\n-            ($ ($ i:ident)#*) => ($ (\n-                fn $ i() {}\n-            )*);\n-            ($ i:ident ,# $ j:ident) => (\n-                struct $ i;\n-                struct $ j;\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"mod foo {} mod bar {}\")\n-    .assert_expand_items(\"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\")\n-    .assert_expand_items(\"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n-}\n-\n-#[test]\n-fn test_match_group_pattern_with_multiple_defs() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( struct Bar { $ (\n-                fn $ i {}\n-            )*} );\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"struct Bar {fn foo {} fn bar {}}\");\n-}\n-\n-#[test]\n-fn test_match_group_pattern_with_multiple_statement() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( fn baz { $ (\n-                $ i ();\n-            )*} );\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n-}\n-\n-#[test]\n-fn test_match_group_pattern_with_multiple_statement_without_semi() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( fn baz { $ (\n-                $i()\n-            );*} );\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n-}\n-\n-#[test]\n-fn test_match_group_empty_fixed_token() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident)* #abc) => ( fn baz { $ (\n-                $ i ();\n-            )*} );\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! {#abc}\", \"fn baz {}\");\n-}\n-\n-#[test]\n-fn test_match_group_in_subtree() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n-                $ i ();\n-            )*} );\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n-}\n-\n-#[test]\n-fn test_match_group_with_multichar_sep() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! (fn baz {true true} );\", \"fn baz () -> bool {true &&true}\");\n-}\n-\n-#[test]\n-fn test_match_group_with_multichar_sep2() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            (fn $name:ident {$($i:literal)&&*} ) => ( fn $name() -> bool { $($i)&&*} );\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! (fn baz {true && true} );\", \"fn baz () -> bool {true &&true}\");\n-}\n-\n-#[test]\n-fn test_match_group_zero_match() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ( $($i:ident)* ) => ();\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! ();\", \"\");\n-}\n-\n-#[test]\n-fn test_match_group_in_group() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n-        }\"#,\n-    )\n-    .assert_expand_items(\"foo! ( (a b) );\", \"(a b)\");\n-}\n-\n-#[test]\n-fn test_expand_to_item_list() {\n-    let tree = parse_macro(\n-        \"\n-            macro_rules! structs {\n-                ($($i:ident),*) => {\n-                    $(struct $i { field: u32 } )*\n-                }\n-            }\n-            \",\n-    )\n-    .expand_items(\"structs!(Foo, Bar);\");\n-    assert_eq!(\n-        format!(\"{:#?}\", tree).trim(),\n-        r#\"\n-MACRO_ITEMS@0..40\n-  STRUCT@0..20\n-    STRUCT_KW@0..6 \"struct\"\n-    NAME@6..9\n-      IDENT@6..9 \"Foo\"\n-    RECORD_FIELD_LIST@9..20\n-      L_CURLY@9..10 \"{\"\n-      RECORD_FIELD@10..19\n-        NAME@10..15\n-          IDENT@10..15 \"field\"\n-        COLON@15..16 \":\"\n-        PATH_TYPE@16..19\n-          PATH@16..19\n-            PATH_SEGMENT@16..19\n-              NAME_REF@16..19\n-                IDENT@16..19 \"u32\"\n-      R_CURLY@19..20 \"}\"\n-  STRUCT@20..40\n-    STRUCT_KW@20..26 \"struct\"\n-    NAME@26..29\n-      IDENT@26..29 \"Bar\"\n-    RECORD_FIELD_LIST@29..40\n-      L_CURLY@29..30 \"{\"\n-      RECORD_FIELD@30..39\n-        NAME@30..35\n-          IDENT@30..35 \"field\"\n-        COLON@35..36 \":\"\n-        PATH_TYPE@36..39\n-          PATH@36..39\n-            PATH_SEGMENT@36..39\n-              NAME_REF@36..39\n-                IDENT@36..39 \"u32\"\n-      R_CURLY@39..40 \"}\"\"#\n-            .trim()\n-    );\n-}\n-\n-fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n-    if let tt::TokenTree::Subtree(subtree) = tt {\n-        return &subtree;\n-    }\n-    unreachable!(\"It is not a subtree\");\n-}\n-fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n-    if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n-        return lit;\n-    }\n-    unreachable!(\"It is not a literal\");\n-}\n-\n-fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n-    if let tt::TokenTree::Leaf(tt::Leaf::Punct(lit)) = tt {\n-        return lit;\n-    }\n-    unreachable!(\"It is not a Punct\");\n-}\n-\n-#[test]\n-fn test_expand_literals_to_token_tree() {\n-    let expansion = parse_macro(\n-        r#\"\n-            macro_rules! literals {\n-                ($i:ident) => {\n-                    {\n-                        let a = 'c';\n-                        let c = 1000;\n-                        let f = 12E+99_f64;\n-                        let s = \"rust1\";\n-                    }\n-                }\n-            }\n-            \"#,\n-    )\n-    .expand_tt(\"literals!(foo);\");\n-    let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n-\n-    // [let] [a] [=] ['c'] [;]\n-    assert_eq!(to_literal(&stm_tokens[3]).text, \"'c'\");\n-    // [let] [c] [=] [1000] [;]\n-    assert_eq!(to_literal(&stm_tokens[5 + 3]).text, \"1000\");\n-    // [let] [f] [=] [12E+99_f64] [;]\n-    assert_eq!(to_literal(&stm_tokens[10 + 3]).text, \"12E+99_f64\");\n-    // [let] [s] [=] [\"rust1\"] [;]\n-    assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n-}\n-\n-#[test]\n-fn test_attr_to_token_tree() {\n-    let expansion = parse_to_token_tree_by_syntax(\n-        r#\"\n-            #[derive(Copy)]\n-            struct Foo;\n-            \"#,\n-    );\n-\n-    assert_eq!(to_punct(&expansion.token_trees[0]).char, '#');\n-    assert_eq!(\n-        to_subtree(&expansion.token_trees[1]).delimiter_kind(),\n-        Some(tt::DelimiterKind::Bracket)\n-    );\n-}\n-\n-#[test]\n-fn test_two_idents() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ident, $ j:ident) => {\n-                fn foo() { let a = $ i; let b = $j; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n-}\n-\n-#[test]\n-fn test_tt_to_stmts() {\n-    let stmts = parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            () => {\n-                 let a = 0;\n-                 a = 10 + 1;\n-                 a\n-            }\n-        }\n-\"#,\n-    )\n-    .expand_statements(\"foo!{}\");\n-\n-    assert_eq!(\n-        format!(\"{:#?}\", stmts).trim(),\n-        r#\"MACRO_STMTS@0..15\n-  LET_STMT@0..7\n-    LET_KW@0..3 \"let\"\n-    IDENT_PAT@3..4\n-      NAME@3..4\n-        IDENT@3..4 \"a\"\n-    EQ@4..5 \"=\"\n-    LITERAL@5..6\n-      INT_NUMBER@5..6 \"0\"\n-    SEMICOLON@6..7 \";\"\n-  EXPR_STMT@7..14\n-    BIN_EXPR@7..13\n-      PATH_EXPR@7..8\n-        PATH@7..8\n-          PATH_SEGMENT@7..8\n-            NAME_REF@7..8\n-              IDENT@7..8 \"a\"\n-      EQ@8..9 \"=\"\n-      BIN_EXPR@9..13\n-        LITERAL@9..11\n-          INT_NUMBER@9..11 \"10\"\n-        PLUS@11..12 \"+\"\n-        LITERAL@12..13\n-          INT_NUMBER@12..13 \"1\"\n-    SEMICOLON@13..14 \";\"\n-  PATH_EXPR@14..15\n-    PATH@14..15\n-      PATH_SEGMENT@14..15\n-        NAME_REF@14..15\n-          IDENT@14..15 \"a\"\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_match_literal() {\n-    parse_macro(\n-        r#\"\n-    macro_rules! foo {\n-        ('(') => {\n-            fn foo() {}\n-        }\n-    }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! ['('];\", \"fn foo () {}\");\n-}\n-\n-#[test]\n-fn test_parse_macro_def_simple() {\n-    cov_mark::check!(parse_macro_def_simple);\n-\n-    parse_macro2(\n-        r#\"\n-macro foo($id:ident) {\n-    fn $id() {}\n-}\n-\"#,\n-    )\n-    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n-}\n-\n-#[test]\n-fn test_parse_macro_def_rules() {\n-    cov_mark::check!(parse_macro_def_rules);\n-\n-    parse_macro2(\n-        r#\"\n-macro foo {\n-    ($id:ident) => {\n-        fn $id() {}\n-    }\n-}\n-\"#,\n-    )\n-    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n-}\n-\n-// The following tests are port from intellij-rust directly\n-// https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n-\n-#[test]\n-fn test_path() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:path) => {\n-                fn foo() { let a = $ i; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo ;}\")\n-    .assert_expand_items(\n-        \"foo! { bar::<u8>::baz::<u8> }\",\n-        \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n-    );\n-}\n-\n-#[test]\n-fn test_two_paths() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:path, $ j:path) => {\n-                fn foo() { let a = $ i; let b = $j; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n-}\n-\n-#[test]\n-fn test_path_with_path() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:path) => {\n-                fn foo() { let a = $ i :: bar; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n-}\n-\n-#[test]\n-fn test_expr() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:expr) => {\n-                 fn bar() { $ i; }\n-            }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\n-        \"foo! { 2 + 2 * baz(3).quux() }\",\n-        \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n-    );\n-}\n-\n-#[test]\n-fn test_last_expr() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! vec {\n-            ($($item:expr),*) => {\n-                {\n-                    let mut v = Vec::new();\n-                    $(\n-                        v.push($item);\n-                    )*\n-                    v\n-                }\n-            };\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\n-        \"vec!(1,2,3);\",\n-        \"{let mut v = Vec :: new () ; v . push (1) ; v . push (2) ; v . push (3) ; v}\",\n-    );\n-}\n-\n-#[test]\n-fn test_expr_with_attr() {\n-    parse_macro(\n-        r#\"\n-macro_rules! m {\n-    ($a:expr) => {0}\n-}\n-\"#,\n-    )\n-    .assert_expand_items(\"m!(#[allow(a)]())\", \"0\");\n-}\n-\n-#[test]\n-fn test_ty() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ty) => (\n-                fn bar() -> $ i { unimplemented!() }\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { Baz<u8> }\", \"fn bar () -> Baz < u8 > {unimplemented ! ()}\");\n-}\n-\n-#[test]\n-fn test_ty_with_complex_type() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:ty) => (\n-                fn bar() -> $ i { unimplemented!() }\n-            )\n-        }\n-\"#,\n-    )\n-    // Reference lifetime struct with generic type\n-    .assert_expand_items(\n-        \"foo! { &'a Baz<u8> }\",\n-        \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n-    )\n-    // extern \"Rust\" func type\n-    .assert_expand_items(\n-        r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n-        r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_pat_() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:pat) => { fn foo() { let $ i; } }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n-}\n-\n-#[test]\n-fn test_stmt() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:stmt) => (\n-                fn bar() { $ i; }\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! { 2 }\", \"fn bar () {2 ;}\")\n-    .assert_expand_items(\"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n-}\n-\n-#[test]\n-fn test_single_item() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:item) => (\n-                $ i\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\"foo! {mod c {}}\", \"mod c {}\");\n-}\n-\n-#[test]\n-fn test_all_items() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ ($ i:item)*) => ($ (\n-                $ i\n-            )*)\n-        }\n-\"#,\n-    ).\n-    assert_expand_items(\n-        r#\"\n-        foo! {\n-            extern crate a;\n-            mod b;\n-            mod c {}\n-            use d;\n-            const E: i32 = 0;\n-            static F: i32 = 0;\n-            impl G {}\n-            struct H;\n-            enum I { Foo }\n-            trait J {}\n-            fn h() {}\n-            extern {}\n-            type T = u8;\n-        }\n-\"#,\n-        r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_block() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:block) => { fn foo() $ i }\n-        }\n-\"#,\n-    )\n-    .assert_expand_statements(\"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n-}\n-\n-#[test]\n-fn test_meta() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:meta) => (\n-                #[$ i]\n-                fn bar() {}\n-            )\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(\n-        r#\"foo! { cfg(target_os = \"windows\") }\"#,\n-        r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n-    )\n-    .assert_expand_items(r#\"foo! { hello::world }\"#, r#\"# [hello :: world] fn bar () {}\"#);\n-}\n-\n-#[test]\n-fn test_meta_doc_comments() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($(#[$ i:meta])+) => (\n-                $(#[$ i])+\n-                fn bar() {}\n-            )\n-        }\n-\"#,\n-    ).\n-    assert_expand_items(\n-        r#\"foo! {\n-            /// Single Line Doc 1\n-            /**\n-                MultiLines Doc\n-            */\n-        }\"#,\n-        \"# [doc = \\\" Single Line Doc 1\\\"] # [doc = \\\"\\\\\\\\n                MultiLines Doc\\\\\\\\n            \\\"] fn bar () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_meta_doc_comments_non_latin() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($(#[$ i:meta])+) => (\n-                $(#[$ i])+\n-                fn bar() {}\n-            )\n-        }\n-\"#,\n-    ).\n-    assert_expand_items(\n-        r#\"foo! {\n-            /// \u9326\u745f\u7121\u7aef\u4e94\u5341\u5f26\uff0c\u4e00\u5f26\u4e00\u67f1\u601d\u83ef\u5e74\u3002\n-            /**\n-                \u838a\u751f\u66c9\u5922\u8ff7\u8774\u8776\uff0c\u671b\u5e1d\u6625\u5fc3\u8a17\u675c\u9d51\u3002\n-            */\n-        }\"#,\n-        \"# [doc = \\\" \u9326\u745f\u7121\u7aef\u4e94\u5341\u5f26\uff0c\u4e00\u5f26\u4e00\u67f1\u601d\u83ef\u5e74\u3002\\\"] # [doc = \\\"\\\\\\\\n                \u838a\u751f\u66c9\u5922\u8ff7\u8774\u8776\uff0c\u671b\u5e1d\u6625\u5fc3\u8a17\u675c\u9d51\u3002\\\\\\\\n            \\\"] fn bar () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_tt_block() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                ($ i:tt) => { fn foo() $ i }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n-}\n-\n-#[test]\n-fn test_tt_group() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 ($($ i:tt)*) => { $($ i)* }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n-}\n-\n-#[test]\n-fn test_tt_composite() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 ($i:tt) => { 0 }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { => }\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_tt_composite2() {\n-    let node = parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                ($($tt:tt)*) => { abs!(=> $($tt)*) }\n-            }\n-    \"#,\n-    )\n-    .expand_items(r#\"foo!{#}\"#);\n-\n-    let res = format!(\"{:#?}\", &node);\n-    assert_eq_text!(\n-        r###\"MACRO_ITEMS@0..10\n-  MACRO_CALL@0..10\n-    PATH@0..3\n-      PATH_SEGMENT@0..3\n-        NAME_REF@0..3\n-          IDENT@0..3 \"abs\"\n-    BANG@3..4 \"!\"\n-    TOKEN_TREE@4..10\n-      L_PAREN@4..5 \"(\"\n-      EQ@5..6 \"=\"\n-      R_ANGLE@6..7 \">\"\n-      WHITESPACE@7..8 \" \"\n-      POUND@8..9 \"#\"\n-      R_PAREN@9..10 \")\"\"###,\n-        res.trim()\n-    );\n-}\n-\n-#[test]\n-fn test_tt_with_composite_without_space() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($ op:tt, $j:path) => (\n-                0\n-            )\n-        }\n-\"#,\n-    )\n-    // Test macro input without any spaces\n-    // See https://github.com/rust-analyzer/rust-analyzer/issues/6692\n-    .assert_expand_items(\"foo!(==,Foo::Bool)\", \"0\");\n-}\n-\n-#[test]\n-fn test_underscore() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 ($_:tt) => { 0 }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { => }\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_underscore_not_greedily() {\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($($a:ident)* _) => {0};\n-}\n-\"#,\n-    )\n-    // `_` overlaps with `$a:ident` but rustc matches it under the `_` token\n-    .assert_expand_items(r#\"q![a b c d _]\"#, r#\"0\"#);\n-\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($($a:expr => $b:ident)* _ => $c:expr) => {0};\n-}\n-\"#,\n-    )\n-    // `_ => ou` overlaps with `$a:expr => $b:ident` but rustc matches it under `_ => $c:expr`\n-    .assert_expand_items(r#\"q![a => b c => d _ => ou]\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_underscore_as_type() {\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($a:ty) => {0};\n-}\n-\"#,\n-    )\n-    // Underscore is a type\n-    .assert_expand_items(r#\"q![_]\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_vertical_bar_with_pat() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 (| $pat:pat | ) => { 0 }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { | x | }\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_dollar_crate_lhs_is_not_meta() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($crate) => {};\n-    () => {0};\n-}\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo!{}\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_lifetime() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n-}\n-\n-#[test]\n-fn test_literal() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(u8,0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n-\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(i32,-1);\"#, r#\"const VALUE : i32 = - 1 ;\"#);\n-}\n-\n-#[test]\n-fn test_boolean_is_ident() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($lit0:literal, $lit1:literal) => { const VALUE: (bool,bool) = ($lit0,$lit1); };\n-        }\n-\"#,\n-    )\n-    .assert_expand(\n-        r#\"foo!(true,false);\"#,\n-        r#\"\n-SUBTREE $\n-  IDENT   const 14\n-  IDENT   VALUE 15\n-  PUNCH   : [alone] 16\n-  SUBTREE () 17\n-    IDENT   bool 18\n-    PUNCH   , [alone] 19\n-    IDENT   bool 20\n-  PUNCH   = [alone] 21\n-  SUBTREE () 22\n-    IDENT   true 29\n-    PUNCH   , [joint] 25\n-    IDENT   false 31\n-  PUNCH   ; [alone] 28\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_vis() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#)\n-    // test optional cases\n-    .assert_expand_items(r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n-}\n-\n-#[test]\n-fn test_inner_macro_rules() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($a:ident, $b:ident, $c:tt) => {\n-\n-        macro_rules! bar {\n-            ($bi:ident) => {\n-                fn $bi() -> u8 {$c}\n-            }\n-        }\n-\n-        bar!($a);\n-        fn $b() -> u8 {$c}\n-    }\n-}\n-\"#,\n-    ).\n-    assert_expand_items(\n-        r#\"foo!(x,y, 1);\"#,\n-        r#\"macro_rules ! bar {($ bi : ident) => {fn $ bi () -> u8 {1}}} bar ! (x) ; fn y () -> u8 {1}\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_expr_after_path_colons() {\n-    assert!(parse_macro(\n-        r#\"\n-macro_rules! m {\n-    ($k:expr) => {\n-            f(K::$k);\n-       }\n-}\n-\"#,\n-    )\n-    .expand_statements(r#\"m!(C(\"0\"))\"#)\n-    .descendants()\n-    .find(|token| token.kind() == ERROR)\n-    .is_some());\n-}\n-\n-#[test]\n-fn test_match_is_not_greedy() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($($i:ident $(,)*),*) => {};\n-}\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(a,b);\"#, r#\"\"#);\n-}\n-\n-// The following tests are based on real world situations\n-#[test]\n-fn test_vec() {\n-    let fixture = parse_macro(\n-        r#\"\n-         macro_rules! vec {\n-            ($($item:expr),*) => {\n-                {\n-                    let mut v = Vec::new();\n-                    $(\n-                        v.push($item);\n-                    )*\n-                    v\n-                }\n-            };\n-}\n-\"#,\n-    );\n-    fixture\n-        .assert_expand_items(r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#)\n-        .assert_expand_items(\n-            r#\"vec![1u32,2];\"#,\n-            r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n-        );\n-\n-    let tree = fixture.expand_expr(r#\"vec![1u32,2];\"#);\n-\n-    assert_eq!(\n-        format!(\"{:#?}\", tree).trim(),\n-        r#\"BLOCK_EXPR@0..45\n-  L_CURLY@0..1 \"{\"\n-  LET_STMT@1..20\n-    LET_KW@1..4 \"let\"\n-    IDENT_PAT@4..8\n-      MUT_KW@4..7 \"mut\"\n-      NAME@7..8\n-        IDENT@7..8 \"v\"\n-    EQ@8..9 \"=\"\n-    CALL_EXPR@9..19\n-      PATH_EXPR@9..17\n-        PATH@9..17\n-          PATH@9..12\n-            PATH_SEGMENT@9..12\n-              NAME_REF@9..12\n-                IDENT@9..12 \"Vec\"\n-          COLON2@12..14 \"::\"\n-          PATH_SEGMENT@14..17\n-            NAME_REF@14..17\n-              IDENT@14..17 \"new\"\n-      ARG_LIST@17..19\n-        L_PAREN@17..18 \"(\"\n-        R_PAREN@18..19 \")\"\n-    SEMICOLON@19..20 \";\"\n-  EXPR_STMT@20..33\n-    METHOD_CALL_EXPR@20..32\n-      PATH_EXPR@20..21\n-        PATH@20..21\n-          PATH_SEGMENT@20..21\n-            NAME_REF@20..21\n-              IDENT@20..21 \"v\"\n-      DOT@21..22 \".\"\n-      NAME_REF@22..26\n-        IDENT@22..26 \"push\"\n-      ARG_LIST@26..32\n-        L_PAREN@26..27 \"(\"\n-        LITERAL@27..31\n-          INT_NUMBER@27..31 \"1u32\"\n-        R_PAREN@31..32 \")\"\n-    SEMICOLON@32..33 \";\"\n-  EXPR_STMT@33..43\n-    METHOD_CALL_EXPR@33..42\n-      PATH_EXPR@33..34\n-        PATH@33..34\n-          PATH_SEGMENT@33..34\n-            NAME_REF@33..34\n-              IDENT@33..34 \"v\"\n-      DOT@34..35 \".\"\n-      NAME_REF@35..39\n-        IDENT@35..39 \"push\"\n-      ARG_LIST@39..42\n-        L_PAREN@39..40 \"(\"\n-        LITERAL@40..41\n-          INT_NUMBER@40..41 \"2\"\n-        R_PAREN@41..42 \")\"\n-    SEMICOLON@42..43 \";\"\n-  PATH_EXPR@43..44\n-    PATH@43..44\n-      PATH_SEGMENT@43..44\n-        NAME_REF@43..44\n-          IDENT@43..44 \"v\"\n-  R_CURLY@44..45 \"}\"\"#\n-    );\n-}\n-\n-#[test]\n-fn test_winapi_struct() {\n-    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n-\n-    parse_macro(\n-        r#\"\n-macro_rules! STRUCT {\n-    ($(#[$attrs:meta])* struct $name:ident {\n-        $($field:ident: $ftype:ty,)+\n-    }) => (\n-        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n-        pub struct $name {\n-            $(pub $field: $ftype,)+\n-        }\n-        impl Clone for $name {\n-            #[inline]\n-            fn clone(&self) -> $name { *self }\n-        }\n-        #[cfg(feature = \"impl-default\")]\n-        impl Default for $name {\n-            #[inline]\n-            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n-        }\n-    );\n-}\n-\"#,\n-    ).\n-    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n-    assert_expand_items(r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n-    )\n-    .assert_expand_items(r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_int_base() {\n-    parse_macro(\n-        r#\"\n-macro_rules! int_base {\n-    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl fmt::$Trait for $T {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                $Radix.fmt_int(*self as $U, f)\n-            }\n-        }\n-    }\n-}\n-\"#,\n-    ).assert_expand_items(r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n-        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_generate_pattern_iterators() {\n-    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n-    parse_macro(\n-        r#\"\n-macro_rules! generate_pattern_iterators {\n-        { double ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-        } => {\n-            fn foo(){}\n-        }\n-}\n-\"#,\n-    ).assert_expand_items(\n-        r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n-        \"fn foo () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_impl_fn_for_zst() {\n-    // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n-    parse_macro(\n-        r#\"\n-macro_rules! impl_fn_for_zst  {\n-        {  $( $( #[$attr: meta] )*\n-        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n-            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n-$body: block; )+\n-        } => {\n-           $(\n-            $( #[$attr] )*\n-            struct $Name;\n-\n-            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    $body\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call_mut(\n-                    &mut self,\n-                    ($( $arg, )*): ($( $ArgTy, )*)\n-                ) -> $ReturnTy {\n-                    Fn::call(&*self, ($( $arg, )*))\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n-                type Output = $ReturnTy;\n-\n-                #[inline]\n-                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    Fn::call(&self, ($( $arg, )*))\n-                }\n-            }\n-        )+\n-}\n-        }\n-\"#,\n-    ).assert_expand_items(r#\"\n-impl_fn_for_zst !   {\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   {\n-         c . escape_debug_ext ( false )\n-     } ;\n-\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   {\n-         c . escape_unicode ( )\n-     } ;\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   {\n-         c . escape_default ( )\n-     } ;\n- }\n-\"#,\n-        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_impl_nonzero_fmt() {\n-    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n-    parse_macro(\n-        r#\"\n-        macro_rules! impl_nonzero_fmt {\n-            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n-                fn foo () {}\n-            }\n-        }\n-\"#,\n-    ).assert_expand_items(\n-        r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n-        \"fn foo () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_cfg_if_items() {\n-    // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n-    parse_macro(\n-        r#\"\n-        macro_rules! __cfg_if_items {\n-            (($($not:meta,)*) ; ) => {};\n-            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-            }\n-        }\n-\"#,\n-    ).assert_expand_items(\n-        r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n-        \"__cfg_if_items ! {(rustdoc ,) ;}\",\n-    );\n-}\n-\n-#[test]\n-fn test_cfg_if_main() {\n-    // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n-    parse_macro(\n-        r#\"\n-        macro_rules! cfg_if {\n-            ($(\n-                if #[cfg($($meta:meta),*)] { $($it:item)* }\n-            ) else * else {\n-                $($it2:item)*\n-            }) => {\n-                __cfg_if_items! {\n-                    () ;\n-                    $( ( ($($meta),*) ($($it)*) ), )*\n-                    ( () ($($it2)*) ),\n-                }\n-            };\n-\n-            // Internal macro to Apply a cfg attribute to a list of items\n-            (@__apply $m:meta, $($it:item)*) => {\n-                $(#[$m] $it)*\n-            };\n-        }\n-\"#,\n-    ).assert_expand_items(r#\"\n-cfg_if !   {\n-     if   # [ cfg ( target_env   =   \"msvc\" ) ]   {\n-         // no extra unwinder support needed\n-     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   {\n-         // no unwinder on the system!\n-     }   else   {\n-         mod   libunwind ;\n-         pub   use   libunwind :: * ;\n-     }\n- }\n-\"#,\n-        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\"\n-    ).assert_expand_items(\n-        r#\"\n-cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n-\"#,\n-        \"\",\n-    );\n-}\n-\n-#[test]\n-fn test_proptest_arbitrary() {\n-    // from https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16\n-    parse_macro(\n-        r#\"\n-macro_rules! arbitrary {\n-    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n-        $args: ident => $logic: expr) => {\n-        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n-            type Parameters = $params;\n-            type Strategy = $strat;\n-            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n-                $logic\n-            }\n-        }\n-    };\n-\n-}\"#,\n-    ).assert_expand_items(r#\"arbitrary !   ( [ A : Arbitrary ]\n-        Vec < A > ,\n-        VecStrategy < A :: Strategy > ,\n-        RangedParams1 < A :: Parameters > ;\n-        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) }\n-    ) ;\"#,\n-    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_old_ridl() {\n-    // This is from winapi 2.8, which do not have a link from github\n-    //\n-    let expanded = parse_macro(\n-        r#\"\n-#[macro_export]\n-macro_rules! RIDL {\n-    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n-        {$(\n-            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n-        ),+}\n-    ) => {\n-        impl $interface {\n-            $(pub unsafe fn $method(&mut self) -> $rtr {\n-                ((*self.lpVtbl).$method)(self $(,$p)*)\n-            })+\n-        }\n-    };\n-}\"#,\n-    ).expand_tt(r#\"\n-    RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n-        fn GetDataSize(&mut self) -> UINT\n-    }}\"#);\n-\n-    assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n-}\n-\n-#[test]\n-fn test_quick_error() {\n-    let expanded = parse_macro(\n-        r#\"\n-macro_rules! quick_error {\n-\n- (SORT [enum $name:ident $( #[$meta:meta] )*]\n-        items [$($( #[$imeta:meta] )*\n-                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n-                                {$( $ifuncs:tt )*} )* ]\n-        buf [ ]\n-        queue [ ]\n-    ) => {\n-        quick_error!(ENUMINITION [enum $name $( #[$meta] )*]\n-            body []\n-            queue [$(\n-                $( #[$imeta] )*\n-                =>\n-                $iitem: $imode [$( $ivar: $ityp ),*]\n-            )*]\n-        );\n-};\n-\n-}\n-\"#,\n-    )\n-    .expand_tt(\n-        r#\"\n-quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n-        => One : UNIT [] {}\n-        => Two : TUPLE [s :String] {display (\"two: {}\" , s) from ()}\n-    ] buf [] queue []) ;\n-\"#,\n-    );\n-\n-    assert_eq!(expanded.to_string(), \"quick_error ! (ENUMINITION [enum Wrapped # [derive (Debug)]] body [] queue [=> One : UNIT [] => Two : TUPLE [s : String]]) ;\");\n-}\n-\n-#[test]\n-fn test_empty_repeat_vars_in_empty_repeat_vars() {\n-    parse_macro(\n-        r#\"\n-macro_rules! delegate_impl {\n-    ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n-     pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n-\n-        // \"Escaped\" associated types. Stripped before making the `trait`\n-        // itself, but forwarded when delegating impls.\n-        $(\n-        @escape [type $assoc_name_ext:ident]\n-        // Associated types. Forwarded.\n-        )*\n-        $(\n-        @section type\n-        $(\n-            $(#[$_assoc_attr:meta])*\n-            type $assoc_name:ident $(: $assoc_bound:ty)*;\n-        )+\n-        )*\n-        // Methods. Forwarded. Using $self_map!(self) around the self argument.\n-        // Methods must use receiver `self` or explicit type like `self: &Self`\n-        // &self and &mut self are _not_ supported.\n-        $(\n-        @section self\n-        $(\n-            $(#[$_method_attr:meta])*\n-            fn $method_name:ident(self $(: $self_selftype:ty)* $(,$marg:ident : $marg_ty:ty)*) -> $mret:ty;\n-        )+\n-        )*\n-        // Arbitrary tail that is ignored when forwarding.\n-        $(\n-        @section nodelegate\n-        $($tail:tt)*\n-        )*\n-    }) => {\n-        impl<> $name for $self_wrap where $self_type: $name {\n-            $(\n-            $(\n-                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) -> $mret {\n-                    $self_map!(self).$method_name($($marg),*)\n-                }\n-            )*\n-            )*\n-        }\n-    }\n-}\n-\"#,\n-    ).assert_expand_items(\n-        r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n-        \"impl <> Data for & \\'a mut G where G : Data {}\",\n-    );\n-}\n-\n-#[test]\n-fn expr_interpolation() {\n-    let expanded = parse_macro(\n-        r#\"\n-        macro_rules! id {\n-            ($expr:expr) => {\n-                map($expr)\n-            }\n-        }\n-        \"#,\n-    )\n-    .expand_expr(\"id!(x + foo);\");\n-\n-    assert_eq!(expanded.to_string(), \"map(x+foo)\");\n-}\n-\n pub(crate) struct MacroFixture {\n     rules: MacroRules,\n }\n@@ -1889,6 +128,37 @@ macro_rules! impl_fixture {\n impl_fixture!(MacroFixture);\n impl_fixture!(MacroFixture2);\n \n+pub(crate) fn parse_macro(ra_fixture: &str) -> MacroFixture {\n+    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n+    let rules = MacroRules::parse(&definition_tt).unwrap();\n+    MacroFixture { rules }\n+}\n+\n+pub(crate) fn parse_macro2(ra_fixture: &str) -> MacroFixture2 {\n+    let definition_tt = parse_macro_def_to_tt(ra_fixture);\n+    let rules = MacroDef::parse(&definition_tt).unwrap();\n+    MacroFixture2 { rules }\n+}\n+\n+pub(crate) fn parse_macro_error(ra_fixture: &str) -> ParseError {\n+    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n+\n+    match MacroRules::parse(&definition_tt) {\n+        Ok(_) => panic!(\"Expect error\"),\n+        Err(err) => err,\n+    }\n+}\n+\n+pub(crate) fn parse_to_token_tree_by_syntax(ra_fixture: &str) -> tt::Subtree {\n+    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n+    let tt = syntax_node_to_token_tree(source_file.syntax()).unwrap().0;\n+\n+    let parsed = parse_to_token_tree(ra_fixture).unwrap().0;\n+    assert_eq!(tt, parsed);\n+\n+    parsed\n+}\n+\n fn parse_macro_rules_to_tt(ra_fixture: &str) -> tt::Subtree {\n     let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n     let macro_definition =\n@@ -1922,37 +192,6 @@ fn parse_macro_def_to_tt(ra_fixture: &str) -> tt::Subtree {\n     definition_tt\n }\n \n-pub(crate) fn parse_macro(ra_fixture: &str) -> MacroFixture {\n-    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n-    let rules = MacroRules::parse(&definition_tt).unwrap();\n-    MacroFixture { rules }\n-}\n-\n-pub(crate) fn parse_macro2(ra_fixture: &str) -> MacroFixture2 {\n-    let definition_tt = parse_macro_def_to_tt(ra_fixture);\n-    let rules = MacroDef::parse(&definition_tt).unwrap();\n-    MacroFixture2 { rules }\n-}\n-\n-pub(crate) fn parse_macro_error(ra_fixture: &str) -> ParseError {\n-    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n-\n-    match MacroRules::parse(&definition_tt) {\n-        Ok(_) => panic!(\"Expect error\"),\n-        Err(err) => err,\n-    }\n-}\n-\n-pub(crate) fn parse_to_token_tree_by_syntax(ra_fixture: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n-    let tt = syntax_node_to_token_tree(source_file.syntax()).unwrap().0;\n-\n-    let parsed = parse_to_token_tree(ra_fixture).unwrap().0;\n-    assert_eq!(tt, parsed);\n-\n-    parsed\n-}\n-\n fn debug_dump_ignore_spaces(node: &syntax::SyntaxNode) -> String {\n     let mut level = 0;\n     let mut buf = String::new();\n@@ -1988,166 +227,3 @@ fn debug_dump_ignore_spaces(node: &syntax::SyntaxNode) -> String {\n \n     buf\n }\n-\n-#[test]\n-fn test_issue_2520() {\n-    let macro_fixture = parse_macro(\n-        r#\"\n-        macro_rules! my_macro {\n-            {\n-                ( $(\n-                    $( [] $sname:ident : $stype:ty  )?\n-                    $( [$expr:expr] $nname:ident : $ntype:ty  )?\n-                ),* )\n-            } => {\n-                Test {\n-                    $(\n-                        $( $sname, )?\n-                    )*\n-                }\n-            };\n-        }\n-    \"#,\n-    );\n-\n-    macro_fixture.assert_expand_items(\n-        r#\"my_macro ! {\n-            ([] p1 : u32 , [|_| S0K0] s : S0K0 , [] k0 : i32)\n-        }\"#,\n-        \"Test {p1 , k0 ,}\",\n-    );\n-}\n-\n-#[test]\n-fn test_issue_3861() {\n-    let macro_fixture = parse_macro(\n-        r#\"\n-        macro_rules! rgb_color {\n-            ($p:expr, $t: ty) => {\n-                pub fn new() {\n-                    let _ = 0 as $t << $p;\n-                }\n-            };\n-        }\n-    \"#,\n-    );\n-\n-    macro_fixture.expand_items(r#\"rgb_color!(8 + 8, u32);\"#);\n-}\n-\n-#[test]\n-fn test_repeat_bad_var() {\n-    // FIXME: the second rule of the macro should be removed and an error about\n-    // `$( $c )+` raised\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($( $b:ident )+) => {\n-                $( $c )+\n-            };\n-            ($( $b:ident )+) => {\n-                $( $b )+\n-            }\n-        }\n-    \"#,\n-    )\n-    .assert_expand_items(\"foo!(b0 b1);\", \"b0 b1\");\n-}\n-\n-#[test]\n-fn test_no_space_after_semi_colon() {\n-    let expanded = parse_macro(\n-        r#\"\n-        macro_rules! with_std { ($($i:item)*) => ($(#[cfg(feature = \"std\")]$i)*) }\n-    \"#,\n-    )\n-    .expand_items(r#\"with_std! {mod m;mod f;}\"#);\n-\n-    let dump = format!(\"{:#?}\", expanded);\n-    assert_eq_text!(\n-        r###\"MACRO_ITEMS@0..52\n-  MODULE@0..26\n-    ATTR@0..21\n-      POUND@0..1 \"#\"\n-      L_BRACK@1..2 \"[\"\n-      PATH@2..5\n-        PATH_SEGMENT@2..5\n-          NAME_REF@2..5\n-            IDENT@2..5 \"cfg\"\n-      TOKEN_TREE@5..20\n-        L_PAREN@5..6 \"(\"\n-        IDENT@6..13 \"feature\"\n-        EQ@13..14 \"=\"\n-        STRING@14..19 \"\\\"std\\\"\"\n-        R_PAREN@19..20 \")\"\n-      R_BRACK@20..21 \"]\"\n-    MOD_KW@21..24 \"mod\"\n-    NAME@24..25\n-      IDENT@24..25 \"m\"\n-    SEMICOLON@25..26 \";\"\n-  MODULE@26..52\n-    ATTR@26..47\n-      POUND@26..27 \"#\"\n-      L_BRACK@27..28 \"[\"\n-      PATH@28..31\n-        PATH_SEGMENT@28..31\n-          NAME_REF@28..31\n-            IDENT@28..31 \"cfg\"\n-      TOKEN_TREE@31..46\n-        L_PAREN@31..32 \"(\"\n-        IDENT@32..39 \"feature\"\n-        EQ@39..40 \"=\"\n-        STRING@40..45 \"\\\"std\\\"\"\n-        R_PAREN@45..46 \")\"\n-      R_BRACK@46..47 \"]\"\n-    MOD_KW@47..50 \"mod\"\n-    NAME@50..51\n-      IDENT@50..51 \"f\"\n-    SEMICOLON@51..52 \";\"\"###,\n-        dump.trim()\n-    );\n-}\n-\n-// https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-57597.rs\n-#[test]\n-fn test_rustc_issue_57597() {\n-    fn test_error(fixture: &str) {\n-        assert_eq!(parse_macro_error(fixture), ParseError::RepetitionEmptyTokenTree);\n-    }\n-\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)+) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)*)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)*)*)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)+) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)+)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)+)*)?) => {}; }\");\n-}\n-\n-#[test]\n-fn test_expand_bad_literal() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo { ($i:literal) => {}; }\n-    \"#,\n-    )\n-    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::BindingError(\"\".into()));\n-}\n-\n-#[test]\n-fn test_empty_comments() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! one_arg_macro { ($fmt:expr) => (); }\n-    \"#,\n-    )\n-    .assert_expand_err(\n-        r#\"one_arg_macro!(/**/)\"#,\n-        &ExpandError::BindingError(\"expected Expr\".into()),\n-    );\n-}"}, {"sha": "9dd8ff75bcad72ed207293ba7c0361a91e13fe20", "filename": "crates/mbe/src/tests/expand.rs", "status": "added", "additions": 1872, "deletions": 0, "changes": 1872, "blob_url": "https://github.com/rust-lang/rust/blob/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs?ref=80d497e5415e9826cfe0596b6be88c6733f56cb5", "patch": "@@ -0,0 +1,1872 @@\n+use ::parser::FragmentKind;\n+use syntax::{\n+    SyntaxKind::{ERROR, IDENT},\n+    T,\n+};\n+use test_utils::assert_eq_text;\n+\n+use super::*;\n+\n+// Good first issue (although a slightly challenging one):\n+//\n+// * Pick a random test from here\n+//   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n+// * Port the test to rust and add it to this module\n+// * Make it pass :-)\n+\n+#[test]\n+fn test_token_id_shift() {\n+    let expansion = parse_macro(\n+        r#\"\n+macro_rules! foobar {\n+    ($e:ident) => { foo bar $e }\n+}\n+\"#,\n+    )\n+    .expand_tt(\"foobar!(baz);\");\n+\n+    fn get_id(t: &tt::TokenTree) -> Option<u32> {\n+        if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n+            return Some(ident.id.0);\n+        }\n+        None\n+    }\n+\n+    assert_eq!(expansion.token_trees.len(), 3);\n+    // {($e:ident) => { foo bar $e }}\n+    // 012345      67 8 9   T   12\n+    assert_eq!(get_id(&expansion.token_trees[0]), Some(9));\n+    assert_eq!(get_id(&expansion.token_trees[1]), Some(10));\n+\n+    // The input args of macro call include parentheses:\n+    // (baz)\n+    // So baz should be 12+1+1\n+    assert_eq!(get_id(&expansion.token_trees[2]), Some(14));\n+}\n+\n+#[test]\n+fn test_token_map() {\n+    let expanded = parse_macro(\n+        r#\"\n+macro_rules! foobar {\n+    ($e:ident) => { fn $e() {} }\n+}\n+\"#,\n+    )\n+    .expand_tt(\"foobar!(baz);\");\n+\n+    let (node, token_map) = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap();\n+    let content = node.syntax_node().to_string();\n+\n+    let get_text = |id, kind| -> String {\n+        content[token_map.range_by_token(id).unwrap().by_kind(kind).unwrap()].to_string()\n+    };\n+\n+    assert_eq!(expanded.token_trees.len(), 4);\n+    // {($e:ident) => { fn $e() {} }}\n+    // 012345      67 8 9  T12  3\n+\n+    assert_eq!(get_text(tt::TokenId(9), IDENT), \"fn\");\n+    assert_eq!(get_text(tt::TokenId(12), T!['(']), \"(\");\n+    assert_eq!(get_text(tt::TokenId(13), T!['{']), \"{\");\n+}\n+\n+#[test]\n+fn test_convert_tt() {\n+    parse_macro(r#\"\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\"#)\n+        .assert_expand_tt(\n+            \"impl_froms!(TokenTree: Leaf, Subtree);\",\n+            \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n+             impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n+        );\n+}\n+\n+#[test]\n+fn test_convert_tt2() {\n+    parse_macro(\n+        r#\"\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\"#,\n+    )\n+    .assert_expand(\n+        \"impl_froms!(TokenTree: Leaf, Subtree);\",\n+        r#\"\n+SUBTREE $\n+  IDENT   impl 20\n+  IDENT   From 21\n+  PUNCH   < [joint] 22\n+  IDENT   Leaf 53\n+  PUNCH   > [alone] 25\n+  IDENT   for 26\n+  IDENT   TokenTree 51\n+  SUBTREE {} 29\n+    IDENT   fn 30\n+    IDENT   from 31\n+    SUBTREE () 32\n+      IDENT   it 33\n+      PUNCH   : [alone] 34\n+      IDENT   Leaf 53\n+    PUNCH   - [joint] 37\n+    PUNCH   > [alone] 38\n+    IDENT   TokenTree 51\n+    SUBTREE {} 41\n+      IDENT   TokenTree 51\n+      PUNCH   : [joint] 44\n+      PUNCH   : [joint] 45\n+      IDENT   Leaf 53\n+      SUBTREE () 48\n+        IDENT   it 49\n+  IDENT   impl 20\n+  IDENT   From 21\n+  PUNCH   < [joint] 22\n+  IDENT   Subtree 55\n+  PUNCH   > [alone] 25\n+  IDENT   for 26\n+  IDENT   TokenTree 51\n+  SUBTREE {} 29\n+    IDENT   fn 30\n+    IDENT   from 31\n+    SUBTREE () 32\n+      IDENT   it 33\n+      PUNCH   : [alone] 34\n+      IDENT   Subtree 55\n+    PUNCH   - [joint] 37\n+    PUNCH   > [alone] 38\n+    IDENT   TokenTree 51\n+    SUBTREE {} 41\n+      IDENT   TokenTree 51\n+      PUNCH   : [joint] 44\n+      PUNCH   : [joint] 45\n+      IDENT   Subtree 55\n+      SUBTREE () 48\n+        IDENT   it 49\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_lifetime_split() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:tt)*) => { $($t)*}\n+}\n+\"#,\n+    )\n+    .assert_expand(\n+        r#\"foo!(static bar: &'static str = \"hello\";);\"#,\n+        r#\"\n+SUBTREE $\n+  IDENT   static 17\n+  IDENT   bar 18\n+  PUNCH   : [alone] 19\n+  PUNCH   & [alone] 20\n+  PUNCH   ' [joint] 21\n+  IDENT   static 22\n+  IDENT   str 23\n+  PUNCH   = [alone] 24\n+  LITERAL \"hello\" 25\n+  PUNCH   ; [joint] 26\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_expr_order() {\n+    let expanded = parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i * 2; }\n+            }\n+        }\n+\"#,\n+    )\n+    .expand_items(\"foo! { 1 + 1}\");\n+\n+    let dump = format!(\"{:#?}\", expanded);\n+    assert_eq_text!(\n+        r#\"MACRO_ITEMS@0..15\n+  FN@0..15\n+    FN_KW@0..2 \"fn\"\n+    NAME@2..5\n+      IDENT@2..5 \"bar\"\n+    PARAM_LIST@5..7\n+      L_PAREN@5..6 \"(\"\n+      R_PAREN@6..7 \")\"\n+    BLOCK_EXPR@7..15\n+      L_CURLY@7..8 \"{\"\n+      EXPR_STMT@8..14\n+        BIN_EXPR@8..13\n+          BIN_EXPR@8..11\n+            LITERAL@8..9\n+              INT_NUMBER@8..9 \"1\"\n+            PLUS@9..10 \"+\"\n+            LITERAL@10..11\n+              INT_NUMBER@10..11 \"1\"\n+          STAR@11..12 \"*\"\n+          LITERAL@12..13\n+            INT_NUMBER@12..13 \"2\"\n+        SEMICOLON@13..14 \";\"\n+      R_CURLY@14..15 \"}\"\"#,\n+        dump.trim()\n+    );\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_first_token() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            (= $ i:ident) => (\n+                fn $ i() {}\n+            );\n+            (+ $ i:ident) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { = bar }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { + Baz }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_last_token() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            ($ i:ident =) => (\n+                fn $ i() {}\n+            );\n+            ($ i:ident +) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { bar = }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { Baz + }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_word_token() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            (spam $ i:ident) => (\n+                fn $ i() {}\n+            );\n+            (eggs $ i:ident) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { spam bar }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { eggs Baz }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_by_separator_token() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ($ (\n+                mod $ i {}\n+            )*);\n+            ($ ($ i:ident)#*) => ($ (\n+                fn $ i() {}\n+            )*);\n+            ($ i:ident ,# $ j:ident) => (\n+                struct $ i;\n+                struct $ j;\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"mod foo {} mod bar {}\")\n+    .assert_expand_items(\"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\")\n+    .assert_expand_items(\"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_defs() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( struct Bar { $ (\n+                fn $ i {}\n+            )*} );\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"struct Bar {fn foo {} fn bar {}}\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_statement() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( fn baz { $ (\n+                $ i ();\n+            )*} );\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_statement_without_semi() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( fn baz { $ (\n+                $i()\n+            );*} );\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n+}\n+\n+#[test]\n+fn test_match_group_empty_fixed_token() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident)* #abc) => ( fn baz { $ (\n+                $ i ();\n+            )*} );\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! {#abc}\", \"fn baz {}\");\n+}\n+\n+#[test]\n+fn test_match_group_in_subtree() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n+                $ i ();\n+            )*} );\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n+}\n+\n+#[test]\n+fn test_match_group_with_multichar_sep() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! (fn baz {true true} );\", \"fn baz () -> bool {true &&true}\");\n+}\n+\n+#[test]\n+fn test_match_group_with_multichar_sep2() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            (fn $name:ident {$($i:literal)&&*} ) => ( fn $name() -> bool { $($i)&&*} );\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! (fn baz {true && true} );\", \"fn baz () -> bool {true &&true}\");\n+}\n+\n+#[test]\n+fn test_match_group_zero_match() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ( $($i:ident)* ) => ();\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! ();\", \"\");\n+}\n+\n+#[test]\n+fn test_match_group_in_group() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! ( (a b) );\", \"(a b)\");\n+}\n+\n+#[test]\n+fn test_expand_to_item_list() {\n+    let tree = parse_macro(\n+        \"\n+            macro_rules! structs {\n+                ($($i:ident),*) => {\n+                    $(struct $i { field: u32 } )*\n+                }\n+            }\n+            \",\n+    )\n+    .expand_items(\"structs!(Foo, Bar);\");\n+    assert_eq!(\n+        format!(\"{:#?}\", tree).trim(),\n+        r#\"\n+MACRO_ITEMS@0..40\n+  STRUCT@0..20\n+    STRUCT_KW@0..6 \"struct\"\n+    NAME@6..9\n+      IDENT@6..9 \"Foo\"\n+    RECORD_FIELD_LIST@9..20\n+      L_CURLY@9..10 \"{\"\n+      RECORD_FIELD@10..19\n+        NAME@10..15\n+          IDENT@10..15 \"field\"\n+        COLON@15..16 \":\"\n+        PATH_TYPE@16..19\n+          PATH@16..19\n+            PATH_SEGMENT@16..19\n+              NAME_REF@16..19\n+                IDENT@16..19 \"u32\"\n+      R_CURLY@19..20 \"}\"\n+  STRUCT@20..40\n+    STRUCT_KW@20..26 \"struct\"\n+    NAME@26..29\n+      IDENT@26..29 \"Bar\"\n+    RECORD_FIELD_LIST@29..40\n+      L_CURLY@29..30 \"{\"\n+      RECORD_FIELD@30..39\n+        NAME@30..35\n+          IDENT@30..35 \"field\"\n+        COLON@35..36 \":\"\n+        PATH_TYPE@36..39\n+          PATH@36..39\n+            PATH_SEGMENT@36..39\n+              NAME_REF@36..39\n+                IDENT@36..39 \"u32\"\n+      R_CURLY@39..40 \"}\"\"#\n+            .trim()\n+    );\n+}\n+\n+fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n+    if let tt::TokenTree::Subtree(subtree) = tt {\n+        return &subtree;\n+    }\n+    unreachable!(\"It is not a subtree\");\n+}\n+fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n+    if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n+        return lit;\n+    }\n+    unreachable!(\"It is not a literal\");\n+}\n+\n+fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n+    if let tt::TokenTree::Leaf(tt::Leaf::Punct(lit)) = tt {\n+        return lit;\n+    }\n+    unreachable!(\"It is not a Punct\");\n+}\n+\n+#[test]\n+fn test_expand_literals_to_token_tree() {\n+    let expansion = parse_macro(\n+        r#\"\n+            macro_rules! literals {\n+                ($i:ident) => {\n+                    {\n+                        let a = 'c';\n+                        let c = 1000;\n+                        let f = 12E+99_f64;\n+                        let s = \"rust1\";\n+                    }\n+                }\n+            }\n+            \"#,\n+    )\n+    .expand_tt(\"literals!(foo);\");\n+    let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n+\n+    // [let] [a] [=] ['c'] [;]\n+    assert_eq!(to_literal(&stm_tokens[3]).text, \"'c'\");\n+    // [let] [c] [=] [1000] [;]\n+    assert_eq!(to_literal(&stm_tokens[5 + 3]).text, \"1000\");\n+    // [let] [f] [=] [12E+99_f64] [;]\n+    assert_eq!(to_literal(&stm_tokens[10 + 3]).text, \"12E+99_f64\");\n+    // [let] [s] [=] [\"rust1\"] [;]\n+    assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n+}\n+\n+#[test]\n+fn test_attr_to_token_tree() {\n+    let expansion = parse_to_token_tree_by_syntax(\n+        r#\"\n+            #[derive(Copy)]\n+            struct Foo;\n+            \"#,\n+    );\n+\n+    assert_eq!(to_punct(&expansion.token_trees[0]).char, '#');\n+    assert_eq!(\n+        to_subtree(&expansion.token_trees[1]).delimiter_kind(),\n+        Some(tt::DelimiterKind::Bracket)\n+    );\n+}\n+\n+#[test]\n+fn test_two_idents() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident, $ j:ident) => {\n+                fn foo() { let a = $ i; let b = $j; }\n+            }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n+}\n+\n+#[test]\n+fn test_tt_to_stmts() {\n+    let stmts = parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            () => {\n+                 let a = 0;\n+                 a = 10 + 1;\n+                 a\n+            }\n+        }\n+\"#,\n+    )\n+    .expand_statements(\"foo!{}\");\n+\n+    assert_eq!(\n+        format!(\"{:#?}\", stmts).trim(),\n+        r#\"MACRO_STMTS@0..15\n+  LET_STMT@0..7\n+    LET_KW@0..3 \"let\"\n+    IDENT_PAT@3..4\n+      NAME@3..4\n+        IDENT@3..4 \"a\"\n+    EQ@4..5 \"=\"\n+    LITERAL@5..6\n+      INT_NUMBER@5..6 \"0\"\n+    SEMICOLON@6..7 \";\"\n+  EXPR_STMT@7..14\n+    BIN_EXPR@7..13\n+      PATH_EXPR@7..8\n+        PATH@7..8\n+          PATH_SEGMENT@7..8\n+            NAME_REF@7..8\n+              IDENT@7..8 \"a\"\n+      EQ@8..9 \"=\"\n+      BIN_EXPR@9..13\n+        LITERAL@9..11\n+          INT_NUMBER@9..11 \"10\"\n+        PLUS@11..12 \"+\"\n+        LITERAL@12..13\n+          INT_NUMBER@12..13 \"1\"\n+    SEMICOLON@13..14 \";\"\n+  PATH_EXPR@14..15\n+    PATH@14..15\n+      PATH_SEGMENT@14..15\n+        NAME_REF@14..15\n+          IDENT@14..15 \"a\"\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_match_literal() {\n+    parse_macro(\n+        r#\"\n+    macro_rules! foo {\n+        ('(') => {\n+            fn foo() {}\n+        }\n+    }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! ['('];\", \"fn foo () {}\");\n+}\n+\n+#[test]\n+fn test_parse_macro_def_simple() {\n+    cov_mark::check!(parse_macro_def_simple);\n+\n+    parse_macro2(\n+        r#\"\n+macro foo($id:ident) {\n+    fn $id() {}\n+}\n+\"#,\n+    )\n+    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n+}\n+\n+#[test]\n+fn test_parse_macro_def_rules() {\n+    cov_mark::check!(parse_macro_def_rules);\n+\n+    parse_macro2(\n+        r#\"\n+macro foo {\n+    ($id:ident) => {\n+        fn $id() {}\n+    }\n+}\n+\"#,\n+    )\n+    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n+}\n+\n+#[test]\n+fn test_path() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path) => {\n+                fn foo() { let a = $ i; }\n+            }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo ;}\")\n+    .assert_expand_items(\n+        \"foo! { bar::<u8>::baz::<u8> }\",\n+        \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_two_paths() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path, $ j:path) => {\n+                fn foo() { let a = $ i; let b = $j; }\n+            }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n+}\n+\n+#[test]\n+fn test_path_with_path() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path) => {\n+                fn foo() { let a = $ i :: bar; }\n+            }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n+}\n+\n+#[test]\n+fn test_expr() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i; }\n+            }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\n+        \"foo! { 2 + 2 * baz(3).quux() }\",\n+        \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_last_expr() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! vec {\n+            ($($item:expr),*) => {\n+                {\n+                    let mut v = Vec::new();\n+                    $(\n+                        v.push($item);\n+                    )*\n+                    v\n+                }\n+            };\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\n+        \"vec!(1,2,3);\",\n+        \"{let mut v = Vec :: new () ; v . push (1) ; v . push (2) ; v . push (3) ; v}\",\n+    );\n+}\n+\n+#[test]\n+fn test_expr_with_attr() {\n+    parse_macro(\n+        r#\"\n+macro_rules! m {\n+    ($a:expr) => {0}\n+}\n+\"#,\n+    )\n+    .assert_expand_items(\"m!(#[allow(a)]())\", \"0\");\n+}\n+\n+#[test]\n+fn test_ty() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { Baz<u8> }\", \"fn bar () -> Baz < u8 > {unimplemented ! ()}\");\n+}\n+\n+#[test]\n+fn test_ty_with_complex_type() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+    )\n+    // Reference lifetime struct with generic type\n+    .assert_expand_items(\n+        \"foo! { &'a Baz<u8> }\",\n+        \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n+    )\n+    // extern \"Rust\" func type\n+    .assert_expand_items(\n+        r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n+        r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_pat_() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:pat) => { fn foo() { let $ i; } }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n+}\n+\n+#[test]\n+fn test_stmt() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:stmt) => (\n+                fn bar() { $ i; }\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! { 2 }\", \"fn bar () {2 ;}\")\n+    .assert_expand_items(\"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n+}\n+\n+#[test]\n+fn test_single_item() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:item) => (\n+                $ i\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\"foo! {mod c {}}\", \"mod c {}\");\n+}\n+\n+#[test]\n+fn test_all_items() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:item)*) => ($ (\n+                $ i\n+            )*)\n+        }\n+\"#,\n+    ).\n+    assert_expand_items(\n+        r#\"\n+        foo! {\n+            extern crate a;\n+            mod b;\n+            mod c {}\n+            use d;\n+            const E: i32 = 0;\n+            static F: i32 = 0;\n+            impl G {}\n+            struct H;\n+            enum I { Foo }\n+            trait J {}\n+            fn h() {}\n+            extern {}\n+            type T = u8;\n+        }\n+\"#,\n+        r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_block() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:block) => { fn foo() $ i }\n+        }\n+\"#,\n+    )\n+    .assert_expand_statements(\"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n+}\n+\n+#[test]\n+fn test_meta() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:meta) => (\n+                #[$ i]\n+                fn bar() {}\n+            )\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(\n+        r#\"foo! { cfg(target_os = \"windows\") }\"#,\n+        r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n+    )\n+    .assert_expand_items(r#\"foo! { hello::world }\"#, r#\"# [hello :: world] fn bar () {}\"#);\n+}\n+\n+#[test]\n+fn test_meta_doc_comments() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($(#[$ i:meta])+) => (\n+                $(#[$ i])+\n+                fn bar() {}\n+            )\n+        }\n+\"#,\n+    ).\n+    assert_expand_items(\n+        r#\"foo! {\n+            /// Single Line Doc 1\n+            /**\n+                MultiLines Doc\n+            */\n+        }\"#,\n+        \"# [doc = \\\" Single Line Doc 1\\\"] # [doc = \\\"\\\\\\\\n                MultiLines Doc\\\\\\\\n            \\\"] fn bar () {}\",\n+    );\n+}\n+\n+#[test]\n+fn test_meta_doc_comments_non_latin() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($(#[$ i:meta])+) => (\n+                $(#[$ i])+\n+                fn bar() {}\n+            )\n+        }\n+\"#,\n+    ).\n+    assert_expand_items(\n+        r#\"foo! {\n+            /// \u9326\u745f\u7121\u7aef\u4e94\u5341\u5f26\uff0c\u4e00\u5f26\u4e00\u67f1\u601d\u83ef\u5e74\u3002\n+            /**\n+                \u838a\u751f\u66c9\u5922\u8ff7\u8774\u8776\uff0c\u671b\u5e1d\u6625\u5fc3\u8a17\u675c\u9d51\u3002\n+            */\n+        }\"#,\n+        \"# [doc = \\\" \u9326\u745f\u7121\u7aef\u4e94\u5341\u5f26\uff0c\u4e00\u5f26\u4e00\u67f1\u601d\u83ef\u5e74\u3002\\\"] # [doc = \\\"\\\\\\\\n                \u838a\u751f\u66c9\u5922\u8ff7\u8774\u8776\uff0c\u671b\u5e1d\u6625\u5fc3\u8a17\u675c\u9d51\u3002\\\\\\\\n            \\\"] fn bar () {}\",\n+    );\n+}\n+\n+#[test]\n+fn test_tt_block() {\n+    parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                ($ i:tt) => { fn foo() $ i }\n+            }\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n+}\n+\n+#[test]\n+fn test_tt_group() {\n+    parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                 ($($ i:tt)*) => { $($ i)* }\n+            }\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n+}\n+\n+#[test]\n+fn test_tt_composite() {\n+    parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                 ($i:tt) => { 0 }\n+            }\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo! { => }\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_tt_composite2() {\n+    let node = parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                ($($tt:tt)*) => { abs!(=> $($tt)*) }\n+            }\n+    \"#,\n+    )\n+    .expand_items(r#\"foo!{#}\"#);\n+\n+    let res = format!(\"{:#?}\", &node);\n+    assert_eq_text!(\n+        r###\"MACRO_ITEMS@0..10\n+  MACRO_CALL@0..10\n+    PATH@0..3\n+      PATH_SEGMENT@0..3\n+        NAME_REF@0..3\n+          IDENT@0..3 \"abs\"\n+    BANG@3..4 \"!\"\n+    TOKEN_TREE@4..10\n+      L_PAREN@4..5 \"(\"\n+      EQ@5..6 \"=\"\n+      R_ANGLE@6..7 \">\"\n+      WHITESPACE@7..8 \" \"\n+      POUND@8..9 \"#\"\n+      R_PAREN@9..10 \")\"\"###,\n+        res.trim()\n+    );\n+}\n+\n+#[test]\n+fn test_tt_with_composite_without_space() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($ op:tt, $j:path) => (\n+                0\n+            )\n+        }\n+\"#,\n+    )\n+    // Test macro input without any spaces\n+    // See https://github.com/rust-analyzer/rust-analyzer/issues/6692\n+    .assert_expand_items(\"foo!(==,Foo::Bool)\", \"0\");\n+}\n+\n+#[test]\n+fn test_underscore() {\n+    parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                 ($_:tt) => { 0 }\n+            }\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo! { => }\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_underscore_not_greedily() {\n+    parse_macro(\n+        r#\"\n+macro_rules! q {\n+    ($($a:ident)* _) => {0};\n+}\n+\"#,\n+    )\n+    // `_` overlaps with `$a:ident` but rustc matches it under the `_` token\n+    .assert_expand_items(r#\"q![a b c d _]\"#, r#\"0\"#);\n+\n+    parse_macro(\n+        r#\"\n+macro_rules! q {\n+    ($($a:expr => $b:ident)* _ => $c:expr) => {0};\n+}\n+\"#,\n+    )\n+    // `_ => ou` overlaps with `$a:expr => $b:ident` but rustc matches it under `_ => $c:expr`\n+    .assert_expand_items(r#\"q![a => b c => d _ => ou]\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_underscore_as_type() {\n+    parse_macro(\n+        r#\"\n+macro_rules! q {\n+    ($a:ty) => {0};\n+}\n+\"#,\n+    )\n+    // Underscore is a type\n+    .assert_expand_items(r#\"q![_]\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_vertical_bar_with_pat() {\n+    parse_macro(\n+        r#\"\n+            macro_rules! foo {\n+                 (| $pat:pat | ) => { 0 }\n+            }\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo! { | x | }\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_dollar_crate_lhs_is_not_meta() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($crate) => {};\n+    () => {0};\n+}\n+    \"#,\n+    )\n+    .assert_expand_items(r#\"foo!{}\"#, r#\"0\"#);\n+}\n+\n+#[test]\n+fn test_lifetime() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n+}\n+\n+#[test]\n+fn test_literal() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!(u8,0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n+\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!(i32,-1);\"#, r#\"const VALUE : i32 = - 1 ;\"#);\n+}\n+\n+#[test]\n+fn test_boolean_is_ident() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($lit0:literal, $lit1:literal) => { const VALUE: (bool,bool) = ($lit0,$lit1); };\n+        }\n+\"#,\n+    )\n+    .assert_expand(\n+        r#\"foo!(true,false);\"#,\n+        r#\"\n+SUBTREE $\n+  IDENT   const 14\n+  IDENT   VALUE 15\n+  PUNCH   : [alone] 16\n+  SUBTREE () 17\n+    IDENT   bool 18\n+    PUNCH   , [alone] 19\n+    IDENT   bool 20\n+  PUNCH   = [alone] 21\n+  SUBTREE () 22\n+    IDENT   true 29\n+    PUNCH   , [joint] 25\n+    IDENT   false 31\n+  PUNCH   ; [alone] 28\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_vis() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n+        }\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#)\n+    // test optional cases\n+    .assert_expand_items(r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n+}\n+\n+#[test]\n+fn test_inner_macro_rules() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($a:ident, $b:ident, $c:tt) => {\n+\n+        macro_rules! bar {\n+            ($bi:ident) => {\n+                fn $bi() -> u8 {$c}\n+            }\n+        }\n+\n+        bar!($a);\n+        fn $b() -> u8 {$c}\n+    }\n+}\n+\"#,\n+    ).\n+    assert_expand_items(\n+        r#\"foo!(x,y, 1);\"#,\n+        r#\"macro_rules ! bar {($ bi : ident) => {fn $ bi () -> u8 {1}}} bar ! (x) ; fn y () -> u8 {1}\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_expr_after_path_colons() {\n+    assert!(parse_macro(\n+        r#\"\n+macro_rules! m {\n+    ($k:expr) => {\n+            f(K::$k);\n+       }\n+}\n+\"#,\n+    )\n+    .expand_statements(r#\"m!(C(\"0\"))\"#)\n+    .descendants()\n+    .find(|token| token.kind() == ERROR)\n+    .is_some());\n+}\n+\n+#[test]\n+fn test_match_is_not_greedy() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($($i:ident $(,)*),*) => {};\n+}\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!(a,b);\"#, r#\"\"#);\n+}\n+\n+// The following tests are based on real world situations\n+#[test]\n+fn test_vec() {\n+    let fixture = parse_macro(\n+        r#\"\n+         macro_rules! vec {\n+            ($($item:expr),*) => {\n+                {\n+                    let mut v = Vec::new();\n+                    $(\n+                        v.push($item);\n+                    )*\n+                    v\n+                }\n+            };\n+}\n+\"#,\n+    );\n+    fixture\n+        .assert_expand_items(r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#)\n+        .assert_expand_items(\n+            r#\"vec![1u32,2];\"#,\n+            r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n+        );\n+\n+    let tree = fixture.expand_expr(r#\"vec![1u32,2];\"#);\n+\n+    assert_eq!(\n+        format!(\"{:#?}\", tree).trim(),\n+        r#\"BLOCK_EXPR@0..45\n+  L_CURLY@0..1 \"{\"\n+  LET_STMT@1..20\n+    LET_KW@1..4 \"let\"\n+    IDENT_PAT@4..8\n+      MUT_KW@4..7 \"mut\"\n+      NAME@7..8\n+        IDENT@7..8 \"v\"\n+    EQ@8..9 \"=\"\n+    CALL_EXPR@9..19\n+      PATH_EXPR@9..17\n+        PATH@9..17\n+          PATH@9..12\n+            PATH_SEGMENT@9..12\n+              NAME_REF@9..12\n+                IDENT@9..12 \"Vec\"\n+          COLON2@12..14 \"::\"\n+          PATH_SEGMENT@14..17\n+            NAME_REF@14..17\n+              IDENT@14..17 \"new\"\n+      ARG_LIST@17..19\n+        L_PAREN@17..18 \"(\"\n+        R_PAREN@18..19 \")\"\n+    SEMICOLON@19..20 \";\"\n+  EXPR_STMT@20..33\n+    METHOD_CALL_EXPR@20..32\n+      PATH_EXPR@20..21\n+        PATH@20..21\n+          PATH_SEGMENT@20..21\n+            NAME_REF@20..21\n+              IDENT@20..21 \"v\"\n+      DOT@21..22 \".\"\n+      NAME_REF@22..26\n+        IDENT@22..26 \"push\"\n+      ARG_LIST@26..32\n+        L_PAREN@26..27 \"(\"\n+        LITERAL@27..31\n+          INT_NUMBER@27..31 \"1u32\"\n+        R_PAREN@31..32 \")\"\n+    SEMICOLON@32..33 \";\"\n+  EXPR_STMT@33..43\n+    METHOD_CALL_EXPR@33..42\n+      PATH_EXPR@33..34\n+        PATH@33..34\n+          PATH_SEGMENT@33..34\n+            NAME_REF@33..34\n+              IDENT@33..34 \"v\"\n+      DOT@34..35 \".\"\n+      NAME_REF@35..39\n+        IDENT@35..39 \"push\"\n+      ARG_LIST@39..42\n+        L_PAREN@39..40 \"(\"\n+        LITERAL@40..41\n+          INT_NUMBER@40..41 \"2\"\n+        R_PAREN@41..42 \")\"\n+    SEMICOLON@42..43 \";\"\n+  PATH_EXPR@43..44\n+    PATH@43..44\n+      PATH_SEGMENT@43..44\n+        NAME_REF@43..44\n+          IDENT@43..44 \"v\"\n+  R_CURLY@44..45 \"}\"\"#\n+    );\n+}\n+\n+#[test]\n+fn test_winapi_struct() {\n+    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n+\n+    parse_macro(\n+        r#\"\n+macro_rules! STRUCT {\n+    ($(#[$attrs:meta])* struct $name:ident {\n+        $($field:ident: $ftype:ty,)+\n+    }) => (\n+        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n+        pub struct $name {\n+            $(pub $field: $ftype,)+\n+        }\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> $name { *self }\n+        }\n+        #[cfg(feature = \"impl-default\")]\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n+        }\n+    );\n+}\n+\"#,\n+    ).\n+    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n+    assert_expand_items(r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n+    )\n+    .assert_expand_items(r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n+    );\n+}\n+\n+#[test]\n+fn test_int_base() {\n+    parse_macro(\n+        r#\"\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}\n+\"#,\n+    ).assert_expand_items(r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n+        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+    );\n+}\n+\n+#[test]\n+fn test_generate_pattern_iterators() {\n+    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n+    parse_macro(\n+        r#\"\n+macro_rules! generate_pattern_iterators {\n+        { double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+        } => {\n+            fn foo(){}\n+        }\n+}\n+\"#,\n+    ).assert_expand_items(\n+        r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n+        \"fn foo () {}\",\n+    );\n+}\n+\n+#[test]\n+fn test_impl_fn_for_zst() {\n+    // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n+    parse_macro(\n+        r#\"\n+macro_rules! impl_fn_for_zst  {\n+        {  $( $( #[$attr: meta] )*\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+$body: block; )+\n+        } => {\n+           $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+}\n+        }\n+\"#,\n+    ).assert_expand_items(r#\"\n+impl_fn_for_zst !   {\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   {\n+         c . escape_debug_ext ( false )\n+     } ;\n+\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   {\n+         c . escape_unicode ( )\n+     } ;\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   {\n+         c . escape_default ( )\n+     } ;\n+ }\n+\"#,\n+        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\"\n+    );\n+}\n+\n+#[test]\n+fn test_impl_nonzero_fmt() {\n+    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n+    parse_macro(\n+        r#\"\n+        macro_rules! impl_nonzero_fmt {\n+            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+                fn foo () {}\n+            }\n+        }\n+\"#,\n+    ).assert_expand_items(\n+        r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n+        \"fn foo () {}\",\n+    );\n+}\n+\n+#[test]\n+fn test_cfg_if_items() {\n+    // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n+    parse_macro(\n+        r#\"\n+        macro_rules! __cfg_if_items {\n+            (($($not:meta,)*) ; ) => {};\n+            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+            }\n+        }\n+\"#,\n+    ).assert_expand_items(\n+        r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n+        \"__cfg_if_items ! {(rustdoc ,) ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_cfg_if_main() {\n+    // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n+    parse_macro(\n+        r#\"\n+        macro_rules! cfg_if {\n+            ($(\n+                if #[cfg($($meta:meta),*)] { $($it:item)* }\n+            ) else * else {\n+                $($it2:item)*\n+            }) => {\n+                __cfg_if_items! {\n+                    () ;\n+                    $( ( ($($meta),*) ($($it)*) ), )*\n+                    ( () ($($it2)*) ),\n+                }\n+            };\n+\n+            // Internal macro to Apply a cfg attribute to a list of items\n+            (@__apply $m:meta, $($it:item)*) => {\n+                $(#[$m] $it)*\n+            };\n+        }\n+\"#,\n+    ).assert_expand_items(r#\"\n+cfg_if !   {\n+     if   # [ cfg ( target_env   =   \"msvc\" ) ]   {\n+         // no extra unwinder support needed\n+     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   {\n+         // no unwinder on the system!\n+     }   else   {\n+         mod   libunwind ;\n+         pub   use   libunwind :: * ;\n+     }\n+ }\n+\"#,\n+        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\"\n+    ).assert_expand_items(\n+        r#\"\n+cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n+\"#,\n+        \"\",\n+    );\n+}\n+\n+#[test]\n+fn test_proptest_arbitrary() {\n+    // from https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16\n+    parse_macro(\n+        r#\"\n+macro_rules! arbitrary {\n+    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n+        $args: ident => $logic: expr) => {\n+        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n+            type Parameters = $params;\n+            type Strategy = $strat;\n+            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n+                $logic\n+            }\n+        }\n+    };\n+\n+}\"#,\n+    ).assert_expand_items(r#\"arbitrary !   ( [ A : Arbitrary ]\n+        Vec < A > ,\n+        VecStrategy < A :: Strategy > ,\n+        RangedParams1 < A :: Parameters > ;\n+        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) }\n+    ) ;\"#,\n+    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\"\n+    );\n+}\n+\n+#[test]\n+fn test_old_ridl() {\n+    // This is from winapi 2.8, which do not have a link from github\n+    //\n+    let expanded = parse_macro(\n+        r#\"\n+#[macro_export]\n+macro_rules! RIDL {\n+    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n+        {$(\n+            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n+        ),+}\n+    ) => {\n+        impl $interface {\n+            $(pub unsafe fn $method(&mut self) -> $rtr {\n+                ((*self.lpVtbl).$method)(self $(,$p)*)\n+            })+\n+        }\n+    };\n+}\"#,\n+    ).expand_tt(r#\"\n+    RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n+        fn GetDataSize(&mut self) -> UINT\n+    }}\"#);\n+\n+    assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n+}\n+\n+#[test]\n+fn test_quick_error() {\n+    let expanded = parse_macro(\n+        r#\"\n+macro_rules! quick_error {\n+\n+ (SORT [enum $name:ident $( #[$meta:meta] )*]\n+        items [$($( #[$imeta:meta] )*\n+                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n+                                {$( $ifuncs:tt )*} )* ]\n+        buf [ ]\n+        queue [ ]\n+    ) => {\n+        quick_error!(ENUMINITION [enum $name $( #[$meta] )*]\n+            body []\n+            queue [$(\n+                $( #[$imeta] )*\n+                =>\n+                $iitem: $imode [$( $ivar: $ityp ),*]\n+            )*]\n+        );\n+};\n+\n+}\n+\"#,\n+    )\n+    .expand_tt(\n+        r#\"\n+quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n+        => One : UNIT [] {}\n+        => Two : TUPLE [s :String] {display (\"two: {}\" , s) from ()}\n+    ] buf [] queue []) ;\n+\"#,\n+    );\n+\n+    assert_eq!(expanded.to_string(), \"quick_error ! (ENUMINITION [enum Wrapped # [derive (Debug)]] body [] queue [=> One : UNIT [] => Two : TUPLE [s : String]]) ;\");\n+}\n+\n+#[test]\n+fn test_empty_repeat_vars_in_empty_repeat_vars() {\n+    parse_macro(\n+        r#\"\n+macro_rules! delegate_impl {\n+    ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n+     pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n+\n+        $(\n+        @escape [type $assoc_name_ext:ident]\n+        )*\n+        $(\n+        @section type\n+        $(\n+            $(#[$_assoc_attr:meta])*\n+            type $assoc_name:ident $(: $assoc_bound:ty)*;\n+        )+\n+        )*\n+        $(\n+        @section self\n+        $(\n+            $(#[$_method_attr:meta])*\n+            fn $method_name:ident(self $(: $self_selftype:ty)* $(,$marg:ident : $marg_ty:ty)*) -> $mret:ty;\n+        )+\n+        )*\n+        $(\n+        @section nodelegate\n+        $($tail:tt)*\n+        )*\n+    }) => {\n+        impl<> $name for $self_wrap where $self_type: $name {\n+            $(\n+            $(\n+                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) -> $mret {\n+                    $self_map!(self).$method_name($($marg),*)\n+                }\n+            )*\n+            )*\n+        }\n+    }\n+}\n+\"#,\n+    ).assert_expand_items(\n+        r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n+        \"impl <> Data for & \\'a mut G where G : Data {}\",\n+    );\n+}\n+\n+#[test]\n+fn expr_interpolation() {\n+    let expanded = parse_macro(\n+        r#\"\n+        macro_rules! id {\n+            ($expr:expr) => {\n+                map($expr)\n+            }\n+        }\n+        \"#,\n+    )\n+    .expand_expr(\"id!(x + foo);\");\n+\n+    assert_eq!(expanded.to_string(), \"map(x+foo)\");\n+}\n+\n+#[test]\n+fn test_issue_2520() {\n+    let macro_fixture = parse_macro(\n+        r#\"\n+        macro_rules! my_macro {\n+            {\n+                ( $(\n+                    $( [] $sname:ident : $stype:ty  )?\n+                    $( [$expr:expr] $nname:ident : $ntype:ty  )?\n+                ),* )\n+            } => {\n+                Test {\n+                    $(\n+                        $( $sname, )?\n+                    )*\n+                }\n+            };\n+        }\n+    \"#,\n+    );\n+\n+    macro_fixture.assert_expand_items(\n+        r#\"my_macro ! {\n+            ([] p1 : u32 , [|_| S0K0] s : S0K0 , [] k0 : i32)\n+        }\"#,\n+        \"Test {p1 , k0 ,}\",\n+    );\n+}\n+\n+#[test]\n+fn test_issue_3861() {\n+    let macro_fixture = parse_macro(\n+        r#\"\n+        macro_rules! rgb_color {\n+            ($p:expr, $t: ty) => {\n+                pub fn new() {\n+                    let _ = 0 as $t << $p;\n+                }\n+            };\n+        }\n+    \"#,\n+    );\n+\n+    macro_fixture.expand_items(r#\"rgb_color!(8 + 8, u32);\"#);\n+}\n+\n+#[test]\n+fn test_repeat_bad_var() {\n+    // FIXME: the second rule of the macro should be removed and an error about\n+    // `$( $c )+` raised\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            ($( $b:ident )+) => {\n+                $( $c )+\n+            };\n+            ($( $b:ident )+) => {\n+                $( $b )+\n+            }\n+        }\n+    \"#,\n+    )\n+    .assert_expand_items(\"foo!(b0 b1);\", \"b0 b1\");\n+}\n+\n+#[test]\n+fn test_no_space_after_semi_colon() {\n+    let expanded = parse_macro(\n+        r#\"\n+        macro_rules! with_std { ($($i:item)*) => ($(#[cfg(feature = \"std\")]$i)*) }\n+    \"#,\n+    )\n+    .expand_items(r#\"with_std! {mod m;mod f;}\"#);\n+\n+    let dump = format!(\"{:#?}\", expanded);\n+    assert_eq_text!(\n+        r###\"MACRO_ITEMS@0..52\n+  MODULE@0..26\n+    ATTR@0..21\n+      POUND@0..1 \"#\"\n+      L_BRACK@1..2 \"[\"\n+      PATH@2..5\n+        PATH_SEGMENT@2..5\n+          NAME_REF@2..5\n+            IDENT@2..5 \"cfg\"\n+      TOKEN_TREE@5..20\n+        L_PAREN@5..6 \"(\"\n+        IDENT@6..13 \"feature\"\n+        EQ@13..14 \"=\"\n+        STRING@14..19 \"\\\"std\\\"\"\n+        R_PAREN@19..20 \")\"\n+      R_BRACK@20..21 \"]\"\n+    MOD_KW@21..24 \"mod\"\n+    NAME@24..25\n+      IDENT@24..25 \"m\"\n+    SEMICOLON@25..26 \";\"\n+  MODULE@26..52\n+    ATTR@26..47\n+      POUND@26..27 \"#\"\n+      L_BRACK@27..28 \"[\"\n+      PATH@28..31\n+        PATH_SEGMENT@28..31\n+          NAME_REF@28..31\n+            IDENT@28..31 \"cfg\"\n+      TOKEN_TREE@31..46\n+        L_PAREN@31..32 \"(\"\n+        IDENT@32..39 \"feature\"\n+        EQ@39..40 \"=\"\n+        STRING@40..45 \"\\\"std\\\"\"\n+        R_PAREN@45..46 \")\"\n+      R_BRACK@46..47 \"]\"\n+    MOD_KW@47..50 \"mod\"\n+    NAME@50..51\n+      IDENT@50..51 \"f\"\n+    SEMICOLON@51..52 \";\"\"###,\n+        dump.trim()\n+    );\n+}\n+\n+// https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-57597.rs\n+#[test]\n+fn test_rustc_issue_57597() {\n+    fn test_error(fixture: &str) {\n+        assert_eq!(parse_macro_error(fixture), ParseError::RepetitionEmptyTokenTree);\n+    }\n+\n+    test_error(\"macro_rules! foo { ($($($i:ident)?)+) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($i:ident)?)*) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($i:ident)?)?) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)?) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)*)?)?) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)?) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)*) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)*)*)?) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)*) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)+) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)+)?)*) => {}; }\");\n+    test_error(\"macro_rules! foo { ($($($($i:ident)+)*)?) => {}; }\");\n+}\n+\n+#[test]\n+fn test_expand_bad_literal() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo { ($i:literal) => {}; }\n+    \"#,\n+    )\n+    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::BindingError(\"\".into()));\n+}\n+\n+#[test]\n+fn test_empty_comments() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! one_arg_macro { ($fmt:expr) => (); }\n+    \"#,\n+    )\n+    .assert_expand_err(\n+        r#\"one_arg_macro!(/**/)\"#,\n+        &ExpandError::BindingError(\"expected Expr\".into()),\n+    );\n+}"}, {"sha": "07277966d49956368efe6663ce1905e049a718c2", "filename": "crates/mbe/src/tests/rule.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d497e5415e9826cfe0596b6be88c6733f56cb5/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs?ref=80d497e5415e9826cfe0596b6be88c6733f56cb5", "patch": "@@ -0,0 +1,45 @@\n+use syntax::{ast, AstNode};\n+\n+use crate::ast_to_token_tree;\n+\n+use super::*;\n+\n+#[test]\n+fn test_valid_arms() {\n+    fn check(macro_body: &str) {\n+        let m = parse_macro_arm(macro_body);\n+        m.unwrap();\n+    }\n+\n+    check(\"($i:ident) => ()\");\n+    check(\"($($i:ident)*) => ($_)\");\n+    check(\"($($true:ident)*) => ($true)\");\n+    check(\"($($false:ident)*) => ($false)\");\n+    check(\"($) => ($)\");\n+}\n+\n+#[test]\n+fn test_invalid_arms() {\n+    fn check(macro_body: &str, err: ParseError) {\n+        let m = parse_macro_arm(macro_body);\n+        assert_eq!(m, Err(err));\n+    }\n+    check(\"invalid\", ParseError::Expected(\"expected subtree\".into()));\n+\n+    check(\"$i:ident => ()\", ParseError::Expected(\"expected subtree\".into()));\n+    check(\"($i:ident) ()\", ParseError::Expected(\"expected `=`\".into()));\n+    check(\"($($i:ident)_) => ()\", ParseError::InvalidRepeat);\n+\n+    check(\"($i) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n+    check(\"($i:) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n+}\n+\n+fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {\n+    let macro_definition = format!(\" macro_rules! m {{ {} }} \", arm_definition);\n+    let source_file = ast::SourceFile::parse(&macro_definition).ok().unwrap();\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n+    crate::MacroRules::parse(&definition_tt)\n+}"}]}