{"sha": "51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "node_id": "C_kwDOAAsO6NoAKDUxZDUwZWE5NmVjYzljNjgxYTAwNTRlNWViOGU1ZTFkNGFiMzg5MDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T01:55:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T01:55:36Z"}, "message": "Auto merge of #107083 - GuillaumeGomez:revert-104889, r=notriddle\n\nrustdoc: Revert #104889\n\nReverts #104889.\n\nI don't think I'll be able to finish https://github.com/rust-lang/rust/pull/107000 on time unfortunately so to prevent https://github.com/rust-lang/rust/issues/106373, better to revert it and to make it into the next release.\n\nr? `@notriddle`", "tree": {"sha": "1afee6642dc06404bd041f75d64b35c567cea8af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1afee6642dc06404bd041f75d64b35c567cea8af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "html_url": "https://github.com/rust-lang/rust/commit/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2bf475d01d0112ded3aa17e40cb335e1524aa8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2bf475d01d0112ded3aa17e40cb335e1524aa8f", "html_url": "https://github.com/rust-lang/rust/commit/a2bf475d01d0112ded3aa17e40cb335e1524aa8f"}, {"sha": "a22cd9cdfad00d28b7116a8ddae91f7fada7473f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a22cd9cdfad00d28b7116a8ddae91f7fada7473f", "html_url": "https://github.com/rust-lang/rust/commit/a22cd9cdfad00d28b7116a8ddae91f7fada7473f"}], "stats": {"total": 249, "additions": 56, "deletions": 193}, "files": [{"sha": "bc8badad38eb0578ea3a0b5f40310241b66eab0c", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "patch": "@@ -138,7 +138,7 @@ pub(super) fn write_shared(\n         Ok((ret, krates))\n     }\n \n-    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\ </code> format,\n+    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\</code> format,\n     /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n     ///\n     /// This forms the payload of files that look like this:"}, {"sha": "22068ebe041c729ca87e33470255f9e40c22bb3b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 48, "deletions": 115, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "patch": "@@ -5,10 +5,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{walk_item, Visitor};\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -59,34 +57,29 @@ pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool\n     false\n }\n \n+// Also, is there some reason that this doesn't use the 'visit'\n+// framework from syntax?.\n+\n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n-    modules: Vec<Module<'tcx>>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n-        let om = Module::new(\n-            cx.tcx.crate_name(LOCAL_CRATE),\n-            hir::CRATE_HIR_ID,\n-            cx.tcx.hir().root_module().spans.inner_span,\n-        );\n-\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n             inside_public_path: true,\n             exact_paths: FxHashMap::default(),\n-            modules: vec![om],\n         }\n     }\n \n@@ -96,10 +89,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub(crate) fn visit(mut self) -> Module<'tcx> {\n-        let root_module = self.cx.tcx.hir().root_module();\n-        self.visit_mod_contents(CRATE_HIR_ID, root_module);\n-\n-        let mut top_level_module = self.modules.pop().unwrap();\n+        let mut top_level_module = self.visit_mod_contents(\n+            hir::CRATE_HIR_ID,\n+            self.cx.tcx.hir().root_module(),\n+            self.cx.tcx.crate_name(LOCAL_CRATE),\n+            None,\n+        );\n \n         // `#[macro_export] macro_rules!` items are reexported at the top level of the\n         // crate, regardless of where they're defined. We want to document the\n@@ -114,13 +109,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // macro in the same module.\n         let mut inserted = FxHashSet::default();\n         for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n-            if let Res::Def(DefKind::Macro(_), def_id) = export.res &&\n-                let Some(local_def_id) = def_id.as_local() &&\n-                self.cx.tcx.has_attr(def_id, sym::macro_export) &&\n-                inserted.insert(def_id)\n-            {\n-                    let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                    top_level_module.items.push((item, None, None));\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n+                if let Some(local_def_id) = def_id.as_local() {\n+                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n+                        if inserted.insert(def_id) {\n+                            let item = self.cx.tcx.hir().expect_item(local_def_id);\n+                            top_level_module.items.push((item, None, None));\n+                        }\n+                    }\n+                }\n             }\n         }\n \n@@ -154,34 +151,36 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         top_level_module\n     }\n \n-    /// This method will go through the given module items in two passes:\n-    /// 1. The items which are not glob imports/reexports.\n-    /// 2. The glob imports/reexports.\n-    fn visit_mod_contents(&mut self, id: hir::HirId, m: &'tcx hir::Mod<'tcx>) {\n-        debug!(\"Going through module {:?}\", m);\n+    fn visit_mod_contents(\n+        &mut self,\n+        id: hir::HirId,\n+        m: &'tcx hir::Mod<'tcx>,\n+        name: Symbol,\n+        parent_id: Option<hir::HirId>,\n+    ) -> Module<'tcx> {\n+        let mut om = Module::new(name, id, m.spans.inner_span);\n         let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= self.cx.tcx.visibility(def_id).is_public();\n-\n-        // Reimplementation of `walk_mod` because we need to do it in two passes (explanations in\n-        // the second loop):\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n-            if !matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item);\n+            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+                continue;\n             }\n+            self.visit_item(item, None, &mut om, parent_id);\n         }\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             // To match the way import precedence works, visit glob imports last.\n             // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n             // imported items appear last, then they'll be the ones that get discarded.\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item);\n+                self.visit_item(item, None, &mut om, parent_id);\n             }\n         }\n         self.inside_public_path = orig_inside_public_path;\n+        om\n     }\n \n     /// Tries to resolve the target of a `pub use` statement and inlines the\n@@ -199,6 +198,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n+        om: &mut Module<'tcx>,\n         please_inline: bool,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n@@ -249,20 +249,20 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item_inner(i, None, Some(id));\n+                    self.visit_item(i, None, om, Some(id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item_inner(it, renamed, Some(id));\n+                self.visit_item(it, renamed, om, Some(id));\n                 self.inlining = prev;\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_foreign_item_inner(it, renamed);\n+                self.visit_foreign_item(it, renamed, om);\n                 self.inlining = prev;\n                 true\n             }\n@@ -272,22 +272,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    #[inline]\n-    fn add_to_current_mod(\n+    fn visit_item(\n         &mut self,\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n+        om: &mut Module<'tcx>,\n         parent_id: Option<hir::HirId>,\n     ) {\n-        self.modules.last_mut().unwrap().items.push((item, renamed, parent_id))\n-    }\n-\n-    fn visit_item_inner(\n-        &mut self,\n-        item: &'tcx hir::Item<'_>,\n-        renamed: Option<Symbol>,\n-        parent_id: Option<hir::HirId>,\n-    ) -> bool {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n \n@@ -302,7 +293,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for item in items {\n                     let item = self.cx.tcx.hir().foreign_item(item.id);\n-                    self.visit_foreign_item_inner(item, None);\n+                    self.visit_foreign_item(item, None, om);\n                 }\n             }\n             // If we're inlining, skip private items or item reexported as \"_\".\n@@ -335,13 +326,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             res,\n                             ident,\n                             is_glob,\n+                            om,\n                             please_inline,\n                         ) {\n                             continue;\n                         }\n                     }\n \n-                    self.add_to_current_mod(item, renamed, parent_id);\n+                    om.items.push((item, renamed, parent_id))\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n@@ -361,11 +353,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    self.add_to_current_mod(item, renamed, None);\n+                    om.items.push((item, renamed, None));\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                self.enter_mod(item.hir_id(), m, name);\n+                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name, parent_id));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -376,92 +368,33 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => {\n-                self.add_to_current_mod(item, renamed, parent_id);\n-            }\n+            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    self.add_to_current_mod(item, renamed, parent_id);\n+                    om.items.push((item, renamed, parent_id));\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    self.add_to_current_mod(item, None, None);\n+                    om.items.push((item, None, None));\n                 }\n             }\n         }\n-        true\n     }\n \n-    fn visit_foreign_item_inner(\n+    fn visit_foreign_item(\n         &mut self,\n         item: &'tcx hir::ForeignItem<'_>,\n         renamed: Option<Symbol>,\n+        om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n         if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n-            self.modules.last_mut().unwrap().foreigns.push((item, renamed));\n+            om.foreigns.push((item, renamed));\n         }\n     }\n-\n-    /// This method will create a new module and push it onto the \"modules stack\" then call\n-    /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n-    /// add into the list of modules of the current module.\n-    fn enter_mod(&mut self, id: hir::HirId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n-        self.modules.push(Module::new(name, id, m.spans.inner_span));\n-\n-        self.visit_mod_contents(id, m);\n-\n-        let last = self.modules.pop().unwrap();\n-        self.modules.last_mut().unwrap().mods.push(last);\n-    }\n-}\n-\n-// We need to implement this visitor so it'll go everywhere and retrieve items we're interested in\n-// such as impl blocks in const blocks.\n-impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n-        let parent_id = if self.modules.len() > 1 {\n-            Some(self.modules[self.modules.len() - 2].id)\n-        } else {\n-            None\n-        };\n-        if self.visit_item_inner(i, None, parent_id) {\n-            walk_item(self, i);\n-        }\n-    }\n-\n-    fn visit_mod(&mut self, _: &hir::Mod<'tcx>, _: Span, _: hir::HirId) {\n-        // Handled in `visit_item_inner`\n-    }\n-\n-    fn visit_use(&mut self, _: &hir::UsePath<'tcx>, _: hir::HirId) {\n-        // Handled in `visit_item_inner`\n-    }\n-\n-    fn visit_path(&mut self, _: &hir::Path<'tcx>, _: hir::HirId) {\n-        // Handled in `visit_item_inner`\n-    }\n-\n-    fn visit_label(&mut self, _: &rustc_ast::Label) {\n-        // Unneeded.\n-    }\n-\n-    fn visit_infer(&mut self, _: &hir::InferArg) {\n-        // Unneeded.\n-    }\n-\n-    fn visit_lifetime(&mut self, _: &hir::Lifetime) {\n-        // Unneeded.\n-    }\n }"}, {"sha": "4b1e04234c870594bcaaf458bb9b2fbe39507c8c", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait-return.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs?ref=51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "patch": "@@ -1,10 +1,12 @@\n+// check-pass\n // normalize-stderr-test: \"`.*`\" -> \"`DEF_ID`\"\n // normalize-stdout-test: \"`.*`\" -> \"`DEF_ID`\"\n // edition:2018\n \n pub async fn f() -> impl std::fmt::Debug {\n+    // rustdoc doesn't care that this is infinitely sized\n     #[derive(Debug)]\n-    enum E { //~ ERROR\n+    enum E {\n         This(E),\n         Unit,\n     }"}, {"sha": "aff7402bc91c65b931304009dae9a059fafe10b3", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait-return.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr?ref=a2bf475d01d0112ded3aa17e40cb335e1524aa8f", "patch": "@@ -1,16 +0,0 @@\n-error[E0072]: recursive type `DEF_ID` has infinite size\n-  --> $DIR/infinite-recursive-type-impl-trait-return.rs:7:5\n-   |\n-LL |     enum E {\n-   |     ^^^^^^\n-LL |         This(E),\n-   |              - recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `DEF_ID`) to break the cycle\n-   |\n-LL |         This(Box<E>),\n-   |              ++++ +\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `DEF_ID`."}, {"sha": "ac79582fb3f0df48e75c11cc1101e0d9f99ac5bc", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs?ref=51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "patch": "@@ -1,5 +1,8 @@\n+// check-pass\n+\n fn f() -> impl Sized {\n-    enum E { //~ ERROR\n+    // rustdoc doesn't care that this is infinitely sized\n+    enum E {\n         V(E),\n     }\n     unimplemented!()"}, {"sha": "a61577bd14afce57afb9e4adabdeb9329774a656", "filename": "tests/rustdoc-ui/infinite-recursive-type-impl-trait.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr?ref=a2bf475d01d0112ded3aa17e40cb335e1524aa8f", "patch": "@@ -1,16 +0,0 @@\n-error[E0072]: recursive type `f::E` has infinite size\n-  --> $DIR/infinite-recursive-type-impl-trait.rs:2:5\n-   |\n-LL |     enum E {\n-   |     ^^^^^^\n-LL |         V(E),\n-   |           - recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n-   |\n-LL |         V(Box<E>),\n-   |           ++++ +\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0072`."}, {"sha": "b44e713524668d6dcdd11cd9b4f30be5b221f51a", "filename": "tests/rustdoc/impl-in-const-block.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc%2Fimpl-in-const-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2bf475d01d0112ded3aa17e40cb335e1524aa8f/tests%2Frustdoc%2Fimpl-in-const-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fimpl-in-const-block.rs?ref=a2bf475d01d0112ded3aa17e40cb335e1524aa8f", "patch": "@@ -1,43 +0,0 @@\n-// Regression test for #83026.\n-// The goal of this test is to ensure that impl blocks inside\n-// const expressions are documented as well.\n-\n-#![crate_name = \"foo\"]\n-\n-// @has 'foo/struct.A.html'\n-// @has - '//*[@id=\"method.new\"]/*[@class=\"code-header\"]' 'pub fn new() -> A'\n-// @has - '//*[@id=\"method.bar\"]/*[@class=\"code-header\"]' 'pub fn bar(&self)'\n-// @has - '//*[@id=\"method.woo\"]/*[@class=\"code-header\"]' 'pub fn woo(&self)'\n-// @has - '//*[@id=\"method.yoo\"]/*[@class=\"code-header\"]' 'pub fn yoo()'\n-// @has - '//*[@id=\"method.yuu\"]/*[@class=\"code-header\"]' 'pub fn yuu()'\n-pub struct A;\n-\n-const _: () = {\n-    impl A {\n-        const FOO: () = {\n-            impl A {\n-                pub fn woo(&self) {}\n-            }\n-        };\n-\n-        pub fn new() -> A {\n-            A\n-        }\n-    }\n-};\n-pub const X: () = {\n-    impl A {\n-        pub fn bar(&self) {}\n-    }\n-};\n-\n-fn foo() {\n-    impl A {\n-        pub fn yoo() {}\n-    }\n-    const _: () = {\n-        impl A {\n-            pub fn yuu() {}\n-        }\n-    };\n-}"}]}