{"sha": "ce4afed2efdaaceb2624021df3a8d8fff892415a", "node_id": "C_kwDOAAsO6NoAKGNlNGFmZWQyZWZkYWFjZWIyNjI0MDIxZGYzYThkOGZmZjg5MjQxNWE", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-05T23:44:10Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-06T21:00:49Z"}, "message": "comments feedback", "tree": {"sha": "328dda732f03d80586e7fe07dc44eb8c2ff54115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328dda732f03d80586e7fe07dc44eb8c2ff54115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce4afed2efdaaceb2624021df3a8d8fff892415a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4afed2efdaaceb2624021df3a8d8fff892415a", "html_url": "https://github.com/rust-lang/rust/commit/ce4afed2efdaaceb2624021df3a8d8fff892415a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce4afed2efdaaceb2624021df3a8d8fff892415a/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a0a6132a8f4f3d54971c11c74035c5872a72a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0a6132a8f4f3d54971c11c74035c5872a72a1f", "html_url": "https://github.com/rust-lang/rust/commit/1a0a6132a8f4f3d54971c11c74035c5872a72a1f"}], "stats": {"total": 101, "additions": 51, "deletions": 50}, "files": [{"sha": "727bdc391bb41ec304ee86a484493a6c819be8df", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ce4afed2efdaaceb2624021df3a8d8fff892415a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4afed2efdaaceb2624021df3a8d8fff892415a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ce4afed2efdaaceb2624021df3a8d8fff892415a", "patch": "@@ -211,10 +211,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    );\n+    ) -> bool;\n \n     fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool;\n \n@@ -1112,60 +1115,58 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        let span = obligation.cause.span;\n-        let body_id = obligation.cause.body_id;\n         let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n         let ty = self.tcx.erase_late_bound_regions(self_ty);\n-        let owner = self.tcx.hir().get_parent_item(body_id);\n-        if let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code() &&\n-            let arg_node = self.tcx.hir().get(*arg_hir_id) &&\n-            let Node::Expr(Expr { kind: hir::ExprKind::Path(_), ..}) = arg_node &&\n-            let Some(generics) = self.tcx.hir().get_generics(owner.def_id) &&\n-            let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() &&\n-            let ty::Param(param) = inner_ty.kind() &&\n-            let Some(generic_param) =\n-                    generics.params.iter().find(|p| p.name.ident().as_str() == param.name.as_str())\n-        {\n-            let clone_trait = self.tcx.require_lang_item(LangItem::Clone, None);\n-            let has_clone = self\n-                .type_implements_trait(clone_trait, [ty], obligation.param_env)\n-                .must_apply_modulo_regions();\n-\n-            let trait_pred_and_suggested_ty =\n-                trait_pred.map_bound(|trait_pred| (trait_pred, *inner_ty));\n-            let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n-                    obligation.param_env,\n-                    trait_pred_and_suggested_ty,\n-            );\n+        let owner = self.tcx.hir().get_parent_item(obligation.cause.body_id);\n+        let Some(generics) = self.tcx.hir().get_generics(owner.def_id) else { return false };\n+        let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n+        let ty::Param(param) = inner_ty.kind() else { return false };\n+        let Some(generic_param) = generics.get_named(param.name) else { return false };\n+        let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code() else { return false };\n+        let arg_node = self.tcx.hir().get(*arg_hir_id);\n+        let Node::Expr(Expr { kind: hir::ExprKind::Path(_), ..}) = arg_node else { return false };\n+\n+        let clone_trait = self.tcx.require_lang_item(LangItem::Clone, None);\n+        let has_clone = self\n+            .type_implements_trait(clone_trait, [ty], obligation.param_env)\n+            .must_apply_modulo_regions();\n+\n+        let trait_pred_and_suggested_ty =\n+            trait_pred.map_bound(|trait_pred| (trait_pred, *inner_ty));\n+        let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n+            obligation.param_env,\n+            trait_pred_and_suggested_ty,\n+        );\n \n-            if  has_clone && self.predicate_may_hold(&new_obligation) {\n-                let clone_bound = generics.bounds_for_param(generic_param.def_id)\n-                                                    .flat_map(|bp| bp.bounds)\n-                                                    .any(|bound| {\n-                    if let hir::GenericBound::Trait( hir::PolyTraitRef { trait_ref, ..}, ..) = bound {\n-                            Some(clone_trait) == trait_ref.trait_def_id()\n-                        } else {\n-                            false\n-                        }\n-                    });\n-                if !clone_bound {\n-                    suggest_constraining_type_param(\n-                        self.tcx,\n-                        generics,\n-                        err,\n-                        param.name.as_str(),\n-                        \"Clone\",\n-                        Some(clone_trait)\n-                    );\n-                }\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"consider using clone here\",\n-                    \".clone()\".to_string(),\n-                    Applicability::MaybeIncorrect,\n+        if has_clone && self.predicate_may_hold(&new_obligation) {\n+            let clone_bound = generics\n+                .bounds_for_param(generic_param.def_id)\n+                .flat_map(|bp| bp.bounds)\n+                .any(|bound| {\n+                    if let hir::GenericBound::Trait(hir::PolyTraitRef { trait_ref, .. }, ..) = bound\n+                    {\n+                        Some(clone_trait) == trait_ref.trait_def_id()\n+                    } else {\n+                        false\n+                    }\n+                });\n+            if !clone_bound {\n+                suggest_constraining_type_param(\n+                    self.tcx,\n+                    generics,\n+                    err,\n+                    param.name.as_str(),\n+                    \"Clone\",\n+                    Some(clone_trait),\n                 );\n-                return true;\n             }\n+            err.span_suggestion_verbose(\n+                obligation.cause.span.shrink_to_hi(),\n+                \"consider using clone here\",\n+                \".clone()\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n         }\n         false\n     }"}]}