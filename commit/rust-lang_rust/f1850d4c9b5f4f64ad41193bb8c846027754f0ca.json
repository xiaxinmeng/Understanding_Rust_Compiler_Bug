{"sha": "f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "node_id": "C_kwDOAAsO6NoAKGYxODUwZDRjOWI1ZjRmNjRhZDQxMTkzYmI4Yzg0NjAyNzc1NGYwY2E", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-29T10:58:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-29T19:36:56Z"}, "message": "rustc_middle: Remove unnecessary type parameter from `AccessLevels`", "tree": {"sha": "0e13d7970c9329bf7fd91dc949a18755a7e487b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e13d7970c9329bf7fd91dc949a18755a7e487b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "html_url": "https://github.com/rust-lang/rust/commit/f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1850d4c9b5f4f64ad41193bb8c846027754f0ca/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90f27f93bdb9e3033faf87ad0b813d3faf077285", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f27f93bdb9e3033faf87ad0b813d3faf077285", "html_url": "https://github.com/rust-lang/rust/commit/90f27f93bdb9e3033faf87ad0b813d3faf077285"}], "stats": {"total": 48, "additions": 16, "deletions": 32}, "files": [{"sha": "ffbd6d10da6b20aaeee2c63541bd04aafa2fac88", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1850d4c9b5f4f64ad41193bb8c846027754f0ca/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1850d4c9b5f4f64ad41193bb8c846027754f0ca/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=f1850d4c9b5f4f64ad41193bb8c846027754f0ca", "patch": "@@ -6,8 +6,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::{DefId, LocalDefId};\n-use std::hash::Hash;\n+use rustc_span::def_id::LocalDefId;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -75,33 +74,33 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Debug, Clone)]\n-pub struct EffectiveVisibilities<Id = LocalDefId> {\n-    map: FxHashMap<Id, EffectiveVisibility>,\n+#[derive(Default, Clone, Debug)]\n+pub struct EffectiveVisibilities {\n+    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n }\n \n-impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n-    pub fn is_public_at_level(&self, id: Id, level: Level) -> bool {\n+impl EffectiveVisibilities {\n+    pub fn is_public_at_level(&self, id: LocalDefId, level: Level) -> bool {\n         self.effective_vis(id)\n             .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n     /// See `Level::Reachable`.\n-    pub fn is_reachable(&self, id: Id) -> bool {\n+    pub fn is_reachable(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reachable)\n     }\n \n     /// See `Level::Reexported`.\n-    pub fn is_exported(&self, id: Id) -> bool {\n+    pub fn is_exported(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reexported)\n     }\n \n     /// See `Level::Direct`.\n-    pub fn is_directly_public(&self, id: Id) -> bool {\n+    pub fn is_directly_public(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Direct)\n     }\n \n-    pub fn public_at_level(&self, id: Id) -> Option<Level> {\n+    pub fn public_at_level(&self, id: LocalDefId) -> Option<Level> {\n         self.effective_vis(id).and_then(|effective_vis| {\n             for level in Level::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n@@ -112,24 +111,17 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n \n-    pub fn map_id<OutId: Hash + Eq + Copy>(\n-        &self,\n-        f: impl Fn(Id) -> OutId,\n-    ) -> EffectiveVisibilities<OutId> {\n-        EffectiveVisibilities { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n-    }\n-\n     pub fn set_public_at_level(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         default_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n@@ -144,23 +136,21 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         }\n         self.map.insert(id, effective_vis);\n     }\n-}\n \n-impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         nominal_vis: Visibility,\n         default_vis: impl FnOnce() -> Visibility,\n-        parent_id: Id,\n+        parent_id: LocalDefId,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n         let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.into().is_crate_root() {\n+            if id.is_top_level_module() {\n                 EffectiveVisibility::from_vis(Visibility::Public)\n             } else {\n                 EffectiveVisibility::from_vis(default_vis())\n@@ -204,12 +194,6 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     }\n }\n \n-impl<Id> Default for EffectiveVisibilities<Id> {\n-    fn default() -> Self {\n-        EffectiveVisibilities { map: Default::default() }\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}]}