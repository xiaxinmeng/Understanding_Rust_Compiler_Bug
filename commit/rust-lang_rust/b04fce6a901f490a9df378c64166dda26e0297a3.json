{"sha": "b04fce6a901f490a9df378c64166dda26e0297a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNGZjZTZhOTAxZjQ5MGE5ZGYzNzhjNjQxNjZkZGEyNmUwMjk3YTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T22:30:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T22:30:01Z"}, "message": "Merge remote-tracking branch 'brson/io-upstream' into incoming\n\nConflicts:\n\tsrc/libcore/logging.rs\n\tsrc/libcore/rt/local_services.rs\n\tsrc/libcore/rt/uv/mod.rs\n\tsrc/libcore/rt/uv/net.rs\n\tsrc/libcore/rt/uv/uvio.rs\n\tsrc/libcore/unstable.rs", "tree": {"sha": "d4c9a3489ee38b1cd9c4318b54b32663aedf8c17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4c9a3489ee38b1cd9c4318b54b32663aedf8c17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b04fce6a901f490a9df378c64166dda26e0297a3", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b04fce6a901f490a9df378c64166dda26e0297a3", "html_url": "https://github.com/rust-lang/rust/commit/b04fce6a901f490a9df378c64166dda26e0297a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b04fce6a901f490a9df378c64166dda26e0297a3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "043d02213e19c5a5cffb781e5a11accbe28bf0de", "url": "https://api.github.com/repos/rust-lang/rust/commits/043d02213e19c5a5cffb781e5a11accbe28bf0de", "html_url": "https://github.com/rust-lang/rust/commit/043d02213e19c5a5cffb781e5a11accbe28bf0de"}, {"sha": "ee0ce64d9db10aebc491454b6595d6edf69fe513", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0ce64d9db10aebc491454b6595d6edf69fe513", "html_url": "https://github.com/rust-lang/rust/commit/ee0ce64d9db10aebc491454b6595d6edf69fe513"}], "stats": {"total": 2212, "additions": 1552, "deletions": 660}, "files": [{"sha": "eb94e9ca0286962293d31861eb7930c5158fb04c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -205,8 +205,11 @@ mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n mod stackwalk;\n+\n+// XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n+// but name resolution doesn't work without it being pub.\n #[path = \"rt/mod.rs\"]\n-mod rt;\n+pub mod rt;\n \n // A curious inner-module that's not exported that contains the binding\n // 'core' so that macro-expanded references to core::error and such"}, {"sha": "b192333999ac46be29cead81ec737d6108771a89", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -10,17 +10,16 @@\n \n //! Logging\n \n-pub mod rustrt {\n-    use libc;\n-\n-    pub extern {\n-        unsafe fn rust_log_console_on();\n-        unsafe fn rust_log_console_off();\n-        unsafe fn rust_log_str(level: u32,\n-                               string: *libc::c_char,\n-                               size: libc::size_t);\n-    }\n-}\n+use option::*;\n+use either::*;\n+use rt;\n+use rt::logging::{Logger, StdErrLogger};\n+use io;\n+use libc;\n+use repr;\n+use vec;\n+use cast;\n+use str;\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -55,8 +54,46 @@ pub fn log_type<T>(level: u32, object: &T) {\n     let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n+\n+    match rt::context() {\n+        rt::OldTaskContext => {\n+            unsafe {\n+                let len = bytes.len() as libc::size_t;\n+                rustrt::rust_log_str(level, cast::transmute(vec::raw::to_ptr(bytes)), len);\n+            }\n+        }\n+        _ => {\n+            // XXX: Bad allocation\n+            let msg = str::from_bytes(bytes);\n+            newsched_log_str(msg);\n+        }\n+    }\n+}\n+\n+fn newsched_log_str(msg: ~str) {\n     unsafe {\n-        let len = bytes.len() as libc::size_t;\n-        rustrt::rust_log_str(level, transmute(vec::raw::to_ptr(bytes)), len);\n+        match rt::local_services::unsafe_try_borrow_local_services() {\n+            Some(local) => {\n+                // Use the available logger\n+                (*local).logger.log(Left(msg));\n+            }\n+            None => {\n+                // There is no logger anywhere, just write to stderr\n+                let mut logger = StdErrLogger;\n+                logger.log(Left(msg));\n+            }\n+        }\n+    }\n+}\n+\n+pub mod rustrt {\n+    use libc;\n+\n+    pub extern {\n+        unsafe fn rust_log_console_on();\n+        unsafe fn rust_log_console_off();\n+        unsafe fn rust_log_str(level: u32,\n+                               string: *libc::c_char,\n+                               size: libc::size_t);\n     }\n }"}, {"sha": "fda48b6ffb7d9140c845846ab0b90fefb5d26651", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -30,10 +30,24 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+macro_rules! rtassert (\n+    ( $arg:expr ) => ( {\n+        if !$arg {\n+            abort!(\"assertion failed: %s\", stringify!($arg));\n+        }\n+    } )\n+)\n+\n macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);\n \n-        unsafe { ::libc::abort(); }\n+        do_abort();\n+\n+        // NB: This is in a fn to avoid putting the `unsafe` block in a macro,\n+        // which causes spurious 'unnecessary unsafe block' warnings.\n+        fn do_abort() -> ! {\n+            unsafe { ::libc::abort(); }\n+        }\n     } )\n )"}, {"sha": "93319efa3b7617975f1c3cbb3e4d6fea4b9d6e0c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -722,7 +722,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             use os::win32::{\n                 as_utf16_p\n             };\n-            use unstable::exchange_alloc::{malloc_raw, free_raw};\n+            use rt::global_heap::{malloc_raw, free_raw};\n             #[nolink]\n             extern {\n                 unsafe fn rust_list_dir_wfd_size() -> libc::size_t;"}, {"sha": "9c1612884f044524d58f762a42ad852e8e15480c", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -111,9 +111,9 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint; }\n+    unsafe { *sp = arg as uint };\n     let sp = mut_offset(sp, -1);\n-    unsafe { *sp = 0; } // The final return address\n+    unsafe { *sp = 0 }; // The final return address\n \n     regs.esp = sp as u32;\n     regs.eip = fptr as u32;\n@@ -195,7 +195,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n \n fn align_down(sp: *mut uint) -> *mut uint {\n     unsafe {\n-        let sp = transmute::<*mut uint, uint>(sp);\n+        let sp: uint = transmute(sp);\n         let sp = sp & !(16 - 1);\n         transmute::<uint, *mut uint>(sp)\n     }"}, {"sha": "3b35c2fb8047fa3b0c476a484c92773d4edcf23c", "filename": "src/libcore/rt/global_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fglobal_heap.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "previous_filename": "src/libcore/unstable/exchange_alloc.rs"}, {"sha": "1f61cf25fbdd4dc52596aea401a6071e2ed648fe", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n use super::support::PathLike;\n-use super::{Reader, Writer, Seek, Close};\n+use super::{Reader, Writer, Seek};\n use super::SeekStyle;\n \n /// # XXX\n@@ -69,10 +69,6 @@ impl Seek for FileStream {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl Close for FileStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n #[test]\n #[ignore]\n fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {"}, {"sha": "8f56005d0a4f66d8f3f20be736edc5a92777ec18", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -238,6 +238,7 @@ Out of scope\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n * Using conditions is a big unknown since we don't have much experience with them\n+* Too many uses of OtherIoError\n \n */\n \n@@ -252,7 +253,9 @@ pub use self::stdio::println;\n \n pub use self::file::FileStream;\n pub use self::net::ip::IpAddr;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpListener;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n@@ -266,6 +269,7 @@ pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n pub mod net {\n+    #[cfg(not(stage0))]\n     pub mod tcp;\n     pub mod udp;\n     pub mod ip;\n@@ -326,12 +330,14 @@ pub struct IoError {\n \n #[deriving(Eq)]\n pub enum IoErrorKind {\n+    PreviousIoError,\n+    OtherIoError,\n+    EndOfFile,\n     FileNotFound,\n-    FilePermission,\n+    PermissionDenied,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError,\n-    PreviousIoError\n+    ConnectionRefused,\n }\n \n // XXX: Can't put doc comments on macros\n@@ -383,16 +389,7 @@ pub trait Writer {\n     fn flush(&mut self);\n }\n \n-/// I/O types that may be closed\n-///\n-/// Any further operations performed on a closed resource will raise\n-/// on `io_error`\n-pub trait Close {\n-    /// Close the I/O resource\n-    fn close(&mut self);\n-}\n-\n-pub trait Stream: Reader + Writer + Close { }\n+pub trait Stream: Reader + Writer { }\n \n pub enum SeekStyle {\n     /// Seek from the beginning of the stream"}, {"sha": "31c90336a24c28abe506d86dffd6a13d2cd40765", "filename": "src/libcore/rt/io/native/file.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -40,10 +40,6 @@ impl Writer for FileDesc {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for FileDesc {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for FileDesc {\n     fn tell(&self) -> u64 { fail!() }\n \n@@ -72,10 +68,6 @@ impl Writer for CFile {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for CFile {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for CFile {\n     fn tell(&self) -> u64 { fail!() }\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }"}, {"sha": "b4c021ed28ffe6a25e48a79900fa271400b2a783", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 230, "deletions": 24, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -8,67 +8,273 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::super::*;\n-use super::ip::IpAddr;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::sched::local_sched::unsafe_borrow_io;\n+use rt::io::net::ip::IpAddr;\n+use rt::io::{Reader, Writer, Listener};\n+use rt::io::io_error;\n+use rt::rtio::{IoFactory,\n+               RtioTcpListener, RtioTcpListenerObject,\n+               RtioTcpStream, RtioTcpStreamObject};\n \n-pub struct TcpStream;\n+pub struct TcpStream {\n+    rtstream: ~RtioTcpStreamObject\n+}\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n-        fail!()\n+    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n+        TcpStream {\n+            rtstream: s\n+        }\n+    }\n+\n+    pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n+        let stream = unsafe {\n+            rtdebug!(\"borrowing io to connect\");\n+            let io = unsafe_borrow_io();\n+            rtdebug!(\"about to connect\");\n+            (*io).tcp_connect(addr)\n+        };\n+\n+        match stream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to connect: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let bytes_read = self.rtstream.read(buf);\n+        match bytes_read {\n+            Ok(read) => Some(read),\n+            Err(_) => {\n+                abort!(\"XXX\");\n+            }\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        let res = self.rtstream.write(buf);\n+        match res {\n+            Ok(_) => (),\n+            Err(_) => {\n+                abort!(\"XXX\");\n+            }\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for TcpStream {\n-    fn close(&mut self) { fail!() }\n+pub struct TcpListener {\n+    rtlistener: ~RtioTcpListenerObject,\n }\n \n-pub struct TcpListener;\n-\n impl TcpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n-        fail!()\n+    pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n+        let listener = unsafe { (*unsafe_borrow_io()).tcp_bind(addr) };\n+        match listener {\n+            Ok(l) => {\n+                Some(TcpListener {\n+                    rtlistener: l\n+                })\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n-    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+    fn accept(&mut self) -> Option<TcpStream> {\n+        let rtstream = self.rtlistener.accept();\n+        match rtstream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(_) => {\n+                abort!(\"XXX\");\n+            }\n+        }\n+    }\n }\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n+    use int;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::io::net::ip::Ipv4;\n+    use rt::io::*;\n \n     #[test] #[ignore]\n+    fn bind_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let listener = TcpListener::bind(addr);\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == ConnectionRefused);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let stream = TcpStream::connect(addr);\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n     fn smoke_test() {\n-        /*do run_in_newsched_task {\n+        do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawn_immediately {\n-                let listener = TcpListener::bind(addr);\n-                do listener.accept() {\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n+            }\n+\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            let max = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for max.times {\n+                    let mut stream = listener.accept();\n                     let mut buf = [0];\n-                    listener.read(buf);\n+                    stream.read(buf);\n                     assert!(buf[0] == 99);\n                 }\n             }\n \n-            do spawn_immediately {\n-                let stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+            do spawntask_immediately {\n+                for max.times {\n+                    let mut stream = TcpStream::connect(addr);\n+                    stream.write([99]);\n+                }\n             }\n-        }*/\n+        }\n     }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "bb5457e334ddaf3303ce07ba65f4121e6765db44", "filename": "src/libcore/rt/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -32,10 +32,6 @@ impl Writer for UdpStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UdpStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UdpListener;\n \n impl UdpListener {"}, {"sha": "b85b7dd059d82f7f1cefd6cae9ac2636d2031858", "filename": "src/libcore/rt/io/net/unix.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -32,10 +32,6 @@ impl Writer for UnixStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UnixStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UnixListener;\n \n impl UnixListener {"}, {"sha": "247fe9544088bfa54984725fed476bf9a83d95f4", "filename": "src/libcore/rt/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::{Reader, Writer, Close};\n+use super::{Reader, Writer};\n \n pub fn stdin() -> StdReader { fail!() }\n \n@@ -39,10 +39,6 @@ impl Reader for StdReader {\n     fn eof(&mut self) -> bool { fail!() }\n }\n \n-impl Close for StdReader {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct StdWriter;\n \n impl StdWriter {\n@@ -55,6 +51,3 @@ impl Writer for StdWriter {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for StdWriter {\n-    fn close(&mut self) { fail!() }\n-}"}, {"sha": "eb35eb7881d39f696c2e27bdd2238c2c4832f8bc", "filename": "src/libcore/rt/local_sched.rs", "status": "renamed", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -13,18 +13,21 @@\n use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n-use cast::transmute;\n+use cast;\n+use cell::Cell;\n \n-use super::Scheduler;\n-use super::super::rtio::IoFactoryObject;\n-use tls = super::super::thread_local_storage;\n-#[cfg(test)] use super::super::uvio::UvEventLoop;\n+use rt::sched::Scheduler;\n+use rt::rtio::{EventLoop, IoFactoryObject};\n+use tls = rt::thread_local_storage;\n+use unstable::finally::Finally;\n+\n+#[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n /// Give the Scheduler to thread-local storage\n pub fn put(sched: ~Scheduler) {\n     unsafe {\n         let key = tls_key();\n-        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        let void_sched: *mut c_void = cast::transmute(sched);\n         tls::set(key, void_sched);\n     }\n }\n@@ -34,8 +37,8 @@ pub fn take() -> ~Scheduler {\n     unsafe {\n         let key = tls_key();\n         let void_sched: *mut c_void = tls::get(key);\n-        assert!(void_sched.is_not_null());\n-        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        rtassert!(void_sched.is_not_null());\n+        let sched: ~Scheduler = cast::transmute(void_sched);\n         tls::set(key, mut_null());\n         return sched;\n     }\n@@ -55,8 +58,18 @@ pub fn exists() -> bool {\n /// While the scheduler is borrowed it is not available in TLS.\n pub fn borrow(f: &fn(&mut Scheduler)) {\n     let mut sched = take();\n-    f(sched);\n-    put(sched);\n+\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    unsafe {\n+        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n+        let sched = Cell(sched);\n+\n+        do (|| {\n+            f(unsafe_sched);\n+        }).finally {\n+            put(sched.take());\n+        }\n+    }\n }\n \n /// Borrow a mutable reference to the thread-local Scheduler\n@@ -65,23 +78,22 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n+pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n-    assert!(void_sched.is_not_null());\n+    rtassert!(void_sched.is_not_null());\n     {\n-        let void_sched_ptr = &mut void_sched;\n-        let sched: &mut ~Scheduler = {\n-            transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-        };\n-        let sched: &mut Scheduler = &mut **sched;\n+        let sched: *mut *mut c_void = &mut void_sched;\n+        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n+        let sched: *mut Scheduler = &mut **sched;\n         return sched;\n     }\n }\n \n-pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n+pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n     let sched = unsafe_borrow();\n-    return sched.event_loop.io().unwrap();\n+    let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+    return io;\n }\n \n fn tls_key() -> tls::Key {\n@@ -91,7 +103,7 @@ fn tls_key() -> tls::Key {\n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_sched_tls_key();\n-        let key: &mut tls::Key = transmute(key);\n+        let key: &mut tls::Key = cast::transmute(key);\n         let key = *key;\n         // Check that the key has been initialized.\n \n@@ -105,7 +117,7 @@ fn maybe_tls_key() -> Option<tls::Key> {\n         // another thread. I think this is fine since the only action\n         // they could take if it was initialized would be to check the\n         // thread-local value and see that it's not set.\n-        if key != 0 {\n+        if key != -1 {\n             return Some(key);\n         } else {\n             return None;", "previous_filename": "src/libcore/rt/sched/local_sched.rs"}, {"sha": "98bfc2fa1686fabd0056db01b81531d471724ac8", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -23,19 +23,19 @@ use libc::{c_void, uintptr_t};\n use cast::transmute;\n use super::sched::local_sched;\n use super::local_heap::LocalHeap;\n+use rt::logging::StdErrLogger;\n \n pub struct LocalServices {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n-    logger: Logger,\n+    logger: StdErrLogger,\n     unwinder: Option<Unwinder>,\n     destroyed: bool\n }\n \n pub struct GarbageCollector;\n pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n-pub struct Logger;\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -47,7 +47,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: Some(Unwinder { unwinding: false }),\n             destroyed: false\n         }\n@@ -58,7 +58,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: None,\n             destroyed: false\n         }\n@@ -169,19 +169,27 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n-pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n-    use cast::transmute_mut_region;\n-\n-    match local_sched::unsafe_borrow().current_task {\n+pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n+    match (*local_sched::unsafe_borrow()).current_task {\n         Some(~ref mut task) => {\n-            transmute_mut_region(&mut task.local_services)\n+            let s: *mut LocalServices = &mut task.local_services;\n+            return s;\n         }\n         None => {\n-            fail!(\"no local services for schedulers yet\")\n+            // Don't fail. Infinite recursion\n+            abort!(\"no local services for schedulers yet\")\n         }\n     }\n }\n \n+pub unsafe fn unsafe_try_borrow_local_services() -> Option<*mut LocalServices> {\n+    if local_sched::exists() {\n+        Some(unsafe_borrow_local_services())\n+    } else {\n+        None\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use rt::test::*;\n@@ -229,4 +237,12 @@ mod test {\n             let _ = r.next();\n         }\n     }\n+\n+    #[test]\n+    fn logging() {\n+        do run_in_newsched_task() {\n+            info!(\"here i am. logging in a newsched task\");\n+        }\n+    }\n }\n+"}, {"sha": "4ed09fd829f22f186d04e5c0a3e6705f24842fc1", "filename": "src/libcore/rt/logging.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flogging.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use either::*;\n+\n+pub trait Logger {\n+    fn log(&mut self, msg: Either<~str, &'static str>);\n+}\n+\n+pub struct StdErrLogger;\n+\n+impl Logger for StdErrLogger {\n+    fn log(&mut self, msg: Either<~str, &'static str>) {\n+        use io::{Writer, WriterUtil};\n+\n+        let s: &str = match msg {\n+            Left(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+            Right(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+        };\n+        let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+        dbg.write_str(s);\n+        dbg.write_str(\"\\n\");\n+        dbg.flush();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "f04c38f79e80004fb348b349ec2def71172f2188", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 116, "deletions": 10, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -8,40 +8,143 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! The Rust runtime, including the scheduler and I/O interface */\n+/*! The Rust Runtime, including the task scheduler and I/O\n+\n+The `rt` module provides the private runtime infrastructure necessary\n+to support core language features like the exchange and local heap,\n+the garbage collector, logging, local data and unwinding. It also\n+implements the default task scheduler and task model. Initialization\n+routines are provided for setting up runtime resources in common\n+configurations, including that used by `rustc` when generating\n+executables.\n+\n+It is intended that the features provided by `rt` can be factored in a\n+way such that the core library can be built with different 'profiles'\n+for different use cases, e.g. excluding the task scheduler. A number\n+of runtime features though are critical to the functioning of the\n+language and an implementation must be provided regardless of the\n+execution environment.\n+\n+Of foremost importance is the global exchange heap, in the module\n+`global_heap`. Very little practical Rust code can be written without\n+access to the global heap. Unlike most of `rt` the global heap is\n+truly a global resource and generally operates independently of the\n+rest of the runtime.\n+\n+All other runtime features are 'local', either thread-local or\n+task-local.  Those critical to the functioning of the language are\n+defined in the module `local_services`. Local services are those which\n+are expected to be available to Rust code generally but rely on\n+thread- or task-local state. These currently include the local heap,\n+the garbage collector, local storage, logging and the stack unwinder.\n+Local services are primarily implemented for tasks, but may also\n+be implemented for use outside of tasks.\n+\n+The relationship between `rt` and the rest of the core library is\n+not entirely clear yet and some modules will be moving into or\n+out of `rt` as development proceeds.\n+\n+Several modules in `core` are clients of `rt`:\n+\n+* `core::task` - The user-facing interface to the Rust task model.\n+* `core::task::local_data` - The interface to local data.\n+* `core::gc` - The garbage collector.\n+* `core::unstable::lang` - Miscellaneous lang items, some of which rely on `core::rt`.\n+* `core::condition` - Uses local data.\n+* `core::cleanup` - Local heap destruction.\n+* `core::io` - In the future `core::io` will use an `rt` implementation.\n+* `core::logging`\n+* `core::pipes`\n+* `core::comm`\n+* `core::stackwalk`\n+\n+*/\n \n #[doc(hidden)];\n \n use libc::c_char;\n use ptr::Ptr;\n \n-#[path = \"sched/mod.rs\"]\n+/// The global (exchange) heap.\n+pub mod global_heap;\n+\n+/// The Scheduler and Task types.\n mod sched;\n+\n+/// Thread-local access to the current Scheduler.\n+pub mod local_sched;\n+\n+/// Synchronous I/O.\n+#[path = \"io/mod.rs\"]\n+pub mod io;\n+\n+/// Thread-local implementations of language-critical runtime features like @.\n+pub mod local_services;\n+\n+/// The EventLoop and internal synchronous I/O interface.\n mod rtio;\n-pub mod uvll;\n-mod uvio;\n+\n+/// libuv and default rtio implementation.\n #[path = \"uv/mod.rs\"]\n-mod uv;\n-#[path = \"io/mod.rs\"]\n-mod io;\n+pub mod uv;\n+\n // FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+/// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n+\n+/// A parallel work-stealing dequeue.\n mod work_queue;\n+\n+/// Stack segments and caching.\n mod stack;\n+\n+/// CPU context swapping.\n mod context;\n+\n+/// Bindings to system threading libraries.\n mod thread;\n+\n+/// The runtime configuration, read from environment variables\n pub mod env;\n-pub mod local_services;\n+\n+/// The local, managed heap\n mod local_heap;\n \n+/// The Logger trait and implementations\n+pub mod logging;\n+\n /// Tools for testing the runtime\n #[cfg(test)]\n pub mod test;\n \n+/// Reference counting\n+pub mod rc;\n+\n+/// A simple single-threaded channel type for passing buffered data between\n+/// scheduler and task context\n+pub mod tube;\n+\n+/// Set up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This is invoked by the `start` _language item_ (unstable::lang) to\n+/// run a Rust executable.\n+///\n+/// # Arguments\n+///\n+/// * `main` - A C-abi function that takes no arguments and returns `c_void`.\n+///   It is a wrapper around the user-defined `main` function, and will be run\n+///   in a task.\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///   by os::args.\n+/// * `crate_map` - Runtime information about the executing crate, mostly for logging\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on error.\n pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n \n     use self::sched::{Scheduler, Task};\n-    use self::uvio::UvEventLoop;\n+    use self::uv::uvio::UvEventLoop;\n     use sys::Closure;\n     use ptr;\n     use cast;\n@@ -72,6 +175,8 @@ pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n \n /// Possible contexts in which Rust code may be executing.\n /// Different runtime services are available depending on context.\n+/// Mostly used for determining if we're using the new scheduler\n+/// or the old scheduler.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n     // Only the exchange heap is available\n@@ -84,6 +189,7 @@ pub enum RuntimeContext {\n     OldTaskContext\n }\n \n+/// Determine the current RuntimeContext\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n@@ -119,7 +225,7 @@ pub fn context() -> RuntimeContext {\n fn test_context() {\n     use unstable::run_in_bare_thread;\n     use self::sched::{local_sched, Task};\n-    use self::uvio::UvEventLoop;\n+    use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n \n     assert!(context() == OldTaskContext);"}, {"sha": "1c0c8c14fdfa6404fa2be80abf552c6a55b26ef8", "filename": "src/libcore/rt/rc.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frc.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An owned, task-local, reference counted type\n+//!\n+//! # Safety note\n+//!\n+//! XXX There is currently no type-system mechanism for enforcing that\n+//! reference counted types are both allocated on the exchange heap\n+//! and also non-sendable\n+//!\n+//! This doesn't prevent borrowing multiple aliasable mutable pointers\n+\n+use ops::Drop;\n+use clone::Clone;\n+use libc::c_void;\n+use cast;\n+\n+pub struct RC<T> {\n+    p: *c_void // ~(uint, T)\n+}\n+\n+impl<T> RC<T> {\n+    pub fn new(val: T) -> RC<T> {\n+        unsafe {\n+            let v = ~(1, val);\n+            let p: *c_void = cast::transmute(v);\n+            RC { p: p }\n+        }\n+    }\n+\n+    fn get_mut_state(&mut self) -> *mut (uint, T) {\n+        unsafe {\n+            let p: &mut ~(uint, T) = cast::transmute(&mut self.p);\n+            let p: *mut (uint, T) = &mut **p;\n+            return p;\n+        }\n+    }\n+\n+    fn get_state(&self) -> *(uint, T) {\n+        unsafe {\n+            let p: &~(uint, T) = cast::transmute(&self.p);\n+            let p: *(uint, T) = &**p;\n+            return p;\n+        }\n+    }\n+\n+    pub fn unsafe_borrow_mut(&mut self) -> *mut T {\n+        unsafe {\n+            match *self.get_mut_state() {\n+                (_, ref mut p) => {\n+                    let p: *mut T = p;\n+                    return p;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn refcount(&self) -> uint {\n+        unsafe {\n+            match *self.get_state() {\n+                (count, _) => count\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RC<T> {\n+    fn finalize(&self) {\n+        assert!(self.refcount() > 0);\n+\n+        unsafe {\n+            // XXX: Mutable finalizer\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count - 1\n+                }\n+            }\n+\n+            if this.refcount() == 0 {\n+                let _: ~(uint, T) = cast::transmute(this.p);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for RC<T> {\n+    fn clone(&self) -> RC<T> {\n+        unsafe {\n+            // XXX: Mutable clone\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count + 1;\n+                }\n+            }\n+        }\n+\n+        RC { p: self.p }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::RC;\n+\n+    #[test]\n+    fn smoke_test() {\n+        unsafe {\n+            let mut v1 = RC::new(100);\n+            assert!(*v1.unsafe_borrow_mut() == 100);\n+            assert!(v1.refcount() == 1);\n+\n+            let mut v2 = v1.clone();\n+            assert!(*v2.unsafe_borrow_mut() == 100);\n+            assert!(v2.refcount() == 2);\n+\n+            *v2.unsafe_borrow_mut() = 200;\n+            assert!(*v2.unsafe_borrow_mut() == 200);\n+            assert!(*v1.unsafe_borrow_mut() == 200);\n+\n+            let v3 = v2.clone();\n+            assert!(v3.refcount() == 3);\n+            {\n+                let _v1 = v1;\n+                let _v2 = v2;\n+            }\n+            assert!(v3.refcount() == 1);\n+        }\n+    }\n+}"}, {"sha": "497ff8841b6bd151aad1df81c10cb521877672a9", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -11,14 +11,16 @@\n use option::*;\n use result::*;\n \n+use rt::io::IoError;\n use super::io::net::ip::IpAddr;\n+use rt::uv::uvio;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n-pub type EventLoopObject = super::uvio::UvEventLoop;\n-pub type IoFactoryObject = super::uvio::UvIoFactory;\n-pub type StreamObject = super::uvio::UvStream;\n-pub type TcpListenerObject = super::uvio::UvTcpListener;\n+pub type EventLoopObject = uvio::UvEventLoop;\n+pub type IoFactoryObject = uvio::UvIoFactory;\n+pub type RtioTcpStreamObject = uvio::UvTcpStream;\n+pub type RtioTcpListenerObject = uvio::UvTcpListener;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -28,15 +30,15 @@ pub trait EventLoop {\n }\n \n pub trait IoFactory {\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject>;\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject>;\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n }\n \n-pub trait TcpListener {\n-    fn listen(&mut self) -> Option<~StreamObject>;\n+pub trait RtioTcpListener {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n }\n \n-pub trait Stream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n+pub trait RtioTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }"}, {"sha": "395f9099571a003577381c7ea07949bad4f0eacb", "filename": "src/libcore/rt/sched.rs", "status": "renamed", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -19,7 +19,7 @@ use super::context::Context;\n use super::local_services::LocalServices;\n use cell::Cell;\n \n-#[cfg(test)] use super::uvio::UvEventLoop;\n+#[cfg(test)] use rt::uv::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n \n@@ -106,6 +106,7 @@ pub impl Scheduler {\n                 }\n             }\n \n+            let scheduler = &mut *scheduler;\n             scheduler.event_loop.callback(run_scheduler_once);\n             scheduler.event_loop.run();\n         }\n@@ -179,18 +180,18 @@ pub impl Scheduler {\n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (sched_context, _, next_task_context) = sched.get_contexts();\n+            let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n             let sched = local_sched::unsafe_borrow();\n             // The running task should have passed ownership elsewhere\n-            assert!(sched.current_task.is_none());\n+            assert!((*sched).current_task.is_none());\n \n             // Running tasks may have asked us to do some cleanup\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -208,21 +209,25 @@ pub impl Scheduler {\n \n         rtdebug!(\"blocking task\");\n \n-        let blocked_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        unsafe {\n+            let blocked_task = this.current_task.swap_unwrap();\n+            let f_fake_region = transmute::<&fn(~Task), &fn(~Task)>(f);\n+            let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+            this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        }\n \n         local_sched::put(this);\n \n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (sched_context, last_task_context, _) = (*sched).get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n \n-        // We could be executing in a different thread now\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        sched.run_cleanup_job();\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            (*sched).run_cleanup_job();\n+        }\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n@@ -244,14 +249,14 @@ pub impl Scheduler {\n \n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n             let sched = local_sched::unsafe_borrow();\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -356,10 +361,10 @@ pub impl Task {\n             // have asked us to do some cleanup.\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n-                sched.run_cleanup_job();\n+                (*sched).run_cleanup_job();\n \n                 let sched = local_sched::unsafe_borrow();\n-                let task = sched.current_task.get_mut_ref();\n+                let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n                 task.local_services.run(||start());\n             }", "previous_filename": "src/libcore/rt/sched/mod.rs"}, {"sha": "019540ce76b3fda2c9ccb35e7735e10cd97395f0", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -11,21 +11,36 @@\n use container::Container;\n use ptr::Ptr;\n use vec;\n+use ops::Drop;\n+use libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n-    buf: ~[u8]\n+    buf: ~[u8],\n+    valgrind_id: c_uint\n }\n \n pub impl StackSegment {\n     fn new(size: uint) -> StackSegment {\n-        // Crate a block of uninitialized values\n-        let mut stack = vec::with_capacity(size);\n         unsafe {\n+            // Crate a block of uninitialized values\n+            let mut stack = vec::with_capacity(size);\n             vec::raw::set_len(&mut stack, size);\n+\n+            let mut stk = StackSegment {\n+                buf: stack,\n+                valgrind_id: 0\n+            };\n+\n+            // XXX: Using the FFI to call a C macro. Slow\n+            stk.valgrind_id = rust_valgrind_stack_register(stk.start(), stk.end());\n+            return stk;\n         }\n+    }\n \n-        StackSegment {\n-            buf: stack\n+    /// Point to the low end of the allocated stack\n+    fn start(&self) -> *uint {\n+        unsafe {\n+            vec::raw::to_ptr(self.buf) as *uint\n         }\n     }\n \n@@ -37,6 +52,15 @@ pub impl StackSegment {\n     }\n }\n \n+impl Drop for StackSegment {\n+    fn finalize(&self) {\n+        unsafe {\n+            // XXX: Using the FFI to call a C macro. Slow\n+            rust_valgrind_stack_deregister(self.valgrind_id);\n+        }\n+    }\n+}\n+\n pub struct StackPool(());\n \n impl StackPool {\n@@ -49,3 +73,8 @@ impl StackPool {\n     fn give_segment(&self, _stack: StackSegment) {\n     }\n }\n+\n+extern {\n+    fn rust_valgrind_stack_register(start: *uintptr_t, end: *uintptr_t) -> c_uint;\n+    fn rust_valgrind_stack_deregister(id: c_uint);\n+}"}, {"sha": "8d0ae0caf4d62dfa419883a5c667031fda71aab7", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -19,7 +19,7 @@ use rt::local_services::LocalServices;\n pub fn run_in_newsched_task(f: ~fn()) {\n     use unstable::run_in_bare_thread;\n     use super::sched::Task;\n-    use super::uvio::UvEventLoop;\n+    use rt::uv::uvio::UvEventLoop;\n \n     let f = Cell(f);\n \n@@ -64,6 +64,46 @@ pub fn spawntask_immediately(f: ~fn()) {\n     }\n }\n \n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_later(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+\n+    sched.task_queue.push_front(task);\n+    local_sched::put(sched);\n+}\n+\n+/// Spawn a task and either run it immediately or run it later\n+pub fn spawntask_random(f: ~fn()) {\n+    use super::sched::*;\n+    use rand::{Rand, rng};\n+\n+    let mut rng = rng();\n+    let run_now: bool = Rand::rand(&mut rng);\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+\n+    if run_now {\n+        do sched.switch_running_tasks_and_then(task) |task| {\n+            let task = Cell(task);\n+            do local_sched::borrow |sched| {\n+                sched.task_queue.push_front(task.take());\n+            }\n+        }\n+    } else {\n+        sched.task_queue.push_front(task);\n+        local_sched::put(sched);\n+    }\n+}\n+\n+\n /// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;"}, {"sha": "8e7bf72fa63087457b606b9b00ad282c4eea3bf3", "filename": "src/libcore/rt/tube.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A very simple unsynchronized channel type for sending buffered data from\n+//! scheduler context to task context.\n+//!\n+//! XXX: This would be safer to use if split into two types like Port/Chan\n+\n+use option::*;\n+use clone::Clone;\n+use super::rc::RC;\n+use rt::sched::Task;\n+use rt::{context, TaskContext, SchedulerContext};\n+use rt::local_sched;\n+use vec::OwnedVector;\n+use container::Container;\n+\n+struct TubeState<T> {\n+    blocked_task: Option<~Task>,\n+    buf: ~[T]\n+}\n+\n+pub struct Tube<T> {\n+    p: RC<TubeState<T>>\n+}\n+\n+impl<T> Tube<T> {\n+    pub fn new() -> Tube<T> {\n+        Tube {\n+            p: RC::new(TubeState {\n+                blocked_task: None,\n+                buf: ~[]\n+            })\n+        }\n+    }\n+\n+    pub fn send(&mut self, val: T) {\n+        rtdebug!(\"tube send\");\n+        assert!(context() == SchedulerContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            (*state).buf.push(val);\n+\n+            if (*state).blocked_task.is_some() {\n+                // There's a waiting task. Wake it up\n+                rtdebug!(\"waking blocked tube\");\n+                let task = (*state).blocked_task.swap_unwrap();\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+        }\n+    }\n+\n+    pub fn recv(&mut self) -> T {\n+        assert!(context() == TaskContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            if !(*state).buf.is_empty() {\n+                return (*state).buf.shift();\n+            } else {\n+                // Block and wait for the next message\n+                rtdebug!(\"blocking on tube recv\");\n+                assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n+                assert!((*state).blocked_task.is_none());\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    (*state).blocked_task = Some(task);\n+                }\n+                rtdebug!(\"waking after tube recv\");\n+                let buf = &mut (*state).buf;\n+                assert!(!buf.is_empty());\n+                return buf.shift();\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Tube<T> {\n+    fn clone(&self) -> Tube<T> {\n+        Tube { p: self.p.clone() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::local_sched;\n+    use rt::test::*;\n+    use rt::rtio::EventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn simple_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone_cell = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let mut tube_clone = tube_clone_cell.take();\n+                tube_clone.send(1);\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn blocking_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(Cell(Cell(tube_clone)));\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let tube_clone = tube_clone.take();\n+                do local_sched::borrow |sched| {\n+                    let tube_clone = tube_clone.take();\n+                    do sched.event_loop.callback {\n+                        let mut tube_clone = tube_clone.take();\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube_clone.send(1);\n+                    }\n+                }\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn many_blocking_test() {\n+        static MAX: int = 100;\n+\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                callback_send(tube_clone.take(), 0);\n+\n+                fn callback_send(tube: Tube<int>, i: int) {\n+                    if i == 100 { return; }\n+\n+                    let tube = Cell(Cell(tube));\n+                    do local_sched::borrow |sched| {\n+                        let tube = tube.take();\n+                        do sched.event_loop.callback {\n+                            let mut tube = tube.take();\n+                            // The task should be blocked on this now and\n+                            // sending will wake it up.\n+                            tube.send(i);\n+                            callback_send(tube, i + 1);\n+                        }\n+                    }\n+                }\n+\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            for int::range(0, MAX) |i| {\n+                let j = tube.recv();\n+                assert!(j == i);\n+            }\n+        }\n+    }\n+}"}, {"sha": "2d14505509759b70e8409c4f36afd9657240268e", "filename": "src/libcore/rt/uv/file.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -11,15 +11,11 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use super::{UvError, Callback, Request, NativeHandle, Loop};\n-use super::super::uvll;\n-use super::super::uvll::*;\n-\n-pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n-impl Callback for FsCallback { }\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback};\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n \n pub struct FsRequest(*uvll::uv_fs_t);\n-\n impl Request for FsRequest;\n \n impl FsRequest {"}, {"sha": "fecb9391caa54cc7c62fd744f4ce7bf2a97c7f82", "filename": "src/libcore/rt/uv/idle.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fidle.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_int;\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+impl Watcher for IdleWatcher { }\n+\n+pub impl IdleWatcher {\n+    fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.idle_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        // NB: Not resetting the Rust idle_cb to None here because `stop` is likely\n+        // called from *within* the idle callback, causing a use after free\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_stop(self.native_handle()));\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            unsafe {\n+                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+                {\n+                    let mut data = idle_watcher.get_watcher_data();\n+                    data.close_cb.swap_unwrap()();\n+                }\n+                idle_watcher.drop_watcher_data();\n+                uvll::idle_delete(handle);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "e71944913975812c25e82b685f9ab6165b665c34", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 146, "deletions": 194, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n \n-Bindings to libuv.\n+Bindings to libuv, along with the default implementation of `core::rt::rtio`.\n \n UV types consist of the event loop (Loop), Watchers, Requests and\n Callbacks.\n@@ -38,56 +38,61 @@ use container::Container;\n use option::*;\n use str::raw::from_c_str;\n use to_str::ToStr;\n+use ptr::Ptr;\n+use libc;\n use vec;\n use ptr;\n-use ptr::Ptr;\n+use cast;\n+use str;\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n-use super::uvll;\n use unstable::finally::Finally;\n \n+use rt::io::IoError;\n+\n #[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::{FsRequest, FsCallback};\n+pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher};\n-pub use self::net::{ReadCallback, AllocCallback, ConnectionCallback, ConnectCallback};\n+pub use self::idle::IdleWatcher;\n+\n+/// The implementation of `rtio` for libuv\n+pub mod uvio;\n+\n+/// C bindings to libuv\n+pub mod uvll;\n \n pub mod file;\n pub mod net;\n+pub mod idle;\n \n-/// A trait for callbacks to implement. Provides a little extra type safety\n-/// for generic, unsafe interop functions like `set_watcher_callback`.\n-pub trait Callback { }\n-\n-pub trait Request { }\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n \n /// The trait implemented by uv 'watchers' (handles). Watchers are\n /// non-owning wrappers around the uv handles and are not completely\n /// safe - there may be multiple instances for a single underlying\n /// handle.  Watchers are generally created, then `start`ed, `stop`ed\n /// and `close`ed, but due to their complex life cycle may not be\n /// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n+pub trait Watcher { }\n \n-pub type NullCallback = ~fn();\n-impl Callback for NullCallback { }\n+pub trait Request { }\n \n /// A type that wraps a native handle\n pub trait NativeHandle<T> {\n     pub fn from_native_handle(T) -> Self;\n     pub fn native_handle(&self) -> T;\n }\n \n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *uvll::uv_loop_t\n-}\n-\n pub impl Loop {\n     fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n@@ -113,64 +118,71 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n     }\n }\n \n-pub struct IdleWatcher(*uvll::uv_idle_t);\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+pub type NullCallback = ~fn();\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+\n \n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>,\n+    idle_cb: Option<IdleCallback>\n }\n \n-pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-impl Callback for IdleCallback { }\n+pub trait WatcherInterop {\n+    fn event_loop(&self) -> Loop;\n+    fn install_watcher_data(&mut self);\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n+    fn drop_watcher_data(&mut self);\n+}\n \n-pub impl IdleWatcher {\n-    fn new(loop_: &mut Loop) -> IdleWatcher {\n+impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n+    /// Get the uv event loop from a Watcher\n+    pub fn event_loop(&self) -> Loop {\n         unsafe {\n-            let handle = uvll::idle_new();\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n+            let handle = self.native_handle();\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            NativeHandle::from_native_handle(loop_)\n         }\n     }\n \n-    fn start(&mut self, cb: IdleCallback) {\n-\n-        set_watcher_callback(self, cb);\n+    pub fn install_watcher_data(&mut self) {\n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n-            let status = status_to_maybe_uv_error(handle, status);\n-            (*cb)(idle_watcher, status);\n+            let data = ~WatcherData {\n+                read_cb: None,\n+                write_cb: None,\n+                connect_cb: None,\n+                close_cb: None,\n+                alloc_cb: None,\n+                idle_cb: None\n+            };\n+            let data = transmute::<~WatcherData, *c_void>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n         }\n     }\n \n-    fn stop(&mut self) {\n-        unsafe { assert!(0 == uvll::idle_stop(self.native_handle())); }\n-    }\n-\n-    fn close(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n+    pub fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+            return &mut **data;\n         }\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n+    pub fn drop_watcher_data(&mut self) {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~WatcherData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+        }\n     }\n }\n \n@@ -213,148 +225,70 @@ fn error_smoke_test() {\n     assert!(err.to_str() == ~\"EOF: end of file\");\n }\n \n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n-}\n-\n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n-}\n-\n-/// Delete a callback from a handle's custom data\n-pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n     unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-        }\n+        let loop_ = watcher.event_loop();\n+        UvError(uvll::last_error(loop_.native_handle()))\n     }\n }\n \n-/// Take a pointer to the callback installed as custom data\n-pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n-    }\n-}\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n \n-/// Take ownership of the callback installed as custom data\n-pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n+    // XXX: Could go in str::raw\n+    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s, len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len);\n+        }\n \n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n+        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n     }\n-}\n \n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-    buf: Option<Buf>\n-}\n \n-pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n     unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None,\n-            buf: None\n+        // Importing error constants\n+        use rt::uv::uvll::*;\n+        use rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(&*uverr);\n+        let desc = c_str_to_static_slice(c_desc);\n+\n+        let kind = match uverr.code {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            e => {\n+                abort!(\"unknown uv error code: %u\", e as uint);\n+            }\n         };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n-    }\n-}\n-\n-pub fn get_watcher_data<'r, H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &'r mut W) -> &'r mut WatcherData {\n \n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n-    }\n-}\n-\n-pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n     }\n }\n \n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    assert!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n     }\n-\n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n }\n \n /// The uv buffer type\n@@ -394,6 +328,24 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n     }\n }\n \n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    assert!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n+}\n+\n+\n #[test]\n fn loop_smoke_test() {\n     do run_in_bare_thread {\n@@ -409,7 +361,7 @@ fn idle_new_then_close() {\n     do run_in_bare_thread {\n         let mut loop_ = Loop::new();\n         let idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        idle_watcher.close();\n+        idle_watcher.close(||());\n     }\n }\n \n@@ -425,7 +377,7 @@ fn idle_smoke_test() {\n             assert!(status.is_none());\n             if unsafe { *count_ptr == 10 } {\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             } else {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             }\n@@ -449,7 +401,7 @@ fn idle_start_stop_start() {\n                 assert!(status.is_none());\n                 let mut idle_watcher = idle_watcher;\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             }\n         }\n         loop_.run();"}, {"sha": "fd78b552119b5c82f5dad8ee8184dfafa24d7d87", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 145, "deletions": 156, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -10,21 +10,15 @@\n \n use prelude::*;\n use libc::{size_t, ssize_t, c_int, c_void};\n-use cast::transmute_mut_region;\n-use super::super::uvll;\n-use super::super::uvll::*;\n-use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n-            loop_from_watcher, status_to_maybe_uv_error,\n-            install_watcher_data, get_watcher_data, drop_watcher_data,\n-            vec_to_uv_buf, vec_from_uv_buf};\n-use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n-\n-#[cfg(test)] use cell::Cell;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::super::thread::Thread;\n-#[cfg(test)] use super::super::test::*;\n-\n-fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n+use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n+             status_to_maybe_uv_error};\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::uv::last_uv_error;\n+\n+fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n             unsafe {\n@@ -34,7 +28,7 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n                                                 c as uint,\n                                                 d as uint), p as int);\n                 do (|| {\n-                    f(addr);\n+                    f(addr)\n                 }).finally {\n                     free_ip4_addr(addr);\n                 }\n@@ -47,34 +41,23 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n-\n-impl Watcher for StreamWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-impl Callback for ReadCallback { }\n-\n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-impl Callback for AllocCallback { }\n+impl Watcher for StreamWatcher { }\n \n pub impl StreamWatcher {\n \n     fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        // XXX: Borrowchk problems\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        data.alloc_cb = Some(alloc);\n-        data.read_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.read_cb = Some(cb);\n+        }\n \n         let handle = self.native_handle();\n         unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let alloc_cb = data.alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n@@ -83,7 +66,7 @@ pub impl StreamWatcher {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let cb = data.read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n@@ -98,31 +81,27 @@ pub impl StreamWatcher {\n         unsafe { uvll::read_stop(handle); }\n     }\n \n-    // XXX: Needs to take &[u8], not ~[u8]\n-    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.write_cb.is_none());\n-        data.write_cb = Some(cb);\n+    fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.write_cb.is_none());\n+            data.write_cb = Some(cb);\n+        }\n \n         let req = WriteRequest::new();\n-        let buf = vec_to_uv_buf(msg);\n-        assert!(data.buf.is_none());\n-        data.buf = Some(buf);\n         let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n-                                          self.native_handle(),\n-                                          bufs, write_cb));\n+                                     self.native_handle(),\n+                                     bufs, write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = {\n-                let data = get_watcher_data(&mut stream_watcher);\n-                let _vec = vec_from_uv_buf(data.buf.swap_unwrap());\n+                let data = stream_watcher.get_watcher_data();\n                 let cb = data.write_cb.swap_unwrap();\n                 cb\n             };\n@@ -142,7 +121,7 @@ pub impl StreamWatcher {\n     fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n-            let data = get_watcher_data(&mut this);\n+            let data = this.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n@@ -152,9 +131,10 @@ pub impl StreamWatcher {\n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             {\n-                get_watcher_data(&mut stream_watcher).close_cb.swap_unwrap()();\n+                let mut data = stream_watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n             }\n-            drop_watcher_data(&mut stream_watcher);\n+            stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n@@ -171,37 +151,32 @@ impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n }\n \n pub struct TcpWatcher(*uvll::uv_tcp_t);\n-\n-impl Watcher for TcpWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-impl Callback for ConnectionCallback { }\n+impl Watcher for TcpWatcher { }\n \n pub impl TcpWatcher {\n     fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n             assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher = NativeHandle::from_native_handle(handle);\n-            install_watcher_data(&mut watcher);\n+            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n             return watcher;\n         }\n     }\n \n-    fn bind(&mut self, address: IpAddr) {\n+    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n                     let result = unsafe {\n                         uvll::tcp_bind(self.native_handle(), addr)\n                     };\n-                    // XXX: bind is likely to fail. need real error handling\n-                    assert!(result == 0);\n+                    if result == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(last_uv_error(self))\n+                    }\n                 }\n             }\n             _ => fail!()\n@@ -210,8 +185,8 @@ pub impl TcpWatcher {\n \n     fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n-            assert!(get_watcher_data(self).connect_cb.is_none());\n-            get_watcher_data(self).connect_cb = Some(cb);\n+            assert!(self.get_watcher_data().connect_cb.is_none());\n+            self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n             match address {\n@@ -232,7 +207,7 @@ pub impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb: ConnectionCallback = {\n-                    let data = get_watcher_data(&mut stream_watcher);\n+                    let data = stream_watcher.get_watcher_data();\n                     data.connect_cb.swap_unwrap()\n                 };\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n@@ -242,10 +217,11 @@ pub impl TcpWatcher {\n     }\n \n     fn listen(&mut self, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.connect_cb.is_none());\n-        data.connect_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n \n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n@@ -257,9 +233,10 @@ pub impl TcpWatcher {\n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = get_watcher_data(&mut stream_watcher).connect_cb.swap_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n-            cb(stream_watcher, status);\n+            let data = stream_watcher.get_watcher_data();\n+            let cb = data.connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(stream_watcher, status);\n         }\n     }\n \n@@ -277,12 +254,8 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n-pub type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n-impl Callback for ConnectCallback { }\n-\n // uv_connect_t is a subclass of uv_req_t\n struct ConnectRequest(*uvll::uv_connect_t);\n-\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n@@ -355,93 +328,109 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n }\n \n \n-#[test]\n-fn connect_close() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        // Connect to a port where nobody is listening\n-        let addr = next_test_ip4();\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_some());\n-            assert!(status.get().name() == ~\"ECONNREFUSED\");\n-            stream_watcher.close(||());\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::ignore;\n+    use cell::Cell;\n+    use vec;\n+    use unstable::run_in_bare_thread;\n+    use rt::thread::Thread;\n+    use rt::test::*;\n+    use rt::uv::{Loop, AllocCallback};\n+    use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+\n+    #[test]\n+    fn connect_close() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert!(status.get().name() == ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n         }\n-        loop_.run();\n-        loop_.close();\n     }\n-}\n \n-#[test]\n-fn listen() {\n-    do run_in_bare_thread() {\n-        static MAX: int = 10;\n-        let mut loop_ = Loop::new();\n-        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = next_test_ip4();\n-        server_tcp_watcher.bind(addr);\n-        let loop_ = loop_;\n-        rtdebug!(\"listening\");\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n-            rtdebug!(\"listened!\");\n-            assert!(status.is_none());\n-            let mut server_stream_watcher = server_stream_watcher;\n-            let mut loop_ = loop_;\n-            let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-            server_stream_watcher.accept(client_tcp_watcher);\n-            let count_cell = Cell(0);\n-            let server_stream_watcher = server_stream_watcher;\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do client_tcp_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                rtdebug!(\"i'm reading!\");\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = count_cell.take();\n-                if status.is_none() {\n-                    rtdebug!(\"got %d bytes\", nread);\n-                    let buf = buf.unwrap();\n-                    for buf.slice(0, nread as uint).each |byte| {\n-                        assert!(*byte == count as u8);\n-                        rtdebug!(\"%u\", *byte as uint);\n-                        count += 1;\n-                    }\n-                } else {\n-                    assert!(count == MAX);\n-                    do stream_watcher.close {\n-                        server_stream_watcher.close(||());\n+    #[test]\n+    fn listen() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = loop_;\n+                let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc)\n+                    |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).each |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert!(count == MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n                     }\n+                    count_cell.put_back(count);\n                 }\n-                count_cell.put_back(count);\n             }\n-        }\n \n-        let _client_thread = do Thread::start {\n-            rtdebug!(\"starting client thread\");\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connecting\");\n-                assert!(status.is_none());\n-                let mut stream_watcher = stream_watcher;\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                do stream_watcher.write(msg) |stream_watcher, status| {\n-                    rtdebug!(\"writing\");\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    stream_watcher.close(||());\n+                    let mut stream_watcher = stream_watcher;\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n                 }\n-            }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n             loop_.run();\n             loop_.close();\n-        };\n-\n-        let mut loop_ = loop_;\n-        loop_.run();\n-        loop_.close();\n+        }\n     }\n }"}, {"sha": "cc9eb2ada4d17f4d7b23e25e9f87dc04d41443a9", "filename": "src/libcore/rt/uv/uvio.rs", "status": "renamed", "additions": 152, "deletions": 128, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -10,20 +10,24 @@\n \n use option::*;\n use result::*;\n-\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n use ops::Drop;\n use old_iter::CopyableIter;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n+use clone::Clone;\n+use rt::io::IoError;\n+use rt::io::net::ip::IpAddr;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::rtio::*;\n+use rt::sched::{Scheduler, local_sched};\n+use rt::io::{standard_error, OtherIoError};\n+use rt::tube::Tube;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n+#[cfg(test)] use rt::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -64,7 +68,7 @@ impl EventLoop for UvEventLoop {\n             assert!(status.is_none());\n             let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n-            idle_watcher.close();\n+            idle_watcher.close(||());\n             f();\n         }\n     }\n@@ -100,11 +104,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -122,125 +126,151 @@ impl IoFactory for UvIoFactory {\n             // Wait for a connection\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"connect: in connect callback\");\n-                let maybe_stream = if status.is_none() {\n+                if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n+                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+\n+                    // Store the stream in the task's stack\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                    // Context switch\n+                    let scheduler = local_sched::take();\n+                    scheduler.resume_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n-                    stream_watcher.close(||());\n-                    None\n+                    let task_cell = Cell(task_cell.take());\n+                    do stream_watcher.close {\n+                        let res = Err(uv_error_to_io_error(status.get()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n                 };\n-\n-                // Store the stream in the task's stack\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Err(uverr) => {\n+                let scheduler = local_sched::take();\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task_cell = Cell(task);\n+                    do watcher.as_stream().close {\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n     }\n }\n \n-pub struct UvTcpListener(TcpWatcher);\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpListener {\n+    watcher: TcpWatcher,\n+    listening: bool,\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+}\n \n impl UvTcpListener {\n-    fn watcher(&self) -> TcpWatcher {\n-        match self { &UvTcpListener(w) => w }\n+    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+        UvTcpListener {\n+            watcher: watcher,\n+            listening: false,\n+            incoming_streams: Tube::new()\n+        }\n     }\n \n-    fn close(&self) {\n-        // XXX: Need to wait until close finishes before returning\n-        self.watcher().as_stream().close(||());\n-    }\n+    fn watcher(&self) -> TcpWatcher { self.watcher }\n }\n \n impl Drop for UvTcpListener {\n     fn finalize(&self) {\n-        // XXX: Again, this never gets called. Use .close() instead\n-        //self.watcher().as_stream().close(||());\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.as_stream().close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl TcpListener for UvTcpListener {\n+impl RtioTcpListener for UvTcpListener {\n \n-    fn listen(&mut self) -> Option<~StreamObject> {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         rtdebug!(\"entering listen\");\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n-        let server_tcp_watcher = self.watcher();\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n+        if self.listening {\n+            return self.incoming_streams.recv();\n+        }\n \n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n-                } else {\n-                    None\n-                };\n+        self.listening = true;\n \n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+        let server_tcp_watcher = self.watcher();\n+        let incoming_streams_cell = Cell(self.incoming_streams.clone());\n+\n+        let incoming_streams_cell = Cell(incoming_streams_cell.take());\n+        let mut server_tcp_watcher = server_tcp_watcher;\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            let maybe_stream = if status.is_none() {\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = server_stream_watcher.event_loop();\n+                let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                // XXX: Need's to be surfaced in interface\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+            } else {\n+                Err(standard_error(OtherIoError))\n+            };\n \n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n+            let mut incoming_streams = incoming_streams_cell.take();\n+            incoming_streams.send(maybe_stream);\n+            incoming_streams_cell.put_back(incoming_streams);\n         }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+        return self.incoming_streams.recv();\n     }\n }\n \n-pub struct UvStream(StreamWatcher);\n-\n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n-    }\n-\n-    fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n-    }\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream {\n+    watcher: StreamWatcher\n+}\n \n-    // XXX: finalize isn't working for ~UvStream???\n-    fn close(&self) {\n-        // XXX: Need to wait until this finishes before returning\n-        self.watcher().close(||());\n-    }\n+impl UvTcpStream {\n+    fn watcher(&self) -> StreamWatcher { self.watcher }\n }\n \n-impl Drop for UvStream {\n+impl Drop for UvTcpStream {\n     fn finalize(&self) {\n-        rtdebug!(\"closing stream\");\n-        //self.watcher().close(||());\n+        rtdebug!(\"closing tcp stream\");\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -271,7 +301,7 @@ impl Stream for UvStream {\n                     assert!(nread >= 0);\n                     Ok(nread as uint)\n                 } else {\n-                    Err(())\n+                    Err(standard_error(OtherIoError))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -285,24 +315,22 @@ impl Stream for UvStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n-            let buf = unsafe { &*buf_ptr };\n-            // XXX: OMGCOPIES\n-            let buf = buf.to_vec();\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n                 } else {\n-                    Err(())\n+                    Err(standard_error(OtherIoError))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -320,10 +348,12 @@ impl Stream for UvStream {\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n+        unsafe {\n+            let io = local_sched::unsafe_borrow_io();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n     }\n }\n \n@@ -336,26 +366,23 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert!(nread == 8);\n                 for uint::range(0, nread) |i| {\n                     rtdebug!(\"%u\", buf[i] as uint);\n                     assert!(buf[i] == i as u8);\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n             }\n         }\n     }\n@@ -368,8 +395,8 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n+            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -399,19 +426,17 @@ fn test_read_and_block() {\n \n             // Make sure we had multiple reads\n             assert!(reads > 1);\n-\n-            stream.close();\n-            listener.close();\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n         }\n \n     }\n@@ -426,34 +451,33 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n                     stream.write(buf);\n                     total_bytes_written += buf.len();\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert!(buf[i] == 1);\n+                    }\n                 }\n+                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n             }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n         }\n     }\n }", "previous_filename": "src/libcore/rt/uvio.rs"}, {"sha": "2a2812c67184750884b184b1c2fa7d387867f57a", "filename": "src/libcore/rt/uv/uvll.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -33,6 +33,13 @@ use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use prelude::*;\n \n+pub static UNKNOWN: c_int = -1;\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+\n pub struct uv_err_t {\n     code: c_int,\n     sys_errno_: c_int", "previous_filename": "src/libcore/rt/uvll.rs"}, {"sha": "50a739ec67df7616268578fb6c0f5fca7a2542e4", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -202,10 +202,12 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use rt::{context, OldTaskContext};\n-    use rt::local_services::unsafe_borrow_local_services;\n+    use option::Option;\n+    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n \n-    match context() {\n+    let context = context();\n+    match context {\n         OldTaskContext => {\n             unsafe {\n                 gc::cleanup_stack_for_failure();\n@@ -214,11 +216,26 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             }\n         }\n         _ => {\n-            // XXX: Need to print the failure message\n-            gc::cleanup_stack_for_failure();\n             unsafe {\n+                // XXX: Bad re-allocations. fail! needs some refactoring\n+                let msg = str::raw::from_c_str(msg);\n+                let file = str::raw::from_c_str(file);\n+\n+                let outmsg = fmt!(\"%s at line %i of file %s\", msg, line as int, file);\n+\n+                // XXX: Logging doesn't work correctly in non-task context because it\n+                // invokes the local heap\n+                if context == TaskContext {\n+                    error!(outmsg);\n+                } else {\n+                    rtdebug!(\"%s\", outmsg);\n+                }\n+\n+                gc::cleanup_stack_for_failure();\n+\n                 let local_services = unsafe_borrow_local_services();\n-                match local_services.unwinder {\n+                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")\n                 }"}, {"sha": "27f58057e2ff58f803b766b685e78030cc6bb968", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -36,7 +36,7 @@ impl Handle {\n                 }\n                 _ => {\n                     let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut local_services.storage)\n+                    NewHandle(&mut (*local_services).storage)\n                 }\n             }\n         }"}, {"sha": "e521fb59fbe5f7ed7cfd9898df1577b0d93c819a", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -16,12 +16,12 @@ use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n-use unstable::exchange_alloc;\n use cast::transmute;\n use rt::{context, OldTaskContext};\n use rt::local_services::borrow_local_services;\n use option::{Option, Some, None};\n use io;\n+use rt::global_heap;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -153,7 +153,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n #[lang=\"exchange_malloc\"]\n #[inline(always)]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n+    transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n \n /// Because this code is so perf. sensitive, use a static constant so that\n@@ -233,7 +233,7 @@ impl DebugPrints for io::fd_t {\n #[lang=\"exchange_free\"]\n #[inline(always)]\n pub unsafe fn exchange_free(ptr: *c_char) {\n-    exchange_alloc::free(transmute(ptr))\n+    global_heap::free(transmute(ptr))\n }\n \n #[lang=\"malloc\"]"}, {"sha": "18a6262f17de99b2b78ccef78a120b8a8e1d57c0", "filename": "src/libcore/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -19,7 +19,6 @@ pub mod at_exit;\n pub mod global;\n pub mod finally;\n pub mod weak_task;\n-pub mod exchange_alloc;\n pub mod intrinsics;\n pub mod simd;\n pub mod extfmt;"}, {"sha": "39a6f5bfd1b7b54f2c69d9180931bf6522e739eb", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -830,9 +830,9 @@ rust_get_rt_env() {\n }\n \n #ifndef _WIN32\n-pthread_key_t sched_key;\n+pthread_key_t sched_key = -1;\n #else\n-DWORD sched_key;\n+DWORD sched_key = -1;\n #endif\n \n extern \"C\" void*"}, {"sha": "a609ac573245d625e9831404ec8b821edb275fe0", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -92,3 +92,14 @@ destroy_exchange_stack(rust_exchange_alloc *exchange, stk_seg *stk) {\n     deregister_valgrind_stack(stk);\n     exchange->free(stk);\n }\n+\n+\n+extern \"C\" CDECL unsigned int\n+rust_valgrind_stack_register(void *start, void *end) {\n+  return VALGRIND_STACK_REGISTER(start, end);\n+}\n+\n+extern \"C\" CDECL void\n+rust_valgrind_stack_deregister(unsigned int id) {\n+  VALGRIND_STACK_DEREGISTER(id);\n+}"}, {"sha": "75a5a069605c7964b7df6fb278d83e4c59f5114f", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b04fce6a901f490a9df378c64166dda26e0297a3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b04fce6a901f490a9df378c64166dda26e0297a3", "patch": "@@ -234,3 +234,5 @@ rust_try\n rust_begin_unwind\n rust_take_task_borrow_list\n rust_set_task_borrow_list\n+rust_valgrind_stack_register\n+rust_valgrind_stack_deregister\n\\ No newline at end of file"}]}