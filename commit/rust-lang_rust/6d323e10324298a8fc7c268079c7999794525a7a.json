{"sha": "6d323e10324298a8fc7c268079c7999794525a7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMzIzZTEwMzI0Mjk4YThmYzdjMjY4MDc5Yzc5OTk3OTQ1MjVhN2E=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-09-06T22:08:41Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-09-06T23:07:14Z"}, "message": "Refactor timespec parsing, improve error handling", "tree": {"sha": "a03c48fe4a543b0ce9432f1b6273395dce18346d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a03c48fe4a543b0ce9432f1b6273395dce18346d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d323e10324298a8fc7c268079c7999794525a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d323e10324298a8fc7c268079c7999794525a7a", "html_url": "https://github.com/rust-lang/rust/commit/6d323e10324298a8fc7c268079c7999794525a7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d323e10324298a8fc7c268079c7999794525a7a/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1182d04a161915df7b1d001ac7cc77fc7a2047", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1182d04a161915df7b1d001ac7cc77fc7a2047", "html_url": "https://github.com/rust-lang/rust/commit/5f1182d04a161915df7b1d001ac7cc77fc7a2047"}], "stats": {"total": 96, "additions": 74, "deletions": 22}, "files": [{"sha": "f8bf9598c14f710a8f6249fac0d8bb7de973a322", "filename": "src/helpers.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6d323e10324298a8fc7c268079c7999794525a7a/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d323e10324298a8fc7c268079c7999794525a7a/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=6d323e10324298a8fc7c268079c7999794525a7a", "patch": "@@ -1,6 +1,7 @@\n use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::num::NonZeroUsize;\n+use std::time::Duration;\n \n use log::trace;\n \n@@ -41,6 +42,9 @@ fn try_resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId\n         })\n }\n \n+/// This error indicates that the value in a `timespec` C struct was invalid.\n+pub struct TimespecError;\n+\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Gets an instance for a path.\n     fn resolve_path(&self, path: &[&str]) -> ty::Instance<'tcx> {\n@@ -512,6 +516,39 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n         this.write_scalar(value, value_place.into())\n     }\n+\n+    /// Parse a `timespec` struct and return it as a `std::time::Duration`. The outer `Result` is\n+    /// for interpreter errors encountered while reading memory, and the inner `Result` indicates\n+    /// whether the value in the `timespec` struct is invalid. Some libc functions will return\n+    /// `EINVAL` if the struct's value is invalid.\n+    fn read_timespec(\n+        &mut self,\n+        timespec_ptr_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, Result<Duration, TimespecError>> {\n+        let this = self.eval_context_mut();\n+        let tp = this.deref_operand(timespec_ptr_op)?;\n+        let seconds_place = this.mplace_field(tp, 0)?;\n+        let seconds_scalar = this.read_scalar(seconds_place.into())?;\n+        let seconds = seconds_scalar.to_machine_isize(this)?;\n+        let nanoseconds_place = this.mplace_field(tp, 1)?;\n+        let nanoseconds_scalar = this.read_scalar(nanoseconds_place.into())?;\n+        let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n+\n+        let seconds: u64 = if let Ok(s) = seconds.try_into() {\n+            s\n+        } else {\n+            return Ok(Err(TimespecError));\n+        };\n+        let nanoseconds: u32 = if let Ok(ns) = nanoseconds.try_into() {\n+            if ns >= 1_000_000_000 {\n+                return Ok(Err(TimespecError));\n+            }\n+            ns\n+        } else {\n+            return Ok(Err(TimespecError));\n+        };\n+        Ok(Ok(Duration::new(seconds, nanoseconds)))\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "94704bff32acfd888b8a7027d6e462f21571058f", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6d323e10324298a8fc7c268079c7999794525a7a/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d323e10324298a8fc7c268079c7999794525a7a/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=6d323e10324298a8fc7c268079c7999794525a7a", "patch": "@@ -1,11 +1,10 @@\n-use std::convert::TryInto;\n-use std::time::{Duration, SystemTime};\n+use std::time::SystemTime;\n \n use crate::*;\n+use helpers::TimespecError;\n use stacked_borrows::Tag;\n use thread::Time;\n \n-\n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -698,25 +697,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n-        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n-\n-        // We return success for now and override it in the timeout callback.\n-        this.write_scalar(Scalar::from_i32(0), dest)?;\n-\n         // Extract the timeout.\n         let clock_id = cond_get_clock_id(this, cond_op)?.to_i32()?;\n-        let duration = {\n-            let tp = this.deref_operand(abstime_op)?;\n-            let seconds_place = this.mplace_field(tp, 0)?;\n-            let seconds = this.read_scalar(seconds_place.into())?;\n-            let nanoseconds_place = this.mplace_field(tp, 1)?;\n-            let nanoseconds = this.read_scalar(nanoseconds_place.into())?;\n-            let (seconds, nanoseconds) = (\n-                seconds.to_machine_usize(this)?,\n-                nanoseconds.to_machine_usize(this)?.try_into().unwrap(),\n-            );\n-            Duration::new(seconds, nanoseconds)\n+        let duration = match this.read_timespec(abstime_op)? {\n+            Ok(duration) => duration,\n+            Err(TimespecError) => {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.write_scalar(einval, dest)?;\n+                return Ok(());\n+            }\n         };\n \n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n@@ -727,6 +716,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n         };\n \n+        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n+        this.condvar_wait(id, active_thread, mutex_id);\n+\n+        // We return success for now and override it in the timeout callback.\n+        this.write_scalar(Scalar::from_i32(0), dest)?;\n+\n         // Register the timeout callback.\n         this.register_timeout_callback(\n             active_thread,\n@@ -740,8 +735,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 ecx.condvar_remove_waiter(id, active_thread);\n \n                 // Set the return value: we timed out.\n-                let timeout = ecx.eval_libc_i32(\"ETIMEDOUT\")?;\n-                ecx.write_scalar(Scalar::from_i32(timeout), dest)?;\n+                let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n+                ecx.write_scalar(etimedout, dest)?;\n \n                 Ok(())\n             }),"}, {"sha": "e1ca63f9ca4370203015778641c310d311dae90a", "filename": "tests/run-pass/concurrency/libc_pthread_cond.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d323e10324298a8fc7c268079c7999794525a7a/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d323e10324298a8fc7c268079c7999794525a7a/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs?ref=6d323e10324298a8fc7c268079c7999794525a7a", "patch": "@@ -37,6 +37,26 @@ fn test_timed_wait_timeout(clock_id: i32) {\n         );\n         let elapsed_time = current_time.elapsed().as_millis();\n         assert!(900 <= elapsed_time && elapsed_time <= 1300);\n+\n+        let invalid_timeout_1 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: 1_000_000_000 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                &mut cond as *mut _,\n+                &mut mutex as *mut _,\n+                &invalid_timeout_1\n+            ),\n+            libc::EINVAL\n+        );\n+        let invalid_timeout_2 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: -1 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                &mut cond as *mut _,\n+                &mut mutex as *mut _,\n+                &invalid_timeout_2\n+            ),\n+            libc::EINVAL\n+        );\n+\n         assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n         assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n         assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);"}]}