{"sha": "ba203c5c5de5af9941dc5be4b7c200db69b3c4d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMjAzYzVjNWRlNWFmOTk0MWRjNWJlNGI3YzIwMGRiNjliM2M0ZDQ=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "message": "Add a new each_in_scope_loan_affecting_path helper function\n\nAdd a helper function that generalizes the loan path restriction\nstrategy used by analyze_restrictions_on_use.", "tree": {"sha": "84ba58b1afb60d89a382bdf94be07ccf02980005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84ba58b1afb60d89a382bdf94be07ccf02980005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4", "html_url": "https://github.com/rust-lang/rust/commit/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4/comments", "author": null, "committer": null, "parents": [{"sha": "e018fc36d17685c31d6b31acf17a9a8f2f73f8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e018fc36d17685c31d6b31acf17a9a8f2f73f8d9", "html_url": "https://github.com/rust-lang/rust/commit/e018fc36d17685c31d6b31acf17a9a8f2f73f8d9"}], "stats": {"total": 114, "additions": 72, "deletions": 42}, "files": [{"sha": "131ed8dbba65a4433251291f58b312260ce26ae5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 72, "deletions": 42, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba203c5c5de5af9941dc5be4b7c200db69b3c4d4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=ba203c5c5de5af9941dc5be4b7c200db69b3c4d4", "patch": "@@ -220,6 +220,77 @@ impl<'a> CheckLoanCtxt<'a> {\n         })\n     }\n \n+    fn each_in_scope_loan_affecting_path(&self,\n+                                         scope_id: ast::NodeId,\n+                                         loan_path: &LoanPath,\n+                                         op: |&Loan| -> bool)\n+                                         -> bool {\n+        //! Iterates through all of the in-scope loans affecting `loan_path`,\n+        //! calling `op`, and ceasing iteration if `false` is returned.\n+\n+        // First, we check for a loan restricting the path P being used. This\n+        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n+        // Consider the following example:\n+        //\n+        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n+        //     let y = a;          // Conflicts with restriction\n+\n+        let cont = self.each_in_scope_loan(scope_id, |loan| {\n+            let mut ret = true;\n+            for restr_path in loan.restricted_paths.iter() {\n+                if **restr_path == *loan_path {\n+                    if !op(loan) {\n+                        ret = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            ret\n+        });\n+\n+        if !cont {\n+            return false;\n+        }\n+\n+        // Next, we must check for *loans* (not restrictions) on the path P or\n+        // any base path. This rejects examples like the following:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.b.c;\n+        //\n+        // Limiting this search to *loans* and not *restrictions* means that\n+        // examples like the following continue to work:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.c;\n+\n+        let mut loan_path = loan_path;\n+        loop {\n+            match *loan_path {\n+                LpVar(_) => {\n+                    break;\n+                }\n+                LpExtend(ref lp_base, _, _) => {\n+                    loan_path = &**lp_base;\n+                }\n+            }\n+\n+            let cont = self.each_in_scope_loan(scope_id, |loan| {\n+                if *loan.loan_path == *loan_path {\n+                    op(loan)\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            if !cont {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n     pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> Vec<uint> {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n@@ -526,14 +597,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         let mut ret = UseOk;\n \n-        // First, we check for a restriction on the path P being used. This\n-        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n-        // Consider the following example:\n-        //\n-        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n-        //     let y = a;          // Conflicts with restriction\n-\n-        self.each_in_scope_restriction(expr_id, use_path, |loan| {\n+        self.each_in_scope_loan_affecting_path(expr_id, use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -542,40 +606,6 @@ impl<'a> CheckLoanCtxt<'a> {\n             }\n         });\n \n-        // Next, we must check for *loans* (not restrictions) on the path P or\n-        // any base path. This rejects examples like the following:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.b.c;\n-        //\n-        // Limiting this search to *loans* and not *restrictions* means that\n-        // examples like the following continue to work:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.c;\n-\n-        let mut loan_path = use_path;\n-        loop {\n-            self.each_in_scope_loan(expr_id, |loan| {\n-                if *loan.loan_path == *loan_path &&\n-                   !compatible_borrow_kinds(loan.kind, borrow_kind) {\n-                    ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            match *loan_path {\n-                LpVar(_) => {\n-                    break;\n-                }\n-                LpExtend(ref lp_base, _, _) => {\n-                    loan_path = &**lp_base;\n-                }\n-            }\n-        }\n-\n         return ret;\n     }\n "}]}