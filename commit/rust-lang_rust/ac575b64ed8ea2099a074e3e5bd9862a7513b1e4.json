{"sha": "ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNTc1YjY0ZWQ4ZWEyMDk5YTA3NGUzZTViZDk4NjJhNzUxM2IxZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-21T03:36:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-21T03:36:21Z"}, "message": "Auto merge of #82653 - jyn514:submodules-on-demand, r=Mark-Simulacrum\n\nUpdate all submodules that rustbuild doesn't depend on lazily\n\nThis only updates the submodules the first time they're needed, instead\nof unconditionally the first time you run x.py.\n\nIdeally, this would move *all* submodules to rustbuild and not exclude some tools and\nbacktrace. Unfortunately, cargo requires all `Cargo.toml` files in the\nwhole workspace to be present to build any crate.\n\nOn my machine, this takes the time for an initial submodule clone (for\n`x.py --help`) from 55.70 to 15.87 seconds.\n\nHelps with https://github.com/rust-lang/rust/issues/76653. Builds on https://github.com/rust-lang/rust/pull/86015 and should not be merged before (only the last commit is relevant).", "tree": {"sha": "a9213287a0690c8c99cb6f07f5a13eac5dd9bf05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9213287a0690c8c99cb6f07f5a13eac5dd9bf05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "html_url": "https://github.com/rust-lang/rust/commit/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fabf502a7a24dfd2dfbc33030cb3d4bad7496b81", "url": "https://api.github.com/repos/rust-lang/rust/commits/fabf502a7a24dfd2dfbc33030cb3d4bad7496b81", "html_url": "https://github.com/rust-lang/rust/commit/fabf502a7a24dfd2dfbc33030cb3d4bad7496b81"}, {"sha": "2ac0e9b6944bcff607e453ad8bd27800318de64f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac0e9b6944bcff607e453ad8bd27800318de64f", "html_url": "https://github.com/rust-lang/rust/commit/2ac0e9b6944bcff607e453ad8bd27800318de64f"}], "stats": {"total": 286, "additions": 173, "deletions": 113}, "files": [{"sha": "3d46548807705f8d75d668bcf86ba344c9c9e404", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -989,21 +989,30 @@ def update_submodules(self):\n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n         if slow_submodules:\n-            print('Unconditionally updating all submodules')\n+            print('Unconditionally updating submodules')\n         else:\n             print('Updating only changed submodules')\n         default_encoding = sys.getdefaultencoding()\n-        submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n-            [\"git\", \"config\", \"--file\",\n-             os.path.join(self.rust_root, \".gitmodules\"),\n-             \"--get-regexp\", \"path\"]\n-        ).decode(default_encoding).splitlines()]\n+        # Only update submodules that are needed to build bootstrap.  These are needed because Cargo\n+        # currently requires everything in a workspace to be \"locally present\" when starting a\n+        # build, and will give a hard error if any Cargo.toml files are missing.\n+        # FIXME: Is there a way to avoid cloning these eagerly? Bootstrap itself doesn't need to\n+        #   share a workspace with any tools - maybe it could be excluded from the workspace?\n+        #   That will still require cloning the submodules the second you check the standard\n+        #   library, though...\n+        # FIXME: Is there a way to avoid hard-coding the submodules required?\n+        # WARNING: keep this in sync with the submodules hard-coded in bootstrap/lib.rs\n+        submodules = [\n+            \"src/tools/rust-installer\",\n+            \"src/tools/cargo\",\n+            \"src/tools/rls\",\n+            \"src/tools/miri\",\n+            \"library/backtrace\",\n+            \"library/stdarch\"\n+        ]\n         filtered_submodules = []\n         submodules_names = []\n         for module in submodules:\n-            # This is handled by native::Llvm in rustbuild, not here\n-            if module.endswith(\"llvm-project\"):\n-                continue\n             check = self.check_submodule(module, slow_submodules)\n             filtered_submodules.append((module, check))\n             submodules_names.append(module)"}, {"sha": "bc106746e57e06e0302fcbcce54988a11c407501", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -7,7 +7,7 @@ use crate::config::TargetSelection;\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::INTERNER;\n use crate::{Compiler, Mode, Subcommand};\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n@@ -72,6 +72,8 @@ impl Step for Std {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n+        builder.update_submodule(&Path::new(\"library\").join(\"stdarch\"));\n+\n         let target = self.target;\n         let compiler = builder.compiler(builder.top_stage, builder.config.build);\n "}, {"sha": "8c28d0b60fa32b274206689ecc2a88edbd4faf24", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -79,6 +79,8 @@ impl Step for Std {\n             return;\n         }\n \n+        builder.update_submodule(&Path::new(\"library\").join(\"stdarch\"));\n+\n         let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);"}, {"sha": "9ec5d4d8ccdb49bcdde2f685177add55aa45642f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -22,8 +22,17 @@ use crate::config::{Config, TargetSelection};\n use crate::tool::{self, prepare_tool_cargo, SourceType, Tool};\n use crate::util::symlink_dir;\n \n+macro_rules! submodule_helper {\n+    ($path:expr, submodule) => {\n+        $path\n+    };\n+    ($path:expr, submodule = $submodule:literal) => {\n+        $submodule\n+    };\n+}\n+\n macro_rules! book {\n-    ($($name:ident, $path:expr, $book_name:expr;)+) => {\n+    ($($name:ident, $path:expr, $book_name:expr $(, submodule $(= $submodule:literal)? )? ;)+) => {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n@@ -46,6 +55,10 @@ macro_rules! book {\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n+                $(\n+                    let path = Path::new(submodule_helper!( $path, submodule $( = $submodule )? ));\n+                    builder.update_submodule(&path);\n+                )?\n                 builder.ensure(RustbookSrc {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n@@ -59,13 +72,16 @@ macro_rules! book {\n \n // NOTE: When adding a book here, make sure to ALSO build the book by\n // adding a build step in `src/bootstrap/builder.rs`!\n+// NOTE: Make sure to add the corresponding submodule when adding a new book.\n+// FIXME: Make checking for a submodule automatic somehow (maybe by having a list of all submodules\n+// and checking against it?).\n book!(\n-    CargoBook, \"src/tools/cargo/src/doc\", \"cargo\";\n-    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\";\n-    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\";\n-    Nomicon, \"src/doc/nomicon\", \"nomicon\";\n-    Reference, \"src/doc/reference\", \"reference\";\n-    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n+    CargoBook, \"src/tools/cargo/src/doc\", \"cargo\", submodule = \"src/tools/cargo\";\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", submodule;\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", submodule;\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\", submodule;\n+    Reference, \"src/doc/reference\", \"reference\", submodule;\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", submodule;\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n@@ -197,22 +213,25 @@ impl Step for TheBook {\n     /// * Index page\n     /// * Redirect pages\n     fn run(self, builder: &Builder<'_>) {\n+        let relative_path = Path::new(\"src\").join(\"doc\").join(\"book\");\n+        builder.update_submodule(&relative_path);\n+\n         let compiler = self.compiler;\n         let target = self.target;\n \n         // build book\n         builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_str(\"book\"),\n-            src: INTERNER.intern_path(builder.src.join(\"src/doc/book\")),\n+            src: INTERNER.intern_path(builder.src.join(&relative_path)),\n         });\n \n         // building older edition redirects\n         for edition in &[\"first-edition\", \"second-edition\", \"2018-edition\"] {\n             builder.ensure(RustbookSrc {\n                 target,\n                 name: INTERNER.intern_string(format!(\"book/{}\", edition)),\n-                src: INTERNER.intern_path(builder.src.join(\"src/doc/book\").join(edition)),\n+                src: INTERNER.intern_path(builder.src.join(&relative_path).join(edition)),\n             });\n         }\n \n@@ -221,7 +240,7 @@ impl Step for TheBook {\n \n         // build the redirect pages\n         builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n-        for file in t!(fs::read_dir(builder.src.join(\"src/doc/book/redirects\"))) {\n+        for file in t!(fs::read_dir(builder.src.join(&relative_path).join(\"redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n             let path = path.to_str().unwrap();"}, {"sha": "6bcdbe3e4bbbb33a5faeffb0e4855c8367a04589", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -477,17 +477,120 @@ impl Build {\n         slice::from_ref(&self.build.triple)\n     }\n \n+    // modified from `check_submodule` and `update_submodule` in bootstrap.py\n+    /// Given a path to the directory of a submodule, update it.\n+    ///\n+    /// `relative_path` should be relative to the root of the git repository, not an absolute path.\n+    pub(crate) fn update_submodule(&self, relative_path: &Path) {\n+        fn dir_is_empty(dir: &Path) -> bool {\n+            t!(std::fs::read_dir(dir)).next().is_none()\n+        }\n+\n+        if !self.config.submodules {\n+            return;\n+        }\n+\n+        let absolute_path = self.config.src.join(relative_path);\n+\n+        // NOTE: The check for the empty directory is here because when running x.py the first time,\n+        // the submodule won't be checked out. Check it out now so we can build it.\n+        if !channel::GitInfo::new(false, relative_path).is_git() && !dir_is_empty(&absolute_path) {\n+            return;\n+        }\n+\n+        // check_submodule\n+        if self.config.fast_submodules {\n+            let checked_out_hash = output(\n+                Command::new(\"git\").args(&[\"rev-parse\", \"HEAD\"]).current_dir(&absolute_path),\n+            );\n+            // update_submodules\n+            let recorded = output(\n+                Command::new(\"git\")\n+                    .args(&[\"ls-tree\", \"HEAD\"])\n+                    .arg(relative_path)\n+                    .current_dir(&self.config.src),\n+            );\n+            let actual_hash = recorded\n+                .split_whitespace()\n+                .nth(2)\n+                .unwrap_or_else(|| panic!(\"unexpected output `{}`\", recorded));\n+\n+            // update_submodule\n+            if actual_hash == checked_out_hash.trim_end() {\n+                // already checked out\n+                return;\n+            }\n+        }\n+\n+        println!(\"Updating submodule {}\", relative_path.display());\n+        self.run(\n+            Command::new(\"git\")\n+                .args(&[\"submodule\", \"-q\", \"sync\"])\n+                .arg(relative_path)\n+                .current_dir(&self.config.src),\n+        );\n+\n+        // Try passing `--progress` to start, then run git again without if that fails.\n+        let update = |progress: bool| {\n+            let mut git = Command::new(\"git\");\n+            git.args(&[\"submodule\", \"update\", \"--init\", \"--recursive\"]);\n+            if progress {\n+                git.arg(\"--progress\");\n+            }\n+            git.arg(relative_path).current_dir(&self.config.src);\n+            git\n+        };\n+        // NOTE: doesn't use `try_run` because this shouldn't print an error if it fails.\n+        if !update(true).status().map_or(false, |status| status.success()) {\n+            self.run(&mut update(false));\n+        }\n+\n+        self.run(Command::new(\"git\").args(&[\"reset\", \"-q\", \"--hard\"]).current_dir(&absolute_path));\n+        self.run(Command::new(\"git\").args(&[\"clean\", \"-qdfx\"]).current_dir(absolute_path));\n+    }\n+\n+    /// If any submodule has been initialized already, sync it unconditionally.\n+    /// This avoids contributors checking in a submodule change by accident.\n+    pub fn maybe_update_submodules(&self) {\n+        // WARNING: keep this in sync with the submodules hard-coded in bootstrap.py\n+        const BOOTSTRAP_SUBMODULES: &[&str] = &[\n+            \"src/tools/rust-installer\",\n+            \"src/tools/cargo\",\n+            \"src/tools/rls\",\n+            \"src/tools/miri\",\n+            \"library/backtrace\",\n+            \"library/stdarch\",\n+        ];\n+        // Avoid running git when there isn't a git checkout.\n+        if !self.config.submodules {\n+            return;\n+        }\n+        let output = output(\n+            Command::new(\"git\")\n+                .args(&[\"config\", \"--file\"])\n+                .arg(&self.config.src.join(\".gitmodules\"))\n+                .args(&[\"--get-regexp\", \"path\"]),\n+        );\n+        for line in output.lines() {\n+            // Look for `submodule.$name.path = $path`\n+            // Sample output: `submodule.src/rust-installer.path src/tools/rust-installer`\n+            let submodule = Path::new(line.splitn(2, ' ').nth(1).unwrap());\n+            // avoid updating submodules twice\n+            if !BOOTSTRAP_SUBMODULES.iter().any(|&p| Path::new(p) == submodule)\n+                && channel::GitInfo::new(false, submodule).is_git()\n+            {\n+                self.update_submodule(submodule);\n+            }\n+        }\n+    }\n+\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n             job::setup(self);\n         }\n \n-        // If the LLVM submodule has been initialized already, sync it unconditionally. This avoids\n-        // contributors checking in a submodule change by accident.\n-        if self.in_tree_llvm_info.is_git() {\n-            native::update_llvm_submodule(self);\n-        }\n+        self.maybe_update_submodules();\n \n         if let Subcommand::Format { check, paths } = &self.config.cmd {\n             return format::format(self, *check, &paths);"}, {"sha": "1be414b29a1aec2ebf195cdd4055e11f56b1ee39", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 84, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -21,7 +21,7 @@ use build_helper::{output, t};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n use crate::util::{self, exe};\n-use crate::{Build, GitRepo};\n+use crate::GitRepo;\n use build_helper::up_to_date;\n \n pub struct Meta {\n@@ -91,86 +91,6 @@ pub fn prebuilt_llvm_config(\n     Err(Meta { stamp, build_llvm_config, out_dir, root: root.into() })\n }\n \n-// modified from `check_submodule` and `update_submodule` in bootstrap.py\n-pub(crate) fn update_llvm_submodule(build: &Build) {\n-    let llvm_project = &Path::new(\"src\").join(\"llvm-project\");\n-\n-    fn dir_is_empty(dir: &Path) -> bool {\n-        t!(std::fs::read_dir(dir)).next().is_none()\n-    }\n-\n-    if !build.config.submodules {\n-        return;\n-    }\n-\n-    // NOTE: The check for the empty directory is here because when running x.py\n-    // the first time, the llvm submodule won't be checked out. Check it out\n-    // now so we can build it.\n-    if !build.in_tree_llvm_info.is_git() && !dir_is_empty(&build.config.src.join(llvm_project)) {\n-        return;\n-    }\n-\n-    // check_submodule\n-    if build.config.fast_submodules {\n-        let checked_out_hash = output(\n-            Command::new(\"git\")\n-                .args(&[\"rev-parse\", \"HEAD\"])\n-                .current_dir(build.config.src.join(llvm_project)),\n-        );\n-        // update_submodules\n-        let recorded = output(\n-            Command::new(\"git\")\n-                .args(&[\"ls-tree\", \"HEAD\"])\n-                .arg(llvm_project)\n-                .current_dir(&build.config.src),\n-        );\n-        let actual_hash = recorded\n-            .split_whitespace()\n-            .nth(2)\n-            .unwrap_or_else(|| panic!(\"unexpected output `{}`\", recorded));\n-\n-        // update_submodule\n-        if actual_hash == checked_out_hash.trim_end() {\n-            // already checked out\n-            return;\n-        }\n-    }\n-\n-    println!(\"Updating submodule {}\", llvm_project.display());\n-    build.run(\n-        Command::new(\"git\")\n-            .args(&[\"submodule\", \"-q\", \"sync\"])\n-            .arg(llvm_project)\n-            .current_dir(&build.config.src),\n-    );\n-\n-    // Try passing `--progress` to start, then run git again without if that fails.\n-    let update = |progress: bool| {\n-        let mut git = Command::new(\"git\");\n-        git.args(&[\"submodule\", \"update\", \"--init\", \"--recursive\"]);\n-        if progress {\n-            git.arg(\"--progress\");\n-        }\n-        git.arg(llvm_project).current_dir(&build.config.src);\n-        git\n-    };\n-    // NOTE: doesn't use `try_run` because this shouldn't print an error if it fails.\n-    if !update(true).status().map_or(false, |status| status.success()) {\n-        build.run(&mut update(false));\n-    }\n-\n-    build.run(\n-        Command::new(\"git\")\n-            .args(&[\"reset\", \"-q\", \"--hard\"])\n-            .current_dir(build.config.src.join(llvm_project)),\n-    );\n-    build.run(\n-        Command::new(\"git\")\n-            .args(&[\"clean\", \"-qdfx\"])\n-            .current_dir(build.config.src.join(llvm_project)),\n-    );\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: TargetSelection,\n@@ -208,9 +128,7 @@ impl Step for Llvm {\n                 Err(m) => m,\n             };\n \n-        if !builder.config.dry_run {\n-            update_llvm_submodule(builder);\n-        }\n+        builder.update_submodule(&Path::new(\"src\").join(\"llvm-project\"));\n         if builder.config.llvm_link_shared\n             && (target.contains(\"windows\") || target.contains(\"apple-darwin\"))\n         {"}, {"sha": "50980d25cb2885179c68aea704db0cf529caf925", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -1833,7 +1833,10 @@ impl Step for RustcGuide {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let src = builder.src.join(\"src/doc/rustc-dev-guide\");\n+        let relative_path = Path::new(\"src\").join(\"doc\").join(\"rustc-dev-guide\");\n+        builder.update_submodule(&relative_path);\n+\n+        let src = builder.src.join(relative_path);\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         let toolstate = if try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src)) {\n             ToolState::TestPass"}, {"sha": "f5e3f61dcc88f6fb5827382bd8dcef13780dc8b2", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac575b64ed8ea2099a074e3e5bd9862a7513b1e4/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=ac575b64ed8ea2099a074e3e5bd9862a7513b1e4", "patch": "@@ -1,7 +1,7 @@\n use std::collections::HashSet;\n use std::env;\n use std::fs;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::{exit, Command};\n \n use build_helper::t;\n@@ -670,7 +670,8 @@ macro_rules! tool_extended {\n        $path:expr,\n        $tool_name:expr,\n        stable = $stable:expr,\n-       $(in_tree = $in_tree:expr,)*\n+       $(in_tree = $in_tree:expr,)?\n+       $(submodule = $submodule:literal,)?\n        $extra_deps:block;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -714,6 +715,7 @@ macro_rules! tool_extended {\n             #[allow(unused_mut)]\n             fn run(mut $sel, $builder: &Builder<'_>) -> Option<PathBuf> {\n                 $extra_deps\n+                $( $builder.update_submodule(&Path::new(\"src\").join(\"tools\").join($submodule)); )?\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n@@ -736,6 +738,8 @@ macro_rules! tool_extended {\n \n // Note: tools need to be also added to `Builder::get_step_descriptions` in `builder.rs`\n // to make `./x.py build <tool>` work.\n+// Note: Most submodule updates for tools are handled by bootstrap.py, since they're needed just to\n+// invoke Cargo to build bootstrap. See the comment there for more details.\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, in_tree=true, {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, in_tree=true, {};\n@@ -752,7 +756,7 @@ tool_extended!((self, builder),\n     };\n     RustDemangler, rust_demangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, {};\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, in_tree=true, {};\n-    RustAnalyzer, rust_analyzer, \"src/tools/rust-analyzer/crates/rust-analyzer\", \"rust-analyzer\", stable=false, {};\n+    RustAnalyzer, rust_analyzer, \"src/tools/rust-analyzer/crates/rust-analyzer\", \"rust-analyzer\", stable=false, submodule=\"rust-analyzer\", {};\n );\n \n impl<'a> Builder<'a> {"}]}