{"sha": "afaeb18910414166801e3ca51272cfa3661175a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYWViMTg5MTA0MTQxNjY4MDFlM2NhNTEyNzJjZmEzNjYxMTc1YTQ=", "commit": {"author": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-15T09:09:58Z"}, "committer": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-22T20:33:48Z"}, "message": "Addeded resolver and db", "tree": {"sha": "41a0c9907afb41464af0ca0f5eee6b5419bffc30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a0c9907afb41464af0ca0f5eee6b5419bffc30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afaeb18910414166801e3ca51272cfa3661175a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afaeb18910414166801e3ca51272cfa3661175a4", "html_url": "https://github.com/rust-lang/rust/commit/afaeb18910414166801e3ca51272cfa3661175a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afaeb18910414166801e3ca51272cfa3661175a4/comments", "author": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1705e5887d5c71cad846cb7e840b3c4e03942856", "url": "https://api.github.com/repos/rust-lang/rust/commits/1705e5887d5c71cad846cb7e840b3c4e03942856", "html_url": "https://github.com/rust-lang/rust/commit/1705e5887d5c71cad846cb7e840b3c4e03942856"}], "stats": {"total": 152, "additions": 92, "deletions": 60}, "files": [{"sha": "7759a6d4fd84cddef76a4cc53e3fe5102714be49", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 79, "deletions": 60, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=afaeb18910414166801e3ca51272cfa3661175a4", "patch": "@@ -12,6 +12,7 @@ use ra_syntax::{\n use crate::{\n     Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n     name::AsName,\n+    ids::MacroDefId,\n     type_ref::{Mutability, TypeRef},\n };\n use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n@@ -485,17 +486,20 @@ pub(crate) struct ExprCollector {\n     source_map: BodySourceMap,\n     params: Vec<PatId>,\n     body_expr: Option<ExprId>,\n+    resolver: Resolver,\n }\n \n-impl ExprCollector {\n-    fn new(owner: DefWithBody) -> Self {\n+impl ExprCollector{\n+    fn new(owner: DefWithBody,resolver:Resolver) -> Self {\n         ExprCollector {\n             owner,\n+            resolver,\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             source_map: BodySourceMap::default(),\n             params: Vec::new(),\n             body_expr: None,\n+           \n         }\n     }\n \n@@ -518,23 +522,23 @@ impl ExprCollector {\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n+    fn collect_expr(&mut self, expr: &ast::Expr,db:&impl HirDatabase) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n                     // if let -- desugar to match\n                     let pat = self.collect_pat(pat);\n                     let match_expr =\n-                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n+                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr(),db);\n+                    let then_branch = self.collect_block_opt(e.then_branch(),db);\n                     let else_branch = e\n                         .else_branch()\n                         .map(|b| match b {\n-                            ast::ElseBranch::Block(it) => self.collect_block(it),\n+                            ast::ElseBranch::Block(it) => self.collect_block(it,db),\n                             ast::ElseBranch::IfExpr(elif) => {\n                                 let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n-                                self.collect_expr(expr)\n+                                self.collect_expr(expr,db)\n                             }\n                         })\n                         .unwrap_or_else(|| self.empty_block());\n@@ -545,56 +549,56 @@ impl ExprCollector {\n                     ];\n                     self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n                 } else {\n-                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n+                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()),db);\n+                    let then_branch = self.collect_block_opt(e.then_branch(),db);\n                     let else_branch = e.else_branch().map(|b| match b {\n-                        ast::ElseBranch::Block(it) => self.collect_block(it),\n+                        ast::ElseBranch::Block(it) => self.collect_block(it,db),\n                         ast::ElseBranch::IfExpr(elif) => {\n                             let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n-                            self.collect_expr(expr)\n+                            self.collect_expr(expr,db)\n                         }\n                     });\n                     self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n                 }\n             }\n-            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block(),db),\n             ast::ExprKind::LoopExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_block_opt(e.loop_body(),db);\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n             ast::ExprKind::WhileExpr(e) => {\n                 let condition = if let Some(condition) = e.condition() {\n                     if condition.pat().is_none() {\n-                        self.collect_expr_opt(condition.expr())\n+                        self.collect_expr_opt(condition.expr(),db)\n                     } else {\n                         // FIXME handle while let\n                         return self.alloc_expr(Expr::Missing, syntax_ptr);\n                     }\n                 } else {\n                     self.exprs.alloc(Expr::Missing)\n                 };\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_block_opt(e.loop_body(),db);\n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n             ast::ExprKind::ForExpr(e) => {\n-                let iterable = self.collect_expr_opt(e.iterable());\n+                let iterable = self.collect_expr_opt(e.iterable(),db);\n                 let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_block_opt(e.loop_body(),db);\n                 self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n             }\n             ast::ExprKind::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr());\n+                let callee = self.collect_expr_opt(e.expr(),db);\n                 let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                    arg_list.args().map(|e| self.collect_expr(e,db)).collect()\n                 } else {\n                     Vec::new()\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n             ast::ExprKind::MethodCallExpr(e) => {\n-                let receiver = self.collect_expr_opt(e.expr());\n+                let receiver = self.collect_expr_opt(e.expr(),db);\n                 let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                    arg_list.args().map(|e| self.collect_expr(e,db)).collect()\n                 } else {\n                     Vec::new()\n                 };\n@@ -606,17 +610,17 @@ impl ExprCollector {\n                 )\n             }\n             ast::ExprKind::MatchExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n                         .arms()\n                         .map(|arm| MatchArm {\n                             pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n-                            expr: self.collect_expr_opt(arm.expr()),\n+                            expr: self.collect_expr_opt(arm.expr(),db),\n                             guard: arm\n                                 .guard()\n                                 .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e)),\n+                                .map(|e| self.collect_expr(e,db)),\n                         })\n                         .collect()\n                 } else {\n@@ -634,17 +638,17 @@ impl ExprCollector {\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n             ast::ExprKind::BreakExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n+                let expr = e.expr().map(|e| self.collect_expr(e,db));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n             ast::ExprKind::ParenExpr(e) => {\n-                let inner = self.collect_expr_opt(e.expr());\n+                let inner = self.collect_expr_opt(e.expr(),db);\n                 // make the paren expr point to the inner expression as well\n                 self.source_map.expr_map.insert(syntax_ptr, inner);\n                 inner\n             }\n             ast::ExprKind::ReturnExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n+                let expr = e.expr().map(|e| self.collect_expr(e,db));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::ExprKind::StructLit(e) => {\n@@ -659,7 +663,7 @@ impl ExprCollector {\n                                 .map(|nr| nr.as_name())\n                                 .unwrap_or_else(Name::missing),\n                             expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e)\n+                                self.collect_expr(e,db)\n                             } else if let Some(nr) = field.name_ref() {\n                                 // field shorthand\n                                 let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n@@ -678,37 +682,37 @@ impl ExprCollector {\n                 } else {\n                     Vec::new()\n                 };\n-                let spread = e.spread().map(|s| self.collect_expr(s));\n+                let spread = e.spread().map(|s| self.collect_expr(s,db));\n                 let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     self.source_map.field_map.insert((res, i), ptr);\n                 }\n                 res\n             }\n             ast::ExprKind::FieldExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n             ast::ExprKind::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n             ast::ExprKind::CastExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::ExprKind::RefExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n             ast::ExprKind::PrefixExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n+                let expr = self.collect_expr_opt(e.expr(),db);\n                 if let Some(op) = e.op_kind() {\n                     self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n                 } else {\n@@ -726,17 +730,17 @@ impl ExprCollector {\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let body = self.collect_expr_opt(e.body());\n+                let body = self.collect_expr_opt(e.body(),db);\n                 self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n             }\n             ast::ExprKind::BinExpr(e) => {\n-                let lhs = self.collect_expr_opt(e.lhs());\n-                let rhs = self.collect_expr_opt(e.rhs());\n+                let lhs = self.collect_expr_opt(e.lhs(),db);\n+                let rhs = self.collect_expr_opt(e.rhs(),db);\n                 let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::ExprKind::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n+                let exprs = e.exprs().map(|expr| self.collect_expr(expr,db)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n \n@@ -745,12 +749,12 @@ impl ExprCollector {\n \n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n+                        let exprs = e.map(|expr| self.collect_expr(expr,db)).collect();\n                         self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n-                        let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n+                        let initializer = self.collect_expr_opt(initializer,db);\n+                        let repeat = self.collect_expr_opt(repeat,db);\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n                             syntax_ptr,\n@@ -794,40 +798,53 @@ impl ExprCollector {\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::MacroCall(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::MacroCall(e) => {\n+\n+                let name = e.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+\n+                let res = self.resolver.resolve_name(db,&name);\n+\n+                // match res  {\n+\n+                // }\n+                \n+                // let resolver = Resolver\n+\n+                self.alloc_expr(Expr::Missing, syntax_ptr)\n+            },\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>,db:&impl HirDatabase) -> ExprId {\n         if let Some(expr) = expr {\n-            self.collect_expr(expr)\n+            self.collect_expr(expr,db)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n+    fn collect_block(&mut self, block: &ast::Block,db:&impl HirDatabase) -> ExprId {\n         let statements = block\n             .statements()\n             .map(|s| match s.kind() {\n                 ast::StmtKind::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e,db));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n                 ast::StmtKind::ExprStmt(stmt) => {\n-                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n+                    Statement::Expr(self.collect_expr_opt(stmt.expr(),db))\n                 }\n             })\n             .collect();\n-        let tail = block.expr().map(|e| self.collect_expr(e));\n+        let tail = block.expr().map(|e| self.collect_expr(e,db));\n         self.alloc_expr(Expr::Block { statements, tail }, SyntaxNodePtr::new(block.syntax()))\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<&ast::Block>,db:&impl HirDatabase) -> ExprId {\n         if let Some(block) = block {\n-            self.collect_block(block)\n+            self.collect_block(block,db)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n@@ -900,17 +917,17 @@ impl ExprCollector {\n         }\n     }\n \n-    fn collect_const_body(&mut self, node: &ast::ConstDef) {\n-        let body = self.collect_expr_opt(node.body());\n+    fn collect_const_body(&mut self, node: &ast::ConstDef,db:&impl HirDatabase) {\n+        let body = self.collect_expr_opt(node.body(),db);\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_static_body(&mut self, node: &ast::StaticDef) {\n-        let body = self.collect_expr_opt(node.body());\n+    fn collect_static_body(&mut self, node: &ast::StaticDef,db:&impl HirDatabase) {\n+        let body = self.collect_expr_opt(node.body(),db);\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n+    fn collect_fn_body(&mut self, node: &ast::FnDef,db:&impl HirDatabase) {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let ptr = AstPtr::new(self_param);\n@@ -936,7 +953,7 @@ impl ExprCollector {\n             }\n         };\n \n-        let body = self.collect_block_opt(node.body());\n+        let body = self.collect_block_opt(node.body(),db);\n         self.body_expr = Some(body);\n     }\n \n@@ -956,12 +973,14 @@ pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector = ExprCollector::new(def);\n+\n+    let mut resolver = def.resolver(db);\n+    let mut collector = ExprCollector::new(def,resolver);\n \n     match def {\n-        DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1),\n-        DefWithBody::Function(ref f) => collector.collect_fn_body(&f.source(db).1),\n-        DefWithBody::Static(ref s) => collector.collect_static_body(&s.source(db).1),\n+        DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1,db),\n+        DefWithBody::Function(ref f) => collector.collect_fn_body(&f.source(db).1,db),\n+        DefWithBody::Static(ref s) => collector.collect_static_body(&s.source(db).1,db),\n     }\n \n     let (body, source_map) = collector.finish();"}, {"sha": "2106872c8318b75249e1cf6d4b60b4e65dd187c3", "filename": "crates/ra_parser/src/grammar/Untitled-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs?ref=afaeb18910414166801e3ca51272cfa3661175a4", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! vec {\n+    ($($item:expr),*) => \n+    {\n+        {\n+            let mut v = Vec::new();\n+            $(\n+                v.push($item);\n+            )*\n+            v\n+        }\n+    };\n+}\n+"}]}