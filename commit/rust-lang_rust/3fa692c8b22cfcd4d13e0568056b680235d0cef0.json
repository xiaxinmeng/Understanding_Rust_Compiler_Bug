{"sha": "3fa692c8b22cfcd4d13e0568056b680235d0cef0", "node_id": "C_kwDOAAsO6NoAKDNmYTY5MmM4YjIyY2ZjZDRkMTNlMDU2ODA1NmI2ODAyMzVkMGNlZjA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-03T18:05:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-03T18:05:56Z"}, "message": "for now, do not do fake reads on non-Unpin mutable references", "tree": {"sha": "b6977f4e3e7e7b6506142c87a7a482d02dd753a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6977f4e3e7e7b6506142c87a7a482d02dd753a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fa692c8b22cfcd4d13e0568056b680235d0cef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa692c8b22cfcd4d13e0568056b680235d0cef0", "html_url": "https://github.com/rust-lang/rust/commit/3fa692c8b22cfcd4d13e0568056b680235d0cef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fa692c8b22cfcd4d13e0568056b680235d0cef0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4cbe9095d83d13feb13060cc66f3e50bd75350", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4cbe9095d83d13feb13060cc66f3e50bd75350", "html_url": "https://github.com/rust-lang/rust/commit/3b4cbe9095d83d13feb13060cc66f3e50bd75350"}], "stats": {"total": 68, "additions": 14, "deletions": 54}, "files": [{"sha": "bcac873251f587509c766cd4197cb929feb950f2", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fa692c8b22cfcd4d13e0568056b680235d0cef0/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa692c8b22cfcd4d13e0568056b680235d0cef0/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=3fa692c8b22cfcd4d13e0568056b680235d0cef0", "patch": "@@ -45,7 +45,9 @@ pub struct Stacks {\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n enum RefKind {\n-    /// `&mut` and `Box`.\n+    /// `Box`.\n+    Box,\n+    /// `&mut`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n@@ -56,6 +58,7 @@ enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n+            RefKind::Box => write!(f, \"Box\"),\n             RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n             RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared reference\"),\n@@ -654,15 +657,17 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let (perm, access) = match kind {\n             RefKind::Unique { two_phase } => {\n                 // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    Permission::Unique\n+                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    (Permission::Unique, Some(AccessKind::Write))\n                 } else {\n-                    Permission::SharedReadWrite\n-                };\n-                // We do an access for all full borrows, even if `!Unpin`.\n-                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n-                (perm, access)\n+                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                    // should do fake accesses here. But then we run into\n+                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                    // we don't do that.\n+                    (Permission::SharedReadWrite, None)\n+                }\n             }\n+            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n             RefKind::Raw { mutable: true } => {\n                 // Creating a raw ptr does not count as an access\n                 (Permission::SharedReadWrite, None)\n@@ -853,7 +858,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n-                    RefKind::Unique { two_phase: false },\n+                    RefKind::Box,\n                     self.retag_cause,\n                     /*protector*/\n                     (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cbe9095d83d13feb13060cc66f3e50bd75350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cbe9095d83d13feb13060cc66f3e50bd75350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=3b4cbe9095d83d13feb13060cc66f3e50bd75350", "patch": "@@ -1,17 +0,0 @@\n-//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n-use std::marker::PhantomPinned;\n-\n-struct NotUnpin(i32, PhantomPinned);\n-\n-fn main() {\n-    unsafe {\n-        let mut x = NotUnpin(0, PhantomPinned);\n-        // Mutable borrow of `Unpin` field (with lifetime laundering)\n-        let fieldref = &mut *(&mut x.0 as *mut i32);\n-        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n-        // still count as a read since we would add `dereferenceable`.\n-        let _xref = &mut x;\n-        // That read should have invalidated `fieldref`.\n-        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n-    }\n-}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cbe9095d83d13feb13060cc66f3e50bd75350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cbe9095d83d13feb13060cc66f3e50bd75350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=3b4cbe9095d83d13feb13060cc66f3e50bd75350", "patch": "@@ -1,28 +0,0 @@\n-error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         *fieldref = 0;\n-   |         ^^^^^^^^^^^^^\n-   |         |\n-   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let _xref = &mut x;\n-   |                     ^^^^^^\n-   = note: BACKTRACE:\n-   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}]}