{"sha": "626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNmZkYmNlOGJkMmE2YzYyYWI2NDgxMjlmNmNiZjhlMTJjOGEyMzk=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-22T08:35:08Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-22T08:35:08Z"}, "message": "add `fn make_contiguous` to VecDeque", "tree": {"sha": "57311e0544770aa7010067bef9f57e506f3edac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57311e0544770aa7010067bef9f57e506f3edac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "html_url": "https://github.com/rust-lang/rust/commit/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303d8aff6092709edd4dbd35b1c88e9aa40bf6d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8", "html_url": "https://github.com/rust-lang/rust/commit/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8"}], "stats": {"total": 280, "additions": 227, "deletions": 53}, "files": [{"sha": "0ad59d2a20c2e127c9e496098e59e785dfda0155", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 145, "deletions": 52, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "patch": "@@ -2043,6 +2043,146 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// In case `self` is already contiguous, [`as_slices`](#method.as_slices) can be used to get immutable access.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"none\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2802,63 +2942,16 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n             let out = Vec::from_raw_parts(buf, len, cap);\n             mem::forget(other);"}, {"sha": "8ef5ec78e056e8a2d72b3402a4d73503b0e4f3c2", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626fdbce8bd2a6c62ab648129f6cbf8e12c8a239/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=626fdbce8bd2a6c62ab648129f6cbf8e12c8a239", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-use ::test;\n+use test;\n \n #[bench]\n #[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n@@ -130,6 +130,87 @@ fn test_insert() {\n     }\n }\n \n+#[test]\n+fn make_contiguous_big_tail() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..3 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 3..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 012......9876543\n+    assert_eq!(tester.capacity(), 15);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n+\n+    let expected_start = tester.head;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_big_head() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..8 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 8..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 01234567......98\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_small_free() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // ABCDEFGH...MLKJI\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // IJKLM...HGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+}\n+\n #[test]\n fn test_remove() {\n     // This test checks that every single combination of tail position, length, and"}]}