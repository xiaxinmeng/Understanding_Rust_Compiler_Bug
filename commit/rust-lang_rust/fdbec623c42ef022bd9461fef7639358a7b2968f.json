{"sha": "fdbec623c42ef022bd9461fef7639358a7b2968f", "node_id": "C_kwDOAAsO6NoAKGZkYmVjNjIzYzQyZWYwMjJiZDk0NjFmZWY3NjM5MzU4YTdiMjk2OGY", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-01-31T16:12:48Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-02-14T15:55:54Z"}, "message": "Port ConsiderAddingAwait", "tree": {"sha": "15e8501561a68641356fa497b4fe9d2523d7af1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e8501561a68641356fa497b4fe9d2523d7af1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdbec623c42ef022bd9461fef7639358a7b2968f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbec623c42ef022bd9461fef7639358a7b2968f", "html_url": "https://github.com/rust-lang/rust/commit/fdbec623c42ef022bd9461fef7639358a7b2968f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdbec623c42ef022bd9461fef7639358a7b2968f/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f06c3d87f5a40078319e60ebe91bba279bf3f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f06c3d87f5a40078319e60ebe91bba279bf3f76", "html_url": "https://github.com/rust-lang/rust/commit/9f06c3d87f5a40078319e60ebe91bba279bf3f76"}], "stats": {"total": 112, "additions": 74, "deletions": 38}, "files": [{"sha": "8f4ac5234ce3381498533ecfdcf1d88e18e4d812", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=fdbec623c42ef022bd9461fef7639358a7b2968f", "patch": "@@ -335,3 +335,7 @@ infer_srs_remove_and_box = consider removing this semicolon and boxing the expre\n infer_srs_remove = consider removing this semicolon\n infer_srs_add = consider returning the local binding `{$ident}`\n infer_srs_add_one = consider returning one of these bindings\n+\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n\\ No newline at end of file"}, {"sha": "ba9821b2151bb81c56e8bacf0b05e0dbf6af2598", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=fdbec623c42ef022bd9461fef7639358a7b2968f", "patch": "@@ -1050,3 +1050,46 @@ pub enum SuggestRemoveSemiOrReturnBinding {\n         spans: MultiSpan,\n     },\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum ConsiderAddingAwait {\n+    #[help(infer_await_both_futures)]\n+    BothFuturesHelp,\n+    #[multipart_suggestion(infer_await_both_futures, applicability = \"maybe-incorrect\")]\n+    BothFuturesSugg {\n+        #[suggestion_part(code = \".await\")]\n+        first: Span,\n+        #[suggestion_part(code = \".await\")]\n+        second: Span,\n+    },\n+    #[suggestion(\n+        infer_await_future,\n+        code = \".await\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSugg {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        infer_await_future,\n+        code = \".await\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    #[note(infer_await_note)]\n+    FutureSuggWithNote {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(\n+        infer_await_future,\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSuggMultiple {\n+        #[suggestion_part(code = \".await\")]\n+        spans: Vec<Span>,\n+    },\n+}"}, {"sha": "b183abf977f4d39e4157eae53e213bd9099b6f71", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbec623c42ef022bd9461fef7639358a7b2968f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=fdbec623c42ef022bd9461fef7639358a7b2968f", "patch": "@@ -11,7 +11,9 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n-use crate::errors::{SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding};\n+use crate::errors::{\n+    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+};\n \n use super::TypeErrCtxt;\n \n@@ -191,7 +193,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        match (\n+        let subdiag = match (\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n@@ -200,65 +202,52 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    Some(ConsiderAddingAwait::BothFuturesSugg {\n+                        first: then_span.shrink_to_hi(),\n+                        second: exp_span.shrink_to_hi(),\n+                    })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     prior_arms,\n                     ..\n                 }) => {\n                     if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        Some(ConsiderAddingAwait::BothFuturesSugg {\n+                            first: arm_span.shrink_to_hi(),\n+                            second: exp_span.shrink_to_hi(),\n+                        })\n                     } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n+                        Some(ConsiderAddingAwait::BothFuturesHelp)\n                     }\n                 }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n+                _ => Some(ConsiderAddingAwait::BothFuturesHelp),\n             },\n             (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                self.suggest_await_on_future(diag, exp_span);\n-                diag.span_note(exp_span, \"calling an async function returns a future\");\n+                Some(ConsiderAddingAwait::FutureSuggWithNote { span: exp_span.shrink_to_hi() })\n             }\n             (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n             {\n                 ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     ref prior_arms,\n                     ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n+                }) => Some({\n+                    ConsiderAddingAwait::FutureSuggMultiple {\n+                        spans: prior_arms.iter().map(|arm| arm.shrink_to_hi()).collect(),\n+                    }\n+                }),\n+                _ => None,\n             },\n-            _ => {}\n+            _ => None,\n+        };\n+        if let Some(subdiag) = subdiag {\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n "}]}