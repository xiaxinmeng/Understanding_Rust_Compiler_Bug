{"sha": "85b80aa1e1c69f0ee22c93e7126f96ab7182377a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YjgwYWExZTFjNjlmMGVlMjJjOTNlNzEyNmY5NmFiNzE4MjM3N2E=", "commit": {"author": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-01-23T09:52:58Z"}, "committer": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-01-26T15:27:28Z"}, "message": "don't ignore errors in encode and allow hashmaps with enum keys\n\ncloses #21470 on main rust repository\nwas fixed on rust-lang/rustc-serialize (see https://github.com/rust-lang/rustc-serialize/pull/32)", "tree": {"sha": "ad7c59072ccd430aac8c50209ad56a18abddbdf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad7c59072ccd430aac8c50209ad56a18abddbdf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85b80aa1e1c69f0ee22c93e7126f96ab7182377a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85b80aa1e1c69f0ee22c93e7126f96ab7182377a", "html_url": "https://github.com/rust-lang/rust/commit/85b80aa1e1c69f0ee22c93e7126f96ab7182377a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85b80aa1e1c69f0ee22c93e7126f96ab7182377a/comments", "author": null, "committer": null, "parents": [{"sha": "59dcba5d14e5eada0a5e7eb0cad5efc7acd1d0e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/59dcba5d14e5eada0a5e7eb0cad5efc7acd1d0e3", "html_url": "https://github.com/rust-lang/rust/commit/59dcba5d14e5eada0a5e7eb0cad5efc7acd1d0e3"}], "stats": {"total": 34, "additions": 25, "deletions": 9}, "files": [{"sha": "d86bf8e48716fb6613b26e4f6a3fe7e27bb735e4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85b80aa1e1c69f0ee22c93e7126f96ab7182377a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b80aa1e1c69f0ee22c93e7126f96ab7182377a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=85b80aa1e1c69f0ee22c93e7126f96ab7182377a", "patch": "@@ -97,7 +97,7 @@\n //!     };\n //!\n //!     // Serialize using `json::encode`\n-//!     let encoded = json::encode(&object);\n+//!     let encoded = json::encode(&object).unwrap();\n //!\n //!     // Deserialize using `json::decode`\n //!     let decoded: TestStruct = json::decode(encoded.as_slice()).unwrap();\n@@ -143,7 +143,7 @@\n //!         uid: 1,\n //!         dsc: \"test\".to_string(),\n //!         val: num.to_json(),\n-//!     });\n+//!     }).unwrap();\n //!     println!(\"data: {}\", data);\n //!     // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539j\"};\n //! }\n@@ -316,13 +316,13 @@ pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> {\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: ::Encodable>(object: &T) -> string::String {\n+pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n-        let _ = object.encode(&mut encoder);\n+        try!(object.encode(&mut encoder));\n     }\n-    s\n+    Ok(s)\n }\n \n impl fmt::Display for ErrorCode {\n@@ -536,7 +536,6 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n-        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -550,10 +549,10 @@ impl<'a> ::Encoder for Encoder<'a> {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n-        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n+            if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n             try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n             try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\\"fields\\\":[\"));\n@@ -785,7 +784,6 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n-        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -797,10 +795,10 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                             -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n-        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n+            if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n             try!(write!(self.writer, \"{{\\n\"));\n             self.curr_indent += self.indent;\n             try!(spaces(self.writer, self.curr_indent));\n@@ -3537,6 +3535,24 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_hashmap_with_enum_key() {\n+        use std::collections::HashMap;\n+        use json;\n+        #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Show)]\n+        enum Enum {\n+            Foo,\n+            #[allow(dead_code)]\n+            Bar,\n+        }\n+        let mut map = HashMap::new();\n+        map.insert(Enum::Foo, 0);\n+        let result = json::encode(&map).unwrap();\n+        assert_eq!(&result[], r#\"{\"Foo\":0}\"#);\n+        let decoded: HashMap<Enum, _> = json::decode(result.as_slice()).unwrap();\n+        assert_eq!(map, decoded);\n+    }\n+\n     #[test]\n     fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n         use std::collections::HashMap;"}]}