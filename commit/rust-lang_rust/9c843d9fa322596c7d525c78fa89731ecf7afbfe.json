{"sha": "9c843d9fa322596c7d525c78fa89731ecf7afbfe", "node_id": "C_kwDOAAsO6NoAKDljODQzZDlmYTMyMjU5NmM3ZDUyNWM3OGZhODk3MzFlY2Y3YWZiZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T03:20:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T03:20:22Z"}, "message": "Auto merge of #112116 - compiler-errors:misc-hir-typeck-mismatch-tweaks, r=WaffleLapkin\n\nMisc HIR typeck type mismatch tweaks\n\nThese are all intended to improve #112104, but I couldn't get it to actually suggest adding `as_ref` to the LHS of the equality expr without some hacks that I may play around with some more.\n\nEach commit's title should explain what it's doing except for perhaps the last one, which addresses the bogus suggestion on #112104 itself.", "tree": {"sha": "bce25222317f45213741940b2e11552009a763b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bce25222317f45213741940b2e11552009a763b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c843d9fa322596c7d525c78fa89731ecf7afbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c843d9fa322596c7d525c78fa89731ecf7afbfe", "html_url": "https://github.com/rust-lang/rust/commit/9c843d9fa322596c7d525c78fa89731ecf7afbfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c843d9fa322596c7d525c78fa89731ecf7afbfe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c8fdaac071432c0a5c149ece5c094449fbe8e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c8fdaac071432c0a5c149ece5c094449fbe8e0", "html_url": "https://github.com/rust-lang/rust/commit/68c8fdaac071432c0a5c149ece5c094449fbe8e0"}, {"sha": "a9188226a87618f98ae039682e7616a50bcf6c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9188226a87618f98ae039682e7616a50bcf6c23", "html_url": "https://github.com/rust-lang/rust/commit/a9188226a87618f98ae039682e7616a50bcf6c23"}], "stats": {"total": 507, "additions": 337, "deletions": 170}, "files": [{"sha": "4728edd837a6cf36b54795f5fe9e5a8d8714dde1", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -25,6 +25,8 @@ hir_typeck_const_select_must_be_fn = this argument must be a function item\n \n hir_typeck_convert_to_str = try converting the passed type into a `&str`\n \n+hir_typeck_convert_using_method = try using `{$sugg}` to convert `{$found}` to `{$expected}`\n+\n hir_typeck_ctor_is_private = tuple struct constructor `{$def}` is private\n \n hir_typeck_expected_default_return_type = expected `()` because of default return type"}, {"sha": "b62f689ec6b89ba40d895b813d6916de93816b82", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorKind, Res};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n@@ -91,6 +91,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_wrong_return_ty_due_to_generic_arg(err, expr, expr_ty);\n     }\n \n+    /// Really hacky heuristic to remap an `assert_eq!` error to the user\n+    /// expressions provided to the macro.\n+    fn adjust_expr_for_assert_eq_macro(\n+        &self,\n+        found_expr: &mut &'tcx hir::Expr<'tcx>,\n+        expected_expr: &mut Option<&'tcx hir::Expr<'tcx>>,\n+    ) {\n+        let Some(expected_expr) = expected_expr else { return; };\n+\n+        if !found_expr.span.eq_ctxt(expected_expr.span) {\n+            return;\n+        }\n+\n+        if !found_expr\n+            .span\n+            .ctxt()\n+            .outer_expn_data()\n+            .macro_def_id\n+            .is_some_and(|def_id| self.tcx.is_diagnostic_item(sym::assert_eq_macro, def_id))\n+        {\n+            return;\n+        }\n+\n+        let hir::ExprKind::Unary(\n+            hir::UnOp::Deref,\n+            hir::Expr { kind: hir::ExprKind::Path(found_path), .. },\n+        ) = found_expr.kind else { return; };\n+        let hir::ExprKind::Unary(\n+            hir::UnOp::Deref,\n+            hir::Expr { kind: hir::ExprKind::Path(expected_path), .. },\n+        ) = expected_expr.kind else { return; };\n+\n+        for (path, name, idx, var) in [\n+            (expected_path, \"left_val\", 0, expected_expr),\n+            (found_path, \"right_val\", 1, found_expr),\n+        ] {\n+            if let hir::QPath::Resolved(_, path) = path\n+                && let [segment] = path.segments\n+                && segment.ident.name.as_str() == name\n+                && let Res::Local(hir_id) = path.res\n+                && let Some((_, hir::Node::Expr(match_expr))) = self.tcx.hir().parent_iter(hir_id).nth(2)\n+                && let hir::ExprKind::Match(scrutinee, _, _) = match_expr.kind\n+                && let hir::ExprKind::Tup(exprs) = scrutinee.kind\n+                && let hir::ExprKind::AddrOf(_, _, macro_arg) = exprs[idx].kind\n+            {\n+                *var = macro_arg;\n+            }\n+        }\n+    }\n+\n     /// Requires that the two types unify, and prints an error message if\n     /// they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n@@ -156,7 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn demand_coerce(\n         &self,\n-        expr: &hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -177,10 +227,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, expr, expected_ty_expr, allow_two_phase))]\n     pub fn demand_coerce_diag(\n         &self,\n-        expr: &hir::Expr<'tcx>,\n+        mut expr: &'tcx hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        mut expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n@@ -190,6 +240,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(e) => e,\n         };\n \n+        self.adjust_expr_for_assert_eq_macro(&mut expr, &mut expected_ty_expr);\n+\n         self.set_tainted_by_errors(self.tcx.sess.delay_span_bug(\n             expr.span,\n             \"`TypeError` when attempting coercion but no error emitted\","}, {"sha": "5161a366ae7d3ccbc669c1260016b943d43b5c0e", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -327,3 +327,19 @@ pub struct CtorIsPrivate {\n     pub span: Span,\n     pub def: String,\n }\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    hir_typeck_convert_using_method,\n+    applicability = \"machine-applicable\",\n+    style = \"verbose\"\n+)]\n+pub struct SuggestConvertViaMethod<'tcx> {\n+    #[suggestion_part(code = \"{sugg}\")]\n+    pub span: Span,\n+    #[suggestion_part(code = \"\")]\n+    pub borrow_removal_span: Option<Span>,\n+    pub sugg: &'static str,\n+    pub expected: Ty<'tcx>,\n+    pub found: Ty<'tcx>,\n+}"}, {"sha": "48c3d6f08dee19d571e15d343121d657222d63a7", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -1404,7 +1404,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // type of the place it is referencing, and not some\n             // supertype thereof.\n             let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n-            self.demand_eqtype(init.span, local_ty, init_ty);\n+            if let Some(mut diag) = self.demand_eqtype_diag(init.span, local_ty, init_ty) {\n+                self.emit_type_mismatch_suggestions(\n+                    &mut diag,\n+                    init.peel_drop_temps(),\n+                    init_ty,\n+                    local_ty,\n+                    None,\n+                    None,\n+                );\n+                diag.emit();\n+            }\n             init_ty\n         } else {\n             self.check_expr_coercible_to_type(init, local_ty, None)"}, {"sha": "3a4fe334f888afdb923e899514895d05f5357c5f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 151, "deletions": 84, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -1,6 +1,8 @@\n use super::FnCtxt;\n \n-use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel, SuggestBoxing};\n+use crate::errors::{\n+    AddReturnTypeSuggestion, ExpectedReturnTypeLabel, SuggestBoxing, SuggestConvertViaMethod,\n+};\n use crate::fluent_generated as fluent;\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n@@ -275,6 +277,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n+        let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n+\n         if let Some((suggestion, msg, applicability, verbose, annotation)) =\n             self.suggest_deref_or_ref(expr, found, expected)\n         {\n@@ -325,9 +329,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             return true;\n-        } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n+        }\n+\n+        if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n-        } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n+        }\n+\n+        if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = *found.kind()\n             && let Some(sp) = self.tcx.hir().span_if_local(def_id)\n         {\n@@ -343,97 +351,156 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n             }\n             return true;\n-        } else if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n+        }\n+\n+        if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n-        } else {\n-            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n-            if !methods.is_empty() {\n-                let mut suggestions = methods.iter()\n-                    .filter_map(|conversion_method| {\n-                        let receiver_method_ident = expr.method_ident();\n-                        if let Some(method_ident) = receiver_method_ident\n-                            && method_ident.name == conversion_method.name\n-                        {\n-                            return None // do not suggest code that is already there (#53348)\n-                        }\n+        }\n \n-                        let method_call_list = [sym::to_vec, sym::to_string];\n-                        let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = expr.kind\n-                            && receiver_method.ident.name == sym::clone\n-                            && method_call_list.contains(&conversion_method.name)\n-                            // If receiver is `.clone()` and found type has one of those methods,\n-                            // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n-                            // to an owned type (`Vec` or `String`). These conversions clone internally,\n-                            // so we remove the user's `clone` call.\n-                        {\n-                            vec![(\n-                                receiver_method.ident.span,\n-                                conversion_method.name.to_string()\n-                            )]\n-                        } else if expr.precedence().order()\n-                            < ExprPrecedence::MethodCall.order()\n-                        {\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                (expr.span.shrink_to_hi(), format!(\").{}()\", conversion_method.name)),\n-                            ]\n-                        } else {\n-                            vec![(expr.span.shrink_to_hi(), format!(\".{}()\", conversion_method.name))]\n-                        };\n-                        let struct_pat_shorthand_field = self.maybe_get_struct_pattern_shorthand_field(expr);\n-                        if let Some(name) = struct_pat_shorthand_field {\n-                            sugg.insert(\n-                                0,\n-                                (expr.span.shrink_to_lo(), format!(\"{}: \", name)),\n-                            );\n-                        }\n-                        Some(sugg)\n-                    })\n-                    .peekable();\n-                if suggestions.peek().is_some() {\n-                    err.multipart_suggestions(\n-                        \"try using a conversion method\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return true;\n-                }\n-            } else if let ty::Adt(found_adt, found_substs) = found.kind()\n-                && self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n-                && let ty::Adt(expected_adt, expected_substs) = expected.kind()\n-                && self.tcx.is_diagnostic_item(sym::Option, expected_adt.did())\n-                && let ty::Ref(_, inner_ty, _) = expected_substs.type_at(0).kind()\n-                && inner_ty.is_str()\n-            {\n-                let ty = found_substs.type_at(0);\n-                let mut peeled = ty;\n-                let mut ref_cnt = 0;\n-                while let ty::Ref(_, inner, _) = peeled.kind() {\n-                    peeled = *inner;\n-                    ref_cnt += 1;\n-                }\n-                if let ty::Adt(adt, _) = peeled.kind()\n-                    && Some(adt.did()) == self.tcx.lang_items().string()\n-                {\n-                    let sugg = if ref_cnt == 0 {\n-                        \".as_deref()\"\n+        if !methods.is_empty() {\n+            let mut suggestions = methods\n+                .iter()\n+                .filter_map(|conversion_method| {\n+                    let receiver_method_ident = expr.method_ident();\n+                    if let Some(method_ident) = receiver_method_ident\n+                        && method_ident.name == conversion_method.name\n+                    {\n+                        return None // do not suggest code that is already there (#53348)\n+                    }\n+\n+                    let method_call_list = [sym::to_vec, sym::to_string];\n+                    let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = expr.kind\n+                        && receiver_method.ident.name == sym::clone\n+                        && method_call_list.contains(&conversion_method.name)\n+                        // If receiver is `.clone()` and found type has one of those methods,\n+                        // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n+                        // to an owned type (`Vec` or `String`). These conversions clone internally,\n+                        // so we remove the user's `clone` call.\n+                    {\n+                        vec![(\n+                            receiver_method.ident.span,\n+                            conversion_method.name.to_string()\n+                        )]\n+                    } else if expr.precedence().order()\n+                        < ExprPrecedence::MethodCall.order()\n+                    {\n+                        vec![\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\").{}()\", conversion_method.name)),\n+                        ]\n                     } else {\n-                        \".map(|x| x.as_str())\"\n+                        vec![(expr.span.shrink_to_hi(), format!(\".{}()\", conversion_method.name))]\n                     };\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_hi(),\n-                        fluent::hir_typeck_convert_to_str,\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return true;\n-                }\n+                    let struct_pat_shorthand_field =\n+                        self.maybe_get_struct_pattern_shorthand_field(expr);\n+                    if let Some(name) = struct_pat_shorthand_field {\n+                        sugg.insert(0, (expr.span.shrink_to_lo(), format!(\"{}: \", name)));\n+                    }\n+                    Some(sugg)\n+                })\n+                .peekable();\n+            if suggestions.peek().is_some() {\n+                err.multipart_suggestions(\n+                    \"try using a conversion method\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+                return true;\n+            }\n+        }\n+\n+        if let Some((found_ty_inner, expected_ty_inner, error_tys)) =\n+            self.deconstruct_option_or_result(found, expected)\n+            && let ty::Ref(_, peeled, hir::Mutability::Not) = *expected_ty_inner.kind()\n+        {\n+            // Suggest removing any stray borrows (unless there's macro shenanigans involved).\n+            let inner_expr = expr.peel_borrows();\n+            if !inner_expr.span.eq_ctxt(expr.span) {\n+                return false;\n+            }\n+            let borrow_removal_span = if inner_expr.hir_id == expr.hir_id {\n+                None\n+            } else {\n+                Some(expr.span.shrink_to_lo().until(inner_expr.span))\n+            };\n+            // Given `Result<_, E>`, check our expected ty is `Result<_, &E>` for\n+            // `as_ref` and `as_deref` compatibility.\n+            let error_tys_equate_as_ref = error_tys.map_or(true, |(found, expected)| {\n+                self.can_eq(self.param_env, self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, found), expected)\n+            });\n+            // FIXME: This could/should be extended to suggest `as_mut` and `as_deref_mut`,\n+            // but those checks need to be a bit more delicate and the benefit is diminishing.\n+            if self.can_eq(self.param_env, found_ty_inner, peeled) && error_tys_equate_as_ref {\n+                err.subdiagnostic(SuggestConvertViaMethod {\n+                    span: expr.span.shrink_to_hi(),\n+                    sugg: \".as_ref()\",\n+                    expected,\n+                    found,\n+                    borrow_removal_span,\n+                });\n+                return true;\n+            } else if let Some((deref_ty, _)) =\n+                self.autoderef(expr.span, found_ty_inner).silence_errors().nth(1)\n+                && self.can_eq(self.param_env, deref_ty, peeled)\n+                && error_tys_equate_as_ref\n+            {\n+                err.subdiagnostic(SuggestConvertViaMethod {\n+                    span: expr.span.shrink_to_hi(),\n+                    sugg: \".as_deref()\",\n+                    expected,\n+                    found,\n+                    borrow_removal_span,\n+                });\n+                return true;\n+            } else if let ty::Adt(adt, _) = found_ty_inner.peel_refs().kind()\n+                && Some(adt.did()) == self.tcx.lang_items().string()\n+                && peeled.is_str()\n+                // `Result::map`, conversely, does not take ref of the error type.\n+                && error_tys.map_or(true, |(found, expected)| {\n+                    self.can_eq(self.param_env, found, expected)\n+                })\n+            {\n+                err.span_suggestion_verbose(\n+                    expr.span.shrink_to_hi(),\n+                    fluent::hir_typeck_convert_to_str,\n+                    \".map(|x| x.as_str())\",\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n             }\n         }\n \n         false\n     }\n \n+    fn deconstruct_option_or_result(\n+        &self,\n+        found_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Ty<'tcx>, Ty<'tcx>, Option<(Ty<'tcx>, Ty<'tcx>)>)> {\n+        let ty::Adt(found_adt, found_substs) = found_ty.peel_refs().kind() else {\n+            return None;\n+        };\n+        let ty::Adt(expected_adt, expected_substs) = expected_ty.kind() else {\n+            return None;\n+        };\n+        if self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n+            && self.tcx.is_diagnostic_item(sym::Option, expected_adt.did())\n+        {\n+            Some((found_substs.type_at(0), expected_substs.type_at(0), None))\n+        } else if self.tcx.is_diagnostic_item(sym::Result, found_adt.did())\n+            && self.tcx.is_diagnostic_item(sym::Result, expected_adt.did())\n+        {\n+            Some((\n+                found_substs.type_at(0),\n+                expected_substs.type_at(0),\n+                Some((found_substs.type_at(1), expected_substs.type_at(1))),\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n     /// in the heap by calling `Box::new()`.\n     pub(in super::super) fn suggest_boxing_when_appropriate("}, {"sha": "4d0e7706367219253cd83aa716b37fc2935bb9f0", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -278,9 +278,6 @@ infer_ril_introduced_by = requirement introduced by this return type\n infer_ril_introduced_here = `'static` requirement introduced here\n infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n \n-infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n-infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n-\n infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n \n infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object"}, {"sha": "7e1fa08f23ae282b6b6e43a439e80a371b383480", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -1246,30 +1246,6 @@ pub struct FnConsiderCasting {\n     pub casting: String,\n }\n \n-#[derive(Subdiagnostic)]\n-pub enum SuggestAsRefWhereAppropriate<'a> {\n-    #[suggestion(\n-        infer_sarwa_option,\n-        code = \"{snippet}.as_ref()\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Option {\n-        #[primary_span]\n-        span: Span,\n-        snippet: &'a str,\n-    },\n-    #[suggestion(\n-        infer_sarwa_result,\n-        code = \"{snippet}.as_ref()\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Result {\n-        #[primary_span]\n-        span: Span,\n-        snippet: &'a str,\n-    },\n-}\n-\n #[derive(Subdiagnostic)]\n pub enum SuggestAccessingField<'a> {\n     #[suggestion("}, {"sha": "ce5b5882e3b26409537b60fe5a427a59a23cd1ac", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -1897,7 +1897,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n             if should_suggest_fixes {\n                 self.suggest_tuple_pattern(cause, &exp_found, diag);\n-                self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                 self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n                 self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n                 self.suggest_function_pointers(cause, span, &exp_found, diag);"}, {"sha": "a723dc3f079d76820204c1776bc0adc1bafeaee2", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -374,12 +374,18 @@ impl<T> Trait<T> for X {\n     ) {\n         let tcx = self.tcx;\n \n+        // Don't suggest constraining a projection to something containing itself\n+        if self.tcx.erase_regions(values.found).contains(self.tcx.erase_regions(values.expected)) {\n+            return;\n+        }\n+\n         let msg = || {\n             format!(\n                 \"consider constraining the associated type `{}` to `{}`\",\n                 values.expected, values.found\n             )\n         };\n+\n         let body_owner = tcx.hir().get_if_local(body_owner_def_id);\n         let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n "}, {"sha": "1422bdc9ea282c86f3a278bf1c6b5cd45c2cb977", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -13,9 +13,9 @@ use rustc_span::{sym, BytePos, Span};\n \n use crate::errors::{\n     ConsiderAddingAwait, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n-    FunctionPointerSuggestion, SuggestAccessingField, SuggestAsRefWhereAppropriate,\n-    SuggestBoxingForReturnImplTrait, SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany,\n-    SuggestTuplePatternOne, TypeErrorAdditionalDiags,\n+    FunctionPointerSuggestion, SuggestAccessingField, SuggestBoxingForReturnImplTrait,\n+    SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany, SuggestTuplePatternOne,\n+    TypeErrorAdditionalDiags,\n };\n \n use super::TypeErrCtxt;\n@@ -289,27 +289,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggests it.\n-    pub(super) fn suggest_as_ref_where_appropriate(\n-        &self,\n-        span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref_kind(exp_found.expected, exp_found.found)\n-        {\n-            // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-            let snippet = snippet.trim_start_matches('&');\n-            let subdiag = match msg {\n-                SuggestAsRefKind::Option => SuggestAsRefWhereAppropriate::Option { span, snippet },\n-                SuggestAsRefKind::Result => SuggestAsRefWhereAppropriate::Result { span, snippet },\n-            };\n-            diag.subdiagnostic(subdiag);\n-        }\n-    }\n-\n     pub(super) fn suggest_function_pointers(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "6894f6b6cc4a02ba55495e304028e20b8dc7e1e4", "filename": "tests/ui/associated-types/dont-suggest-cyclic-constraint.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -0,0 +1,11 @@\n+use std::fmt::Debug;\n+\n+fn foo<I: Iterator>(mut iter: I, value: &I::Item)\n+where\n+    I::Item: Eq + Debug,\n+{\n+    debug_assert_eq!(iter.next(), Some(value));\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "3ecac9c83e571e5f891266db9201e61703b61e3a", "filename": "tests/ui/associated-types/dont-suggest-cyclic-constraint.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fdont-suggest-cyclic-constraint.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-cyclic-constraint.rs:7:35\n+   |\n+LL |     debug_assert_eq!(iter.next(), Some(value));\n+   |                                   ^^^^^^^^^^^ expected `Option<<I as Iterator>::Item>`, found `Option<&<I as Iterator>::Item>`\n+   |\n+   = note: expected enum `Option<<I as Iterator>::Item>`\n+              found enum `Option<&<I as Iterator>::Item>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "096989db0b4e88fbccb2c89c6f61716134e1944b", "filename": "tests/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fderef-suggestion.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -84,15 +84,16 @@ LL | fn foo3(_: u32) {}\n    |    ^^^^ ------\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:37:5\n+  --> $DIR/deref-suggestion.rs:37:22\n    |\n LL |     assert_eq!(3i32, &3i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     expected `i32`, found `&i32`\n-   |     expected because this is `i32`\n+   |                      ^^^^^ expected `i32`, found `&i32`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     assert_eq!(3i32, &3i32);\n+LL +     assert_eq!(3i32, 3i32);\n    |\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:40:17"}, {"sha": "6f11f44755a9d0f533e327ff7beca1a1aa112db5", "filename": "tests/ui/issues/issue-100605.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fissues%2Fissue-100605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fissues%2Fissue-100605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-100605.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -13,10 +13,6 @@ note: function defined here\n    |\n LL | fn takes_option(_arg: Option<&String>) {}\n    |    ^^^^^^^^^^^^ ---------------------\n-help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n-   |\n-LL |     takes_option(None.as_ref());\n-   |                  ~~~~~~~~~~~~~\n help: consider removing the borrow\n    |\n LL -     takes_option(&None);\n@@ -27,10 +23,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-100605.rs:8:18\n    |\n LL |     takes_option(&res);\n-   |     ------------ ^^^^\n-   |     |            |\n-   |     |            expected `Option<&String>`, found `&Option<String>`\n-   |     |            help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`: `res.as_ref()`\n+   |     ------------ ^^^^ expected `Option<&String>`, found `&Option<String>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note:   expected enum `Option<&String>`\n@@ -40,6 +34,11 @@ note: function defined here\n    |\n LL | fn takes_option(_arg: Option<&String>) {}\n    |    ^^^^^^^^^^^^ ---------------------\n+help: try using `.as_ref()` to convert `&Option<String>` to `Option<&String>`\n+   |\n+LL -     takes_option(&res);\n+LL +     takes_option(res.as_ref());\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0886d7f1770e959764268251654b7527acbf916e", "filename": "tests/ui/let-else/let-else-ref-bindings.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -6,6 +6,10 @@ LL |     let Some(ref a): Option<&[u8]> = some else { return };\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(ref a): Option<&[u8]> = some.as_deref() else { return };\n+   |                                          +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:20:38\n@@ -15,6 +19,11 @@ LL |     let Some(ref a): Option<&[u8]> = &some else { return };\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `&Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL -     let Some(ref a): Option<&[u8]> = &some else { return };\n+LL +     let Some(ref a): Option<&[u8]> = some.as_deref() else { return };\n+   |\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:24:34\n@@ -26,6 +35,10 @@ LL |     let Some(a): Option<&[u8]> = some else { return };\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL |     let Some(a): Option<&[u8]> = some.as_deref() else { return };\n+   |                                      +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:27:34\n@@ -37,6 +50,11 @@ LL |     let Some(a): Option<&[u8]> = &some else { return };\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n+help: try using `.as_deref()` to convert `&Option<Vec<u8>>` to `Option<&[u8]>`\n+   |\n+LL -     let Some(a): Option<&[u8]> = &some else { return };\n+LL +     let Some(a): Option<&[u8]> = some.as_deref() else { return };\n+   |\n \n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:44:46"}, {"sha": "0d9790ac22974b7614750e42a0a936aea61a8e3f", "filename": "tests/ui/suggestions/as-ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fas-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fas-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fas-ref.rs?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -24,4 +24,6 @@ fn main() {\n     let multiple_ref_result = &&Ok(Foo);\n     multiple_ref_result.map(|arg| takes_ref(arg)); //~ ERROR mismatched types [E0308]\n     multiple_ref_result.and_then(|arg| Ok(takes_ref(arg))); //~ ERROR mismatched types [E0308]\n+\n+    let _: Result<&usize, _> = &Ok(42); //~ ERROR mismatched types [E0308]\n }"}, {"sha": "c5b2bb1260f354ef8b1bc18bc1e61a4a72afbc8f", "filename": "tests/ui/suggestions/as-ref.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fas-ref.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -74,14 +74,16 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:13:29\n    |\n LL |     let y: Option<&usize> = x;\n-   |            --------------   ^\n-   |            |                |\n-   |            |                expected `Option<&usize>`, found `&Option<usize>`\n-   |            |                help: you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`: `x.as_ref()`\n+   |            --------------   ^ expected `Option<&usize>`, found `&Option<usize>`\n+   |            |\n    |            expected due to this\n    |\n    = note:   expected enum `Option<&usize>`\n            found reference `&Option<usize>`\n+help: try using `.as_ref()` to convert `&Option<usize>` to `Option<&usize>`\n+   |\n+LL |     let y: Option<&usize> = x.as_ref();\n+   |                              +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:15:37\n@@ -93,10 +95,10 @@ LL |     let y: Result<&usize, &usize> = x;\n    |\n    = note:   expected enum `Result<&usize, &usize>`\n            found reference `&Result<usize, usize>`\n-help: you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n+help: try using `.as_ref()` to convert `&Result<usize, usize>` to `Result<&usize, &usize>`\n    |\n LL |     let y: Result<&usize, &usize> = x.as_ref();\n-   |                                     ~~~~~~~~~~\n+   |                                      +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:19:36\n@@ -181,6 +183,22 @@ help: consider using `as_ref` instead\n LL |     multiple_ref_result.as_ref().and_then(|arg| Ok(takes_ref(arg)));\n    |                         +++++++++\n \n-error: aborting due to 11 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/as-ref.rs:28:32\n+   |\n+LL |     let _: Result<&usize, _> = &Ok(42);\n+   |            -----------------   ^^^^^^^ expected `Result<&usize, _>`, found `&Result<{integer}, _>`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:   expected enum `Result<&usize, _>`\n+           found reference `&Result<{integer}, _>`\n+help: try using `.as_ref()` to convert `&Result<{integer}, _>` to `Result<&usize, _>`\n+   |\n+LL -     let _: Result<&usize, _> = &Ok(42);\n+LL +     let _: Result<&usize, _> = Ok(42).as_ref();\n+   |\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "319d866003ba80f1224e48f8f4d1451dbcf1ab52", "filename": "tests/ui/suggestions/dont-suggest-try_into-in-macros.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fdont-suggest-try_into-in-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fsuggestions%2Fdont-suggest-try_into-in-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fdont-suggest-try_into-in-macros.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -1,13 +1,13 @@\n error[E0308]: mismatched types\n-  --> $DIR/dont-suggest-try_into-in-macros.rs:2:5\n+  --> $DIR/dont-suggest-try_into-in-macros.rs:2:23\n    |\n LL |     assert_eq!(10u64, 10usize);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     expected `u64`, found `usize`\n-   |     expected because this is `u64`\n+   |                       ^^^^^^^ expected `u64`, found `usize`\n    |\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: change the type of the numeric literal from `usize` to `u64`\n+   |\n+LL |     assert_eq!(10u64, 10u64);\n+   |                         ~~~\n \n error: aborting due to previous error\n "}, {"sha": "6e1bbf701d77f979e79fc74826ac5e15b7d2c2f6", "filename": "tests/ui/switched-expectations.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fswitched-expectations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Fswitched-expectations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswitched-expectations.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/switched-expectations.rs:3:30\n    |\n LL |     let ref string: String = var;\n-   |                              ^^^ expected `String`, found `i32`\n+   |                              ^^^- help: try using a conversion method: `.to_string()`\n+   |                              |\n+   |                              expected `String`, found `i32`\n \n error: aborting due to previous error\n "}, {"sha": "0db3e67ede0d4b0a441d7a4f1c308c35e81a947d", "filename": "tests/ui/typeck/issue-89856.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c843d9fa322596c7d525c78fa89731ecf7afbfe/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-89856.stderr?ref=9c843d9fa322596c7d525c78fa89731ecf7afbfe", "patch": "@@ -13,7 +13,7 @@ note: function defined here\n    |\n LL | fn take_str_maybe(_: Option<&str>) { }\n    |    ^^^^^^^^^^^^^^ ---------------\n-help: try converting the passed type into a `&str`\n+help: try using `.as_deref()` to convert `Option<String>` to `Option<&str>`\n    |\n LL |     take_str_maybe(option.as_deref());\n    |                          +++++++++++"}]}