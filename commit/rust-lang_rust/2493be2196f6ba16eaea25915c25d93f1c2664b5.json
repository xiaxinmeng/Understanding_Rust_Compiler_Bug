{"sha": "2493be2196f6ba16eaea25915c25d93f1c2664b5", "node_id": "C_kwDOAAsO6NoAKDI0OTNiZTIxOTZmNmJhMTZlYWVhMjU5MTVjMjVkOTNmMWMyNjY0YjU", "commit": {"author": {"name": "bluthej", "email": "joffrey.bluthe@e.email", "date": "2023-03-26T16:25:15Z"}, "committer": {"name": "bluthej", "email": "joffrey.bluthe@e.email", "date": "2023-03-26T17:12:36Z"}, "message": "Improve `is_range_full` implementation\n\nMake this function work with signed integer types by extracting the\nunderlying type and finding the min and max values.\n\nChange the signature to make it more consistent:\n- The range is now given as an `Expr` in order to extract the type\n- The container's path is now passed, and only as an `Option` so that\n  the function can be called in the general case without a container", "tree": {"sha": "6951d406c4bb779d1c4d706dd32e4557b99c7c8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6951d406c4bb779d1c4d706dd32e4557b99c7c8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2493be2196f6ba16eaea25915c25d93f1c2664b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2493be2196f6ba16eaea25915c25d93f1c2664b5", "html_url": "https://github.com/rust-lang/rust/commit/2493be2196f6ba16eaea25915c25d93f1c2664b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2493be2196f6ba16eaea25915c25d93f1c2664b5/comments", "author": {"login": "bluthej", "id": 29771403, "node_id": "MDQ6VXNlcjI5NzcxNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/29771403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluthej", "html_url": "https://github.com/bluthej", "followers_url": "https://api.github.com/users/bluthej/followers", "following_url": "https://api.github.com/users/bluthej/following{/other_user}", "gists_url": "https://api.github.com/users/bluthej/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluthej/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluthej/subscriptions", "organizations_url": "https://api.github.com/users/bluthej/orgs", "repos_url": "https://api.github.com/users/bluthej/repos", "events_url": "https://api.github.com/users/bluthej/events{/privacy}", "received_events_url": "https://api.github.com/users/bluthej/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluthej", "id": 29771403, "node_id": "MDQ6VXNlcjI5NzcxNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/29771403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluthej", "html_url": "https://github.com/bluthej", "followers_url": "https://api.github.com/users/bluthej/followers", "following_url": "https://api.github.com/users/bluthej/following{/other_user}", "gists_url": "https://api.github.com/users/bluthej/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluthej/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluthej/subscriptions", "organizations_url": "https://api.github.com/users/bluthej/orgs", "repos_url": "https://api.github.com/users/bluthej/repos", "events_url": "https://api.github.com/users/bluthej/events{/privacy}", "received_events_url": "https://api.github.com/users/bluthej/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee0de538d4196596986328311bb097a07f473273", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0de538d4196596986328311bb097a07f473273", "html_url": "https://github.com/rust-lang/rust/commit/ee0de538d4196596986328311bb097a07f473273"}], "stats": {"total": 85, "additions": 65, "deletions": 20}, "files": [{"sha": "24496bd4689f59776bfab246471b7141eef8c713", "filename": "clippy_lints/src/methods/clear_with_drain.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs?ref=2493be2196f6ba16eaea25915c25d93f1c2664b5", "patch": "@@ -1,9 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::Range;\n use clippy_utils::is_range_full;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -12,7 +11,9 @@ use super::CLEAR_WITH_DRAIN;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(recv);\n-    if is_type_diagnostic_item(cx, ty, sym::Vec) && let Some(range) = Range::hir(arg) && is_range_full(cx, recv, range)\n+    if is_type_diagnostic_item(cx, ty, sym::Vec)\n+        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+        && is_range_full(cx, arg, Some(container_path))\n     {\n         span_lint_and_sugg(\n             cx,"}, {"sha": "f6772c5c6b369c03ea12cff1c39647f9577794e6", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=2493be2196f6ba16eaea25915c25d93f1c2664b5", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::Range;\n use clippy_utils::is_range_full;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -14,8 +13,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n         && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n         && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n         && matches!(ty_name, sym::Vec | sym::VecDeque)\n-        && let Some(range) = Range::hir(arg)\n-        && is_range_full(cx, recv, range)\n+        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+        && is_range_full(cx, arg, Some(container_path))\n     {\n         span_lint_and_sugg(\n             cx,"}, {"sha": "2e839fdf47288fdaacc3ba89becd0971821aaa24", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2493be2196f6ba16eaea25915c25d93f1c2664b5/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=2493be2196f6ba16eaea25915c25d93f1c2664b5", "patch": "@@ -96,6 +96,7 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n@@ -114,7 +115,7 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Integer;\n \n-use crate::consts::{constant, Constant};\n+use crate::consts::{constant, miri_to_const, Constant};\n use crate::higher::Range;\n use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n use crate::visitors::for_each_expr;\n@@ -1492,22 +1493,66 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-/// Checks whether the given `Range` is equivalent to a `RangeFull`.\n-/// Inclusive ranges are not considered because they already constitute a lint.\n-pub fn is_range_full(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n-    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n-        && range.end.map_or(true, |e| {\n-            if range.limits == RangeLimits::HalfOpen\n-                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n-                && name.ident.name == sym::len\n-                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+/// Checks whether the given `Expr` is a range equivalent to a `RangeFull`.\n+/// For the lower bound, this means that:\n+/// - either there is none\n+/// - or it is the smallest value that can be represented by the range's integer type\n+/// For the upper bound, this means that:\n+/// - either there is none\n+/// - or it is the largest value that can be represented by the range's integer type and is\n+///   inclusive\n+/// - or it is a call to some container's `len` method and is exclusive, and the range is passed to\n+///   a method call on that same container (e.g. `v.drain(..v.len())`)\n+/// If the given `Expr` is not some kind of range, the function returns `false`.\n+pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Option<&Path<'_>>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let Some(Range { start, end, limits }) = Range::hir(expr) {\n+        let start_is_none_or_min = start.map_or(true, |start| {\n+            if let rustc_ty::Adt(_, subst) = ty.kind()\n+                && let bnd_ty = subst.type_at(0)\n+                && let Some(min_val) = bnd_ty.numeric_min_val(cx.tcx)\n+                && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, min_val.to_valtree()))\n+                && let min_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                && let Some(min_const) = miri_to_const(cx.tcx, min_const_kind)\n+                && let Some((start_const, _)) = constant(cx, cx.typeck_results(), start)\n             {\n-                container_path.res == path.res\n+                start_const == min_const\n             } else {\n                 false\n             }\n-        })\n+        });\n+        let end_is_none_or_max = end.map_or(true, |end| {\n+            match limits {\n+                RangeLimits::Closed => {\n+                    if let rustc_ty::Adt(_, subst) = ty.kind()\n+                        && let bnd_ty = subst.type_at(0)\n+                        && let Some(max_val) = bnd_ty.numeric_max_val(cx.tcx)\n+                        && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, max_val.to_valtree()))\n+                        && let max_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                        && let Some(max_const) = miri_to_const(cx.tcx, max_const_kind)\n+                        && let Some((end_const, _)) = constant(cx, cx.typeck_results(), end)\n+                    {\n+                        end_const == max_const\n+                    } else {\n+                        false\n+                    }\n+                },\n+                RangeLimits::HalfOpen => {\n+                    if let Some(container_path) = container_path\n+                        && let ExprKind::MethodCall(name, self_arg, [], _) = end.kind\n+                        && name.ident.name == sym::len\n+                        && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+                    {\n+                        container_path.res == path.res\n+                    } else {\n+                        false\n+                    }\n+                },\n+            }\n+        });\n+        return start_is_none_or_min && end_is_none_or_max;\n+    }\n+    false\n }\n \n /// Checks whether the given expression is a constant integer of the given value."}]}