{"sha": "e6d22187a67e762bb950de244a6ca15f3a0b0731", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZDIyMTg3YTY3ZTc2MmJiOTUwZGUyNDRhNmNhMTVmM2EwYjA3MzE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T16:25:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T16:25:36Z"}, "message": "Add _token suffix to token accessors\n\nI think this makes is more clear which things are : AstNode and which\nare : AstToken", "tree": {"sha": "c1bf1fa132003b333b6ccd55d60127d93518f0eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1bf1fa132003b333b6ccd55d60127d93518f0eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d22187a67e762bb950de244a6ca15f3a0b0731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d22187a67e762bb950de244a6ca15f3a0b0731", "html_url": "https://github.com/rust-lang/rust/commit/e6d22187a67e762bb950de244a6ca15f3a0b0731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d22187a67e762bb950de244a6ca15f3a0b0731/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "html_url": "https://github.com/rust-lang/rust/commit/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e"}], "stats": {"total": 423, "additions": 210, "deletions": 213}, "files": [{"sha": "e7dcfb44e27362e8c0371a3df82a18c0b7fa6f86", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -1,6 +1,6 @@\n use hir::HirDisplay;\n use ra_syntax::{\n-    ast::{self, AstNode, LetStmt, NameOwner, TypeAscriptionOwner},\n+    ast::{self, AstNode, AstToken, LetStmt, NameOwner, TypeAscriptionOwner},\n     TextRange,\n };\n \n@@ -35,7 +35,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n     let name = pat.name()?;\n     let name_range = name.syntax().text_range();\n     let stmt_range = stmt.syntax().text_range();\n-    let eq_range = stmt.eq_token()?.text_range();\n+    let eq_range = stmt.eq_token()?.syntax().text_range();\n     // Assist should only be applicable if cursor is between 'let' and '='\n     let let_range = TextRange::from_to(stmt_range.start(), eq_range.start());\n     let cursor_in_range = ctx.frange.range.is_subrange(&let_range);"}, {"sha": "26dfed23767990588e152a7267fc9a22627494e7", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n         if let Some(type_params) = type_params {\n             let lifetime_params = type_params\n                 .lifetime_params()\n-                .filter_map(|it| it.lifetime())\n+                .filter_map(|it| it.lifetime_token())\n                 .map(|it| it.text().clone());\n             let type_params =\n                 type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "30360af9421db6b946dccb51072c6d68ae43ded7", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -106,7 +106,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n     if let Some(type_params) = type_params {\n         let lifetime_params = type_params\n             .lifetime_params()\n-            .filter_map(|it| it.lifetime())\n+            .filter_map(|it| it.lifetime_token())\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "936d50ab49c28b583031fe146665686248d580ca", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -82,7 +82,7 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n             .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n     );\n     let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly()?.syntax().clone().into());\n+    let pos = InsertPosition::Before(use_tree_list.r_curly_token()?.syntax().clone().into());\n     let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n     Some(lhs.with_use_tree_list(use_tree_list))\n }"}, {"sha": "0f806d6fb500abf04546fc85387465555e7f572a", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -28,7 +28,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     loop {\n         let segment = path.segment()?;\n \n-        if segment.coloncolon().is_some() {\n+        if segment.coloncolon_token().is_some() {\n             kind = PathKind::Abs;\n         }\n "}, {"sha": "5b6854b0f0038de438ecfb8cd1d9d02ecf2de374", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn lower_use_tree(\n         let alias = tree.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n-        let is_glob = tree.star().is_some();\n+        let is_glob = tree.star_token().is_some();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path.\n             // E.g. `use something::{self, <...>}`"}, {"sha": "f97e0bfebc8723b49454d4d57381fad69c7af75a", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -101,7 +101,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n-                (self_param.self_kw().unwrap().syntax().text_range(), \"self\".to_string())\n+                (self_param.self_kw_token().unwrap().syntax().text_range(), \"self\".to_string())\n             } else {\n                 (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };"}, {"sha": "15a8279f3dc31d0f2ef232f5cb825a90b93e3cc4", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -287,7 +287,7 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"'a\", pred.lifetime().unwrap().text());\n+    assert_eq!(\"'a\", pred.lifetime_token().unwrap().text());\n \n     assert_bound(\"'b\", bounds.next());\n     assert_bound(\"'c\", bounds.next());"}, {"sha": "62153f199b365b136eefa8a4390d90647ea2a771", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -96,7 +96,7 @@ impl ast::ItemList {\n                 leading_indent(it.syntax()).unwrap_or_default().to_string(),\n                 InsertPosition::After(it.syntax().clone().into()),\n             ),\n-            None => match self.l_curly() {\n+            None => match self.l_curly_token() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n                     InsertPosition::After(it.syntax().clone().into()),\n@@ -142,7 +142,7 @@ impl ast::RecordFieldList {\n \n         macro_rules! after_l_curly {\n             () => {{\n-                let anchor = match self.l_curly() {\n+                let anchor = match self.l_curly_token() {\n                     Some(it) => it.syntax().clone().into(),\n                     None => return self.clone(),\n                 };\n@@ -301,7 +301,7 @@ impl ast::UseTree {\n             suffix.clone(),\n             self.use_tree_list(),\n             self.alias(),\n-            self.star().is_some(),\n+            self.star_token().is_some(),\n         );\n         let nested = make::use_tree_list(iter::once(use_tree));\n         return make::use_tree(prefix.clone(), Some(nested), None, false);"}, {"sha": "ff3525c8447b57363ec026c49f0c985df84d30b3", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -23,7 +23,7 @@ impl ast::NameRef {\n     }\n \n     pub fn as_tuple_field(&self) -> Option<usize> {\n-        if let Some(ast::NameRefToken::IntNumber(token)) = self.name_ref_token() {\n+        if let Some(ast::NameRefToken::IntNumber(token)) = self.name_ref_token_token() {\n             token.text().as_str().parse().ok()\n         } else {\n             None\n@@ -138,7 +138,7 @@ impl ast::Path {\n \n impl ast::Module {\n     pub fn has_semi(&self) -> bool {\n-        self.semi().is_some()\n+        self.semi_token().is_some()\n     }\n }\n \n@@ -174,7 +174,7 @@ impl ast::ImplDef {\n     }\n \n     pub fn is_negative(&self) -> bool {\n-        self.excl().is_some()\n+        self.excl_token().is_some()\n     }\n }\n \n@@ -218,11 +218,11 @@ impl ast::EnumVariant {\n \n impl ast::FnDef {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> {\n-        Some(self.semi()?.syntax().clone())\n+        Some(self.semi_token()?.syntax().clone())\n     }\n \n     pub fn is_async(&self) -> bool {\n-        self.async_kw().is_some()\n+        self.async_kw_token().is_some()\n     }\n }\n \n@@ -233,15 +233,11 @@ impl ast::LetStmt {\n             Some(node) => node.kind() == T![;],\n         }\n     }\n-\n-    pub fn eq_token(&self) -> Option<SyntaxToken> {\n-        Some(self.eq()?.syntax().clone())\n-    }\n }\n \n impl ast::ExprStmt {\n     pub fn has_semi(&self) -> bool {\n-        self.semi().is_some()\n+        self.semi_token().is_some()\n     }\n }\n \n@@ -350,7 +346,7 @@ pub enum SelfParamKind {\n \n impl ast::SelfParam {\n     pub fn kind(&self) -> SelfParamKind {\n-        if self.amp().is_some() {\n+        if self.amp_token().is_some() {\n             if self.amp_mut_kw().is_some() {\n                 SelfParamKind::MutRef\n             } else {\n@@ -396,7 +392,7 @@ impl ast::TypeBound {\n             TypeBoundKind::PathType(path_type)\n         } else if let Some(for_type) = children(self).next() {\n             TypeBoundKind::ForType(for_type)\n-        } else if let Some(lifetime) = self.lifetime() {\n+        } else if let Some(lifetime) = self.lifetime_token() {\n             TypeBoundKind::Lifetime(lifetime)\n         } else {\n             unreachable!()\n@@ -416,7 +412,7 @@ impl ast::TypeBound {\n     }\n \n     pub fn question(&self) -> Option<ast::Question> {\n-        if self.const_kw().is_some() {\n+        if self.const_kw_token().is_some() {\n             self.syntax()\n                 .children_with_tokens()\n                 .filter_map(|it| it.into_token())"}, {"sha": "0bcb7fe61cde2f3a5e29769a8355799d77f38b69", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 188, "deletions": 188, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -49,15 +49,15 @@ impl ast::DocCommentsOwner for FnDef {}\n impl ast::AttrsOwner for FnDef {}\n impl FnDef {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn async_kw(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn fn_kw(&self) -> Option<FnKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn async_kw_token(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn fn_kw_token(&self) -> Option<FnKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n@@ -75,7 +75,7 @@ impl AstNode for RetType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RetType {\n-    pub fn thin_arrow(&self) -> Option<ThinArrow> { support::token(&self.syntax) }\n+    pub fn thin_arrow_token(&self) -> Option<ThinArrow> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -99,9 +99,9 @@ impl ast::TypeParamsOwner for StructDef {}\n impl ast::AttrsOwner for StructDef {}\n impl ast::DocCommentsOwner for StructDef {}\n impl StructDef {\n-    pub fn struct_kw(&self) -> Option<StructKw> { support::token(&self.syntax) }\n+    pub fn struct_kw_token(&self) -> Option<StructKw> { support::token(&self.syntax) }\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n@@ -124,7 +124,7 @@ impl ast::TypeParamsOwner for UnionDef {}\n impl ast::AttrsOwner for UnionDef {}\n impl ast::DocCommentsOwner for UnionDef {}\n impl UnionDef {\n-    pub fn union_kw(&self) -> Option<UnionKw> { support::token(&self.syntax) }\n+    pub fn union_kw_token(&self) -> Option<UnionKw> { support::token(&self.syntax) }\n     pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n         support::child(&self.syntax)\n     }\n@@ -145,9 +145,9 @@ impl AstNode for RecordFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldDefList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n@@ -186,9 +186,9 @@ impl AstNode for TupleFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleFieldDefList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n@@ -231,7 +231,7 @@ impl ast::TypeParamsOwner for EnumDef {}\n impl ast::AttrsOwner for EnumDef {}\n impl ast::DocCommentsOwner for EnumDef {}\n impl EnumDef {\n-    pub fn enum_kw(&self) -> Option<EnumKw> { support::token(&self.syntax) }\n+    pub fn enum_kw_token(&self) -> Option<EnumKw> { support::token(&self.syntax) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -250,9 +250,9 @@ impl AstNode for EnumVariantList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl EnumVariantList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n@@ -275,7 +275,7 @@ impl ast::DocCommentsOwner for EnumVariant {}\n impl ast::AttrsOwner for EnumVariant {}\n impl EnumVariant {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -300,9 +300,9 @@ impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n impl ast::TypeBoundsOwner for TraitDef {}\n impl TraitDef {\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn auto_kw(&self) -> Option<AutoKw> { support::token(&self.syntax) }\n-    pub fn trait_kw(&self) -> Option<TraitKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn auto_kw_token(&self) -> Option<AutoKw> { support::token(&self.syntax) }\n+    pub fn trait_kw_token(&self) -> Option<TraitKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -325,9 +325,9 @@ impl ast::NameOwner for Module {}\n impl ast::AttrsOwner for Module {}\n impl ast::DocCommentsOwner for Module {}\n impl Module {\n-    pub fn mod_kw(&self) -> Option<ModKw> { support::token(&self.syntax) }\n+    pub fn mod_kw_token(&self) -> Option<ModKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n@@ -347,9 +347,9 @@ impl AstNode for ItemList {\n impl ast::FnDefOwner for ItemList {}\n impl ast::ModuleItemOwner for ItemList {}\n impl ItemList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn impl_items(&self) -> AstChildren<ImplItem> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n@@ -373,11 +373,11 @@ impl ast::AttrsOwner for ConstDef {}\n impl ast::DocCommentsOwner for ConstDef {}\n impl ast::TypeAscriptionOwner for ConstDef {}\n impl ConstDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n@@ -401,11 +401,11 @@ impl ast::AttrsOwner for StaticDef {}\n impl ast::DocCommentsOwner for StaticDef {}\n impl ast::TypeAscriptionOwner for StaticDef {}\n impl StaticDef {\n-    pub fn static_kw(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn static_kw_token(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n@@ -429,11 +429,11 @@ impl ast::AttrsOwner for TypeAliasDef {}\n impl ast::DocCommentsOwner for TypeAliasDef {}\n impl ast::TypeBoundsOwner for TypeAliasDef {}\n impl TypeAliasDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn type_kw(&self) -> Option<TypeKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn type_kw_token(&self) -> Option<TypeKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n@@ -453,12 +453,12 @@ impl AstNode for ImplDef {\n impl ast::TypeParamsOwner for ImplDef {}\n impl ast::AttrsOwner for ImplDef {}\n impl ImplDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn impl_kw(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn impl_kw_token(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -477,9 +477,9 @@ impl AstNode for ParenType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenType {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n@@ -497,9 +497,9 @@ impl AstNode for TupleType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleType {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n@@ -517,7 +517,7 @@ impl AstNode for NeverType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NeverType {\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n@@ -553,8 +553,8 @@ impl AstNode for PointerType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PointerType {\n-    pub fn star(&self) -> Option<Star> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -573,11 +573,11 @@ impl AstNode for ArrayType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArrayType {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n@@ -595,9 +595,9 @@ impl AstNode for SliceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SliceType {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n@@ -615,9 +615,9 @@ impl AstNode for ReferenceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ReferenceType {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -636,7 +636,7 @@ impl AstNode for PlaceholderType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderType {\n-    pub fn underscore(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n@@ -655,8 +655,8 @@ impl AstNode for FnPointerType {\n }\n impl FnPointerType {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn fn_kw(&self) -> Option<FnKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn fn_kw_token(&self) -> Option<FnKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n@@ -676,7 +676,7 @@ impl AstNode for ForType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ForType {\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -697,7 +697,7 @@ impl AstNode for ImplTraitType {\n }\n impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n-    pub fn impl_kw(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n+    pub fn impl_kw_token(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n@@ -716,7 +716,7 @@ impl AstNode for DynTraitType {\n }\n impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n-    pub fn dyn_kw(&self) -> Option<DynKw> { support::token(&self.syntax) }\n+    pub fn dyn_kw_token(&self) -> Option<DynKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n@@ -735,9 +735,9 @@ impl AstNode for TupleExpr {\n }\n impl ast::AttrsOwner for TupleExpr {}\n impl TupleExpr {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n@@ -756,10 +756,10 @@ impl AstNode for ArrayExpr {\n }\n impl ast::AttrsOwner for ArrayExpr {}\n impl ArrayExpr {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -778,9 +778,9 @@ impl AstNode for ParenExpr {\n }\n impl ast::AttrsOwner for ParenExpr {}\n impl ParenExpr {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n@@ -817,9 +817,9 @@ impl AstNode for LambdaExpr {\n }\n impl ast::AttrsOwner for LambdaExpr {}\n impl LambdaExpr {\n-    pub fn static_kw(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n-    pub fn async_kw(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n-    pub fn move_kw(&self) -> Option<MoveKw> { support::token(&self.syntax) }\n+    pub fn static_kw_token(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n+    pub fn async_kw_token(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n+    pub fn move_kw_token(&self) -> Option<MoveKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -841,7 +841,7 @@ impl AstNode for IfExpr {\n }\n impl ast::AttrsOwner for IfExpr {}\n impl IfExpr {\n-    pub fn if_kw(&self) -> Option<IfKw> { support::token(&self.syntax) }\n+    pub fn if_kw_token(&self) -> Option<IfKw> { support::token(&self.syntax) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -862,7 +862,7 @@ impl AstNode for LoopExpr {\n impl ast::AttrsOwner for LoopExpr {}\n impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n-    pub fn loop_kw(&self) -> Option<LoopKw> { support::token(&self.syntax) }\n+    pub fn loop_kw_token(&self) -> Option<LoopKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryBlockExpr {\n@@ -881,7 +881,7 @@ impl AstNode for TryBlockExpr {\n }\n impl ast::AttrsOwner for TryBlockExpr {}\n impl TryBlockExpr {\n-    pub fn try_kw(&self) -> Option<TryKw> { support::token(&self.syntax) }\n+    pub fn try_kw_token(&self) -> Option<TryKw> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -902,9 +902,9 @@ impl AstNode for ForExpr {\n impl ast::AttrsOwner for ForExpr {}\n impl ast::LoopBodyOwner for ForExpr {}\n impl ForExpr {\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_kw(&self) -> Option<InKw> { support::token(&self.syntax) }\n+    pub fn in_kw_token(&self) -> Option<InKw> { support::token(&self.syntax) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -925,7 +925,7 @@ impl AstNode for WhileExpr {\n impl ast::AttrsOwner for WhileExpr {}\n impl ast::LoopBodyOwner for WhileExpr {}\n impl WhileExpr {\n-    pub fn while_kw(&self) -> Option<WhileKw> { support::token(&self.syntax) }\n+    pub fn while_kw_token(&self) -> Option<WhileKw> { support::token(&self.syntax) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -945,8 +945,8 @@ impl AstNode for ContinueExpr {\n }\n impl ast::AttrsOwner for ContinueExpr {}\n impl ContinueExpr {\n-    pub fn continue_kw(&self) -> Option<ContinueKw> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn continue_kw_token(&self) -> Option<ContinueKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n@@ -965,8 +965,8 @@ impl AstNode for BreakExpr {\n }\n impl ast::AttrsOwner for BreakExpr {}\n impl BreakExpr {\n-    pub fn break_kw(&self) -> Option<BreakKw> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn break_kw_token(&self) -> Option<BreakKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -985,7 +985,7 @@ impl AstNode for Label {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Label {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n@@ -1005,7 +1005,7 @@ impl AstNode for BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n     pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1065,7 +1065,7 @@ impl ast::AttrsOwner for MethodCallExpr {}\n impl ast::ArgListOwner for MethodCallExpr {}\n impl MethodCallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n@@ -1086,8 +1086,8 @@ impl AstNode for IndexExpr {\n }\n impl ast::AttrsOwner for IndexExpr {}\n impl IndexExpr {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n@@ -1107,7 +1107,7 @@ impl AstNode for FieldExpr {\n impl ast::AttrsOwner for FieldExpr {}\n impl FieldExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1128,8 +1128,8 @@ impl AstNode for AwaitExpr {\n impl ast::AttrsOwner for AwaitExpr {}\n impl AwaitExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n-    pub fn await_kw(&self) -> Option<AwaitKw> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn await_kw_token(&self) -> Option<AwaitKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n@@ -1148,7 +1148,7 @@ impl AstNode for TryExpr {\n }\n impl ast::AttrsOwner for TryExpr {}\n impl TryExpr {\n-    pub fn try_kw(&self) -> Option<TryKw> { support::token(&self.syntax) }\n+    pub fn try_kw_token(&self) -> Option<TryKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1169,7 +1169,7 @@ impl AstNode for CastExpr {\n impl ast::AttrsOwner for CastExpr {}\n impl CastExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_kw(&self) -> Option<AsKw> { support::token(&self.syntax) }\n+    pub fn as_kw_token(&self) -> Option<AsKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1189,9 +1189,9 @@ impl AstNode for RefExpr {\n }\n impl ast::AttrsOwner for RefExpr {}\n impl RefExpr {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn raw_kw(&self) -> Option<RawKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn raw_kw_token(&self) -> Option<RawKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1211,7 +1211,7 @@ impl AstNode for PrefixExpr {\n }\n impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n-    pub fn prefix_op(&self) -> Option<PrefixOp> { support::token(&self.syntax) }\n+    pub fn prefix_op_token(&self) -> Option<PrefixOp> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1231,7 +1231,7 @@ impl AstNode for BoxExpr {\n }\n impl ast::AttrsOwner for BoxExpr {}\n impl BoxExpr {\n-    pub fn box_kw(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n+    pub fn box_kw_token(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1251,7 +1251,7 @@ impl AstNode for RangeExpr {\n }\n impl ast::AttrsOwner for RangeExpr {}\n impl RangeExpr {\n-    pub fn range_op(&self) -> Option<RangeOp> { support::token(&self.syntax) }\n+    pub fn range_op_token(&self) -> Option<RangeOp> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n@@ -1270,7 +1270,7 @@ impl AstNode for BinExpr {\n }\n impl ast::AttrsOwner for BinExpr {}\n impl BinExpr {\n-    pub fn bin_op(&self) -> Option<BinOp> { support::token(&self.syntax) }\n+    pub fn bin_op_token(&self) -> Option<BinOp> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n@@ -1288,7 +1288,7 @@ impl AstNode for Literal {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Literal {\n-    pub fn literal_token(&self) -> Option<LiteralToken> { support::token(&self.syntax) }\n+    pub fn literal_token_token(&self) -> Option<LiteralToken> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n@@ -1307,7 +1307,7 @@ impl AstNode for MatchExpr {\n }\n impl ast::AttrsOwner for MatchExpr {}\n impl MatchExpr {\n-    pub fn match_kw(&self) -> Option<MatchKw> { support::token(&self.syntax) }\n+    pub fn match_kw_token(&self) -> Option<MatchKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n@@ -1328,9 +1328,9 @@ impl AstNode for MatchArmList {\n }\n impl ast::AttrsOwner for MatchArmList {}\n impl MatchArmList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n@@ -1351,7 +1351,7 @@ impl ast::AttrsOwner for MatchArm {}\n impl MatchArm {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow(&self) -> Option<FatArrow> { support::token(&self.syntax) }\n+    pub fn fat_arrow_token(&self) -> Option<FatArrow> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1370,7 +1370,7 @@ impl AstNode for MatchGuard {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl MatchGuard {\n-    pub fn if_kw(&self) -> Option<IfKw> { support::token(&self.syntax) }\n+    pub fn if_kw_token(&self) -> Option<IfKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1408,11 +1408,11 @@ impl AstNode for RecordFieldList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n@@ -1432,7 +1432,7 @@ impl AstNode for RecordField {\n impl ast::AttrsOwner for RecordField {}\n impl RecordField {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1469,9 +1469,9 @@ impl AstNode for ParenPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenPat {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n@@ -1489,8 +1489,8 @@ impl AstNode for RefPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RefPat {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1509,7 +1509,7 @@ impl AstNode for BoxPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl BoxPat {\n-    pub fn box_kw(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n+    pub fn box_kw_token(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1530,8 +1530,8 @@ impl AstNode for BindPat {\n impl ast::AttrsOwner for BindPat {}\n impl ast::NameOwner for BindPat {}\n impl BindPat {\n-    pub fn ref_kw(&self) -> Option<RefKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn ref_kw_token(&self) -> Option<RefKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1550,7 +1550,7 @@ impl AstNode for PlaceholderPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderPat {\n-    pub fn underscore(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n@@ -1568,7 +1568,7 @@ impl AstNode for DotDotPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl DotDotPat {\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n@@ -1604,9 +1604,9 @@ impl AstNode for SlicePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SlicePat {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n@@ -1624,7 +1624,7 @@ impl AstNode for RangePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RangePat {\n-    pub fn range_separator(&self) -> Option<RangeSeparator> { support::token(&self.syntax) }\n+    pub fn range_separator_token(&self) -> Option<RangeSeparator> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n@@ -1699,14 +1699,14 @@ impl AstNode for RecordFieldPatList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldPatList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn pats(&self) -> AstChildren<RecordInnerPat> { support::children(&self.syntax) }\n     pub fn record_field_pats(&self) -> AstChildren<RecordFieldPat> {\n         support::children(&self.syntax)\n     }\n     pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n@@ -1726,7 +1726,7 @@ impl AstNode for RecordFieldPat {\n impl ast::AttrsOwner for RecordFieldPat {}\n impl ast::NameOwner for RecordFieldPat {}\n impl RecordFieldPat {\n-    pub fn colon(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1746,9 +1746,9 @@ impl AstNode for TupleStructPat {\n }\n impl TupleStructPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n@@ -1766,9 +1766,9 @@ impl AstNode for TuplePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TuplePat {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n@@ -1786,10 +1786,10 @@ impl AstNode for Visibility {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Visibility {\n-    pub fn pub_kw(&self) -> Option<PubKw> { support::token(&self.syntax) }\n-    pub fn super_kw(&self) -> Option<SuperKw> { support::token(&self.syntax) }\n-    pub fn self_kw(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n-    pub fn crate_kw(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n+    pub fn pub_kw_token(&self) -> Option<PubKw> { support::token(&self.syntax) }\n+    pub fn super_kw_token(&self) -> Option<SuperKw> { support::token(&self.syntax) }\n+    pub fn self_kw_token(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n+    pub fn crate_kw_token(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n@@ -1807,7 +1807,7 @@ impl AstNode for Name {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Name {\n-    pub fn ident(&self) -> Option<Ident> { support::token(&self.syntax) }\n+    pub fn ident_token(&self) -> Option<Ident> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n@@ -1825,7 +1825,7 @@ impl AstNode for NameRef {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NameRef {\n-    pub fn name_ref_token(&self) -> Option<NameRefToken> { support::token(&self.syntax) }\n+    pub fn name_ref_token_token(&self) -> Option<NameRefToken> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n@@ -1847,9 +1847,9 @@ impl ast::AttrsOwner for MacroCall {}\n impl ast::DocCommentsOwner for MacroCall {}\n impl MacroCall {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n@@ -1867,13 +1867,13 @@ impl AstNode for Attr {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Attr {\n-    pub fn pound(&self) -> Option<Pound> { support::token(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn pound_token(&self) -> Option<Pound> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -1907,12 +1907,12 @@ impl AstNode for TypeParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeParamList {\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n     pub fn type_params(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }\n     pub fn lifetime_params(&self) -> AstChildren<LifetimeParam> { support::children(&self.syntax) }\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n@@ -1933,7 +1933,7 @@ impl ast::NameOwner for TypeParam {}\n impl ast::AttrsOwner for TypeParam {}\n impl ast::TypeBoundsOwner for TypeParam {}\n impl TypeParam {\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1955,7 +1955,7 @@ impl ast::NameOwner for ConstParam {}\n impl ast::AttrsOwner for ConstParam {}\n impl ast::TypeAscriptionOwner for ConstParam {}\n impl ConstParam {\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1975,7 +1975,7 @@ impl AstNode for LifetimeParam {\n }\n impl ast::AttrsOwner for LifetimeParam {}\n impl LifetimeParam {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n@@ -1993,8 +1993,8 @@ impl AstNode for TypeBound {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeBound {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2032,7 +2032,7 @@ impl AstNode for WherePred {\n }\n impl ast::TypeBoundsOwner for WherePred {}\n impl WherePred {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2051,7 +2051,7 @@ impl AstNode for WhereClause {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl WhereClause {\n-    pub fn where_kw(&self) -> Option<WhereKw> { support::token(&self.syntax) }\n+    pub fn where_kw_token(&self) -> Option<WhereKw> { support::token(&self.syntax) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2070,7 +2070,7 @@ impl AstNode for Abi {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Abi {\n-    pub fn string(&self) -> Option<String> { support::token(&self.syntax) }\n+    pub fn string_token(&self) -> Option<String> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n@@ -2090,7 +2090,7 @@ impl AstNode for ExprStmt {\n impl ast::AttrsOwner for ExprStmt {}\n impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n@@ -2110,9 +2110,9 @@ impl AstNode for LetStmt {\n impl ast::AttrsOwner for LetStmt {}\n impl ast::TypeAscriptionOwner for LetStmt {}\n impl LetStmt {\n-    pub fn let_kw(&self) -> Option<LetKw> { support::token(&self.syntax) }\n+    pub fn let_kw_token(&self) -> Option<LetKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2131,9 +2131,9 @@ impl AstNode for Condition {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Condition {\n-    pub fn let_kw(&self) -> Option<LetKw> { support::token(&self.syntax) }\n+    pub fn let_kw_token(&self) -> Option<LetKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2154,10 +2154,10 @@ impl AstNode for Block {\n impl ast::AttrsOwner for Block {}\n impl ast::ModuleItemOwner for Block {}\n impl Block {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n@@ -2175,10 +2175,10 @@ impl AstNode for ParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParamList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n@@ -2198,9 +2198,9 @@ impl AstNode for SelfParam {\n impl ast::TypeAscriptionOwner for SelfParam {}\n impl ast::AttrsOwner for SelfParam {}\n impl SelfParam {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn self_kw(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn self_kw_token(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n@@ -2221,7 +2221,7 @@ impl ast::TypeAscriptionOwner for Param {}\n impl ast::AttrsOwner for Param {}\n impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn dotdotdot(&self) -> Option<Dotdotdot> { support::token(&self.syntax) }\n+    pub fn dotdotdot_token(&self) -> Option<Dotdotdot> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n@@ -2241,7 +2241,7 @@ impl AstNode for UseItem {\n impl ast::AttrsOwner for UseItem {}\n impl ast::VisibilityOwner for UseItem {}\n impl UseItem {\n-    pub fn use_kw(&self) -> Option<UseKw> { support::token(&self.syntax) }\n+    pub fn use_kw_token(&self) -> Option<UseKw> { support::token(&self.syntax) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2261,7 +2261,7 @@ impl AstNode for UseTree {\n }\n impl UseTree {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn star(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2282,7 +2282,7 @@ impl AstNode for Alias {\n }\n impl ast::NameOwner for Alias {}\n impl Alias {\n-    pub fn as_kw(&self) -> Option<AsKw> { support::token(&self.syntax) }\n+    pub fn as_kw_token(&self) -> Option<AsKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n@@ -2300,9 +2300,9 @@ impl AstNode for UseTreeList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl UseTreeList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n@@ -2322,8 +2322,8 @@ impl AstNode for ExternCrateItem {\n impl ast::AttrsOwner for ExternCrateItem {}\n impl ast::VisibilityOwner for ExternCrateItem {}\n impl ExternCrateItem {\n-    pub fn extern_kw(&self) -> Option<ExternKw> { support::token(&self.syntax) }\n-    pub fn crate_kw(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n+    pub fn extern_kw_token(&self) -> Option<ExternKw> { support::token(&self.syntax) }\n+    pub fn crate_kw_token(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2343,9 +2343,9 @@ impl AstNode for ArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArgList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -2382,14 +2382,14 @@ impl AstNode for PathSegment {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PathSegment {\n-    pub fn coloncolon(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n@@ -2407,14 +2407,14 @@ impl AstNode for TypeArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeArgList {\n-    pub fn coloncolon(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n     pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n     pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n@@ -2452,7 +2452,7 @@ impl AstNode for AssocTypeArg {\n impl ast::TypeBoundsOwner for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2471,7 +2471,7 @@ impl AstNode for LifetimeArg {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl LifetimeArg {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n@@ -2490,7 +2490,7 @@ impl AstNode for ConstArg {\n }\n impl ConstArg {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2548,9 +2548,9 @@ impl AstNode for ExternItemList {\n impl ast::FnDefOwner for ExternItemList {}\n impl ast::ModuleItemOwner for ExternItemList {}\n impl ExternItemList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n@@ -2588,7 +2588,7 @@ impl AstNode for MetaItem {\n }\n impl MetaItem {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }"}, {"sha": "b5594e3a982e691011b6e28fdb5927bfe7e555dd", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d22187a67e762bb950de244a6ca15f3a0b0731/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d22187a67e762bb950de244a6ca15f3a0b0731/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=e6d22187a67e762bb950de244a6ca15f3a0b0731", "patch": "@@ -208,6 +208,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n                     let is_token = token_kinds.contains(&ty.to_string());\n                     if is_token {\n+                        let method_name = format_ident!(\"{}_token\", method_name);\n                         quote! {\n                             pub fn #method_name(&self) -> Option<#ty> {\n                                 support::token(&self.syntax)"}]}