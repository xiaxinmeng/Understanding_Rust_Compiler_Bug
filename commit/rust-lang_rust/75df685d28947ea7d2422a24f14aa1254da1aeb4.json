{"sha": "75df685d28947ea7d2422a24f14aa1254da1aeb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZGY2ODVkMjg5NDdlYTdkMjQyMmEyNGYxNGFhMTI1NGRhMWFlYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-03T11:25:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-03T11:25:58Z"}, "message": "Auto merge of #36766 - nnethercote:hash-span-capacity, r=bluss\n\nClarify HashMap's capacity handling.\n\nHashMap has two notions of \"capacity\":\n\n- \"Usable capacity\": the number of elements a hash map can hold without\n  resizing. This is the meaning of \"capacity\" used in HashMap's API,\n  e.g. the `with_capacity()` function.\n\n- \"Internal capacity\": the number of allocated slots. Except for the\n  zero case, it is always larger than the usable capacity (because some\n  slots must be left empty) and is always a power of two.\n\nHashMap's code is confusing because it does a poor job of\ndistinguishing these two meanings. I propose using two different terms\nfor these two concepts. Because \"capacity\" is already used in HashMap's\nAPI to mean \"usable capacity\", I will use a different word for \"internal\ncapacity\". I propose \"span\", though I'm happy to consider other names.", "tree": {"sha": "b407534e3141ef6818cbcc2709bec0118d5ffb45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b407534e3141ef6818cbcc2709bec0118d5ffb45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75df685d28947ea7d2422a24f14aa1254da1aeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75df685d28947ea7d2422a24f14aa1254da1aeb4", "html_url": "https://github.com/rust-lang/rust/commit/75df685d28947ea7d2422a24f14aa1254da1aeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75df685d28947ea7d2422a24f14aa1254da1aeb4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3745653e10e366e7e119a12c178a59ab6394007", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3745653e10e366e7e119a12c178a59ab6394007", "html_url": "https://github.com/rust-lang/rust/commit/f3745653e10e366e7e119a12c178a59ab6394007"}, {"sha": "607d2973da7bd5895a5e84a65ba5174527bee904", "url": "https://api.github.com/repos/rust-lang/rust/commits/607d2973da7bd5895a5e84a65ba5174527bee904", "html_url": "https://github.com/rust-lang/rust/commit/607d2973da7bd5895a5e84a65ba5174527bee904"}], "stats": {"total": 212, "additions": 122, "deletions": 90}, "files": [{"sha": "b0a6c224897468b71a8f6d75624f31d5d7c9aa81", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 94, "deletions": 85, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/75df685d28947ea7d2422a24f14aa1254da1aeb4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75df685d28947ea7d2422a24f14aa1254da1aeb4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=75df685d28947ea7d2422a24f14aa1254da1aeb4", "patch": "@@ -34,13 +34,9 @@ use super::table::BucketState::{\n     Full,\n };\n \n-const INITIAL_LOG2_CAP: usize = 5;\n-const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n+const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n \n-/// The default behavior of HashMap implements a load factor of 90.9%.\n-/// This behavior is characterized by the following condition:\n-///\n-/// - if size > 0.909 * capacity: grow the map\n+/// The default behavior of HashMap implements a maximum load factor of 90.9%.\n #[derive(Clone)]\n struct DefaultResizePolicy;\n \n@@ -49,40 +45,35 @@ impl DefaultResizePolicy {\n         DefaultResizePolicy\n     }\n \n+    /// A hash map's \"capacity\" is the number of elements it can hold without\n+    /// being resized. Its \"raw capacity\" is the number of slots required to\n+    /// provide that capacity, accounting for maximum loading. The raw capacity\n+    /// is always zero or a power of two.\n     #[inline]\n-    fn min_capacity(&self, usable_size: usize) -> usize {\n-        // Here, we are rephrasing the logic by specifying the lower limit\n-        // on capacity:\n-        //\n-        // - if `cap < size * 1.1`: grow the map\n-        usable_size * 11 / 10\n+    fn raw_capacity(&self, len: usize) -> usize {\n+        if len == 0 {\n+            0\n+        } else {\n+            // 1. Account for loading: `raw_capacity >= len * 1.1`.\n+            // 2. Ensure it is a power of two.\n+            // 3. Ensure it is at least the minimum size.\n+            let mut raw_cap = len * 11 / 10;\n+            assert!(raw_cap >= len, \"raw_cap overflow\");\n+            raw_cap = raw_cap.checked_next_power_of_two().expect(\"raw_capacity overflow\");\n+            raw_cap = max(MIN_NONZERO_RAW_CAPACITY, raw_cap);\n+            raw_cap\n+        }\n     }\n \n-    /// An inverse of `min_capacity`, approximately.\n+    /// The capacity of the given raw capacity.\n     #[inline]\n-    fn usable_capacity(&self, cap: usize) -> usize {\n-        // As the number of entries approaches usable capacity,\n-        // min_capacity(size) must be smaller than the internal capacity,\n-        // so that the map is not resized:\n-        // `min_capacity(usable_capacity(x)) <= x`.\n-        // The left-hand side can only be smaller due to flooring by integer\n-        // division.\n-        //\n+    fn capacity(&self, raw_cap: usize) -> usize {\n         // This doesn't have to be checked for overflow since allocation size\n         // in bytes will overflow earlier than multiplication by 10.\n         //\n         // As per https://github.com/rust-lang/rust/pull/30991 this is updated\n-        // to be: (cap * den + den - 1) / num\n-        (cap * 10 + 10 - 1) / 11\n-    }\n-}\n-\n-#[test]\n-fn test_resize_policy() {\n-    let rp = DefaultResizePolicy;\n-    for n in 0..1000 {\n-        assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n-        assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n+        // to be: (raw_cap * den + den - 1) / num\n+        (raw_cap * 10 + 10 - 1) / 11\n     }\n }\n \n@@ -540,11 +531,11 @@ impl<K, V, S> HashMap<K, V, S>\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let cap = self.table.capacity();\n+        let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n         let ib = buckets.index();\n \n-        while buckets.index() != ib + cap {\n+        while buckets.index() != ib + raw_cap {\n             // We don't need to compare hashes for value swap.\n             // Not even DIBs for Robin Hood.\n             buckets = match buckets.peek() {\n@@ -575,7 +566,10 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty `HashMap` with the given initial capacity.\n+    /// Creates an empty `HashMap` with the specified capacity.\n+    ///\n+    /// The hash map will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -623,9 +617,11 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Creates an empty `HashMap` with space for at least `capacity`\n-    /// elements, using `hasher` to hash the keys.\n+    /// Creates an empty `HashMap` with the specified capacity, using `hasher`\n+    /// to hash the keys.\n     ///\n+    /// The hash map will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n     /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n@@ -646,13 +642,11 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)\n                                     -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n-        let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n-        let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n-        assert!(internal_cap >= capacity, \"capacity overflow\");\n+        let raw_cap = resize_policy.raw_capacity(capacity);\n         HashMap {\n             hash_builder: hash_builder,\n             resize_policy: resize_policy,\n-            table: RawTable::new(internal_cap),\n+            table: RawTable::new(raw_cap),\n         }\n     }\n \n@@ -677,7 +671,13 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.resize_policy.usable_capacity(self.table.capacity())\n+        self.resize_policy.capacity(self.raw_capacity())\n+    }\n+\n+    /// Returns the hash map's raw capacity.\n+    #[inline]\n+    fn raw_capacity(&self) -> usize {\n+        self.table.capacity()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -697,28 +697,24 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let min_cap = self.resize_policy.min_capacity(new_size);\n-\n-        // An invalid value shouldn't make us run out of space. This includes\n-        // an overflow check.\n-        assert!(new_size <= min_cap);\n-\n-        if self.table.capacity() < min_cap {\n-            let new_capacity = max(min_cap.next_power_of_two(), INITIAL_CAPACITY);\n-            self.resize(new_capacity);\n+        let remaining = self.capacity() - self.len(); // this can't overflow\n+        if remaining < additional {\n+            let min_cap = self.len().checked_add(additional).expect(\"reserve overflow\");\n+            let raw_cap = self.resize_policy.raw_capacity(min_cap);\n+            self.resize(raw_cap);\n         }\n     }\n \n-    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n-    ///   1) Make sure the new capacity is enough for all the elements, accounting\n+    /// Resizes the internal vectors to a new capacity. It's your\n+    /// responsibility to:\n+    ///   1) Ensure `new_raw_cap` is enough for all the elements, accounting\n     ///      for the load factor.\n-    ///   2) Ensure `new_capacity` is a power of two or zero.\n-    fn resize(&mut self, new_capacity: usize) {\n-        assert!(self.table.size() <= new_capacity);\n-        assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n+    ///   2) Ensure `new_raw_cap` is a power of two or zero.\n+    fn resize(&mut self, new_raw_cap: usize) {\n+        assert!(self.table.size() <= new_raw_cap);\n+        assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n+        let mut old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n         let old_size = old_table.size();\n \n         if old_table.capacity() == 0 || old_table.size() == 0 {\n@@ -808,14 +804,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let min_capacity = self.resize_policy.min_capacity(self.len());\n-        let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n-\n-        // An invalid value shouldn't make us run out of space.\n-        debug_assert!(self.len() <= min_capacity);\n-\n-        if self.table.capacity() != min_capacity {\n-            let old_table = replace(&mut self.table, RawTable::new(min_capacity));\n+        let new_raw_cap = self.resize_policy.raw_capacity(self.len());\n+        if self.raw_capacity() != new_raw_cap {\n+            let old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n             let old_size = old_table.size();\n \n             // Shrink the table. Naive algorithm for resizing:\n@@ -2122,7 +2113,7 @@ mod test_map {\n     use rand::{thread_rng, Rng};\n \n     #[test]\n-    fn test_create_capacities() {\n+    fn test_zero_capacities() {\n         type HM = HashMap<i32, i32>;\n \n         let m = HM::new();\n@@ -2133,6 +2124,24 @@ mod test_map {\n \n         let m = HM::with_hasher(RandomState::new());\n         assert_eq!(m.capacity(), 0);\n+\n+        let m = HM::with_capacity(0);\n+        assert_eq!(m.capacity(), 0);\n+\n+        let m = HM::with_capacity_and_hasher(0, RandomState::new());\n+        assert_eq!(m.capacity(), 0);\n+\n+        let mut m = HM::new();\n+        m.insert(1, 1);\n+        m.insert(2, 2);\n+        m.remove(&1);\n+        m.remove(&2);\n+        m.shrink_to_fit();\n+        assert_eq!(m.capacity(), 0);\n+\n+        let mut m = HM::new();\n+        m.reserve(0);\n+        assert_eq!(m.capacity(), 0);\n     }\n \n     #[test]\n@@ -2592,8 +2601,8 @@ mod test_map {\n         assert!(m.is_empty());\n \n         let mut i = 0;\n-        let old_cap = m.table.capacity();\n-        while old_cap == m.table.capacity() {\n+        let old_raw_cap = m.raw_capacity();\n+        while old_raw_cap == m.raw_capacity() {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -2607,55 +2616,55 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         assert_eq!(m.len(), 0);\n-        assert_eq!(m.table.capacity(), 0);\n+        assert_eq!(m.raw_capacity(), 0);\n         assert!(m.is_empty());\n \n         m.insert(0, 0);\n         m.remove(&0);\n         assert!(m.is_empty());\n-        let initial_cap = m.table.capacity();\n-        m.reserve(initial_cap);\n-        let cap = m.table.capacity();\n+        let initial_raw_cap = m.raw_capacity();\n+        m.reserve(initial_raw_cap);\n+        let raw_cap = m.raw_capacity();\n \n-        assert_eq!(cap, initial_cap * 2);\n+        assert_eq!(raw_cap, initial_raw_cap * 2);\n \n         let mut i = 0;\n-        for _ in 0..cap * 3 / 4 {\n+        for _ in 0..raw_cap * 3 / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n         // three quarters full\n \n         assert_eq!(m.len(), i);\n-        assert_eq!(m.table.capacity(), cap);\n+        assert_eq!(m.raw_capacity(), raw_cap);\n \n-        for _ in 0..cap / 4 {\n+        for _ in 0..raw_cap / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n         // half full\n \n-        let new_cap = m.table.capacity();\n-        assert_eq!(new_cap, cap * 2);\n+        let new_raw_cap = m.raw_capacity();\n+        assert_eq!(new_raw_cap, raw_cap * 2);\n \n-        for _ in 0..cap / 2 - 1 {\n+        for _ in 0..raw_cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n-            assert_eq!(m.table.capacity(), new_cap);\n+            assert_eq!(m.raw_capacity(), new_raw_cap);\n         }\n         // A little more than one quarter full.\n         m.shrink_to_fit();\n-        assert_eq!(m.table.capacity(), cap);\n+        assert_eq!(m.raw_capacity(), raw_cap);\n         // again, a little more than half full\n-        for _ in 0..cap / 2 - 1 {\n+        for _ in 0..raw_cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n         }\n         m.shrink_to_fit();\n \n         assert_eq!(m.len(), i);\n         assert!(!m.is_empty());\n-        assert_eq!(m.table.capacity(), initial_cap);\n+        assert_eq!(m.raw_capacity(), initial_raw_cap);\n     }\n \n     #[test]"}, {"sha": "e5fe3c2f7c61f55550b421fec6447181b11ef2a3", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/75df685d28947ea7d2422a24f14aa1254da1aeb4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75df685d28947ea7d2422a24f14aa1254da1aeb4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=75df685d28947ea7d2422a24f14aa1254da1aeb4", "patch": "@@ -133,8 +133,10 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n         HashSet { map: HashMap::new() }\n     }\n \n-    /// Creates an empty HashSet with space for at least `n` elements in\n-    /// the hash table.\n+    /// Creates an empty `HashSet` with the specified capacity.\n+    ///\n+    /// The hash set will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -178,8 +180,11 @@ impl<T, S> HashSet<T, S>\n         HashSet { map: HashMap::with_hasher(hasher) }\n     }\n \n-    /// Creates an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `hasher` to hash the keys.\n+    /// Creates an empty HashSet with with the specified capacity, using\n+    /// `hasher` to hash the keys.\n+    ///\n+    /// The hash set will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n@@ -1082,7 +1087,7 @@ mod test_set {\n     use super::super::map::RandomState;\n \n     #[test]\n-    fn test_create_capacities() {\n+    fn test_zero_capacities() {\n         type HS = HashSet<i32>;\n \n         let s = HS::new();\n@@ -1093,6 +1098,24 @@ mod test_set {\n \n         let s = HS::with_hasher(RandomState::new());\n         assert_eq!(s.capacity(), 0);\n+\n+        let s = HS::with_capacity(0);\n+        assert_eq!(s.capacity(), 0);\n+\n+        let s = HS::with_capacity_and_hasher(0, RandomState::new());\n+        assert_eq!(s.capacity(), 0);\n+\n+        let mut s = HS::new();\n+        s.insert(1);\n+        s.insert(2);\n+        s.remove(&1);\n+        s.remove(&2);\n+        s.shrink_to_fit();\n+        assert_eq!(s.capacity(), 0);\n+\n+        let mut s = HS::new();\n+        s.reserve(0);\n+        assert_eq!(s.capacity(), 0);\n     }\n \n     #[test]"}]}