{"sha": "5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhODRmOWI4NmVjM2UyYjViNjM5M2ZhZWJlZWFhOTZkYzZjMjExOTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-20T17:32:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-20T17:32:09Z"}, "message": "Rollup merge of #66496 - petrochenkov:metapriv2, r=eddyb\n\nrustc_metadata: Privatize more things\n\nContinuation of https://github.com/rust-lang/rust/pull/66056.\n\nThe most notable change here is that `CrateMetadata` is moved from `cstore.rs` to `decoder.rs`.\nMost of uses of `CrateMetadata` fields are in the decoder and uses of `root: CrateRoot` and other fields are so intertwined with each other that it would be hard to move a part of them into `cstore.rs` to privatize `CrateMetadata` fields, so we are going the other way round.\n\n`cstore.rs` can probably be dismantled now, but I'll leave this to some other day.\nSimilarly, remaining `CrateMetadata` fields can be privatized by introducing some getter/setter methods, but not today.\n\nr? @eddyb", "tree": {"sha": "7676faeea8e4821a4e4931a41f98807daa7f29ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7676faeea8e4821a4e4931a41f98807daa7f29ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1XiZCRBK7hj4Ov3rIwAAdHIIACUdHwHBo8ZFcFFg/x7DcesA\n8ev3Mnm0UeJav9Isvc8Hs5f/AqoAA2NAU+KurmrtJ+Ehsqas4gBEofjWvrxLW8ym\nwN+feI7gGMtcOwIWNMHJyjt1l5dHJS1yoL9Wd6+fUK7AsJLZ4UDsOIDd4+osde3Z\n+63JEK87TF/cVwzB8qrXCfi+OVoHnl8EAZetT+XN/hK2fA+6CUz0ouz4+N3lhyqu\n6ZwDZsCDwfOLB0GxvzQVucSnfocJHqcnXvF3YzG1oPDXBwzu0Il3fp6r4b3KhDZT\nIMBQgSibOdQpA1uRMo7p8G0ChA4kf9mwvLdcDvU+VirRK01txl6smqgMdVM1gxo=\n=eR8i\n-----END PGP SIGNATURE-----\n", "payload": "tree 7676faeea8e4821a4e4931a41f98807daa7f29ae\nparent 647eda17e825b61511e66d7d01ac737cae054ee3\nparent febde53fde9fa88f5e1ea2b779c002a6f0d68cd6\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574271129 +0100\ncommitter GitHub <noreply@github.com> 1574271129 +0100\n\nRollup merge of #66496 - petrochenkov:metapriv2, r=eddyb\n\nrustc_metadata: Privatize more things\n\nContinuation of https://github.com/rust-lang/rust/pull/66056.\n\nThe most notable change here is that `CrateMetadata` is moved from `cstore.rs` to `decoder.rs`.\nMost of uses of `CrateMetadata` fields are in the decoder and uses of `root: CrateRoot` and other fields are so intertwined with each other that it would be hard to move a part of them into `cstore.rs` to privatize `CrateMetadata` fields, so we are going the other way round.\n\n`cstore.rs` can probably be dismantled now, but I'll leave this to some other day.\nSimilarly, remaining `CrateMetadata` fields can be privatized by introducing some getter/setter methods, but not today.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "html_url": "https://github.com/rust-lang/rust/commit/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "647eda17e825b61511e66d7d01ac737cae054ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/647eda17e825b61511e66d7d01ac737cae054ee3", "html_url": "https://github.com/rust-lang/rust/commit/647eda17e825b61511e66d7d01ac737cae054ee3"}, {"sha": "febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "html_url": "https://github.com/rust-lang/rust/commit/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6"}], "stats": {"total": 625, "additions": 343, "deletions": 282}, "files": [{"sha": "a721e381b4e9971ef560a7e374d4daea9d29d73c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 51, "deletions": 81, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -1,21 +1,17 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore, MetadataBlob};\n-use crate::locator::{self, CratePaths};\n-use crate::rmeta::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lock, Once, AtomicCell};\n+use crate::cstore::CStore;\n+use crate::locator::{CrateLocator, CratePaths};\n+use crate::rmeta::{CrateMetadata, CrateNumMap, CrateRoot, CrateDep, MetadataBlob};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n-use rustc::dep_graph::DepNodeIndex;\n use rustc::middle::cstore::DepKind;\n-use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n-use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -50,9 +46,9 @@ pub struct CrateLoader<'a> {\n \n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|_, data| {\n+    cstore.iter_crate_data(|cnum, data| {\n         info!(\"  name: {}\", data.root.name);\n-        info!(\"  cnum: {}\", data.cnum);\n+        info!(\"  cnum: {}\", cnum);\n         info!(\"  hash: {}\", data.root.hash);\n         info!(\"  reqd: {:?}\", *data.dep_kind.lock());\n         let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n@@ -68,13 +64,13 @@ enum LoadResult {\n }\n \n enum LoadError<'a> {\n-    LocatorError(locator::Context<'a>),\n+    LocatorError(CrateLocator<'a>),\n }\n \n impl<'a> LoadError<'a> {\n     fn report(self) -> ! {\n         match self {\n-            LoadError::LocatorError(locate_ctxt) => locate_ctxt.report_errs(),\n+            LoadError::LocatorError(locator) => locator.report_errs(),\n         }\n     }\n }\n@@ -145,7 +141,7 @@ impl<'a> CrateLoader<'a> {\n             let prev_kind = source.dylib.as_ref().or(source.rlib.as_ref())\n                                   .or(source.rmeta.as_ref())\n                                   .expect(\"No sources for crate\").1;\n-            if ret.is_none() && (prev_kind == kind || prev_kind == PathKind::All) {\n+            if kind.matches(prev_kind) {\n                 ret = Some(cnum);\n             }\n         });\n@@ -211,71 +207,52 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths { name: crate_root.name, source: source.clone() };\n+            crate_paths = CratePaths::new(crate_root.name, source.clone());\n             &crate_paths\n         };\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n-        let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n-\n-        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n+        let raw_proc_macros = if crate_root.is_proc_macro_crate() {\n             let temp_root;\n             let (dlsym_source, dlsym_root) = match &host_lib {\n                 Some(host_lib) =>\n                     (&host_lib.source, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n-        });\n-\n-        let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n-                                                        .decode(&metadata)\n-                                                        .collect();\n-        let trait_impls = crate_root\n-            .impls\n-            .decode((&metadata, self.sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-            .collect();\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            crate_root.def_path_table.decode((&metadata, self.sess))\n-        });\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span))\n+        } else {\n+            None\n+        };\n \n-        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n-            extern_crate: Lock::new(None),\n-            def_path_table,\n-            trait_impls,\n-            root: crate_root,\n-            host_hash,\n-            blob: metadata,\n-            cnum_map,\n+        self.cstore.set_crate_data(cnum, CrateMetadata::new(\n+            self.sess,\n+            metadata,\n+            crate_root,\n+            raw_proc_macros,\n             cnum,\n-            dependencies: Lock::new(dependencies),\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n-            dep_kind: Lock::new(dep_kind),\n+            cnum_map,\n+            dep_kind,\n             source,\n             private_dep,\n-            raw_proc_macros,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        });\n+            host_hash,\n+        ));\n \n         cnum\n     }\n \n     fn load_proc_macro<'b>(\n         &self,\n-        locate_ctxt: &mut locator::Context<'b>,\n+        locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n     ) -> Option<(LoadResult, Option<Library>)>\n     where\n         'a: 'b,\n     {\n-        // Use a new locator Context so trying to load a proc macro doesn't affect the error\n+        // Use a new crate locator so trying to load a proc macro doesn't affect the error\n         // message we emit\n-        let mut proc_macro_locator = locate_ctxt.clone();\n+        let mut proc_macro_locator = locator.clone();\n \n         // Try to load a proc macro\n         proc_macro_locator.is_proc_macro = Some(true);\n@@ -287,10 +264,10 @@ impl<'a> CrateLoader<'a> {\n                 LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n                 LoadResult::Loaded(library) => Some(LoadResult::Loaded(library))\n             };\n-            locate_ctxt.hash = locate_ctxt.host_hash;\n-            // Use the locate_ctxt when looking for the host proc macro crate, as that is required\n+            locator.hash = locator.host_hash;\n+            // Use the locator when looking for the host proc macro crate, as that is required\n             // so we want it to affect the error message\n-            (locate_ctxt, result)\n+            (locator, result)\n         } else {\n             (&mut proc_macro_locator, None)\n         };\n@@ -350,37 +327,30 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n-            let mut locate_ctxt = locator::Context {\n-                sess: self.sess,\n-                span,\n-                crate_name: name,\n+            let mut locator = CrateLocator::new(\n+                self.sess,\n+                self.metadata_loader,\n+                name,\n                 hash,\n                 host_hash,\n                 extra_filename,\n-                filesearch: self.sess.target_filesearch(path_kind),\n-                target: &self.sess.target.target,\n-                triple: self.sess.opts.target_triple.clone(),\n+                false, // is_host\n+                path_kind,\n+                span,\n                 root,\n-                rejected_via_hash: vec![],\n-                rejected_via_triple: vec![],\n-                rejected_via_kind: vec![],\n-                rejected_via_version: vec![],\n-                rejected_via_filename: vec![],\n-                should_match_name: true,\n-                is_proc_macro: Some(false),\n-                metadata_loader: self.metadata_loader,\n-            };\n+                Some(false), // is_proc_macro\n+            );\n \n-            self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n+            self.load(&mut locator).map(|r| (r, None)).or_else(|| {\n                 dep_kind = DepKind::UnexportedMacrosOnly;\n-                self.load_proc_macro(&mut locate_ctxt, path_kind)\n-            }).ok_or_else(move || LoadError::LocatorError(locate_ctxt))?\n+                self.load_proc_macro(&mut locator, path_kind)\n+            }).ok_or_else(move || LoadError::LocatorError(locator))?\n         };\n \n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_data.is_some() {\n+                if data.root.is_proc_macro_crate() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -395,8 +365,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn load(&self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n-        let library = locate_ctxt.maybe_load_library_crate()?;\n+    fn load(&self, locator: &mut CrateLocator<'_>) -> Option<LoadResult> {\n+        let library = locator.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash\n@@ -407,11 +377,11 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locate_ctxt.triple == self.sess.opts.target_triple {\n+        if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.root.name == root.name && root.hash == data.root.hash {\n-                    assert!(locate_ctxt.hash.is_none());\n+                    assert!(locator.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n                 }\n@@ -471,16 +441,16 @@ impl<'a> CrateLoader<'a> {\n                           krate: CrateNum,\n                           span: Span,\n                           dep_kind: DepKind)\n-                          -> cstore::CrateNumMap {\n+                          -> CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_data.is_some() {\n-            return cstore::CrateNumMap::new();\n+        if crate_root.is_proc_macro_crate() {\n+            return CrateNumMap::new();\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n+        std::iter::once(krate).chain(crate_root.decode_crate_deps(metadata).map(|dep| {\n             info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n                   dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n@@ -824,7 +794,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,\n-                            needs_dep: &dyn Fn(&cstore::CrateMetadata) -> bool) {\n+                            needs_dep: &dyn Fn(&CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow."}, {"sha": "48cf0b982f2902192775ab755f8aff95d852c59c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 93, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -1,109 +1,23 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use crate::rmeta;\n-use rustc::dep_graph::DepNodeIndex;\n-use rustc::hir::def_id::{CrateNum, DefIndex};\n-use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n-use rustc::mir::interpret::AllocDecodingState;\n+use crate::rmeta::CrateMetadata;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::sync::{Lrc, Lock, MetadataRef, Once, AtomicCell};\n-use rustc_data_structures::svh::Svh;\n+use rustc::hir::def_id::CrateNum;\n use syntax::ast;\n use syntax::edition::Edition;\n-use syntax_expand::base::SyntaxExtension;\n use syntax::expand::allocator::AllocatorKind;\n-use syntax_pos;\n-use proc_macro::bridge::client::ProcMacro;\n+use syntax_expand::base::SyntaxExtension;\n \n pub use crate::rmeta::{provide, provide_extern};\n \n-// A map from external crate numbers (as decoded from some crate file) to\n-// local crate numbers (as generated during this session). Each external\n-// crate may refer to types in other external crates, and each has their\n-// own crate numbers.\n-crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n-\n-crate struct MetadataBlob(pub MetadataRef);\n-\n-/// Holds information about a syntax_pos::SourceFile imported from another crate.\n-/// See `imported_source_files()` for more information.\n-crate struct ImportedSourceFile {\n-    /// This SourceFile's byte-offset within the source_map of its original crate\n-    pub original_start_pos: syntax_pos::BytePos,\n-    /// The end of this SourceFile within the source_map of its original crate\n-    pub original_end_pos: syntax_pos::BytePos,\n-    /// The imported SourceFile's representation within the local source_map\n-    pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n-}\n-\n-crate struct CrateMetadata {\n-    /// The primary crate data - binary metadata blob.\n-    crate blob: MetadataBlob,\n-\n-    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-\n-    /// Properties of the whole crate.\n-    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `Lazy`, and therefore acts like an\n-    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    /// is being used to decode those values.\n-    crate root: rmeta::CrateRoot<'static>,\n-    /// For each definition in this crate, we encode a key. When the\n-    /// crate is loaded, we read all the keys and put them in this\n-    /// hashmap, which gives the reverse mapping. This allows us to\n-    /// quickly retrace a `DefPath`, which is needed for incremental\n-    /// compilation support.\n-    crate def_path_table: DefPathTable,\n-    /// Trait impl data.\n-    /// FIXME: Used only from queries and can use query cache,\n-    /// so pre-decoding can probably be avoided.\n-    crate trait_impls: FxHashMap<(u32, DefIndex), rmeta::Lazy<[DefIndex]>>,\n-    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n-    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n-    /// Source maps for code from the crate.\n-    crate source_map_import_info: Once<Vec<ImportedSourceFile>>,\n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    crate alloc_decoding_state: AllocDecodingState,\n-    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n-    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n-    /// Do not access the value directly, as it might not have been initialized yet.\n-    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    crate dep_node_index: AtomicCell<DepNodeIndex>,\n-\n-    // --- Other significant crate properties ---\n-\n-    /// ID of this crate, from the current compilation session's point of view.\n-    crate cnum: CrateNum,\n-    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n-    /// IDs as they are seen from the current compilation session.\n-    crate cnum_map: CrateNumMap,\n-    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    crate dependencies: Lock<Vec<CrateNum>>,\n-    /// How to link (or not link) this crate to the currently compiled crate.\n-    crate dep_kind: Lock<DepKind>,\n-    /// Filesystem location of this crate.\n-    crate source: CrateSource,\n-    /// Whether or not this crate should be consider a private dependency\n-    /// for purposes of the 'exported_private_dependencies' lint\n-    crate private_dep: bool,\n-    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n-    crate host_hash: Option<Svh>,\n-\n-    // --- Data used only for improving diagnostics ---\n-\n-    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n-    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n-    crate extern_crate: Lock<Option<ExternCrate>>,\n-}\n-\n #[derive(Clone)]\n pub struct CStore {\n     metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n-    pub(crate) injected_panic_runtime: Option<CrateNum>,\n-    pub(crate) allocator_kind: Option<AllocatorKind>,\n+    crate injected_panic_runtime: Option<CrateNum>,\n+    crate allocator_kind: Option<AllocatorKind>,\n }\n \n pub enum LoadedMacro {"}, {"sha": "64230fd9e608d5194d6519a51c32eee332d7b277", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 114, "deletions": 72, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -212,9 +212,8 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n-use crate::rmeta::{METADATA_HEADER, rustc_version};\n+use crate::rmeta::{METADATA_HEADER, rustc_version, MetadataBlob};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n@@ -249,37 +248,47 @@ use log::{debug, info, warn};\n use rustc_error_codes::*;\n \n #[derive(Clone)]\n-crate struct CrateMismatch {\n+struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n #[derive(Clone)]\n-crate struct Context<'a> {\n-    pub sess: &'a Session,\n-    pub span: Span,\n-    pub crate_name: Symbol,\n+crate struct CrateLocator<'a> {\n+    // Immutable per-session configuration.\n+    sess: &'a Session,\n+    metadata_loader: &'a dyn MetadataLoader,\n+\n+    // Immutable per-search configuration.\n+    crate_name: Symbol,\n+    exact_paths: Vec<PathBuf>,\n     pub hash: Option<&'a Svh>,\n     pub host_hash: Option<&'a Svh>,\n-    pub extra_filename: Option<&'a str>,\n-    // points to either self.sess.target.target or self.sess.host, must match triple\n+    extra_filename: Option<&'a str>,\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    pub root: Option<&'a CratePaths>,\n-    pub rejected_via_hash: Vec<CrateMismatch>,\n-    pub rejected_via_triple: Vec<CrateMismatch>,\n-    pub rejected_via_kind: Vec<CrateMismatch>,\n-    pub rejected_via_version: Vec<CrateMismatch>,\n-    pub rejected_via_filename: Vec<CrateMismatch>,\n-    pub should_match_name: bool,\n+    span: Span,\n+    root: Option<&'a CratePaths>,\n     pub is_proc_macro: Option<bool>,\n-    pub metadata_loader: &'a dyn MetadataLoader,\n+\n+    // Mutable in-progress state or output.\n+    rejected_via_hash: Vec<CrateMismatch>,\n+    rejected_via_triple: Vec<CrateMismatch>,\n+    rejected_via_kind: Vec<CrateMismatch>,\n+    rejected_via_version: Vec<CrateMismatch>,\n+    rejected_via_filename: Vec<CrateMismatch>,\n }\n \n crate struct CratePaths {\n-    pub name: Symbol,\n-    pub source: CrateSource,\n+    name: Symbol,\n+    source: CrateSource,\n+}\n+\n+impl CratePaths {\n+    crate fn new(name: Symbol, source: CrateSource) -> CratePaths {\n+        CratePaths { name, source }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -299,7 +308,58 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n-impl<'a> Context<'a> {\n+impl<'a> CrateLocator<'a> {\n+    crate fn new(\n+        sess: &'a Session,\n+        metadata_loader: &'a dyn MetadataLoader,\n+        crate_name: Symbol,\n+        hash: Option<&'a Svh>,\n+        host_hash: Option<&'a Svh>,\n+        extra_filename: Option<&'a str>,\n+        is_host: bool,\n+        path_kind: PathKind,\n+        span: Span,\n+        root: Option<&'a CratePaths>,\n+        is_proc_macro: Option<bool>,\n+    ) -> CrateLocator<'a> {\n+        CrateLocator {\n+            sess,\n+            metadata_loader,\n+            crate_name,\n+            exact_paths: if hash.is_none() {\n+                sess.opts.externs.get(&crate_name.as_str()).into_iter()\n+                    .flat_map(|entry| entry.locations.iter())\n+                    .filter_map(|location| location.clone().map(PathBuf::from)).collect()\n+            } else {\n+                // SVH being specified means this is a transitive dependency,\n+                // so `--extern` options do not apply.\n+                Vec::new()\n+            },\n+            hash,\n+            host_hash,\n+            extra_filename,\n+            target: if is_host { &sess.host } else { &sess.target.target },\n+            triple: if is_host {\n+                TargetTriple::from_triple(config::host_triple())\n+            } else {\n+                sess.opts.target_triple.clone()\n+            },\n+            filesearch: if is_host {\n+                sess.host_filesearch(path_kind)\n+            } else {\n+                sess.target_filesearch(path_kind)\n+            },\n+            span,\n+            root,\n+            is_proc_macro,\n+            rejected_via_hash: Vec::new(),\n+            rejected_via_triple: Vec::new(),\n+            rejected_via_kind: Vec::new(),\n+            rejected_via_version: Vec::new(),\n+            rejected_via_filename: Vec::new(),\n+        }\n+    }\n+\n     crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n         self.rejected_via_triple.clear();\n@@ -309,6 +369,9 @@ impl<'a> Context<'a> {\n     }\n \n     crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+        if !self.exact_paths.is_empty() {\n+            return self.find_commandline_library();\n+        }\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -434,21 +497,6 @@ impl<'a> Context<'a> {\n                           extra_prefix: &str,\n                           seen_paths: &mut FxHashSet<PathBuf>)\n                           -> Option<Library> {\n-        // If an SVH is specified, then this is a transitive dependency that\n-        // must be loaded via -L plus some filtering.\n-        if self.hash.is_none() {\n-            self.should_match_name = false;\n-            if let Some(entry) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n-                // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                if entry.locations.iter().any(|l| l.is_some()) {\n-                    return self.find_commandline_library(\n-                        entry.locations.iter().filter_map(|l| l.as_ref()),\n-                    );\n-                }\n-            }\n-            self.should_match_name = true;\n-        }\n-\n         let dypair = self.dylibname();\n         let staticpair = self.staticlibname();\n \n@@ -716,15 +764,16 @@ impl<'a> Context<'a> {\n         }\n \n         let root = metadata.get_root();\n-        if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_data.is_some() != is_proc_macro {\n+        if let Some(expected_is_proc_macro) = self.is_proc_macro {\n+            let is_proc_macro = root.is_proc_macro_crate();\n+            if is_proc_macro != expected_is_proc_macro {\n                 info!(\"Rejecting via proc macro: expected {} got {}\",\n-                      is_proc_macro, root.proc_macro_data.is_some());\n+                      expected_is_proc_macro, is_proc_macro);\n                 return None;\n             }\n         }\n \n-        if self.should_match_name {\n+        if self.exact_paths.is_empty() {\n             if self.crate_name != root.name {\n                 info!(\"Rejecting via crate name\");\n                 return None;\n@@ -771,9 +820,7 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library<'b, LOCS>(&mut self, locs: LOCS) -> Option<Library>\n-        where LOCS: Iterator<Item = &'b String>\n-    {\n+    fn find_commandline_library(&mut self) -> Option<Library> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n@@ -783,18 +830,20 @@ impl<'a> Context<'a> {\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n         {\n-            let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n+                let crate_name = self.crate_name;\n+                let rejected_via_filename = &mut self.rejected_via_filename;\n+                let locs = self.exact_paths.iter().filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                      self.crate_name,\n+                                      crate_name,\n                                       loc.display()));\n                     return false;\n                 }\n                 let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                          self.crate_name,\n+                                          crate_name,\n                                           loc.display()));\n                         return false;\n                     }\n@@ -809,8 +858,8 @@ impl<'a> Context<'a> {\n                     }\n                 }\n \n-                self.rejected_via_filename.push(CrateMismatch {\n-                    path: loc.clone(),\n+                rejected_via_filename.push(CrateMismatch {\n+                    path: (*loc).clone(),\n                     got: String::new(),\n                 });\n \n@@ -907,7 +956,7 @@ fn get_metadata_section_imp(target: &Target,\n             rustc_erase_owner!(OwningRef::new(StableDerefMmap(mmap)).map_owner_box())\n         }\n     };\n-    let blob = MetadataBlob(raw_bytes);\n+    let blob = MetadataBlob::new(raw_bytes);\n     if blob.is_compatible() {\n         Ok(blob)\n     } else {\n@@ -927,44 +976,37 @@ pub fn find_plugin_registrar(\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let is_cross = target_triple != host_triple;\n     let mut target_only = false;\n-    let mut locate_ctxt = Context {\n+    let mut locator = CrateLocator::new(\n         sess,\n-        span,\n-        crate_name: name,\n-        hash: None,\n-        host_hash: None,\n-        extra_filename: None,\n-        filesearch: sess.host_filesearch(PathKind::Crate),\n-        target: &sess.host,\n-        triple: host_triple,\n-        root: None,\n-        rejected_via_hash: vec![],\n-        rejected_via_triple: vec![],\n-        rejected_via_kind: vec![],\n-        rejected_via_version: vec![],\n-        rejected_via_filename: vec![],\n-        should_match_name: true,\n-        is_proc_macro: None,\n         metadata_loader,\n-    };\n+        name,\n+        None, // hash\n+        None, // host_hash\n+        None, // extra_filename\n+        true, // is_host\n+        PathKind::Crate,\n+        span,\n+        None, // root\n+        None, // is_proc_macro\n+    );\n \n-    let library = locate_ctxt.maybe_load_library_crate().or_else(|| {\n+    let library = locator.maybe_load_library_crate().or_else(|| {\n         if !is_cross {\n             return None\n         }\n         // Try loading from target crates. This will abort later if we\n         // try to load a plugin registrar function,\n         target_only = true;\n \n-        locate_ctxt.target = &sess.target.target;\n-        locate_ctxt.triple = target_triple;\n-        locate_ctxt.filesearch = sess.target_filesearch(PathKind::Crate);\n+        locator.target = &sess.target.target;\n+        locator.triple = target_triple;\n+        locator.filesearch = sess.target_filesearch(PathKind::Crate);\n \n-        locate_ctxt.maybe_load_library_crate()\n+        locator.maybe_load_library_crate()\n     });\n     let library = match library {\n         Some(l) => l,\n-        None => locate_ctxt.report_errs(),\n+        None => locator.report_errs(),\n     };\n \n     if target_only {"}, {"sha": "7b0cf451ff918227d3ed5afcff12badd86907028", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 157, "deletions": 23, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -1,27 +1,30 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::rmeta::*;\n use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir;\n+use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc::dep_graph::{DepNodeIndex, DepKind};\n+use rustc_data_structures::svh::Svh;\n+use rustc::dep_graph::{self, DepNodeIndex};\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n-use rustc::mir::interpret::AllocDecodingSession;\n+use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::{Body, Promoted};\n+use rustc::util::common::record_time;\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -44,7 +47,86 @@ pub use cstore_impl::{provide, provide_extern};\n \n mod cstore_impl;\n \n-crate struct DecodeContext<'a, 'tcx> {\n+crate struct MetadataBlob(MetadataRef);\n+\n+// A map from external crate numbers (as decoded from some crate file) to\n+// local crate numbers (as generated during this session). Each external\n+// crate may refer to types in other external crates, and each has their\n+// own crate numbers.\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+\n+crate struct CrateMetadata {\n+    /// The primary crate data - binary metadata blob.\n+    blob: MetadataBlob,\n+\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n+\n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n+    crate root: CrateRoot<'static>,\n+    /// For each definition in this crate, we encode a key. When the\n+    /// crate is loaded, we read all the keys and put them in this\n+    /// hashmap, which gives the reverse mapping. This allows us to\n+    /// quickly retrace a `DefPath`, which is needed for incremental\n+    /// compilation support.\n+    def_path_table: DefPathTable,\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n+    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    source_map_import_info: Once<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n+\n+    /// ID of this crate, from the current compilation session's point of view.\n+    cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n+    crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n+    crate source: CrateSource,\n+    /// Whether or not this crate should be consider a private dependency\n+    /// for purposes of the 'exported_private_dependencies' lint\n+    private_dep: bool,\n+    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n+    host_hash: Option<Svh>,\n+\n+    // --- Data used only for improving diagnostics ---\n+\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n+}\n+\n+/// Holds information about a syntax_pos::SourceFile imported from another crate.\n+/// See `imported_source_files()` for more information.\n+struct ImportedSourceFile {\n+    /// This SourceFile's byte-offset within the source_map of its original crate\n+    original_start_pos: syntax_pos::BytePos,\n+    /// The end of this SourceFile within the source_map of its original crate\n+    original_end_pos: syntax_pos::BytePos,\n+    /// The imported SourceFile's representation within the local source_map\n+    translated_source_file: Lrc<syntax_pos::SourceFile>,\n+}\n+\n+pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'tcx Session>,\n@@ -60,7 +142,7 @@ crate struct DecodeContext<'a, 'tcx> {\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n-crate trait Metadata<'a, 'tcx>: Copy {\n+pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'tcx Session> { None }\n@@ -136,15 +218,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n }\n \n impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n+    fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(\n+    fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n@@ -393,7 +475,11 @@ for DecodeContext<'a, 'tcx> {\n \n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n-impl<'tcx> MetadataBlob {\n+impl MetadataBlob {\n+    crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n+        MetadataBlob(metadata_ref)\n+    }\n+\n     crate fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n@@ -467,14 +553,62 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n+impl CrateRoot<'_> {\n+    crate fn is_proc_macro_crate(&self) -> bool {\n+        self.proc_macro_data.is_some()\n+    }\n+\n+    crate fn decode_crate_deps(\n+        &self,\n+        metadata: &'a MetadataBlob,\n+    ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {\n+        self.crate_deps.decode(metadata)\n+    }\n+}\n+\n impl<'a, 'tcx> CrateMetadata {\n-    fn is_proc_macro_crate(&self) -> bool {\n-        self.root.proc_macro_decls_static.is_some()\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root.impls.decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls)).collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n+        }\n     }\n \n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.is_proc_macro_crate() &&\n-            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n+        self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind<'tcx>> {\n@@ -757,7 +891,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -773,7 +907,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n-        tcx.arena.alloc(if self.is_proc_macro_crate() {\n+        tcx.arena.alloc(if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n         } else {\n@@ -1081,7 +1215,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1125,7 +1259,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1134,7 +1268,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1157,7 +1291,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1181,7 +1315,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1296,7 +1430,7 @@ impl<'a, 'tcx> CrateMetadata {\n     fn imported_source_files(\n         &'a self,\n         local_source_map: &source_map::SourceMap,\n-    ) -> &[cstore::ImportedSourceFile] {\n+    ) -> &[ImportedSourceFile] {\n         self.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n@@ -1351,7 +1485,7 @@ impl<'a, 'tcx> CrateMetadata {\n                        local_version.name, start_pos, end_pos,\n                        local_version.start_pos, local_version.end_pos);\n \n-                cstore::ImportedSourceFile {\n+                ImportedSourceFile {\n                     original_start_pos: start_pos,\n                     original_end_pos: end_pos,\n                     translated_source_file: local_version,\n@@ -1374,7 +1508,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // would always write the same value.\n \n             let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::CrateMetadata);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n \n             dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n             assert!(dep_node_index != DepNodeIndex::INVALID);"}, {"sha": "abb0ceb4ff4277f8083bafc1bd31fa5ad2da750c", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -52,7 +52,7 @@ macro_rules! provide {\n                 assert!(!$def_id.is_local());\n \n                 let $cdata = $tcx.crate_data_as_any($def_id.krate);\n-                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                let $cdata = $cdata.downcast_ref::<rmeta::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n                 if $tcx.dep_graph.is_fully_enabled() {\n@@ -410,7 +410,7 @@ impl cstore::CStore {\n         let _prof_timer = sess.prof.generic_activity(\"metadata_load_macro\");\n \n         let data = self.get_crate_data(id.krate);\n-        if data.is_proc_macro_crate() {\n+        if data.root.is_proc_macro_crate() {\n             return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n "}, {"sha": "23c0204ee256bd138d5bc58f4e63907f674afae0", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=5a84f9b86ec3e2b5b6393faebeeaa96dc6c21192", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::MetadataRef;\n use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n@@ -24,6 +25,7 @@ use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n pub use decoder::{provide, provide_extern};\n+crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n \n mod decoder;\n mod encoder;\n@@ -49,7 +51,7 @@ crate const METADATA_HEADER: &[u8; 8] =\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-crate trait LazyMeta {\n+trait LazyMeta {\n     type Meta: Copy + 'static;\n \n     /// Returns the minimum encoded size.\n@@ -103,7 +105,7 @@ impl<T: Encodable> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n@@ -186,7 +188,7 @@ crate struct CrateRoot<'tcx> {\n     proc_macro_decls_static: Option<DefIndex>,\n     proc_macro_stability: Option<attr::Stability>,\n \n-    pub crate_deps: Lazy<[CrateDep]>,\n+    crate_deps: Lazy<[CrateDep]>,\n     dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n     lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n     lang_items: Lazy<[(DefIndex, usize)]>,\n@@ -195,16 +197,15 @@ crate struct CrateRoot<'tcx> {\n     native_libraries: Lazy<[NativeLibrary]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n     source_map: Lazy<[syntax_pos::SourceFile]>,\n-    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: Lazy<[TraitImpls]>,\n+    def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n+    impls: Lazy<[TraitImpls]>,\n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n-    pub interpret_alloc_index: Lazy<[u32]>,\n+    interpret_alloc_index: Lazy<[u32]>,\n \n     per_def: LazyPerDefTables<'tcx>,\n \n-    /// The DefIndex's of any proc macros delcared by\n-    /// this crate\n-    pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n+    /// The DefIndex's of any proc macros delcared by this crate.\n+    proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -227,8 +228,8 @@ crate struct CrateDep {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct TraitImpls {\n-    pub trait_id: (u32, DefIndex),\n-    pub impls: Lazy<[DefIndex]>,\n+    trait_id: (u32, DefIndex),\n+    impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}]}