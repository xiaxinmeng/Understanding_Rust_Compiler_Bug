{"sha": "bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhY2I1YzU4ZGZkZGU3YzM1ZTk5YjJiMGQ4MTcxMjM4Y2MzM2NmNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-26T17:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-26T17:41:36Z"}, "message": "Auto merge of #47748 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 19 pull requests\n\n- Successful merges: #47415, #47437, #47439, #47453, #47460, #47502, #47529, #47600, #47607, #47618, #47626, #47656, #47668, #47696, #47701, #47705, #47710, #47711, #47719\n- Failed merges: #47455, #47521", "tree": {"sha": "a4a44364f143350bb7262ca8e63612e2ee71f6ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4a44364f143350bb7262ca8e63612e2ee71f6ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "html_url": "https://github.com/rust-lang/rust/commit/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "html_url": "https://github.com/rust-lang/rust/commit/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82"}, {"sha": "a06d333a148f6c620044a765f47497f1ed1e4dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/a06d333a148f6c620044a765f47497f1ed1e4dde", "html_url": "https://github.com/rust-lang/rust/commit/a06d333a148f6c620044a765f47497f1ed1e4dde"}], "stats": {"total": 6082, "additions": 3681, "deletions": 2401}, "files": [{"sha": "55d104b182698d3901e6c3433301cdc48e8094b3", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -125,11 +125,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        // Pass down incremental directory, if any.\n-        if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n-            cmd.arg(format!(\"-Zincremental={}\", dir));\n-        }\n-\n         let crate_name = args.windows(2)\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();"}, {"sha": "ecf9c0a75903e514f0f06b5f322c8c4e7100759c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -602,6 +602,7 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n+        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2\"\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):"}, {"sha": "79058984b13523a0dd4795aaa9ca00f6daabd9f4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -26,6 +26,7 @@ use util::{exe, libdir, add_lib_path};\n use {Build, Mode};\n use cache::{INTERNER, Interned, Cache};\n use check;\n+use test;\n use flags::Subcommand;\n use doc;\n use tool;\n@@ -230,6 +231,7 @@ impl<'a> ShouldRun<'a> {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Kind {\n     Build,\n+    Check,\n     Test,\n     Bench,\n     Dist,\n@@ -251,13 +253,13 @@ impl<'a> Builder<'a> {\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n-            Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n-                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Rustdoc,\n-                check::Linkcheck, check::Cargotest, check::Cargo, check::Rls, check::Docs,\n-                check::ErrorIndex, check::Distcheck, check::Rustfmt, check::Miri, check::Clippy,\n-                check::RustdocJS),\n-\n-            Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n+            Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n+                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n+                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n+                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n+                test::RustdocJS),\n+            Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n                 doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n@@ -304,6 +306,7 @@ impl<'a> Builder<'a> {\n     pub fn run(build: &Build) {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -493,13 +496,14 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n         }\n \n+\n         if let Some(host_linker) = self.build.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n         if let Some(target_linker) = self.build.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if cmd != \"build\" {\n+        if cmd != \"build\" && cmd != \"check\" {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n         }\n \n@@ -566,8 +570,7 @@ impl<'a> Builder<'a> {\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n         if self.config.incremental && compiler.stage == 0 {\n-            let incr_dir = self.incremental_dir(compiler);\n-            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n+            cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         }\n \n         if let Some(ref on_fail) = self.config.on_fail {"}, {"sha": "0bc82c4f9f2c2571235083bca558478f6eeaf536", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 80, "deletions": 1459, "changes": 1539, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,1535 +8,156 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementation of the test-related targets of the build system.\n-//!\n-//! This file implements the various regression test suites that we execute on\n-//! our CI.\n+//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n \n-use std::collections::HashSet;\n-use std::env;\n-use std::ffi::OsString;\n-use std::iter;\n-use std::fmt;\n-use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n-use std::io::Read;\n-\n-use build_helper::{self, output};\n-\n-use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n-use cache::{INTERNER, Interned};\n-use compile;\n-use dist;\n-use native;\n-use tool::{self, Tool};\n-use util::{self, dylib_path, dylib_path_var};\n-use {Build, Mode};\n-use toolstate::ToolState;\n-\n-const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n-\n-/// The two modes of the test runner; tests or benchmarks.\n-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n-pub enum TestKind {\n-    /// Run `cargo test`\n-    Test,\n-    /// Run `cargo bench`\n-    Bench,\n-}\n-\n-impl TestKind {\n-    // Return the cargo subcommand for this test kind\n-    fn subcommand(self) -> &'static str {\n-        match self {\n-            TestKind::Test => \"test\",\n-            TestKind::Bench => \"bench\",\n-        }\n-    }\n-}\n-\n-impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            TestKind::Test => \"Testing\",\n-            TestKind::Bench => \"Benchmarking\",\n-        })\n-    }\n-}\n-\n-fn try_run(build: &Build, cmd: &mut Command) -> bool {\n-    if !build.fail_fast {\n-        if !build.try_run(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-            return false;\n-        }\n-    } else {\n-        build.run(cmd);\n-    }\n-    true\n-}\n-\n-fn try_run_quiet(build: &Build, cmd: &mut Command) {\n-    if !build.fail_fast {\n-        if !build.try_run_quiet(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-        }\n-    } else {\n-        build.run_quiet(cmd);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Linkcheck {\n-    host: Interned<String>,\n-}\n-\n-impl Step for Linkcheck {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will verify the validity of all our links in the\n-    /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        println!(\"Linkcheck ({})\", host);\n-\n-        builder.default_doc(None);\n-\n-        let _time = util::timeit();\n-        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n-                            .arg(build.out.join(host).join(\"doc\")));\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Linkcheck { host: run.target });\n-    }\n-}\n+use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, add_to_sysroot};\n+use builder::{RunConfig, Builder, ShouldRun, Step};\n+use {Build, Compiler, Mode};\n+use cache::Interned;\n+use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargotest {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargotest {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargotest\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargotest {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n-    /// test` to ensure that we don't regress the test suites there.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n-\n-        // Note that this is a short, cryptic, and not scoped directory name. This\n-        // is currently to minimize the length of path on Windows where we otherwise\n-        // quickly run into path name limit constraints.\n-        let out_dir = build.out.join(\"ct\");\n-        t!(fs::create_dir_all(&out_dir));\n-\n-        let _time = util::timeit();\n-        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(build, cmd.arg(&build.initial_cargo)\n-                          .arg(&out_dir)\n-                          .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargo {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargo {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargo\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for `cargo` packaged with Rust.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-\n-        builder.ensure(tool::Cargo { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-        if !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n-        // available.\n-        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n-\n-        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rls {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rls\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for the rls.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rls\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rls\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustfmt {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rustfmt\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for rustfmt.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rustfmt\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Miri {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let test_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(test_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for miri.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // miri tests need to know about the stage sysroot\n-            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n-\n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"miri\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test miri: could not build\");\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Clippy {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Clippy {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = false;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/clippy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for clippy.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n-\n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n-\n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n-    }\n-}\n-\n-fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n-    // Configure PATH to find the right rustc. NB. we have to use PATH\n-    // and not RUSTC because the Cargo test suite has tests that will\n-    // fail if rustc is not spelled `rustc`.\n-    let path = builder.sysroot(compiler).join(\"bin\");\n-    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct RustdocJS {\n-    pub host: Interned<String>,\n+pub struct Std {\n     pub target: Interned<String>,\n }\n \n-impl Step for RustdocJS {\n+impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/test/rustdoc-js\")\n+        run.path(\"src/libstd\").krate(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(RustdocJS {\n-            host: run.host,\n+        run.builder.ensure(Std {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n-        if let Some(ref nodejs) = builder.config.nodejs {\n-            let mut command = Command::new(nodejs);\n-            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n-            builder.ensure(::doc::Std {\n-                target: self.target,\n-                stage: builder.top_stage,\n-            });\n-            builder.run(&mut command);\n-        } else {\n-            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Tidy {\n-    host: Interned<String>,\n-}\n-\n-impl Step for Tidy {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` checks up on various bits and pieces of style and\n-    /// otherwise just implements a few lint-like checks that are specific to the\n-    /// compiler itself.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check ({})\", host);\n-        let mut cmd = builder.tool_cmd(Tool::Tidy);\n-        cmd.arg(build.src.join(\"src\"));\n-        if !build.config.vendor {\n-            cmd.arg(\"--no-vendor\");\n-        }\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-        try_run(build, &mut cmd);\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/tidy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Tidy {\n-            host: run.builder.build.build,\n-        });\n-    }\n-}\n-\n-fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n-    build.out.join(host).join(\"test\")\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test {\n-        path: \"src/test/incremental-fulldeps\",\n-        mode: \"incremental\",\n-        suite: \"incremental-fulldeps\",\n-    },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Compiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for Compiletest {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n-    }\n-\n-    /// Executes the `compiletest` tool to run a suite of tests.\n-    ///\n-    /// Compiles all tests with `compiler` for `target` with the specified\n-    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n-    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = self.compiler;\n         let target = self.target;\n-        let mode = self.mode;\n-        let suite = self.suite;\n-\n-        // Skip codegen tests if they aren't enabled in configuration.\n-        if !build.config.codegen_tests && suite == \"codegen\" {\n-            return;\n-        }\n-\n-        if suite == \"debuginfo\" {\n-            // Skip debuginfo tests on MSVC\n-            if build.build.contains(\"msvc\") {\n-                return;\n-            }\n-\n-            if mode == \"debuginfo-XXX\" {\n-                return if build.build.contains(\"apple\") {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-lldb\",\n-                        ..self\n-                    });\n-                } else {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-gdb\",\n-                        ..self\n-                    });\n-                };\n-            }\n-\n-            builder.ensure(dist::DebuggerScripts {\n-                sysroot: builder.sysroot(compiler),\n-                host: target\n-            });\n-        }\n-\n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\" ||\n-            mode == \"rustdoc\" ||\n-            mode == \"run-make\" {\n-            builder.ensure(compile::Rustc { compiler, target });\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(native::TestHelpers { target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n-        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n-\n-        // compiletest currently has... a lot of arguments, so let's just pass all\n-        // of them!\n-\n-        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n-        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n-\n-        // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" || mode == \"run-make\" {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n-        }\n-\n-        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n-        cmd.arg(\"--mode\").arg(mode);\n-        cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n-\n-        if let Some(ref nodejs) = build.config.nodejs {\n-            cmd.arg(\"--nodejs\").arg(nodejs);\n-        }\n-\n-        let mut flags = vec![\"-Crpath\".to_string()];\n-        if build.config.rust_optimize_tests {\n-            flags.push(\"-O\".to_string());\n-        }\n-        if build.config.rust_debuginfo_tests {\n-            flags.push(\"-g\".to_string());\n-        }\n-        flags.push(\"-Zmiri -Zunstable-options\".to_string());\n-        flags.push(build.config.cmd.rustc_args().join(\" \"));\n-\n-        if let Some(linker) = build.linker(target) {\n-            cmd.arg(\"--linker\").arg(linker);\n-        }\n-\n-        let hostflags = flags.clone();\n-        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n-\n-        let mut targetflags = flags.clone();\n-        targetflags.push(format!(\"-Lnative={}\",\n-                                 build.test_helpers_out(target).display()));\n-        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n-\n-        cmd.arg(\"--docck-python\").arg(build.python());\n-\n-        if build.build.ends_with(\"apple-darwin\") {\n-            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n-            // LLDB plugin's compiled module which only works with the system python\n-            // (namely not Homebrew-installed python)\n-            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n-        } else {\n-            cmd.arg(\"--lldb-python\").arg(build.python());\n-        }\n-\n-        if let Some(ref gdb) = build.config.gdb {\n-            cmd.arg(\"--gdb\").arg(gdb);\n-        }\n-        if let Some(ref vers) = build.lldb_version {\n-            cmd.arg(\"--lldb-version\").arg(vers);\n-        }\n-        if let Some(ref dir) = build.lldb_python_dir {\n-            cmd.arg(\"--lldb-python-dir\").arg(dir);\n-        }\n-\n-        cmd.args(&build.config.cmd.test_args());\n-\n-        if build.is_verbose() {\n-            cmd.arg(\"--verbose\");\n-        }\n-\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-\n-        if build.config.llvm_enabled {\n-            let llvm_config = build.llvm_config(target);\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n-            if !build.is_rust_llvm(target) {\n-                cmd.arg(\"--system-llvm\");\n-            }\n-\n-            // Only pass correct values for these flags for the `run-make` suite as it\n-            // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make\" {\n-                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(build.cc(target))\n-                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n-                .arg(\"--llvm-components\").arg(llvm_components.trim())\n-                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-                if let Some(ar) = build.ar(target) {\n-                    cmd.arg(\"--ar\").arg(ar);\n-                }\n-            }\n-        }\n-        if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n-            return;\n-        }\n+        let compiler = builder.compiler(0, build.build);\n \n-        if suite != \"run-make\" {\n-            cmd.arg(\"--cc\").arg(\"\")\n-               .arg(\"--cxx\").arg(\"\")\n-               .arg(\"--cflags\").arg(\"\")\n-               .arg(\"--llvm-components\").arg(\"\")\n-               .arg(\"--llvm-cxxflags\").arg(\"\");\n-        }\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n \n-        if build.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n-        }\n-\n-        // Running a C compiler on MSVC requires a few env vars to be set, to be\n-        // sure to set them here.\n-        //\n-        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n-        // rather than stomp over it.\n-        if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].env() {\n-                if k != \"PATH\" {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        build.add_rust_test_threads(&mut cmd);\n-\n-        if build.config.sanitizers {\n-            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n-        }\n-\n-        if build.config.profiler {\n-            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n-        }\n-\n-        cmd.arg(\"--adb-path\").arg(\"adb\");\n-        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n-        if target.contains(\"android\") {\n-            // Assume that cc for this target comes from the android sysroot\n-            cmd.arg(\"--android-cross-path\")\n-               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n-        } else {\n-            cmd.arg(\"--android-cross-path\").arg(\"\");\n-        }\n-\n-        build.ci_env.force_coloring_in_ci(&mut cmd);\n-\n-        let _time = util::timeit();\n-        try_run(build, &mut cmd);\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n+        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n+        std_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libstd_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Docs {\n-    compiler: Compiler,\n+pub struct Rustc {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Docs {\n+impl Step for Rustc {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/doc\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Docs {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n-    }\n-\n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n-    ///\n-    /// This will run all tests in our markdown documentation (e.g. the book)\n-    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n-    /// `compiler`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n-\n-        // Do a breadth-first traversal of the `src/doc` directory and just run\n-        // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(\"src/doc\")];\n-        let _time = util::timeit();\n-        let _folder = build.fold_output(|| \"test_docs\");\n-\n-        while let Some(p) = stack.pop() {\n-            if p.is_dir() {\n-                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-                continue\n-            }\n-\n-            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n-                continue;\n-            }\n-\n-            // The nostarch directory in the book is for no starch, and so isn't\n-            // guaranteed to build. We don't care if it doesn't build, so skip it.\n-            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n-                continue;\n-            }\n-\n-            markdown_test(builder, compiler, &p);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct ErrorIndex {\n-    compiler: Compiler,\n-}\n-\n-impl Step for ErrorIndex {\n-    type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/error_index_generator\")\n+        run.path(\"src/librustc\").krate(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(ErrorIndex {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n-    }\n-\n-    /// Run the error index generator tool to execute the tests located in the error\n-    /// index.\n-    ///\n-    /// The `error_index_generator` tool lives in `src/tools` and is used to\n-    /// generate a markdown file from the error indexes of the code base which is\n-    /// then passed to `rustdoc --test`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n-\n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n-        let dir = testdir(build, compiler.host);\n-        t!(fs::create_dir_all(&dir));\n-        let output = dir.join(\"error-index.md\");\n-\n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n-\n-        markdown_test(builder, compiler, &output);\n-    }\n-}\n-\n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n-    let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return;\n-    }\n-\n-    println!(\"doc tests for: {}\", markdown.display());\n-    let mut cmd = builder.rustdoc_cmd(compiler.host);\n-    build.add_rust_test_threads(&mut cmd);\n-    cmd.arg(\"--test\");\n-    cmd.arg(markdown);\n-    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-\n-    let test_args = build.config.cmd.test_args().join(\" \");\n-    cmd.arg(\"--test-args\").arg(test_args);\n-\n-    if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd);\n-    } else {\n-        try_run(build, &mut cmd);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct CrateLibrustc {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n-}\n-\n-impl Step for CrateLibrustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"rustc-main\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n-            }\n-        } else {\n-            make(None);\n-        }\n-    }\n-\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Crate {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: Mode::Librustc,\n-            test_kind: self.test_kind,\n-            krate: self.krate,\n+        run.builder.ensure(Rustc {\n+            target: run.target,\n         });\n     }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Crate {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n-}\n-\n-impl Step for Crate {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n-    }\n \n-    fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(Crate {\n-                compiler,\n-                target: run.target,\n-                mode,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n-            }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n-            }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n-        }\n-    }\n-\n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n-    ///\n-    /// This is what runs tests for crates like the standard library, compiler, etc.\n-    /// It essentially is the driver for running `cargo test`.\n+    /// Build the compiler.\n     ///\n-    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n-    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    /// This will build the compiler for a particular stage of the build using\n+    /// the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = self.compiler;\n+        let compiler = builder.compiler(0, build.build);\n         let target = self.target;\n-        let mode = self.mode;\n-        let test_kind = self.test_kind;\n-        let krate = self.krate;\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n-        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n-            Mode::Libstd => {\n-                compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n-            }\n-            Mode::Libtest => {\n-                compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n-            }\n-            Mode::Librustc => {\n-                builder.ensure(compile::Rustc { compiler, target });\n-                compile::rustc_cargo(build, target, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n-            }\n-            _ => panic!(\"can only test libraries\"),\n-        };\n-        let root = INTERNER.intern_string(String::from(root));\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n-                &compiler.host, target);\n-\n-        // Build up the base `cargo test` command.\n-        //\n-        // Pass in some standard flags then iterate over the graph we've discovered\n-        // in `cargo metadata` with the maps above and figure out what `-p`\n-        // arguments need to get passed.\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The tests are going to run with the *target* libraries, so we need to\n-        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n-        //\n-        // Note that to run the compiler we need to run with the *host* libraries,\n-        // but our wrapper scripts arrange for that to be the case anyway.\n-        let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n-        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n \n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n-        let _time = util::timeit();\n-\n-        if target.contains(\"emscripten\") {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n-        } else if target.starts_with(\"wasm32\") {\n-            // On the wasm32-unknown-unknown target we're using LTO which is\n-            // incompatible with `-C prefer-dynamic`, so disable that here\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-            let node = build.config.nodejs.as_ref()\n-                .expect(\"nodejs not configured\");\n-            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n-                                 node.display(),\n-                                 build.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n-        } else if build.remote_tested(target) {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      format!(\"{} run\",\n-                              builder.tool_exe(Tool::RemoteTestClient).display()));\n-        }\n-        try_run(build, &mut cargo);\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        rustc_cargo(build, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &librustc_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n-    host: Interned<String>,\n-    test_kind: TestKind,\n+pub struct Test {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Rustdoc {\n+impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.path(\"src/libtest\").krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-\n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n-\n-        builder.ensure(Rustdoc {\n-            host: run.host,\n-            test_kind,\n+        run.builder.ensure(Test {\n+            target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let test_kind = self.test_kind;\n-\n-        let compiler = builder.compiler(builder.top_stage, self.host);\n-        let target = compiler.host;\n-\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 target,\n-                                                 test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n-\n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n-        let _time = util::timeit();\n+        let target = self.target;\n+        let compiler = builder.compiler(0, build.build);\n \n-        try_run(build, &mut cargo);\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n+        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n+        test_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libtest_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n \n-fn envify(s: &str) -> String {\n-    s.chars().map(|c| {\n-        match c {\n-            '-' => '_',\n-            c => c,\n-        }\n-    }).flat_map(|c| c.to_uppercase()).collect()\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n }\n \n-/// Some test suites are run inside emulators or on remote devices, and most\n-/// of our test binaries are linked dynamically which means we need to ship\n-/// the standard library and such to the emulator ahead of time. This step\n-/// represents this and is a dependency of all test suites.\n-///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n-/// QEMU we have to build our own tools so we've got conditional dependencies\n-/// on those programs as well. Note that the remote test client is built for\n-/// the build target (us) and the server is built for the target.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct RemoteCopyLibs {\n-    compiler: Compiler,\n-    target: Interned<String>,\n+/// Cargo's output path for libtest in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n }\n \n-impl Step for RemoteCopyLibs {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-        let target = self.target;\n-        if !build.remote_tested(target) {\n-            return\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-\n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n-\n-        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n-\n-        // Spawn the emulator and wait for it to come online\n-        let tool = builder.tool_exe(Tool::RemoteTestClient);\n-        let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\")\n-           .arg(target)\n-           .arg(&server)\n-           .arg(build.out.join(\"tmp\"));\n-        if let Some(rootfs) = build.qemu_rootfs(target) {\n-            cmd.arg(rootfs);\n-        }\n-        build.run(&mut cmd);\n-\n-        // Push all our dylibs to the emulator\n-        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n-            let f = t!(f);\n-            let name = f.file_name().into_string().unwrap();\n-            if util::is_dylib(&name) {\n-                build.run(Command::new(&tool)\n-                                  .arg(\"push\")\n-                                  .arg(f.path()));\n-            }\n-        }\n-    }\n+/// Cargo's output path for librustc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Distcheck;\n-\n-impl Step for Distcheck {\n-    type Output = ();\n-    const ONLY_BUILD: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"distcheck\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Distcheck);\n-    }\n-\n-    /// Run \"distcheck\", a 'make check' from a tarball\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n-        println!(\"Distcheck\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        // Guarantee that these are built before we begin running.\n-        builder.ensure(dist::PlainSourceTarball);\n-        builder.ensure(dist::Src);\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::PlainSourceTarball))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-        build.run(Command::new(\"./configure\")\n-                         .args(&build.config.configure_args)\n-                         .arg(\"--enable-vendor\")\n-                         .current_dir(&dir));\n-        build.run(Command::new(build_helper::make(&build.build))\n-                         .arg(\"check\")\n-                         .current_dir(&dir));\n-\n-        // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::Src))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-\n-        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        build.run(Command::new(&build.initial_cargo)\n-                         .arg(\"generate-lockfile\")\n-                         .arg(\"--manifest-path\")\n-                         .arg(&toml)\n-                         .current_dir(&dir));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Bootstrap;\n-\n-impl Step for Bootstrap {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Test the build system itself\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let mut cmd = Command::new(&build.initial_cargo);\n-        cmd.arg(\"test\")\n-           .current_dir(build.src.join(\"src/bootstrap\"))\n-           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &build.initial_rustc);\n-        if !build.fail_fast {\n-            cmd.arg(\"--no-fail-fast\");\n-        }\n-        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n-        try_run(build, &mut cmd);\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/bootstrap\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Bootstrap);\n-    }\n-}"}, {"sha": "21bbd82dd333a725df98687ff1ad0559ae54fc7b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -108,7 +108,8 @@ impl Step for Std {\n         std_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target));\n+                  &libstd_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -360,7 +361,8 @@ impl Step for Test {\n         test_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target));\n+                  &libtest_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -488,7 +490,8 @@ impl Step for Rustc {\n         rustc_cargo(build, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target));\n+                  &librustc_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(RustcLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -755,7 +758,7 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n@@ -785,7 +788,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n+pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool) {\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")\n@@ -836,7 +839,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n-               !is_dylib(&filename) {\n+               !is_dylib(&filename) &&\n+               !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue\n             }\n "}, {"sha": "478e496078add23a5b85842e820ecf78b41335c0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -48,6 +48,9 @@ pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n     },\n+    Check {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n@@ -88,6 +91,7 @@ Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n     build       Compile either the compiler or libraries\n+    check       Compile either the compiler or libraries, using cargo check\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n@@ -128,6 +132,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // there on out.\n         let subcommand = args.iter().find(|&s|\n             (s == \"build\")\n+            || (s == \"check\")\n             || (s == \"test\")\n             || (s == \"bench\")\n             || (s == \"doc\")\n@@ -217,6 +222,21 @@ Arguments:\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+            }\n+            \"check\" => {\n+                subcommand_help.push_str(\"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n+\n+        ./x.py check src/libcore\n+        ./x.py check src/libcore src/libproc_macro\n+\n+    If no arguments are passed then the complete artifacts are compiled: std, test, and rustc. Note\n+    also that since we use `cargo check`, by default this will automatically enable incremental\n+    compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n+    ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n+    the compiler.\");\n             }\n             \"test\" => {\n                 subcommand_help.push_str(\"\\n\n@@ -286,6 +306,9 @@ Arguments:\n             \"build\" => {\n                 Subcommand::Build { paths: paths }\n             }\n+            \"check\" => {\n+                Subcommand::Check { paths: paths }\n+            }\n             \"test\" => {\n                 Subcommand::Test {\n                     paths,"}, {"sha": "a6a5ba67723901ea32cd44de9a85449c521be26f", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -150,6 +150,7 @@ use util::{exe, libdir, OutputFolder, CiEnv};\n mod cc_detect;\n mod channel;\n mod check;\n+mod test;\n mod clean;\n mod compile;\n mod metadata;\n@@ -449,12 +450,6 @@ impl Build {\n         out\n     }\n \n-    /// Get the directory for incremental by-products when using the\n-    /// given compiler.\n-    fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n-        self.out.join(&*compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n-    }\n-\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///\n@@ -776,7 +771,11 @@ impl Build {\n     fn release(&self, num: &str) -> String {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n-            \"beta\" => format!(\"{}-beta.{}\", num, self.beta_prerelease_version()),\n+            \"beta\" => if self.rust_info.is_git() {\n+                format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n+            } else {\n+                format!(\"{}-beta\", num)\n+            },\n             \"nightly\" => format!(\"{}-nightly\", num),\n             _ => format!(\"{}-dev\", num),\n         }"}, {"sha": "5faec27943847e5a63314d807667baeaa9e80866", "filename": "src/bootstrap/test.rs", "status": "added", "additions": 1542, "deletions": 0, "changes": 1542, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,1542 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the test-related targets of the build system.\n+//!\n+//! This file implements the various regression test suites that we execute on\n+//! our CI.\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::ffi::OsString;\n+use std::iter;\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::path::{PathBuf, Path};\n+use std::process::Command;\n+use std::io::Read;\n+\n+use build_helper::{self, output};\n+\n+use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use cache::{INTERNER, Interned};\n+use compile;\n+use dist;\n+use native;\n+use tool::{self, Tool};\n+use util::{self, dylib_path, dylib_path_var};\n+use {Build, Mode};\n+use toolstate::ToolState;\n+\n+const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n+\n+/// The two modes of the test runner; tests or benchmarks.\n+#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n+pub enum TestKind {\n+    /// Run `cargo test`\n+    Test,\n+    /// Run `cargo bench`\n+    Bench,\n+}\n+\n+impl TestKind {\n+    // Return the cargo subcommand for this test kind\n+    fn subcommand(self) -> &'static str {\n+        match self {\n+            TestKind::Test => \"test\",\n+            TestKind::Bench => \"bench\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for TestKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            TestKind::Test => \"Testing\",\n+            TestKind::Bench => \"Benchmarking\",\n+        })\n+    }\n+}\n+\n+fn try_run(build: &Build, cmd: &mut Command) -> bool {\n+    if !build.fail_fast {\n+        if !build.try_run(cmd) {\n+            let mut failures = build.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        build.run(cmd);\n+    }\n+    true\n+}\n+\n+fn try_run_quiet(build: &Build, cmd: &mut Command) {\n+    if !build.fail_fast {\n+        if !build.try_run_quiet(cmd) {\n+            let mut failures = build.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+        }\n+    } else {\n+        build.run_quiet(cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Linkcheck {\n+    host: Interned<String>,\n+}\n+\n+impl Step for Linkcheck {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will verify the validity of all our links in the\n+    /// documentation to ensure we don't have a bunch of dead ones.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        println!(\"Linkcheck ({})\", host);\n+\n+        builder.default_doc(None);\n+\n+        let _time = util::timeit();\n+        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n+                            .arg(build.out.join(host).join(\"doc\")));\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Linkcheck { host: run.target });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargotest {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargotest {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargotest\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargotest {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n+    /// test` to ensure that we don't regress the test suites there.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = builder.compiler(self.stage, self.host);\n+        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+\n+        // Note that this is a short, cryptic, and not scoped directory name. This\n+        // is currently to minimize the length of path on Windows where we otherwise\n+        // quickly run into path name limit constraints.\n+        let out_dir = build.out.join(\"ct\");\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let _time = util::timeit();\n+        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n+        try_run(build, cmd.arg(&build.initial_cargo)\n+                          .arg(&out_dir)\n+                          .env(\"RUSTC\", builder.rustc(compiler))\n+                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargo {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargo {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargo\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargo {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for `cargo` packaged with Rust.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = builder.compiler(self.stage, self.host);\n+\n+        builder.ensure(tool::Cargo { compiler, target: self.host });\n+        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n+        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        if !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n+        // available.\n+        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n+\n+        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rls {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rls {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rls\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rls {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for the rls.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        builder.ensure(tool::Rls { compiler, target: self.host });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        if try_run(build, &mut cargo) {\n+            build.save_toolstate(\"rls\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustfmt {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rustfmt {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rustfmt\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustfmt {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for rustfmt.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        if try_run(build, &mut cargo) {\n+            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Miri {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Miri {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let test_miri = run.builder.build.config.test_miri;\n+        run.path(\"src/tools/miri\").default_condition(test_miri)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Miri {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for miri.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(build, &mut cargo) {\n+                build.save_toolstate(\"miri\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Clippy {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Clippy {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for clippy.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n+            cargo.env(\"HOST_LIBS\", host_libs);\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(build, &mut cargo) {\n+                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n+    }\n+}\n+\n+fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n+    // Configure PATH to find the right rustc. NB. we have to use PATH\n+    // and not RUSTC because the Cargo test suite has tests that will\n+    // fail if rustc is not spelled `rustc`.\n+    let path = builder.sysroot(compiler).join(\"bin\");\n+    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocJS {\n+    pub host: Interned<String>,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustdocJS {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/test/rustdoc-js\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustdocJS {\n+            host: run.host,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        if let Some(ref nodejs) = builder.config.nodejs {\n+            let mut command = Command::new(nodejs);\n+            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n+            builder.ensure(::doc::Std {\n+                target: self.target,\n+                stage: builder.top_stage,\n+            });\n+            builder.run(&mut command);\n+        } else {\n+            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Tidy {\n+    host: Interned<String>,\n+}\n+\n+impl Step for Tidy {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` checks up on various bits and pieces of style and\n+    /// otherwise just implements a few lint-like checks that are specific to the\n+    /// compiler itself.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        println!(\"tidy check ({})\", host);\n+        let mut cmd = builder.tool_cmd(Tool::Tidy);\n+        cmd.arg(build.src.join(\"src\"));\n+        if !build.config.vendor {\n+            cmd.arg(\"--no-vendor\");\n+        }\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+        try_run(build, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/tidy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Tidy {\n+            host: run.builder.build.build,\n+        });\n+    }\n+}\n+\n+fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n+    build.out.join(host).join(\"test\")\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct Test {\n+    path: &'static str,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+static DEFAULT_COMPILETESTS: &[Test] = &[\n+    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n+    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n+    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n+    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n+    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n+    Test {\n+        path: \"src/test/run-pass-valgrind\",\n+        mode: \"run-pass-valgrind\",\n+        suite: \"run-pass-valgrind\"\n+    },\n+    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n+    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n+    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n+    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n+\n+    // What this runs varies depending on the native platform being apple\n+    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n+];\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct DefaultCompiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for DefaultCompiletest {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        for test in DEFAULT_COMPILETESTS {\n+            run = run.path(test.path);\n+        }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        let test = run.path.map(|path| {\n+            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n+                path.ends_with(test.path)\n+            }).unwrap_or_else(|| {\n+                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n+            })\n+        });\n+\n+        if let Some(test) = test {\n+            run.builder.ensure(DefaultCompiletest {\n+                compiler,\n+                target: run.target,\n+                mode: test.mode,\n+                suite: test.suite,\n+            });\n+        } else {\n+            for test in DEFAULT_COMPILETESTS {\n+                run.builder.ensure(DefaultCompiletest {\n+                    compiler,\n+                    target: run.target,\n+                    mode: test.mode,\n+                    suite: test.suite\n+                });\n+            }\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Compiletest {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: self.mode,\n+            suite: self.suite,\n+        })\n+    }\n+}\n+\n+// Also default, but host-only.\n+static HOST_COMPILETESTS: &[Test] = &[\n+    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n+    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n+    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n+    Test {\n+        path: \"src/test/compile-fail-fulldeps\",\n+        mode: \"compile-fail\",\n+        suite: \"compile-fail-fulldeps\",\n+    },\n+    Test {\n+        path: \"src/test/incremental-fulldeps\",\n+        mode: \"incremental\",\n+        suite: \"incremental-fulldeps\",\n+    },\n+    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n+    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n+\n+    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n+    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n+    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n+    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n+    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n+    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n+];\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct HostCompiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for HostCompiletest {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        for test in HOST_COMPILETESTS {\n+            run = run.path(test.path);\n+        }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        let test = run.path.map(|path| {\n+            HOST_COMPILETESTS.iter().find(|&&test| {\n+                path.ends_with(test.path)\n+            }).unwrap_or_else(|| {\n+                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n+            })\n+        });\n+\n+        if let Some(test) = test {\n+            run.builder.ensure(HostCompiletest {\n+                compiler,\n+                target: run.target,\n+                mode: test.mode,\n+                suite: test.suite,\n+            });\n+        } else {\n+            for test in HOST_COMPILETESTS {\n+                if test.mode == \"pretty\" {\n+                    continue;\n+                }\n+                run.builder.ensure(HostCompiletest {\n+                    compiler,\n+                    target: run.target,\n+                    mode: test.mode,\n+                    suite: test.suite\n+                });\n+            }\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Compiletest {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: self.mode,\n+            suite: self.suite,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct Compiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for Compiletest {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    /// Executes the `compiletest` tool to run a suite of tests.\n+    ///\n+    /// Compiles all tests with `compiler` for `target` with the specified\n+    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n+    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let suite = self.suite;\n+\n+        // Skip codegen tests if they aren't enabled in configuration.\n+        if !build.config.codegen_tests && suite == \"codegen\" {\n+            return;\n+        }\n+\n+        if suite == \"debuginfo\" {\n+            // Skip debuginfo tests on MSVC\n+            if build.build.contains(\"msvc\") {\n+                return;\n+            }\n+\n+            if mode == \"debuginfo-XXX\" {\n+                return if build.build.contains(\"apple\") {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-lldb\",\n+                        ..self\n+                    });\n+                } else {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-gdb\",\n+                        ..self\n+                    });\n+                };\n+            }\n+\n+            builder.ensure(dist::DebuggerScripts {\n+                sysroot: builder.sysroot(compiler),\n+                host: target\n+            });\n+        }\n+\n+        if suite.ends_with(\"fulldeps\") ||\n+            // FIXME: Does pretty need librustc compiled? Note that there are\n+            // fulldeps test suites with mode = pretty as well.\n+            mode == \"pretty\" ||\n+            mode == \"rustdoc\" ||\n+            mode == \"run-make\" {\n+            builder.ensure(compile::Rustc { compiler, target });\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(native::TestHelpers { target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target);\n+        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n+\n+        // compiletest currently has... a lot of arguments, so let's just pass all\n+        // of them!\n+\n+        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n+\n+        // Avoid depending on rustdoc when we don't need it.\n+        if mode == \"rustdoc\" || mode == \"run-make\" {\n+            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n+        }\n+\n+        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--mode\").arg(mode);\n+        cmd.arg(\"--target\").arg(target);\n+        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n+\n+        if let Some(ref nodejs) = build.config.nodejs {\n+            cmd.arg(\"--nodejs\").arg(nodejs);\n+        }\n+\n+        let mut flags = vec![\"-Crpath\".to_string()];\n+        if build.config.rust_optimize_tests {\n+            flags.push(\"-O\".to_string());\n+        }\n+        if build.config.rust_debuginfo_tests {\n+            flags.push(\"-g\".to_string());\n+        }\n+        flags.push(\"-Zmiri -Zunstable-options\".to_string());\n+        flags.push(build.config.cmd.rustc_args().join(\" \"));\n+\n+        if let Some(linker) = build.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n+        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+\n+        let mut targetflags = flags.clone();\n+        targetflags.push(format!(\"-Lnative={}\",\n+                                 build.test_helpers_out(target).display()));\n+        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+\n+        cmd.arg(\"--docck-python\").arg(build.python());\n+\n+        if build.build.ends_with(\"apple-darwin\") {\n+            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n+            // LLDB plugin's compiled module which only works with the system python\n+            // (namely not Homebrew-installed python)\n+            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n+        } else {\n+            cmd.arg(\"--lldb-python\").arg(build.python());\n+        }\n+\n+        if let Some(ref gdb) = build.config.gdb {\n+            cmd.arg(\"--gdb\").arg(gdb);\n+        }\n+        if let Some(ref vers) = build.lldb_version {\n+            cmd.arg(\"--lldb-version\").arg(vers);\n+        }\n+        if let Some(ref dir) = build.lldb_python_dir {\n+            cmd.arg(\"--lldb-python-dir\").arg(dir);\n+        }\n+\n+        cmd.args(&build.config.cmd.test_args());\n+\n+        if build.is_verbose() {\n+            cmd.arg(\"--verbose\");\n+        }\n+\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+\n+        if build.config.llvm_enabled {\n+            let llvm_config = build.llvm_config(target);\n+            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.is_rust_llvm(target) {\n+                cmd.arg(\"--system-llvm\");\n+            }\n+\n+            // Only pass correct values for these flags for the `run-make` suite as it\n+            // requires that a C++ compiler was configured which isn't always the case.\n+            if suite == \"run-make\" {\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n+                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n+                cmd.arg(\"--cc\").arg(build.cc(target))\n+                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n+                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n+                .arg(\"--llvm-components\").arg(llvm_components.trim())\n+                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                if let Some(ar) = build.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n+            }\n+        }\n+        if suite == \"run-make\" && !build.config.llvm_enabled {\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n+            return;\n+        }\n+\n+        if suite != \"run-make\" {\n+            cmd.arg(\"--cc\").arg(\"\")\n+               .arg(\"--cxx\").arg(\"\")\n+               .arg(\"--cflags\").arg(\"\")\n+               .arg(\"--llvm-components\").arg(\"\")\n+               .arg(\"--llvm-cxxflags\").arg(\"\");\n+        }\n+\n+        if build.remote_tested(target) {\n+            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n+        }\n+\n+        // Running a C compiler on MSVC requires a few env vars to be set, to be\n+        // sure to set them here.\n+        //\n+        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+        // rather than stomp over it.\n+        if target.contains(\"msvc\") {\n+            for &(ref k, ref v) in build.cc[&target].env() {\n+                if k != \"PATH\" {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        build.add_rust_test_threads(&mut cmd);\n+\n+        if build.config.sanitizers {\n+            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n+        }\n+\n+        if build.config.profiler {\n+            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+        }\n+\n+        cmd.arg(\"--adb-path\").arg(\"adb\");\n+        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+        if target.contains(\"android\") {\n+            // Assume that cc for this target comes from the android sysroot\n+            cmd.arg(\"--android-cross-path\")\n+               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+        } else {\n+            cmd.arg(\"--android-cross-path\").arg(\"\");\n+        }\n+\n+        build.ci_env.force_coloring_in_ci(&mut cmd);\n+\n+        let _time = util::timeit();\n+        try_run(build, &mut cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Docs {\n+    compiler: Compiler,\n+}\n+\n+impl Step for Docs {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/doc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Docs {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        });\n+    }\n+\n+    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    ///\n+    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n+    /// `compiler`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Test { compiler, target: compiler.host });\n+\n+        // Do a breadth-first traversal of the `src/doc` directory and just run\n+        // tests for all files that end in `*.md`\n+        let mut stack = vec![build.src.join(\"src/doc\")];\n+        let _time = util::timeit();\n+        let _folder = build.fold_output(|| \"test_docs\");\n+\n+        while let Some(p) = stack.pop() {\n+            if p.is_dir() {\n+                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n+                continue\n+            }\n+\n+            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n+                continue;\n+            }\n+\n+            // The nostarch directory in the book is for no starch, and so isn't\n+            // guaranteed to build. We don't care if it doesn't build, so skip it.\n+            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n+                continue;\n+            }\n+\n+            markdown_test(builder, compiler, &p);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ErrorIndex {\n+    compiler: Compiler,\n+}\n+\n+impl Step for ErrorIndex {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(ErrorIndex {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        });\n+    }\n+\n+    /// Run the error index generator tool to execute the tests located in the error\n+    /// index.\n+    ///\n+    /// The `error_index_generator` tool lives in `src/tools` and is used to\n+    /// generate a markdown file from the error indexes of the code base which is\n+    /// then passed to `rustdoc --test`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n+\n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        println!(\"Testing error-index stage{}\", compiler.stage);\n+\n+        let dir = testdir(build, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        let output = dir.join(\"error-index.md\");\n+\n+        let _time = util::timeit();\n+        build.run(builder.tool_cmd(Tool::ErrorIndex)\n+                    .arg(\"markdown\")\n+                    .arg(&output)\n+                    .env(\"CFG_BUILD\", &build.build)\n+                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n+\n+        markdown_test(builder, compiler, &output);\n+    }\n+}\n+\n+fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n+    let build = builder.build;\n+    let mut file = t!(File::open(markdown));\n+    let mut contents = String::new();\n+    t!(file.read_to_string(&mut contents));\n+    if !contents.contains(\"```\") {\n+        return;\n+    }\n+\n+    println!(\"doc tests for: {}\", markdown.display());\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n+    build.add_rust_test_threads(&mut cmd);\n+    cmd.arg(\"--test\");\n+    cmd.arg(markdown);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+\n+    let test_args = build.config.cmd.test_args().join(\" \");\n+    cmd.arg(\"--test-args\").arg(test_args);\n+\n+    if build.config.quiet_tests {\n+        try_run_quiet(build, &mut cmd);\n+    } else {\n+        try_run(build, &mut cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateLibrustc {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: Option<Interned<String>>,\n+}\n+\n+impl Step for CrateLibrustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"rustc-main\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let make = |name: Option<Interned<String>>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(CrateLibrustc {\n+                compiler,\n+                target: run.target,\n+                test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = run.path {\n+            for (name, krate_path) in builder.crates(\"rustc-main\") {\n+                if path.ends_with(krate_path) {\n+                    make(Some(name));\n+                }\n+            }\n+        } else {\n+            make(None);\n+        }\n+    }\n+\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Librustc,\n+            test_kind: self.test_kind,\n+            krate: self.krate,\n+        });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Crate {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: Mode,\n+    test_kind: TestKind,\n+    krate: Option<Interned<String>>,\n+}\n+\n+impl Step for Crate {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"std\").krate(\"test\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let make = |mode: Mode, name: Option<Interned<String>>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(Crate {\n+                compiler,\n+                target: run.target,\n+                mode,\n+                test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = run.path {\n+            for (name, krate_path) in builder.crates(\"std\") {\n+                if path.ends_with(krate_path) {\n+                    make(Mode::Libstd, Some(name));\n+                }\n+            }\n+            for (name, krate_path) in builder.crates(\"test\") {\n+                if path.ends_with(krate_path) {\n+                    make(Mode::Libtest, Some(name));\n+                }\n+            }\n+        } else {\n+            make(Mode::Libstd, None);\n+            make(Mode::Libtest, None);\n+        }\n+    }\n+\n+    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n+    /// by a `Cargo.toml`\n+    ///\n+    /// This is what runs tests for crates like the standard library, compiler, etc.\n+    /// It essentially is the driver for running `cargo test`.\n+    ///\n+    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n+    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let test_kind = self.test_kind;\n+        let krate = self.krate;\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        // If we're not doing a full bootstrap but we're testing a stage2 version of\n+        // libstd, then what we're actually testing is the libstd produced in\n+        // stage1. Reflect that here by updating the compiler that we're working\n+        // with automatically.\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler.clone()\n+        };\n+\n+        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n+        let (name, root) = match mode {\n+            Mode::Libstd => {\n+                compile::std_cargo(build, &compiler, target, &mut cargo);\n+                (\"libstd\", \"std\")\n+            }\n+            Mode::Libtest => {\n+                compile::test_cargo(build, &compiler, target, &mut cargo);\n+                (\"libtest\", \"test\")\n+            }\n+            Mode::Librustc => {\n+                builder.ensure(compile::Rustc { compiler, target });\n+                compile::rustc_cargo(build, target, &mut cargo);\n+                (\"librustc\", \"rustc-main\")\n+            }\n+            _ => panic!(\"can only test libraries\"),\n+        };\n+        let root = INTERNER.intern_string(String::from(root));\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+        });\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+                &compiler.host, target);\n+\n+        // Build up the base `cargo test` command.\n+        //\n+        // Pass in some standard flags then iterate over the graph we've discovered\n+        // in `cargo metadata` with the maps above and figure out what `-p`\n+        // arguments need to get passed.\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        match krate {\n+            Some(krate) => {\n+                cargo.arg(\"-p\").arg(krate);\n+            }\n+            None => {\n+                let mut visited = HashSet::new();\n+                let mut next = vec![root];\n+                while let Some(name) = next.pop() {\n+                    // Right now jemalloc and the sanitizer crates are\n+                    // target-specific crate in the sense that it's not present\n+                    // on all platforms. Custom skip it here for now, but if we\n+                    // add more this probably wants to get more generalized.\n+                    //\n+                    // Also skip `build_helper` as it's not compiled normally\n+                    // for target during the bootstrap and it's just meant to be\n+                    // a helper crate, not tested. If it leaks through then it\n+                    // ends up messing with various mtime calculations and such.\n+                    if !name.contains(\"jemalloc\") &&\n+                       *name != *\"build_helper\" &&\n+                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n+                       name != \"dlmalloc\" {\n+                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n+                    }\n+                    for dep in build.crates[&name].deps.iter() {\n+                        if visited.insert(dep) {\n+                            next.push(*dep);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // The tests are going to run with the *target* libraries, so we need to\n+        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n+        //\n+        // Note that to run the compiler we need to run with the *host* libraries,\n+        // but our wrapper scripts arrange for that to be the case anyway.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&build.config.cmd.test_args());\n+\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _time = util::timeit();\n+\n+        if target.contains(\"emscripten\") {\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+        } else if target.starts_with(\"wasm32\") {\n+            // On the wasm32-unknown-unknown target we're using LTO which is\n+            // incompatible with `-C prefer-dynamic`, so disable that here\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+            let node = build.config.nodejs.as_ref()\n+                .expect(\"nodejs not configured\");\n+            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n+                                 node.display(),\n+                                 build.src.display());\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n+        } else if build.remote_tested(target) {\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      format!(\"{} run\",\n+                              builder.tool_exe(Tool::RemoteTestClient).display()));\n+        }\n+        try_run(build, &mut cargo);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustdoc {\n+    host: Interned<String>,\n+    test_kind: TestKind,\n+}\n+\n+impl Step for Rustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(Rustdoc {\n+            host: run.host,\n+            test_kind,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let test_kind = self.test_kind;\n+\n+        let compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = compiler.host;\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 target,\n+                                                 test_kind.subcommand(),\n+                                                 \"src/tools/rustdoc\");\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target);\n+\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&build.config.cmd.test_args());\n+\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _time = util::timeit();\n+\n+        try_run(build, &mut cargo);\n+    }\n+}\n+\n+fn envify(s: &str) -> String {\n+    s.chars().map(|c| {\n+        match c {\n+            '-' => '_',\n+            c => c,\n+        }\n+    }).flat_map(|c| c.to_uppercase()).collect()\n+}\n+\n+/// Some test suites are run inside emulators or on remote devices, and most\n+/// of our test binaries are linked dynamically which means we need to ship\n+/// the standard library and such to the emulator ahead of time. This step\n+/// represents this and is a dependency of all test suites.\n+///\n+/// Most of the time this is a noop. For some steps such as shipping data to\n+/// QEMU we have to build our own tools so we've got conditional dependencies\n+/// on those programs as well. Note that the remote test client is built for\n+/// the build target (us) and the server is built for the target.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RemoteCopyLibs {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+}\n+\n+impl Step for RemoteCopyLibs {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        if !build.remote_tested(target) {\n+            return\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+\n+        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n+\n+        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n+\n+        // Spawn the emulator and wait for it to come online\n+        let tool = builder.tool_exe(Tool::RemoteTestClient);\n+        let mut cmd = Command::new(&tool);\n+        cmd.arg(\"spawn-emulator\")\n+           .arg(target)\n+           .arg(&server)\n+           .arg(build.out.join(\"tmp\"));\n+        if let Some(rootfs) = build.qemu_rootfs(target) {\n+            cmd.arg(rootfs);\n+        }\n+        build.run(&mut cmd);\n+\n+        // Push all our dylibs to the emulator\n+        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n+            let f = t!(f);\n+            let name = f.file_name().into_string().unwrap();\n+            if util::is_dylib(&name) {\n+                build.run(Command::new(&tool)\n+                                  .arg(\"push\")\n+                                  .arg(f.path()));\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Distcheck;\n+\n+impl Step for Distcheck {\n+    type Output = ();\n+    const ONLY_BUILD: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"distcheck\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Distcheck);\n+    }\n+\n+    /// Run \"distcheck\", a 'make check' from a tarball\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+\n+        println!(\"Distcheck\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        // Guarantee that these are built before we begin running.\n+        builder.ensure(dist::PlainSourceTarball);\n+        builder.ensure(dist::Src);\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(builder.ensure(dist::PlainSourceTarball))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+        build.run(Command::new(\"./configure\")\n+                         .args(&build.config.configure_args)\n+                         .arg(\"--enable-vendor\")\n+                         .current_dir(&dir));\n+        build.run(Command::new(build_helper::make(&build.build))\n+                         .arg(\"check\")\n+                         .current_dir(&dir));\n+\n+        // Now make sure that rust-src has all of libstd's dependencies\n+        println!(\"Distcheck rust-src\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(builder.ensure(dist::Src))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+\n+        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n+        build.run(Command::new(&build.initial_cargo)\n+                         .arg(\"generate-lockfile\")\n+                         .arg(\"--manifest-path\")\n+                         .arg(&toml)\n+                         .current_dir(&dir));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Bootstrap;\n+\n+impl Step for Bootstrap {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    /// Test the build system itself\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let mut cmd = Command::new(&build.initial_cargo);\n+        cmd.arg(\"test\")\n+           .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n+           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+           .env(\"RUSTC\", &build.initial_rustc);\n+        if !build.fail_fast {\n+            cmd.arg(\"--no-fail-fast\");\n+        }\n+        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n+        try_run(build, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/bootstrap\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Bootstrap);\n+    }\n+}"}, {"sha": "f9f5b7062f8a43b41ec569432729217250cb657e", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   clang \\"}, {"sha": "0a95675bab808c49f86208bacc89c5d9c53ac43f", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1 +1 @@\n-Subproject commit 0ba07e49264a54cb5bbd4856fcea083bb3fbec15\n+Subproject commit 0a95675bab808c49f86208bacc89c5d9c53ac43f"}, {"sha": "1de9091b5df7d34f059aa9418186f7bf1d4ea24f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -638,6 +638,7 @@ define_dep_nodes!( <'tcx>\n     [input] TargetFeaturesWhitelist,\n     [] TargetFeaturesEnabled(DefId),\n \n+    [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "97cf9b01410b1bccedfe309845fdac247c1ac4b8", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -43,7 +43,6 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n use hir::def::Def;\n@@ -336,6 +335,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n+    fn visit_label(&mut self, label: &'v Label) {\n+        walk_label(self, label)\n+    }\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -370,18 +372,6 @@ pub trait Visitor<'v> : Sized {\n     }\n }\n \n-pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    if let Some(name) = opt_name {\n-        visitor.visit_name(span, name);\n-    }\n-}\n-\n-pub fn walk_opt_sp_name<'v, V: Visitor<'v>>(visitor: &mut V, opt_sp_name: &Option<Spanned<Name>>) {\n-    if let Some(ref sp_name) = *opt_sp_name {\n-        visitor.visit_name(sp_name.span, sp_name.node);\n-    }\n-}\n-\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n@@ -420,6 +410,10 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n \n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_name(label.span, label.name);\n+}\n+\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n     match lifetime.name {\n@@ -452,7 +446,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     match item.node {\n         ItemExternCrate(opt_name) => {\n             visitor.visit_id(item.id);\n-            walk_opt_name(visitor, item.span, opt_name)\n+            if let Some(name) = opt_name {\n+                visitor.visit_name(item.span, name);\n+            }\n         }\n         ItemUse(ref path, _) => {\n             visitor.visit_id(item.id);\n@@ -993,14 +989,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, ref opt_sp_name) => {\n+        ExprWhile(ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, ref opt_sp_name, _) => {\n+        ExprLoop(ref block, ref opt_label, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n-            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n@@ -1036,28 +1032,28 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(label, ref opt_expr) => {\n-            label.ident.map(|ident| {\n-                match label.target_id {\n+        ExprBreak(ref destination, ref opt_expr) => {\n+            if let Some(ref label) = destination.label {\n+                visitor.visit_label(label);\n+                match destination.target_id {\n                     ScopeTarget::Block(node_id) |\n                     ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n                         visitor.visit_def_mention(Def::Label(node_id)),\n                     ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n                 };\n-                visitor.visit_name(ident.span, ident.node.name);\n-            });\n+            }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(label) => {\n-            label.ident.map(|ident| {\n-                match label.target_id {\n+        ExprAgain(ref destination) => {\n+            if let Some(ref label) = destination.label {\n+                visitor.visit_label(label);\n+                match destination.target_id {\n                     ScopeTarget::Block(_) => bug!(\"can't `continue` to a non-loop block\"),\n                     ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n                         visitor.visit_def_mention(Def::Label(node_id)),\n                     ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n                 };\n-                visitor.visit_name(ident.span, ident.node.name);\n-            });\n+            }\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "f2f420c91dd1a1455375f7f9f5afbca70784de2c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -773,22 +773,22 @@ impl<'a> LoweringContext<'a> {\n         *self.name_map.entry(ident).or_insert_with(|| Symbol::from_ident(ident))\n     }\n \n-    fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n-        o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n+    fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n+        label.map(|label| hir::Label { name: label.ident.name, span: label.span })\n     }\n \n-    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n+    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>)\n         -> hir::Destination\n     {\n         match destination {\n-            Some((id, label_ident)) => {\n+            Some((id, label)) => {\n                 let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n                     hir::LoopIdResult::Ok(self.lower_node_id(loop_id).node_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 };\n                 hir::Destination {\n-                    ident: Some(label_ident),\n+                    label: self.lower_label(Some(label)),\n                     target_id: hir::ScopeTarget::Loop(target),\n                 }\n             },\n@@ -798,7 +798,7 @@ impl<'a> LoweringContext<'a> {\n                                   .map(|innermost_loop_id| *innermost_loop_id);\n \n                 hir::Destination {\n-                    ident: None,\n+                    label: None,\n                     target_id: hir::ScopeTarget::Loop(\n                         loop_id.map(|id| Ok(self.lower_node_id(id).node_id))\n                                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n@@ -2751,17 +2751,17 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n             }\n-            ExprKind::While(ref cond, ref body, opt_ident) => {\n+            ExprKind::While(ref cond, ref body, opt_label) => {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprWhile(\n                         this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n                         this.lower_block(body, false),\n-                        this.lower_opt_sp_ident(opt_ident)))\n+                        this.lower_label(opt_label)))\n             }\n-            ExprKind::Loop(ref body, opt_ident) => {\n+            ExprKind::Loop(ref body, opt_label) => {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprLoop(this.lower_block(body, false),\n-                                  this.lower_opt_sp_ident(opt_ident),\n+                                  this.lower_label(opt_label),\n                                   hir::LoopSource::Loop))\n             }\n             ExprKind::Catch(ref body) => {\n@@ -2837,8 +2837,8 @@ impl<'a> LoweringContext<'a> {\n                     (&None, &Some(..), Closed) => \"RangeToInclusive\",\n                     (&Some(..), &Some(..), Closed) => \"RangeInclusive\",\n                     (_, &None, Closed) =>\n-                        panic!(self.diagnostic().span_fatal(\n-                            e.span, \"inclusive range with no end\")),\n+                        self.diagnostic().span_fatal(\n+                            e.span, \"inclusive range with no end\").raise(),\n                 };\n \n                 let fields =\n@@ -2877,30 +2877,30 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional,\n                                                ImplTraitContext::Disallowed))\n             }\n-            ExprKind::Break(opt_ident, ref opt_expr) => {\n-                let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                let destination = if self.is_in_loop_condition && opt_label.is_none() {\n                     hir::Destination {\n-                        ident: opt_ident,\n+                        label: None,\n                         target_id: hir::ScopeTarget::Loop(\n                                 Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                     }\n                 } else {\n-                    self.lower_loop_destination(opt_ident.map(|ident| (e.id, ident)))\n+                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 };\n                 hir::ExprBreak(\n-                        label_result,\n+                        destination,\n                         opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n             }\n-            ExprKind::Continue(opt_ident) =>\n+            ExprKind::Continue(opt_label) =>\n                 hir::ExprAgain(\n-                    if self.is_in_loop_condition && opt_ident.is_none() {\n+                    if self.is_in_loop_condition && opt_label.is_none() {\n                         hir::Destination {\n-                            ident: opt_ident,\n+                            label: None,\n                             target_id: hir::ScopeTarget::Loop(Err(\n                                 hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                         }\n                     } else {\n-                        self.lower_loop_destination(opt_ident.map( |ident| (e.id, ident)))\n+                        self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                     }),\n             ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n             ExprKind::InlineAsm(ref asm) => {\n@@ -3000,7 +3000,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -3041,15 +3041,15 @@ impl<'a> LoweringContext<'a> {\n \n                 // `[opt_ident]: loop { ... }`\n                 let loop_block = P(self.block_expr(P(match_expr)));\n-                let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                let loop_expr = hir::ExprLoop(loop_block, self.lower_label(opt_label),\n                                               hir::LoopSource::WhileLet);\n                 // add attributes to the outer returned expr node\n                 loop_expr\n             }\n \n             // Desugar ExprForLoop\n             // From: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprKind::ForLoop(ref pat, ref head, ref body, opt_ident) => {\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   {\n@@ -3150,7 +3150,7 @@ impl<'a> LoweringContext<'a> {\n                                                   None));\n \n                 // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                let loop_expr = hir::ExprLoop(loop_block, self.lower_label(opt_label),\n                                               hir::LoopSource::ForLoop);\n                 let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n@@ -3270,7 +3270,7 @@ impl<'a> LoweringContext<'a> {\n                             e.span,\n                             hir::ExprBreak(\n                                 hir::Destination {\n-                                    ident: None,\n+                                    label: None,\n                                     target_id: hir::ScopeTarget::Block(catch_node),\n                                 },\n                                 Some(from_err_expr)"}, {"sha": "2854b9da1476f618e964195d89ca3954367fa17f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -34,7 +34,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n@@ -172,6 +172,18 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct Label {\n+    pub name: Name,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"label({:?})\", self.name)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -1276,11 +1288,11 @@ pub enum Expr_ {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Spanned<Name>>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Spanned<Name>>, LoopSource),\n+    ExprLoop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -1459,7 +1471,7 @@ impl ScopeTarget {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n-    pub ident: Option<Spanned<Ident>>,\n+    pub label: Option<Label>,\n \n     // These errors are caught and then reported during the diagnostics pass in\n     // librustc_passes/loops.rs"}, {"sha": "30c1ad01d140138705fd350114a595c59d3ab2de", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1337,19 +1337,19 @@ impl<'a> State<'a> {\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_sp_name) => {\n-                if let Some(sp_name) = opt_sp_name {\n-                    self.print_name(sp_name.node)?;\n+            hir::ExprWhile(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr_as_cond(&test)?;\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_sp_name, _) => {\n-                if let Some(sp_name) = opt_sp_name {\n-                    self.print_name(sp_name.node)?;\n+            hir::ExprLoop(ref blk, opt_label, _) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -1424,23 +1424,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprBreak(destination, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n-                if let Some(label_ident) = label.ident {\n-                    self.print_name(label_ident.node.name)?;\n+                if let Some(label) = destination.label {\n+                    self.print_name(label.name)?;\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n-            hir::ExprAgain(label) => {\n+            hir::ExprAgain(destination) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n-                if let Some(label_ident) = label.ident {\n-                    self.print_name(label_ident.node.name)?;\n+                if let Some(label) = destination.label {\n+                    self.print_name(label.name)?;\n                     self.s.space()?\n                 }\n             }"}, {"sha": "7dca96f94e655f8b4ff318f9f24d69d875391471", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -148,6 +148,11 @@ impl_stable_hash_for!(enum hir::LifetimeName {\n     Name(name)\n });\n \n+impl_stable_hash_for!(struct hir::Label {\n+    span,\n+    name\n+});\n+\n impl_stable_hash_for!(struct hir::Lifetime {\n     id,\n     span,\n@@ -619,7 +624,7 @@ impl_stable_hash_for!(enum hir::CaptureClause {\n impl_stable_hash_for_spanned!(usize);\n \n impl_stable_hash_for!(struct hir::Destination {\n-    ident,\n+    label,\n     target_id\n });\n "}, {"sha": "68d81a2dee352c4f72becb5da5cfad63bc385164", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -82,7 +82,7 @@ pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n /// Describes constraints between the region variables and other\n /// regions, as well as other conditions that must be verified, or\n /// assumptions that can be made.\n-#[derive(Default)]\n+#[derive(Debug, Default)]\n pub struct RegionConstraintData<'tcx> {\n     /// Constraints of the form `A <= B`, where either `A` or `B` can\n     /// be a region variable (or neither, as it happens)."}, {"sha": "944d770516375ea20dd03aad6cd987722f7f3c8f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1018,7 +1018,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(.., Some(label)) | hir::ExprLoop(_, Some(label), _) => {\n-                Some((label.node, label.span))\n+                Some((label.name, label.span))\n             }\n             _ => None,\n         }"}, {"sha": "49e5c0dc21f9ead7954c506cc9db63a6d32f9ef2", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n-use ty::Instance;\n+use ty::{Instance, TyCtxt};\n use util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n@@ -25,6 +25,21 @@ pub enum MonoItem<'tcx> {\n     GlobalAsm(NodeId),\n }\n \n+impl<'tcx> MonoItem<'tcx> {\n+    pub fn size_estimate<'a>(&self, tcx: &TyCtxt<'a, 'tcx, 'tcx>) -> usize {\n+        match *self {\n+            MonoItem::Fn(instance) => {\n+                // Estimate the size of a function based on how many statements\n+                // it contains.\n+                tcx.instance_def_size_estimate(instance.def)\n+            },\n+            // Conservatively estimate the size of a static declaration\n+            // or assembly to be 1.\n+            MonoItem::Static(_) | MonoItem::GlobalAsm(_) => 1,\n+        }\n+    }\n+}\n+\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                            hcx: &mut StableHashingContext<'tcx>,\n@@ -52,6 +67,7 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n+    size_estimate: Option<usize>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -101,6 +117,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         CodegenUnit {\n             name: name,\n             items: FxHashMap(),\n+            size_estimate: None,\n         }\n     }\n \n@@ -131,6 +148,24 @@ impl<'tcx> CodegenUnit<'tcx> {\n         let hash = hash & ((1u128 << 80) - 1);\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n+\n+    pub fn estimate_size<'a>(&mut self, tcx: &TyCtxt<'a, 'tcx, 'tcx>) {\n+        // Estimate the size of a codegen unit as (approximately) the number of MIR\n+        // statements it corresponds to.\n+        self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n+    }\n+\n+    pub fn size_estimate(&self) -> usize {\n+        // Should only be called if `estimate_size` has previously been called.\n+        self.size_estimate.expect(\"estimate_size must be called before getting a size_estimate\")\n+    }\n+\n+    pub fn modify_size_estimate(&mut self, delta: usize) {\n+        assert!(self.size_estimate.is_some());\n+        if let Some(size_estimate) = self.size_estimate {\n+            self.size_estimate = Some(size_estimate + delta);\n+        }\n+    }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n@@ -140,6 +175,8 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n         let CodegenUnit {\n             ref items,\n             name,\n+            // The size estimate is not relevant to the hash\n+            size_estimate: _,\n         } = *self;\n \n         name.hash_stable(hcx, hasher);"}, {"sha": "b9546143a054b32af67f2b88bf2ddd72cf5edfe5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -72,6 +72,26 @@ pub enum OptLevel {\n     SizeMin, // -Oz\n }\n \n+#[derive(Clone, Copy, PartialEq, Hash)]\n+pub enum Lto {\n+    /// Don't do any LTO whatsoever\n+    No,\n+\n+    /// Do a full crate graph LTO. The flavor is determined by the compiler\n+    /// (currently the default is \"fat\").\n+    Yes,\n+\n+    /// Do a full crate graph LTO with ThinLTO\n+    Thin,\n+\n+    /// Do a local graph LTO with ThinLTO (only relevant for multiple codegen\n+    /// units).\n+    ThinLocal,\n+\n+    /// Do a full crate graph LTO with \"fat\" LTO\n+    Fat,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n@@ -389,7 +409,7 @@ top_level_options!(\n         // commands like `--emit llvm-ir` which they're often incompatible with\n         // if we otherwise use the defaults of rustc.\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n-        cli_forced_thinlto: Option<bool> [UNTRACKED],\n+        cli_forced_thinlto_off: bool [UNTRACKED],\n     }\n );\n \n@@ -590,7 +610,7 @@ pub fn basic_options() -> Options {\n         debug_assertions: true,\n         actually_rustdoc: false,\n         cli_forced_codegen_units: None,\n-        cli_forced_thinlto: None,\n+        cli_forced_thinlto_off: false,\n     }\n }\n \n@@ -780,11 +800,13 @@ macro_rules! options {\n             Some(\"crate=integer\");\n         pub const parse_unpretty: Option<&'static str> =\n             Some(\"`string` or `string=string`\");\n+        pub const parse_lto: Option<&'static str> =\n+            Some(\"one of `thin`, `fat`, or omitted\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer};\n+        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer, Lto};\n         use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n \n@@ -978,6 +1000,16 @@ macro_rules! options {\n                 _ => false,\n             }\n         }\n+\n+        fn parse_lto(slot: &mut Lto, v: Option<&str>) -> bool {\n+            *slot = match v {\n+                None => Lto::Yes,\n+                Some(\"thin\") => Lto::Thin,\n+                Some(\"fat\") => Lto::Fat,\n+                Some(_) => return false,\n+            };\n+            true\n+        }\n     }\n ) }\n \n@@ -994,7 +1026,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"extra arguments to append to the linker invocation (space separated)\"),\n     link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: bool = (false, parse_bool, [TRACKED],\n+    lto: Lto = (Lto::No, parse_lto, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (rustc --print target-cpus for details)\"),\n@@ -1135,6 +1167,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"treat all errors that occur as bugs\"),\n     external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n           \"show macro backtraces even for non-local macros\"),\n+    teach: bool = (false, parse_bool, [TRACKED],\n+          \"show extended diagnostic help\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1333,16 +1367,16 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n             sp.struct_fatal(&format!(\"Error loading target specification: {}\", e))\n                 .help(\"Use `--print target-list` for a list of built-in targets\")\n                 .emit();\n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n     };\n \n     let (isize_ty, usize_ty) = match &target.target_pointer_width[..] {\n         \"16\" => (ast::IntTy::I16, ast::UintTy::U16),\n         \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n         \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n-        w    => panic!(sp.fatal(&format!(\"target specification was invalid: \\\n-                                          unrecognized target-pointer-width {}\", w))),\n+        w    => sp.fatal(&format!(\"target specification was invalid: \\\n+                                          unrecognized target-pointer-width {}\", w)).raise(),\n     };\n \n     Config {\n@@ -1632,8 +1666,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     let mut debugging_opts = build_debugging_options(matches, error_format);\n \n     if !debugging_opts.unstable_options && error_format == ErrorOutputType::Json(true) {\n-        early_error(ErrorOutputType::Json(false),\n-                    \"--error-format=pretty-json is unstable\");\n+        early_error(ErrorOutputType::Json(false), \"--error-format=pretty-json is unstable\");\n     }\n \n     let mut output_types = BTreeMap::new();\n@@ -1677,7 +1710,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let mut cg = build_codegen_options(matches, error_format);\n     let mut codegen_units = cg.codegen_units;\n-    let mut thinlto = None;\n+    let mut disable_thinlto = false;\n \n     // Issue #30063: if user requests llvm-related output to one\n     // particular path, disable codegen-units.\n@@ -1699,12 +1732,12 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                     }\n                     early_warn(error_format, \"resetting to default -C codegen-units=1\");\n                     codegen_units = Some(1);\n-                    thinlto = Some(false);\n+                    disable_thinlto = true;\n                 }\n             }\n             _ => {\n                 codegen_units = Some(1);\n-                thinlto = Some(false);\n+                disable_thinlto = true;\n             }\n         }\n     }\n@@ -1734,7 +1767,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         (&None, &None) => None,\n     }.map(|m| PathBuf::from(m));\n \n-    if cg.lto && incremental.is_some() {\n+    if cg.lto != Lto::No && incremental.is_some() {\n         early_error(error_format, \"can't perform LTO when compiling incrementally\");\n     }\n \n@@ -1934,7 +1967,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         debug_assertions,\n         actually_rustdoc: false,\n         cli_forced_codegen_units: codegen_units,\n-        cli_forced_thinlto: thinlto,\n+        cli_forced_thinlto_off: disable_thinlto,\n     },\n     cfg)\n }\n@@ -2052,7 +2085,7 @@ mod dep_tracking {\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n-    use super::{Passes, CrateType, OptLevel, DebugInfoLevel,\n+    use super::{Passes, CrateType, OptLevel, DebugInfoLevel, Lto,\n                 OutputTypes, Externs, ErrorOutputType, Sanitizer};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::{PanicStrategy, RelroLevel};\n@@ -2107,6 +2140,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(RelroLevel);\n     impl_dep_tracking_hash_via_hash!(Passes);\n     impl_dep_tracking_hash_via_hash!(OptLevel);\n+    impl_dep_tracking_hash_via_hash!(Lto);\n     impl_dep_tracking_hash_via_hash!(DebugInfoLevel);\n     impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n     impl_dep_tracking_hash_via_hash!(Externs);\n@@ -2180,6 +2214,7 @@ mod tests {\n     use lint;\n     use middle::cstore;\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n+    use session::config::Lto;\n     use session::build_session;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n@@ -2656,7 +2691,7 @@ mod tests {\n \n         // Make sure changing a [TRACKED] option changes the hash\n         opts = reference.clone();\n-        opts.cg.lto = true;\n+        opts.cg.lto = Lto::Fat;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "2765239d5e6494cc0c1d84dae5307164ba3b2025", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -250,18 +250,18 @@ impl Session {\n     }\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        panic!(self.diagnostic().span_fatal(sp, msg))\n+        self.diagnostic().span_fatal(sp, msg).raise()\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n     ) -> ! {\n-        panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n+        self.diagnostic().span_fatal_with_code(sp, msg, code).raise()\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        panic!(self.diagnostic().fatal(msg))\n+        self.diagnostic().fatal(msg).raise()\n     }\n     pub fn span_err_or_warn<S: Into<MultiSpan>>(&self, is_warning: bool, sp: S, msg: &str) {\n         if is_warning {\n@@ -498,9 +498,65 @@ impl Session {\n             self.use_mir()\n     }\n \n-    pub fn lto(&self) -> bool {\n-        self.opts.cg.lto || self.target.target.options.requires_lto\n+    /// Calculates the flavor of LTO to use for this compilation.\n+    pub fn lto(&self) -> config::Lto {\n+        // If our target has codegen requirements ignore the command line\n+        if self.target.target.options.requires_lto {\n+            return config::Lto::Fat\n+        }\n+\n+        // If the user specified something, return that. If they only said `-C\n+        // lto` and we've for whatever reason forced off ThinLTO via the CLI,\n+        // then ensure we can't use a ThinLTO.\n+        match self.opts.cg.lto {\n+            config::Lto::No => {}\n+            config::Lto::Yes if self.opts.cli_forced_thinlto_off => {\n+                return config::Lto::Fat\n+            }\n+            other => return other,\n+        }\n+\n+        // Ok at this point the target doesn't require anything and the user\n+        // hasn't asked for anything. Our next decision is whether or not\n+        // we enable \"auto\" ThinLTO where we use multiple codegen units and\n+        // then do ThinLTO over those codegen units. The logic below will\n+        // either return `No` or `ThinLocal`.\n+\n+        // If processing command line options determined that we're incompatible\n+        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n+        if self.opts.cli_forced_thinlto_off {\n+            return config::Lto::No\n+        }\n+\n+        // If `-Z thinlto` specified process that, but note that this is mostly\n+        // a deprecated option now that `-C lto=thin` exists.\n+        if let Some(enabled) = self.opts.debugging_opts.thinlto {\n+            if enabled {\n+                return config::Lto::ThinLocal\n+            } else {\n+                return config::Lto::No\n+            }\n+        }\n+\n+        // If there's only one codegen unit and LTO isn't enabled then there's\n+        // no need for ThinLTO so just return false.\n+        if self.codegen_units() == 1 {\n+            return config::Lto::No\n+        }\n+\n+        // Right now ThinLTO isn't compatible with incremental compilation.\n+        if self.opts.incremental.is_some() {\n+            return config::Lto::No\n+        }\n+\n+        // Now we're in \"defaults\" territory. By default we enable ThinLTO for\n+        // optimized compiles (anything greater than O0).\n+        match self.opts.optimize {\n+            config::OptLevel::No => config::Lto::No,\n+            _ => config::Lto::ThinLocal,\n+        }\n     }\n+\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n     pub fn panic_strategy(&self) -> PanicStrategy {\n@@ -805,36 +861,8 @@ impl Session {\n         16\n     }\n \n-    /// Returns whether ThinLTO is enabled for this compilation\n-    pub fn thinlto(&self) -> bool {\n-        // If processing command line options determined that we're incompatible\n-        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n-        if let Some(enabled) = self.opts.cli_forced_thinlto {\n-            return enabled\n-        }\n-\n-        // If explicitly specified, use that with the next highest priority\n-        if let Some(enabled) = self.opts.debugging_opts.thinlto {\n-            return enabled\n-        }\n-\n-        // If there's only one codegen unit and LTO isn't enabled then there's\n-        // no need for ThinLTO so just return false.\n-        if self.codegen_units() == 1 && !self.lto() {\n-            return false\n-        }\n-\n-        // Right now ThinLTO isn't compatible with incremental compilation.\n-        if self.opts.incremental.is_some() {\n-            return false\n-        }\n-\n-        // Now we're in \"defaults\" territory. By default we enable ThinLTO for\n-        // optimized compiles (anything greater than O0).\n-        match self.opts.optimize {\n-            config::OptLevel::No => false,\n-            _ => true,\n-        }\n+    pub fn teach(&self, code: &DiagnosticId) -> bool {\n+        self.opts.debugging_opts.teach && !self.parse_sess.span_diagnostic.code_emitted(code)\n     }\n }\n \n@@ -919,7 +947,7 @@ pub fn build_session_(sopts: config::Options,\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n+            span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)).raise();\n         }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n@@ -945,7 +973,7 @@ pub fn build_session_(sopts: config::Options,\n     let working_dir = match env::current_dir() {\n         Ok(dir) => dir,\n         Err(e) => {\n-            panic!(p_s.span_diagnostic.fatal(&format!(\"Current directory is invalid: {}\", e)))\n+            p_s.span_diagnostic.fatal(&format!(\"Current directory is invalid: {}\", e)).raise()\n         }\n     };\n     let working_dir = file_path_mapping.map_prefix(working_dir);\n@@ -1076,7 +1104,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     };\n     let handler = errors::Handler::with_emitter(true, false, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n-    panic!(errors::FatalError);\n+    errors::FatalError.raise();\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {"}, {"sha": "42200a3a44728335967a229640ddbb4501e33953", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -794,48 +794,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n-        if let hir::map::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(_, ref _decl, id, span, _),\n-            ..\n-        }) = node {\n-            (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n-                .map(|arg| {\n-                    if let hir::Pat {\n-                        node: hir::PatKind::Tuple(args, _),\n-                        span,\n-                        ..\n-                    } = arg.pat.clone().into_inner() {\n-                        ArgKind::Tuple(\n+        match node {\n+            hir::map::NodeExpr(&hir::Expr {\n+                node: hir::ExprClosure(_, ref _decl, id, span, _),\n+                ..\n+            }) => {\n+                (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                    .map(|arg| {\n+                        if let hir::Pat {\n+                            node: hir::PatKind::Tuple(args, _),\n                             span,\n-                            args.iter().map(|pat| {\n-                                let snippet = self.tcx.sess.codemap()\n-                                    .span_to_snippet(pat.span).unwrap();\n-                                (snippet, \"_\".to_owned())\n-                            }).collect::<Vec<_>>(),\n-                        )\n-                    } else {\n-                        let name = self.tcx.sess.codemap().span_to_snippet(arg.pat.span).unwrap();\n-                        ArgKind::Arg(name, \"_\".to_owned())\n-                    }\n-                })\n-                .collect::<Vec<ArgKind>>())\n-        } else if let hir::map::NodeItem(&hir::Item {\n-            span,\n-            node: hir::ItemFn(ref decl, ..),\n-            ..\n-        }) = node {\n-            (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n-                    .map(|arg| match arg.clone().into_inner().node {\n-                hir::TyTup(ref tys) => ArgKind::Tuple(\n-                    arg.span,\n-                    tys.iter()\n-                        .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n-                        .collect::<Vec<_>>(),\n-                ),\n-                _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n-            }).collect::<Vec<ArgKind>>())\n-        } else {\n-            panic!(\"non-FnLike node found: {:?}\", node);\n+                            ..\n+                        } = arg.pat.clone().into_inner() {\n+                            ArgKind::Tuple(\n+                                span,\n+                                args.iter().map(|pat| {\n+                                    let snippet = self.tcx.sess.codemap()\n+                                        .span_to_snippet(pat.span).unwrap();\n+                                    (snippet, \"_\".to_owned())\n+                                }).collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name = self.tcx.sess.codemap()\n+                                .span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>())\n+            }\n+            hir::map::NodeItem(&hir::Item {\n+                span,\n+                node: hir::ItemFn(ref decl, ..),\n+                ..\n+            }) |\n+            hir::map::NodeImplItem(&hir::ImplItem {\n+                span,\n+                node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                ..\n+            }) => {\n+                (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                        .map(|arg| match arg.clone().into_inner().node {\n+                    hir::TyTup(ref tys) => ArgKind::Tuple(\n+                        arg.span,\n+                        tys.iter()\n+                            .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n+                            .collect::<Vec<_>>(),\n+                    ),\n+                    _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+                }).collect::<Vec<ArgKind>>())\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n     }\n "}, {"sha": "ae539f07336d53f9920d4c0cb66aa512c07d8c5d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -101,7 +101,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     // from a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n@@ -293,9 +293,23 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                     Reveal::UserFacing => ty,\n \n                     Reveal::All => {\n+                        let recursion_limit = self.tcx().sess.recursion_limit.get();\n+                        if self.depth >= recursion_limit {\n+                            let obligation = Obligation::with_depth(\n+                                self.cause.clone(),\n+                                recursion_limit,\n+                                self.param_env,\n+                                ty,\n+                            );\n+                            self.selcx.infcx().report_overflow_error(&obligation, true);\n+                        }\n+\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n-                        self.fold_ty(concrete_ty)\n+                        self.depth += 1;\n+                        let folded_ty = self.fold_ty(concrete_ty);\n+                        self.depth -= 1;\n+                        folded_ty\n                     }\n                 }\n             }\n@@ -824,21 +838,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n     // Drop duplicates.\n     //\n     // Note: `candidates.vec` seems to be on the critical path of the\n-    // compiler. Replacing it with an hash set was also tried, which would\n-    // render the following dedup unnecessary. It led to cleaner code but\n-    // prolonged compiling time of `librustc` from 5m30s to 6m in one test, or\n-    // ~9% performance lost.\n-    if candidates.vec.len() > 1 {\n-        let mut i = 0;\n-        while i < candidates.vec.len() {\n-            let has_dup = (0..i).any(|j| candidates.vec[i] == candidates.vec[j]);\n-            if has_dup {\n-                candidates.vec.swap_remove(i);\n-            } else {\n-                i += 1;\n-            }\n-        }\n-    }\n+    // compiler. Replacing it with an HashSet was also tried, which would\n+    // render the following dedup unnecessary. The original comment indicated\n+    // that it was 9% slower, but that data is now obsolete and a new\n+    // benchmark should be performed.\n+    candidates.vec.sort_unstable();\n+    candidates.vec.dedup();\n \n     // Prefer where-clauses. As in select, if there are multiple\n     // candidates, we prefer where-clause candidates over impls.  This"}, {"sha": "93e4cd9adf888ded465ec92d45730c065e59f234", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -262,10 +262,11 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                if len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) {\n-                    DefIdForest::empty()\n-                } else {\n-                    ty.uninhabited_from(visited, tcx)\n+                match len.val.to_const_int().and_then(|i| i.to_u64()) {\n+                    // If the array is definitely non-empty, it's uninhabited if\n+                    // the type of its elements is uninhabited.\n+                    Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),\n+                    _ => DefIdForest::empty()\n                 }\n             }\n             TyRef(_, ref tm) => {"}, {"sha": "eb07876b05f26cb408e9cc86ae7329b42d128401", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -617,8 +617,8 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n     }\n \n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n         let mir: Option<::mir::Mir<'tcx>> = tcx.on_disk_query_result_cache\n                                                .try_load_query_result(tcx, id);\n         mir.map(|x| tcx.alloc_mir(x))\n@@ -637,6 +637,27 @@ impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n+    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n+        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id()))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n+    #[inline]\n+    fn cache_on_disk(def_id: Self::Key) -> bool {\n+        def_id.is_local()\n+    }\n+\n+    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n+        let generics: Option<ty::Generics> = tcx.on_disk_query_result_cache\n+                                                .try_load_query_result(tcx, id);\n+        generics.map(|x| tcx.alloc_generics(x))\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n@@ -662,3 +683,6 @@ impl_disk_cacheable_query!(mir_const_qualif, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(check_match, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(contains_extern_indicator, |_| true);\n impl_disk_cacheable_query!(def_symbol_name, |_| true);\n+impl_disk_cacheable_query!(type_of, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(predicates_of, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(used_trait_imports, |def_id| def_id.is_local());"}, {"sha": "6c79f6a62fa0b3779861edcddbe7bf95b300c89d", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -365,6 +365,9 @@ define_maps! { <'tcx>\n         target_features_whitelist_node(CrateNum) -> Rc<FxHashSet<String>>,\n     [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Rc<Vec<String>>,\n \n+    // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+    [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n+        -> usize,\n }\n \n //////////////////////////////////////////////////////////////////////\n@@ -514,3 +517,10 @@ fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, &'tcx Substs\n fn target_features_whitelist_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::TargetFeaturesWhitelist\n }\n+\n+fn instance_def_size_estimate_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>)\n+                                              -> DepConstructor<'tcx> {\n+    DepConstructor::InstanceDefSizeEstimate {\n+        instance_def\n+    }\n+}"}, {"sha": "56ed0f9106f30d689f08e07eb9e94847f74c3490", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -204,8 +204,12 @@ impl<'sess> OnDiskCache<'sess> {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n \n-                // Encode TypeckTables\n+                encode_query_results::<type_of, _>(tcx, enc, qri)?;\n+                encode_query_results::<generics_of, _>(tcx, enc, qri)?;\n+                encode_query_results::<predicates_of, _>(tcx, enc, qri)?;\n+                encode_query_results::<used_trait_imports, _>(tcx, enc, qri)?;\n                 encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n+                encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n                 encode_query_results::<optimized_mir, _>(tcx, enc, qri)?;\n                 encode_query_results::<unsafety_check_result, _>(tcx, enc, qri)?;\n                 encode_query_results::<borrowck, _>(tcx, enc, qri)?;\n@@ -215,7 +219,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n                 encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n-                encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n             }\n "}, {"sha": "c9eebc3d2a0a723e9f486ced5063d4d54699ae9b", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -761,6 +761,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::EraseRegionsTy |\n         DepKind::NormalizeTy |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n+        DepKind::InstanceDefSizeEstimate |\n \n         // This one should never occur in this context\n         DepKind::Null => {\n@@ -982,4 +983,8 @@ impl_load_from_cache!(\n     ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n     ContainsExternIndicator => contains_extern_indicator,\n     CheckMatch => check_match,\n+    TypeOfItem => type_of,\n+    GenericsOfItem => generics_of,\n+    PredicatesOfItem => predicates_of,\n+    UsedTraitImports => used_trait_imports,\n );"}, {"sha": "63df1179af22828e7eeb26b1f29f5f8e5a9972b2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -17,7 +17,7 @@ pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n-use hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n use hir::svh::Svh;\n use ich::Fingerprint;\n@@ -39,8 +39,8 @@ use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n-use std::collections::BTreeMap;\n use std::cmp;\n+use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n@@ -499,6 +499,20 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n+impl<'tcx> Ord for TyS<'tcx> {\n+    #[inline]\n+    fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n+        // (self as *const _).cmp(other as *const _)\n+        (self as *const TyS<'tcx>).cmp(&(other as *const TyS<'tcx>))\n+    }\n+}\n+impl<'tcx> PartialOrd for TyS<'tcx> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n@@ -568,6 +582,19 @@ impl<T> PartialEq for Slice<T> {\n }\n impl<T> Eq for Slice<T> {}\n \n+impl<T> Ord for Slice<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Slice<T>) -> Ordering {\n+        (&self.0 as *const [T]).cmp(&(&other.0 as *const [T]))\n+    }\n+}\n+impl<T> PartialOrd for Slice<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n impl<T> Hash for Slice<T> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self.as_ptr(), self.len()).hash(s)\n@@ -758,9 +785,8 @@ pub struct Generics {\n     pub regions: Vec<RegionParameterDef>,\n     pub types: Vec<TypeParameterDef>,\n \n-    /// Reverse map to each `TypeParameterDef`'s `index` field, from\n-    /// `def_id.index` (`def_id.krate` is the same as the item's).\n-    pub type_param_to_index: BTreeMap<DefIndex, u32>,\n+    /// Reverse map to each `TypeParameterDef`'s `index` field\n+    pub type_param_to_index: FxHashMap<DefId, u32>,\n \n     pub has_self: bool,\n     pub has_late_bound_regions: Option<Span>,\n@@ -1103,7 +1129,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -2695,6 +2721,20 @@ fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.hir.crate_hash\n }\n \n+fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        instance_def: InstanceDef<'tcx>)\n+                                        -> usize {\n+    match instance_def {\n+        InstanceDef::Item(..) |\n+        InstanceDef::DropGlue(..) => {\n+            let mir = tcx.instance_mir(instance_def);\n+            mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n+        },\n+        // Estimate the size of other compiler-generated shims to be 1.\n+        _ => 1\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n@@ -2712,6 +2752,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         original_crate_name,\n         crate_hash,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n+        instance_def_size_estimate,\n         ..*providers\n     };\n }"}, {"sha": "db7e4fe45ef769d2e523ed3a4e1d2d26c35d1939", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -638,7 +638,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -738,7 +738,7 @@ impl<T> Binder<T> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,"}, {"sha": "7c167f69ebd8c063c504cd9c671437f212a0175c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -29,7 +29,7 @@ use std::mem;\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty` or `Region`) it points to.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZero<usize>,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>"}, {"sha": "2e860f940a7a7b7fa1cbf3fa25d11fe717ada873", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -320,8 +320,8 @@ pub struct TargetOptions {\n     /// Relocation model to use in object file. Corresponds to `llc\n     /// -relocation-model=$relocation_model`. Defaults to \"pic\".\n     pub relocation_model: String,\n-    /// Code model to use. Corresponds to `llc -code-model=$code_model`. Defaults to \"default\".\n-    pub code_model: String,\n+    /// Code model to use. Corresponds to `llc -code-model=$code_model`.\n+    pub code_model: Option<String>,\n     /// TLS model to use. Options are \"global-dynamic\" (default), \"local-dynamic\", \"initial-exec\"\n     /// and \"local-exec\". This is similar to the -ftls-model option in GCC/Clang.\n     pub tls_model: String,\n@@ -483,7 +483,7 @@ impl Default for TargetOptions {\n             only_cdylib: false,\n             executables: false,\n             relocation_model: \"pic\".to_string(),\n-            code_model: \"default\".to_string(),\n+            code_model: None,\n             tls_model: \"global-dynamic\".to_string(),\n             disable_redzone: false,\n             eliminate_frame_pointer: true,\n@@ -736,7 +736,7 @@ impl Target {\n         key!(only_cdylib, bool);\n         key!(executables, bool);\n         key!(relocation_model);\n-        key!(code_model);\n+        key!(code_model, optional);\n         key!(tls_model);\n         key!(disable_redzone, bool);\n         key!(eliminate_frame_pointer, bool);"}, {"sha": "cdb50a0ae48507a90d180fb1b9e32aaaa4f9a4c5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -87,11 +87,11 @@ use std::env;\n use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n+use std::panic;\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n-use std::sync::{Arc, Mutex};\n use std::thread;\n \n use syntax::ast;\n@@ -168,7 +168,7 @@ pub fn run<F>(run_compiler: F) -> isize\n                     handler.emit(&MultiSpan::new(),\n                                  \"aborting due to previous error(s)\",\n                                  errors::Level::Fatal);\n-                    exit_on_err();\n+                    panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n                 }\n             }\n         }\n@@ -1228,27 +1228,16 @@ pub fn in_rustc_thread<F, R>(f: F) -> Result<R, Box<Any + Send>>\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> {\n-            Ok(())\n-        }\n-    }\n-\n-    let data = Arc::new(Mutex::new(Vec::new()));\n-    let err = Sink(data.clone());\n-\n     let result = in_rustc_thread(move || {\n-        io::set_panic(Some(box err));\n         f()\n     });\n \n     if let Err(value) = result {\n         // Thread panicked without emitting a fatal diagnostic\n-        if !value.is::<errors::FatalError>() {\n+        if !value.is::<errors::FatalErrorMarker>() {\n+            // Emit a newline\n+            eprintln!(\"\");\n+\n             let emitter =\n                 Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n                                                                 None,\n@@ -1273,22 +1262,12 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                              &note,\n                              errors::Level::Note);\n             }\n-\n-            eprintln!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n         }\n \n-        exit_on_err();\n+        panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n     }\n }\n \n-fn exit_on_err() -> ! {\n-    // Panic so the process returns a failure code, but don't pollute the\n-    // output with some unnecessary panic messages, we've already\n-    // printed everything that we needed to.\n-    io::set_panic(Some(box io::sink()));\n-    panic!();\n-}\n-\n #[cfg(stage0)]\n pub fn diagnostics_registry() -> errors::registry::Registry {\n     use errors::registry::Registry;"}, {"sha": "2e654fe9929a6af7801755994f0dcc8147c29043", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -27,7 +27,7 @@ pub struct Diagnostic {\n     pub suggestions: Vec<CodeSuggestion>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DiagnosticId {\n     Error(String),\n     Lint(String),\n@@ -281,6 +281,10 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn get_code(&self) -> Option<DiagnosticId> {\n+        self.code.clone()\n+    }\n+\n     pub fn message(&self) -> String {\n         self.message.iter().map(|i| i.0.to_owned()).collect::<String>()\n     }"}, {"sha": "3d50c95d3f4f9857d542155d2518474ca84fcaff", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -19,6 +19,7 @@\n #![cfg_attr(unix, feature(libc))]\n #![feature(conservative_impl_trait)]\n #![feature(i128_type)]\n+#![feature(optin_builtin_traits)]\n \n extern crate term;\n #[cfg(unix)]\n@@ -44,6 +45,7 @@ use std::rc::Rc;\n use std::{error, fmt};\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n+use std::panic;\n \n mod diagnostic;\n mod diagnostic_builder;\n@@ -201,6 +203,18 @@ impl CodeSuggestion {\n #[must_use]\n pub struct FatalError;\n \n+pub struct FatalErrorMarker;\n+\n+// Don't implement Send on FatalError. This makes it impossible to panic!(FatalError).\n+// We don't want to invoke the panic handler and print a backtrace for fatal errors.\n+impl !Send for FatalError {}\n+\n+impl FatalError {\n+    pub fn raise(self) -> ! {\n+        panic::resume_unwind(Box::new(FatalErrorMarker))\n+    }\n+}\n+\n impl fmt::Display for FatalError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         write!(f, \"parser fatal error\")\n@@ -245,6 +259,11 @@ pub struct Handler {\n     delayed_span_bug: RefCell<Option<Diagnostic>>,\n     tracked_diagnostics: RefCell<Option<Vec<Diagnostic>>>,\n \n+    // This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n+    // emitting the same diagnostic with extended help (`--teach`) twice, which\n+    // would be uneccessary repetition.\n+    tracked_diagnostic_codes: RefCell<FxHashSet<DiagnosticId>>,\n+\n     // This set contains a hash of every diagnostic that has been emitted by\n     // this handler. These hashes is used to avoid emitting the same error\n     // twice.\n@@ -303,6 +322,7 @@ impl Handler {\n             continue_after_error: Cell::new(true),\n             delayed_span_bug: RefCell::new(None),\n             tracked_diagnostics: RefCell::new(None),\n+            tracked_diagnostic_codes: RefCell::new(FxHashSet()),\n             emitted_diagnostics: RefCell::new(FxHashSet()),\n         }\n     }\n@@ -539,7 +559,7 @@ impl Handler {\n             }\n         }\n \n-        panic!(self.fatal(&s));\n+        self.fatal(&s).raise();\n     }\n     pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n         if lvl == Warning && !self.flags.can_emit_warnings {\n@@ -575,13 +595,25 @@ impl Handler {\n         (ret, diagnostics)\n     }\n \n+    /// `true` if a diagnostic with this code has already been emitted in this handler.\n+    ///\n+    /// Used to suppress emitting the same error multiple times with extended explanation when\n+    /// calling `-Zteach`.\n+    pub fn code_emitted(&self, code: &DiagnosticId) -> bool {\n+        self.tracked_diagnostic_codes.borrow().contains(code)\n+    }\n+\n     fn emit_db(&self, db: &DiagnosticBuilder) {\n         let diagnostic = &**db;\n \n         if let Some(ref mut list) = *self.tracked_diagnostics.borrow_mut() {\n             list.push(diagnostic.clone());\n         }\n \n+        if let Some(ref code) = diagnostic.code {\n+            self.tracked_diagnostic_codes.borrow_mut().insert(code.clone());\n+        }\n+\n         let diagnostic_hash = {\n             use std::hash::Hash;\n             let mut hasher = StableHasher::new();"}, {"sha": "99e43a2ddf98de52b09d71522557ca59e06d693c", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -299,12 +299,11 @@ pub enum RelocMode {\n #[repr(C)]\n pub enum CodeModel {\n     Other,\n-    Default,\n-    JITDefault,\n     Small,\n     Kernel,\n     Medium,\n     Large,\n+    None,\n }\n \n /// LLVMRustDiagnosticKind\n@@ -331,7 +330,6 @@ pub enum DiagnosticKind {\n pub enum ArchiveKind {\n     Other,\n     K_GNU,\n-    K_MIPS64,\n     K_BSD,\n     K_COFF,\n }\n@@ -498,6 +496,10 @@ pub mod debuginfo {\n             const FlagStaticMember        = (1 << 12);\n             const FlagLValueReference     = (1 << 13);\n             const FlagRValueReference     = (1 << 14);\n+            const FlagExternalTypeRef     = (1 << 15);\n+            const FlagIntroducedVirtual   = (1 << 18);\n+            const FlagBitField            = (1 << 19);\n+            const FlagNoReturn            = (1 << 20);\n             const FlagMainSubprogram      = (1 << 21);\n         }\n     }"}, {"sha": "8dcf7444dd18f919c59026bf1179d2a94f5e869b", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -105,7 +105,6 @@ impl FromStr for ArchiveKind {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         match s {\n             \"gnu\" => Ok(ArchiveKind::K_GNU),\n-            \"mips64\" => Ok(ArchiveKind::K_MIPS64),\n             \"bsd\" => Ok(ArchiveKind::K_BSD),\n             \"coff\" => Ok(ArchiveKind::K_COFF),\n             _ => Err(()),"}, {"sha": "9dcd4435580ab71723e38699e114411c620ac523", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -681,6 +681,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         let data = self.infcx.take_and_reset_region_constraints();\n         if !data.is_empty() {\n+            debug!(\"fully_perform_op: constraints generated at {:?} are {:#?}\",\n+                   locations, data);\n             self.constraints\n                 .outlives_sets\n                 .push(OutlivesSet { locations, data });\n@@ -1539,6 +1541,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n+        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         self.fully_perform_op(location.at_self(), |this| {\n             let mut selcx = traits::SelectionContext::new(this.infcx);\n             let cause = this.misc(this.last_span);"}, {"sha": "806d787c84522601c69c4a56fde4acbc7f547ba4", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -115,6 +115,7 @@ use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use rustc::mir::mono::MonoItem;\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n+use core::usize;\n \n pub use rustc::mir::mono::CodegenUnit;\n \n@@ -224,6 +225,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(tcx,\n                                                                 trans_items);\n \n+    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n+\n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n@@ -241,6 +244,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                             inlining_map);\n \n+    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n+\n     debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n@@ -422,14 +427,13 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     codegen_units.sort_by_key(|cgu| cgu.name().clone());\n \n     // Merge the two smallest codegen units until the target size is reached.\n-    // Note that \"size\" is estimated here rather inaccurately as the number of\n-    // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n-        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as i64));\n+        codegen_units.sort_by_key(|cgu| usize::MAX - cgu.size_estimate());\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n         for (k, v) in smallest.items_mut().drain() {\n             second_smallest.items_mut().insert(k, v);\n         }"}, {"sha": "6971033c8994b97afb28085257c269afabd0f4d7", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -141,14 +141,6 @@ impl<'a> AstValidator<'a> {\n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n-            ExprKind::While(.., Some(ident)) |\n-            ExprKind::Loop(_, Some(ident)) |\n-            ExprKind::WhileLet(.., Some(ident)) |\n-            ExprKind::ForLoop(.., Some(ident)) |\n-            ExprKind::Break(Some(ident), _) |\n-            ExprKind::Continue(Some(ident)) => {\n-                self.check_label(ident.node, ident.span);\n-            }\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n             }\n@@ -211,6 +203,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n+    fn visit_label(&mut self, label: &'a Label) {\n+        self.check_label(label.ident, label.span);\n+        visit::walk_label(self, label);\n+    }\n+\n     fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n         self.check_lifetime(lifetime);\n         visit::walk_lifetime(self, lifetime);"}, {"sha": "557ff887a3ef283c205ac6b8a4421b61f435c811", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -55,7 +55,7 @@ use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParam, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n-use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n+use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n use syntax::parse::token;\n@@ -2045,7 +2045,7 @@ impl<'a> Resolver<'a> {\n                     segments: vec![],\n                     span: use_tree.span,\n                 };\n-                self.resolve_use_tree(item, use_tree, &path);\n+                self.resolve_use_tree(item.id, use_tree, &path);\n             }\n \n             ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_) => {\n@@ -2056,7 +2056,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_use_tree(&mut self, item: &Item, use_tree: &ast::UseTree, prefix: &Path) {\n+    fn resolve_use_tree(&mut self, id: NodeId, use_tree: &ast::UseTree, prefix: &Path) {\n         match use_tree.kind {\n             ast::UseTreeKind::Nested(ref items) => {\n                 let path = Path {\n@@ -2070,10 +2070,10 @@ impl<'a> Resolver<'a> {\n \n                 if items.len() == 0 {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n-                    self.smart_resolve_path(item.id, None, &path, PathSource::ImportPrefix);\n+                    self.smart_resolve_path(id, None, &path, PathSource::ImportPrefix);\n                 } else {\n-                    for &(ref tree, _) in items {\n-                        self.resolve_use_tree(item, tree, &path);\n+                    for &(ref tree, nested_id) in items {\n+                        self.resolve_use_tree(nested_id, tree, &path);\n                     }\n                 }\n             }\n@@ -3415,21 +3415,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)\n+    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n-                this.label_ribs.last_mut().unwrap().bindings.insert(label.node, def);\n+                this.label_ribs.last_mut().unwrap().bindings.insert(label.ident, def);\n                 f(this);\n             });\n         } else {\n             f(self);\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n@@ -3452,19 +3452,19 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.node, |rib, id| rib.bindings.get(&id).cloned()) {\n+                match self.search_label(label.ident, |rib, id| rib.bindings.get(&id).cloned()) {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n                         // the closest match\n-                        let close_match = self.search_label(label.node, |rib, ident| {\n+                        let close_match = self.search_label(label.ident, |rib, ident| {\n                             let names = rib.bindings.iter().map(|(id, _)| &id.name);\n                             find_best_match_for_name(names, &*ident.name.as_str(), None)\n                         });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str(),\n+                                      ResolutionError::UndeclaredLabel(&label.ident.name.as_str(),\n                                                                        close_match));\n                     }\n                     Some(def @ Def::Label(_)) => {"}, {"sha": "9cabd9356e9bfe17b8c55554a6c664126d774aed", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -871,6 +871,31 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n                 match arg.layout.abi {\n                     layout::Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    layout::Abi::Vector { .. } if abi != Abi::PlatformIntrinsic => {\n+                        arg.make_indirect();\n+                        return\n+                    }\n+\n                     _ => return\n                 }\n "}, {"sha": "f050edcd513b918167fd49355050327a64716b8e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -16,7 +16,7 @@ use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::RUST_CGU_EXT;\n+use rustc::session::config::{RUST_CGU_EXT, Lto};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n@@ -503,7 +503,8 @@ fn link_staticlib(sess: &Session,\n         });\n         ab.add_rlib(path,\n                     &name.as_str(),\n-                    sess.lto() && !ignored_for_lto(sess, &trans.crate_info, cnum),\n+                    is_full_lto_enabled(sess) &&\n+                        !ignored_for_lto(sess, &trans.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n         all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -1211,7 +1212,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if (!sess.lto() || ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n+        if (!is_full_lto_enabled(sess) ||\n+            ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1264,7 +1266,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                let skip_because_lto = sess.lto() &&\n+                let skip_because_lto = is_full_lto_enabled(sess) &&\n                     is_rust_object &&\n                     (sess.target.target.options.no_builtins ||\n                      !trans.crate_info.is_no_builtins.contains(&cnum));\n@@ -1301,7 +1303,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     fn add_dynamic_crate(cmd: &mut Linker, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n-        assert!(!sess.lto());\n+        assert!(!is_full_lto_enabled(sess));\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n@@ -1409,3 +1411,13 @@ fn link_binaryen(sess: &Session,\n                             e));\n     }\n }\n+\n+fn is_full_lto_enabled(sess: &Session) -> bool {\n+    match sess.lto() {\n+        Lto::Yes |\n+        Lto::Thin |\n+        Lto::Fat => true,\n+        Lto::No |\n+        Lto::ThinLocal => false,\n+    }\n+}"}, {"sha": "9ff5bcf7a33caaa5772aaf8e822ef673e6e6f281", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -18,7 +18,7 @@ use llvm::{ModuleRef, TargetMachineRef, True, False};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n-use rustc::session::config;\n+use rustc::session::config::{self, Lto};\n use rustc::util::common::time;\n use time_graph::Timeline;\n use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n@@ -95,25 +95,22 @@ impl LtoModuleTranslation {\n     }\n }\n \n-pub enum LTOMode {\n-    WholeCrateGraph,\n-    JustThisCrate,\n-}\n-\n pub(crate) fn run(cgcx: &CodegenContext,\n-           modules: Vec<ModuleTranslation>,\n-           mode: LTOMode,\n-           timeline: &mut Timeline)\n+                  modules: Vec<ModuleTranslation>,\n+                  timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    let export_threshold = match mode {\n-        LTOMode::WholeCrateGraph => {\n+    let export_threshold = match cgcx.lto {\n+        // We're just doing LTO for our one crate\n+        Lto::ThinLocal => SymbolExportLevel::Rust,\n+\n+        // We're doing LTO for the entire crate graph\n+        Lto::Yes | Lto::Fat | Lto::Thin => {\n             symbol_export::crates_export_threshold(&cgcx.crate_types)\n         }\n-        LTOMode::JustThisCrate => {\n-            SymbolExportLevel::Rust\n-        }\n+\n+        Lto::No => panic!(\"didn't request LTO but we're doing LTO\"),\n     };\n \n     let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n@@ -140,7 +137,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n     // We save off all the bytecode and LLVM module ids for later processing\n     // with either fat or thin LTO\n     let mut upstream_modules = Vec::new();\n-    if let LTOMode::WholeCrateGraph = mode {\n+    if cgcx.lto != Lto::ThinLocal {\n         if cgcx.opts.cg.prefer_dynamic {\n             diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n                         .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n@@ -186,13 +183,16 @@ pub(crate) fn run(cgcx: &CodegenContext,\n     }\n \n     let arr = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n-    match mode {\n-        LTOMode::WholeCrateGraph if !cgcx.thinlto => {\n+    match cgcx.lto {\n+        Lto::Yes | // `-C lto` == fat LTO by default\n+        Lto::Fat => {\n             fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr, timeline)\n         }\n-        _ => {\n+        Lto::Thin |\n+        Lto::ThinLocal => {\n             thin_lto(&diag_handler, modules, upstream_modules, &arr, timeline)\n         }\n+        Lto::No => unreachable!(),\n     }\n }\n "}, {"sha": "8afa63a5e9735e113bceac783870cdca3d54d91f", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 123, "deletions": 114, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -11,15 +11,16 @@\n use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n use back::lto::{self, ModuleBuffer, ThinBuffer};\n use back::link::{self, get_linker, remove};\n+use back::command::Command;\n use back::linker::LinkerInfo;\n use back::symbol_export::ExportedSymbols;\n use base;\n use consts;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::dep_graph::{DepGraph, WorkProductFileKind};\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n-use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n-                             AllPasses, Sanitizer};\n+use rustc::session::config::{self, OutputFilenames, OutputType, Passes, SomePasses,\n+                             AllPasses, Sanitizer, Lto};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc_back::LinkerFlavor;\n@@ -32,7 +33,7 @@ use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n-use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n+use rustc::util::fs::{link_or_copy};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use errors::emitter::{Emitter};\n use syntax::attr;\n@@ -68,8 +69,7 @@ pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n     (\"ropi-rwpi\", llvm::RelocMode::ROPI_RWPI),\n ];\n \n-pub const CODE_GEN_MODEL_ARGS : [(&'static str, llvm::CodeModel); 5] = [\n-    (\"default\", llvm::CodeModel::Default),\n+pub const CODE_GEN_MODEL_ARGS: &[(&str, llvm::CodeModel)] = &[\n     (\"small\", llvm::CodeModel::Small),\n     (\"kernel\", llvm::CodeModel::Kernel),\n     (\"medium\", llvm::CodeModel::Medium),\n@@ -155,7 +155,7 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n \n pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     target_machine_factory(sess)().unwrap_or_else(|err| {\n-        panic!(llvm_err(sess.diagnostic(), err))\n+        llvm_err(sess.diagnostic(), err).raise()\n     })\n }\n \n@@ -170,20 +170,23 @@ pub fn target_machine_factory(sess: &Session)\n     let ffunction_sections = sess.target.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n-    let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => &s,\n-        None => &sess.target.target.options.code_model,\n-    };\n-\n-    let code_model = match CODE_GEN_MODEL_ARGS.iter().find(\n-        |&&arg| arg.0 == code_model_arg) {\n-        Some(x) => x.1,\n-        _ => {\n-            sess.err(&format!(\"{:?} is not a valid code model\",\n-                              code_model_arg));\n-            sess.abort_if_errors();\n-            bug!();\n+    let code_model_arg = sess.opts.cg.code_model.as_ref().or(\n+        sess.target.target.options.code_model.as_ref(),\n+    );\n+\n+    let code_model = match code_model_arg {\n+        Some(s) => {\n+            match CODE_GEN_MODEL_ARGS.iter().find(|arg| arg.0 == s) {\n+                Some(x) => x.1,\n+                _ => {\n+                    sess.err(&format!(\"{:?} is not a valid code model\",\n+                                      code_model_arg));\n+                    sess.abort_if_errors();\n+                    bug!();\n+                }\n+            }\n         }\n+        None => llvm::CodeModel::None,\n     };\n \n     let singlethread = sess.target.target.options.singlethread;\n@@ -258,6 +261,7 @@ pub struct ModuleConfig {\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n     obj_is_bitcode: bool,\n+    no_integrated_as: bool,\n }\n \n impl ModuleConfig {\n@@ -275,6 +279,7 @@ impl ModuleConfig {\n             emit_asm: false,\n             emit_obj: false,\n             obj_is_bitcode: false,\n+            no_integrated_as: false,\n \n             no_verify: false,\n             no_prepopulate_passes: false,\n@@ -313,13 +318,18 @@ impl ModuleConfig {\n     }\n }\n \n+/// Assembler name and command used by codegen when no_integrated_as is enabled\n+struct AssemblerCommand {\n+    name: PathBuf,\n+    cmd: Command,\n+}\n+\n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n-    pub lto: bool,\n-    pub thinlto: bool,\n+    pub lto: Lto,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub fewer_names: bool,\n@@ -356,6 +366,8 @@ pub struct CodegenContext {\n     // A reference to the TimeGraph so we can register timings. None means that\n     // measuring is disabled.\n     time_graph: Option<TimeGraph>,\n+    // The assembler command if no_integrated_as option is enabled, None otherwise\n+    assembler_cmd: Option<Arc<AssemblerCommand>>,\n }\n \n impl CodegenContext {\n@@ -576,13 +588,8 @@ fn generate_lto_work(cgcx: &CodegenContext,\n                  TRANS_WORK_PACKAGE_KIND,\n                  \"generate lto\")\n     }).unwrap_or(Timeline::noop());\n-    let mode = if cgcx.lto {\n-        lto::LTOMode::WholeCrateGraph\n-    } else {\n-        lto::LTOMode::JustThisCrate\n-    };\n-    let lto_modules = lto::run(cgcx, modules, mode, &mut timeline)\n-        .unwrap_or_else(|e| panic!(e));\n+    let lto_modules = lto::run(cgcx, modules, &mut timeline)\n+        .unwrap_or_else(|e| e.raise());\n \n     lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n@@ -639,13 +646,17 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         !cgcx.crate_types.contains(&config::CrateTypeRlib) &&\n         mtrans.kind == ModuleKind::Regular;\n \n+    // If we don't have the integrated assembler, then we need to emit asm\n+    // from LLVM and use `gcc` to create the object file.\n+    let asm_to_obj = config.emit_obj && config.no_integrated_as;\n+\n     // Change what we write and cleanup based on whether obj files are\n     // just llvm bitcode. In that case write bitcode, and possibly\n     // delete the bitcode if it wasn't requested. Don't generate the\n     // machine code, instead copy the .o file from the .bc\n     let write_bc = config.emit_bc || (config.obj_is_bitcode && !asm2wasm);\n     let rm_bc = !config.emit_bc && config.obj_is_bitcode && !asm2wasm;\n-    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm2wasm;\n+    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm2wasm && !asm_to_obj;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode && !asm2wasm;\n \n     let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n@@ -725,13 +736,13 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             timeline.record(\"ir\");\n         }\n \n-        if config.emit_asm || (asm2wasm && config.emit_obj) {\n+        if config.emit_asm || (asm2wasm && config.emit_obj) || asm_to_obj {\n             let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n             // module to produce the asm output\n-            let llmod = if config.emit_obj {\n+            let llmod = if config.emit_obj && !asm2wasm {\n                 llvm::LLVMCloneModule(llmod)\n             } else {\n                 llmod\n@@ -740,7 +751,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                 write_output_file(diag_handler, tm, cpm, llmod, &path,\n                                   llvm::FileType::AssemblyFile)\n             })?;\n-            if config.emit_obj {\n+            if config.emit_obj && !asm2wasm {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n             timeline.record(\"asm\");\n@@ -760,6 +771,14 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                                   llvm::FileType::ObjectFile)\n             })?;\n             timeline.record(\"obj\");\n+        } else if asm_to_obj {\n+            let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+            run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+            timeline.record(\"asm_to_obj\");\n+\n+            if !config.emit_asm && !cgcx.save_temps {\n+                drop(fs::remove_file(&assembly));\n+            }\n         }\n \n         Ok(())\n@@ -841,7 +860,6 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                total_cgus: usize)\n                                -> OngoingCrateTranslation {\n     let sess = tcx.sess;\n-    let crate_output = tcx.output_filenames(LOCAL_CRATE);\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n     let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n@@ -855,19 +873,9 @@ pub fn start_async_translation(tcx: TyCtxt,\n         subsystem.to_string()\n     });\n \n-    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n-        (tcx.sess.target.target.options.no_integrated_as &&\n-         (crate_output.outputs.contains_key(&OutputType::Object) ||\n-          crate_output.outputs.contains_key(&OutputType::Exe)));\n     let linker_info = LinkerInfo::new(tcx);\n     let crate_info = CrateInfo::new(tcx);\n \n-    let output_types_override = if no_integrated_as {\n-        OutputTypes::new(&[(OutputType::Assembly, None)])\n-    } else {\n-        sess.opts.output_types.clone()\n-    };\n-\n     // Figure out what we actually need to build.\n     let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n     let mut metadata_config = ModuleConfig::new(vec![]);\n@@ -913,7 +921,10 @@ pub fn start_async_translation(tcx: TyCtxt,\n         allocator_config.emit_bc_compressed = true;\n     }\n \n-    for output_type in output_types_override.keys() {\n+    modules_config.no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n+        tcx.sess.target.target.options.no_integrated_as;\n+\n+    for output_type in sess.opts.output_types.keys() {\n         match *output_type {\n             OutputType::Bitcode => { modules_config.emit_bc = true; }\n             OutputType::LlvmAssembly => { modules_config.emit_ir = true; }\n@@ -976,7 +987,6 @@ pub fn start_async_translation(tcx: TyCtxt,\n         metadata,\n         windows_subsystem,\n         linker_info,\n-        no_integrated_as,\n         crate_info,\n \n         time_graph,\n@@ -1280,28 +1290,51 @@ fn execute_work_item(cgcx: &CodegenContext,\n         unsafe {\n             optimize(cgcx, &diag_handler, &mtrans, config, timeline)?;\n \n-            let lto = cgcx.lto;\n+            // After we've done the initial round of optimizations we need to\n+            // decide whether to synchronously codegen this module or ship it\n+            // back to the coordinator thread for further LTO processing (which\n+            // has to wait for all the initial modules to be optimized).\n+            //\n+            // Here we dispatch based on the `cgcx.lto` and kind of module we're\n+            // translating...\n+            let needs_lto = match cgcx.lto {\n+                Lto::No => false,\n+\n+                // Here we've got a full crate graph LTO requested. We ignore\n+                // this, however, if the crate type is only an rlib as there's\n+                // no full crate graph to process, that'll happen later.\n+                //\n+                // This use case currently comes up primarily for targets that\n+                // require LTO so the request for LTO is always unconditionally\n+                // passed down to the backend, but we don't actually want to do\n+                // anything about it yet until we've got a final product.\n+                Lto::Yes | Lto::Fat | Lto::Thin => {\n+                    cgcx.crate_types.len() != 1 ||\n+                        cgcx.crate_types[0] != config::CrateTypeRlib\n+                }\n \n-            let auto_thin_lto =\n-                cgcx.thinlto &&\n-                cgcx.total_cgus > 1 &&\n-                mtrans.kind != ModuleKind::Allocator;\n+                // When we're automatically doing ThinLTO for multi-codegen-unit\n+                // builds we don't actually want to LTO the allocator modules if\n+                // it shows up. This is due to various linker shenanigans that\n+                // we'll encounter later.\n+                //\n+                // Additionally here's where we also factor in the current LLVM\n+                // version. If it doesn't support ThinLTO we skip this.\n+                Lto::ThinLocal => {\n+                    mtrans.kind != ModuleKind::Allocator &&\n+                        llvm::LLVMRustThinLTOAvailable()\n+                }\n+            };\n \n-            // If we're a metadata module we never participate in LTO.\n-            //\n-            // If LTO was explicitly requested on the command line, we always\n-            // LTO everything else.\n-            //\n-            // If LTO *wasn't* explicitly requested and we're not a metdata\n-            // module, then we may automatically do ThinLTO if we've got\n-            // multiple codegen units. Note, however, that the allocator module\n-            // doesn't participate here automatically because of linker\n-            // shenanigans later on.\n-            if mtrans.kind == ModuleKind::Metadata || (!lto && !auto_thin_lto) {\n+            // Metadata modules never participate in LTO regardless of the lto\n+            // settings.\n+            let needs_lto = needs_lto && mtrans.kind != ModuleKind::Metadata;\n+\n+            if needs_lto {\n+                Ok(WorkItemResult::NeedsLTO(mtrans))\n+            } else {\n                 let module = codegen(cgcx, &diag_handler, mtrans, config, timeline)?;\n                 Ok(WorkItemResult::Compiled(module))\n-            } else {\n-                Ok(WorkItemResult::NeedsLTO(mtrans))\n             }\n         }\n     }\n@@ -1377,28 +1410,25 @@ fn start_executing_work(tcx: TyCtxt,\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n-    let crate_types = sess.crate_types.borrow();\n-    let only_rlib = crate_types.len() == 1 &&\n-        crate_types[0] == config::CrateTypeRlib;\n-\n     let wasm_import_memory =\n         attr::contains_name(&tcx.hir.krate().attrs, \"wasm_import_memory\");\n \n+    let assembler_cmd = if modules_config.no_integrated_as {\n+        // HACK: currently we use linker (gcc) as our assembler\n+        let (name, mut cmd, _) = get_linker(sess);\n+        cmd.args(&sess.target.target.options.asm_args);\n+        Some(Arc::new(AssemblerCommand {\n+            name,\n+            cmd,\n+        }))\n+    } else {\n+        None\n+    };\n+\n     let cgcx = CodegenContext {\n         crate_types: sess.crate_types.borrow().clone(),\n         each_linked_rlib_for_lto,\n-        // If we're only building an rlibc then allow the LTO flag to be passed\n-        // but don't actually do anything, the full LTO will happen later\n-        lto: sess.lto() && !only_rlib,\n-\n-        // Enable ThinLTO if requested, but only if the target we're compiling\n-        // for doesn't require full LTO. Some targets require one LLVM module\n-        // (they effectively don't have a linker) so it's up to us to use LTO to\n-        // link everything together.\n-        thinlto: sess.thinlto() &&\n-            !sess.target.target.options.requires_lto &&\n-            unsafe { llvm::LLVMRustThinLTOAvailable() },\n-\n+        lto: sess.lto(),\n         no_landing_pads: sess.no_landing_pads(),\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,\n@@ -1423,6 +1453,7 @@ fn start_executing_work(tcx: TyCtxt,\n         binaryen_linker: tcx.sess.linker_flavor() == LinkerFlavor::Binaryen,\n         debuginfo: tcx.sess.opts.debuginfo,\n         wasm_import_memory: wasm_import_memory,\n+        assembler_cmd,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1931,15 +1962,14 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n     });\n }\n \n-pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-    let (pname, mut cmd, _) = get_linker(sess);\n-\n-    for arg in &sess.target.target.options.asm_args {\n-        cmd.arg(arg);\n-    }\n+pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path, object: &Path) {\n+    let assembler = cgcx.assembler_cmd\n+        .as_ref()\n+        .expect(\"cgcx.assembler_cmd is missing?\");\n \n-    cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n-                           .arg(&outputs.temp_path(OutputType::Assembly, None));\n+    let pname = &assembler.name;\n+    let mut cmd = assembler.cmd.clone();\n+    cmd.arg(\"-c\").arg(\"-o\").arg(object).arg(assembly);\n     debug!(\"{:?}\", cmd);\n \n     match cmd.output() {\n@@ -1948,18 +1978,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n                 let mut note = prog.stderr.clone();\n                 note.extend_from_slice(&prog.stdout);\n \n-                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname.display(),\n-                                         prog.status))\n+                handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                            pname.display(),\n+                                            prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n                     .note(str::from_utf8(&note[..]).unwrap())\n                     .emit();\n-                sess.abort_if_errors();\n+                handler.abort_if_errors();\n             }\n         },\n         Err(e) => {\n-            sess.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n-            sess.abort_if_errors();\n+            handler.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n+            handler.abort_if_errors();\n         }\n     }\n }\n@@ -2133,7 +2163,6 @@ pub struct OngoingCrateTranslation {\n     metadata: EncodedMetadata,\n     windows_subsystem: Option<String>,\n     linker_info: LinkerInfo,\n-    no_integrated_as: bool,\n     crate_info: CrateInfo,\n     time_graph: Option<TimeGraph>,\n     coordinator_send: Sender<Box<Any + Send>>,\n@@ -2189,26 +2218,6 @@ impl OngoingCrateTranslation {\n             metadata_module: compiled_modules.metadata_module,\n         };\n \n-        if self.no_integrated_as {\n-            run_assembler(sess,  &self.output_filenames);\n-\n-            // HACK the linker expects the object file to be named foo.0.o but\n-            // `run_assembler` produces an object named just foo.o. Rename it if we\n-            // are going to build an executable\n-            if sess.opts.output_types.contains_key(&OutputType::Exe) {\n-                let f =  self.output_filenames.path(OutputType::Object);\n-                rename_or_copy_remove(&f,\n-                    f.with_file_name(format!(\"{}.0.o\",\n-                                             f.file_stem().unwrap().to_string_lossy()))).unwrap();\n-            }\n-\n-            // Remove assembly source, unless --save-temps was specified\n-            if !sess.opts.cg.save_temps {\n-                fs::remove_file(&self.output_filenames\n-                                     .temp_path(OutputType::Assembly, None)).unwrap();\n-            }\n-        }\n-\n         trans\n     }\n "}, {"sha": "466a86e7ea5584d221eb13e17d71ca043d3ab09f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -78,7 +78,7 @@ use std::ffi::CString;\n use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n-use std::i32;\n+use std::{i32, usize};\n use std::iter;\n use std::sync::mpsc;\n use syntax_pos::Span;\n@@ -823,12 +823,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n \n     // We sort the codegen units by size. This way we can schedule work for LLVM\n-    // a bit more efficiently. Note that \"size\" is defined rather crudely at the\n-    // moment as it is just the number of TransItems in the CGU, not taking into\n-    // account the size of each TransItem.\n+    // a bit more efficiently.\n     let codegen_units = {\n         let mut codegen_units = codegen_units;\n-        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as isize));\n+        codegen_units.sort_by_key(|cgu| usize::MAX - cgu.size_estimate());\n         codegen_units\n     };\n "}, {"sha": "62bac8469ce4bc75dddc20482c6a93d0047a8dd1", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 79, "deletions": 87, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -16,9 +16,11 @@ use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout, Size};\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+/// Classification of \"eightbyte\" components.\n+// NB: the order of the variants is from general to specific,\n+// such that `unify(a, b)` is the \"smaller\" of `a` and `b`.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n enum Class {\n-    None,\n     Int,\n     Sse,\n     SseUp\n@@ -32,29 +34,10 @@ const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n-                          -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n-    fn unify(cls: &mut [Class],\n-             off: Size,\n-             c: Class) {\n-        let i = (off.bytes() / 8) as usize;\n-        let to_write = match (cls[i], c) {\n-            (Class::None, _) => c,\n-            (_, Class::None) => return,\n-\n-            (Class::Int, _) |\n-            (_, Class::Int) => Class::Int,\n-\n-            (Class::Sse, _) |\n-            (_, Class::Sse) => Class::Sse,\n-\n-            (Class::SseUp, Class::SseUp) => Class::SseUp\n-        };\n-        cls[i] = to_write;\n-    }\n-\n+                          -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory> {\n     fn classify<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n-                          cls: &mut [Class],\n+                          cls: &mut [Option<Class>],\n                           off: Size)\n                           -> Result<(), Memory> {\n         if !off.is_abi_aligned(layout.align) {\n@@ -64,31 +47,20 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n             return Ok(());\n         }\n \n-        match layout.abi {\n-            layout::Abi::Uninhabited => {}\n+        let mut c = match layout.abi {\n+            layout::Abi::Uninhabited => return Ok(()),\n \n             layout::Abi::Scalar(ref scalar) => {\n-                let reg = match scalar.value {\n+                match scalar.value {\n                     layout::Int(..) |\n                     layout::Pointer => Class::Int,\n                     layout::F32 |\n                     layout::F64 => Class::Sse\n-                };\n-                unify(cls, off, reg);\n-            }\n-\n-            layout::Abi::Vector { ref element, count } => {\n-                unify(cls, off, Class::Sse);\n-\n-                // everything after the first one is the upper\n-                // half of a register.\n-                let stride = element.value.size(cx);\n-                for i in 1..count {\n-                    let field_off = off + stride * i;\n-                    unify(cls, field_off, Class::SseUp);\n                 }\n             }\n \n+            layout::Abi::Vector { .. } => Class::Sse,\n+\n             layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => {\n                 match layout.variants {\n@@ -97,12 +69,26 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                             let field_off = off + layout.fields.offset(i);\n                             classify(cx, layout.field(cx, i), cls, field_off)?;\n                         }\n+                        return Ok(());\n                     }\n                     layout::Variants::Tagged { .. } |\n                     layout::Variants::NicheFilling { .. } => return Err(Memory),\n                 }\n             }\n \n+        };\n+\n+        // Fill in `cls` for scalars (Int/Sse) and vectors (Sse).\n+        let first = (off.bytes() / 8) as usize;\n+        let last = ((off.bytes() + layout.size.bytes() - 1) / 8) as usize;\n+        for cls in &mut cls[first..=last] {\n+            *cls = Some(cls.map_or(c, |old| old.min(c)));\n+\n+            // Everything after the first Sse \"eightbyte\"\n+            // component is the upper half of a register.\n+            if c == Class::Sse {\n+                c = Class::SseUp;\n+            }\n         }\n \n         Ok(())\n@@ -113,23 +99,23 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n         return Err(Memory);\n     }\n \n-    let mut cls = [Class::None; MAX_EIGHTBYTES];\n+    let mut cls = [None; MAX_EIGHTBYTES];\n     classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n-        if cls[0] != Class::Sse {\n+        if cls[0] != Some(Class::Sse) {\n             return Err(Memory);\n         }\n-        if cls[1..n].iter().any(|&c| c != Class::SseUp) {\n+        if cls[1..n].iter().any(|&c| c != Some(Class::SseUp)) {\n             return Err(Memory);\n         }\n     } else {\n         let mut i = 0;\n         while i < n {\n-            if cls[i] == Class::SseUp {\n-                cls[i] = Class::Sse;\n-            } else if cls[i] == Class::Sse {\n+            if cls[i] == Some(Class::SseUp) {\n+                cls[i] = Some(Class::Sse);\n+            } else if cls[i] == Some(Class::Sse) {\n                 i += 1;\n-                while i != n && cls[i] == Class::SseUp { i += 1; }\n+                while i != n && cls[i] == Some(Class::SseUp) { i += 1; }\n             } else {\n                 i += 1;\n             }\n@@ -139,14 +125,14 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n     Ok(cls)\n }\n \n-fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n+fn reg_component(cls: &[Option<Class>], i: &mut usize, size: Size) -> Option<Reg> {\n     if *i >= cls.len() {\n         return None;\n     }\n \n     match cls[*i] {\n-        Class::None => None,\n-        Class::Int => {\n+        None => None,\n+        Some(Class::Int) => {\n             *i += 1;\n             Some(match size.bytes() {\n                 1 => Reg::i8(),\n@@ -156,8 +142,10 @@ fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n                 _ => Reg::i64()\n             })\n         }\n-        Class::Sse => {\n-            let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n+        Some(Class::Sse) => {\n+            let vec_len = 1 + cls[*i+1..].iter()\n+                .take_while(|&&c| c == Some(Class::SseUp))\n+                .count();\n             *i += vec_len;\n             Some(if vec_len == 1 {\n                 match size.bytes() {\n@@ -171,20 +159,20 @@ fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n                 }\n             })\n         }\n-        c => bug!(\"reg_component: unhandled class {:?}\", c)\n+        Some(c) => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n }\n \n-fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n+fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     let mut i = 0;\n     let lo = reg_component(cls, &mut i, size).unwrap();\n     let offset = Size::from_bytes(8) * (i as u64);\n-    let target = if size <= offset {\n-        CastTarget::from(lo)\n-    } else {\n-        let hi = reg_component(cls, &mut i, size - offset).unwrap();\n-        CastTarget::Pair(lo, hi)\n-    };\n+    let mut target = CastTarget::from(lo);\n+    if size > offset {\n+        if let Some(hi) = reg_component(cls, &mut i, size - offset) {\n+            target = CastTarget::Pair(lo, hi);\n+        }\n+    }\n     assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);\n     target\n }\n@@ -194,44 +182,48 @@ pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tc\n     let mut sse_regs = 8; // XMM0-7\n \n     let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n-        let cls = classify_arg(cx, arg);\n+        let mut cls_or_mem = classify_arg(cx, arg);\n \n         let mut needed_int = 0;\n         let mut needed_sse = 0;\n-        let in_mem = match cls {\n-            Err(Memory) => true,\n-            Ok(ref cls) if is_arg => {\n-                for &c in cls {\n+        if is_arg {\n+            if let Ok(cls) = cls_or_mem {\n+                for &c in &cls {\n                     match c {\n-                        Class::Int => needed_int += 1,\n-                        Class::Sse => needed_sse += 1,\n+                        Some(Class::Int) => needed_int += 1,\n+                        Some(Class::Sse) => needed_sse += 1,\n                         _ => {}\n                     }\n                 }\n-                arg.layout.is_aggregate() &&\n-                    (int_regs < needed_int || sse_regs < needed_sse)\n+                if arg.layout.is_aggregate() {\n+                    if int_regs < needed_int || sse_regs < needed_sse {\n+                        cls_or_mem = Err(Memory);\n+                    }\n+                }\n             }\n-            Ok(_) => false\n-        };\n+        }\n \n-        if in_mem {\n-            if is_arg {\n-                arg.make_indirect_byval();\n-            } else {\n-                // `sret` parameter thus one less integer register available\n-                arg.make_indirect();\n-                int_regs -= 1;\n+        match cls_or_mem {\n+            Err(Memory) => {\n+                if is_arg {\n+                    arg.make_indirect_byval();\n+                } else {\n+                    // `sret` parameter thus one less integer register available\n+                    arg.make_indirect();\n+                    int_regs -= 1;\n+                }\n             }\n-        } else {\n-            // split into sized chunks passed individually\n-            int_regs -= needed_int;\n-            sse_regs -= needed_sse;\n-\n-            if arg.layout.is_aggregate() {\n-                let size = arg.layout.size;\n-                arg.cast_to(cast_target(cls.as_ref().unwrap(), size))\n-            } else {\n-                arg.extend_integer_width_to(32);\n+            Ok(ref cls) => {\n+                // split into sized chunks passed individually\n+                int_regs -= needed_int;\n+                sse_regs -= needed_sse;\n+\n+                if arg.layout.is_aggregate() {\n+                    let size = arg.layout.size;\n+                    arg.cast_to(cast_target(cls, size))\n+                } else {\n+                    arg.extend_integer_width_to(32);\n+                }\n             }\n         }\n     };"}, {"sha": "9071eb776d5295dc25231789591d74dae9ad5251", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -270,6 +270,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         None => {}\n     };\n+    if sig.output().is_never() {\n+        flags = flags | DIFlags::FlagNoReturn;\n+    }\n \n     let fn_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateFunction("}, {"sha": "da01592d9118a9e1e9cd3f804adad15e5732adc2", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -487,16 +487,18 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM does the deref itself, so we must not add it.\n+                // Starting with D31439 in LLVM 5, it *always* does the deref itself.\n                 let mut variable_access = VariableAccess::DirectVariable {\n                     alloca: place.llval\n                 };\n-\n-                if let PassMode::Indirect(ref attrs) = arg.mode {\n-                    if !attrs.contains(ArgAttribute::ByVal) {\n-                        variable_access = VariableAccess::IndirectVariable {\n-                            alloca: place.llval,\n-                            address_operations: &deref_op,\n-                        };\n+                if unsafe { llvm::LLVMRustVersionMajor() < 5 } {\n+                    if let PassMode::Indirect(ref attrs) = arg.mode {\n+                        if !attrs.contains(ArgAttribute::ByVal) {\n+                            variable_access = VariableAccess::IndirectVariable {\n+                                alloca: place.llval,\n+                                address_operations: &deref_op,\n+                            };\n+                        }\n                     }\n                 }\n "}, {"sha": "1139ea5fbd364074c33abdf2c47d2fe2b12388e8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -979,7 +979,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let item_id = tcx.hir.get_parent_node(node_id);\n                 let item_def_id = tcx.hir.local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n-                let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n+                let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id)];\n                 tcx.mk_param(index, tcx.hir.name(node_id))\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n@@ -1206,22 +1206,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let output = bare_fn_ty.output();\n         let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n         for br in late_bound_in_ret.difference(&late_bound_in_args) {\n-            let br_name = match *br {\n-                ty::BrNamed(_, name) => name,\n-                _ => {\n-                    span_bug!(\n-                        decl.output.span(),\n-                        \"anonymous bound region {:?} in return but not args\",\n-                        br);\n-                }\n+            let lifetime_name = match *br {\n+                ty::BrNamed(_, name) => format!(\"lifetime `{}`,\", name),\n+                ty::BrAnon(_) | ty::BrFresh(_) | ty::BrEnv => format!(\"an anonymous lifetime\"),\n             };\n-            struct_span_err!(tcx.sess,\n-                             decl.output.span(),\n-                             E0581,\n-                             \"return type references lifetime `{}`, \\\n-                             which does not appear in the fn input types\",\n-                             br_name)\n-                .emit();\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           decl.output.span(),\n+                                           E0581,\n+                                           \"return type references {} \\\n+                                            which is not constrained by the fn input types\",\n+                                           lifetime_name);\n+            if let ty::BrAnon(_) = *br {\n+                // The only way for an anonymous lifetime to wind up\n+                // in the return type but **also** be unconstrained is\n+                // if it only appears in \"associated types\" in the\n+                // input. See #47511 for an example. In this case,\n+                // though we can easily give a hint that ought to be\n+                // relevant.\n+                err.note(\"lifetimes appearing in an associated type \\\n+                          are not considered constrained\");\n+            }\n+            err.emit();\n         }\n \n         bare_fn_ty"}, {"sha": "48bd7b14fc96ab69439bbf7325900b5589497df3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -281,10 +281,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                 .emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0607,\n-                                 \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n-                                 self.expr_ty,\n-                                 fcx.ty_to_string(self.cast_ty)).emit();\n+                use structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n+                SizedUnsizedCastError::new(&fcx.tcx.sess,\n+                                           self.span,\n+                                           self.expr_ty,\n+                                           fcx.ty_to_string(self.cast_ty))\n+                    .diagnostic().emit();\n             }\n             CastError::UnknownCastPtrKind |\n             CastError::UnknownExprPtrKind => {"}, {"sha": "6147743437b8e638b5be3ad4814dcb3d27f2a0ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -103,6 +103,7 @@ use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use rustc::ty::layout::LayoutOf;\n use errors::{DiagnosticBuilder, DiagnosticId};\n+\n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n use TypeAndSubsts;\n@@ -1636,7 +1637,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n-        let index = generics.type_param_to_index[&def_id.index];\n+        let index = generics.type_param_to_index[&def_id];\n         ty::GenericPredicates {\n             parent: None,\n             predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n@@ -2599,9 +2600,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // arguments which we skipped above.\n         if variadic {\n             fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n-                type_error_struct!(s, span, t, E0617,\n-                                   \"can't pass `{}` to variadic function, cast to `{}`\",\n-                                   t, cast_ty).emit();\n+                use structured_errors::{VariadicError, StructuredDiagnostic};\n+                VariadicError::new(s, span, t, cast_ty).diagnostic().emit();\n             }\n \n             for arg in args.iter().skip(expected_arg_count) {"}, {"sha": "7a91827faef83666e6699eda73951e75df94b3cf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -40,8 +40,6 @@ use util::nodemap::FxHashMap;\n \n use rustc_const_math::ConstInt;\n \n-use std::collections::BTreeMap;\n-\n use syntax::{abi, ast};\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n@@ -240,7 +238,7 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let param_owner = tcx.hir.ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n-    let index = generics.type_param_to_index[&def_id.index];\n+    let index = generics.type_param_to_index[&def_id];\n     let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n@@ -1024,10 +1022,9 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         });\n     }\n \n-    let mut type_param_to_index = BTreeMap::new();\n-    for param in &types {\n-        type_param_to_index.insert(param.def_id.index, param.index);\n-    }\n+    let type_param_to_index = types.iter()\n+                                   .map(|param| (param.def_id, param.index))\n+                                   .collect();\n \n     tcx.alloc_generics(ty::Generics {\n         parent: parent_def_id,"}, {"sha": "bd7e200d620e6f07baa4c17b18ed6a0e421b6d17", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -123,16 +123,17 @@ use std::iter;\n // registered before they are used.\n mod diagnostics;\n \n+mod astconv;\n mod check;\n mod check_unused;\n-mod astconv;\n+mod coherence;\n mod collect;\n mod constrained_type_params;\n+mod structured_errors;\n mod impl_wf_check;\n-mod coherence;\n+mod namespace;\n mod outlives;\n mod variance;\n-mod namespace;\n \n pub struct TypeAndSubsts<'tcx> {\n     substs: &'tcx Substs<'tcx>,"}, {"sha": "afcdc7575a3cbe1c36cfc3528aea4481db0d2369", "filename": "src/librustc_typeck/structured_errors.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fstructured_errors.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::session::Session;\n+use syntax_pos::Span;\n+use errors::{DiagnosticId, DiagnosticBuilder};\n+use rustc::ty::{Ty, TypeFoldable};\n+\n+pub trait StructuredDiagnostic<'tcx> {\n+    fn session(&self) -> &Session;\n+\n+    fn code(&self) -> DiagnosticId;\n+\n+    fn common(&self) -> DiagnosticBuilder<'tcx>;\n+\n+    fn diagnostic(&self) -> DiagnosticBuilder<'tcx> {\n+        let err = self.common();\n+        if self.session().teach(&self.code()) {\n+            self.extended(err)\n+        } else {\n+            self.regular(err)\n+        }\n+    }\n+\n+    fn regular(&self, err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+        err\n+    }\n+\n+    fn extended(&self, err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+        err\n+    }\n+}\n+\n+pub struct VariadicError<'tcx> {\n+    sess: &'tcx Session,\n+    span: Span,\n+    t: Ty<'tcx>,\n+    cast_ty: &'tcx str,\n+}\n+\n+impl<'tcx> VariadicError<'tcx> {\n+    pub fn new(sess: &'tcx Session,\n+               span: Span,\n+               t: Ty<'tcx>,\n+               cast_ty: &'tcx str) -> VariadicError<'tcx> {\n+        VariadicError { sess, span, t, cast_ty }\n+    }\n+}\n+\n+impl<'tcx> StructuredDiagnostic<'tcx> for VariadicError<'tcx> {\n+    fn session(&self) -> &Session { self.sess }\n+\n+    fn code(&self) -> DiagnosticId {\n+        __diagnostic_used!(E0617);\n+        DiagnosticId::Error(\"E0617\".to_owned())\n+    }\n+\n+    fn common(&self) -> DiagnosticBuilder<'tcx> {\n+        let mut err = if self.t.references_error() {\n+            self.sess.diagnostic().struct_dummy()\n+        } else {\n+            self.sess.struct_span_fatal_with_code(\n+                self.span,\n+                &format!(\"can't pass `{}` to variadic function\", self.t),\n+                self.code(),\n+            )\n+        };\n+        if let Ok(snippet) = self.sess.codemap().span_to_snippet(self.span) {\n+            err.span_suggestion(self.span,\n+                                &format!(\"cast the value to `{}`\", self.cast_ty),\n+                                format!(\"{} as {}\", snippet, self.cast_ty));\n+        } else {\n+            err.help(&format!(\"cast the value to `{}`\", self.cast_ty));\n+        }\n+        err\n+    }\n+\n+    fn extended(&self, mut err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+        err.note(&format!(\"certain types, like `{}`, must be cast before passing them to a \\\n+                           variadic function, because of arcane ABI rules dictated by the C \\\n+                           standard\",\n+                          self.t));\n+        err\n+    }\n+}\n+\n+pub struct SizedUnsizedCastError<'tcx> {\n+    sess: &'tcx Session,\n+    span: Span,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: String,\n+}\n+\n+impl<'tcx> SizedUnsizedCastError<'tcx> {\n+    pub fn new(sess: &'tcx Session,\n+               span: Span,\n+               expr_ty: Ty<'tcx>,\n+               cast_ty: String) -> SizedUnsizedCastError<'tcx> {\n+        SizedUnsizedCastError { sess, span, expr_ty, cast_ty }\n+    }\n+}\n+\n+impl<'tcx> StructuredDiagnostic<'tcx> for SizedUnsizedCastError<'tcx> {\n+    fn session(&self) -> &Session { self.sess }\n+\n+    fn code(&self) -> DiagnosticId {\n+        __diagnostic_used!(E0607);\n+        DiagnosticId::Error(\"E0607\".to_owned())\n+    }\n+\n+    fn common(&self) -> DiagnosticBuilder<'tcx> {\n+        if self.expr_ty.references_error() {\n+            self.sess.diagnostic().struct_dummy()\n+        } else {\n+            self.sess.struct_span_fatal_with_code(\n+                self.span,\n+                &format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n+                         self.expr_ty,\n+                         self.cast_ty),\n+                self.code(),\n+            )\n+        }\n+    }\n+\n+    fn extended(&self, mut err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+        err.help(\n+            \"Thin pointers are \\\"simple\\\" pointers: they are purely a reference to a\n+memory address.\n+\n+Fat pointers are pointers referencing \\\"Dynamically Sized Types\\\" (also\n+called DST). DST don't have a statically known size, therefore they can\n+only exist behind some kind of pointers that contain additional\n+information. Slices and trait objects are DSTs. In the case of slices,\n+the additional information the fat pointer holds is their size.\n+\n+To fix this error, don't try to cast directly between thin and fat\n+pointers.\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\");\n+        err\n+    }\n+}"}, {"sha": "f7e10a4a47d37733677da801410cecdb062dbe5d", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -14,16 +14,12 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::dep_graph::{DepGraphSafe, DepKind, DepNodeColor};\n-use rustc::ich::StableHashingContext;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n-use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n-\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n \n@@ -132,50 +128,11 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> StableHashingContextProvider for ConstraintContext<'a, 'tcx> {\n-    type ContextType = StableHashingContext<'tcx>;\n-\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-         self.terms_cx.tcx.create_stable_hashing_context()\n-    }\n-}\n-\n-impl<'a, 'tcx> DepGraphSafe for ConstraintContext<'a, 'tcx> {}\n-\n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n         let def_id = tcx.hir.local_def_id(id);\n-\n-        // Encapsulate constructing the constraints into a task we can\n-        // reference later. This can go away once the red-green\n-        // algorithm is in place.\n-        //\n-        // See README.md for a detailed discussion\n-        // on dep-graph management.\n-        let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-\n-        if let Some(DepNodeColor::Green(_)) = tcx.dep_graph.node_color(&dep_node) {\n-            // If the corresponding node has already been marked as green, the\n-            // appropriate portion of the DepGraph has already been loaded from\n-            // the previous graph, so we don't do any dep-tracking. Since we\n-            // don't cache any values though, we still have to re-run the\n-            // computation.\n-            tcx.dep_graph.with_ignore(|| {\n-                self.build_constraints_for_item(def_id);\n-            });\n-        } else {\n-            tcx.dep_graph.with_task(dep_node,\n-                                    self,\n-                                    def_id,\n-                                    visit_item_task);\n-        }\n-\n-        fn visit_item_task<'a, 'tcx>(ccx: &mut ConstraintContext<'a, 'tcx>,\n-                                     def_id: DefId)\n-        {\n-            ccx.build_constraints_for_item(def_id);\n-        }\n+        self.build_constraints_for_item(def_id);\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "003ee6f25995d8a6e1d4989a3974cb0d9eaba5ce", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -12,7 +12,6 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::dep_graph::DepKind;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n@@ -95,9 +94,6 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n     // Everything else must be inferred.\n \n     let crate_map = tcx.crate_variances(LOCAL_CRATE);\n-    let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-    tcx.dep_graph.read(dep_node);\n-\n     crate_map.variances.get(&item_def_id)\n                        .unwrap_or(&crate_map.empty_variance)\n                        .clone()"}, {"sha": "0929b833c1965395337753946980f8f4db38ec84", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 138, "deletions": 41, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -659,7 +659,8 @@ pub struct Attributes {\n     pub other_attrs: Vec<ast::Attribute>,\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n-    pub links: Vec<(String, DefId)>,\n+    /// map from Rust paths to resolved defs and potential URL fragments\n+    pub links: Vec<(String, DefId, Option<String>)>,\n }\n \n impl Attributes {\n@@ -820,8 +821,12 @@ impl Attributes {\n     /// Cache must be populated before call\n     pub fn links(&self) -> Vec<(String, String)> {\n         use html::format::href;\n-        self.links.iter().filter_map(|&(ref s, did)| {\n-            if let Some((href, ..)) = href(did) {\n+        self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n+            if let Some((mut href, ..)) = href(did) {\n+                if let Some(ref fragment) = *fragment {\n+                    href.push_str(\"#\");\n+                    href.push_str(fragment);\n+                }\n                 Some((s.clone(), href))\n             } else {\n                 None\n@@ -843,10 +848,8 @@ impl AttributesExt for Attributes {\n /// they exist in both namespaces (structs and modules)\n fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n     match def {\n-        // structs and mods exist in both namespaces. skip them\n-        Def::StructCtor(..) | Def::Mod(..) => None,\n-        Def::Variant(..) | Def::VariantCtor(..)\n-            => Some((\"variant\", format!(\"{}()\", path_str))),\n+        // structs, variants, and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n         Def::Fn(..)\n             => Some((\"function\", format!(\"{}()\", path_str))),\n         Def::Method(..)\n@@ -880,10 +883,10 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n     let sp = attrs.doc_strings.first()\n                   .map_or(DUMMY_SP, |a| a.span());\n     cx.sess()\n-      .struct_span_err(sp,\n-                       &format!(\"`{}` is both {} {} and {} {}\",\n-                                path_str, article1, kind1,\n-                                article2, kind2))\n+      .struct_span_warn(sp,\n+                        &format!(\"`{}` is both {} {} and {} {}\",\n+                                 path_str, article1, kind1,\n+                                 article2, kind2))\n       .help(&format!(\"try `{}` if you want to select the {}, \\\n                       or `{}` if you want to \\\n                       select the {}\",\n@@ -892,21 +895,114 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n              .emit();\n }\n \n+/// Given an enum variant's def, return the def of its enum and the associated fragment\n+fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+    use rustc::ty::DefIdTree;\n+\n+    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n+        parent\n+    } else {\n+        return Err(())\n+    };\n+    let parent_def = Def::Enum(parent);\n+    let variant = cx.tcx.expect_variant_def(def);\n+    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n+}\n+\n /// Resolve a given string as a path, along with whether or not it is\n-/// in the value namespace\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<hir::Path, ()> {\n+/// in the value namespace. Also returns an optional URL fragment in the case\n+/// of variants and methods\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option<String>), ()> {\n     // In case we're in a module, try to resolve the relative\n     // path\n     if let Some(id) = cx.mod_ids.borrow().last() {\n-        cx.resolver.borrow_mut()\n-                   .with_scope(*id, |resolver| {\n-                        resolver.resolve_str_path_error(DUMMY_SP,\n-                                                        &path_str, is_val)\n-                    })\n+        let result = cx.resolver.borrow_mut()\n+                                .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path_str, is_val)\n+        });\n+\n+        if let Ok(result) = result {\n+            // In case this is a trait item, skip the\n+            // early return and try looking for the trait\n+            let value = match result.def {\n+                Def::Method(_) | Def::AssociatedConst(_) => true,\n+                Def::AssociatedTy(_)  => false,\n+                Def::Variant(_) => return handle_variant(cx, result.def),\n+                // not a trait item, just return what we found\n+                _ => return Ok((result.def, None))\n+            };\n+\n+            if value != is_val {\n+                return Err(())\n+            }\n+        } else {\n+            // If resolution failed, it may still be a method\n+            // because methods are not handled by the resolver\n+            // If so, bail when we're not looking for a value\n+            if !is_val {\n+                return Err(())\n+            }\n+        }\n+\n+        // Try looking for methods and associated items\n+        let mut split = path_str.rsplitn(2, \"::\");\n+        let mut item_name = if let Some(first) = split.next() {\n+            first\n+        } else {\n+            return Err(())\n+        };\n+\n+        let mut path = if let Some(second) = split.next() {\n+            second\n+        } else {\n+            return Err(())\n+        };\n+\n+        let ty = cx.resolver.borrow_mut()\n+                            .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path, false)\n+        })?;\n+        match ty.def {\n+            Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                let item = cx.tcx.inherent_impls(did).iter()\n+                                 .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                                 .find(|item| item.name == item_name);\n+                if let Some(item) = item {\n+                    if item.kind == ty::AssociatedKind::Method && is_val {\n+                        Ok((ty.def, Some(format!(\"method.{}\", item_name))))\n+                    } else {\n+                        Err(())\n+                    }\n+                } else {\n+                    Err(())\n+                }\n+            }\n+            Def::Trait(did) => {\n+                let item = cx.tcx.associated_item_def_ids(did).iter()\n+                             .map(|item| cx.tcx.associated_item(*item))\n+                             .find(|item| item.name == item_name);\n+                if let Some(item) = item {\n+                    let kind = match item.kind {\n+                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                        ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n+                        ty::AssociatedKind::Method if is_val => \"tymethod\",\n+                        _ => return Err(())\n+                    };\n+\n+                    Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n+                } else {\n+                    Err(())\n+                }\n+            }\n+            _ => Err(())\n+        }\n+\n     } else {\n-        // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n-        cx.resolver.borrow_mut()\n-                   .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+        Err(())\n     }\n }\n \n@@ -955,7 +1051,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n             for link in markdown_links(&dox, cx.render_type) {\n-                let def = {\n+                let (def, fragment)  = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n                         [\"struct@\", \"enum@\", \"type@\",\n@@ -965,7 +1061,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         link.trim_left_matches(prefix)\n                     } else if let Some(prefix) =\n                         [\"const@\", \"static@\",\n-                         \"value@\", \"function@\", \"mod@\", \"fn@\", \"module@\"]\n+                         \"value@\", \"function@\", \"mod@\",\n+                         \"fn@\", \"module@\", \"method@\"]\n                             .iter().find(|p| link.starts_with(**p)) {\n                         kind = PathKind::Value;\n                         link.trim_left_matches(prefix)\n@@ -993,8 +1090,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n                     match kind {\n                         PathKind::Value => {\n-                            if let Ok(path) = resolve(cx, path_str, true) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, true) {\n+                                def\n                             } else {\n                                 // this could just be a normal link or a broken link\n                                 // we could potentially check if something is\n@@ -1003,8 +1100,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             }\n                         }\n                         PathKind::Type => {\n-                            if let Ok(path) = resolve(cx, path_str, false) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, false) {\n+                                def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;\n@@ -1013,50 +1110,50 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         PathKind::Unknown => {\n                             // try everything!\n                             if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                                if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                if let Ok(type_def) = resolve(cx, path_str, false) {\n                                     let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_path.def, path_str);\n+                                        = type_ns_kind(type_def.0, path_str);\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     article, type_kind, &type_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                     continue;\n-                                } else if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                } else if let Ok(value_def) = resolve(cx, path_str, true) {\n                                     let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_path.def, path_str)\n+                                        = value_ns_kind(value_def.0, path_str)\n                                             .expect(\"struct and mod cases should have been \\\n                                                      caught in previous branch\");\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     \"a\", value_kind, &value_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 }\n-                                macro_def\n-                            } else if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                (macro_def, None)\n+                            } else if let Ok(type_def) = resolve(cx, path_str, false) {\n                                 // It is imperative we search for not-a-value first\n                                 // Otherwise we will find struct ctors for when we are looking\n                                 // for structs, and the link won't work.\n                                 // if there is something in both namespaces\n-                                if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_path.def, path_str);\n+                                if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                    let kind = value_ns_kind(value_def.0, path_str);\n                                     if let Some((value_kind, value_disambig)) = kind {\n                                         let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_path.def, path_str);\n+                                            = type_ns_kind(type_def.0, path_str);\n                                         ambiguity_error(cx, &attrs, path_str,\n                                                         article, type_kind, &type_disambig,\n                                                         \"a\", value_kind, &value_disambig);\n                                         continue;\n                                     }\n                                 }\n-                                type_path.def\n-                            } else if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                value_path.def\n+                                type_def\n+                            } else if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                value_def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;\n                             }\n                         }\n                         PathKind::Macro => {\n                             if let Some(def) = macro_resolve(cx, path_str) {\n-                                def\n+                                (def, None)\n                             } else {\n                                 continue\n                             }\n@@ -1066,7 +1163,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n \n                 let id = register_def(cx, def);\n-                attrs.links.push((link, id));\n+                attrs.links.push((link, id, fragment));\n             }\n \n             cx.sess().abort_if_errors();"}, {"sha": "1fb8f106cac030f5379305c40668d0edcb2cefec", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1243,6 +1243,16 @@ impl DocFolder for Cache {\n             _ => self.stripped_mod,\n         };\n \n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate) ||\n+               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n+               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n+                return None;\n+            }\n+        }\n+\n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types.\n         if let Some(generics) = item.inner.generics() {\n@@ -1257,14 +1267,10 @@ impl DocFolder for Cache {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n-            if !self.masked_crates.contains(&item.def_id.krate) {\n-                if let Some(did) = i.trait_.def_id() {\n-                    if i.for_.def_id().map_or(true, |d| !self.masked_crates.contains(&d.krate)) {\n-                        self.implementors.entry(did).or_insert(vec![]).push(Impl {\n-                            impl_item: item.clone(),\n-                        });\n-                    }\n-                }\n+            if let Some(did) = i.trait_.def_id() {\n+                self.implementors.entry(did).or_insert(vec![]).push(Impl {\n+                    impl_item: item.clone(),\n+                });\n             }\n         }\n \n@@ -1427,24 +1433,20 @@ impl DocFolder for Cache {\n                 // Note: matching twice to restrict the lifetime of the `i` borrow.\n                 let mut dids = FxHashSet();\n                 if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    let masked_trait = i.trait_.def_id().map_or(false,\n-                        |d| self.masked_crates.contains(&d.krate));\n-                    if !masked_trait {\n-                        match i.for_ {\n-                            clean::ResolvedPath { did, .. } |\n-                            clean::BorrowedRef {\n-                                type_: box clean::ResolvedPath { did, .. }, ..\n-                            } => {\n-                                dids.insert(did);\n-                            }\n-                            ref t => {\n-                                let did = t.primitive_type().and_then(|t| {\n-                                    self.primitive_locations.get(&t).cloned()\n-                                });\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).cloned()\n+                            });\n \n-                                if let Some(did) = did {\n-                                    dids.insert(did);\n-                                }\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n                             }\n                         }\n                     }"}, {"sha": "73810b3fe81d73cc02bc58bca039e36f7ad06536", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -33,6 +33,18 @@ use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct Label {\n+    pub ident: Ident,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"label({:?})\", self.ident)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -1078,23 +1090,23 @@ pub enum ExprKind {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    While(P<Expr>, P<Block>, Option<SpannedIdent>),\n+    While(P<Expr>, P<Block>, Option<Label>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<SpannedIdent>),\n+    Loop(P<Block>, Option<Label>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| a + b + c`)\n@@ -1133,9 +1145,9 @@ pub enum ExprKind {\n     /// A referencing operation (`&a` or `&mut a`)\n     AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break, and an optional expression\n-    Break(Option<SpannedIdent>, Option<P<Expr>>),\n+    Break(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    Continue(Option<SpannedIdent>),\n+    Continue(Option<Label>),\n     /// A `return`, with an optional value to be returned\n     Ret(Option<P<Expr>>),\n "}, {"sha": "025aa94ce06f5afae48a09ed0c0b1a05f0340f01", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -786,7 +786,7 @@ impl<'a> ExtCtxt<'a> {\n     ///   substitute; we never hit resolve/type-checking so the dummy\n     ///   value doesn't have to match anything)\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        panic!(self.parse_sess.span_diagnostic.span_fatal(sp, msg));\n+        self.parse_sess.span_diagnostic.span_fatal(sp, msg).raise();\n     }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping"}, {"sha": "44a073545a7302acbe2ce9210af27263850016ab", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 suggested_limit));\n             err.emit();\n             self.cx.trace_macros_diag();\n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n \n         Some(result)"}, {"sha": "ec4e6ced1b273a9b69e96c689c655436bd316eae", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -116,9 +116,10 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => panic!(self.p.diagnostic().span_fatal(self.p.span,\n+                    None => self.p.diagnostic().span_fatal(self.p.span,\n                                                            &format!(\"expected item, found `{}`\",\n-                                                                    self.p.this_token_to_string())))\n+                                                                    self.p.this_token_to_string()))\n+                                               .raise()\n                 }\n             }\n             Some(ret)"}, {"sha": "3e3c1618fffb2de30119d58246fffb69aad263c3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -573,15 +573,15 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             Some(i) => token::NtItem(i),\n             None => {\n                 p.fatal(\"expected an item keyword\").emit();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n         \"stmt\" => match panictry!(p.parse_stmt()) {\n             Some(s) => token::NtStmt(s),\n             None => {\n                 p.fatal(\"expected a statement\").emit();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n@@ -597,7 +597,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n                 let token_str = pprust::token_to_string(&p.token);\n                 p.fatal(&format!(\"expected ident, found {}\",\n                                  &token_str[..])).emit();\n-                panic!(FatalError)\n+                FatalError.raise()\n             }\n         },\n         \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),"}, {"sha": "9efb4faa63535725bc198d261465afe694120063", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -222,10 +222,10 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);\n-            panic!(sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s));\n+            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n         }\n         Error(sp, s) => {\n-            panic!(sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s));\n+            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n         }\n     };\n "}, {"sha": "8512e215ca7655cad4d5bf4cac965867b1e908a9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1954,7 +1954,7 @@ impl FeatureChecker {\n                 .span_note(ca_span, \"`#![feature(custom_attribute)]` declared here\")\n                 .emit();\n \n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n \n         if let (Some(span), None) = (self.copy_closures, self.clone_closures) {\n@@ -1963,7 +1963,7 @@ impl FeatureChecker {\n                   .span_note(span, \"`#![feature(copy_closures)]` declared here\")\n                   .emit();\n \n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n     }\n }"}, {"sha": "0f8fe57e380e557e02379331bcdb4b774ffce223", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -193,6 +193,10 @@ pub trait Folder : Sized {\n         noop_fold_macro_def(def, self)\n     }\n \n+    fn fold_label(&mut self, label: Label) -> Label {\n+        noop_fold_label(label, self)\n+    }\n+\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -696,6 +700,13 @@ pub fn noop_fold_generic_params<T: Folder>(\n     params.move_map(|p| fld.fold_generic_param(p))\n }\n \n+pub fn noop_fold_label<T: Folder>(label: Label, fld: &mut T) -> Label {\n+    Label {\n+        ident: fld.fold_ident(label.ident),\n+        span: fld.new_span(label.span),\n+    }\n+}\n+\n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n@@ -1206,30 +1217,26 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprKind::While(cond, body, opt_ident) => {\n+            ExprKind::While(cond, body, opt_label) => {\n                 ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                       folder.fold_ident(label.node))))\n+                          opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n+            ExprKind::WhileLet(pat, expr, body, opt_label) => {\n                 ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n-                             opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                          folder.fold_ident(label.node))))\n+                             opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n+            ExprKind::ForLoop(pat, iter, body, opt_label) => {\n                 ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n-                            opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                         folder.fold_ident(label.node))))\n+                            opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::Loop(body, opt_ident) => {\n+            ExprKind::Loop(body, opt_label) => {\n                 ExprKind::Loop(folder.fold_block(body),\n-                               opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                            folder.fold_ident(label.node))))\n+                               opt_label.map(|label| folder.fold_label(label)))\n             }\n             ExprKind::Match(expr, arms) => {\n                 ExprKind::Match(folder.fold_expr(expr),\n@@ -1278,15 +1285,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 });\n                 ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprKind::Break(opt_ident, opt_expr) => {\n-                ExprKind::Break(opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                             folder.fold_ident(label.node))),\n+            ExprKind::Break(opt_label, opt_expr) => {\n+                ExprKind::Break(opt_label.map(|label| folder.fold_label(label)),\n                                 opt_expr.map(|e| folder.fold_expr(e)))\n             }\n-            ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n+            ExprKind::Continue(opt_label) => {\n+                ExprKind::Continue(opt_label.map(|label| folder.fold_label(label)))\n+            }\n             ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n             ExprKind::InlineAsm(asm) => ExprKind::InlineAsm(asm.map(|asm| {\n                 InlineAsm {"}, {"sha": "3b4c5da10f20b35b5f0014a956419e00b4125d11", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -54,7 +54,7 @@ macro_rules! panictry {\n             Ok(e) => e,\n             Err(mut e) => {\n                 e.emit();\n-                panic!(FatalError);\n+                FatalError.raise()\n             }\n         }\n     })"}, {"sha": "63aa5d28ce8dc9a6df04454c397886d85f9262da", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -265,7 +265,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n-                panic!(rdr.fatal(\"unterminated block comment\"));\n+                rdr.fatal(\"unterminated block comment\").raise();\n             }\n             if rdr.ch_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);"}, {"sha": "b95c91548d00b99954ed70701f9e1cc87eed12ed", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -90,7 +90,7 @@ impl<'a> StringReader<'a> {\n             Ok(tok) => tok,\n             Err(_) => {\n                 self.emit_fatal_errors();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         }\n     }\n@@ -191,7 +191,7 @@ impl<'a> StringReader<'a> {\n         let mut sr = StringReader::new_raw(sess, filemap);\n         if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n         sr\n     }\n@@ -216,7 +216,7 @@ impl<'a> StringReader<'a> {\n \n         if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n-            panic!(FatalError);\n+            FatalError.raise();\n         }\n         sr\n     }\n@@ -647,7 +647,7 @@ impl<'a> StringReader<'a> {\n                     \"unterminated block comment\"\n                 };\n                 let last_bpos = self.pos;\n-                panic!(self.fatal_span_(start_bpos, last_bpos, msg));\n+                self.fatal_span_(start_bpos, last_bpos, msg).raise();\n             }\n             let n = self.ch.unwrap();\n             match n {\n@@ -808,9 +808,9 @@ impl<'a> StringReader<'a> {\n         for _ in 0..n_digits {\n             if self.is_eof() {\n                 let last_bpos = self.pos;\n-                panic!(self.fatal_span_(start_bpos,\n-                                        last_bpos,\n-                                        \"unterminated numeric character escape\"));\n+                self.fatal_span_(start_bpos,\n+                                 last_bpos,\n+                                 \"unterminated numeric character escape\").raise();\n             }\n             if self.ch_is(delim) {\n                 let last_bpos = self.pos;\n@@ -1025,9 +1025,9 @@ impl<'a> StringReader<'a> {\n                     }\n                 },\n                 None => {\n-                    panic!(self.fatal_span_(start_bpos,\n-                                            self.pos,\n-                                            \"unterminated unicode escape (found EOF)\"));\n+                    self.fatal_span_(start_bpos,\n+                                     self.pos,\n+                                     \"unterminated unicode escape (found EOF)\").raise();\n                 }\n             }\n             self.bump();\n@@ -1283,9 +1283,9 @@ impl<'a> StringReader<'a> {\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        panic!(self.fatal_span_verbose(\n-                               start_with_quote, self.next_pos,\n-                               String::from(\"character literal may only contain one codepoint\")));\n+                        self.fatal_span_verbose(start_with_quote, self.next_pos,\n+                                String::from(\"character literal may only contain one codepoint\"))\n+                            .raise();\n \n                     }\n \n@@ -1332,9 +1332,8 @@ impl<'a> StringReader<'a> {\n                             break;\n                         }\n                     }\n-                    panic!(self.fatal_span_verbose(\n-                           start_with_quote, pos,\n-                           String::from(\"character literal may only contain one codepoint\")));\n+                    self.fatal_span_verbose(start_with_quote, pos,\n+                        String::from(\"character literal may only contain one codepoint\")).raise();\n                 }\n \n                 let id = if valid {\n@@ -1364,9 +1363,9 @@ impl<'a> StringReader<'a> {\n                 while !self.ch_is('\"') {\n                     if self.is_eof() {\n                         let last_bpos = self.pos;\n-                        panic!(self.fatal_span_(start_bpos,\n-                                                last_bpos,\n-                                                \"unterminated double quote string\"));\n+                        self.fatal_span_(start_bpos,\n+                                         last_bpos,\n+                                         \"unterminated double quote string\").raise();\n                     }\n \n                     let ch_start = self.pos;\n@@ -1399,15 +1398,15 @@ impl<'a> StringReader<'a> {\n \n                 if self.is_eof() {\n                     let last_bpos = self.pos;\n-                    panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n+                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\").raise();\n                 } else if !self.ch_is('\"') {\n                     let last_bpos = self.pos;\n                     let curr_char = self.ch.unwrap();\n-                    panic!(self.fatal_span_char(start_bpos,\n-                                                last_bpos,\n-                                                \"found invalid character; only `#` is allowed \\\n-                                                 in raw string delimitation\",\n-                                                curr_char));\n+                    self.fatal_span_char(start_bpos,\n+                                         last_bpos,\n+                                         \"found invalid character; only `#` is allowed \\\n+                                         in raw string delimitation\",\n+                                         curr_char).raise();\n                 }\n                 self.bump();\n                 let content_start_bpos = self.pos;\n@@ -1416,7 +1415,7 @@ impl<'a> StringReader<'a> {\n                 'outer: loop {\n                     if self.is_eof() {\n                         let last_bpos = self.pos;\n-                        panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n+                        self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\").raise();\n                     }\n                     // if self.ch_is('\"') {\n                     // content_end_bpos = self.pos;\n@@ -1573,9 +1572,9 @@ impl<'a> StringReader<'a> {\n             // character before position `start` are an\n             // ascii single quote and ascii 'b'.\n             let pos = self.pos;\n-            panic!(self.fatal_span_verbose(start - BytePos(2),\n-                                           pos,\n-                                           \"unterminated byte constant\".to_string()));\n+            self.fatal_span_verbose(start - BytePos(2),\n+                                    pos,\n+                                    \"unterminated byte constant\".to_string()).raise();\n         }\n \n         let id = if valid {\n@@ -1599,7 +1598,7 @@ impl<'a> StringReader<'a> {\n         while !self.ch_is('\"') {\n             if self.is_eof() {\n                 let pos = self.pos;\n-                panic!(self.fatal_span_(start, pos, \"unterminated double quote byte string\"));\n+                self.fatal_span_(start, pos, \"unterminated double quote byte string\").raise();\n             }\n \n             let ch_start = self.pos;\n@@ -1631,15 +1630,15 @@ impl<'a> StringReader<'a> {\n \n         if self.is_eof() {\n             let pos = self.pos;\n-            panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"));\n+            self.fatal_span_(start_bpos, pos, \"unterminated raw string\").raise();\n         } else if !self.ch_is('\"') {\n             let pos = self.pos;\n             let ch = self.ch.unwrap();\n-            panic!(self.fatal_span_char(start_bpos,\n+            self.fatal_span_char(start_bpos,\n                                         pos,\n                                         \"found invalid character; only `#` is allowed in raw \\\n                                          string delimitation\",\n-                                        ch));\n+                                        ch).raise();\n         }\n         self.bump();\n         let content_start_bpos = self.pos;\n@@ -1648,7 +1647,7 @@ impl<'a> StringReader<'a> {\n             match self.ch {\n                 None => {\n                     let pos = self.pos;\n-                    panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"))\n+                    self.fatal_span_(start_bpos, pos, \"unterminated raw string\").raise()\n                 }\n                 Some('\"') => {\n                     content_end_bpos = self.pos;"}, {"sha": "b671f81c2a84b681c3301d488380a5a0c4e7723f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -212,8 +212,8 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n         Err(e) => {\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n-                Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, &msg)),\n-                None => panic!(sess.span_diagnostic.fatal(&msg))\n+                Some(sp) => sess.span_diagnostic.span_fatal(sp, &msg).raise(),\n+                None => sess.span_diagnostic.fatal(&msg).raise()\n             }\n         }\n     }"}, {"sha": "d393cab471850a5af744a53f39f23ccee8a83bbb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -23,7 +23,7 @@ use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::GenericParam;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n-use ast::{Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n+use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n@@ -1325,15 +1325,17 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern)\n     }\n \n-    fn get_label(&mut self) -> ast::Ident {\n-        match self.token {\n+    fn eat_label(&mut self) -> Option<Label> {\n+        let ident = match self.token {\n             token::Lifetime(ref ident) => *ident,\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtLifetime(lifetime) => lifetime.ident,\n-                _ => self.bug(\"not a lifetime\"),\n+                _ => return None,\n             },\n-            _ => self.bug(\"not a lifetime\"),\n-        }\n+            _ => return None,\n+        };\n+        self.bump();\n+        Some(Label { ident, span: self.prev_span })\n     }\n \n     /// parse a TyKind::BareFn type:\n@@ -2317,11 +2319,8 @@ impl<'a> Parser<'a> {\n                     let lo = self.prev_span;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n-                if self.token.is_lifetime() {\n-                    let label = Spanned { node: self.get_label(),\n-                                          span: self.span };\n-                    let lo = self.span;\n-                    self.bump();\n+                if let Some(label) = self.eat_label() {\n+                    let lo = label.span;\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n                         return self.parse_while_expr(Some(label), lo, attrs)\n@@ -2339,16 +2338,8 @@ impl<'a> Parser<'a> {\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n-                    let ex = if self.token.is_lifetime() {\n-                        let ex = ExprKind::Continue(Some(Spanned{\n-                            node: self.get_label(),\n-                            span: self.span\n-                        }));\n-                        self.bump();\n-                        ex\n-                    } else {\n-                        ExprKind::Continue(None)\n-                    };\n+                    let label = self.eat_label();\n+                    let ex = ExprKind::Continue(label);\n                     let hi = self.prev_span;\n                     return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n                 }\n@@ -2376,16 +2367,7 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n-                    let lt = if self.token.is_lifetime() {\n-                        let spanned_lt = Spanned {\n-                            node: self.get_label(),\n-                            span: self.span\n-                        };\n-                        self.bump();\n-                        Some(spanned_lt)\n-                    } else {\n-                        None\n-                    };\n+                    let label = self.eat_label();\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n@@ -2394,7 +2376,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         None\n                     };\n-                    ex = ExprKind::Break(lt, e);\n+                    ex = ExprKind::Break(label, e);\n                     hi = self.prev_span;\n                 } else if self.eat_keyword(keywords::Yield) {\n                     if self.token.can_begin_expr() {\n@@ -3291,7 +3273,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_for_expr(&mut self, opt_label: Option<Label>,\n                           span_lo: Span,\n                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n@@ -3309,25 +3291,25 @@ impl<'a> Parser<'a> {\n         attrs.extend(iattrs);\n \n         let hi = self.prev_span;\n-        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_ident), attrs))\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_while_expr(&mut self, opt_label: Option<Label>,\n                             span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n-            return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n+            return self.parse_while_let_expr(opt_label, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_while_let_expr(&mut self, opt_label: Option<Label>,\n                                 span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n@@ -3337,17 +3319,17 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_label), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_loop_expr(&mut self, opt_label: Option<Label>,\n                            span_lo: Span,\n                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_ident), attrs))\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n     }\n \n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)"}, {"sha": "ae459c668aae403c3b6ddc09ac65c4e0526bd7f6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -2104,19 +2104,19 @@ impl<'a> State<'a> {\n             ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n                 self.print_if_let(pat, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr_as_cond(test)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n@@ -2127,9 +2127,9 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"for\")?;\n@@ -2140,9 +2140,9 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::Loop(ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::Loop(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -2238,23 +2238,23 @@ impl<'a> State<'a> {\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n             }\n-            ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n+            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n-            ast::ExprKind::Continue(opt_ident) => {\n+            ast::ExprKind::Continue(opt_label) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?\n                 }\n             }"}, {"sha": "e73550d0719a41cbfe1fe547475b9bbc07f410b7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -123,7 +123,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             match i.node {\n                 ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n-                    panic!(diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\"));\n+                    diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\").raise();\n                 }\n                 _ => {\n                     debug!(\"this is a test function\");"}, {"sha": "bbb123dab286844ec4e8ce5b0dcaa837aeba7d81", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -101,6 +101,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n+    fn visit_label(&mut self, label: &'ast Label) {\n+        walk_label(self, label)\n+    }\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -163,25 +166,6 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_opt_name<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    if let Some(name) = opt_name {\n-        visitor.visit_name(span, name);\n-    }\n-}\n-\n-pub fn walk_opt_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n-    if let Some(ident) = opt_ident {\n-        visitor.visit_ident(span, ident);\n-    }\n-}\n-\n-pub fn walk_opt_sp_ident<'a, V: Visitor<'a>>(visitor: &mut V,\n-                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n-    if let Some(ref sp_ident) = *opt_sp_ident {\n-        visitor.visit_ident(sp_ident.span, sp_ident.node);\n-    }\n-}\n-\n pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n@@ -204,6 +188,10 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n+pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {\n+    visitor.visit_ident(label.span, label.ident);\n+}\n+\n pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n     visitor.visit_ident(lifetime.span, lifetime.ident);\n }\n@@ -226,7 +214,9 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n         ItemKind::ExternCrate(opt_name) => {\n-            walk_opt_name(visitor, item.span, opt_name)\n+            if let Some(name) = opt_name {\n+                visitor.visit_name(item.span, name);\n+            }\n         }\n         ItemKind::Use(ref use_tree) => {\n             visitor.visit_use_tree(use_tree, item.id, false)\n@@ -622,7 +612,9 @@ pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &\n \n pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n     visitor.visit_vis(&struct_field.vis);\n-    walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n+    if let Some(ident) = struct_field.ident {\n+        visitor.visit_ident(struct_field.span, ident);\n+    }\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n@@ -708,32 +700,32 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::Loop(ref block, ref opt_sp_ident) => {\n+        ExprKind::Loop(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n@@ -775,12 +767,12 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident, ref opt_expr) => {\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n+        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_sp_ident) => {\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n+        ExprKind::Continue(ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n         }\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "22e78e9b426b2e7a26544dc7adfc33f5efd42279", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -92,7 +92,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                 }\n \n                 err.emit();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         };\n \n@@ -103,13 +103,13 @@ impl MultiItemModifier for ProcMacroDerive {\n                 // fail if there have been errors emitted\n                 Ok(_) if ecx.parse_sess.span_diagnostic.err_count() > error_count_before => {\n                     ecx.struct_span_fatal(span, msg).emit();\n-                    panic!(FatalError);\n+                    FatalError.raise();\n                 }\n                 Ok(new_items) => new_items.into_iter().map(Annotatable::Item).collect(),\n                 Err(_) => {\n                     // FIXME: handle this better\n                     ecx.struct_span_fatal(span, msg).emit();\n-                    panic!(FatalError);\n+                    FatalError.raise();\n                 }\n             }\n         })"}, {"sha": "12400e363f4b0ba477e4bc2596c7b54db132f809", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -51,7 +51,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n                 }\n \n                 err.emit();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         }\n     }\n@@ -86,7 +86,7 @@ impl base::ProcMacro for BangProcMacro {\n                 }\n \n                 err.emit();\n-                panic!(FatalError);\n+                FatalError.raise();\n             }\n         }\n     }"}, {"sha": "bc344d5bc23c61ff9baf82d268a0edf199933cc3", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1 +1 @@\n-Subproject commit 2717444753318e461e0c3b30dacd03ffbac96903\n+Subproject commit bc344d5bc23c61ff9baf82d268a0edf199933cc3"}, {"sha": "93157cd681942c5e51c0c44286f1b8d5764eec03", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -42,7 +42,6 @@ struct RustArchiveIterator {\n enum class LLVMRustArchiveKind {\n   Other,\n   GNU,\n-  MIPS64,\n   BSD,\n   COFF,\n };\n@@ -51,8 +50,6 @@ static Archive::Kind fromRust(LLVMRustArchiveKind Kind) {\n   switch (Kind) {\n   case LLVMRustArchiveKind::GNU:\n     return Archive::K_GNU;\n-  case LLVMRustArchiveKind::MIPS64:\n-    return Archive::K_MIPS64;\n   case LLVMRustArchiveKind::BSD:\n     return Archive::K_BSD;\n   case LLVMRustArchiveKind::COFF:\n@@ -235,9 +232,16 @@ LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n       Members.push_back(std::move(*MOrErr));\n     }\n   }\n-  auto Pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true, false);\n-  if (!Pair.second)\n+  auto Result = writeArchive(Dst, Members, WriteSymbtab, Kind, true, false);\n+#if LLVM_VERSION_GE(6, 0)\n+  if (!Result)\n     return LLVMRustResult::Success;\n-  LLVMRustSetLastError(Pair.second.message().c_str());\n+  LLVMRustSetLastError(toString(std::move(Result)).c_str());\n+#else\n+  if (!Result.second)\n+    return LLVMRustResult::Success;\n+  LLVMRustSetLastError(Result.second.message().c_str());\n+#endif\n+\n   return LLVMRustResult::Failure;\n }"}, {"sha": "b2f1229891d261dd4758130671f1a87ec46f0de3", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -23,9 +23,15 @@\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n #include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Target/TargetSubtargetInfo.h\"\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n \n+#if LLVM_VERSION_GE(6, 0)\n+#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n+#include \"llvm/IR/IntrinsicInst.h\"\n+#else\n+#include \"llvm/Target/TargetSubtargetInfo.h\"\n+#endif\n+\n #if LLVM_VERSION_GE(4, 0)\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n@@ -210,20 +216,15 @@ extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n \n enum class LLVMRustCodeModel {\n   Other,\n-  Default,\n-  JITDefault,\n   Small,\n   Kernel,\n   Medium,\n   Large,\n+  None,\n };\n \n static CodeModel::Model fromRust(LLVMRustCodeModel Model) {\n   switch (Model) {\n-  case LLVMRustCodeModel::Default:\n-    return CodeModel::Default;\n-  case LLVMRustCodeModel::JITDefault:\n-    return CodeModel::JITDefault;\n   case LLVMRustCodeModel::Small:\n     return CodeModel::Small;\n   case LLVMRustCodeModel::Kernel:\n@@ -360,7 +361,6 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool TrapUnreachable,\n     bool Singlethread) {\n \n-  auto CM = fromRust(RustCM);\n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n \n@@ -399,6 +399,13 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     Options.ThreadModel = ThreadModel::Single;\n   }\n \n+#if LLVM_VERSION_GE(6, 0)\n+  Optional<CodeModel::Model> CM;\n+#else\n+  CodeModel::Model CM = CodeModel::Model::Default;\n+#endif\n+  if (RustCM != LLVMRustCodeModel::None)\n+    CM = fromRust(RustCM);\n   TargetMachine *TM = TheTarget->createTargetMachine(\n       Trip.getTriple(), RealCPU, Feature, Options, RM, CM, OptLevel);\n   return wrap(TM);"}, {"sha": "611d63f6a4d14a1fe13b0a9371e926093dae882f", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -315,7 +315,11 @@ extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n // enable fpmath flag UnsafeAlgebra\n extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n   if (auto I = dyn_cast<Instruction>(unwrap<Value>(V))) {\n+#if LLVM_VERSION_GE(6, 0)\n+    I->setFast(true);\n+#else\n     I->setHasUnsafeAlgebra(true);\n+#endif\n   }\n }\n \n@@ -457,9 +461,13 @@ enum class LLVMRustDIFlags : uint32_t {\n   FlagStaticMember = (1 << 12),\n   FlagLValueReference = (1 << 13),\n   FlagRValueReference = (1 << 14),\n-  FlagMainSubprogram      = (1 << 21),\n+  FlagExternalTypeRef = (1 << 15),\n+  FlagIntroducedVirtual = (1 << 18),\n+  FlagBitField = (1 << 19),\n+  FlagNoReturn = (1 << 20),\n+  FlagMainSubprogram = (1 << 21),\n   // Do not add values that are not supported by the minimum LLVM\n-  // version we support!\n+  // version we support! see llvm/include/llvm/IR/DebugInfoFlags.def\n };\n \n inline LLVMRustDIFlags operator&(LLVMRustDIFlags A, LLVMRustDIFlags B) {\n@@ -544,7 +552,19 @@ static unsigned fromRust(LLVMRustDIFlags Flags) {\n   if (isSet(Flags & LLVMRustDIFlags::FlagRValueReference)) {\n     Result |= DINode::DIFlags::FlagRValueReference;\n   }\n+  if (isSet(Flags & LLVMRustDIFlags::FlagExternalTypeRef)) {\n+    Result |= DINode::DIFlags::FlagExternalTypeRef;\n+  }\n+  if (isSet(Flags & LLVMRustDIFlags::FlagIntroducedVirtual)) {\n+    Result |= DINode::DIFlags::FlagIntroducedVirtual;\n+  }\n+  if (isSet(Flags & LLVMRustDIFlags::FlagBitField)) {\n+    Result |= DINode::DIFlags::FlagBitField;\n+  }\n #if LLVM_RUSTLLVM || LLVM_VERSION_GE(4, 0)\n+  if (isSet(Flags & LLVMRustDIFlags::FlagNoReturn)) {\n+    Result |= DINode::DIFlags::FlagNoReturn;\n+  }\n   if (isSet(Flags & LLVMRustDIFlags::FlagMainSubprogram)) {\n     Result |= DINode::DIFlags::FlagMainSubprogram;\n   }"}, {"sha": "2635ca73303e74af865989c0adb9883e57cf9ee8", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2017-11-08\n+2018-01-25"}, {"sha": "24a5a4e44cb297a6463b06310c50703e41da9e79", "filename": "src/test/codegen/noreturnflag.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcodegen%2Fnoreturnflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcodegen%2Fnoreturnflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnoreturnflag.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-llvm-version 4.0\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK: {{.*}}DISubprogram{{.*}}name: \"foo\"{{.*}}DIFlagNoReturn\n+\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+pub fn main() {\n+    foo();\n+}"}, {"sha": "dc9f63c35db2eadd00a6309477c93968d551d375", "filename": "src/test/codegen/x86_mmx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fx86_mmx.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -22,9 +22,7 @@ pub struct i8x8(u64);\n \n #[no_mangle]\n pub fn a(a: &mut i8x8, b: i8x8) -> i8x8 {\n-    // CHECK-LABEL: define x86_mmx @a(x86_mmx*{{.*}}, x86_mmx{{.*}})\n-    // CHECK: store x86_mmx %b, x86_mmx* %a\n-    // CHECK: ret x86_mmx %b\n+    // CHECK-LABEL: define void @a(x86_mmx*{{.*}}, x86_mmx*{{.*}}, x86_mmx*{{.*}})\n     *a = b;\n     return b\n }"}, {"sha": "9375fd9cade355fcbc6abab29c773d65afe23ccf", "filename": "src/test/compile-fail/E0617.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2FE0617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2FE0617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0617.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -17,16 +17,22 @@ extern {\n fn main() {\n     unsafe {\n         printf(::std::ptr::null(), 0f32);\n-        //~^ ERROR can't pass `f32` to variadic function, cast to `c_double` [E0617]\n+        //~^ ERROR can't pass `f32` to variadic function\n+        //~| HELP cast the value to `c_double`\n         printf(::std::ptr::null(), 0i8);\n-        //~^ ERROR can't pass `i8` to variadic function, cast to `c_int` [E0617]\n+        //~^ ERROR can't pass `i8` to variadic function\n+        //~| HELP cast the value to `c_int`\n         printf(::std::ptr::null(), 0i16);\n-        //~^ ERROR can't pass `i16` to variadic function, cast to `c_int` [E0617]\n+        //~^ ERROR can't pass `i16` to variadic function\n+        //~| HELP cast the value to `c_int`\n         printf(::std::ptr::null(), 0u8);\n-        //~^ ERROR can't pass `u8` to variadic function, cast to `c_uint` [E0617]\n+        //~^ ERROR can't pass `u8` to variadic function\n+        //~| HELP cast the value to `c_uint`\n         printf(::std::ptr::null(), 0u16);\n-        //~^ ERROR can't pass `u16` to variadic function, cast to `c_uint` [E0617]\n+        //~^ ERROR can't pass `u16` to variadic function\n+        //~| HELP cast the value to `c_uint`\n         printf(::std::ptr::null(), printf);\n-        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function, cast to `unsafe extern \"C\" fn(*const i8, ...)` [E0617]\n+        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n+        //~| HELP cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n     }\n }"}, {"sha": "18cfd00180428dc857edcfee44aae3a81a5f0b9c", "filename": "src/test/compile-fail/dep-graph-variance-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -23,7 +23,7 @@ struct Foo<T> {\n     f: T\n }\n \n-#[rustc_if_this_changed]\n+#[rustc_if_this_changed(Krate)]\n type TypeAlias<T> = Foo<T>;\n \n #[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK"}, {"sha": "53b24e1731932227e4085ac4072f134eda6b8e81", "filename": "src/test/compile-fail/empty-never-array.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-never-array.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+enum Helper<T, U> {\n+    T(T, [!; 0]),\n+    #[allow(dead_code)]\n+    U(U),\n+}\n+\n+fn transmute<T, U>(t: T) -> U {\n+    let Helper::U(u) = Helper::T(t, []);\n+    //~^ ERROR refutable pattern in local binding: `T(_, _)` not covered\n+    u\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", transmute::<&str, (*const u8, u64)>(\"type safety\"));\n+}"}, {"sha": "abde9689bd6b6607dbc84f17f2df5a8c68ed0dcb", "filename": "src/test/compile-fail/impl-trait/infinite-impl-trait-issue-38064.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that attempts to construct infinite types via impl trait fail\n+// in a graceful way.\n+//\n+// Regression test for #38064.\n+\n+// error-pattern:overflow evaluating the requirement `impl Quux`\n+\n+#![feature(conservative_impl_trait)]\n+\n+trait Quux {}\n+\n+fn foo() -> impl Quux {\n+    struct Foo<T>(T);\n+    impl<T> Quux for Foo<T> {}\n+    Foo(bar())\n+}\n+\n+fn bar() -> impl Quux {\n+    struct Bar<T>(T);\n+    impl<T> Quux for Bar<T> {}\n+    Bar(foo())\n+}\n+\n+// effectively:\n+//     struct Foo(Bar);\n+//     struct Bar(Foo);\n+// should produce an error about infinite size\n+\n+fn main() { foo(); }"}, {"sha": "bf9f8ecbc8097c6eecb47cfb7c1f00b145d295e0", "filename": "src/test/compile-fail/issue-32201.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fissue-32201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fissue-32201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32201.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -17,6 +17,7 @@ fn bar(_: *const u8) {}\n fn main() {\n     unsafe {\n         foo(0, bar);\n-        //~^ ERROR can't pass `fn(*const u8) {bar}` to variadic function, cast to `fn(*const u8)`\n+        //~^ ERROR can't pass `fn(*const u8) {bar}` to variadic function\n+        //~| HELP cast the value to `fn(*const u8)`\n     }\n }"}, {"sha": "b90dec9281bc1f2fec3a86ac5e029876bd5e35ab", "filename": "src/test/compile-fail/panic-runtime/auxiliary/depends.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fdepends.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fdepends.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fdepends.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "previous_filename": "src/test/compile-fail/panic-runtime/auxiliary/runtime-depending-on-panic-runtime.rs"}, {"sha": "7cfdacbd983c103151784376f9a492a59ea66f59", "filename": "src/test/compile-fail/panic-runtime/runtime-depend-on-needs-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // aux-build:needs-panic-runtime.rs\n-// aux-build:runtime-depending-on-panic-runtime.rs\n+// aux-build:depends.rs\n // error-pattern:cannot depend on a crate that needs a panic runtime\n \n-extern crate runtime_depending_on_panic_runtime;\n+extern crate depends;"}, {"sha": "fda96a8b1fb5eb0bad399e2cbe0d971161c01ece", "filename": "src/test/run-make/codegen-options-parsing/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -16,11 +16,11 @@ all:\n \t$(RUSTC) -C extra-filename=foo dummy.rs 2>&1\n \t#Option taking no argument\n \t$(RUSTC) -C lto= dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto=1 dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto=foo dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto dummy.rs\n \n \t# Should not link dead code..."}, {"sha": "78e3025b99ad4b376256f07fa8132b3cb826e95e", "filename": "src/test/run-make/no-integrated-as/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fno-integrated-as%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fno-integrated-as%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-integrated-as%2FMakefile?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n+\t$(RUSTC) hello.rs -C no_integrated_as\n+\t$(call RUN,hello)\n+endif"}, {"sha": "68e7f6d94d139ba305aafeefd5fc93317479072e", "filename": "src/test/run-make/no-integrated-as/hello.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fno-integrated-as%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-make%2Fno-integrated-as%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-integrated-as%2Fhello.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "15e3b4b03eb27b0a68e01e4708ed67b81cf76d41", "filename": "src/test/run-pass/align-with-extern-c-fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Falign-with-extern-c-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Falign-with-extern-c-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-with-extern-c-fn.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -14,10 +14,10 @@\n #![feature(attr_literals)]\n \n #[repr(align(16))]\n-pub struct A {\n-    y: i64,\n-}\n+pub struct A(i64);\n \n pub extern \"C\" fn foo(x: A) {}\n \n-fn main() {}\n+fn main() {\n+    foo(A(0));\n+}"}, {"sha": "9eeb815c5de88a0088256dd66b1fb51d6100dd59", "filename": "src/test/run-pass/auxiliary/trait_xc_call_aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftrait_xc_call_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftrait_xc_call_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftrait_xc_call_aux.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "previous_filename": "src/test/run-pass/auxiliary/trait_inheritance_cross_trait_call_xc_aux.rs"}, {"sha": "1efbfb927fa75631ae0c00002b5fe70b3441389d", "filename": "src/test/run-pass/conditional-compile-arch.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -28,6 +28,9 @@ pub fn main() { }\n #[cfg(target_arch = \"mips64\")]\n pub fn main() { }\n \n+#[cfg(target_arch = \"powerpc\")]\n+pub fn main() { }\n+\n #[cfg(target_arch = \"powerpc64\")]\n pub fn main() { }\n "}, {"sha": "453eede261cc084f2252e2ca56af513744467a7f", "filename": "src/test/run-pass/fat-lto.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Ffat-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Ffat-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-lto.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Clto=fat\n+// no-prefer-dynamic\n+\n+fn main() {\n+    println!(\"hello!\");\n+}\n+"}, {"sha": "5a6a6e0163ede85fa03583c5c9ab652d9bac27fb", "filename": "src/test/run-pass/intrinsic-alignment.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -19,7 +19,8 @@ mod rusti {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\",\n+#[cfg(any(target_os = \"android\",\n+          target_os = \"cloudabi\",\n           target_os = \"dragonfly\",\n           target_os = \"emscripten\",\n           target_os = \"freebsd\",\n@@ -80,15 +81,3 @@ mod m {\n         }\n     }\n }\n-\n-#[cfg(target_os = \"android\")]\n-mod m {\n-    #[main]\n-    #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n-    pub fn main() {\n-        unsafe {\n-            assert_eq!(::rusti::pref_align_of::<u64>(), 8);\n-            assert_eq!(::rusti::min_align_of::<u64>(), 8);\n-        }\n-    }\n-}"}, {"sha": "01cc8265a399fbed44fc98f4f8b598b3600f298c", "filename": "src/test/run-pass/issue-38763.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-38763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-38763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38763.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+#![feature(i128_type)]\n+\n+#[repr(C)]\n+pub struct Foo(i128);\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo(x: Foo) -> Foo { x }\n+\n+fn main() {\n+    foo(Foo(1));\n+}"}, {"sha": "2847ac2a0ba43d39ee1fbee395f52dba3dbec3d6", "filename": "src/test/run-pass/issue-47364.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-47364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-47364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47364.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C codegen-units=8 -O\n+\n+fn main() {\n+    nom_sql::selection(b\"x \");\n+}\n+\n+pub enum Err<P>{\n+    Position(P),\n+    NodePosition(u32),\n+}\n+\n+pub enum IResult<I,O> {\n+    Done(I,O),\n+    Error(Err<I>),\n+    Incomplete(u32, u64)\n+}\n+\n+pub fn multispace<T: Copy>(input: T) -> ::IResult<i8, i8> {\n+    ::IResult::Done(0, 0)\n+}\n+\n+mod nom_sql {\n+    fn where_clause(i: &[u8]) -> ::IResult<&[u8], Option<String>> {\n+        let X = match ::multispace(i) {\n+            ::IResult::Done(..) => ::IResult::Done(i, None::<String>),\n+            _ => ::IResult::Error(::Err::NodePosition(0)),\n+        };\n+        match X {\n+            ::IResult::Done(_, _) => ::IResult::Done(i, None),\n+            _ => X\n+        }\n+    }\n+\n+    pub fn selection(i: &[u8]) {\n+        let Y = match {\n+            match {\n+                where_clause(i)\n+            } {\n+                ::IResult::Done(_, o) => ::IResult::Done(i, Some(o)),\n+                ::IResult::Error(_) => ::IResult::Done(i, None),\n+                _ => ::IResult::Incomplete(0, 0),\n+            }\n+        } {\n+            ::IResult::Done(z, _) => ::IResult::Done(z, None::<String>),\n+            _ => return ()\n+        };\n+        match Y {\n+            ::IResult::Done(x, _) => {\n+                let bytes = b\";   \";\n+                let len = x.len();\n+                bytes[len];\n+            }\n+            _ => ()\n+        }\n+    }\n+}"}, {"sha": "92f54a44f63c94ae0af9c11fbba66de1f0e2b1ef", "filename": "src/test/run-pass/issue-47673.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-47673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fissue-47673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47673.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_nested_groups)]\n+#![allow(unused_import)]\n+\n+use {{}, {}};\n+\n+fn main() {}"}, {"sha": "85c1b2adb79ec058c800ec27ebb9daec19040776", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -38,7 +38,8 @@ struct Outer {\n }\n \n \n-#[cfg(any(target_os = \"cloudabi\",\n+#[cfg(any(target_os = \"android\",\n+          target_os = \"cloudabi\",\n           target_os = \"dragonfly\",\n           target_os = \"emscripten\",\n           target_os = \"freebsd\",\n@@ -85,15 +86,6 @@ mod m {\n     }\n }\n \n-#[cfg(target_os = \"android\")]\n-mod m {\n-    #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n-    pub mod m {\n-        pub fn align() -> usize { 8 }\n-        pub fn size() -> usize { 16 }\n-    }\n-}\n-\n pub fn main() {\n     unsafe {\n         let x = Outer {c8: 22, t: Inner {c64: 44}};"}, {"sha": "eae431aa4044d2d507aefee2de554e9cedf645f5", "filename": "src/test/run-pass/signal-alternate-stack-cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     unsafe {\n         // Install signal hander that runs on alternate signal stack.\n         let mut action: sigaction = std::mem::zeroed();\n-        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+        action.sa_flags = (SA_ONSTACK | SA_SIGINFO) as _;\n         action.sa_sigaction = signal_handler as sighandler_t;\n         sigaction(SIGWINCH, &action, std::ptr::null_mut());\n "}, {"sha": "2c9ef59709dbf4e13ceaf032ff3d61a5abd57edf", "filename": "src/test/run-pass/simd-target-feature-mixup.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,188 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+#![feature(repr_simd, target_feature, cfg_target_feature)]\n+\n+use std::process::{Command, ExitStatus};\n+use std::env;\n+\n+fn main() {\n+    if let Some(level) = env::args().nth(1) {\n+        return test::main(&level)\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    for level in [\"sse\", \"avx\", \"avx512\"].iter() {\n+        let status = Command::new(&me).arg(level).status().unwrap();\n+        if status.success() {\n+            println!(\"success with {}\", level);\n+            continue\n+        }\n+\n+        // We don't actually know if our computer has the requisite target features\n+        // for the test below. Testing for that will get added to libstd later so\n+        // for now just asume sigill means this is a machine that can't run this test.\n+        if is_sigill(status) {\n+            println!(\"sigill with {}, assuming spurious\", level);\n+            continue\n+        }\n+        panic!(\"invalid status at {}: {}\", level, status);\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    use std::os::unix::prelude::*;\n+    status.signal() == Some(4)\n+}\n+\n+#[cfg(windows)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    status.code() == Some(0xc000001d)\n+}\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[allow(bad_style)]\n+mod test {\n+    // An SSE type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m128i(u64, u64);\n+\n+    // An AVX type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m256i(u64, u64, u64, u64);\n+\n+    // An AVX-512 type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m512i(u64, u64, u64, u64, u64, u64, u64, u64);\n+\n+    pub fn main(level: &str) {\n+        unsafe {\n+            main_normal(level);\n+            main_sse(level);\n+            if level == \"sse\" {\n+                return\n+            }\n+            main_avx(level);\n+            if level == \"avx\" {\n+                return\n+            }\n+            main_avx512(level);\n+        }\n+    }\n+\n+    macro_rules! mains {\n+        ($(\n+            $(#[$attr:meta])*\n+            unsafe fn $main:ident(level: &str) {\n+                ...\n+            }\n+        )*) => ($(\n+            $(#[$attr])*\n+            unsafe fn $main(level: &str) {\n+                let m128 = __m128i(1, 2);\n+                let m256 = __m256i(3, 4, 5, 6);\n+                let m512 = __m512i(7, 8, 9, 10, 11, 12, 13, 14);\n+                assert_eq!(id_sse_128(m128), m128);\n+                assert_eq!(id_sse_256(m256), m256);\n+                assert_eq!(id_sse_512(m512), m512);\n+\n+                if level == \"sse\" {\n+                    return\n+                }\n+                assert_eq!(id_avx_128(m128), m128);\n+                assert_eq!(id_avx_256(m256), m256);\n+                assert_eq!(id_avx_512(m512), m512);\n+\n+                if level == \"avx\" {\n+                    return\n+                }\n+                assert_eq!(id_avx512_128(m128), m128);\n+                assert_eq!(id_avx512_256(m256), m256);\n+                assert_eq!(id_avx512_512(m512), m512);\n+            }\n+        )*)\n+    }\n+\n+    mains! {\n+        unsafe fn main_normal(level: &str) { ... }\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn main_sse(level: &str) { ... }\n+        #[target_feature(enable = \"avx\")]\n+        unsafe fn main_avx(level: &str) { ... }\n+        #[target_feature(enable = \"avx512bw\")]\n+        unsafe fn main_avx512(level: &str) { ... }\n+    }\n+\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+}\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+mod test {\n+    pub fn main(level: &str) {}\n+}"}, {"sha": "772a9ec8293e4becbb76955de1d059473206ee70", "filename": "src/test/run-pass/thinlto/all-crates.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Clto=thin\n+// no-prefer-dynamic\n+// min-llvm-version 4.0\n+\n+fn main() {\n+    println!(\"hello!\");\n+}"}, {"sha": "6020f72415dad2740d2d543a8ec2c4fef1a7d29e", "filename": "src/test/run-pass/thinlto/thin-lto-inlines2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z thinlto -C codegen-units=8 -O -C lto\n+// compile-flags: -C codegen-units=8 -O -C lto=thin\n // aux-build:thin-lto-inlines-aux.rs\n // min-llvm-version 4.0\n // no-prefer-dynamic"}, {"sha": "3e68bea57c660d8481309a27d52767303c5ae46b", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call-xc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:trait_inheritance_cross_trait_call_xc_aux.rs\n+// aux-build:trait_xc_call_aux.rs\n \n \n-extern crate trait_inheritance_cross_trait_call_xc_aux as aux;\n+extern crate trait_xc_call_aux as aux;\n \n use aux::Foo;\n "}, {"sha": "34b98a758df9dd5d237a8b16aadc32f692bfb73f", "filename": "src/test/rustdoc-js/from_u.js", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc-js%2Ffrom_u.js", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc-js%2Ffrom_u.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Ffrom_u.js?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -15,7 +15,5 @@ const EXPECTED = {\n         { 'path': 'std::char', 'name': 'from_u32' },\n         { 'path': 'std::str', 'name': 'from_utf8' },\n         { 'path': 'std::string::String', 'name': 'from_utf8' },\n-        { 'path': 'std::i32', 'name': 'from_unsigned' },\n-        { 'path': 'std::i128', 'name': 'from_unsigned' },\n     ],\n };"}, {"sha": "e0d53a72220f9629883571da0dbc312dcfdd6b48", "filename": "src/test/rustdoc/auxiliary/masked.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone)]\n+pub struct MaskedStruct;\n+\n+pub trait MaskedTrait {\n+    fn masked_method();\n+}\n+\n+impl MaskedTrait for String {\n+    fn masked_method() {}\n+}"}, {"sha": "4726323e11cef839a2170d109a94a4b85f58224d", "filename": "src/test/rustdoc/intra-links.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fintra-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fintra-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -10,7 +10,13 @@\n \n // @has intra_links/index.html\n // @has - '//a/@href' '../intra_links/struct.ThisType.html'\n+// @has - '//a/@href' '../intra_links/struct.ThisType.html#method.this_method'\n // @has - '//a/@href' '../intra_links/enum.ThisEnum.html'\n+// @has - '//a/@href' '../intra_links/enum.ThisEnum.html#ThisVariant.v'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#tymethod.this_associated_method'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n // @has - '//a/@href' '../intra_links/trait.ThisTrait.html'\n // @has - '//a/@href' '../intra_links/type.ThisAlias.html'\n // @has - '//a/@href' '../intra_links/union.ThisUnion.html'\n@@ -23,8 +29,13 @@\n //! In this crate we would like to link to:\n //!\n //! * [`ThisType`](ThisType)\n+//! * [`ThisType::this_method`](ThisType::this_method)\n //! * [`ThisEnum`](ThisEnum)\n+//! * [`ThisEnum::ThisVariant`](ThisEnum::ThisVariant)\n //! * [`ThisTrait`](ThisTrait)\n+//! * [`ThisTrait::this_associated_method`](ThisTrait::this_associated_method)\n+//! * [`ThisTrait::ThisAssociatedType`](ThisTrait::ThisAssociatedType)\n+//! * [`ThisTrait::THIS_ASSOCIATED_CONST`](ThisTrait::THIS_ASSOCIATED_CONST)\n //! * [`ThisAlias`](ThisAlias)\n //! * [`ThisUnion`](ThisUnion)\n //! * [`this_function`](this_function())\n@@ -45,8 +56,16 @@ macro_rules! this_macro {\n }\n \n pub struct ThisType;\n+\n+impl ThisType {\n+    pub fn this_method() {}\n+}\n pub enum ThisEnum { ThisVariant, }\n-pub trait ThisTrait {}\n+pub trait ThisTrait {\n+    type ThisAssociatedType;\n+    const THIS_ASSOCIATED_CONST: u8;\n+    fn this_associated_method();\n+}\n pub type ThisAlias = Result<(), ()>;\n pub union ThisUnion { this_field: usize, }\n "}, {"sha": "1f398da84e57ed1e7eb86e34e0b554e7599aa118", "filename": "src/test/rustdoc/masked.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fmasked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Frustdoc%2Fmasked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmasked.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:masked.rs\n+\n+#![feature(doc_masked)]\n+\n+#![crate_name = \"foo\"]\n+\n+#[doc(masked)]\n+extern crate masked;\n+\n+// @!has 'search-index.js' 'masked_method'\n+\n+// @!has 'foo/struct.String.html' 'MaskedTrait'\n+// @!has 'foo/struct.String.html' 'masked_method'\n+pub use std::string::String;\n+\n+// @!has 'foo/trait.Clone.html' 'MaskedStruct'\n+pub use std::clone::Clone;\n+\n+// @!has 'foo/struct.MyStruct.html' 'MaskedTrait'\n+// @!has 'foo/struct.MyStruct.html' 'masked_method'\n+pub struct MyStruct;\n+\n+impl masked::MaskedTrait for MyStruct {\n+    fn masked_method() {}\n+}\n+\n+// @!has 'foo/trait.MyTrait.html' 'MaskedStruct'\n+pub trait MyTrait {}\n+\n+impl MyTrait for masked::MaskedStruct {}"}, {"sha": "df4ff301bc9ce1995027a646e8730738eeb4b031", "filename": "src/test/ui/issue-47511.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47511.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #47511: anonymous lifetimes can appear\n+// unconstrained in a return type, but only if they appear just once\n+// in the input, as the input to a projection.\n+\n+fn f(_: X) -> X {\n+    //~^ ERROR return type references an anonymous lifetime\n+    unimplemented!()\n+}\n+\n+fn g<'a>(_: X<'a>) -> X<'a> {\n+    //~^ ERROR return type references lifetime `'a`, which is not constrained\n+    unimplemented!()\n+}\n+\n+type X<'a> = <&'a () as Trait>::Value;\n+\n+trait Trait {\n+    type Value;\n+}\n+\n+impl<'a> Trait for &'a () {\n+    type Value = ();\n+}\n+\n+fn main() {}"}, {"sha": "fabd6b6c25396d26aae3ecb3ed8a2be267570b02", "filename": "src/test/ui/issue-47511.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47511.stderr?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,16 @@\n+error[E0581]: return type references an anonymous lifetime which is not constrained by the fn input types\n+  --> $DIR/issue-47511.rs:15:15\n+   |\n+15 | fn f(_: X) -> X {\n+   |               ^\n+   |\n+   = note: lifetimes appearing in an associated type are not considered constrained\n+\n+error[E0581]: return type references lifetime `'a`, which is not constrained by the fn input types\n+  --> $DIR/issue-47511.rs:20:23\n+   |\n+20 | fn g<'a>(_: X<'a>) -> X<'a> {\n+   |                       ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "24a0f66f5b1c445514c09fc4605cb2baa445b032", "filename": "src/test/ui/issue-47706.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo {\n+    foo: Option<i32>,\n+}\n+\n+impl Foo {\n+    pub fn new(foo: Option<i32>, _: ()) -> Foo {\n+        Foo { foo }\n+    }\n+\n+    pub fn map(self) -> Option<Foo> {\n+        self.foo.map(Foo::new)\n+    }\n+    //~^^ ERROR function is expected to take 1 argument, but it takes 2 arguments [E0593]\n+}"}, {"sha": "0916dc64292e3ae0c2b370dbb68ffdae0518661a", "filename": "src/test/ui/issue-47706.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fissue-47706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.stderr?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -0,0 +1,13 @@\n+error[E0601]: main function not found\n+\n+error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n+  --> $DIR/issue-47706.rs:21:18\n+   |\n+16 |     pub fn new(foo: Option<i32>, _: ()) -> Foo {\n+   |     ------------------------------------------ takes 2 arguments\n+...\n+21 |         self.foo.map(Foo::new)\n+   |                  ^^^ expected function that takes 1 argument\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9807952c636e1dfc521914861abee0a75bd99154", "filename": "src/test/ui/variadic-ffi-3.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariadic-ffi-3.rs?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -31,11 +31,11 @@ fn main() {\n         //~| expected type `extern \"C\" fn(isize, u8, ...)`\n         //~| found type `extern \"C\" fn(isize, u8) {bar}`\n \n-        foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function, cast to `c_double`\n-        foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function, cast to `c_int`\n-        foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function, cast to `c_int`\n-        foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function, cast to `c_uint`\n-        foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function, cast to `c_int`\n-        foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function, cast to `c_uint`\n+        foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n+        foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function\n+        foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function\n+        foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function\n+        foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function\n+        foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function\n     }\n }"}, {"sha": "54275fbc4f29f70fdfbf50812884f259547c05e7", "filename": "src/test/ui/variadic-ffi-3.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c/src%2Ftest%2Fui%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariadic-ffi-3.stderr?ref=bacb5c58dfdde7c35e99b2b0d8171238cc33cf6c", "patch": "@@ -34,41 +34,41 @@ error[E0308]: mismatched types\n    = note: expected type `extern \"C\" fn(isize, u8, ...)`\n               found type `extern \"C\" fn(isize, u8) {bar}`\n \n-error[E0617]: can't pass `f32` to variadic function, cast to `c_double`\n+error[E0617]: can't pass `f32` to variadic function\n   --> $DIR/variadic-ffi-3.rs:34:19\n    |\n-34 |         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function, cast to `c_double`\n-   |                   ^^^^\n+34 |         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n+   |                   ^^^^ help: cast the value to `c_double`: `3f32 as c_double`\n \n-error[E0617]: can't pass `bool` to variadic function, cast to `c_int`\n+error[E0617]: can't pass `bool` to variadic function\n   --> $DIR/variadic-ffi-3.rs:35:19\n    |\n-35 |         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function, cast to `c_int`\n-   |                   ^^^^\n+35 |         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function\n+   |                   ^^^^ help: cast the value to `c_int`: `true as c_int`\n \n-error[E0617]: can't pass `i8` to variadic function, cast to `c_int`\n+error[E0617]: can't pass `i8` to variadic function\n   --> $DIR/variadic-ffi-3.rs:36:19\n    |\n-36 |         foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function, cast to `c_int`\n-   |                   ^^^\n+36 |         foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function\n+   |                   ^^^ help: cast the value to `c_int`: `1i8 as c_int`\n \n-error[E0617]: can't pass `u8` to variadic function, cast to `c_uint`\n+error[E0617]: can't pass `u8` to variadic function\n   --> $DIR/variadic-ffi-3.rs:37:19\n    |\n-37 |         foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function, cast to `c_uint`\n-   |                   ^^^\n+37 |         foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function\n+   |                   ^^^ help: cast the value to `c_uint`: `1u8 as c_uint`\n \n-error[E0617]: can't pass `i16` to variadic function, cast to `c_int`\n+error[E0617]: can't pass `i16` to variadic function\n   --> $DIR/variadic-ffi-3.rs:38:19\n    |\n-38 |         foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function, cast to `c_int`\n-   |                   ^^^^\n+38 |         foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function\n+   |                   ^^^^ help: cast the value to `c_int`: `1i16 as c_int`\n \n-error[E0617]: can't pass `u16` to variadic function, cast to `c_uint`\n+error[E0617]: can't pass `u16` to variadic function\n   --> $DIR/variadic-ffi-3.rs:39:19\n    |\n-39 |         foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function, cast to `c_uint`\n-   |                   ^^^^\n+39 |         foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function\n+   |                   ^^^^ help: cast the value to `c_uint`: `1u16 as c_uint`\n \n error: aborting due to 10 previous errors\n "}]}