{"sha": "fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlODUzNDJlZjZjMDRhZWIzNWIwZDBkYmRlODI3OTFmMWE4NzIxYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T23:10:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T23:10:06Z"}, "message": "Auto merge of #25688 - nham:E0055_E0192, r=alexcrichton\n\n - Adds explanations for E0055, E0089, E0192, E0261-E0263, E0318\r\n - Improves explanations for E0250, E0368, E0372.\r\n - Converts 15 diagnostics to have error codes (E0380-E0394). Adds an explanation for E0380.\r\n - The E0087-E0090 messages currently look like \"expected {} parameter(s) found {} parameter(s)\". This changes them to either use \"parameter\" or \"parameters\", based on the number.\r\n\r\nThis is, in part, more progress towards #24407", "tree": {"sha": "af9ed9d47c7129008fb8ba1c41a72cda3a682d7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af9ed9d47c7129008fb8ba1c41a72cda3a682d7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "html_url": "https://github.com/rust-lang/rust/commit/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cccc137b888af7561687aae7e6af3ed32461c160", "url": "https://api.github.com/repos/rust-lang/rust/commits/cccc137b888af7561687aae7e6af3ed32461c160", "html_url": "https://github.com/rust-lang/rust/commit/cccc137b888af7561687aae7e6af3ed32461c160"}, {"sha": "570a0435765864e2e51c8f953a645c544e9afdd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/570a0435765864e2e51c8f953a645c544e9afdd4", "html_url": "https://github.com/rust-lang/rust/commit/570a0435765864e2e51c8f953a645c544e9afdd4"}], "stats": {"total": 335, "additions": 240, "deletions": 95}, "files": [{"sha": "9d459027bf5cdfa7360281ceb1c78337ea0b74e9", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -396,6 +396,54 @@ enum Method { GET, POST }\n ```\n \"##,\n \n+E0261: r##\"\n+When using a lifetime like `'a` in a type, it must be declared before being\n+used.\n+\n+These two examples illustrate the problem:\n+\n+```\n+// error, use of undeclared lifetime name `'a`\n+fn foo(x: &'a str) { }\n+\n+struct Foo {\n+    // error, use of undeclared lifetime name `'a`\n+    x: &'a str,\n+}\n+```\n+\n+These can be fixed by declaring lifetime parameters:\n+\n+```\n+fn foo<'a>(x: &'a str) { }\n+\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+```\n+\"##,\n+\n+E0262: r##\"\n+Declaring certain lifetime names in parameters is disallowed. For example,\n+because the `'static` lifetime is a special built-in lifetime name denoting\n+the lifetime of the entire program, this is an error:\n+\n+```\n+// error, illegal lifetime parameter name `'static`\n+fn foo<'static>(x: &'static str) { }\n+```\n+\"##,\n+\n+E0263: r##\"\n+A lifetime name cannot be declared more than once in the same scope. For\n+example:\n+\n+```\n+// error, lifetime name `'a` declared twice in the same scope\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n+```\n+\"##,\n+\n E0265: r##\"\n This error indicates that a static or constant references itself.\n All statics and constants need to resolve to a value in an acyclic manner.\n@@ -814,9 +862,6 @@ register_diagnostics! {\n     E0136,\n     E0138,\n     E0139,\n-    E0261, // use of undeclared lifetime name\n-    E0262, // illegal lifetime parameter name\n-    E0263, // lifetime name declared twice in same scope\n     E0264, // unknown external lang item\n     E0266, // expected item\n     E0269, // not all control paths return a value\n@@ -846,5 +891,7 @@ register_diagnostics! {\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n     E0370, // discriminant overflow\n-    E0378  // method calls limited to constant inherent methods\n+    E0378, // method calls limited to constant inherent methods\n+    E0394  // cannot refer to other statics by value, use the address-of\n+           // operator or a constant instead\n }"}, {"sha": "c54517e00173b21f7fccd46c9b7b7f68139d4ede", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -762,9 +762,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                         // statics cannot be consumed by value at any time, that would imply\n                         // that they're an initializer (what a const is for) or kept in sync\n                         // over time (not feasible), so deny it outright.\n-                        self.tcx.sess.span_err(consume_span,\n-                            \"cannot refer to other statics by value, use the \\\n-                             address-of operator or a constant instead\");\n+                        span_err!(self.tcx.sess, consume_span, E0394,\n+                                  \"cannot refer to other statics by value, use the \\\n+                                   address-of operator or a constant instead\");\n                     }\n                     break;\n                 }"}, {"sha": "472aff6625bc70fbdee887760ce878ca2e12a545", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -603,11 +603,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         let (ol, moved_lp_msg) = match the_move.kind {\n             move_data::Declared => {\n-                self.tcx.sess.span_err(\n-                    use_span,\n-                    &format!(\"{} of possibly uninitialized variable: `{}`\",\n-                            verb,\n-                            self.loan_path_to_string(lp)));\n+                span_err!(\n+                    self.tcx.sess, use_span, E0381,\n+                    \"{} of possibly uninitialized variable: `{}`\",\n+                    verb,\n+                    self.loan_path_to_string(lp));\n+\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -644,12 +645,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n                           else { \"\" };\n-                self.tcx.sess.span_err(\n-                    use_span,\n-                    &format!(\"{} of {}moved value: `{}`\",\n-                            verb,\n-                            msg,\n-                            nl));\n+                span_err!(\n+                    self.tcx.sess, use_span, E0382,\n+                    \"{} of {}moved value: `{}`\",\n+                    verb, msg, nl);\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -762,23 +761,21 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        self.tcx\n-            .sess\n-            .span_err(span,\n-                      &format!(\"partial reinitialization of uninitialized \\\n-                               structure `{}`\",\n-                               self.loan_path_to_string(lp)));\n+        span_err!(\n+            self.tcx.sess, span, E0383,\n+            \"partial reinitialization of uninitialized structure `{}`\",\n+            self.loan_path_to_string(lp));\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n                                                 span: Span,\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        self.tcx.sess.span_err(\n-            span,\n-            &format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp)));\n+        span_err!(\n+            self.tcx.sess, span, E0384,\n+            \"re-assignment of immutable variable `{}`\",\n+            self.loan_path_to_string(lp));\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -896,21 +893,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         match cause {\n             mc::AliasableOther => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"{} in an aliasable location\",\n-                             prefix));\n+                span_err!(\n+                    self.tcx.sess, span, E0385,\n+                    \"{} in an aliasable location\", prefix);\n             }\n             mc::AliasableReason::UnaliasableImmutable => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"{} in an immutable container\",\n-                             prefix));\n+                span_err!(\n+                    self.tcx.sess, span, E0386,\n+                    \"{} in an immutable container\", prefix);\n             }\n             mc::AliasableClosure(id) => {\n-                self.tcx.sess.span_err(span,\n-                                       &format!(\"{} in a captured outer \\\n-                                                variable in an `Fn` closure\", prefix));\n+                span_err!(\n+                    self.tcx.sess, span, E0387,\n+                    \"{} in a captured outer variable in an `Fn` closure\", prefix);\n                 if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n@@ -925,14 +920,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"{} in a static location\", prefix));\n+                span_err!(\n+                    self.tcx.sess, span, E0388,\n+                    \"{} in a static location\", prefix);\n             }\n             mc::AliasableBorrowed => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"{} in a `&` reference\", prefix));\n+                span_err!(\n+                    self.tcx.sess, span, E0389,\n+                    \"{} in a `&` reference\", prefix);\n             }\n         }\n "}, {"sha": "3e7cfe3ee7f88aaa8bacbaf24992108d36bdc108", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -10,6 +10,31 @@\n \n #![allow(non_snake_case)]\n \n+register_long_diagnostics! {\n+\n+E0381: r##\"\n+It is not allowed to use or capture an uninitialized variable. For example:\n+\n+```\n+fn main() {\n+    let x: i32;\n+    let y = x; // error, use of possibly uninitialized variable\n+```\n+\n+To fix this, ensure that any declared variables are initialized before being\n+used.\n+\"##\n+\n+}\n+\n register_diagnostics! {\n-    E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n+    E0373, // closure may outlive current fn, but it borrows {}, which is owned by current fn\n+    E0382, // use of partially/collaterally moved value\n+    E0383, // partial reinitialization of uninitialized structure\n+    E0384, // reassignment of immutable variable\n+    E0385, // {} in an aliasable location\n+    E0386, // {} in an immutable container\n+    E0387, // {} in a captured outer variable in an `Fn` closure\n+    E0388, // {} in a static location\n+    E0389  // {} in a `&` reference\n }"}, {"sha": "90bbd1af4efd035f43aea82d0a854dd854acbe5a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -437,13 +437,12 @@ fn create_substs_for_ast_path<'tcx>(\n             // defaults. This will lead to an ICE if we are not\n             // careful!\n             if self_ty.is_none() && ty::type_has_self(default) {\n-                tcx.sess.span_err(\n-                    span,\n-                    &format!(\"the type parameter `{}` must be explicitly specified \\\n-                              in an object type because its default value `{}` references \\\n-                              the type `Self`\",\n-                             param.name.user_string(tcx),\n-                             default.user_string(tcx)));\n+                span_err!(tcx.sess, span, E0393,\n+                          \"the type parameter `{}` must be explicitly specified \\\n+                           in an object type because its default value `{}` references \\\n+                           the type `Self`\",\n+                          param.name.user_string(tcx),\n+                          default.user_string(tcx));\n                 substs.types.push(TypeSpace, tcx.types.err);\n             } else {\n                 // This is a default type parameter."}, {"sha": "af3d8894c74d1e6889222286769344366b39e246", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -4688,9 +4688,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else if i == type_count {\n                     span_err!(fcx.tcx().sess, typ.span, E0087,\n                         \"too many type parameters provided: \\\n-                         expected at most {} parameter(s), \\\n-                         found {} parameter(s)\",\n-                         type_count, data.types.len());\n+                         expected at most {} parameter{}, \\\n+                         found {} parameter{}\",\n+                         type_count,\n+                         if type_count == 1 {\"\"} else {\"s\"},\n+                         data.types.len(),\n+                         if data.types.len() == 1 {\"\"} else {\"s\"});\n                     substs.types.truncate(space, 0);\n                     break;\n                 }\n@@ -4713,9 +4716,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else if i == region_count {\n                     span_err!(fcx.tcx().sess, lifetime.span, E0088,\n                         \"too many lifetime parameters provided: \\\n-                         expected {} parameter(s), found {} parameter(s)\",\n+                         expected {} parameter{}, found {} parameter{}\",\n                         region_count,\n-                        data.lifetimes.len());\n+                        if region_count == 1 {\"\"} else {\"s\"},\n+                        data.lifetimes.len(),\n+                        if data.lifetimes.len() == 1 {\"\"} else {\"s\"});\n                     substs.mut_regions().truncate(space, 0);\n                     break;\n                 }\n@@ -4805,9 +4810,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let qualifier =\n                 if desired.len() != required_len { \"at least \" } else { \"\" };\n             span_err!(fcx.tcx().sess, span, E0089,\n-                \"too few type parameters provided: expected {}{} parameter(s) \\\n-                , found {} parameter(s)\",\n-                qualifier, required_len, provided_len);\n+                \"too few type parameters provided: expected {}{} parameter{}, \\\n+                 found {} parameter{}\",\n+                qualifier, required_len,\n+                if required_len == 1 {\"\"} else {\"s\"},\n+                provided_len,\n+                if provided_len == 1 {\"\"} else {\"s\"});\n             substs.types.replace(space, repeat(fcx.tcx().types.err).take(desired.len()).collect());\n             return;\n         }\n@@ -4858,9 +4866,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Otherwise, too few were provided. Report an error and then\n         // use inference variables.\n         span_err!(fcx.tcx().sess, span, E0090,\n-            \"too few lifetime parameters provided: expected {} parameter(s), \\\n-             found {} parameter(s)\",\n-            desired.len(), provided_len);\n+            \"too few lifetime parameters provided: expected {} parameter{}, \\\n+             found {} parameter{}\",\n+            desired.len(),\n+            if desired.len() == 1 {\"\"} else {\"s\"},\n+            provided_len,\n+            if provided_len == 1 {\"\"} else {\"s\"});\n \n         substs.mut_regions().replace(\n             space,"}, {"sha": "405d43548b23af8fa9ef8e9f13c9b02dbe6e3782", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -124,10 +124,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n                 if ty::trait_has_default_impl(ccx.tcx, local_def(item.id)) {\n                     if !items.is_empty() {\n-                        ccx.tcx.sess.span_err(\n-                            item.span,\n-                            \"traits with default impls (`e.g. unsafe impl Trait for ..`) must \\\n-                            have no methods or associated items\")\n+                        span_err!(ccx.tcx.sess, item.span, E0380,\n+                                  \"traits with default impls (`e.g. unsafe impl \\\n+                                  Trait for ..`) must have no methods or associated items\")\n                     }\n                 }\n             }\n@@ -353,10 +352,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        self.tcx().sess.span_err(\n-            span,\n-            &format!(\"parameter `{}` is never used\",\n-                     param_name.user_string(self.tcx())));\n+        span_err!(self.tcx().sess, span, E0392,\n+            \"parameter `{}` is never used\", param_name.user_string(self.tcx()));\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {"}, {"sha": "7dc865ef8855cb3877a07567b9cb91f24c4ab27d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -48,10 +48,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n         match lang_def_id {\n             Some(lang_def_id) if lang_def_id == impl_def_id => { /* OK */ },\n             _ => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n-                              is allowed for the `{}` primitive\", lang, ty));\n+                span_err!(self.tcx.sess, span, E0390,\n+                          \"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n+                           is allowed for the `{}` primitive\", lang, ty);\n             }\n         }\n     }"}, {"sha": "42d1c122fba83b5cff4cb2f3128690674e9eed66", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -236,9 +236,8 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         assert!(!cycle.is_empty());\n         let tcx = self.tcx;\n \n-        tcx.sess.span_err(\n-            span,\n-            &format!(\"unsupported cyclic reference between types/traits detected\"));\n+        span_err!(tcx.sess, span, E0391,\n+            \"unsupported cyclic reference between types/traits detected\");\n \n         match cycle[0] {\n             AstConvRequest::GetItemTypeScheme(def_id) |"}, {"sha": "edfad77d588df1d40a394cce1cb5b98c243e3368", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 86, "deletions": 13, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -261,6 +261,37 @@ let x_is_nonzero = x as bool;\n ```\n \"##,\n \n+E0055: r##\"\n+During a method call, a value is automatically dereferenced as many times as\n+needed to make the value's type match the method's receiver. The catch is that\n+the compiler will only attempt to dereference a number of times up to the\n+recursion limit (which can be set via the `recursion_limit` attribute).\n+\n+For a somewhat artificial example:\n+\n+```\n+#![recursion_limit=\"2\"]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let ref_foo = &&Foo;\n+\n+    // error, reached the recursion limit while auto-dereferencing &&Foo\n+    ref_foo.foo();\n+}\n+```\n+\n+One fix may be to increase the recursion limit. Note that it is possible to\n+create an infinite recursion of dereferencing, in which case the only fix is to\n+somehow break the recursion.\n+\"##,\n+\n E0062: r##\"\n This error indicates that during an attempt to build a struct or struct-like\n enum variant, one of the fields was specified more than once. Each field should\n@@ -511,6 +542,31 @@ enum Empty {}\n ```\n \"##,\n \n+E0089: r##\"\n+Not enough type parameters were supplied for a function. For example:\n+\n+```\n+fn foo<T, U>() {}\n+\n+fn main() {\n+    foo::<f64>(); // error, expected 2 parameters, found 1 parameter\n+}\n+```\n+\n+Note that if a function takes multiple type parameters but you want the compiler\n+to infer some of them, you can use type placeholders:\n+\n+```\n+fn foo<T, U>(x: T) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter\n+    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n+}\n+```\n+\"##,\n+\n E0106: r##\"\n This error indicates that a lifetime is missing from a type. If it is an error\n inside a function signature, the problem may be with failing to adhere to the\n@@ -707,6 +763,12 @@ impl Foo for Bar {\n }\n \"##,\n \n+E0192: r##\"\n+Negative impls are only allowed for traits with default impls. For more\n+information see the [opt-in builtin traits RFC](https://github.com/rust-lang/\n+rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+\"##,\n+\n E0197: r##\"\n Inherent implementations (one that do not implement a trait but provide\n methods associated with a type) are always safe because they are not\n@@ -917,10 +979,10 @@ const C: [u32; 0.0] = []; // error\n \"##,\n \n E0250: r##\"\n-This means there was an error while evaluating the expression for the length of\n-a fixed-size array type.\n+There was an error while evaluating the expression for the length of a fixed-\n+size array type.\n \n-Some examples of code that produces this error are:\n+Some examples of this error are:\n \n ```\n // divide by zero in the length expression\n@@ -936,6 +998,12 @@ const C: [u32; u8::MAX + f64::EPSILON] = [];\n ```\n \"##,\n \n+E0318: r##\"\n+Default impls for a trait must be located in the same crate where the trait was\n+defined. For more information see the [opt-in builtin traits RFC](https://github\n+.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+\"##,\n+\n E0322: r##\"\n The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n@@ -964,9 +1032,7 @@ impl Foo for Bar {\n \n E0368: r##\"\n This error indicates that a binary assignment operator like `+=` or `^=` was\n-applied to the wrong types.\n-\n-A couple examples of this are as follows:\n+applied to the wrong types. For example:\n \n ```\n let mut x: u16 = 5;\n@@ -1029,8 +1095,13 @@ Trying to implement a trait for a trait object (as in `impl Trait1 for\n Trait2 { ... }`) does not work if the trait is not object-safe. Please see the\n [RFC 255] for more details on object safety rules.\n \n-[RFC 255]:https://github.com/rust-lang/rfcs/blob/master/text/0255-object-\\\n-safety.md\n+[RFC 255]: https://github.com/rust-lang/rfcs/pull/255\n+\"##,\n+\n+E0380: r##\"\n+Default impls are only allowed for traits with no methods or associated items.\n+For more information see the [opt-in builtin traits RFC](https://github.com/rust\n+-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n \"##\n \n }\n@@ -1045,7 +1116,6 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n@@ -1060,7 +1130,6 @@ register_diagnostics! {\n     E0086,\n     E0087,\n     E0088,\n-    E0089,\n     E0090,\n     E0091,\n     E0092,\n@@ -1098,7 +1167,6 @@ register_diagnostics! {\n     E0189, // deprecated: can only cast a boxed pointer to a boxed object\n     E0190, // deprecated: can only cast a &-pointer to an &-object\n     E0191, // value of the associated type must be specified\n-    E0192, // negative impls are allowed just for `Send` and `Sync`\n     E0193, // cannot bound type where clause bounds may only be attached to types\n            // involving type parameters\n     E0194,\n@@ -1146,7 +1214,6 @@ register_diagnostics! {\n     E0246, // illegal recursive type\n     E0247, // found module name used as a type\n     E0248, // found value name used as a type\n-    E0318, // can't create default impls for traits outside their crates\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n@@ -1168,5 +1235,11 @@ register_diagnostics! {\n            // between structures\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition\n-    E0379  // trait fns cannot be const\n+    E0379,  // trait fns cannot be const\n+    E0390, // only a single inherent implementation marked with\n+           // `#[lang = \\\"{}\\\"]` is allowed for the `{}` primitive\n+    E0391, // unsupported cyclic reference between types/traits detected\n+    E0392, // parameter `{}` is never used\n+    E0393  // the type parameter `{}` must be explicitly specified in an object\n+           // type because its default value `{}` references the type `Self`\"\n }"}, {"sha": "539d594cb8be2079fffbd72b1654fd4d64b05dd7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -4564,7 +4564,7 @@ impl<'a> Parser<'a> {\n         if try!(self.eat(&token::DotDot) ){\n             if generics.is_parameterized() {\n                 self.span_err(impl_span, \"default trait implementations are not \\\n-                                          allowed to have genercis\");\n+                                          allowed to have generics\");\n             }\n \n             try!(self.expect(&token::OpenDelim(token::Brace)));"}, {"sha": "7d6a1c9c1544c296daafa72c8817564ab609226e", "filename": "src/test/compile-fail/syntaxt-default-trait-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -13,6 +13,6 @@\n trait MyDefaultImpl {}\n \n impl<T> MyDefaultImpl for .. {}\n-//~^ ERROR default trait implementations are not allowed to have genercis\n+//~^ ERROR default trait implementations are not allowed to have generics\n \n fn main() {}"}, {"sha": "2e8f9d42e789547cba427470d8a9fcf6bfd79140", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe85342ef6c04aeb35b0d0dbde82791f1a8721bb/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=fe85342ef6c04aeb35b0d0dbde82791f1a8721bb", "patch": "@@ -12,5 +12,5 @@ use std::borrow::IntoCow;\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());\n-    //~^ ERROR too few type parameters provided: expected 1 parameter(s)\n+    //~^ ERROR too few type parameters provided: expected 1 parameter\n }"}]}