{"sha": "797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5N2EzNzNjZDE0NDkzZGQ1ZTFjMWQyZjM3Y2E0NjQ3M2YzMmI1ZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T13:10:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T13:10:57Z"}, "message": "auto merge of #9492 : pnkfelix/rust/fsk-syntax-visit-refactor-remainder, r=huonw\n\nr? anyone\r\n\r\nPart of #7081.\r\n\r\nRemoved many unnecessary context arguments, turning them into visitors.  Removed some @allocation.\r\n\r\nIf this lands, then I think the only thing left that is unaddressed are:\r\n * the various lint visitors, and\r\n * middle/privacy.rs, which has `impl<'self> Visitor<&'self method_map> for PrivacyVisitor`", "tree": {"sha": "9b0767a9c633d46b5f85ca788d23b7a3cc190a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b0767a9c633d46b5f85ca788d23b7a3cc190a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "html_url": "https://github.com/rust-lang/rust/commit/797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df97d23c71f6fbe300d3bc0dca23b063044b3934", "url": "https://api.github.com/repos/rust-lang/rust/commits/df97d23c71f6fbe300d3bc0dca23b063044b3934", "html_url": "https://github.com/rust-lang/rust/commit/df97d23c71f6fbe300d3bc0dca23b063044b3934"}, {"sha": "37481641b1101108eb394789dd2adf9e095e39d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/37481641b1101108eb394789dd2adf9e095e39d9", "html_url": "https://github.com/rust-lang/rust/commit/37481641b1101108eb394789dd2adf9e095e39d9"}], "stats": {"total": 509, "additions": 250, "deletions": 259}, "files": [{"sha": "3a50306bb8766cc51a28ab5c943be59077c97be9", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -226,7 +226,9 @@ struct env {\n     idstack: @mut ~[NodeId]\n }\n \n-struct CheckItemRecursionVisitor;\n+struct CheckItemRecursionVisitor {\n+    env: env,\n+}\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n@@ -242,34 +244,34 @@ pub fn check_item_recursion(sess: Session,\n         idstack: @mut ~[]\n     };\n \n-    let mut visitor = CheckItemRecursionVisitor;\n-    visitor.visit_item(it, env);\n+    let mut visitor = CheckItemRecursionVisitor { env: env };\n+    visitor.visit_item(it, ());\n }\n \n-impl Visitor<env> for CheckItemRecursionVisitor {\n-    fn visit_item(&mut self, it: @item, env: env) {\n-        if env.idstack.iter().any(|x| x == &(it.id)) {\n-            env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n+impl Visitor<()> for CheckItemRecursionVisitor {\n+    fn visit_item(&mut self, it: @item, _: ()) {\n+        if self.env.idstack.iter().any(|x| x == &(it.id)) {\n+            self.env.sess.span_fatal(self.env.root_it.span, \"recursive constant\");\n         }\n-        env.idstack.push(it.id);\n-        visit::walk_item(self, it, env);\n-        env.idstack.pop();\n+        self.env.idstack.push(it.id);\n+        visit::walk_item(self, it, ());\n+        self.env.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: @Expr, env: env) {\n+    fn visit_expr(&mut self, e: @Expr, _: ()) {\n         match e.node {\n-            ExprPath(*) => match env.def_map.find(&e.id) {\n+            ExprPath(*) => match self.env.def_map.find(&e.id) {\n                 Some(&DefStatic(def_id, _)) if ast_util::is_local(def_id) =>\n-                    match env.ast_map.get_copy(&def_id.node) {\n+                    match self.env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {\n-                            self.visit_item(it, env);\n+                            self.visit_item(it, ());\n                         }\n                         _ => fail!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },\n             _ => ()\n         }\n-        visit::walk_expr(self, e, env);\n+        visit::walk_expr(self, e, ());\n     }\n }"}, {"sha": "270babb9cf3e238a54f19d68948f00fbd196d6d2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -54,43 +54,38 @@ use syntax::visit::Visitor;\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    current_item: NodeId\n }\n \n-struct KindAnalysisVisitor;\n+impl Visitor<()> for Context {\n \n-impl Visitor<Context> for KindAnalysisVisitor {\n-\n-    fn visit_expr(&mut self, ex:@Expr, e:Context) {\n-        check_expr(self, ex, e);\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+        check_expr(self, ex);\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:Context) {\n-        check_fn(self, fk, fd, b, s, n, e);\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, _:()) {\n+        check_fn(self, fk, fd, b, s, n);\n     }\n \n-    fn visit_ty(&mut self, t:&Ty, e:Context) {\n-        check_ty(self, t, e);\n+    fn visit_ty(&mut self, t:&Ty, _:()) {\n+        check_ty(self, t);\n     }\n-    fn visit_item(&mut self, i:@item, e:Context) {\n-        check_item(self, i, e);\n+    fn visit_item(&mut self, i:@item, _:()) {\n+        check_item(self, i);\n     }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    crate: &Crate) {\n-    let ctx = Context {\n+    let mut ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n-        current_item: -1\n     };\n-    let mut visit = KindAnalysisVisitor;\n-    visit::walk_crate(&mut visit, crate, ctx);\n+    visit::walk_crate(&mut ctx, crate, ());\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_struct_safe_for_destructor(cx: Context,\n+fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     span: Span,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n@@ -120,7 +115,7 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n+fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n     let ast_trait_def = cx.tcx.def_map.find(&trait_ref.ref_id)\n                             .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n@@ -156,7 +151,7 @@ fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type:\n     }\n }\n \n-fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n+fn check_item(cx: &mut Context, item: @item) {\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n@@ -166,16 +161,15 @@ fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n         }\n     }\n \n-    let cx = Context { current_item: item.id, ..cx };\n-    visit::walk_item(visitor, item, cx);\n+    visit::walk_item(cx, item, ());\n }\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: NodeId,\n-                            b: &fn(checker: &fn(Context, @freevar_entry))) {\n-    fn check_for_uniq(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+fn with_appropriate_checker(cx: &Context, id: NodeId,\n+                            b: &fn(checker: &fn(&Context, @freevar_entry))) {\n+    fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n@@ -187,7 +181,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_box(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_box(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -198,7 +192,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(cx: Context, fv: &freevar_entry,\n+    fn check_for_block(cx: &Context, fv: &freevar_entry,\n                        bounds: ty::BuiltinBounds, region: ty::Region) {\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -209,7 +203,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: Context, fv: @freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n             \"can't capture dynamic environment in a fn item; \\\n@@ -252,13 +246,12 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n fn check_fn(\n-    v: &mut KindAnalysisVisitor,\n+    cx: &mut Context,\n     fk: &visit::fn_kind,\n     decl: &fn_decl,\n     body: &Block,\n     sp: Span,\n-    fn_id: NodeId,\n-    cx: Context) {\n+    fn_id: NodeId) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -268,10 +261,10 @@ fn check_fn(\n         }\n     }\n \n-    visit::walk_fn(v, fk, decl, body, sp, fn_id, cx);\n+    visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n }\n \n-pub fn check_expr(v: &mut KindAnalysisVisitor, e: @Expr, cx: Context) {\n+pub fn check_expr(cx: &mut Context, e: @Expr) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -336,10 +329,10 @@ pub fn check_expr(v: &mut KindAnalysisVisitor, e: @Expr, cx: Context) {\n         }\n         _ => {}\n     }\n-    visit::walk_expr(v, e, cx);\n+    visit::walk_expr(cx, e, ());\n }\n \n-fn check_ty(v: &mut KindAnalysisVisitor, aty: &Ty, cx: Context) {\n+fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n@@ -354,11 +347,11 @@ fn check_ty(v: &mut KindAnalysisVisitor, aty: &Ty, cx: Context) {\n       }\n       _ => {}\n     }\n-    visit::walk_ty(v, aty, cx);\n+    visit::walk_ty(cx, aty, ());\n }\n \n // Calls \"any_missing\" if any bounds were missing.\n-pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n+pub fn check_builtin_bounds(cx: &Context, ty: ty::t, bounds: ty::BuiltinBounds,\n                             any_missing: &fn(ty::BuiltinBounds))\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n@@ -373,7 +366,7 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n     }\n }\n \n-pub fn check_typaram_bounds(cx: Context,\n+pub fn check_typaram_bounds(cx: &Context,\n                     _type_parameter_id: NodeId,\n                     sp: Span,\n                     ty: ty::t,\n@@ -389,7 +382,7 @@ pub fn check_typaram_bounds(cx: Context,\n     }\n }\n \n-pub fn check_freevar_bounds(cx: Context, sp: Span, ty: ty::t,\n+pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n@@ -412,7 +405,7 @@ pub fn check_freevar_bounds(cx: Context, sp: Span, ty: ty::t,\n     }\n }\n \n-pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n+pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n@@ -423,7 +416,7 @@ pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n     }\n }\n \n-fn is_nullary_variant(cx: Context, ex: @Expr) -> bool {\n+fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {\n     match ex.node {\n       ExprPath(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n@@ -437,7 +430,7 @@ fn is_nullary_variant(cx: Context, ex: @Expr) -> bool {\n     }\n }\n \n-fn check_imm_free_var(cx: Context, def: Def, sp: Span) {\n+fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n     match def {\n         DefLocal(_, is_mutbl) => {\n             if is_mutbl {\n@@ -457,7 +450,7 @@ fn check_imm_free_var(cx: Context, def: Def, sp: Span) {\n     }\n }\n \n-fn check_copy(cx: Context, ty: ty::t, sp: Span, reason: &str) {\n+fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents(%s)=%s\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n@@ -469,7 +462,7 @@ fn check_copy(cx: Context, ty: ty::t, sp: Span, reason: &str) {\n     }\n }\n \n-pub fn check_send(cx: Context, ty: ty::t, sp: Span) -> bool {\n+pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n             sp, fmt!(\"value has non-sendable type `%s`\",\n@@ -525,7 +518,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n ///\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n-    cx: Context,\n+    cx: &Context,\n     source: &Expr,\n     target: &Expr)\n {\n@@ -601,7 +594,7 @@ pub fn check_cast_for_escaping_regions(\n         }\n     }\n \n-    fn is_subregion_of(cx: Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+    fn is_subregion_of(cx: &Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n }"}, {"sha": "9e28bfcb964c401b1be1aabbe59b81d009cf925d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -345,20 +345,18 @@ impl IrMaps {\n     }\n }\n \n-struct ErrorCheckVisitor;\n-\n-impl Visitor<@Liveness> for ErrorCheckVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:@Liveness) {\n-        check_fn(self, fk, fd, b, s, n, e);\n+impl Visitor<()> for Liveness {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, _:()) {\n+        check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l:@Local, e:@Liveness) {\n-        check_local(self, l, e);\n+    fn visit_local(&mut self, l:@Local, _:()) {\n+        check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, e:@Liveness) {\n-        check_expr(self, ex, e);\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+        check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a:&Arm, e:@Liveness) {\n-        check_arm(self, a, e);\n+    fn visit_arm(&mut self, a:&Arm, _:()) {\n+        check_arm(self, a);\n     }\n }\n \n@@ -419,12 +417,11 @@ fn visit_fn(v: &mut LivenessVisitor,\n     };\n \n     // compute liveness\n-    let lsets = @Liveness(fn_maps, specials);\n-    let entry_ln = (*lsets).compute(decl, body);\n+    let mut lsets = Liveness(fn_maps, specials);\n+    let entry_ln = lsets.compute(decl, body);\n \n     // check for various error conditions\n-    let mut check_vt = ErrorCheckVisitor;\n-    check_vt.visit_block(body, lsets);\n+    lsets.visit_block(body, ());\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -1423,7 +1420,7 @@ impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(vt: &mut ErrorCheckVisitor, local: @Local, this: @Liveness) {\n+fn check_local(this: &mut Liveness, local: @Local) {\n     match local.init {\n       Some(_) => {\n         this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n@@ -1449,48 +1446,48 @@ fn check_local(vt: &mut ErrorCheckVisitor, local: @Local, this: @Liveness) {\n       }\n     }\n \n-    visit::walk_local(vt, local, this);\n+    visit::walk_local(this, local, ());\n }\n \n-fn check_arm(vt: &mut ErrorCheckVisitor, arm: &Arm, this: @Liveness) {\n+fn check_arm(this: &mut Liveness, arm: &Arm) {\n     do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     }\n-    visit::walk_arm(vt, arm, this);\n+    visit::walk_arm(this, arm, ());\n }\n \n-fn check_expr(vt: &mut ErrorCheckVisitor, expr: @Expr, this: @Liveness) {\n+fn check_expr(this: &mut Liveness, expr: @Expr) {\n     match expr.node {\n       ExprAssign(l, r) => {\n-        this.check_lvalue(l, vt);\n-        vt.visit_expr(r, this);\n+        this.check_lvalue(l);\n+        this.visit_expr(r, ());\n \n-        visit::walk_expr(vt, expr, this);\n+        visit::walk_expr(this, expr, ());\n       }\n \n       ExprAssignOp(_, _, l, _) => {\n-        this.check_lvalue(l, vt);\n+        this.check_lvalue(l);\n \n-        visit::walk_expr(vt, expr, this);\n+        visit::walk_expr(this, expr, ());\n       }\n \n       ExprInlineAsm(ref ia) => {\n         for &(_, input) in ia.inputs.iter() {\n-          vt.visit_expr(input, this);\n+          this.visit_expr(input, ());\n         }\n \n         // Output operands must be lvalues\n         for &(_, out) in ia.outputs.iter() {\n           match out.node {\n             ExprAddrOf(_, inner) => {\n-              this.check_lvalue(inner, vt);\n+              this.check_lvalue(inner);\n             }\n             _ => {}\n           }\n-          vt.visit_expr(out, this);\n+          this.visit_expr(out, ());\n         }\n \n-        visit::walk_expr(vt, expr, this);\n+        visit::walk_expr(this, expr, ());\n       }\n \n       // no correctness conditions related to liveness\n@@ -1502,19 +1499,18 @@ fn check_expr(vt: &mut ErrorCheckVisitor, expr: @Expr, this: @Liveness) {\n       ExprAgain(*) | ExprLit(_) | ExprBlock(*) |\n       ExprMac(*) | ExprAddrOf(*) | ExprStruct(*) | ExprRepeat(*) |\n       ExprParen(*) | ExprFnBlock(*) | ExprPath(*) | ExprSelf(*) => {\n-        visit::walk_expr(vt, expr, this);\n+        visit::walk_expr(this, expr, ());\n       }\n       ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n \n-fn check_fn(_v: &mut ErrorCheckVisitor,\n+fn check_fn(_v: &Liveness,\n             _fk: &visit::fn_kind,\n             _decl: &fn_decl,\n             _body: &Block,\n             _sp: Span,\n-            _id: NodeId,\n-            _self: @Liveness) {\n+            _id: NodeId) {\n     // do not check contents of nested fns\n }\n \n@@ -1549,7 +1545,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn check_lvalue(@self, expr: @Expr, vt: &mut ErrorCheckVisitor) {\n+    pub fn check_lvalue(&mut self, expr: @Expr) {\n         match expr.node {\n           ExprPath(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n@@ -1578,7 +1574,7 @@ impl Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            visit::walk_expr(vt, expr, self);\n+            visit::walk_expr(self, expr, ());\n           }\n        }\n     }"}, {"sha": "5b6bb3a7b752af0dd8265b0e1e9e45194cddcde4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -65,19 +65,22 @@ pub struct RegionMaps {\n \n #[deriving(Clone)]\n pub struct Context {\n-    sess: Session,\n-    def_map: resolve::DefMap,\n-\n-    // Generated maps:\n-    region_maps: @mut RegionMaps,\n-\n     // Scope where variables should be parented to\n     var_parent: Option<ast::NodeId>,\n \n     // Innermost enclosing expression\n     parent: Option<ast::NodeId>,\n }\n \n+struct RegionResolutionVisitor {\n+    sess: Session,\n+    def_map: resolve::DefMap,\n+\n+    // Generated maps:\n+    region_maps: @mut RegionMaps,\n+}\n+\n+\n impl RegionMaps {\n     pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n@@ -318,24 +321,24 @@ impl RegionMaps {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: Span) {\n+fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n+                  cx: Context, child_id: ast::NodeId, sp: Span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n-           cx.sess.codemap.span_to_str(sp));\n+           visitor.sess.codemap.span_to_str(sp));\n     for parent_id in cx.parent.iter() {\n-        cx.region_maps.record_parent(child_id, *parent_id);\n+        visitor.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor,\n                  blk: &ast::Block,\n                  cx: Context) {\n     // Record the parent of this block.\n-    parent_to_expr(cx, blk.id, blk.span);\n+    parent_to_expr(visitor, cx, blk.id, blk.span);\n \n     // Descend.\n     let new_cx = Context {var_parent: Some(blk.id),\n-                          parent: Some(blk.id),\n-                          ..cx};\n+                          parent: Some(blk.id)};\n     visit::walk_block(visitor, blk, new_cx);\n }\n \n@@ -349,7 +352,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n                pat: @ast::Pat,\n                cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(cx, pat.id, pat.span);\n+    parent_to_expr(visitor, cx, pat.id, pat.span);\n     visit::walk_pat(visitor, pat, cx);\n }\n \n@@ -362,18 +365,18 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n         }\n         ast::StmtExpr(_, stmt_id) |\n         ast::StmtSemi(_, stmt_id) => {\n-            parent_to_expr(cx, stmt_id, stmt.span);\n+            parent_to_expr(visitor, cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n             visit::walk_stmt(visitor, stmt, expr_cx);\n         }\n-        ast::StmtMac(*) => cx.sess.bug(\"unexpanded macro\")\n+        ast::StmtMac(*) => visitor.sess.bug(\"unexpanded macro\")\n     }\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n                 expr: @ast::Expr,\n                 cx: Context) {\n-    parent_to_expr(cx, expr.id, expr.span);\n+    parent_to_expr(visitor, cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n     new_cx.parent = Some(expr.id);\n@@ -415,7 +418,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                  local: @ast::Local,\n                  cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(cx, local.id, local.span);\n+    parent_to_expr(visitor, cx, local.id, local.span);\n     visit::walk_local(visitor, local, cx);\n }\n \n@@ -439,7 +442,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                                body.id=%?, \\\n                                cx.parent=%?)\",\n            id,\n-           cx.sess.codemap.span_to_str(sp),\n+           visitor.sess.codemap.span_to_str(sp),\n            body.id,\n            cx.parent);\n \n@@ -449,7 +452,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                            ..cx};\n     match *fk {\n         visit::fk_method(_, _, method) => {\n-            cx.region_maps.record_parent(method.self_id, body.id);\n+            visitor.region_maps.record_parent(method.self_id, body.id);\n         }\n         _ => {}\n     }\n@@ -470,8 +473,6 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     visitor.visit_block(body, body_cx);\n }\n \n-struct RegionResolutionVisitor;\n-\n impl Visitor<Context> for RegionResolutionVisitor {\n \n     fn visit_block(&mut self, b:&Block, cx:Context) {\n@@ -511,12 +512,13 @@ pub fn resolve_crate(sess: Session,\n         free_region_map: HashMap::new(),\n         cleanup_scopes: HashSet::new(),\n     };\n-    let cx = Context {sess: sess,\n-                      def_map: def_map,\n-                      region_maps: region_maps,\n-                      parent: None,\n+    let cx = Context {parent: None,\n                       var_parent: None};\n-    let mut visitor = RegionResolutionVisitor;\n+    let mut visitor = RegionResolutionVisitor {\n+        sess: sess,\n+        def_map: def_map,\n+        region_maps: region_maps,\n+    };\n     visit::walk_crate(&mut visitor, crate, cx);\n     return region_maps;\n }\n@@ -733,10 +735,9 @@ impl DetermineRpCtxt {\n }\n \n fn determine_rp_in_item(visitor: &mut DetermineRpVisitor,\n-                        item: @ast::item,\n-                        cx: @mut DetermineRpCtxt) {\n-    do cx.with(item.id, true) {\n-        visit::walk_item(visitor, item, cx);\n+                        item: @ast::item) {\n+    do visitor.cx.with(item.id, true) {\n+        visit::walk_item(visitor, item, ());\n     }\n }\n \n@@ -745,32 +746,33 @@ fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n                       _: Span,\n-                      _: ast::NodeId,\n-                      cx: @mut DetermineRpCtxt) {\n+                      _: ast::NodeId) {\n+    let cx = visitor.cx;\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for a in decl.inputs.iter() {\n-                visitor.visit_ty(&a.ty, cx);\n+                visitor.visit_ty(&a.ty, ());\n             }\n         }\n-        visitor.visit_ty(&decl.output, cx);\n+        visitor.visit_ty(&decl.output, ());\n         let generics = visit::generics_of_fn(fk);\n-        visitor.visit_generics(&generics, cx);\n-        visitor.visit_block(body, cx);\n+        visitor.visit_generics(&generics, ());\n+        visitor.visit_block(body, ());\n     }\n }\n \n fn determine_rp_in_ty_method(visitor: &mut DetermineRpVisitor,\n-                             ty_m: &ast::TypeMethod,\n-                             cx: @mut DetermineRpCtxt) {\n+                             ty_m: &ast::TypeMethod) {\n+    let cx = visitor.cx;\n     do cx.with(cx.item_id, false) {\n-        visit::walk_ty_method(visitor, ty_m, cx);\n+        visit::walk_ty_method(visitor, ty_m, ());\n     }\n }\n \n fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n-                      ty: &ast::Ty,\n-                      cx: @mut DetermineRpCtxt) {\n+                      ty: &ast::Ty) {\n+    let cx = visitor.cx;\n+\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -854,14 +856,14 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n     match ty.node {\n       ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n       ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n-        visit_mt(visitor, mt, cx);\n+        visit_mt(visitor, mt);\n       }\n \n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for tp in path.segments.iter().flat_map(|s| s.types.iter()) {\n-                visitor.visit_ty(tp, cx);\n+                visitor.visit_ty(tp, ());\n             }\n         }\n       }\n@@ -874,57 +876,58 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for a in decl.inputs.iter() {\n-                    visitor.visit_ty(&a.ty, cx);\n+                    visitor.visit_ty(&a.ty, ());\n                 }\n             }\n-            visitor.visit_ty(&decl.output, cx);\n+            visitor.visit_ty(&decl.output, ());\n         }\n       }\n \n       _ => {\n-        visit::walk_ty(visitor, ty, cx);\n+        visit::walk_ty(visitor, ty, ());\n       }\n     }\n \n     fn visit_mt(visitor: &mut DetermineRpVisitor,\n-                mt: &ast::mt,\n-                cx: @mut DetermineRpCtxt) {\n+                mt: &ast::mt) {\n+        let cx = visitor.cx;\n         // mutability is invariant\n         if mt.mutbl == ast::MutMutable {\n             do cx.with_ambient_variance(rv_invariant) {\n-                visitor.visit_ty(mt.ty, cx);\n+                visitor.visit_ty(mt.ty, ());\n             }\n         } else {\n-            visitor.visit_ty(mt.ty, cx);\n+            visitor.visit_ty(mt.ty, ());\n         }\n     }\n }\n \n fn determine_rp_in_struct_field(visitor: &mut DetermineRpVisitor,\n-                                cm: @ast::struct_field,\n-                                cx: @mut DetermineRpCtxt) {\n-    visit::walk_struct_field(visitor, cm, cx);\n+                                cm: @ast::struct_field) {\n+    visit::walk_struct_field(visitor, cm, ());\n }\n \n-struct DetermineRpVisitor;\n+struct DetermineRpVisitor {\n+    cx: @mut DetermineRpCtxt\n+}\n \n-impl Visitor<@mut DetermineRpCtxt> for DetermineRpVisitor {\n+impl Visitor<()> for DetermineRpVisitor {\n \n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, e:@mut DetermineRpCtxt) {\n-        determine_rp_in_fn(self, fk, fd, b, s, n, e);\n+                b:&Block, s:Span, n:NodeId, _:()) {\n+        determine_rp_in_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_item(&mut self, i:@item, e:@mut DetermineRpCtxt) {\n-        determine_rp_in_item(self, i, e);\n+    fn visit_item(&mut self, i:@item, _:()) {\n+        determine_rp_in_item(self, i);\n     }\n-    fn visit_ty(&mut self, t:&Ty, e:@mut DetermineRpCtxt) {\n-        determine_rp_in_ty(self, t, e);\n+    fn visit_ty(&mut self, t:&Ty, _:()) {\n+        determine_rp_in_ty(self, t);\n     }\n-    fn visit_ty_method(&mut self, t:&TypeMethod, e:@mut DetermineRpCtxt) {\n-        determine_rp_in_ty_method(self, t, e);\n+    fn visit_ty_method(&mut self, t:&TypeMethod, _:()) {\n+        determine_rp_in_ty_method(self, t);\n     }\n-    fn visit_struct_field(&mut self, s:@struct_field, e:@mut DetermineRpCtxt) {\n-        determine_rp_in_struct_field(self, s, e);\n+    fn visit_struct_field(&mut self, s:@struct_field, _:()) {\n+        determine_rp_in_struct_field(self, s);\n     }\n \n }\n@@ -947,8 +950,8 @@ pub fn determine_rp_in_crate(sess: Session,\n     };\n \n     // Gather up the base set, worklist and dep_map\n-    let mut visitor = DetermineRpVisitor;\n-    visit::walk_crate(&mut visitor, crate, cx);\n+    let mut visitor = DetermineRpVisitor { cx: cx };\n+    visit::walk_crate(&mut visitor, crate, ());\n \n     // Propagate indirect dependencies\n     //"}, {"sha": "44de6fde05070c38c34b2452b2bcd3b79943c96d", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -28,72 +28,69 @@ use util::ppaux::Repr;\n \n #[deriving(Clone)]\n struct Context {\n-    tcx: ty::ctxt,\n     safe_stack: bool\n }\n \n-struct StackCheckVisitor;\n+struct StackCheckVisitor {\n+    tcx: ty::ctxt,\n+}\n \n impl Visitor<Context> for StackCheckVisitor {\n     fn visit_item(&mut self, i:@ast::item, e:Context) {\n-        stack_check_item(*self, i, e);\n+        stack_check_item(self, i, e);\n     }\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n                 b:&ast::Block, s:Span, n:ast::NodeId, e:Context) {\n-        stack_check_fn(*self, fk, fd, b, s, n, e);\n+        stack_check_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_expr(&mut self, ex:@ast::Expr, e:Context) {\n-        stack_check_expr(*self, ex, e);\n+        stack_check_expr(self, ex, e);\n     }\n }\n \n pub fn stack_check_crate(tcx: ty::ctxt,\n                          crate: &ast::Crate) {\n-    let new_cx = Context {\n-        tcx: tcx,\n-        safe_stack: false\n-    };\n-    let mut visitor = StackCheckVisitor;\n+    let new_cx = Context { safe_stack: false };\n+    let mut visitor = StackCheckVisitor { tcx: tcx };\n     visit::walk_crate(&mut visitor, crate, new_cx);\n }\n \n-fn stack_check_item(v: StackCheckVisitor,\n+fn stack_check_item(v: &mut StackCheckVisitor,\n                     item: @ast::item,\n                     in_cx: Context) {\n-    let mut v = v;\n     match item.node {\n         ast::item_fn(_, ast::extern_fn, _, _, _) => {\n             // an extern fn is already being called from C code...\n-            let new_cx = Context {safe_stack: true, ..in_cx};\n-            visit::walk_item(&mut v, item, new_cx);\n+            let new_cx = Context {safe_stack: true};\n+            visit::walk_item(v, item, new_cx);\n         }\n         ast::item_fn(*) => {\n             let safe_stack = fixed_stack_segment(item.attrs);\n-            let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n-            visit::walk_item(&mut v, item, new_cx);\n+            let new_cx = Context {safe_stack: safe_stack};\n+            visit::walk_item(v, item, new_cx);\n         }\n         ast::item_impl(_, _, _, ref methods) => {\n             // visit_method() would make this nicer\n             for &method in methods.iter() {\n                 let safe_stack = fixed_stack_segment(method.attrs);\n-                let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n-                visit::walk_method_helper(&mut v, method, new_cx);\n+                let new_cx = Context {safe_stack: safe_stack};\n+                visit::walk_method_helper(v, method, new_cx);\n             }\n         }\n         ast::item_trait(_, _, ref methods) => {\n             for method in methods.iter() {\n                 match *method {\n                     ast::provided(@ref method) => {\n                         let safe_stack = fixed_stack_segment(method.attrs);\n-                        let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n-                        visit::walk_method_helper(&mut v, method, new_cx);\n+                        let new_cx = Context {safe_stack: safe_stack};\n+                        visit::walk_method_helper(v, method, new_cx);\n                     }\n                     ast::required(*) => ()\n                 }\n             }\n         }\n         _ => {\n-            visit::walk_item(&mut v, item, in_cx);\n+            visit::walk_item(v, item, in_cx);\n         }\n     }\n \n@@ -102,7 +99,7 @@ fn stack_check_item(v: StackCheckVisitor,\n     }\n }\n \n-fn stack_check_fn<'a>(v: StackCheckVisitor,\n+fn stack_check_fn<'a>(v: &mut StackCheckVisitor,\n                       fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n@@ -114,7 +111,7 @@ fn stack_check_fn<'a>(v: StackCheckVisitor,\n             in_cx.safe_stack // see stack_check_item above\n         }\n         visit::fk_anon(*) | visit::fk_fn_block => {\n-            match ty::get(ty::node_id_to_type(in_cx.tcx, id)).sty {\n+            match ty::get(ty::node_id_to_type(v.tcx, id)).sty {\n                 ty::ty_bare_fn(*) |\n                 ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n                     false\n@@ -125,26 +122,25 @@ fn stack_check_fn<'a>(v: StackCheckVisitor,\n             }\n         }\n     };\n-    let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+    let new_cx = Context {safe_stack: safe_stack};\n     debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n-    let mut v = v;\n-    visit::walk_fn(&mut v, fk, decl, body, sp, id, new_cx);\n+    visit::walk_fn(v, fk, decl, body, sp, id, new_cx);\n }\n \n-fn stack_check_expr<'a>(v: StackCheckVisitor,\n+fn stack_check_expr<'a>(v: &mut StackCheckVisitor,\n                         expr: @ast::Expr,\n                         cx: Context) {\n     debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n-           cx.safe_stack, expr.repr(cx.tcx));\n+           cx.safe_stack, expr.repr(v.tcx));\n     if !cx.safe_stack {\n         match expr.node {\n             ast::ExprCall(callee, _, _) => {\n-                let callee_ty = ty::expr_ty(cx.tcx, callee);\n-                debug!(\"callee_ty=%s\", callee_ty.repr(cx.tcx));\n+                let callee_ty = ty::expr_ty(v.tcx, callee);\n+                debug!(\"callee_ty=%s\", callee_ty.repr(v.tcx));\n                 match ty::get(callee_ty).sty {\n                     ty::ty_bare_fn(ref fty) => {\n                         if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n-                            call_to_extern_fn(cx, callee);\n+                            call_to_extern_fn(v, callee);\n                         }\n                     }\n                     _ => {}\n@@ -153,18 +149,17 @@ fn stack_check_expr<'a>(v: StackCheckVisitor,\n             _ => {}\n         }\n     }\n-    let mut v = v;\n-    visit::walk_expr(&mut v, expr, cx);\n+    visit::walk_expr(v, expr, cx);\n }\n \n-fn call_to_extern_fn(cx: Context, callee: @ast::Expr) {\n+fn call_to_extern_fn(v: &mut StackCheckVisitor, callee: @ast::Expr) {\n     // Permit direct calls to extern fns that are annotated with\n     // #[rust_stack]. This is naturally a horrible pain to achieve.\n     match callee.node {\n         ast::ExprPath(*) => {\n-            match cx.tcx.def_map.find(&callee.id) {\n+            match v.tcx.def_map.find(&callee.id) {\n                 Some(&ast::DefFn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n-                    match cx.tcx.items.find(&id.node) {\n+                    match v.tcx.items.find(&id.node) {\n                         Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n                             if attr::contains_name(item.attrs, \"rust_stack\") {\n                                 return;\n@@ -179,7 +174,7 @@ fn call_to_extern_fn(cx: Context, callee: @ast::Expr) {\n         _ => {}\n     }\n \n-    cx.tcx.sess.add_lint(lint::cstack,\n+    v.tcx.sess.add_lint(lint::cstack,\n                          callee.id,\n                          callee.span,\n                          fmt!(\"invoking non-Rust fn in fn without \\"}, {"sha": "010d2fb12c5f0807c182ae82241af4b521428090", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -2194,11 +2194,13 @@ pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n     }\n }\n \n-pub struct TransItemVisitor;\n+pub struct TransItemVisitor {\n+    ccx: @mut CrateContext,\n+}\n \n-impl Visitor<@mut CrateContext> for TransItemVisitor {\n-    fn visit_item(&mut self, i: @ast::item, ccx: @mut CrateContext) {\n-        trans_item(ccx, i);\n+impl Visitor<()> for TransItemVisitor {\n+    fn visit_item(&mut self, i: @ast::item, _:()) {\n+        trans_item(self.ccx, i);\n     }\n }\n \n@@ -2235,8 +2237,8 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n-            let mut v = TransItemVisitor;\n-            v.visit_block(body, ccx);\n+            let mut v = TransItemVisitor{ ccx: ccx };\n+            v.visit_block(body, ());\n         }\n       }\n       ast::item_impl(ref generics, _, _, ref ms) => {\n@@ -2288,8 +2290,8 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         // functions, but the trait still needs to be walked. Otherwise default\n         // methods with items will not get translated and will cause ICE's when\n         // metadata time comes around.\n-        let mut v = TransItemVisitor;\n-        visit::walk_item(&mut v, item, ccx);\n+        let mut v = TransItemVisitor{ ccx: ccx };\n+        visit::walk_item(&mut v, item, ());\n       }\n       _ => {/* fall through */ }\n     }"}, {"sha": "a327b2e193939503b608c56ff8388e8a84c3e0c7", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -570,29 +570,30 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n }\n \n \n-struct CalleeTranslationVisitor;\n+struct CalleeTranslationVisitor {\n+    flag: bool,\n+}\n \n-impl Visitor<@mut bool> for CalleeTranslationVisitor {\n+impl Visitor<()> for CalleeTranslationVisitor {\n \n-    fn visit_item(&mut self, _:@ast::item, _:@mut bool) { }\n+    fn visit_item(&mut self, _:@ast::item, _:()) { }\n \n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut bool) {\n+    fn visit_expr(&mut self, e:@ast::Expr, _:()) {\n \n-            if !*cx {\n+            if !self.flag {\n                 match e.node {\n-                  ast::ExprRet(_) => *cx = true,\n-                  _ => visit::walk_expr(self, e, cx),\n+                  ast::ExprRet(_) => self.flag = true,\n+                  _ => visit::walk_expr(self, e, ()),\n                 }\n             }\n     }\n \n }\n \n pub fn body_contains_ret(body: &ast::Block) -> bool {\n-    let cx = @mut false;\n-    let mut v = CalleeTranslationVisitor;\n-    visit::walk_block(&mut v, body, cx);\n-    *cx\n+    let mut v = CalleeTranslationVisitor{ flag: false };\n+    visit::walk_block(&mut v, body, ());\n+    v.flag\n }\n \n pub fn trans_call_inner(in_cx: @mut Block,"}, {"sha": "fd35d05f0fde770e3e4e63624bbfceec09b0f5bd", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -61,9 +61,9 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n-        let mut v = TransItemVisitor;\n+        let mut v = TransItemVisitor{ ccx: ccx };\n         for method in methods.iter() {\n-            visit::walk_method_helper(&mut v, *method, ccx);\n+            visit::walk_method_helper(&mut v, *method, ());\n         }\n         return;\n     }\n@@ -80,8 +80,8 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                          None,\n                          llfn);\n         } else {\n-            let mut v = TransItemVisitor;\n-            visit::walk_method_helper(&mut v, *method, ccx);\n+            let mut v = TransItemVisitor{ ccx: ccx };\n+            visit::walk_method_helper(&mut v, *method, ());\n         }\n     }\n }"}, {"sha": "6ae196226d575c0e029f5dda804452c522c7e20e", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -81,7 +81,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: DefId, n_tps: uint)\n     // Conservatively assume full use for recursive loops\n     ccx.type_use_cache.insert(fn_id, @vec::from_elem(n_tps, use_all));\n \n-    let cx = Context {\n+    let mut cx = Context {\n         ccx: ccx,\n         uses: @mut vec::from_elem(n_tps, 0u)\n     };\n@@ -112,7 +112,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: DefId, n_tps: uint)\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, _, ref body),\n                                       _ }, _) |\n       ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n-        handle_body(&cx, body);\n+        handle_body(&mut cx, body);\n       }\n       ast_map::node_trait_method(*) => {\n         // This will be a static trait method. For now, we just assume\n@@ -414,39 +414,36 @@ pub fn mark_for_expr(cx: &Context, e: &Expr) {\n     }\n }\n \n-struct TypeUseVisitor;\n+impl Visitor<()> for Context {\n \n-impl<'self> Visitor<&'self Context> for TypeUseVisitor {\n-\n-    fn visit_expr<'a>(&mut self, e:@Expr, cx: &'a Context) {\n-            visit::walk_expr(self, e, cx);\n-            mark_for_expr(cx, e);\n+    fn visit_expr(&mut self, e:@Expr, _: ()) {\n+            visit::walk_expr(self, e, ());\n+            mark_for_expr(self, e);\n     }\n \n-    fn visit_local<'a>(&mut self, l:@Local, cx: &'a Context) {\n-            visit::walk_local(self, l, cx);\n-            node_type_needs(cx, use_repr, l.id);\n+    fn visit_local(&mut self, l:@Local, _:()) {\n+            visit::walk_local(self, l, ());\n+            node_type_needs(self, use_repr, l.id);\n     }\n \n-    fn visit_pat<'a>(&mut self, p:@Pat, cx: &'a Context) {\n-            visit::walk_pat(self, p, cx);\n-            node_type_needs(cx, use_repr, p.id);\n+    fn visit_pat(&mut self, p:@Pat, _: ()) {\n+            visit::walk_pat(self, p, ());\n+            node_type_needs(self, use_repr, p.id);\n     }\n \n-    fn visit_block<'a>(&mut self, b:&Block, cx: &'a Context) {\n-            visit::walk_block(self, b, cx);\n+   fn visit_block(&mut self, b:&Block, _: ()) {\n+            visit::walk_block(self, b, ());\n             for e in b.expr.iter() {\n-                node_type_needs(cx, use_repr, e.id);\n+                node_type_needs(self, use_repr, e.id);\n             }\n     }\n \n-    fn visit_item<'a>(&mut self, _:@item, _: &'a Context) {\n+    fn visit_item(&mut self, _:@item, _: ()) {\n         // do nothing\n     }\n \n }\n \n-pub fn handle_body(cx: &Context, body: &Block) {\n-    let mut v = TypeUseVisitor;\n-    v.visit_block(body, cx);\n+pub fn handle_body(cx: &mut Context, body: &Block) {\n+    cx.visit_block(body, ());\n }"}, {"sha": "eeef2b798e20a002499ac326684ebc343597301d", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797a373cd14493dd5e1c1d2f37ca46473f32b5ef/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=797a373cd14493dd5e1c1d2f37ca46473f32b5ef", "patch": "@@ -61,52 +61,54 @@ pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n }\n \n struct LoopQueryVisitor<'self> {\n-    p: &'self fn(&ast::Expr_) -> bool\n+    p: &'self fn(&ast::Expr_) -> bool,\n+    flag: bool,\n }\n \n-impl<'self> Visitor<@mut bool> for LoopQueryVisitor<'self> {\n-    fn visit_expr(&mut self, e: @ast::Expr, flag: @mut bool) {\n-        *flag |= (self.p)(&e.node);\n+impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n+    fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+        self.flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n           ast::ExprLoop(*) | ast::ExprWhile(*) => {}\n-          _ => visit::walk_expr(self, e, flag)\n+          _ => visit::walk_expr(self, e, ())\n         }\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n pub fn loop_query(b: &ast::Block, p: &fn(&ast::Expr_) -> bool) -> bool {\n-    let rs = @mut false;\n     let mut v = LoopQueryVisitor {\n         p: p,\n+        flag: false,\n     };\n-    visit::walk_block(&mut v, b, rs);\n-    return *rs;\n+    visit::walk_block(&mut v, b, ());\n+    return v.flag;\n }\n \n struct BlockQueryVisitor<'self> {\n-    p: &'self fn(@ast::Expr) -> bool\n+    p: &'self fn(@ast::Expr) -> bool,\n+    flag: bool,\n }\n \n-impl<'self> Visitor<@mut bool> for BlockQueryVisitor<'self> {\n-    fn visit_expr(&mut self, e: @ast::Expr, flag: @mut bool) {\n-        *flag |= (self.p)(e);\n-        visit::walk_expr(self, e, flag)\n+impl<'self> Visitor<()> for BlockQueryVisitor<'self> {\n+    fn visit_expr(&mut self, e: @ast::Expr, _:()) {\n+        self.flag |= (self.p)(e);\n+        visit::walk_expr(self, e, ())\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n pub fn block_query(b: &ast::Block, p: &fn(@ast::Expr) -> bool) -> bool {\n-    let rs = @mut false;\n     let mut v = BlockQueryVisitor {\n         p: p,\n+        flag: false,\n     };\n-    visit::walk_block(&mut v, b, rs);\n-    return *rs;\n+    visit::walk_block(&mut v, b, ());\n+    return v.flag;\n }\n \n pub fn local_rhs_span(l: @ast::Local, def: Span) -> Span {"}]}