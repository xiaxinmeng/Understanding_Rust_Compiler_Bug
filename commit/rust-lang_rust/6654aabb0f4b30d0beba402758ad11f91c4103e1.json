{"sha": "6654aabb0f4b30d0beba402758ad11f91c4103e1", "node_id": "C_kwDOAAsO6NoAKDY2NTRhYWJiMGY0YjMwZDBiZWJhNDAyNzU4YWQxMWY5MWM0MTAzZTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T20:02:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T20:02:55Z"}, "message": "Auto merge of #97313 - cjgillot:ast-lifetimes-anon, r=petrochenkov\n\nResolve function lifetime elision on the AST\n\n~Based on https://github.com/rust-lang/rust/pull/97720~\n\nLifetime elision for functions is purely syntactic in nature, so can be resolved on the AST.\nThis PR replicates the elision logic and diagnostics on the AST, and replaces HIR-based resolution by a `delay_span_bug`.\n\nThis refactor allows for more consistent diagnostics, which don't have to guess the original code from HIR.\n\nr? `@petrochenkov`", "tree": {"sha": "f107c855e49bf9159e58f01f50eb67d1ba4dba39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f107c855e49bf9159e58f01f50eb67d1ba4dba39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6654aabb0f4b30d0beba402758ad11f91c4103e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6654aabb0f4b30d0beba402758ad11f91c4103e1", "html_url": "https://github.com/rust-lang/rust/commit/6654aabb0f4b30d0beba402758ad11f91c4103e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6654aabb0f4b30d0beba402758ad11f91c4103e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "632f9945d60c6338a38d385c59c6c9b5f3f5e94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/632f9945d60c6338a38d385c59c6c9b5f3f5e94d", "html_url": "https://github.com/rust-lang/rust/commit/632f9945d60c6338a38d385c59c6c9b5f3f5e94d"}, {"sha": "419d39c072825bb622e262c59b0243fcfe69d337", "url": "https://api.github.com/repos/rust-lang/rust/commits/419d39c072825bb622e262c59b0243fcfe69d337", "html_url": "https://github.com/rust-lang/rust/commit/419d39c072825bb622e262c59b0243fcfe69d337"}], "stats": {"total": 78, "additions": 46, "deletions": 32}, "files": [{"sha": "826353aafc0690c2a9caf64d26fd95358f49cb1a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6654aabb0f4b30d0beba402758ad11f91c4103e1/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6654aabb0f4b30d0beba402758ad11f91c4103e1/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=6654aabb0f4b30d0beba402758ad11f91c4103e1", "patch": "@@ -9,12 +9,14 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, LifetimeParamKind, ParamName, PolyTraitRef,\n-    PredicateOrigin, TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin,\n+    TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Ident, Symbol};\n \n@@ -129,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n enum RefLt {\n     Unnamed,\n     Static,\n-    Named(Symbol),\n+    Named(LocalDefId),\n }\n \n fn check_fn_inner<'tcx>(\n@@ -232,7 +234,7 @@ fn could_use_elision<'tcx>(\n     // level of the current item.\n \n     // check named LTs\n-    let allowed_lts = allowed_lts_from(named_generics);\n+    let allowed_lts = allowed_lts_from(cx.tcx, named_generics);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor::new(cx);\n@@ -254,22 +256,6 @@ fn could_use_elision<'tcx>(\n         return false;\n     }\n \n-    if allowed_lts\n-        .intersection(\n-            &input_visitor\n-                .nested_elision_site_lts\n-                .iter()\n-                .chain(output_visitor.nested_elision_site_lts.iter())\n-                .cloned()\n-                .filter(|v| matches!(v, RefLt::Named(_)))\n-                .collect(),\n-        )\n-        .next()\n-        .is_some()\n-    {\n-        return false;\n-    }\n-\n     let input_lts = input_visitor.lts;\n     let output_lts = output_visitor.lts;\n \n@@ -303,6 +289,31 @@ fn could_use_elision<'tcx>(\n         }\n     }\n \n+    // check for higher-ranked trait bounds\n+    if !input_visitor.nested_elision_site_lts.is_empty() || !output_visitor.nested_elision_site_lts.is_empty() {\n+        let allowed_lts: FxHashSet<_> = allowed_lts\n+            .iter()\n+            .filter_map(|lt| match lt {\n+                RefLt::Named(def_id) => Some(cx.tcx.item_name(def_id.to_def_id())),\n+                _ => None,\n+            })\n+            .collect();\n+        for lt in input_visitor.nested_elision_site_lts {\n+            if let RefLt::Named(def_id) = lt {\n+                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n+                    return false;\n+                }\n+            }\n+        }\n+        for lt in output_visitor.nested_elision_site_lts {\n+            if let RefLt::Named(def_id) = lt {\n+                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n         false\n@@ -335,14 +346,11 @@ fn could_use_elision<'tcx>(\n     }\n }\n \n-fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n+fn allowed_lts_from(tcx: TyCtxt<'_>, named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n-        if let GenericParamKind::Lifetime {\n-            kind: LifetimeParamKind::Explicit,\n-        } = par.kind\n-        {\n-            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n+        if let GenericParamKind::Lifetime { .. } = par.kind {\n+            allowed_lts.insert(RefLt::Named(tcx.hir().local_def_id(par.hir_id)));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);\n@@ -385,8 +393,10 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n                 self.lts.push(RefLt::Unnamed);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);\n+            } else if let LifetimeName::Param(def_id, _) = lt.name {\n+                self.lts.push(RefLt::Named(def_id));\n             } else {\n-                self.lts.push(RefLt::Named(lt.name.ident().name));\n+                self.lts.push(RefLt::Unnamed);\n             }\n         } else {\n             self.lts.push(RefLt::Unnamed);\n@@ -434,10 +444,15 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyKind::OpaqueDef(item, bounds) => {\n                 let map = self.cx.tcx.hir();\n                 let item = map.item(item);\n+                let len = self.lts.len();\n                 walk_item(self, item);\n-                walk_ty(self, ty);\n+                self.lts.truncate(len);\n                 self.lts.extend(bounds.iter().filter_map(|bound| match bound {\n-                    GenericArg::Lifetime(l) => Some(RefLt::Named(l.name.ident().name)),\n+                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id, _) = l.name {\n+                        RefLt::Named(def_id)\n+                    } else {\n+                        RefLt::Unnamed\n+                    }),\n                     _ => None,\n                 }));\n             },\n@@ -456,9 +471,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 }\n                 return;\n             },\n-            _ => (),\n+            _ => walk_ty(self, ty),\n         }\n-        walk_ty(self, ty);\n     }\n }\n \n@@ -477,7 +491,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n-                let allowed_lts = allowed_lts_from(pred.bound_generic_params);\n+                let allowed_lts = allowed_lts_from(cx.tcx, pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n                     walk_param_bound(&mut visitor, bound);"}]}