{"sha": "f18b7e18c479144325ec150be00837aae3329ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOGI3ZTE4YzQ3OTE0NDMyNWVjMTUwYmUwMDgzN2FhZTMzMjlhZTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-06T20:28:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-06T20:28:28Z"}, "message": "Merge #2484\n\n2484: DynMap r=matklad a=matklad\n\nImplement a `DynMap` a semi-dynamic, semi-static map, which helps to thread heterogeneously typed info in a uniform way. Totally inspired by https://github.com/JetBrains/kotlin/blob/df3bee30384787d8951ea548a4257c2cb52a16a3/compiler/frontend/src/org/jetbrains/kotlin/resolve/BindingContext.java. \r\n\r\n@flodiebold wdyt? Seems like a potentially useful pattern for various source-map-like things.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2c8fbda35c5d9f43b70fe3c6e91ce3e4a8bb3226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c8fbda35c5d9f43b70fe3c6e91ce3e4a8bb3226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f18b7e18c479144325ec150be00837aae3329ae2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6rnsCRBK7hj4Ov3rIwAAdHIIAIH3JUgtwR3AUh9/WNPY75K0\n/fFUJbxsbPVc9NB4YUx1orPP5hy7sG0YGL6lbC+LnvJyH2ubAnmtCLHXNUs/1lTv\ncIsZhD4nhJG3gRatSFT7DPOnyGvbc05iX5eUgr6cI5ZdnxdUb/bgNw/VZvCEYWmf\nn37ghYVE605DNAHeL1e0iAmoeU5mc9nS4jm53iV/7Cm/ADiLqOG9dNkFSkZzgvNH\nQV3t+b3gDJSlbhid9BGsVIRhK1Nx3KCGJSMjSHTyaiPG12EULOG4Onp+UxSMApbC\nVJU3VYTHgj9eHAnPpqZUMeE2IyFt5e6FdAZQrwTbpNORczuY76384//khgn9nak=\n=fXpi\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c8fbda35c5d9f43b70fe3c6e91ce3e4a8bb3226\nparent d3702c02cdff158f05d2af1bd7106cca8a3e4ba9\nparent 8c86963d47953045f2f33ee6620d305a6589641e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575664108 +0000\ncommitter GitHub <noreply@github.com> 1575664108 +0000\n\nMerge #2484\n\n2484: DynMap r=matklad a=matklad\n\nImplement a `DynMap` a semi-dynamic, semi-static map, which helps to thread heterogeneously typed info in a uniform way. Totally inspired by https://github.com/JetBrains/kotlin/blob/df3bee30384787d8951ea548a4257c2cb52a16a3/compiler/frontend/src/org/jetbrains/kotlin/resolve/BindingContext.java. \r\n\r\n@flodiebold wdyt? Seems like a potentially useful pattern for various source-map-like things.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f18b7e18c479144325ec150be00837aae3329ae2", "html_url": "https://github.com/rust-lang/rust/commit/f18b7e18c479144325ec150be00837aae3329ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f18b7e18c479144325ec150be00837aae3329ae2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3702c02cdff158f05d2af1bd7106cca8a3e4ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3702c02cdff158f05d2af1bd7106cca8a3e4ba9", "html_url": "https://github.com/rust-lang/rust/commit/d3702c02cdff158f05d2af1bd7106cca8a3e4ba9"}, {"sha": "8c86963d47953045f2f33ee6620d305a6589641e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c86963d47953045f2f33ee6620d305a6589641e", "html_url": "https://github.com/rust-lang/rust/commit/8c86963d47953045f2f33ee6620d305a6589641e"}], "stats": {"total": 680, "additions": 362, "deletions": 318}, "files": [{"sha": "a95f9139f12bce756672cabc63cfdaa613263c8d", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -13,6 +13,11 @@ name = \"anyhow\"\n version = \"1.0.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"anymap\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"arrayvec\"\n version = \"0.5.1\"\n@@ -958,6 +963,7 @@ dependencies = [\n name = \"ra_hir_def\"\n version = \"0.1.0\"\n dependencies = [\n+ \"anymap 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1776,6 +1782,7 @@ dependencies = [\n [metadata]\n \"checksum aho-corasick 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n \"checksum anyhow 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9267dff192e68f3399525901e709a48c1d3982c9c072fa32f2127a0cb0babf14\"\n+\"checksum anymap 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33954243bd79057c2de7338850b85983a44588021f8a5fee574a8888c6de4344\"\n \"checksum arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \"checksum atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n \"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\""}, {"sha": "437f800c1e1997f18bbdaaad84423b468ca5f295", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -1,9 +1,7 @@\n //! FIXME: write short doc here\n-use either::Either;\n-\n use hir_def::{\n-    child_from_source::ChildFromSource, nameres::ModuleSource, AstItemDef, EnumVariantId, ImplId,\n-    LocationCtx, ModuleId, TraitId, VariantId,\n+    child_by_source::ChildBySource, dyn_map::DynMap, keys, nameres::ModuleSource, AstItemDef,\n+    EnumVariantId, LocationCtx, ModuleId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n@@ -53,35 +51,39 @@ impl FromSource for Trait {\n impl FromSource for Function {\n     type Ast = ast::FnDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n-            .child_from_source(db, src)\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?.child_by_source(db)[keys::FUNCTION]\n+            .get(&src)\n+            .copied()\n             .map(Function::from)\n     }\n }\n \n impl FromSource for Const {\n     type Ast = ast::ConstDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n-            .child_from_source(db, src)\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?.child_by_source(db)[keys::CONST]\n+            .get(&src)\n+            .copied()\n             .map(Const::from)\n     }\n }\n impl FromSource for Static {\n     type Ast = ast::StaticDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Module(it) => it.id.child_from_source(db, src).map(Static::from),\n-            Container::Trait(_) | Container::ImplBlock(_) => None,\n-        }\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?.child_by_source(db)[keys::STATIC]\n+            .get(&src)\n+            .copied()\n+            .map(Static::from)\n     }\n }\n \n impl FromSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n-            .child_from_source(db, src)\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?.child_by_source(db)\n+            [keys::TYPE_ALIAS]\n+            .get(&src)\n+            .copied()\n             .map(TypeAlias::from)\n     }\n }\n@@ -116,32 +118,41 @@ impl FromSource for EnumVariant {\n         let parent_enum = src.value.parent_enum();\n         let src_enum = InFile { file_id: src.file_id, value: parent_enum };\n         let parent_enum = Enum::from_source(db, src_enum)?;\n-        parent_enum.id.child_from_source(db, src).map(EnumVariant::from)\n+        parent_enum.id.child_by_source(db)[keys::ENUM_VARIANT]\n+            .get(&src)\n+            .copied()\n+            .map(EnumVariant::from)\n     }\n }\n \n impl FromSource for StructField {\n     type Ast = FieldSource;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n+        let src = src.as_ref();\n+\n+        // FIXME this is buggy\n         let variant_id: VariantId = match src.value {\n-            FieldSource::Named(ref field) => {\n+            FieldSource::Named(field) => {\n                 let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = Struct::from_source(db, src)?;\n                 def.id.into()\n             }\n-            FieldSource::Pos(ref field) => {\n+            FieldSource::Pos(field) => {\n                 let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = EnumVariant::from_source(db, src)?;\n                 EnumVariantId::from(def).into()\n             }\n         };\n-        let src = src.map(|field_source| match field_source {\n-            FieldSource::Pos(it) => Either::Left(it),\n-            FieldSource::Named(it) => Either::Right(it),\n-        });\n-        variant_id.child_from_source(db, src).map(StructField::from)\n+\n+        let dyn_map = variant_id.child_by_source(db);\n+        match src.value {\n+            FieldSource::Pos(it) => dyn_map[keys::TUPLE_FIELD].get(&src.with_value(it.clone())),\n+            FieldSource::Named(it) => dyn_map[keys::RECORD_FIELD].get(&src.with_value(it.clone())),\n+        }\n+        .copied()\n+        .map(StructField::from)\n     }\n }\n \n@@ -255,21 +266,12 @@ impl Container {\n     }\n }\n \n-impl<CHILD, SOURCE> ChildFromSource<CHILD, SOURCE> for Container\n-where\n-    TraitId: ChildFromSource<CHILD, SOURCE>,\n-    ImplId: ChildFromSource<CHILD, SOURCE>,\n-    ModuleId: ChildFromSource<CHILD, SOURCE>,\n-{\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<SOURCE>,\n-    ) -> Option<CHILD> {\n+impl ChildBySource for Container {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n         match self {\n-            Container::Trait(it) => it.id.child_from_source(db, child_source),\n-            Container::ImplBlock(it) => it.id.child_from_source(db, child_source),\n-            Container::Module(it) => it.id.child_from_source(db, child_source),\n+            Container::Trait(it) => it.id.child_by_source(db),\n+            Container::ImplBlock(it) => it.id.child_by_source(db),\n+            Container::Module(it) => it.id.child_by_source(db),\n         }\n     }\n }"}, {"sha": "b1923bbf2edf5b119b9f3185b7d94924626d2e34", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -12,6 +12,7 @@ log = \"0.4.5\"\n once_cell = \"1.0.1\"\n rustc-hash = \"1.0\"\n either = \"1.5\"\n+anymap = \"0.12\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "a3574a9dbb35151b1509f818e4e5ccc28c3e9466", "filename": "crates/ra_hir_def/src/child_by_source.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -0,0 +1,139 @@\n+//! When *constructing* `hir`, we start at some parent syntax node and recursively\n+//! lower the children.\n+//!\n+//! This modules allows one to go in the opposite direction: start with a syntax\n+//! node for a *child*, and get its hir.\n+\n+use either::Either;\n+\n+use crate::{\n+    db::DefDatabase,\n+    dyn_map::DynMap,\n+    keys,\n+    src::{HasChildSource, HasSource},\n+    AssocItemId, EnumId, EnumVariantId, ImplId, Lookup, ModuleDefId, ModuleId, StructFieldId,\n+    TraitId, VariantId,\n+};\n+\n+pub trait ChildBySource {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap;\n+}\n+\n+impl ChildBySource for TraitId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let data = db.trait_data(*self);\n+        for (_name, item) in data.items.iter() {\n+            match *item {\n+                AssocItemId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    res[keys::FUNCTION].insert(src, func)\n+                }\n+                AssocItemId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    res[keys::CONST].insert(src, konst)\n+                }\n+                AssocItemId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for ImplId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let data = db.impl_data(*self);\n+        for &item in data.items.iter() {\n+            match item {\n+                AssocItemId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    res[keys::FUNCTION].insert(src, func)\n+                }\n+                AssocItemId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    res[keys::CONST].insert(src, konst)\n+                }\n+                AssocItemId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for ModuleId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        for item in crate_def_map[self.local_id].scope.declarations() {\n+            match item {\n+                ModuleDefId::FunctionId(func) => {\n+                    let src = func.lookup(db).source(db);\n+                    res[keys::FUNCTION].insert(src, func)\n+                }\n+                ModuleDefId::ConstId(konst) => {\n+                    let src = konst.lookup(db).source(db);\n+                    res[keys::CONST].insert(src, konst)\n+                }\n+                ModuleDefId::StaticId(statik) => {\n+                    let src = statik.lookup(db).source(db);\n+                    res[keys::STATIC].insert(src, statik)\n+                }\n+                ModuleDefId::TypeAliasId(ty) => {\n+                    let src = ty.lookup(db).source(db);\n+                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl ChildBySource for VariantId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = StructFieldId { parent: *self, local_id };\n+            match source {\n+                Either::Left(source) => {\n+                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                }\n+                Either::Right(source) => {\n+                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                }\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+impl ChildBySource for EnumId {\n+    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+        let mut res = DynMap::default();\n+\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = EnumVariantId { parent: *self, local_id };\n+            res[keys::ENUM_VARIANT].insert(arena_map.with_value(source.clone()), id)\n+        }\n+\n+        res\n+    }\n+}"}, {"sha": "37d4b787066bc75e9d49194e2be57dab5fb184af", "filename": "crates/ra_hir_def/src/child_from_source.rs", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/d3702c02cdff158f05d2af1bd7106cca8a3e4ba9/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3702c02cdff158f05d2af1bd7106cca8a3e4ba9/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs?ref=d3702c02cdff158f05d2af1bd7106cca8a3e4ba9", "patch": "@@ -1,276 +0,0 @@\n-//! When *constructing* `hir`, we start at some parent syntax node and recursively\n-//! lower the children.\n-//!\n-//! This modules allows one to go in the opposite direction: start with a syntax\n-//! node for a *child*, and get its hir.\n-\n-use either::Either;\n-use hir_expand::InFile;\n-use ra_syntax::{ast, AstNode, AstPtr};\n-\n-use crate::{\n-    db::DefDatabase,\n-    src::{HasChildSource, HasSource},\n-    AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, ImplId, Lookup, ModuleDefId, ModuleId,\n-    StaticId, StructFieldId, TraitId, TypeAliasId, VariantId,\n-};\n-\n-pub trait ChildFromSource<CHILD, SOURCE> {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<SOURCE>,\n-    ) -> Option<CHILD>;\n-}\n-\n-impl ChildFromSource<FunctionId, ast::FnDef> for TraitId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::FnDef>,\n-    ) -> Option<FunctionId> {\n-        let data = db.trait_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|(_, item)| match item {\n-                AssocItemId::FunctionId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<FunctionId, ast::FnDef> for ImplId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::FnDef>,\n-    ) -> Option<FunctionId> {\n-        let data = db.impl_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|item| match item {\n-                AssocItemId::FunctionId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<FunctionId, ast::FnDef> for ModuleId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::FnDef>,\n-    ) -> Option<FunctionId> {\n-        let crate_def_map = db.crate_def_map(self.krate);\n-        let res = crate_def_map[self.local_id]\n-            .scope\n-            .declarations()\n-            .filter_map(|item| match item {\n-                ModuleDefId::FunctionId(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            });\n-        res\n-    }\n-}\n-\n-impl ChildFromSource<ConstId, ast::ConstDef> for TraitId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::ConstDef>,\n-    ) -> Option<ConstId> {\n-        let data = db.trait_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|(_, item)| match item {\n-                AssocItemId::ConstId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<ConstId, ast::ConstDef> for ImplId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::ConstDef>,\n-    ) -> Option<ConstId> {\n-        let data = db.impl_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|item| match item {\n-                AssocItemId::ConstId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<ConstId, ast::ConstDef> for ModuleId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::ConstDef>,\n-    ) -> Option<ConstId> {\n-        let crate_def_map = db.crate_def_map(self.krate);\n-        let res = crate_def_map[self.local_id]\n-            .scope\n-            .declarations()\n-            .filter_map(|item| match item {\n-                ModuleDefId::ConstId(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            });\n-        res\n-    }\n-}\n-\n-impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for TraitId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::TypeAliasDef>,\n-    ) -> Option<TypeAliasId> {\n-        let data = db.trait_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|(_, item)| match item {\n-                AssocItemId::TypeAliasId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ImplId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::TypeAliasDef>,\n-    ) -> Option<TypeAliasId> {\n-        let data = db.impl_data(*self);\n-        data.items\n-            .iter()\n-            .filter_map(|item| match item {\n-                AssocItemId::TypeAliasId(it) => Some(*it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            })\n-    }\n-}\n-\n-impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ModuleId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::TypeAliasDef>,\n-    ) -> Option<TypeAliasId> {\n-        let crate_def_map = db.crate_def_map(self.krate);\n-        let res = crate_def_map[self.local_id]\n-            .scope\n-            .declarations()\n-            .filter_map(|item| match item {\n-                ModuleDefId::TypeAliasId(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            });\n-        res\n-    }\n-}\n-\n-impl ChildFromSource<StaticId, ast::StaticDef> for ModuleId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::StaticDef>,\n-    ) -> Option<StaticId> {\n-        let crate_def_map = db.crate_def_map(self.krate);\n-        let res = crate_def_map[self.local_id]\n-            .scope\n-            .declarations()\n-            .filter_map(|item| match item {\n-                ModuleDefId::StaticId(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|func| {\n-                let source = func.lookup(db).source(db);\n-                same_source(&source, &child_source)\n-            });\n-        res\n-    }\n-}\n-\n-impl ChildFromSource<StructFieldId, Either<ast::TupleFieldDef, ast::RecordFieldDef>> for VariantId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n-    ) -> Option<StructFieldId> {\n-        let arena_map = self.child_source(db);\n-        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n-            child_source.file_id == arena_map.file_id\n-                && match (source, &child_source.value) {\n-                    (Either::Left(a), Either::Left(b)) => AstPtr::new(a) == AstPtr::new(b),\n-                    (Either::Right(a), Either::Right(b)) => AstPtr::new(a) == AstPtr::new(b),\n-                    _ => false,\n-                }\n-        })?;\n-        Some(StructFieldId { parent: *self, local_id })\n-    }\n-}\n-\n-impl ChildFromSource<EnumVariantId, ast::EnumVariant> for EnumId {\n-    fn child_from_source(\n-        &self,\n-        db: &impl DefDatabase,\n-        child_source: InFile<ast::EnumVariant>,\n-    ) -> Option<EnumVariantId> {\n-        let arena_map = self.child_source(db);\n-        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n-            child_source.file_id == arena_map.file_id\n-                && AstPtr::new(*source) == AstPtr::new(&child_source.value)\n-        })?;\n-        Some(EnumVariantId { parent: *self, local_id })\n-    }\n-}\n-\n-/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n-/// equal if they point to exactly the same object.\n-///\n-/// In general, we do not guarantee that we have exactly one instance of a\n-/// syntax tree for each file. We probably should add such guarantee, but, for\n-/// the time being, we will use identity-less AstPtr comparison.\n-fn same_source<N: AstNode>(s1: &InFile<N>, s2: &InFile<N>) -> bool {\n-    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n-}"}, {"sha": "6f269d7b01fec1645d62e7f79bef846b9f57af6f", "filename": "crates/ra_hir_def/src/dyn_map.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdyn_map.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -0,0 +1,108 @@\n+//! This module defines a `DynMap` -- a container for heterogeneous maps.\n+//!\n+//! This means that `DynMap` stores a bunch of hash maps inside, and those maps\n+//! can be of different types.\n+//!\n+//! It is used like this:\n+//!\n+//! ```\n+//! // keys define submaps of a `DynMap`\n+//! const STRING_TO_U32: Key<String, u32> = Key::new();\n+//! const U32_TO_VEC: Key<u32, Vec<bool>> = Key::new();\n+//!\n+//! // Note: concrete type, no type params!\n+//! let mut map = DynMap::new();\n+//!\n+//! // To access a specific map, index the `DynMap` by `Key`:\n+//! map[STRING_TO_U32].insert(\"hello\".to_string(), 92);\n+//! let value = map[U32_TO_VEC].get(92);\n+//! assert!(value.is_none());\n+//! ```\n+//!\n+//! This is a work of fiction. Any similarities to Kotlin's `BindingContext` are\n+//! a coincidence.\n+use std::{\n+    hash::Hash,\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+use anymap::Map;\n+use rustc_hash::FxHashMap;\n+\n+pub struct Key<K, V, P = (K, V)> {\n+    _phantom: PhantomData<(K, V, P)>,\n+}\n+\n+impl<K, V, P> Key<K, V, P> {\n+    pub(crate) const fn new() -> Key<K, V, P> {\n+        Key { _phantom: PhantomData }\n+    }\n+}\n+\n+impl<K, V, P> Copy for Key<K, V, P> {}\n+\n+impl<K, V, P> Clone for Key<K, V, P> {\n+    fn clone(&self) -> Key<K, V, P> {\n+        *self\n+    }\n+}\n+\n+pub trait Policy {\n+    type K;\n+    type V;\n+\n+    fn insert(map: &mut DynMap, key: Self::K, value: Self::V);\n+    fn get<'a>(map: &'a DynMap, key: &Self::K) -> Option<&'a Self::V>;\n+}\n+\n+impl<K: Hash + Eq + 'static, V: 'static> Policy for (K, V) {\n+    type K = K;\n+    type V = V;\n+    fn insert(map: &mut DynMap, key: K, value: V) {\n+        map.map.entry::<FxHashMap<K, V>>().or_insert_with(Default::default).insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &K) -> Option<&'a V> {\n+        map.map.get::<FxHashMap<K, V>>()?.get(key)\n+    }\n+}\n+\n+pub struct DynMap {\n+    pub(crate) map: Map,\n+}\n+\n+impl Default for DynMap {\n+    fn default() -> Self {\n+        DynMap { map: Map::new() }\n+    }\n+}\n+\n+#[repr(transparent)]\n+pub struct KeyMap<KEY> {\n+    map: DynMap,\n+    _phantom: PhantomData<KEY>,\n+}\n+\n+impl<P: Policy> KeyMap<Key<P::K, P::V, P>> {\n+    pub fn insert(&mut self, key: P::K, value: P::V) {\n+        P::insert(&mut self.map, key, value)\n+    }\n+    pub fn get(&self, key: &P::K) -> Option<&P::V> {\n+        P::get(&self.map, key)\n+    }\n+}\n+\n+impl<P: Policy> Index<Key<P::K, P::V, P>> for DynMap {\n+    type Output = KeyMap<Key<P::K, P::V, P>>;\n+    fn index(&self, _key: Key<P::K, P::V, P>) -> &Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&DynMap, &KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}\n+\n+impl<P: Policy> IndexMut<Key<P::K, P::V, P>> for DynMap {\n+    fn index_mut(&mut self, _key: Key<P::K, P::V, P>) -> &mut Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&mut DynMap, &mut KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}"}, {"sha": "447b7e3baa29384d16cc48eb63c4f2180049d941", "filename": "crates/ra_hir_def/src/keys.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -0,0 +1,48 @@\n+//! keys to be used with `DynMap`\n+\n+use std::marker::PhantomData;\n+\n+use hir_expand::InFile;\n+use ra_syntax::{ast, AstNode, AstPtr};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    dyn_map::{DynMap, Policy},\n+    ConstId, EnumVariantId, FunctionId, StaticId, StructFieldId, TypeAliasId,\n+};\n+\n+type Key<K, V> = crate::dyn_map::Key<InFile<K>, V, AstPtrPolicy<K, V>>;\n+\n+pub const FUNCTION: Key<ast::FnDef, FunctionId> = Key::new();\n+pub const CONST: Key<ast::ConstDef, ConstId> = Key::new();\n+pub const STATIC: Key<ast::StaticDef, StaticId> = Key::new();\n+pub const ENUM_VARIANT: Key<ast::EnumVariant, EnumVariantId> = Key::new();\n+pub const TYPE_ALIAS: Key<ast::TypeAliasDef, TypeAliasId> = Key::new();\n+pub const TUPLE_FIELD: Key<ast::TupleFieldDef, StructFieldId> = Key::new();\n+pub const RECORD_FIELD: Key<ast::RecordFieldDef, StructFieldId> = Key::new();\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+pub struct AstPtrPolicy<AST, ID> {\n+    _phantom: PhantomData<(AST, ID)>,\n+}\n+\n+impl<AST: AstNode + 'static, ID: 'static> Policy for AstPtrPolicy<AST, ID> {\n+    type K = InFile<AST>;\n+    type V = ID;\n+    fn insert(map: &mut DynMap, key: InFile<AST>, value: ID) {\n+        let key = key.as_ref().map(AstPtr::new);\n+        map.map\n+            .entry::<FxHashMap<InFile<AstPtr<AST>>, ID>>()\n+            .or_insert_with(Default::default)\n+            .insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &InFile<AST>) -> Option<&'a ID> {\n+        let key = key.as_ref().map(AstPtr::new);\n+        map.map.get::<FxHashMap<InFile<AstPtr<AST>>, ID>>()?.get(&key)\n+    }\n+}"}, {"sha": "68e66d276502360f56489e238df41c73a0199ba2", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -16,6 +16,9 @@ pub mod builtin_type;\n pub mod diagnostics;\n pub mod per_ns;\n \n+pub mod dyn_map;\n+pub mod keys;\n+\n pub mod adt;\n pub mod data;\n pub mod generics;\n@@ -30,7 +33,7 @@ mod trace;\n pub mod nameres;\n \n pub mod src;\n-pub mod child_from_source;\n+pub mod child_by_source;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "d724ee12237fe50a2808cd79c5147b7f6f385fd7", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -11,8 +11,8 @@ use std::fmt::Write;\n use std::sync::Arc;\n \n use hir_def::{\n-    body::BodySourceMap, child_from_source::ChildFromSource, db::DefDatabase, nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    body::BodySourceMap, child_by_source::ChildBySource, db::DefDatabase, keys,\n+    nameres::CrateDefMap, AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::InFile;\n use insta::assert_snapshot;\n@@ -33,7 +33,9 @@ fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n     let module = db.module_for_file(pos.file_id);\n-    let func = module.child_from_source(db, InFile::new(pos.file_id.into(), fn_def)).unwrap();\n+    let func = *module.child_by_source(db)[keys::FUNCTION]\n+        .get(&InFile::new(pos.file_id.into(), fn_def))\n+        .unwrap();\n \n     let (_body, source_map) = db.body_with_source_map(func.into());\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {"}, {"sha": "db6230aab969843956012a244f9f8d64b028394c", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18b7e18c479144325ec150be00837aae3329ae2/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=f18b7e18c479144325ec150be00837aae3329ae2", "patch": "@@ -1,6 +1,10 @@\n //! FIXME: write short doc here\n \n-use std::{iter::successors, marker::PhantomData};\n+use std::{\n+    hash::{Hash, Hasher},\n+    iter::successors,\n+    marker::PhantomData,\n+};\n \n use crate::{AstNode, SyntaxKind, SyntaxNode, TextRange};\n \n@@ -43,7 +47,7 @@ impl SyntaxNodePtr {\n }\n \n /// Like `SyntaxNodePtr`, but remembers the type of node\n-#[derive(Debug, Hash)]\n+#[derive(Debug)]\n pub struct AstPtr<N: AstNode> {\n     raw: SyntaxNodePtr,\n     _ty: PhantomData<fn() -> N>,\n@@ -64,6 +68,12 @@ impl<N: AstNode> PartialEq for AstPtr<N> {\n     }\n }\n \n+impl<N: AstNode> Hash for AstPtr<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.raw.hash(state)\n+    }\n+}\n+\n impl<N: AstNode> AstPtr<N> {\n     pub fn new(node: &N) -> AstPtr<N> {\n         AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }"}]}