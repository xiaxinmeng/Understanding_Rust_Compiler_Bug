{"sha": "de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMGZmYWRiNjcyMjM3MWI5ZWI2MzZlZTliMmQ0NjI3ZGI5ZTAyZmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-10T00:06:34Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-10T00:06:34Z"}, "message": "rustc: unify and simplify managing associated items.", "tree": {"sha": "07606b093a437afbcd869107014dd3d079e8c384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07606b093a437afbcd869107014dd3d079e8c384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "html_url": "https://github.com/rust-lang/rust/commit/de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da2ce2276873242a101f205537e7ce297d68f8dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/da2ce2276873242a101f205537e7ce297d68f8dd", "html_url": "https://github.com/rust-lang/rust/commit/da2ce2276873242a101f205537e7ce297d68f8dd"}], "stats": {"total": 2730, "additions": 1039, "deletions": 1691}, "files": [{"sha": "351feaba0346ab7e47a28146a074c0623f614528", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -103,11 +103,11 @@ pub enum DepNode<D: Clone + Debug> {\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n     // predicates for an item wind up in `ItemSignature`).\n-    ImplOrTraitItems(D),\n+    AssociatedItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    ImplOrTraitItemDefIds(D),\n+    AssociatedItemDefIds(D),\n     InherentImpls(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n@@ -153,10 +153,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,\n-            ImplOrTraitItems,\n+            AssociatedItems,\n             ItemSignature,\n             FieldTy,\n-            ImplOrTraitItemDefIds,\n+            AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n             ReprHints,\n@@ -219,11 +219,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n-            ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n+            AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n+            AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),"}, {"sha": "a1f226ab11d80df8b4bd9f3b9815b62828429550", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -147,7 +147,7 @@ pub trait CrateStore<'tcx> {\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n@@ -157,8 +157,8 @@ pub trait CrateStore<'tcx> {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>;\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -311,8 +311,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n-        { bug!(\"impl_or_trait_items\") }\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"associated_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n@@ -323,8 +323,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }"}, {"sha": "294cdd3b7614bbf7d736c4530c2dc88e20bd3df6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -471,11 +471,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n-            for impl_did in impl_list.iter() {\n-                for &item_did in &impl_items[impl_did][..] {\n+            for &impl_did in impl_list.iter() {\n+                for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                     if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;"}, {"sha": "0127ac9dc7223b93eb16be4d454df7296dca0765", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -227,8 +227,8 @@ impl OverloadedCallType {\n     }\n \n     fn from_method_id(tcx: TyCtxt, method_id: DefId) -> OverloadedCallType {\n-        let method = tcx.impl_or_trait_item(method_id);\n-        OverloadedCallType::from_trait_id(tcx, method.container().id())\n+        let method = tcx.associated_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container.id())\n     }\n }\n "}, {"sha": "d79833998d6c8ec442ae048f4dccb1bb2eef5b48", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -529,14 +529,11 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // items.\n         hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            let trait_items = tcx.trait_items(trait_did);\n-\n             for impl_item in impl_items {\n-                let item = trait_items.iter().find(|item| {\n-                    item.name() == impl_item.name\n-                }).unwrap();\n+                let item = tcx.associated_items(trait_did)\n+                    .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n+                    maybe_do_stability_check(tcx, item.def_id, impl_item.span, cb);\n                 }\n             }\n         }\n@@ -685,15 +682,8 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n }\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n-    match tcx.trait_item_of_item(id) {\n-        Some(trait_method_id) if trait_method_id != id => {\n-            is_staged_api(tcx, trait_method_id)\n-        }\n-        _ => {\n-            *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-                || tcx.sess.cstore.is_staged_api(id.krate))\n-        }\n-    }\n+    *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n+        || tcx.sess.cstore.is_staged_api(id.krate))\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "7e70fdb92e68b6ce1d9a476819a91822eac3226e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -663,25 +663,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                          in the supertrait listing\"\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::StaticMethod) => {\n-                    buf = format!(\"method `{}` has no receiver\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has no receiver\", name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::ReferencesSelf) => {\n                     buf = format!(\"method `{}` references the `Self` type \\\n                                        in its arguments or return type\",\n-                                  method.name);\n+                                  name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::Generic) => {\n-                    buf = format!(\"method `{}` has generic type parameters\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has generic type parameters\", name);\n                     &buf\n                 }\n             };"}, {"sha": "36405df6325af31618be834348c5ac2909512ad6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -578,18 +578,14 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n         tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n \n-        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n-        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n-            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n-                ty::MethodTraitItem(m) => Some(m),\n-                _ => None\n-            }\n-        });\n+        let trait_methods = tcx.associated_items(trait_ref.def_id())\n+            .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n         // Now list each method's DefId and Substs (for within its trait).\n         // If the method can never be called from this object, produce None.\n         trait_methods.map(move |trait_method| {\n             debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n \n             // Some methods cannot be called on an object; skip those.\n             if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n@@ -599,21 +595,21 @@ pub fn get_vtable_methods<'a, 'tcx>(\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let substs = Substs::for_item(tcx, trait_method.def_id,\n-                                            |_, _| tcx.mk_region(ty::ReErased),\n-                                            |def, _| trait_ref.substs().type_for_def(def));\n+            let substs = Substs::for_item(tcx, def_id,\n+                                          |_, _| tcx.mk_region(ty::ReErased),\n+                                          |def, _| trait_ref.substs().type_for_def(def));\n \n             // It's possible that the method relies on where clauses that\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;\n             }\n \n-            Some((trait_method.def_id, substs))\n+            Some((def_id, substs))\n         })\n     })\n }"}, {"sha": "c783bd561bb1a7bd73042397359218cb2424fe6f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -22,11 +22,10 @@ use super::elaborate_predicates;\n use hir::def_id::DefId;\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use std::rc::Rc;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObjectSafetyViolation<'tcx> {\n+pub enum ObjectSafetyViolation {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n \n@@ -35,7 +34,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n     SupertraitSelf,\n \n     /// Method has something illegal\n-    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+    Method(ast::Name, MethodViolationCode),\n }\n \n /// Reasons a method might not be object-safe.\n@@ -77,7 +76,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+                                            -> Vec<ObjectSafetyViolation>\n     {\n         let mut violations = vec![];\n \n@@ -93,29 +92,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn object_safety_violations(self, trait_def_id: DefId)\n-                                    -> Vec<ObjectSafetyViolation<'tcx>>\n+                                    -> Vec<ObjectSafetyViolation>\n     {\n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n     fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation<'tcx>>\n+                                          -> Vec<ObjectSafetyViolation>\n     {\n         // Check methods for violations.\n-        let mut violations: Vec<_> =\n-            self.trait_items(trait_def_id).iter()\n+        let mut violations: Vec<_> = self.associated_items(trait_def_id)\n+            .filter(|item| item.kind == ty::AssociatedKind::Method)\n             .filter_map(|item| {\n-                match *item {\n-                    ty::MethodTraitItem(ref m) => {\n-                        self.object_safety_violation_for_method(trait_def_id, &m)\n-                            .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n+                self.object_safety_violation_for_method(trait_def_id, &item)\n+                    .map(|code| ObjectSafetyViolation::Method(item.name, code))\n+            }).collect();\n \n         // Check the trait itself.\n         if self.trait_has_sized_self(trait_def_id) {\n@@ -198,7 +191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n     fn object_safety_violation_for_method(self,\n                                           trait_def_id: DefId,\n-                                          method: &ty::Method<'gcx>)\n+                                          method: &ty::AssociatedItem)\n                                           -> Option<MethodViolationCode>\n     {\n         // Any method that has a `Self : Sized` requisite is otherwise\n@@ -216,7 +209,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// otherwise ensure that they cannot be used when `Self=Trait`.\n     pub fn is_vtable_safe_method(self,\n                                  trait_def_id: DefId,\n-                                 method: &ty::Method<'gcx>)\n+                                 method: &ty::AssociatedItem)\n                                  -> bool\n     {\n         // Any method that has a `Self : Sized` requisite can't be called.\n@@ -233,26 +226,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `Self:Sized`.\n     fn virtual_call_violation_for_method(self,\n                                          trait_def_id: DefId,\n-                                         method: &ty::Method<'tcx>)\n+                                         method: &ty::AssociatedItem)\n                                          -> Option<MethodViolationCode>\n     {\n         // The method's first parameter must be something that derefs (or\n         // autorefs) to `&self`. For now, we only accept `self`, `&self`\n         // and `Box<Self>`.\n-        match method.explicit_self {\n-            ty::ExplicitSelfCategory::Static => {\n-                return Some(MethodViolationCode::StaticMethod);\n-            }\n-\n-            ty::ExplicitSelfCategory::ByValue |\n-            ty::ExplicitSelfCategory::ByReference(..) |\n-            ty::ExplicitSelfCategory::ByBox => {\n-            }\n+        if !method.method_has_self_argument {\n+            return Some(MethodViolationCode::StaticMethod);\n         }\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = method.fty.sig;\n+        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -263,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !method.generics.types.is_empty() {\n+        if !self.lookup_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "b1ab61b09757e69babf1719dd7d415768a097858", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -33,8 +33,6 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::FN_OUTPUT_NAME;\n \n-use std::rc::Rc;\n-\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -945,7 +943,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                         // an error when we confirm the candidate\n                         // (which will ultimately lead to `normalize_to_error`\n                         // being invoked).\n-                        node_item.item.ty.is_some()\n+                        node_item.item.has_value\n                     } else {\n                         node_item.item.defaultness.is_default()\n                     };\n@@ -1305,7 +1303,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     match assoc_ty {\n         Some(node_item) => {\n-            let ty = node_item.item.ty.unwrap_or_else(|| {\n+            let ty = if !node_item.item.has_value {\n                 // This means that the impl is missing a definition for the\n                 // associated type. This error will be reported by the type\n                 // checker method `check_impl_items_against_trait`, so here we\n@@ -1314,7 +1312,9 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        node_item.item.name,\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n-            });\n+            } else {\n+                tcx.lookup_item_type(node_item.item.def_id).ty\n+            };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {\n                 ty: ty.subst(tcx, substs),\n@@ -1339,27 +1339,25 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n \n     if selcx.projection_mode() == Reveal::ExactMatch {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n-            if let ty::TypeTraitItem(assoc_ty) = item {\n-                if assoc_ty.name == assoc_ty_name {\n-                    return Some(specialization_graph::NodeItem {\n-                        node: specialization_graph::Node::Impl(impl_def_id),\n-                        item: assoc_ty,\n-                    });\n-                }\n+            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+                return Some(specialization_graph::NodeItem {\n+                    node: specialization_graph::Node::Impl(impl_def_id),\n+                    item: item,\n+                });\n             }\n         }\n         None\n     } else {\n         selcx.tcx().lookup_trait_def(trait_def_id)\n             .ancestors(impl_def_id)\n-            .type_defs(selcx.tcx(), assoc_ty_name)\n+            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n             .next()\n     }\n }"}, {"sha": "91c40a5cc85161872f5a37ff4764676014741e2b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -120,7 +120,8 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n \n-    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);"}, {"sha": "5a6809f1fad6829824078529e8d4b106f492645e", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 14, "deletions": 128, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n-\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n@@ -285,12 +283,10 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        NodeItems {\n-            tcx: tcx.global_tcx(),\n-            items: tcx.impl_or_trait_items(self.def_id()),\n-            idx: 0,\n-        }\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                 -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        tcx.associated_items(self.def_id())\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -301,28 +297,6 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-/// An iterator over the items defined within a trait or impl.\n-pub struct NodeItems<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    items: Rc<Vec<DefId>>,\n-    idx: usize\n-}\n-\n-impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n-    type Item = ImplOrTraitItem<'tcx>;\n-    fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        if self.idx < self.items.len() {\n-            let item_def_id = self.items[self.idx];\n-            let items_table = self.tcx.impl_or_trait_items.borrow();\n-            let item = items_table[&item_def_id].clone();\n-            self.idx += 1;\n-            Some(item)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n pub struct Ancestors<'a, 'tcx: 'a> {\n     trait_def: &'a TraitDef<'tcx>,\n     current_source: Option<Node>,\n@@ -358,104 +332,16 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-pub struct TypeDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for TypeDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct FnDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::Method<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for FnDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::Method<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct ConstDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n-    /// Search the items from the given ancestors, returning each type definition\n-    /// with the given name.\n-    pub fn type_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> TypeDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::TypeTraitItem(assoc_ty) = item {\n-                        if assoc_ty.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: assoc_ty,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        TypeDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each fn definition\n-    /// with the given name.\n-    pub fn fn_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> FnDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::MethodTraitItem(method) = item {\n-                        if method.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: method,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        FnDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each const\n-    /// definition with the given name.\n-    pub fn const_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> ConstDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::ConstTraitItem(konst) = item {\n-                        if konst.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: konst,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        ConstDefs { iter: Box::new(iter) }\n+    /// Search the items from the given ancestors, returning each definition\n+    /// with the given name and the given kind.\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name, kind: ty::AssociatedKind)\n+                -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n+        self.flat_map(move |node| {\n+            node.items(tcx).filter(move |item| item.kind == kind && item.name == name)\n+                           .map(move |item| NodeItem { node: node, item: item })\n+        })\n     }\n }\n "}, {"sha": "9346bbd30f9ceb2485db154e88e44c162480e732", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -477,8 +477,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut entries = 0;\n         // Count number of methods and add them to the total offset.\n         // Skip over associated types and constants.\n-        for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+        for trait_item in self.associated_items(trait_ref.def_id()) {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }\n@@ -495,17 +495,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // add them to the total offset.\n         // Skip over associated types and constants.\n         let mut entries = object.vtable_base;\n-        for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n-            if trait_item.def_id() == method_def_id {\n+        for trait_item in self.associated_items(object.upcast_trait_ref.def_id()) {\n+            if trait_item.def_id == method_def_id {\n                 // The item with the ID we were given really ought to be a method.\n-                assert!(match *trait_item {\n-                    ty::MethodTraitItem(_) => true,\n-                    _ => false\n-                });\n-\n+                assert_eq!(trait_item.kind, ty::AssociatedKind::Method);\n                 return entries;\n             }\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }"}, {"sha": "60a48ba580a0deca18da0de083cf263d7792344a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -403,14 +403,10 @@ pub struct GlobalCtxt<'tcx> {\n     pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n+    pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n-\n-    /// A cache for the trait_items() routine; note that the routine\n-    /// itself pushes the `TraitItems` dependency node.\n-    trait_items_cache: RefCell<DepTrackingMap<maps::TraitItems<'tcx>>>,\n+    pub associated_item_def_ids: RefCell<DepTrackingMap<maps::AssociatedItemDefIds<'tcx>>>,\n \n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n@@ -822,9 +818,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n-            impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n@@ -1539,15 +1534,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n \n-    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n-        self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.impl_or_trait_items(trait_did);\n-            Rc::new(def_ids.iter()\n-                           .map(|&def_id| self.impl_or_trait_item(def_id))\n-                           .collect())\n-        })\n-    }\n-\n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {"}, {"sha": "43abb61e7fcd83ff08943bd24180d8a96e922c21", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty};\n use std::cell::RefCell;\n use std::marker::PhantomData;\n use std::rc::Rc;\n-use syntax::{attr, ast};\n+use syntax::attr;\n \n macro_rules! dep_map_ty {\n     ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n@@ -32,18 +32,16 @@ macro_rules! dep_map_ty {\n     }\n }\n \n-dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n+dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n-dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }"}, {"sha": "1d260fd65feffba808d69a2217b61c51ba28544d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 152, "deletions": 244, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -10,9 +10,8 @@\n \n pub use self::Variance::*;\n pub use self::DtorKind::*;\n-pub use self::ImplOrTraitItemContainer::*;\n+pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;\n-pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n@@ -135,12 +134,12 @@ impl DtorKind {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum ImplOrTraitItemContainer {\n+pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n }\n \n-impl ImplOrTraitItemContainer {\n+impl AssociatedItemContainer {\n     pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -183,58 +182,34 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n-pub enum ImplOrTraitItem<'tcx> {\n-    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n-    MethodTraitItem(Rc<Method<'tcx>>),\n-    TypeTraitItem(Rc<AssociatedType<'tcx>>),\n-}\n-\n-impl<'tcx> ImplOrTraitItem<'tcx> {\n-    pub fn def(&self) -> Def {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n-            MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n-        }\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.def_id,\n-            MethodTraitItem(ref method) => method.def_id,\n-            TypeTraitItem(ref associated_type) => associated_type.def_id,\n-        }\n-    }\n-\n-    pub fn name(&self) -> Name {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.name,\n-            MethodTraitItem(ref method) => method.name,\n-            TypeTraitItem(ref associated_type) => associated_type.name,\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub struct AssociatedItem {\n+    pub def_id: DefId,\n+    pub name: Name,\n+    pub kind: AssociatedKind,\n+    pub vis: Visibility,\n+    pub defaultness: hir::Defaultness,\n+    pub has_value: bool,\n+    pub container: AssociatedItemContainer,\n \n-    pub fn vis(&self) -> Visibility {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.vis,\n-            MethodTraitItem(ref method) => method.vis,\n-            TypeTraitItem(ref associated_type) => associated_type.vis,\n-        }\n-    }\n+    /// Whether this is a method with an explicit self\n+    /// as its first argument, allowing method calls.\n+    pub method_has_self_argument: bool,\n+}\n \n-    pub fn container(&self) -> ImplOrTraitItemContainer {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.container,\n-            MethodTraitItem(ref method) => method.container,\n-            TypeTraitItem(ref associated_type) => associated_type.container,\n-        }\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AssociatedKind {\n+    Const,\n+    Method,\n+    Type\n+}\n \n-    pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n-        match *self {\n-            MethodTraitItem(ref m) => Some((*m).clone()),\n-            _ => None,\n+impl AssociatedItem {\n+    pub fn def(&self) -> Def {\n+        match self.kind {\n+            AssociatedKind::Const => Def::AssociatedConst(self.def_id),\n+            AssociatedKind::Method => Def::Method(self.def_id),\n+            AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n         }\n     }\n }\n@@ -308,64 +283,6 @@ impl Visibility {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Method<'tcx> {\n-    pub name: Name,\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub predicates: GenericPredicates<'tcx>,\n-    pub fty: &'tcx BareFnTy<'tcx>,\n-    pub explicit_self: ExplicitSelfCategory<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub has_body: bool,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n-impl<'tcx> Method<'tcx> {\n-    pub fn container_id(&self) -> DefId {\n-        match self.container {\n-            TraitContainer(id) => id,\n-            ImplContainer(id) => id,\n-        }\n-    }\n-}\n-\n-impl<'tcx> PartialEq for Method<'tcx> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool { self.def_id == other.def_id }\n-}\n-\n-impl<'tcx> Eq for Method<'tcx> {}\n-\n-impl<'tcx> Hash for Method<'tcx> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.def_id.hash(s)\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedConst<'tcx> {\n-    pub name: Name,\n-    pub ty: Ty<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-    pub has_value: bool\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedType<'tcx> {\n-    pub name: Name,\n-    pub ty: Option<Ty<'tcx>>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -1288,19 +1205,10 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                tcx.construct_parameter_environment(\n-                                    impl_item.span,\n-                                    method_ty.def_id,\n-                                    tcx.region_maps.call_site_extent(id, body.id))\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from impl method?!\")\n-                            }\n-                        }\n+                        tcx.construct_parameter_environment(\n+                            impl_item.span,\n+                            tcx.map.local_def_id(id),\n+                            tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                 }\n             }\n@@ -1319,27 +1227,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                let extent = if let Some(ref body) = *body {\n-                                    // default impl: use call_site extent as free_id_outlive bound.\n-                                    tcx.region_maps.call_site_extent(id, body.id)\n-                                } else {\n-                                    // no default impl: use item extent as free_id_outlive bound.\n-                                    tcx.region_maps.item_extent(id)\n-                                };\n-                                tcx.construct_parameter_environment(\n-                                    trait_item.span,\n-                                    method_ty.def_id,\n-                                    extent)\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from provided \\\n-                                      method?!\")\n-                            }\n-                        }\n+                        let extent = if let Some(ref body) = *body {\n+                            // default impl: use call_site extent as free_id_outlive bound.\n+                            tcx.region_maps.call_site_extent(id, body.id)\n+                        } else {\n+                            // no default impl: use item extent as free_id_outlive bound.\n+                            tcx.region_maps.item_extent(id)\n+                        };\n+                        tcx.construct_parameter_environment(\n+                            trait_item.span,\n+                            tcx.map.local_def_id(id),\n+                            extent)\n                     }\n                 }\n             }\n@@ -2065,7 +1963,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.impl_or_trait_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2204,13 +2102,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n-            match self.impl_or_trait_item(def_id) {\n-                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n-                _ => None\n-            }\n-        }).collect()\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n+        self.associated_items(id)\n+            .filter(|item| item.kind == AssociatedKind::Method && item.has_value)\n+            .collect()\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n@@ -2243,17 +2138,105 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self.global_tcx(), id)\n-                   .expect(\"missing ImplOrTraitItem in metadata\"))\n+    pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n+        self.associated_items.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n+                           .expect(\"missing AssociatedItem in metadata\");\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let parent_id = self.map.get_parent(id);\n+            let parent_def_id = self.map.local_def_id(parent_id);\n+            match self.map.get(id) {\n+                ast_map::NodeTraitItem(trait_item) => {\n+                    let (kind, has_self, has_value) = match trait_item.node {\n+                        hir::MethodTraitItem(ref sig, ref body) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                             body.is_some())\n+                        }\n+                        hir::ConstTraitItem(_, ref value) => {\n+                            (AssociatedKind::Const, false, value.is_some())\n+                        }\n+                        hir::TypeTraitItem(_, ref ty) => {\n+                            (AssociatedKind::Type, false, ty.is_some())\n+                        }\n+                    };\n+\n+                    AssociatedItem {\n+                        name: trait_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n+                        defaultness: hir::Defaultness::Default,\n+                        has_value: has_value,\n+                        def_id: def_id,\n+                        container: TraitContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                ast_map::NodeImplItem(impl_item) => {\n+                    let (kind, has_self) = match impl_item.node {\n+                        hir::ImplItemKind::Method(ref sig, _) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n+                        }\n+                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n+                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n+                    };\n+\n+                    // Trait impl items are always public.\n+                    let public = hir::Public;\n+                    let parent_item = self.map.expect_item(parent_id);\n+                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n+                        &public\n+                    } else {\n+                        &impl_item.vis\n+                    };\n+\n+                    AssociatedItem {\n+                        name: impl_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(vis, id, self),\n+                        defaultness: impl_item.defaultness,\n+                        has_value: true,\n+                        def_id: def_id,\n+                        container: ImplContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+            }\n+        })\n     }\n \n-    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n+    pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n+        self.associated_item_def_ids.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let item = self.map.expect_item(id);\n+            match item.node {\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    Rc::new(trait_items.iter().map(|trait_item| {\n+                        self.map.local_def_id(trait_item.id)\n+                    }).collect())\n+                }\n+                hir::ItemImpl(.., ref impl_items) => {\n+                    Rc::new(impl_items.iter().map(|impl_item| {\n+                        self.map.local_def_id(impl_item.id)\n+                    }).collect())\n+                }\n+                _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n+            }\n+        })\n+    }\n+\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn associated_items(self, def_id: DefId)\n+                            -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        let def_ids = self.associated_item_def_ids(def_id);\n+        (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2539,31 +2522,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Load primitive inherent implementations if necessary\n-    pub fn populate_implementations_for_primitive_if_necessary(self,\n-                                                               primitive_def_id: DefId) {\n-        if primitive_def_id.is_local() {\n-            return\n-        }\n-\n-        // The primitive is not local, hence we are reading this out\n-        // of metadata.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n-               primitive_def_id);\n-\n-        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n-\n-        // Store the implementation info.\n-        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n-        self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n-    }\n-\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(self,\n@@ -2584,11 +2542,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                type_id);\n \n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-        for &impl_def_id in &inherent_impls {\n-            // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n-        }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n@@ -2617,23 +2570,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n             let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n             def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-\n-            // For any methods that use a default implementation, add them to\n-            // the map. This is a bit unfortunate.\n-            for &impl_item_def_id in &impl_items {\n-                // load impl items eagerly for convenience\n-                // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(impl_item_def_id);\n-            }\n-\n-            // Store the implementation info.\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2679,17 +2620,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.impl_or_trait_item(self.global_tcx(), def_id)\n+            return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n                        .and_then(|item| {\n-                match item.container() {\n+                match item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n             });\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n+        match self.associated_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {\n-                match trait_item.container() {\n+                match trait_item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n@@ -2705,9 +2646,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(impl_or_trait_item) => {\n-                match impl_or_trait_item.container() {\n+        match self.associated_items.borrow().get(&def_id) {\n+            Some(associated_item) => {\n+                match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),\n                     ImplContainer(_) => None\n                 }\n@@ -2716,30 +2657,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// If the given def ID describes an item belonging to a trait, (either a\n-    /// default method or an implementation of a trait method), return the ID of\n-    /// the method inside trait definition (this means that if the given def ID\n-    /// is already that of the original trait method, then the return value is\n-    /// the same).\n-    /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n-        let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(m) => m.clone(),\n-            None => return None,\n-        };\n-        match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n-            ImplContainer(def_id) => {\n-                self.trait_id_of_impl(def_id).and_then(|trait_did| {\n-                    let name = impl_or_trait_item.name();\n-                    self.trait_items(trait_did).iter()\n-                        .find(|item| item.name() == name)\n-                        .map(|item| item.def_id())\n-                })\n-            }\n-        }\n-    }\n-\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n@@ -2856,15 +2773,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ExplicitSelfCategory<'tcx> {\n-    Static,\n-    ByValue,\n-    ByReference(&'tcx Region, hir::Mutability),\n-    ByBox,\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,"}, {"sha": "01b44ced8e08ec0308e0b3ba0fd88af13a4b1176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -670,18 +670,6 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ImplOrTraitItem(\")?;\n-        match *self {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n-        }?;\n-        write!(f, \")\")\n-    }\n-}\n-\n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"fn\")?;\n@@ -995,20 +983,6 @@ impl fmt::Display for ty::InferTy {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ExplicitSelfCategory<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::ExplicitSelfCategory::Static => \"static\",\n-            ty::ExplicitSelfCategory::ByValue => \"self\",\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutMutable) => {\n-                \"&mut self\"\n-            }\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutImmutable) => \"&self\",\n-            ty::ExplicitSelfCategory::ByBox => \"Box<self>\",\n-        })\n-    }\n-}\n-\n impl fmt::Display for ty::ParamTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.name)"}, {"sha": "08b8f4c8941cc1eab66cdadbbd8dc325661fb990", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -1091,13 +1091,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match tcx.impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ic) => Some(ic),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == ti.name);\n+                let ac = tcx.associated_items(impl_data.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == ti.name);\n                 match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                     None => match ti.node {"}, {"sha": "28d45080284cdfba312aefd96c4055b37dce522d", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -29,10 +29,10 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n-    match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n+    match cx.tcx.associated_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n-            match item.container() {\n+            match item.container {\n                 ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n                 ty::ImplContainer(cid) => {\n                     match cx.tcx.impl_trait_ref(cid) {"}, {"sha": "af05724d9f951a0d3414c9c2de0d7b4ddef87e14", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -818,7 +818,7 @@ impl LateLintPass for UnconditionalRecursion {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n+                Some(cx.tcx.associated_item(cx.tcx.map.local_def_id(id)))\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure(_) => return,\n@@ -937,7 +937,7 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                method: &ty::Method,\n+                                                method: &ty::AssociatedItem,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n             use rustc::ty::adjustment::*;\n@@ -986,14 +986,14 @@ impl LateLintPass for UnconditionalRecursion {\n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n         fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  method: &ty::Method,\n+                                                  method: &ty::AssociatedItem,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n                                                   expr_id: ast::NodeId)\n                                                   -> bool {\n-            let callee_item = tcx.impl_or_trait_item(callee_id);\n+            let callee_item = tcx.associated_item(callee_id);\n \n-            match callee_item.container() {\n+            match callee_item.container {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n                 ty::ImplContainer(_) => callee_id == method.def_id,\n@@ -1034,7 +1034,7 @@ impl LateLintPass for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container && callee_item.name() == method.name\n+                                container == method.container && callee_item.name == method.name\n                             }\n \n                             // There's no way to know if this call is"}, {"sha": "18ce514c9c42d302f4ceaf8c4127c5fa88d6a83a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n@@ -182,11 +182,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>\n+    fn associated_item<'a>(&self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_or_trait_item(def.index, tcx)\n+        self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n@@ -427,9 +427,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 // the logic to do that already exists in `middle`. In order to\n                 // reuse that code, it needs to be able to look up the traits for\n                 // inlined items.\n-                let ty_trait_item = tcx.impl_or_trait_item(def_id).clone();\n+                let ty_trait_item = tcx.associated_item(def_id).clone();\n                 let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-                tcx.impl_or_trait_items.borrow_mut()\n+                tcx.associated_items.borrow_mut()\n                    .insert(trait_item_def_id, ty_trait_item);\n             }\n             Some(&InlinedItem::ImplItem(_, ref impl_item)) => {"}, {"sha": "7973cd880fe344d7aa60bececd8c1910369a480e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -36,7 +36,6 @@ use std::borrow::Cow;\n use std::cell::Ref;\n use std::io;\n use std::mem;\n-use std::rc::Rc;\n use std::str;\n use std::u32;\n \n@@ -792,10 +791,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n-    pub fn get_impl_or_trait_item(&self,\n-                                  id: DefIndex,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                  -> Option<ty::ImplOrTraitItem<'tcx>> {\n+    pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n             let def_key = item.def_key.decode(self);\n@@ -806,52 +802,43 @@ impl<'a, 'tcx> CrateMetadata {\n         Some(match item.kind {\n             EntryKind::AssociatedConst(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.unwrap().decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Const,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                    has_value: container.has_body(),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             EntryKind::Method(data) => {\n                 let (parent, name) = parent_and_name();\n-                let ity = item.ty.unwrap().decode((self, tcx));\n-                let fty = match ity.sty {\n-                    ty::TyFnDef(.., fty) => fty,\n-                    _ => {\n-                        bug!(\"the type {:?} of the method {:?} is not a function?\",\n-                             ity,\n-                             name)\n-                    }\n-                };\n-\n                 let data = data.decode(self);\n-                ty::MethodTraitItem(Rc::new(ty::Method {\n+                ty::AssociatedItem {\n                     name: name,\n-                    generics: tcx.lookup_generics(self.local_def_id(id)),\n-                    predicates: item.predicates.unwrap().decode((self, tcx)),\n-                    fty: fty,\n-                    explicit_self: data.explicit_self.decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Method,\n                     vis: item.visibility,\n                     defaultness: data.container.defaultness(),\n-                    has_body: data.container.has_body(),\n+                    has_value: data.container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: data.has_self\n+                }\n             }\n             EntryKind::AssociatedType(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.map(|ty| ty.decode((self, tcx))),\n+                    kind: ty::AssociatedKind::Type,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             _ => return None,\n         })"}, {"sha": "2379e744c49e14e5971c110cd09141826a4d2870", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -457,19 +457,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = tcx.map.expect_trait_item(node_id);\n-        let trait_item = tcx.impl_or_trait_item(def_id);\n+        let trait_item = tcx.associated_item(def_id);\n \n-        let container = |has_body| if has_body {\n+        let container = if trait_item.has_value {\n             AssociatedContainer::TraitWithDefault\n         } else {\n             AssociatedContainer::TraitRequired\n         };\n \n-        let kind = match trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                EntryKind::AssociatedConst(container(associated_const.has_value))\n-            }\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match trait_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n@@ -478,39 +476,44 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n-                    container: container(method_ty.has_body),\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    container: container,\n+                    has_self: trait_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container(false)),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container),\n         };\n \n         Entry {\n             kind: kind,\n-            visibility: trait_item.vis().simplify(),\n+            visibility: trait_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match trait_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n+            ty: match trait_item.kind {\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                ty::AssociatedKind::Type => {\n+                    if trait_item.has_value {\n+                        Some(self.encode_item_type(def_id))\n+                    } else {\n+                        None\n+                    }\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let ty::ConstTraitItem(_) = trait_item {\n-                let trait_def_id = trait_item.container().id();\n+            ast: if trait_item.kind == ty::AssociatedKind::Const {\n+                let trait_def_id = trait_item.container.id();\n                 Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n             } else {\n                 None\n@@ -522,17 +525,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n-        let impl_item = self.tcx.impl_or_trait_item(def_id);\n-        let impl_def_id = impl_item.container().id();\n+        let impl_item = self.tcx.associated_item(def_id);\n+        let impl_def_id = impl_item.container.id();\n \n-        let container = match ast_item.defaultness {\n+        let container = match impl_item.defaultness {\n             hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n             hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n         };\n \n-        let kind = match impl_item {\n-            ty::ConstTraitItem(_) => EntryKind::AssociatedConst(container),\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match impl_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n@@ -541,17 +544,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n                     container: container,\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    has_self: impl_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n+        let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n             let generics = self.tcx.lookup_generics(def_id);\n@@ -565,20 +567,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: impl_item.vis().simplify(),\n+            visibility: impl_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match impl_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n-                }\n-            },\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n@@ -758,7 +754,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n                 hir::ItemImpl(..) |\n                 hir::ItemTrait(..) => {\n-                    self.lazy_seq(tcx.impl_or_trait_items(def_id).iter().map(|&def_id| {\n+                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n@@ -880,14 +876,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemImpl(..) => {\n-                for &trait_item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &trait_item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(trait_item_def_id,\n                                 EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                for &item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(item_def_id,\n                                 EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);"}, {"sha": "ff2a764571025fb64a650b9692bbbd69c0f5a879", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -245,7 +245,7 @@ pub enum EntryKind<'tcx> {\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData<'tcx>>),\n+    Method(Lazy<MethodData>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer),\n }\n@@ -300,7 +300,7 @@ pub enum AssociatedContainer {\n }\n \n impl AssociatedContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n+    pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n             AssociatedContainer::TraitRequired |\n             AssociatedContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -310,7 +310,7 @@ impl AssociatedContainer {\n         }\n     }\n \n-    pub fn has_body(&self) -> bool {\n+    pub fn has_value(&self) -> bool {\n         match *self {\n             AssociatedContainer::TraitRequired => false,\n \n@@ -332,10 +332,10 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+pub struct MethodData {\n     pub fn_data: FnData,\n     pub container: AssociatedContainer,\n-    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>,\n+    pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "ecc2d8fe050adc23be4a56ecb8277856e20c3240", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -147,20 +147,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n-        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n-            match *trait_item {\n-                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                    if method.name == method_name {\n-                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, substs);\n-                        return (method_ty, Literal::Item {\n-                            def_id: method.def_id,\n-                            substs: substs,\n-                        });\n-                    }\n-                }\n-                ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+        for item in self.tcx.associated_items(trait_def_id) {\n+            if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n+                let method_ty = self.tcx.lookup_item_type(item.def_id);\n+                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                return (method_ty, Literal::Item {\n+                    def_id: item.def_id,\n+                    substs: substs,\n+                });\n             }\n         }\n "}, {"sha": "1ab99b822d08d3b9a3d96845718ca2f22293eaa3", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -542,7 +542,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n                 Some(Def::Method(did)) => {\n-                    match v.tcx.impl_or_trait_item(did).container() {\n+                    match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)\n                         }\n@@ -557,7 +557,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprMethodCall(..) => {\n             let method = v.tcx.tables().method_map[&method_call];\n-            let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n+            let is_const = match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n             };"}, {"sha": "dc7399e228908bee2ad0a3daec05455c8527ffaa", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, method_def_id: DefId) {\n-        match self.tcx.impl_or_trait_item(method_def_id).container() {\n+        match self.tcx.associated_item(method_def_id).container {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {"}, {"sha": "cb8dd7250b496e550fa79eafad23f6fb807f6a4c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -456,7 +456,7 @@ impl<'b> Resolver<'b> {\n                 self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n-                let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n+                let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n                 for trait_item_def_id in trait_item_def_ids {\n                     let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n                                               .disambiguated_data.data.get_opt_name()"}, {"sha": "148a24f1358c53fe83de347719dac5cd51906790", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n-use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n+use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n \n use std::collections::HashSet;\n use std::collections::hash_map::DefaultHasher;\n@@ -402,19 +402,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             // with the right name.\n             if !self.span.filter_generated(Some(method_data.span), span) {\n                 let container =\n-                    self.tcx.impl_or_trait_item(self.tcx.map.local_def_id(id)).container();\n+                    self.tcx.associated_item(self.tcx.map.local_def_id(id)).container;\n                 let mut trait_id;\n                 let mut decl_id = None;\n                 match container {\n-                    ImplOrTraitItemContainer::ImplContainer(id) => {\n+                    AssociatedItemContainer::ImplContainer(id) => {\n                         trait_id = self.tcx.trait_id_of_impl(id);\n \n                         match trait_id {\n                             Some(id) => {\n-                                for item in &**self.tcx.trait_items(id) {\n-                                    if let &ImplOrTraitItem::MethodTraitItem(ref m) = item {\n-                                        if m.name == name {\n-                                            decl_id = Some(m.def_id);\n+                                for item in self.tcx.associated_items(id) {\n+                                    if item.kind == ty::AssociatedKind::Method {\n+                                        if item.name == name {\n+                                            decl_id = Some(item.def_id);\n                                             break;\n                                         }\n                                     }\n@@ -429,7 +429,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             }\n                         }\n                     }\n-                    ImplOrTraitItemContainer::TraitContainer(id) => {\n+                    AssociatedItemContainer::TraitContainer(id) => {\n                         trait_id = Some(id);\n                     }\n                 }\n@@ -916,11 +916,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // Modules or types in the path prefix.\n         match self.tcx.expect_def(id) {\n             Def::Method(did) => {\n-                let ti = self.tcx.impl_or_trait_item(did);\n-                if let ty::MethodTraitItem(m) = ti {\n-                    if m.explicit_self == ty::ExplicitSelfCategory::Static {\n-                        self.write_sub_path_trait_truncated(path);\n-                    }\n+                let ti = self.tcx.associated_item(did);\n+                if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n+                    self.write_sub_path_trait_truncated(path);\n                 }\n             }\n             Def::Fn(..) |"}, {"sha": "fded34d2c856c74bf0e436dc4c51ddb539084c1a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -313,7 +313,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            name: ast::Name, span: Span) -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, vis, docs) =\n+        let (qualname, parent_scope, decl_id, vis, docs) =\n           match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n                 Some(NodeItem(item)) => {\n@@ -323,12 +323,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+                            let mut decl_id = None;\n                             if let Some(def_id) = trait_id {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n+                                self.tcx.associated_items(def_id)\n+                                    .find(|item| item.name == name)\n+                                    .map(|item| decl_id = Some(item.def_id));\n                             }\n                             result.push_str(\">\");\n-                            (result, trait_id, From::from(&item.vis), docs_for_attrs(&item.attrs))\n+\n+                            (result, trait_id, decl_id,\n+                             From::from(&item.vis),\n+                             docs_for_attrs(&item.attrs))\n                         }\n                         _ => {\n                             span_bug!(span,\n@@ -351,7 +358,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match self.tcx.map.get_if_local(def_id) {\n                         Some(NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n-                             Some(def_id),\n+                             Some(def_id), None,\n                              From::from(&item.vis),\n                              docs_for_attrs(&item.attrs))\n                         }\n@@ -373,15 +380,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_def_id| {\n-            if new_def_id != def_id {\n-                Some(new_def_id)\n-            } else {\n-                None\n-            }\n-        });\n-\n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n         Some(FunctionData {\n@@ -473,7 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method_id = self.tcx.tables().method_map[&method_call].def_id;\n-                let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n+                let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n@@ -535,21 +533,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n-                    let ti = self.tcx.impl_or_trait_item(decl_id);\n-                    match ti.container() {\n-                        ty::TraitContainer(def_id) => {\n-                            self.tcx\n-                                .trait_items(def_id)\n-                                .iter()\n-                                .find(|mr| mr.name() == ti.name() && self.trait_method_has_body(mr))\n-                                .map(|mr| mr.def_id())\n-                        }\n-                        ty::ImplContainer(def_id) => {\n-                            Some(*self.tcx.impl_or_trait_items(def_id).iter().find(|&&mr| {\n-                                self.tcx.impl_or_trait_item(mr).name() == ti.name()\n-                            }).unwrap())\n-                        }\n-                    }\n+                    let ti = self.tcx.associated_item(decl_id);\n+                    self.tcx.associated_items(ti.container.id())\n+                        .find(|item| item.name == ti.name && item.has_value)\n+                        .map(|item| item.def_id)\n                 } else {\n                     None\n                 };\n@@ -582,20 +569,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n-        let def_id = mr.def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-            let trait_item = self.tcx.map.expect_trait_item(node_id);\n-            if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n                               variant: ty::VariantDef,"}, {"sha": "2c0ba36f3b412fd4c7cbbcf1e1d0bc73936320c7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -844,17 +844,12 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            param_substs);\n \n     if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n-        match scx.tcx().impl_or_trait_item(fn_def_id) {\n-            ty::MethodTraitItem(ref method) => {\n-                debug!(\" => trait method, attempting to find impl\");\n-                do_static_trait_method_dispatch(scx,\n-                                                method,\n-                                                trait_def_id,\n-                                                fn_substs,\n-                                                param_substs)\n-            }\n-            _ => bug!()\n-        }\n+        debug!(\" => trait method, attempting to find impl\");\n+        do_static_trait_method_dispatch(scx,\n+                                        &scx.tcx().associated_item(fn_def_id),\n+                                        trait_def_id,\n+                                        fn_substs,\n+                                        param_substs)\n     } else {\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n@@ -866,7 +861,7 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trait_method: &ty::Method,\n+                                             trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n@@ -1187,7 +1182,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if !method.generics.types.is_empty() {\n+                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n "}, {"sha": "b8d346b11c13f1500c4c4c2e2063b87b95777e72", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -248,13 +248,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n-                let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match ccx.tcx().impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ac) => Some(ac),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == name);\n+                let ac = ccx.tcx().associated_items(vtable_impl.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 if let Some(ac) = ac {\n                     instance = Instance::new(ac.def_id, vtable_impl.substs);\n                 }"}, {"sha": "513b4860d5e8748fd30a739b7d45bec9e248fecf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 101, "deletions": 133, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -107,11 +107,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n-    /// Returns true if the trait with id `trait_def_id` defines an\n-    /// associated type with the name `name`.\n-    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, name: ast::Name)\n-                                           -> bool;\n-\n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n     /// within a fn body.\n@@ -831,6 +826,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         Some(self_ty))\n     }\n \n+    fn trait_defines_associated_type_named(&self,\n+                                           trait_def_id: DefId,\n+                                           assoc_name: ast::Name)\n+                                           -> bool\n+    {\n+        self.tcx().associated_items(trait_def_id).any(|item| {\n+            item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+        })\n+    }\n+\n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n         path_id: ast::NodeId,\n@@ -1144,20 +1149,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut associated_types = FxHashSet::default();\n         for tr in traits::supertraits(tcx, principal) {\n-            if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n-                use collect::trait_associated_type_names;\n-\n-                associated_types.extend(trait_associated_type_names(tcx, trait_id)\n-                    .map(|name| (tr.def_id(), name)))\n-            } else {\n-                let trait_items = tcx.impl_or_trait_items(tr.def_id());\n-                associated_types.extend(trait_items.iter().filter_map(|&def_id| {\n-                    match tcx.impl_or_trait_item(def_id) {\n-                        ty::TypeTraitItem(ref item) => Some(item.name),\n-                        _ => None\n-                    }\n-                }).map(|name| (tr.def_id(), name)));\n-            }\n+            associated_types.extend(tcx.associated_items(tr.def_id())\n+                .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                .map(|item| (tr.def_id(), item.name)));\n         }\n \n         for projection_bound in &projection_bounds {\n@@ -1260,14 +1254,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if bounds.len() > 1 {\n             let spans = bounds.iter().map(|b| {\n-                self.tcx().impl_or_trait_items(b.def_id()).iter()\n-                .find(|&&def_id| {\n-                    match self.tcx().impl_or_trait_item(def_id) {\n-                        ty::TypeTraitItem(ref item) => item.name.as_str() == assoc_name,\n-                        _ => false\n-                    }\n+                self.tcx().associated_items(b.def_id()).find(|item| {\n+                    item.kind == ty::AssociatedKind::Type && item.name.as_str() == assoc_name\n                 })\n-                .and_then(|&def_id| self.tcx().map.as_local_node_id(def_id))\n+                .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n                 .and_then(|node_id| self.tcx().map.opt_span(node_id))\n             });\n \n@@ -1383,25 +1373,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_did = bound.0.def_id;\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n-        let item_did = if let Some(trait_id) = tcx.map.as_local_node_id(trait_did) {\n-            // `ty::trait_items` used below requires information generated\n-            // by type collection, which may be in progress at this point.\n-            match tcx.map.expect_item(trait_id).node {\n-                hir::ItemTrait(.., ref trait_items) => {\n-                    let item = trait_items.iter()\n-                                          .find(|i| i.name == assoc_name)\n-                                          .expect(\"missing associated type\");\n-                    tcx.map.local_def_id(item.id)\n-                }\n-                _ => bug!()\n-            }\n-        } else {\n-            let trait_items = tcx.trait_items(trait_did);\n-            let item = trait_items.iter().find(|i| i.name() == assoc_name);\n-            item.expect(\"missing associated type\").def_id()\n-        };\n-\n-        (ty, Def::AssociatedTy(item_did))\n+        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n+        (ty, Def::AssociatedTy(item.expect(\"missing associated type\").def_id))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1694,13 +1667,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n                 let anon_scope = rscope.anon_type_scope();\n-                let (bare_fn_ty, _) =\n-                    self.ty_of_method_or_bare_fn(bf.unsafety,\n-                                                 bf.abi,\n-                                                 None,\n-                                                 &bf.decl,\n-                                                 anon_scope,\n-                                                 anon_scope);\n+                let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n+                                                              bf.abi,\n+                                                              None,\n+                                                              &bf.decl,\n+                                                              anon_scope,\n+                                                              anon_scope);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1842,7 +1814,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>,\n                         anon_scope: Option<AnonTypeScope>)\n-                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>) {\n+                        -> &'tcx ty::BareFnTy<'tcx> {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n                                      Some(untransformed_self_ty),\n@@ -1857,7 +1829,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                          decl: &hir::FnDecl,\n                          anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope).0\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope)\n     }\n \n     fn ty_of_method_or_bare_fn(&self,\n@@ -1867,7 +1839,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                decl: &hir::FnDecl,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n-                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n+                               -> &'tcx ty::BareFnTy<'tcx>\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1880,13 +1852,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, decl.get_self()) {\n+        let (self_ty, explicit_self) = match (opt_untransformed_self_ty, decl.get_self()) {\n             (Some(untransformed_self_ty), Some(explicit_self)) => {\n                 let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n                                                          &explicit_self);\n-                (Some(self_type.0), self_type.1)\n+                (Some(self_type), Some(ExplicitSelf::determine(untransformed_self_ty, self_type)))\n             }\n-            _ => (None, ty::ExplicitSelfCategory::Static),\n+            _ => (None, None),\n         };\n \n         // HACK(eddyb) replace the fake self type in the AST with the actual type.\n@@ -1901,8 +1873,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // Second, if there was exactly one lifetime (either a substitution or a\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n-        let implied_output_region = match explicit_self_category {\n-            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(*region),\n+        let implied_output_region = match explicit_self {\n+            Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n             _ => {\n                 // `pat_to_string` is expensive and\n                 // `find_implied_output_region` only needs its result when\n@@ -1928,103 +1900,38 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_method_or_bare_fn: input_tys={:?}\", input_tys);\n         debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n \n-        (self.tcx().mk_bare_fn(ty::BareFnTy {\n+        self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n             abi: abi,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_tys,\n                 output: output_ty,\n                 variadic: decl.variadic\n             }),\n-        }), explicit_self_category)\n+        })\n     }\n \n     fn determine_self_type<'a>(&self,\n                                rscope: &RegionScope,\n                                untransformed_self_ty: Ty<'tcx>,\n                                explicit_self: &hir::ExplicitSelf)\n-                               -> (Ty<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n+                               -> Ty<'tcx>\n     {\n-        return match explicit_self.node {\n-            SelfKind::Value(..) => {\n-                (untransformed_self_ty, ty::ExplicitSelfCategory::ByValue)\n-            }\n+        match explicit_self.node {\n+            SelfKind::Value(..) => untransformed_self_ty,\n             SelfKind::Region(ref lifetime, mutability) => {\n                 let region =\n                     self.opt_ast_region_to_region(\n                                              rscope,\n                                              explicit_self.span,\n                                              lifetime);\n-                (self.tcx().mk_ref(region,\n+                self.tcx().mk_ref(region,\n                     ty::TypeAndMut {\n                         ty: untransformed_self_ty,\n                         mutbl: mutability\n-                    }),\n-                 ty::ExplicitSelfCategory::ByReference(region, mutability))\n-            }\n-            SelfKind::Explicit(ref ast_type, _) => {\n-                let explicit_type = self.ast_ty_to_ty(rscope, &ast_type);\n-\n-                // We wish to (for now) categorize an explicit self\n-                // declaration like `self: SomeType` into either `self`,\n-                // `&self`, `&mut self`, or `Box<self>`. We do this here\n-                // by some simple pattern matching. A more precise check\n-                // is done later in `check_method_self_type()`.\n-                //\n-                // Examples:\n-                //\n-                // ```\n-                // impl Foo for &T {\n-                //     // Legal declarations:\n-                //     fn method1(self: &&T); // ExplicitSelfCategory::ByReference\n-                //     fn method2(self: &T); // ExplicitSelfCategory::ByValue\n-                //     fn method3(self: Box<&T>); // ExplicitSelfCategory::ByBox\n-                //\n-                //     // Invalid cases will be caught later by `check_method_self_type`:\n-                //     fn method_err1(self: &mut T); // ExplicitSelfCategory::ByReference\n-                // }\n-                // ```\n-                //\n-                // To do the check we just count the number of \"modifiers\"\n-                // on each type and compare them. If they are the same or\n-                // the impl has more, we call it \"by value\". Otherwise, we\n-                // look at the outermost modifier on the method decl and\n-                // call it by-ref, by-box as appropriate. For method1, for\n-                // example, the impl type has one modifier, but the method\n-                // type has two, so we end up with\n-                // ExplicitSelfCategory::ByReference.\n-\n-                let impl_modifiers = count_modifiers(untransformed_self_ty);\n-                let method_modifiers = count_modifiers(explicit_type);\n-\n-                debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n-                       explicit_type={:?} \\\n-                       modifiers=({},{})\",\n-                       untransformed_self_ty,\n-                       explicit_type,\n-                       impl_modifiers,\n-                       method_modifiers);\n-\n-                let category = if impl_modifiers >= method_modifiers {\n-                    ty::ExplicitSelfCategory::ByValue\n-                } else {\n-                    match explicit_type.sty {\n-                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(r, mt.mutbl),\n-                        ty::TyBox(_) => ty::ExplicitSelfCategory::ByBox,\n-                        _ => ty::ExplicitSelfCategory::ByValue,\n-                    }\n-                };\n-\n-                (explicit_type, category)\n-            }\n-        };\n-\n-        fn count_modifiers(ty: Ty) -> usize {\n-            match ty.sty {\n-                ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n-                ty::TyBox(t) => count_modifiers(t) + 1,\n-                _ => 0,\n+                    })\n             }\n+            SelfKind::Explicit(ref ast_type, _) => self.ast_ty_to_ty(rscope, &ast_type)\n         }\n     }\n \n@@ -2334,3 +2241,64 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n         vec\n     }\n }\n+\n+pub enum ExplicitSelf<'tcx> {\n+    ByValue,\n+    ByReference(&'tcx ty::Region, hir::Mutability),\n+    ByBox\n+}\n+\n+impl<'tcx> ExplicitSelf<'tcx> {\n+    /// We wish to (for now) categorize an explicit self\n+    /// declaration like `self: SomeType` into either `self`,\n+    /// `&self`, `&mut self`, or `Box<self>`. We do this here\n+    /// by some simple pattern matching. A more precise check\n+    /// is done later in `check_method_self_type()`.\n+    ///\n+    /// Examples:\n+    ///\n+    /// ```\n+    /// impl Foo for &T {\n+    ///     // Legal declarations:\n+    ///     fn method1(self: &&T); // ExplicitSelf::ByReference\n+    ///     fn method2(self: &T); // ExplicitSelf::ByValue\n+    ///     fn method3(self: Box<&T>); // ExplicitSelf::ByBox\n+    ///\n+    ///     // Invalid cases will be caught later by `check_method_self_type`:\n+    ///     fn method_err1(self: &mut T); // ExplicitSelf::ByReference\n+    /// }\n+    /// ```\n+    ///\n+    /// To do the check we just count the number of \"modifiers\"\n+    /// on each type and compare them. If they are the same or\n+    /// the impl has more, we call it \"by value\". Otherwise, we\n+    /// look at the outermost modifier on the method decl and\n+    /// call it by-ref, by-box as appropriate. For method1, for\n+    /// example, the impl type has one modifier, but the method\n+    /// type has two, so we end up with\n+    /// ExplicitSelf::ByReference.\n+    pub fn determine(untransformed_self_ty: Ty<'tcx>,\n+                     self_arg_ty: Ty<'tcx>)\n+                     -> ExplicitSelf<'tcx> {\n+        fn count_modifiers(ty: Ty) -> usize {\n+            match ty.sty {\n+                ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n+                ty::TyBox(t) => count_modifiers(t) + 1,\n+                _ => 0,\n+            }\n+        }\n+\n+        let impl_modifiers = count_modifiers(untransformed_self_ty);\n+        let method_modifiers = count_modifiers(self_arg_ty);\n+\n+        if impl_modifiers >= method_modifiers {\n+            ExplicitSelf::ByValue\n+        } else {\n+            match self_arg_ty.sty {\n+                ty::TyRef(r, mt) => ExplicitSelf::ByReference(r, mt.mutbl),\n+                ty::TyBox(_) => ExplicitSelf::ByBox,\n+                _ => ExplicitSelf::ByValue,\n+            }\n+        }\n+    }\n+}"}, {"sha": "ffde940b3f48a83b1788c2321e0fc69f39beb228", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 98, "deletions": 55, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n@@ -23,6 +24,7 @@ use syntax_pos::Span;\n use CrateCtxt;\n use super::assoc;\n use super::{Inherited, FnCtxt};\n+use astconv::ExplicitSelf;\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -36,11 +38,11 @@ use super::{Inherited, FnCtxt};\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     impl_m: &ty::Method<'tcx>,\n+                                     impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n                                      impl_m_body_id: ast::NodeId,\n-                                     trait_m: &ty::Method<'tcx>,\n-                                     impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                     trait_m: &ty::AssociatedItem,\n+                                     impl_trait_ref: ty::TraitRef<'tcx>,\n                                      trait_item_span: Option<Span>,\n                                      old_broken_mode: bool) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n@@ -49,7 +51,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if let Err(ErrorReported) = compare_self_type(ccx,\n                                                   impl_m,\n                                                   impl_m_span,\n-                                                  trait_m) {\n+                                                  trait_m,\n+                                                  impl_trait_ref) {\n         return;\n     }\n \n@@ -81,16 +84,16 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                          impl_m: &ty::Method<'tcx>,\n+                                          impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n                                           impl_m_body_id: ast::NodeId,\n-                                          trait_m: &ty::Method<'tcx>,\n-                                          impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                          trait_m: &ty::AssociatedItem,\n+                                          impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n \n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This code is best explained by example. Consider a trait:\n     //\n@@ -165,18 +168,23 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n-                                                               impl_m.container_id(),\n+                                                               impl_m.container.id(),\n                                                                trait_to_impl_substs.subst(tcx,\n                                                                           impl_to_skol_substs));\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n+    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let impl_m_predicates = tcx.lookup_predicates(impl_m.def_id);\n+    let trait_m_predicates = tcx.lookup_predicates(trait_m.def_id);\n+\n     // Check region bounds.\n     check_region_bounds_on_impl_method(ccx,\n                                        impl_m_span,\n                                        impl_m,\n-                                       &trait_m.generics,\n-                                       &impl_m.generics,\n+                                       &trait_m_generics,\n+                                       &impl_m_generics,\n                                        trait_to_skol_substs,\n                                        impl_to_skol_substs)?;\n \n@@ -185,7 +193,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+    let impl_predicates = tcx.lookup_predicates(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -198,7 +206,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // We then register the obligations from the impl_m and check to see\n     // if all constraints hold.\n     hybrid_preds.predicates\n-                .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+                .extend(trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n@@ -219,7 +227,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let impl_m_own_bounds = impl_m.predicates.instantiate_own(tcx, impl_to_skol_substs);\n+        let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_skol_substs);\n         let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                        infer::HigherRankedType,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n@@ -260,10 +268,19 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let tcx = infcx.tcx;\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n+        let m_fty = |method: &ty::AssociatedItem| {\n+            match tcx.lookup_item_type(method.def_id).ty.sty {\n+                ty::TyFnDef(_, _, f) => f,\n+                _ => bug!()\n+            }\n+        };\n+        let impl_m_fty = m_fty(impl_m);\n+        let trait_m_fty = m_fty(trait_m);\n+\n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &impl_m.fty.sig);\n+                                                            &impl_m_fty.sig);\n         let impl_sig =\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n@@ -273,15 +290,15 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: impl_m.fty.unsafety,\n-            abi: impl_m.fty.abi,\n+            unsafety: impl_m_fty.unsafety,\n+            abi: impl_m_fty.abi,\n             sig: ty::Binder(impl_sig.clone()),\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(\n             infcx.parameter_environment.free_id_outlive,\n-            &trait_m.fty.sig);\n+            &trait_m_fty.sig);\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -291,8 +308,8 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: trait_m.fty.unsafety,\n-            abi: trait_m.fty.abi,\n+            unsafety: trait_m_fty.unsafety,\n+            abi: trait_m_fty.abi,\n             sig: ty::Binder(trait_sig.clone()),\n         }));\n \n@@ -367,7 +384,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 span: Span,\n-                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m: &ty::AssociatedItem,\n                                                 trait_generics: &ty::Generics<'tcx>,\n                                                 impl_generics: &ty::Generics<'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n@@ -413,9 +430,9 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      terr: &TypeError,\n                                                      origin: TypeOrigin,\n-                                                     impl_m: &ty::Method,\n+                                                     impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,\n-                                                     trait_m: &ty::Method,\n+                                                     trait_m: &ty::AssociatedItem,\n                                                      trait_sig: ty::FnSig<'tcx>)\n                                                      -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n@@ -505,9 +522,10 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n }\n \n fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               impl_m: &ty::Method<'tcx>,\n+                               impl_m: &ty::AssociatedItem,\n                                impl_m_span: Span,\n-                               trait_m: &ty::Method<'tcx>)\n+                               trait_m: &ty::AssociatedItem,\n+                               impl_trait_ref: ty::TraitRef<'tcx>)\n                                -> Result<(), ErrorReported>\n {\n     let tcx = ccx.tcx;\n@@ -518,58 +536,75 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n-        (&ty::ExplicitSelfCategory::Static, _) => {\n+\n+    let self_string = |method: &ty::AssociatedItem| {\n+        let untransformed_self_ty = match method.container {\n+            ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n+            ty::TraitContainer(_) => tcx.mk_self_type()\n+        };\n+        let method_ty = tcx.lookup_item_type(method.def_id).ty;\n+        let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n+        match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n+            ExplicitSelf::ByValue => \"self\".to_string(),\n+            ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n+            ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n+            _ => format!(\"self: {}\", self_arg_ty)\n+        }\n+    };\n+\n+    match (trait_m.method_has_self_argument, impl_m.method_has_self_argument) {\n+        (false, false) | (true, true) => {}\n+\n+        (false, true) => {\n+            let self_descr = self_string(impl_m);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_m_span,\n                                            E0185,\n                                            \"method `{}` has a `{}` declaration in the impl, but \\\n                                             not in the trait\",\n                                            trait_m.name,\n-                                           impl_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n+                                           self_descr);\n+            err.span_label(impl_m_span, &format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span,\n-                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n+                err.span_label(span, &format!(\"trait declared without `{}`\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n         }\n-        (_, &ty::ExplicitSelfCategory::Static) => {\n+\n+        (true, false) => {\n+            let self_descr = self_string(trait_m);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_m_span,\n                                            E0186,\n                                            \"method `{}` has a `{}` declaration in the trait, but \\\n                                             not in the impl\",\n                                            trait_m.name,\n-                                           trait_m.explicit_self);\n+                                           self_descr);\n             err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n+                           &format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n+                err.span_label(span, &format!(\"`{}` used in trait\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n         }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n     }\n \n     Ok(())\n }\n \n fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                        impl_m: &ty::Method<'tcx>,\n+                                        impl_m: &ty::AssociatedItem,\n                                         impl_m_span: Span,\n-                                        trait_m: &ty::Method<'tcx>,\n+                                        trait_m: &ty::AssociatedItem,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    let num_impl_m_type_params = impl_m.generics.types.len();\n-    let num_trait_m_type_params = trait_m.generics.types.len();\n+    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let num_impl_m_type_params = impl_m_generics.types.len();\n+    let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n         let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n@@ -630,15 +665,23 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m: &ty::AssociatedItem,\n                                                 impl_m_span: Span,\n-                                                trait_m: &ty::Method<'tcx>,\n+                                                trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n-        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n+    let m_fty = |method: &ty::AssociatedItem| {\n+        match tcx.lookup_item_type(method.def_id).ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        }\n+    };\n+    let impl_m_fty = m_fty(impl_m);\n+    let trait_m_fty = m_fty(trait_m);\n+    if impl_m_fty.sig.0.inputs.len() != trait_m_fty.sig.0.inputs.len() {\n+        let trait_number_args = trait_m_fty.sig.0.inputs.len();\n+        let impl_number_args = impl_m_fty.sig.0.inputs.len();\n         let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n             match tcx.map.expect_trait_item(trait_id).node {\n@@ -708,10 +751,10 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    impl_c: &ty::AssociatedConst<'tcx>,\n+                                    impl_c: &ty::AssociatedItem,\n                                     impl_c_span: Span,\n-                                    trait_c: &ty::AssociatedConst<'tcx>,\n-                                    impl_trait_ref: &ty::TraitRef<'tcx>) {\n+                                    trait_c: &ty::AssociatedItem,\n+                                    impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let tcx = ccx.tcx;\n@@ -723,7 +766,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // because we shouldn't really have to deal with lifetimes or\n         // predicates. In fact some of this should probably be put into\n         // shared functions because of DRY violations...\n-        let trait_to_impl_substs = &impl_trait_ref.substs;\n+        let trait_to_impl_substs = impl_trait_ref.substs;\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n@@ -742,8 +785,8 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = trait_c.ty.subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.lookup_item_type(impl_c.def_id).ty.subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.lookup_item_type(trait_c.def_id).ty.subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "a06b3e70881a5204c1af7a7267c4fece982ac712", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -553,9 +553,9 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // attributes attached to the impl's generics.\n             let dtor_method = adt_def.destructor()\n                 .expect(\"dtorck type without destructor impossible\");\n-            let method = tcx.impl_or_trait_item(dtor_method);\n-            let impl_id: DefId = method.container().id();\n-            let revised_ty = revise_self_ty(tcx, adt_def, impl_id, substs);\n+            let method = tcx.associated_item(dtor_method);\n+            let impl_def_id = method.container.id();\n+            let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {"}, {"sha": "3894a7a2097eb9375153acb3df8d45258c8b7708", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -37,16 +37,6 @@ impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct InstantiatedMethodSig<'tcx> {\n-    /// Function signature of the method being invoked. The 0th\n-    /// argument is the receiver.\n-    method_sig: ty::FnSig<'tcx>,\n-\n-    /// Generic bounds on the method's parameters which must be added\n-    /// as pending obligations.\n-    method_predicates: ty::InstantiatedPredicates<'tcx>,\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn confirm_method(&self,\n                           span: Span,\n@@ -98,31 +88,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let InstantiatedMethodSig { method_sig, method_predicates } =\n-            self.instantiate_method_sig(&pick, all_substs);\n-        let method_self_ty = method_sig.inputs[0];\n+        let (method_ty, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n         // Unify the (adjusted) self type with what the method expects.\n-        self.unify_receivers(self_ty, method_self_ty);\n-\n-        // Create the method type\n-        let def_id = pick.item.def_id();\n-        let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx.mk_fn_def(def_id,\n-                                     all_substs,\n-                                     self.tcx.mk_bare_fn(ty::BareFnTy {\n-                                         sig: ty::Binder(method_sig),\n-                                         unsafety: method_ty.fty.unsafety,\n-                                         abi: method_ty.fty.abi.clone(),\n-                                     }));\n+        self.unify_receivers(self_ty, method_ty.fn_sig().input(0).skip_binder());\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(fty, all_substs, &method_predicates);\n+        self.add_obligations(method_ty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n-            def_id: def_id,\n-            ty: fty,\n+            def_id: pick.item.def_id,\n+            ty: method_ty,\n             substs: all_substs,\n         };\n \n@@ -193,15 +170,15 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                              -> &'tcx Substs<'tcx> {\n         match pick.kind {\n             probe::InherentImplPick => {\n-                let impl_def_id = pick.item.container().id();\n+                let impl_def_id = pick.item.container.id();\n                 assert!(self.tcx.impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\",\n                         impl_def_id);\n                 self.impl_self_ty(self.span, impl_def_id).substs\n             }\n \n             probe::ObjectPick => {\n-                let trait_def_id = pick.item.container().id();\n+                let trait_def_id = pick.item.container.id();\n                 self.extract_existential_trait_ref(self_ty, |this, object_ty, principal| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -244,7 +221,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n \n             probe::TraitPick => {\n-                let trait_def_id = pick.item.container().id();\n+                let trait_def_id = pick.item.container.id();\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n@@ -299,8 +276,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method = pick.item.as_opt_method().unwrap();\n-        let num_method_types = method.generics.types.len();\n+        let method_generics = self.tcx.lookup_generics(pick.item.def_id);\n+        let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n             if num_method_types == 0 {\n@@ -332,18 +309,15 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let supplied_start = substs.params().len() + method.generics.regions.len();\n-        Substs::for_item(self.tcx,\n-                         method.def_id,\n-                         |def, _| {\n+        let supplied_start = substs.params().len() + method_generics.regions.len();\n+        Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n-        },\n-                         |def, cur_substs| {\n+        }, |def, cur_substs| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.type_at(i)\n@@ -376,44 +350,48 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n                               all_substs: &'tcx Substs<'tcx>)\n-                              -> InstantiatedMethodSig<'tcx> {\n+                              -> (Ty<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n                pick,\n                all_substs);\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.item\n-            .as_opt_method()\n-            .unwrap()\n-            .predicates\n-            .instantiate(self.tcx, all_substs);\n-        let method_predicates = self.normalize_associated_types_in(self.span, &method_predicates);\n+        let def_id = pick.item.def_id;\n+        let method_predicates = self.tcx.lookup_predicates(def_id)\n+                                    .instantiate(self.tcx, all_substs);\n+        let method_predicates = self.normalize_associated_types_in(self.span,\n+                                                                   &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n+        let fty = match self.tcx.lookup_item_type(def_id).ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        };\n+\n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.item\n-            .as_opt_method()\n-            .unwrap()\n-            .fty\n-            .sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n-        InstantiatedMethodSig {\n-            method_sig: method_sig,\n-            method_predicates: method_predicates,\n-        }\n+        let method_ty = self.tcx.mk_fn_def(def_id, all_substs,\n+                                           self.tcx.mk_bare_fn(ty::BareFnTy {\n+            sig: ty::Binder(method_sig),\n+            unsafety: fty.unsafety,\n+            abi: fty.abi,\n+        }));\n+\n+        (method_ty, method_predicates)\n     }\n \n     fn add_obligations(&mut self,\n@@ -587,7 +565,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n-        match pick.item.container() {\n+        match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {\n                 callee::check_legal_trait_for_method_call(self.ccx, self.span, trait_def_id)\n             }"}, {"sha": "579a54fb5318df629d10912a06c99df21a55687e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -228,37 +228,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.impl_or_trait_item(trait_def_id, m_name).unwrap();\n-        let method_ty = method_item.as_opt_method().unwrap();\n-        assert_eq!(method_ty.generics.types.len(), 0);\n-        assert_eq!(method_ty.generics.regions.len(), 0);\n+        let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n+        let def_id = method_item.def_id;\n+        let generics = tcx.lookup_generics(def_id);\n+        assert_eq!(generics.types.len(), 0);\n+        assert_eq!(generics.regions.len(), 0);\n \n-        debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n-               method_item,\n-               method_ty);\n+        debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(span, infer::FnCall, &method_ty.fty.sig)\n-                .0;\n+        let original_method_ty = tcx.lookup_item_type(def_id).ty;\n+        let fty = match original_method_ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        };\n+        let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n+                                                                    infer::FnCall,\n+                                                                    &fty.sig).0;\n         let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs[0];\n-        let def_id = method_item.def_id();\n-        let fty = tcx.mk_fn_def(def_id,\n-                                trait_ref.substs,\n-                                tcx.mk_bare_fn(ty::BareFnTy {\n-                                    sig: ty::Binder(fn_sig),\n-                                    unsafety: method_ty.fty.unsafety,\n-                                    abi: method_ty.fty.abi.clone(),\n-                                }));\n-\n-        debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n-               fty,\n+        let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n+                                      tcx.mk_bare_fn(ty::BareFnTy {\n+            sig: ty::Binder(fn_sig),\n+            unsafety: fty.unsafety,\n+            abi: fty.abi\n+        }));\n+\n+        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n+               method_ty,\n                obligation);\n \n         // Register obligations for the parameters.  This will include the\n@@ -269,75 +271,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n-        let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n+        let method_bounds = self.instantiate_bounds(span, def_id, trait_ref.substs);\n         assert!(!method_bounds.has_escaping_regions());\n         self.add_obligations_for_parameters(traits::ObligationCause::misc(span, self.body_id),\n                                             &method_bounds);\n \n         // Also register an obligation for the method type being well-formed.\n-        self.register_wf_obligation(fty, span, traits::MiscObligation);\n+        self.register_wf_obligation(method_ty, span, traits::MiscObligation);\n \n         // FIXME(#18653) -- Try to resolve obligations, giving us more\n         // typing information, which can sometimes be needed to avoid\n         // pathological region inference failures.\n         self.select_obligations_where_possible();\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n-        match self_expr {\n-            None => {}\n-\n-            Some(self_expr) => {\n-                debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                       (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n-                       self_expr.id,\n-                       autoderefs,\n-                       unsize,\n-                       method_ty.explicit_self);\n-\n-                let autoref = match method_ty.explicit_self {\n-                    ty::ExplicitSelfCategory::ByValue => {\n-                        // Trait method is fn(self), no transformation needed.\n-                        assert!(!unsize);\n-                        None\n-                    }\n-\n-                    ty::ExplicitSelfCategory::ByReference(..) => {\n-                        // Trait method is fn(&self) or fn(&mut self), need an\n-                        // autoref. Pull the region etc out of the type of first argument.\n-                        match transformed_self_ty.sty {\n-                            ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                                Some(AutoBorrow::Ref(region, mutbl))\n-                            }\n-\n-                            _ => {\n-                                span_bug!(span,\n-                                          \"trait method is &self but first arg is: {}\",\n-                                          transformed_self_ty);\n-                            }\n-                        }\n-                    }\n-\n-                    _ => {\n-                        span_bug!(span,\n-                                  \"unexpected explicit self type in operator method: {:?}\",\n-                                  method_ty.explicit_self);\n-                    }\n-                };\n-\n-                self.write_adjustment(self_expr.id, Adjustment {\n-                    kind: Adjust::DerefRef {\n-                        autoderefs: autoderefs,\n-                        autoref: autoref,\n-                        unsize: unsize\n-                    },\n-                    target: transformed_self_ty\n-                });\n-            }\n+        if let Some(self_expr) = self_expr {\n+            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n+                    (self-id={}, autoderefs={}, unsize={}, fty={:?})\",\n+                    self_expr.id, autoderefs, unsize, original_method_ty);\n+\n+            let original_sig = original_method_ty.fn_sig();\n+            let autoref = match (&original_sig.input(0).skip_binder().sty,\n+                                 &transformed_self_ty.sty) {\n+                (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n+                    // Trait method is fn(&self) or fn(&mut self), need an\n+                    // autoref. Pull the region etc out of the type of first argument.\n+                    Some(AutoBorrow::Ref(region, mutbl))\n+                }\n+                _ => {\n+                    // Trait method is fn(self), no transformation needed.\n+                    assert!(!unsize);\n+                    None\n+                }\n+            };\n+\n+            self.write_adjustment(self_expr.id, Adjustment {\n+                kind: Adjust::DerefRef {\n+                    autoderefs: autoderefs,\n+                    autoref: autoref,\n+                    unsize: unsize\n+                },\n+                target: transformed_self_ty\n+            });\n         }\n \n         let callee = ty::MethodCallee {\n             def_id: def_id,\n-            ty: fty,\n+            ty: method_ty,\n             substs: trait_ref.substs,\n         };\n \n@@ -361,7 +341,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let def = pick.item.def();\n         if let probe::InherentImplPick = pick.kind {\n-            if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n+            if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n                 self.tcx.sess.span_err(span, &msg);\n             }\n@@ -371,14 +351,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn impl_or_trait_item(&self,\n-                              def_id: DefId,\n-                              item_name: ast::Name)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>> {\n-        self.tcx\n-            .impl_or_trait_items(def_id)\n-            .iter()\n-            .map(|&did| self.tcx.impl_or_trait_item(did))\n-            .find(|m| m.name() == item_name)\n+    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n+                           -> Option<ty::AssociatedItem> {\n+        self.tcx.associated_items(def_id).find(|item| item.name == item_name)\n     }\n }"}, {"sha": "7068b2dea7263b847a920708c23be6987cc2c756", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -72,7 +72,7 @@ struct CandidateStep<'tcx> {\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n-    item: ty::ImplOrTraitItem<'tcx>,\n+    item: ty::AssociatedItem,\n     kind: CandidateKind<'tcx>,\n     import_id: Option<ast::NodeId>,\n }\n@@ -95,7 +95,7 @@ enum CandidateKind<'tcx> {\n \n #[derive(Debug)]\n pub struct Pick<'tcx> {\n-    pub item: ty::ImplOrTraitItem<'tcx>,\n+    pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,\n     pub import_id: Option<ast::NodeId>,\n \n@@ -384,8 +384,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n-            self.tcx.populate_implementations_for_primitive_if_necessary(impl_def_id);\n-\n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n@@ -409,7 +407,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.impl_or_trait_item(impl_def_id) {\n+        let item = match self.associated_item(impl_def_id) {\n             Some(m) => m,\n             None => {\n                 return;\n@@ -421,7 +419,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if !item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n+        if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n             self.private_candidate = Some(item.def());\n             return;\n         }\n@@ -512,17 +510,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let xform_self_ty = this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n \n-            if let Some(ref m) = item.as_opt_method() {\n-                debug!(\"found match: trait_ref={:?} substs={:?} m={:?}\",\n-                       trait_ref,\n-                       trait_ref.substs,\n-                       m);\n-                assert_eq!(m.generics.parent_types as usize,\n-                           trait_ref.substs.types().count());\n-                assert_eq!(m.generics.parent_regions as usize,\n-                           trait_ref.substs.regions().count());\n-            }\n-\n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n@@ -544,13 +531,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn elaborate_bounds<F>(&mut self, bounds: &[ty::PolyTraitRef<'tcx>], mut mk_cand: F)\n         where F: for<'b> FnMut(&mut ProbeContext<'b, 'gcx, 'tcx>,\n                                ty::PolyTraitRef<'tcx>,\n-                               ty::ImplOrTraitItem<'tcx>)\n+                               ty::AssociatedItem)\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n+            let item = match self.associated_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n                 None => {\n                     continue;\n@@ -601,9 +588,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        let trait_items = self.tcx.trait_items(trait_def_id);\n-        let maybe_item = trait_items.iter()\n-            .find(|item| item.name() == self.item_name);\n+        let maybe_item = self.tcx.associated_items(trait_def_id)\n+                             .find(|item| item.name == self.item_name);\n         let item = match maybe_item {\n             Some(i) => i,\n             None => {\n@@ -612,7 +598,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         };\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(item) {\n+        if !self.has_applicable_self(&item) {\n             debug!(\"method has inapplicable self\");\n             self.record_static_candidate(TraitSource(trait_def_id));\n             return Ok(());\n@@ -631,7 +617,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: DefId,\n-                                                     item: ty::ImplOrTraitItem<'tcx>) {\n+                                                     item: ty::AssociatedItem) {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n@@ -700,7 +686,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: DefId,\n-                                   item: ty::ImplOrTraitItem<'tcx>)\n+                                   item: ty::AssociatedItem)\n                                    -> Result<(), MethodError<'tcx>> {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx;\n@@ -765,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: DefId,\n-                                      item: ty::ImplOrTraitItem<'tcx>) {\n+                                      item: ty::AssociatedItem) {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={:?}, \\\n                item={:?})\",\n@@ -820,7 +806,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: DefId,\n-                                        item: ty::ImplOrTraitItem<'tcx>) {\n+                                        item: ty::AssociatedItem) {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n@@ -865,7 +851,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.assemble_extension_candidates_for_all_traits()?;\n \n         let out_of_scope_traits = match self.pick_core() {\n-            Some(Ok(p)) => vec![p.item.container().id()],\n+            Some(Ok(p)) => vec![p.item.container.id()],\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n                     .map(|source| {\n@@ -1065,7 +1051,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // don't have enough information to fully evaluate).\n             let (impl_def_id, substs, ref_obligations) = match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n-                    (probe.item.container().id(), substs, ref_obligations)\n+                    (probe.item.container.id(), substs, ref_obligations)\n                 }\n \n                 ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n@@ -1128,12 +1114,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n     fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate<'tcx>]) -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n-        let container = probes[0].item.container();\n+        let container = probes[0].item.container;\n         match container {\n             ty::TraitContainer(_) => {}\n             ty::ImplContainer(_) => return None,\n         }\n-        if probes[1..].iter().any(|p| p.item.container() != container) {\n+        if probes[1..].iter().any(|p| p.item.container != container) {\n             return None;\n         }\n \n@@ -1150,19 +1136,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n-    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n+    fn has_applicable_self(&self, item: &ty::AssociatedItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n-        match *item {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                match method.explicit_self {\n-                    ty::ExplicitSelfCategory::Static => self.mode == Mode::Path,\n-                    ty::ExplicitSelfCategory::ByValue |\n-                    ty::ExplicitSelfCategory::ByReference(..) |\n-                    ty::ExplicitSelfCategory::ByBox => true,\n-                }\n-            }\n-            ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n-            _ => false,\n+        match self.mode {\n+            Mode::MethodCall => item.method_has_self_argument,\n+            Mode::Path => true\n         }\n         // FIXME -- check for types that deref to `Self`,\n         // like `Rc<Self>` and so on.\n@@ -1177,24 +1155,26 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn xform_self_ty(&self,\n-                     item: &ty::ImplOrTraitItem<'tcx>,\n+                     item: &ty::AssociatedItem,\n                      impl_ty: Ty<'tcx>,\n                      substs: &Substs<'tcx>)\n                      -> Ty<'tcx> {\n-        match item.as_opt_method() {\n-            Some(ref method) => self.xform_method_self_ty(method, impl_ty, substs),\n-            None => impl_ty,\n+        if item.kind == ty::AssociatedKind::Method && self.mode == Mode::MethodCall {\n+            self.xform_method_self_ty(item.def_id, impl_ty, substs)\n+        } else {\n+            impl_ty\n         }\n     }\n \n     fn xform_method_self_ty(&self,\n-                            method: &Rc<ty::Method<'tcx>>,\n+                            method: DefId,\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n+        let self_ty = self.tcx.lookup_item_type(method).ty.fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n-               method.fty.sig.0.inputs.get(0),\n+               self_ty,\n                substs);\n \n         assert!(!substs.has_escaping_regions());\n@@ -1204,26 +1184,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types().count(),\n-                   method.generics.parent_types as usize);\n-        assert_eq!(substs.regions().count(),\n-                   method.generics.parent_regions as usize);\n-\n-        if self.mode == Mode::Path {\n-            return impl_ty;\n-        }\n+        let generics = self.tcx.lookup_generics(method);\n+        assert_eq!(substs.types().count(), generics.parent_types as usize);\n+        assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n-        let xform_self_ty = method.fty.sig.input(0);\n-        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n+        let xform_self_ty = self.erase_late_bound_regions(&self_ty);\n \n-        if method.generics.types.is_empty() && method.generics.regions.is_empty() {\n+        if generics.types.is_empty() && generics.regions.is_empty() {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n-            let substs = Substs::for_item(self.tcx,\n-                                          method.def_id,\n-                                          |def, _| {\n+            let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.region_at(i)\n@@ -1232,8 +1204,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     // `impl_self_ty()` for an explanation.\n                     self.tcx.mk_region(ty::ReErased)\n                 }\n-            },\n-                                          |def, cur_substs| {\n+            }, |def, cur_substs| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.type_at(i)\n@@ -1283,8 +1254,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::ImplOrTraitItem<'tcx>> {\n-        self.fcx.impl_or_trait_item(def_id, self.item_name)\n+    fn associated_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n+        self.fcx.associated_item(def_id, self.item_name)\n     }\n }\n \n@@ -1317,11 +1288,11 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(..) => ImplSource(self.item.container().id()),\n+            InherentImplCandidate(..) => ImplSource(self.item.container.id()),\n             ExtensionImplCandidate(def_id, ..) => ImplSource(def_id),\n             ObjectCandidate |\n             TraitCandidate |\n-            WhereClauseCandidate(_) => TraitSource(self.item.container().id()),\n+            WhereClauseCandidate(_) => TraitSource(self.item.container.id()),\n         }\n     }\n }"}, {"sha": "0cb8cf2a58886af8247dcb97fc7271b15538f063", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -89,20 +89,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.impl_or_trait_item(impl_did, item_name)\n+                        let item = self.associated_item(impl_did, item_name)\n                             .or_else(|| {\n-                                self.impl_or_trait_item(self.tcx\n-                                                            .impl_trait_ref(impl_did)\n-                                                            .unwrap()\n-                                                            .def_id,\n-\n-                                                        item_name)\n-                            })\n-                            .unwrap();\n-                        let note_span = self.tcx\n-                            .map\n-                            .span_if_local(item.def_id())\n-                            .or_else(|| self.tcx.map.span_if_local(impl_did));\n+                                self.associated_item(\n+                                    self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n+\n+                                    item_name\n+                                )\n+                            }).unwrap();\n+                        let note_span = self.tcx.map.span_if_local(item.def_id).or_else(|| {\n+                            self.tcx.map.span_if_local(impl_did)\n+                        });\n \n                         let impl_ty = self.impl_self_ty(span, impl_did).ty;\n \n@@ -127,8 +124,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self.impl_or_trait_item(trait_did, item_name).unwrap();\n-                        let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n+                        let item = self.associated_item(trait_did, item_name).unwrap();\n+                        let item_span = self.tcx.map.def_id_span(item.def_id, span);\n                         span_note!(err,\n                                    item_span,\n                                    \"candidate #{} is defined in the trait `{}`\",\n@@ -334,8 +331,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                (type_is_local || info.def_id.is_local()) &&\n-                self.impl_or_trait_item(info.def_id, item_name).is_some()\n+                (type_is_local || info.def_id.is_local())\n+                    && self.associated_item(info.def_id, item_name).is_some()\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "0265e397ef6c4df27d9791cdfc6e7401c0db5f51", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 129, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -760,7 +760,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n-                                             &impl_trait_ref,\n+                                             impl_trait_ref,\n                                              impl_items);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n@@ -942,21 +942,13 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let ancestors = trait_def.ancestors(impl_id);\n \n-    let parent = match impl_item.node {\n-        hir::ImplItemKind::Const(..) => {\n-            ancestors.const_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-        }\n-        hir::ImplItemKind::Method(..) => {\n-            ancestors.fn_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-\n-        }\n-        hir::ImplItemKind::Type(_) => {\n-            ancestors.type_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-        }\n+    let kind = match impl_item.node {\n+        hir::ImplItemKind::Const(..) => ty::AssociatedKind::Const,\n+        hir::ImplItemKind::Method(..) => ty::AssociatedKind::Method,\n+        hir::ImplItemKind::Type(_) => ty::AssociatedKind::Type\n     };\n+    let parent = ancestors.defs(tcx, impl_item.name, kind).skip(1).next()\n+        .map(|node_item| node_item.map(|parent| parent.defaultness));\n \n     if let Some(parent) = parent {\n         if parent.item.is_final() {\n@@ -969,7 +961,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n-                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                            impl_trait_ref: ty::TraitRef<'tcx>,\n                                             impl_items: &[hir::ImplItem]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -979,106 +971,90 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Locate trait definition and items\n     let tcx = ccx.tcx;\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n-    let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = tcx.impl_or_trait_item(tcx.map.local_def_id(impl_item.id));\n-        let ty_trait_item = trait_items.iter()\n-            .find(|ac| ac.name() == ty_impl_item.name());\n+        let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n+        let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n+            .find(|ac| ac.name == ty_impl_item.name);\n \n         // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(..) => {\n-                    let impl_const = match ty_impl_item {\n-                        ty::ConstTraitItem(ref cti) => cti,\n-                        _ => span_bug!(impl_item.span, \"non-const impl-item for const\")\n-                    };\n-\n                     // Find associated const definition.\n-                    if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                    if ty_trait_item.kind == ty::AssociatedKind::Const {\n                         compare_const_impl(ccx,\n-                                           &impl_const,\n+                                           &ty_impl_item,\n                                            impl_item.span,\n-                                           trait_const,\n-                                           &impl_trait_ref);\n+                                           &ty_trait_item,\n+                                           impl_trait_ref);\n                     } else {\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_const.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(_, ref body) => {\n-                    let impl_method = match ty_impl_item {\n-                        ty::MethodTraitItem(ref mti) => mti,\n-                        _ => span_bug!(impl_item.span, \"non-method impl-item for method\")\n-                    };\n-\n-                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id());\n-                    if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id);\n+                    if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n-                                            &impl_method,\n+                                            &ty_impl_item,\n                                             impl_item.span,\n                                             body.id,\n-                                            &trait_method,\n-                                            &impl_trait_ref,\n+                                            &ty_trait_item,\n+                                            impl_trait_ref,\n                                             trait_span,\n                                             true); // start with old-broken-mode\n                         if err_count == tcx.sess.err_count() {\n                             // old broken mode did not report an error. Try with the new mode.\n                             compare_impl_method(ccx,\n-                                                &impl_method,\n+                                                &ty_impl_item,\n                                                 impl_item.span,\n                                                 body.id,\n-                                                &trait_method,\n-                                                &impl_trait_ref,\n+                                                &ty_trait_item,\n+                                                impl_trait_ref,\n                                                 trait_span,\n                                                 false); // use the new mode\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_method.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Type(_) => {\n-                    let impl_type = match ty_impl_item {\n-                        ty::TypeTraitItem(ref tti) => tti,\n-                        _ => span_bug!(impl_item.span, \"non-type impl-item for type\")\n-                    };\n-\n-                    if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n-                        if let Some(_) = at.ty {\n+                    if ty_trait_item.kind == ty::AssociatedKind::Type {\n+                        if ty_trait_item.has_value {\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_type.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n@@ -1091,70 +1067,55 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n-    for trait_item in trait_items.iter() {\n-        let is_implemented;\n-        let is_provided;\n-\n-        match *trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                is_provided = associated_const.has_value;\n-                is_implemented = impl_items.iter().any(|ii| {\n-                    match ii.node {\n-                        hir::ImplItemKind::Const(..) => {\n-                            ii.name == associated_const.name\n-                        }\n-                        _ => false,\n-                    }\n-                });\n-            }\n-            ty::MethodTraitItem(ref trait_method) => {\n-                is_provided = provided_methods.iter().any(|m| m.name == trait_method.name);\n-                is_implemented = trait_def.ancestors(impl_id)\n-                    .fn_defs(tcx, trait_method.name)\n-                    .next()\n-                    .map(|node_item| !node_item.node.is_from_trait())\n-                    .unwrap_or(false);\n-            }\n-            ty::TypeTraitItem(ref trait_assoc_ty) => {\n-                is_provided = trait_assoc_ty.ty.is_some();\n-                is_implemented = trait_def.ancestors(impl_id)\n-                    .type_defs(tcx, trait_assoc_ty.name)\n-                    .next()\n-                    .map(|node_item| !node_item.node.is_from_trait())\n-                    .unwrap_or(false);\n-            }\n-        }\n+    for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n+        let is_implemented = trait_def.ancestors(impl_id)\n+            .defs(tcx, trait_item.name, trait_item.kind)\n+            .next()\n+            .map(|node_item| !node_item.node.is_from_trait())\n+            .unwrap_or(false);\n \n         if !is_implemented {\n-            if !is_provided {\n+            if !trait_item.has_value {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n-                invalidated_items.push(trait_item.name());\n+                invalidated_items.push(trait_item.name);\n             }\n         }\n     }\n \n+    let signature = |item: &ty::AssociatedItem| {\n+        match item.kind {\n+            ty::AssociatedKind::Method => {\n+                format!(\"{}\", tcx.lookup_item_type(item.def_id).ty.fn_sig().0)\n+            }\n+            ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n+            ty::AssociatedKind::Const => {\n+                format!(\"const {}: {:?};\", item.name.to_string(),\n+                        tcx.lookup_item_type(item.def_id).ty)\n+            }\n+        }\n+    };\n+\n     if !missing_items.is_empty() {\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.name().to_string())\n+                  .map(|trait_item| trait_item.name.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, &format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n-                    .map(|trait_item| trait_item.name().to_string())\n+                    .map(|trait_item| trait_item.name.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n-            if let Some(span) = tcx.map.span_if_local(trait_item.def_id()) {\n-                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name()));\n+            if let Some(span) = tcx.map.span_if_local(trait_item.def_id) {\n+                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name));\n             } else {\n                 err.note(&format!(\"`{}` from trait: `{}`\",\n-                                  trait_item.name(),\n-                                  signature(trait_item)));\n+                                  trait_item.name,\n+                                  signature(&trait_item)));\n             }\n         }\n         err.emit();\n@@ -1172,14 +1133,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn signature<'a, 'tcx>(item: &ty::ImplOrTraitItem) -> String {\n-    match *item {\n-        ty::MethodTraitItem(ref item) => format!(\"{}\", item.fty.sig.0),\n-        ty::TypeTraitItem(ref item) => format!(\"type {};\", item.name.to_string()),\n-        ty::ConstTraitItem(ref item) => format!(\"const {}: {:?};\", item.name.to_string(), item.ty),\n-    }\n-}\n-\n /// Checks a constant with a given type.\n fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    expr: &'tcx hir::Expr,\n@@ -1385,19 +1338,6 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n-    fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: DefId,\n-                                           assoc_name: ast::Name)\n-                                           -> bool\n-    {\n-        self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n-            match self.tcx().impl_or_trait_item(def_id) {\n-                ty::TypeTraitItem(ref item) => item.name == assoc_name,\n-                _ => false\n-            }\n-        })\n-    }\n-\n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.next_ty_var()\n     }\n@@ -1643,12 +1583,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// As `instantiate_type_scheme`, but for the bounds found in a\n     /// generic type scheme.\n-    fn instantiate_bounds(&self,\n-                          span: Span,\n-                          substs: &Substs<'tcx>,\n-                          bounds: &ty::GenericPredicates<'tcx>)\n-                          -> ty::InstantiatedPredicates<'tcx>\n-    {\n+    fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n+                          -> ty::InstantiatedPredicates<'tcx> {\n+        let bounds = self.tcx.lookup_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result.predicates);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -3279,8 +3216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             // Check bounds on type arguments used in the path.\n-            let type_predicates = self.tcx.lookup_predicates(did);\n-            let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+            let bounds = self.instantiate_bounds(path.span, did, substs);\n             let cause = traits::ObligationCause::new(path.span, self.body_id,\n                                                      traits::ItemObligation(did));\n             self.add_obligations_for_parameters(cause, &bounds);\n@@ -4149,7 +4085,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Case 3. Reference to a method or associated const.\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let container = self.tcx.impl_or_trait_item(def_id).container();\n+                let container = self.tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n@@ -4290,13 +4226,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n         let scheme = self.tcx.lookup_item_type(def.def_id());\n-        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n         assert!(!substs.has_escaping_regions());\n         assert!(!scheme.ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n-        let bounds = self.instantiate_bounds(span, &substs, &type_predicates);\n+        let bounds = self.instantiate_bounds(span, def.def_id(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def.def_id())),\n             &bounds);"}, {"sha": "07415bab2f100d4fac633eec0e992a17c6893fec", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use astconv::ExplicitSelf;\n use check::FnCtxt;\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n+\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n@@ -156,8 +158,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            hir::ItemTrait(.., ref items) => {\n-                self.check_trait(item, items);\n+            hir::ItemTrait(..) => {\n+                self.check_trait(item);\n             }\n             _ => {}\n         }\n@@ -172,32 +174,39 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n-            let item = fcx.tcx.impl_or_trait_item(fcx.tcx.map.local_def_id(item_id));\n+            let item = fcx.tcx.associated_item(fcx.tcx.map.local_def_id(item_id));\n \n-            let (mut implied_bounds, self_ty) = match item.container() {\n+            let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                               fcx.tcx.lookup_item_type(def_id).ty)\n             };\n \n-            match item {\n-                ty::ConstTraitItem(assoc_const) => {\n-                    let ty = fcx.instantiate_type_scheme(span, free_substs, &assoc_const.ty);\n+            match item.kind {\n+                ty::AssociatedKind::Const => {\n+                    let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n-                ty::MethodTraitItem(method) => {\n-                    reject_shadowing_type_parameters(fcx.tcx, span, &method.generics);\n-                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-                    let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n-                    this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n+                ty::AssociatedKind::Method => {\n+                    reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n+                    let method_ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n+                    let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n+                    let fty = match method_ty.sty {\n+                        ty::TyFnDef(_, _, f) => f,\n+                        _ => bug!()\n+                    };\n+                    this.check_fn_or_method(fcx, span, fty, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &method,\n+                    this.check_method_receiver(fcx, sig_if_method, &item,\n                                                free_id_outlive, self_ty);\n                 }\n-                ty::TypeTraitItem(assoc_type) => {\n-                    if let Some(ref ty) = assoc_type.ty {\n-                        let ty = fcx.instantiate_type_scheme(span, free_substs, ty);\n+                ty::AssociatedKind::Type => {\n+                    if item.has_value {\n+                        let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                        let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n                 }\n@@ -248,19 +257,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             }\n \n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             vec![] // no implied bounds in a struct def'n\n         });\n     }\n \n-    fn check_auto_trait(&mut self,\n-                        trait_def_id: DefId,\n-                        items: &[hir::TraitItem],\n-                        span: Span)\n-    {\n+    fn check_auto_trait(&mut self, trait_def_id: DefId, span: Span) {\n         // We want to ensure:\n         //\n         // 1) that there are no items contained within\n@@ -302,7 +307,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         // extraneous predicates created by things like\n         // an associated type inside the trait.\n         let mut err = None;\n-        if !items.is_empty() {\n+        if !self.tcx().associated_item_def_ids(trait_def_id).is_empty() {\n             error_380(self.ccx, span);\n         } else if has_ty_params {\n             err = Some(struct_span_err!(self.tcx().sess, span, E0567,\n@@ -326,20 +331,16 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n     }\n \n-    fn check_trait(&mut self,\n-                   item: &hir::Item,\n-                   items: &[hir::TraitItem])\n-    {\n+    fn check_trait(&mut self, item: &hir::Item) {\n         let trait_def_id = self.tcx().map.local_def_id(item.id);\n \n         if self.tcx().trait_has_default_impl(trait_def_id) {\n-            self.check_auto_trait(trait_def_id, items, item.span);\n+            self.check_auto_trait(trait_def_id, item.span);\n         }\n \n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx.lookup_predicates(trait_def_id);\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, trait_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n             vec![]\n         });\n@@ -351,7 +352,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n+            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let type_scheme = fcx.tcx.lookup_item_type(def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n@@ -360,8 +362,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n             let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body.id);\n@@ -422,8 +423,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.lookup_predicates(item_def_id);\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n@@ -476,43 +476,47 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     fn check_method_receiver<'fcx, 'tcx>(&mut self,\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n-                                         method: &ty::Method<'tcx>,\n+                                         method: &ty::AssociatedItem,\n                                          free_id_outlive: CodeExtent,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n-        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?})\",\n-               method.name, method.explicit_self, self_ty);\n+        debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n+               method, self_ty);\n \n-        let rcvr_ty = match method.explicit_self {\n-            ty::ExplicitSelfCategory::Static => return,\n-            ty::ExplicitSelfCategory::ByValue => self_ty,\n-            ty::ExplicitSelfCategory::ByReference(region, mutability) => {\n-                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n-                    ty: self_ty,\n-                    mutbl: mutability\n-                })\n-            }\n-            ty::ExplicitSelfCategory::ByBox => fcx.tcx.mk_box(self_ty)\n-        };\n+        if !method.method_has_self_argument {\n+            return;\n+        }\n \n         let span = method_sig.decl.inputs[0].pat.span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+        let method_ty = fcx.tcx.lookup_item_type(method.def_id).ty;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n+        let self_arg_ty = sig.inputs[0];\n+        let rcvr_ty = match ExplicitSelf::determine(self_ty, self_arg_ty) {\n+            ExplicitSelf::ByValue => self_ty,\n+            ExplicitSelf::ByReference(region, mutbl) => {\n+                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n+                    ty: self_ty,\n+                    mutbl: mutbl\n+                })\n+            }\n+            ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n+        };\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n         let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n                                                           &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n         let origin = TypeOrigin::MethodReceiver(span);\n-        fcx.demand_eqtype_with_origin(origin, rcvr_ty, sig.inputs[0]);\n+        fcx.demand_eqtype_with_origin(origin, rcvr_ty, self_arg_ty);\n     }\n \n     fn check_variances_for_type_defn(&self,\n@@ -578,7 +582,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n+fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n+    let generics = tcx.lookup_generics(def_id);\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()"}, {"sha": "90541539c1e23551dcdfafa9ef0887eb82d3934d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -38,8 +38,6 @@ use rustc::hir::intravisit;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n-use std::rc::Rc;\n-\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -113,8 +111,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        let impl_items = self.create_impl_from_item(item);\n-\n         if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n@@ -144,8 +140,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n-\n-        tcx.impl_or_trait_item_def_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -161,20 +155,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n-    // Converts an implementation in the AST to a vector of items.\n-    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n-        match item.node {\n-            ItemImpl(.., ref impl_items) => {\n-                impl_items.iter()\n-                    .map(|impl_item| self.crate_context.tcx.map.local_def_id(impl_item.id))\n-                    .collect()\n-            }\n-            _ => {\n-                span_bug!(item.span, \"can't convert a non-impl to an impl\");\n-            }\n-        }\n-    }\n-\n     // Destructors\n     //\n \n@@ -187,10 +167,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n-        let impl_items = tcx.impl_or_trait_item_def_ids.borrow();\n-\n         drop_trait.for_each_impl(tcx, |impl_did| {\n-            let items = impl_items.get(&impl_did).unwrap();\n+            let items = tcx.associated_item_def_ids(impl_did);\n             if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n                 return;"}, {"sha": "b5aba512a66bd6c0172c5a3b8184fd830c657002", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -48,25 +48,23 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             Value,\n         }\n \n-        fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId)\n-                                        -> (ast::Name, Namespace) {\n-            let item = tcx.impl_or_trait_item(def_id);\n-            (item.name(),\n-             match item {\n-                 ty::TypeTraitItem(..) => Namespace::Type,\n-                 ty::ConstTraitItem(..) => Namespace::Value,\n-                 ty::MethodTraitItem(..) => Namespace::Value,\n-             })\n-        }\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n \n-        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n \n-        for &item1 in &impl_items[&impl1][..] {\n-            let (name, namespace) = name_and_namespace(self.tcx, item1);\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n \n-            for &item2 in &impl_items[&impl2][..] {\n-                if (name, namespace) == name_and_namespace(self.tcx, item2) {\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n                     let node_id = self.tcx.map.as_local_node_id(item1).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,"}, {"sha": "d92a98485103cd6ef4b8ad5cc1ad3db9ffa9b7c7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 54, "deletions": 183, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -66,7 +66,7 @@ use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n+use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n@@ -79,7 +79,6 @@ use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::rc::Rc;\n \n use syntax::{abi, ast, attr};\n use syntax::parse::token::keywords;\n@@ -351,24 +350,6 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: DefId,\n-                                           assoc_name: ast::Name)\n-                                           -> bool\n-    {\n-        if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n-            trait_associated_type_names(self.tcx(), trait_id)\n-                .any(|name| name == assoc_name)\n-        } else {\n-            self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n-                match self.tcx().impl_or_trait_item(def_id) {\n-                    ty::TypeTraitItem(ref item) => item.name == assoc_name,\n-                    _ => false\n-                }\n-            })\n-        }\n-    }\n-\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         None\n     }\n@@ -557,60 +538,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            container: ImplOrTraitItemContainer,\n-                            name: ast::Name,\n-                            id: ast::NodeId,\n-                            vis: &hir::Visibility,\n-                            sig: &hir::MethodSig,\n-                            defaultness: hir::Defaultness,\n-                            has_body: bool,\n-                            untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n-    let def_id = ccx.tcx.map.local_def_id(id);\n-    let ty_generics = generics_of_def_id(ccx, def_id);\n-\n-    let ty_generic_predicates =\n-        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n-\n-    let (fty, explicit_self_category) = {\n-        let anon_scope = match container {\n-            ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n-            TraitContainer(_) => None\n-        };\n-        AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                              sig, untransformed_rcvr_ty, anon_scope)\n-    };\n-\n-    let ty_method = ty::Method {\n-        name: name,\n-        generics: ty_generics,\n-        predicates: ty_generic_predicates,\n-        fty: fty,\n-        explicit_self: explicit_self_category,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        has_body: has_body,\n-        def_id: def_id,\n-        container: container,\n-    };\n-\n-    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                ccx.tcx.map.span(id), def_id);\n-    let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty);\n-    debug!(\"method {} (id {}) has type {:?}\",\n-            name, id, fty);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n-    write_ty_to_tcx(ccx, id, fty);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n-\n-    debug!(\"writing method type: def_id={:?} mty={:?}\",\n-            def_id, ty_method);\n-\n-    ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n-        ty::MethodTraitItem(Rc::new(ty_method)));\n-}\n-\n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n@@ -631,62 +558,65 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            struct_predicates.clone());\n }\n \n+fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            container: AssociatedItemContainer,\n+                            id: ast::NodeId,\n+                            sig: &hir::MethodSig,\n+                            untransformed_rcvr_ty: Ty<'tcx>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n+\n+    let ty_generic_predicates =\n+        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n+\n+    let anon_scope = match container {\n+        ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n+        TraitContainer(_) => None\n+    };\n+    let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                    sig, untransformed_rcvr_ty, anon_scope);\n+\n+    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                ccx.tcx.map.span(id), def_id);\n+    let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n+    write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n+}\n+\n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                      container: ImplOrTraitItemContainer,\n-                                      name: ast::Name,\n+                                      container: AssociatedItemContainer,\n                                       id: ast::NodeId,\n-                                      vis: &hir::Visibility,\n-                                      defaultness: hir::Defaultness,\n-                                      ty: ty::Ty<'tcx>,\n-                                      has_value: bool)\n+                                      ty: ty::Ty<'tcx>)\n {\n     let predicates = ty::GenericPredicates {\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           predicates);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n \n     write_ty_to_tcx(ccx, id, ty);\n-\n-    let associated_const = Rc::new(ty::AssociatedConst {\n-        name: name,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        def_id: ccx.tcx.map.local_def_id(id),\n-        container: container,\n-        ty: ty,\n-        has_value: has_value\n-    });\n-    ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(ccx.tcx.map.local_def_id(id), ty::ConstTraitItem(associated_const));\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     container: ImplOrTraitItemContainer,\n-                                     name: ast::Name,\n+                                     container: AssociatedItemContainer,\n                                      id: ast::NodeId,\n-                                     vis: &hir::Visibility,\n-                                     defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let predicates = ty::GenericPredicates {\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           predicates);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n \n-    let associated_type = Rc::new(ty::AssociatedType {\n-        name: name,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        ty: ty,\n-        def_id: ccx.tcx.map.local_def_id(id),\n-        container: container\n-    });\n-    ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(ccx.tcx.map.local_def_id(id), ty::TypeTraitItem(associated_type));\n+    if let Some(ty) = ty {\n+        ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n+        write_ty_to_tcx(ccx, id, ty);\n+    }\n }\n \n fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n@@ -820,14 +750,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics,\n                                                ty: ty,\n                                            });\n-                    // Trait-associated constants are always public.\n-                    let public = &hir::Public;\n-                    let visibility = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n                     convert_associated_const(ccx, ImplContainer(def_id),\n-                                             impl_item.name, impl_item.id,\n-                                             visibility,\n-                                             impl_item.defaultness,\n-                                             ty, true /* has_value */);\n+                                             impl_item.id, ty);\n                 }\n             }\n \n@@ -844,21 +768,14 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(def_id),\n-                                            impl_item.name, impl_item.id, &impl_item.vis,\n-                                            impl_item.defaultness, Some(typ));\n+                    convert_associated_type(ccx, ImplContainer(def_id), impl_item.id, Some(typ));\n                 }\n             }\n \n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    // Trait methods are always public.\n-                    let public = &hir::Public;\n-                    let method_vis = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n-\n                     convert_method(ccx, ImplContainer(def_id),\n-                                   impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, true, selfty,\n+                                   impl_item.id, sig, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -880,7 +797,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the associated constants.\n             for trait_item in trait_items {\n-                if let hir::ConstTraitItem(ref ty, ref default) = trait_item.node {\n+                if let hir::ConstTraitItem(ref ty, _) = trait_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n                     let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n@@ -890,14 +807,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics,\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx,\n-                                             container,\n-                                             trait_item.name,\n-                                             trait_item.id,\n-                                             &hir::Public,\n-                                             hir::Defaultness::Default,\n-                                             ty,\n-                                             default.is_some())\n+                    convert_associated_const(ccx, container, trait_item.id, ty)\n                 }\n             }\n \n@@ -911,39 +821,21 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                         |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                     });\n \n-                    convert_associated_type(ccx,\n-                                            container,\n-                                            trait_item.name,\n-                                            trait_item.id,\n-                                            &hir::Public,\n-                                            hir::Defaultness::Default,\n-                                            typ);\n+                    convert_associated_type(ccx, container, trait_item.id, typ);\n                 }\n             }\n \n             // Convert all the methods\n             for trait_item in trait_items {\n-                if let hir::MethodTraitItem(ref sig, ref body) = trait_item.node {\n+                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n                     convert_method(ccx,\n                                    container,\n-                                   trait_item.name,\n                                    trait_item.id,\n-                                   &hir::Inherited,\n                                    sig,\n-                                   hir::Defaultness::Default,\n-                                   body.is_some(),\n                                    tcx.mk_self_type(),\n                                    &trait_predicates);\n-\n                 }\n             }\n-\n-            // Add an entry mapping\n-            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                ccx.tcx.map.local_def_id(trait_item.id)\n-            }).collect());\n-            tcx.impl_or_trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                               trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n@@ -1308,28 +1200,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     tcx.intern_trait_def(trait_def)\n }\n \n-pub fn trait_associated_type_names<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                   trait_node_id: ast::NodeId)\n-                                                   -> impl Iterator<Item=ast::Name> + 'a\n-{\n-    let item = match tcx.map.get(trait_node_id) {\n-        hir_map::NodeItem(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n-    };\n-\n-    let trait_items = match item.node {\n-        hir::ItemTrait(.., ref trait_items) => trait_items,\n-        _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n-    };\n-\n-    trait_items.iter().filter_map(|trait_item| {\n-        match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.name),\n-            _ => None,\n-        }\n-    })\n-}\n-\n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n@@ -2209,13 +2079,14 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n-        .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n-        .filter_map(|item| match item {\n-            ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n-            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n+        .map(|item|  ccx.tcx.map.local_def_id(item.id))\n+        .filter(|&def_id| {\n+            let item = ccx.tcx.associated_item(def_id);\n+            item.kind == ty::AssociatedKind::Type && item.has_value\n         })\n-        .flat_map(|ty| ctp::parameters_for(&ty, true))\n-        .collect();\n+        .flat_map(|def_id| {\n+            ctp::parameters_for(&ccx.tcx.lookup_item_type(def_id).ty, true)\n+        }).collect();\n \n     for (ty_lifetime, lifetime) in impl_scheme.generics.regions.iter()\n         .zip(&ast_generics.lifetimes)"}, {"sha": "a2955169cbb81d70947c05fb76fde65e1a4a806c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -163,7 +163,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n-    let trait_items = tcx.trait_items(did).clean(cx);\n+    let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = tcx.lookup_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n@@ -307,7 +307,6 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n         if !def_id.is_local() {\n-            tcx.populate_implementations_for_primitive_if_necessary(def_id);\n             build_impl(cx, tcx, def_id, &mut impls);\n         }\n     }\n@@ -367,43 +366,40 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = tcx.sess.cstore.impl_or_trait_items(did)\n-            .iter()\n-            .filter_map(|&did| {\n-        match tcx.impl_or_trait_item(did) {\n-            ty::ConstTraitItem(ref assoc_const) => {\n-                let did = assoc_const.def_id;\n-                let type_scheme = tcx.lookup_item_type(did);\n-                let default = if assoc_const.has_value {\n+    let trait_items = tcx.associated_items(did).filter_map(|item| {\n+        match item.kind {\n+            ty::AssociatedKind::Const => {\n+                let type_scheme = tcx.lookup_item_type(item.def_id);\n+                let default = if item.has_value {\n                     Some(pprust::expr_to_string(\n-                        lookup_const_by_id(tcx, did, None).unwrap().0))\n+                        lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n                 } else {\n                     None\n                 };\n                 Some(clean::Item {\n-                    name: Some(assoc_const.name.clean(cx)),\n+                    name: Some(item.name.clean(cx)),\n                     inner: clean::AssociatedConstItem(\n                         type_scheme.ty.clean(cx),\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: tcx.lookup_stability(did).clean(cx),\n-                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n-                    def_id: did\n+                    stability: tcx.lookup_stability(item.def_id).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n+                    def_id: item.def_id\n                 })\n             }\n-            ty::MethodTraitItem(method) => {\n-                if method.vis != ty::Visibility::Public && associated_trait.is_none() {\n+            ty::AssociatedKind::Method => {\n+                if item.vis != ty::Visibility::Public && associated_trait.is_none() {\n                     return None\n                 }\n-                let mut item = method.clean(cx);\n-                item.inner = match item.inner.clone() {\n+                let mut cleaned = item.clean(cx);\n+                cleaned.inner = match cleaned.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n                         unsafety, decl, generics, abi\n                     }) => {\n-                        let constness = if tcx.sess.cstore.is_const_fn(did) {\n+                        let constness = if tcx.sess.cstore.is_const_fn(item.def_id) {\n                             hir::Constness::Const\n                         } else {\n                             hir::Constness::NotConst\n@@ -419,27 +415,26 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                     }\n                     _ => panic!(\"not a tymethod\"),\n                 };\n-                Some(item)\n+                Some(cleaned)\n             }\n-            ty::TypeTraitItem(ref assoc_ty) => {\n-                let did = assoc_ty.def_id;\n+            ty::AssociatedKind::Type => {\n                 let typedef = clean::Typedef {\n-                    type_: assoc_ty.ty.unwrap().clean(cx),\n+                    type_: tcx.lookup_item_type(item.def_id).ty.clean(cx),\n                     generics: clean::Generics {\n                         lifetimes: vec![],\n                         type_params: vec![],\n                         where_predicates: vec![]\n                     }\n                 };\n                 Some(clean::Item {\n-                    name: Some(assoc_ty.name.clean(cx)),\n+                    name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: tcx.lookup_stability(did).clean(cx),\n-                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n-                    def_id: did\n+                    stability: tcx.lookup_stability(item.def_id).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n+                    def_id: item.def_id\n                 })\n             }\n         }"}, {"sha": "9e29d191946b71957dbc68f07af6b63b33ecb69c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 105, "deletions": 119, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0ffadb6722371b9eb636ee9b2d4627db9e02fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=de0ffadb6722371b9eb636ee9b2d4627db9e02fa", "patch": "@@ -1338,48 +1338,117 @@ impl Clean<Item> for hir::ImplItem {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n+impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let generics = (self.generics, &self.predicates).clean(cx);\n-        let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n-        match self.explicit_self {\n-            ty::ExplicitSelfCategory::ByValue => {\n-                decl.inputs.values[0].type_ = Infer;\n+        let inner = match self.kind {\n+            ty::AssociatedKind::Const => {\n+                let ty = cx.tcx().lookup_item_type(self.def_id).ty;\n+                AssociatedConstItem(ty.clean(cx), None)\n             }\n-            ty::ExplicitSelfCategory::ByReference(..) => {\n-                match decl.inputs.values[0].type_ {\n-                    BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n-                    _ => unreachable!(),\n+            ty::AssociatedKind::Method => {\n+                let generics = (cx.tcx().lookup_generics(self.def_id),\n+                                &cx.tcx().lookup_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx().lookup_item_type(self.def_id).ty.sty {\n+                    ty::TyFnDef(_, _, f) => f,\n+                    _ => unreachable!()\n+                };\n+                let mut decl = (self.def_id, &fty.sig).clean(cx);\n+\n+                if self.method_has_self_argument {\n+                    let self_ty = match self.container {\n+                        ty::ImplContainer(def_id) => {\n+                            cx.tcx().lookup_item_type(def_id).ty\n+                        }\n+                        ty::TraitContainer(_) => cx.tcx().mk_self_type()\n+                    };\n+                    let self_arg_ty = *fty.sig.input(0).skip_binder();\n+                    if self_arg_ty == self_ty {\n+                        decl.inputs.values[0].type_ = Infer;\n+                    } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n+                        if mt.ty == self_ty {\n+                            match decl.inputs.values[0].type_ {\n+                                BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                                _ => unreachable!(),\n+                            }\n+                        }\n+                    }\n+                }\n+                let provided = match self.container {\n+                    ty::ImplContainer(_) => false,\n+                    ty::TraitContainer(_) => self.has_value\n+                };\n+                if provided {\n+                    MethodItem(Method {\n+                        unsafety: fty.unsafety,\n+                        generics: generics,\n+                        decl: decl,\n+                        abi: fty.abi,\n+\n+                        // trait methods canot (currently, at least) be const\n+                        constness: hir::Constness::NotConst,\n+                    })\n+                } else {\n+                    TyMethodItem(TyMethod {\n+                        unsafety: fty.unsafety,\n+                        generics: generics,\n+                        decl: decl,\n+                        abi: fty.abi,\n+                    })\n                 }\n             }\n-            _ => {}\n-        }\n-        let provided = match self.container {\n-            ty::ImplContainer(..) => false,\n-            ty::TraitContainer(did) => {\n-                cx.tcx().provided_trait_methods(did).iter().any(|m| {\n-                    m.def_id == self.def_id\n-                })\n+            ty::AssociatedKind::Type => {\n+                let my_name = self.name.clean(cx);\n+\n+                let mut bounds = if let ty::TraitContainer(did) = self.container {\n+                    // When loading a cross-crate associated type, the bounds for this type\n+                    // are actually located on the trait/impl itself, so we need to load\n+                    // all of the generics from there and then look for bounds that are\n+                    // applied to this associated type in question.\n+                    let def = cx.tcx().lookup_trait_def(did);\n+                    let predicates = cx.tcx().lookup_predicates(did);\n+                    let generics = (def.generics, &predicates).clean(cx);\n+                    generics.where_predicates.iter().filter_map(|pred| {\n+                        let (name, self_type, trait_, bounds) = match *pred {\n+                            WherePredicate::BoundPredicate {\n+                                ty: QPath { ref name, ref self_type, ref trait_ },\n+                                ref bounds\n+                            } => (name, self_type, trait_, bounds),\n+                            _ => return None,\n+                        };\n+                        if *name != my_name { return None }\n+                        match **trait_ {\n+                            ResolvedPath { did, .. } if did == self.container.id() => {}\n+                            _ => return None,\n+                        }\n+                        match **self_type {\n+                            Generic(ref s) if *s == \"Self\" => {}\n+                            _ => return None,\n+                        }\n+                        Some(bounds)\n+                    }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>()\n+                } else {\n+                    vec![]\n+                };\n+\n+                // Our Sized/?Sized bound didn't get handled when creating the generics\n+                // because we didn't actually get our whole set of bounds until just now\n+                // (some of them may have come from the trait). If we do have a sized\n+                // bound, we remove it, and if we don't then we add the `?Sized` bound\n+                // at the end.\n+                match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n+                    Some(i) => { bounds.remove(i); }\n+                    None => bounds.push(TyParamBound::maybe_sized(cx)),\n+                }\n+\n+                let ty = if self.has_value {\n+                    Some(cx.tcx().lookup_item_type(self.def_id).ty)\n+                } else {\n+                    None\n+                };\n+\n+                AssociatedTypeItem(bounds, ty.clean(cx))\n             }\n         };\n-        let inner = if provided {\n-            MethodItem(Method {\n-                unsafety: self.fty.unsafety,\n-                generics: generics,\n-                decl: decl,\n-                abi: self.fty.abi,\n-\n-                // trait methods canot (currently, at least) be const\n-                constness: hir::Constness::NotConst,\n-            })\n-        } else {\n-            TyMethodItem(TyMethod {\n-                unsafety: self.fty.unsafety,\n-                generics: generics,\n-                decl: decl,\n-                abi: self.fty.abi,\n-            })\n-        };\n \n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -1394,16 +1463,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        match *self {\n-            ty::ConstTraitItem(ref cti) => cti.clean(cx),\n-            ty::MethodTraitItem(ref mti) => mti.clean(cx),\n-            ty::TypeTraitItem(ref tti) => tti.clean(cx),\n-        }\n-    }\n-}\n-\n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PolyTrait {\n@@ -2884,79 +2943,6 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: DUMMY_SP.clean(cx),\n-            name: Some(self.name.clean(cx)),\n-            attrs: Vec::new(),\n-            inner: AssociatedConstItem(self.ty.clean(cx), None),\n-            visibility: None,\n-            def_id: self.def_id,\n-            stability: None,\n-            deprecation: None,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        let my_name = self.name.clean(cx);\n-\n-        let mut bounds = if let ty::TraitContainer(did) = self.container {\n-            // When loading a cross-crate associated type, the bounds for this type\n-            // are actually located on the trait/impl itself, so we need to load\n-            // all of the generics from there and then look for bounds that are\n-            // applied to this associated type in question.\n-            let def = cx.tcx().lookup_trait_def(did);\n-            let predicates = cx.tcx().lookup_predicates(did);\n-            let generics = (def.generics, &predicates).clean(cx);\n-            generics.where_predicates.iter().filter_map(|pred| {\n-                let (name, self_type, trait_, bounds) = match *pred {\n-                    WherePredicate::BoundPredicate {\n-                        ty: QPath { ref name, ref self_type, ref trait_ },\n-                        ref bounds\n-                    } => (name, self_type, trait_, bounds),\n-                    _ => return None,\n-                };\n-                if *name != my_name { return None }\n-                match **trait_ {\n-                    ResolvedPath { did, .. } if did == self.container.id() => {}\n-                    _ => return None,\n-                }\n-                match **self_type {\n-                    Generic(ref s) if *s == \"Self\" => {}\n-                    _ => return None,\n-                }\n-                Some(bounds)\n-            }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>()\n-        } else {\n-            vec![]\n-        };\n-\n-        // Our Sized/?Sized bound didn't get handled when creating the generics\n-        // because we didn't actually get our whole set of bounds until just now\n-        // (some of them may have come from the trait). If we do have a sized\n-        // bound, we remove it, and if we don't then we add the `?Sized` bound\n-        // at the end.\n-        match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n-            Some(i) => { bounds.remove(i); }\n-            None => bounds.push(TyParamBound::maybe_sized(cx)),\n-        }\n-\n-        Item {\n-            source: DUMMY_SP.clean(cx),\n-            name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n-            inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n-            visibility: self.vis.clean(cx),\n-            def_id: self.def_id,\n-            stability: cx.tcx().lookup_stability(self.def_id).clean(cx),\n-            deprecation: cx.tcx().lookup_deprecation(self.def_id).clean(cx),\n-        }\n-    }\n-}\n-\n fn lang_struct(cx: &DocContext, did: Option<DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}]}