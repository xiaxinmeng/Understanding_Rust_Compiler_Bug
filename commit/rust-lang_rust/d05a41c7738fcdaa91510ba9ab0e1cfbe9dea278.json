{"sha": "d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNWE0MWM3NzM4ZmNkYWE5MTUxMGJhOWFiMGUxY2ZiZTlkZWEyNzg=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-04T16:09:05Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-07T18:35:25Z"}, "message": "Add failure mode to `write_list`", "tree": {"sha": "ff7d9bf04d47d3afda7462ec97476afb5881629a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff7d9bf04d47d3afda7462ec97476afb5881629a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "html_url": "https://github.com/rust-lang/rust/commit/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a61a989d5074069cf63abd4364470c1d0780da6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a61a989d5074069cf63abd4364470c1d0780da6", "html_url": "https://github.com/rust-lang/rust/commit/2a61a989d5074069cf63abd4364470c1d0780da6"}], "stats": {"total": 510, "additions": 296, "deletions": 214}, "files": [{"sha": "08acd5de67d4cbed91550d305eb6011235d3a3f7", "filename": "src/expr.rs", "status": "modified", "additions": 70, "deletions": 49, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cmp::Ordering;\n+\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n use StructLitStyle;\n-use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width};\n+use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n@@ -134,37 +136,9 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n-            _ => {\n-                // We do not format these expressions yet, but they should still\n-                // satisfy our width restrictions.\n-                let snippet = context.snippet(self.span);\n-\n-                {\n-                    let mut lines = snippet.lines();\n-\n-                    // The caller of this function has already placed `offset`\n-                    // characters on the first line.\n-                    let first_line_max_len = try_opt!(context.config.max_width.checked_sub(offset));\n-                    if lines.next().unwrap().len() > first_line_max_len {\n-                        return None;\n-                    }\n-\n-                    // The other lines must fit within the maximum width.\n-                    if lines.find(|line| line.len() > context.config.max_width).is_some() {\n-                        return None;\n-                    }\n-\n-                    // `width` is the maximum length of the last line, excluding\n-                    // indentation.\n-                    // A special check for the last line, since the caller may\n-                    // place trailing characters on this line.\n-                    if snippet.lines().rev().next().unwrap().len() > offset + width {\n-                        return None;\n-                    }\n-                }\n-\n-                Some(snippet)\n-            }\n+            // We do not format these expressions yet, but they should still\n+            // satisfy our width restrictions.\n+            _ => wrap_str(context.snippet(self.span), context.config.max_width, width, offset),\n         }\n     }\n }\n@@ -202,7 +176,8 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                                  body.span.lo);\n \n     let fmt = ListFormatting::for_fn(argument_budget, argument_offset);\n-    let prefix = format!(\"{}|{}|\", mover, write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n+    let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n+    let prefix = format!(\"{}|{}|\", mover, list_str);\n     let closure_indent = closure_indent(context, offset);\n \n     // Try to format closure body as a single line expression without braces.\n@@ -869,19 +844,58 @@ fn rewrite_call(context: &RewriteContext,\n                 -> Option<String> {\n     debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n-    // FIXME using byte lens instead of char lens (and probably all over the place too)\n     // 2 is for parens\n-    let max_callee_width = try_opt!(width.checked_sub(2));\n-    let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n-    debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n-\n-    if args.is_empty() {\n-        return Some(format!(\"{}()\", callee_str));\n+    let mut hi = try_opt!(width.checked_sub(2)) * 2;\n+    let mut lo = 0;\n+    let mut tries = 0;\n+\n+    // Binary search for the best split between callee and arguments.\n+    loop {\n+        let middle = (lo + hi) / 2;\n+\n+        match rewrite_call_inner(context, callee, middle, args, span, width, offset) {\n+            _ if tries > 10 => return None,\n+            Ok(result) => return Some(result),\n+            Err(Ordering::Less) => {\n+                lo = middle;\n+                tries += 1;\n+            }\n+            Err(Ordering::Greater) => {\n+                hi = middle;\n+                tries += 1;\n+            }\n+            _ => unreachable!(),\n+        }\n     }\n+}\n+\n+fn rewrite_call_inner(context: &RewriteContext,\n+                      callee: &ast::Expr,\n+                      max_callee_width: usize,\n+                      args: &[ptr::P<ast::Expr>],\n+                      span: Span,\n+                      width: usize,\n+                      offset: usize)\n+                      -> Result<String, Ordering> {\n+    // FIXME using byte lens instead of char lens (and probably all over the place too)\n+    let callee_str = match callee.rewrite(context, max_callee_width, offset) {\n+        Some(string) => {\n+            if !string.contains('\\n') && string.len() > max_callee_width {\n+                panic!(\"{:?} {}\", string, max_callee_width);\n+            } else {\n+                string\n+            }\n+        }\n+        None => return Err(Ordering::Less),\n+    };\n+    debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n \n     let extra_offset = extra_offset(&callee_str, offset);\n     // 2 is for parens.\n-    let remaining_width = try_opt!(width.checked_sub(extra_offset + 2));\n+    let remaining_width = match width.checked_sub(extra_offset + 2) {\n+        Some(str) => str,\n+        None => return Err(Ordering::Greater),\n+    };\n     let offset = offset + extra_offset + 1;\n     let inner_indent = expr_indent(context, offset);\n     let inner_context = context.overflow_context(inner_indent - context.block_indent);\n@@ -900,8 +914,12 @@ fn rewrite_call(context: &RewriteContext,\n                              span.hi);\n \n     let fmt = ListFormatting::for_fn(remaining_width, offset);\n+    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+        Some(str) => str,\n+        None => return Err(Ordering::Greater),\n+    };\n \n-    Some(format!(\"{}({})\", callee_str, write_list(&items.collect::<Vec<_>>(), &fmt)))\n+    Ok(format!(\"{}({})\", callee_str, list_str))\n }\n \n macro_rules! block_indent_helper {\n@@ -1024,7 +1042,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         v_width: v_budget,\n         ends_with_newline: false,\n     };\n-    let fields_str = write_list(&items.collect::<Vec<_>>(), &fmt);\n+    let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     match context.config.struct_lit_style {\n         StructLitStyle::Block if fields_str.contains('\\n') => {\n@@ -1046,7 +1064,8 @@ fn rewrite_field(context: &RewriteContext,\n                  -> Option<String> {\n     let name = &field.ident.node.to_string();\n     let overhead = name.len() + 2;\n-    let expr = field.expr.rewrite(context, try_opt!(width.checked_sub(overhead)), offset + overhead);\n+    let expr =\n+        field.expr.rewrite(context, try_opt!(width.checked_sub(overhead)), offset + overhead);\n     expr.map(|s| format!(\"{}: {}\", name, s))\n }\n \n@@ -1080,8 +1099,9 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n \n     let budget = try_opt!(width.checked_sub(2));\n     let fmt = ListFormatting::for_fn(budget, indent);\n+    let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n-    Some(format!(\"({})\", write_list(&items.collect::<Vec<_>>(), &fmt)))\n+    Some(format!(\"({})\", list_str))\n }\n \n fn rewrite_binary_op(context: &RewriteContext,\n@@ -1206,12 +1226,13 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             let new_offset = offset + context.config.tab_spaces;\n             result.push_str(&format!(\"\\n{}\", make_indent(new_offset)));\n \n+            // FIXME: we probably should related max_width to width instead of config.max_width\n+            // where is the 1 coming from anyway?\n             let max_width = try_opt!(context.config.max_width.checked_sub(new_offset + 1));\n-            let rhs = try_opt!(ex.rewrite(&context.overflow_context(context.config.tab_spaces),\n-                                          max_width,\n-                                          new_offset));\n+            let overflow_context = context.overflow_context(context.config.tab_spaces);\n+            let rhs = ex.rewrite(&overflow_context, max_width, new_offset);\n \n-            result.push_str(&rhs);\n+            result.push_str(&&try_opt!(rhs));\n         }\n     }\n "}, {"sha": "8411b3208df82b4af78ceb886a9c37cca33efe10", "filename": "src/imports.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -22,13 +22,11 @@ impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         match self.node {\n+            ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n+                Some(String::new())\n+            }\n             ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                Some(rewrite_use_list(width,\n-                                      offset,\n-                                      path,\n-                                      path_list,\n-                                      self.span,\n-                                      context).unwrap_or(\"\".to_owned()))\n+                rewrite_use_list(width, offset, path, path_list, self.span, context)\n             }\n             ast::ViewPath_::ViewPathGlob(_) => {\n                 // FIXME convert to list?\n@@ -67,8 +65,8 @@ fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem) -> String {\n     }\n }\n \n-// Basically just pretty prints a multi-item import.\n-// Returns None when the import can be removed.\n+// Pretty prints a multi-item import.\n+// Assumes that path_list.len() > 0.\n pub fn rewrite_use_list(width: usize,\n                         offset: usize,\n                         path: &ast::Path,\n@@ -80,7 +78,7 @@ pub fn rewrite_use_list(width: usize,\n     let path_str = try_opt!(path.rewrite(context, width - 1, offset));\n \n     match path_list.len() {\n-        0 => return None,\n+        0 => unreachable!(),\n         1 => return Some(rewrite_single_use_list(path_str, path_list[0])),\n         _ => (),\n     }\n@@ -149,12 +147,12 @@ pub fn rewrite_use_list(width: usize,\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n \n-    let list = write_list(&items[first_index..], &fmt);\n+    let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {\n-            format!(\"{{{}}}\", list)\n+            format!(\"{{{}}}\", list_str)\n         } else {\n-            format!(\"{}::{{{}}}\", path_str, list)\n+            format!(\"{}::{{{}}}\", path_str, list_str)\n         })\n }\n "}, {"sha": "e2224ce4eff9c0d32fbc5d2ca747953609af5c99", "filename": "src/items.rs", "status": "modified", "additions": 106, "deletions": 86, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -99,20 +99,20 @@ impl<'a> FmtVisitor<'a> {\n                       abi: &abi::Abi,\n                       vis: ast::Visibility,\n                       span: Span)\n-                      -> String {\n+                      -> Option<String> {\n         let mut newline_brace = self.newline_for_brace(&generics.where_clause);\n \n-        let mut result = self.rewrite_fn_base(indent,\n-                                              ident,\n-                                              fd,\n-                                              explicit_self,\n-                                              generics,\n-                                              unsafety,\n-                                              constness,\n-                                              abi,\n-                                              vis,\n-                                              span,\n-                                              newline_brace);\n+        let mut result = try_opt!(self.rewrite_fn_base(indent,\n+                                                       ident,\n+                                                       fd,\n+                                                       explicit_self,\n+                                                       generics,\n+                                                       unsafety,\n+                                                       constness,\n+                                                       abi,\n+                                                       vis,\n+                                                       span,\n+                                                       newline_brace));\n \n         if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n@@ -130,34 +130,34 @@ impl<'a> FmtVisitor<'a> {\n             result.push(' ');\n         }\n \n-        result\n+        Some(result)\n     }\n \n     pub fn rewrite_required_fn(&mut self,\n                                indent: usize,\n                                ident: ast::Ident,\n                                sig: &ast::MethodSig,\n                                span: Span)\n-                               -> String {\n+                               -> Option<String> {\n         // Drop semicolon or it will be interpreted as comment\n         let span = codemap::mk_sp(span.lo, span.hi - BytePos(1));\n \n-        let mut result = self.rewrite_fn_base(indent,\n-                                              ident,\n-                                              &sig.decl,\n-                                              Some(&sig.explicit_self),\n-                                              &sig.generics,\n-                                              &sig.unsafety,\n-                                              &sig.constness,\n-                                              &sig.abi,\n-                                              ast::Visibility::Inherited,\n-                                              span,\n-                                              false);\n+        let mut result = try_opt!(self.rewrite_fn_base(indent,\n+                                                       ident,\n+                                                       &sig.decl,\n+                                                       Some(&sig.explicit_self),\n+                                                       &sig.generics,\n+                                                       &sig.unsafety,\n+                                                       &sig.constness,\n+                                                       &sig.abi,\n+                                                       ast::Visibility::Inherited,\n+                                                       span,\n+                                                       false));\n \n         // Re-attach semicolon\n         result.push(';');\n \n-        result\n+        Some(result)\n     }\n \n     fn rewrite_fn_base(&mut self,\n@@ -172,7 +172,7 @@ impl<'a> FmtVisitor<'a> {\n                        vis: ast::Visibility,\n                        span: Span,\n                        newline_brace: bool)\n-                       -> String {\n+                       -> Option<String> {\n         // FIXME we'll lose any comments in between parts of the function decl, but anyone\n         // who comments there probably deserves what they get.\n \n@@ -200,11 +200,12 @@ impl<'a> FmtVisitor<'a> {\n \n         // Generics.\n         let generics_indent = indent + result.len();\n-        result.push_str(&self.rewrite_generics(generics,\n-                                               indent,\n-                                               generics_indent,\n-                                               codemap::mk_sp(span.lo,\n-                                                              span_for_return(&fd.output).lo)));\n+        let generics_span = codemap::mk_sp(span.lo, span_for_return(&fd.output).lo);\n+        let generics_str = try_opt!(self.rewrite_generics(generics,\n+                                                          indent,\n+                                                          generics_indent,\n+                                                          generics_span));\n+        result.push_str(&generics_str);\n \n         let ret_str = self.rewrite_return(&fd.output, indent);\n \n@@ -243,13 +244,14 @@ impl<'a> FmtVisitor<'a> {\n                                                   \"(\",\n                                                   self.codemap),\n                                        span_for_return(&fd.output).lo);\n-        result.push_str(&self.rewrite_args(&fd.inputs,\n-                                           explicit_self,\n-                                           one_line_budget,\n-                                           multi_line_budget,\n-                                           indent,\n-                                           arg_indent,\n-                                           args_span));\n+        let arg_str = try_opt!(self.rewrite_args(&fd.inputs,\n+                                                 explicit_self,\n+                                                 one_line_budget,\n+                                                 multi_line_budget,\n+                                                 indent,\n+                                                 arg_indent,\n+                                                 args_span));\n+        result.push_str(&arg_str);\n         if self.config.fn_args_layout == StructLitStyle::Block {\n             result.push('\\n');\n         }\n@@ -307,13 +309,14 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause,\n-                                                   self.config,\n-                                                   indent,\n-                                                   where_density,\n-                                                   span.hi));\n-\n-        result\n+        let where_clause_str = try_opt!(self.rewrite_where_clause(where_clause,\n+                                                                  self.config,\n+                                                                  indent,\n+                                                                  where_density,\n+                                                                  span.hi));\n+        result.push_str(&where_clause_str);\n+\n+        Some(result)\n     }\n \n     fn rewrite_args(&self,\n@@ -324,7 +327,7 @@ impl<'a> FmtVisitor<'a> {\n                     indent: usize,\n                     arg_indent: usize,\n                     span: Span)\n-                    -> String {\n+                    -> Option<String> {\n         let mut arg_item_strs: Vec<_> = args.iter().map(rewrite_fn_input).collect();\n         // Account for sugary self.\n         // FIXME: the comment for the self argument is dropped. This is blocked\n@@ -461,8 +464,8 @@ impl<'a> FmtVisitor<'a> {\n                                                 \" {\",\n                                                 self.block_indent,\n                                                 self.block_indent + self.config.tab_spaces,\n-                                                codemap::mk_sp(span.lo,\n-                                                               body_start));\n+                                                codemap::mk_sp(span.lo, body_start))\n+                               .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n@@ -534,7 +537,12 @@ impl<'a> FmtVisitor<'a> {\n                         v_width: budget,\n                         ends_with_newline: true,\n                     };\n-                    result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n+                    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+                        Some(list_str) => list_str,\n+                        None => return,\n+                    };\n+\n+                    result.push_str(&list_str);\n                     result.push(')');\n                 }\n \n@@ -554,13 +562,18 @@ impl<'a> FmtVisitor<'a> {\n             }\n             ast::VariantKind::StructVariantKind(ref struct_def) => {\n                 // TODO Should limit the width, as we have a trailing comma\n-                self.format_struct(\"\",\n-                                   field.node.name,\n-                                   field.node.vis,\n-                                   struct_def,\n-                                   None,\n-                                   field.span,\n-                                   self.block_indent)\n+                let struct_rewrite = self.format_struct(\"\",\n+                                                        field.node.name,\n+                                                        field.node.vis,\n+                                                        struct_def,\n+                                                        None,\n+                                                        field.span,\n+                                                        self.block_indent);\n+\n+                match struct_rewrite {\n+                    Some(struct_str) => struct_str,\n+                    None => return,\n+                }\n             }\n         };\n         self.buffer.push_str(&result);\n@@ -580,15 +593,15 @@ impl<'a> FmtVisitor<'a> {\n                      generics: Option<&ast::Generics>,\n                      span: Span,\n                      offset: usize)\n-                     -> String {\n+                     -> Option<String> {\n         let mut result = String::with_capacity(1024);\n \n         let header_str = self.format_header(item_name, ident, vis);\n         result.push_str(&header_str);\n \n         if struct_def.fields.is_empty() {\n             result.push(';');\n-            return result;\n+            return Some(result);\n         }\n \n         let is_tuple = match struct_def.fields[0].node.kind {\n@@ -603,12 +616,14 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         let generics_str = match generics {\n-            Some(g) => self.format_generics(g,\n-                                            opener,\n-                                            offset,\n-                                            offset + header_str.len(),\n-                                            codemap::mk_sp(span.lo,\n-                                                           struct_def.fields[0].span.lo)),\n+            Some(g) => {\n+                try_opt!(self.format_generics(g,\n+                                              opener,\n+                                              offset,\n+                                              offset + header_str.len(),\n+                                              codemap::mk_sp(span.lo,\n+                                                             struct_def.fields[0].span.lo)))\n+            }\n             None => opener.to_owned(),\n         };\n         result.push_str(&generics_str);\n@@ -658,8 +673,9 @@ impl<'a> FmtVisitor<'a> {\n             v_width: budget,\n             ends_with_newline: true,\n         };\n+        let list_str = write_list(&items.collect::<Vec<_>>(), &fmt).unwrap();\n \n-        result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n+        result.push_str(&list_str);\n \n         if break_line {\n             result.push('\\n');\n@@ -672,7 +688,7 @@ impl<'a> FmtVisitor<'a> {\n             result.push(';');\n         }\n \n-        result\n+        Some(result)\n     }\n \n     pub fn visit_struct(&mut self,\n@@ -688,7 +704,9 @@ impl<'a> FmtVisitor<'a> {\n                                         struct_def,\n                                         Some(generics),\n                                         span,\n-                                        indent);\n+                                        indent)\n+                         .unwrap();\n+\n         self.buffer.push_str(&result);\n         self.last_pos = span.hi;\n     }\n@@ -703,23 +721,24 @@ impl<'a> FmtVisitor<'a> {\n                        offset: usize,\n                        generics_offset: usize,\n                        span: Span)\n-                       -> String {\n-        let mut result = self.rewrite_generics(generics, offset, generics_offset, span);\n+                       -> Option<String> {\n+        let mut result = try_opt!(self.rewrite_generics(generics, offset, generics_offset, span));\n \n         if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-            result.push_str(&self.rewrite_where_clause(&generics.where_clause,\n-                                                       self.config,\n-                                                       self.block_indent,\n-                                                       Density::Tall,\n-                                                       span.hi));\n+            let where_clause_str = try_opt!(self.rewrite_where_clause(&generics.where_clause,\n+                                                                      self.config,\n+                                                                      self.block_indent,\n+                                                                      Density::Tall,\n+                                                                      span.hi));\n+            result.push_str(&where_clause_str);\n             result.push_str(&make_indent(self.block_indent));\n             result.push('\\n');\n             result.push_str(opener.trim());\n         } else {\n             result.push_str(opener);\n         }\n \n-        result\n+        Some(result)\n     }\n \n     // Field of a struct\n@@ -761,13 +780,13 @@ impl<'a> FmtVisitor<'a> {\n                         offset: usize,\n                         generics_offset: usize,\n                         span: Span)\n-                        -> String {\n+                        -> Option<String> {\n         // FIXME convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n         let lifetimes: &[_] = &generics.lifetimes;\n         let tys: &[_] = &generics.ty_params;\n         if lifetimes.is_empty() && tys.is_empty() {\n-            return String::new();\n+            return Some(String::new());\n         }\n \n         let offset = match self.config.generics_indent {\n@@ -816,8 +835,9 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let fmt = ListFormatting::for_fn(h_budget, offset);\n+        let list_str = try_opt!(write_list(&items, &fmt));\n \n-        format!(\"<{}>\", write_list(&items, &fmt))\n+        Some(format!(\"<{}>\", list_str))\n     }\n \n     fn rewrite_where_clause(&self,\n@@ -826,9 +846,9 @@ impl<'a> FmtVisitor<'a> {\n                             indent: usize,\n                             density: Density,\n                             span_end: BytePos)\n-                            -> String {\n+                            -> Option<String> {\n         if where_clause.predicates.is_empty() {\n-            return String::new();\n+            return Some(String::new());\n         }\n \n         let extra_indent = match self.config.where_indent {\n@@ -870,16 +890,16 @@ impl<'a> FmtVisitor<'a> {\n             v_width: budget,\n             ends_with_newline: true,\n         };\n-        let preds_str = write_list(&items.collect::<Vec<_>>(), &fmt);\n+        let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||\n            indent + 9 + preds_str.len() > self.config.max_width {\n-            format!(\"\\n{}where {}\",\n-                    make_indent(indent + extra_indent),\n-                    preds_str)\n+            Some(format!(\"\\n{}where {}\",\n+                         make_indent(indent + extra_indent),\n+                         preds_str))\n         } else {\n-            format!(\" where {}\", preds_str)\n+            Some(format!(\" where {}\", preds_str))\n         }\n     }\n "}, {"sha": "e21327631d443d84ad9cd842856f7acbe6836422", "filename": "src/lists.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -13,7 +13,7 @@ use std::iter::Peekable;\n \n use syntax::codemap::{self, CodeMap, BytePos};\n \n-use utils::{round_up_to_power_of_two, make_indent};\n+use utils::{round_up_to_power_of_two, make_indent, wrap_str};\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n@@ -95,9 +95,9 @@ impl ListItem {\n // Format a list of commented items into a string.\n // FIXME: this has grown into a monstrosity\n // TODO: add unit tests\n-pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> String {\n+pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Option<String> {\n     if items.is_empty() {\n-        return String::new();\n+        return Some(String::new());\n     }\n \n     let mut tactic = formatting.tactic;\n@@ -204,7 +204,9 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n             }\n         }\n \n-        result.push_str(&item.item);\n+        // FIXME: no magic numbers!\n+        let item_str = wrap_str(&item.item[..], 100, formatting.v_width, formatting.indent);\n+        result.push_str(&&try_opt!(item_str));\n \n         // Post-comments\n         if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n@@ -240,7 +242,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n         }\n     }\n \n-    result\n+    Some(result)\n }\n \n pub struct ListItems<'a, I, F1, F2, F3>"}, {"sha": "58bb930510ce130cc137d5f9732ad97d3852b85d", "filename": "src/types.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -87,6 +87,12 @@ fn rewrite_path_segments<'a, I>(mut buffer: String,\n     let mut first = true;\n \n     for segment in iter {\n+        if first {\n+            first = false;\n+        } else {\n+            buffer.push_str(\"::\");\n+        }\n+\n         let extra_offset = extra_offset(&buffer, offset);\n         let remaining_width = try_opt!(width.checked_sub(extra_offset));\n         let new_offset = offset + extra_offset;\n@@ -97,12 +103,6 @@ fn rewrite_path_segments<'a, I>(mut buffer: String,\n                                                       remaining_width,\n                                                       new_offset));\n \n-        if first {\n-            first = false;\n-        } else {\n-            buffer.push_str(\"::\");\n-        }\n-\n         buffer.push_str(&segment_string);\n     }\n \n@@ -218,18 +218,20 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \">\",\n                                      |param| param.get_span().lo,\n                                      |param| param.get_span().hi,\n+                                     // FIXME: need better params\n                                      |seg| {\n-                                         seg.rewrite(context, list_width, offset + extra_offset).unwrap()\n+                                         seg.rewrite(context, 1000, offset + extra_offset).unwrap()\n                                      },\n                                      list_lo,\n                                      span_hi);\n \n             let fmt = ListFormatting::for_fn(list_width, offset + extra_offset);\n+            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             // update pos\n             *span_lo = next_span_lo;\n \n-            format!(\"{}<{}>\", separator, write_list(&items.collect::<Vec<_>>(), &fmt))\n+            format!(\"{}<{}>\", separator, list_str)\n         }\n         ast::PathParameters::ParenthesizedParameters(ref data) => {\n             let output = match data.output {\n@@ -252,11 +254,12 @@ fn rewrite_segment(segment: &ast::PathSegment,\n \n             // 1 for (\n             let fmt = ListFormatting::for_fn(budget, offset + 1);\n+            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             // update pos\n             *span_lo = data.span.hi + BytePos(1);\n \n-            format!(\"({}){}\", write_list(&items.collect::<Vec<_>>(), &fmt), output)\n+            format!(\"({}){}\", list_str, output)\n         }\n         _ => String::new(),\n     };\n@@ -354,7 +357,8 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        let strs: Vec<_> = self.iter().map(|b| b.rewrite(context, width, offset).unwrap()).collect();\n+        let strs: Vec<_> =\n+            self.iter().map(|b| b.rewrite(context, width, offset).unwrap()).collect();\n         Some(strs.join(\" + \"))\n     }\n }"}, {"sha": "07807bf31aae0b84a1b5b86b06f836ff66c91cf5", "filename": "src/utils.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -164,6 +164,38 @@ macro_rules! try_opt {\n     })\n }\n \n+pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usize) -> Option<S> {\n+    let snippet = s.as_ref();\n+\n+    if !snippet.contains('\\n') && snippet.len() > width {\n+        return None;\n+    } else {\n+        let mut lines = snippet.lines();\n+\n+        // The caller of this function has already placed `offset`\n+        // characters on the first line.\n+        let first_line_max_len = try_opt!(max_width.checked_sub(offset));\n+        if lines.next().unwrap().len() > first_line_max_len {\n+            return None;\n+        }\n+\n+        // The other lines must fit within the maximum width.\n+        if lines.find(|line| line.len() > max_width).is_some() {\n+            return None;\n+        }\n+\n+        // `width` is the maximum length of the last line, excluding\n+        // indentation.\n+        // A special check for the last line, since the caller may\n+        // place trailing characters on this line.\n+        if snippet.lines().rev().next().unwrap().len() > offset + width {\n+            return None;\n+        }\n+    }\n+\n+    Some(s)\n+}\n+\n #[test]\n fn power_rounding() {\n     assert_eq!(0, round_up_to_power_of_two(0));"}, {"sha": "c1c1f2fcbbd245b6b123e6ded45e115038c393dd", "filename": "src/visitor.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         // Check if this block has braces.\n         let snippet = self.snippet(b.span);\n-        let has_braces = snippet.chars().next().unwrap() == '{' || &snippet[..6] == \"unsafe\";\n+        let has_braces = &snippet[..1] == \"{\" || &snippet[..6] == \"unsafe\";\n         let brace_compensation = if has_braces {\n             BytePos(1)\n         } else {\n@@ -125,43 +125,45 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 _: ast::NodeId) {\n-        self.format_missing_with_indent(s.lo);\n-        self.last_pos = s.lo;\n-\n         let indent = self.block_indent;\n-        match fk {\n+        let rewrite = match fk {\n             visit::FnKind::ItemFn(ident,\n-                            ref generics,\n-                            ref unsafety,\n-                            ref constness,\n-                            ref abi,\n-                            vis) => {\n-                let new_fn = self.rewrite_fn(indent,\n-                                             ident,\n-                                             fd,\n-                                             None,\n-                                             generics,\n-                                             unsafety,\n-                                             constness,\n-                                             abi,\n-                                             vis,\n-                                             codemap::mk_sp(s.lo, b.span.lo));\n-                self.buffer.push_str(&new_fn);\n+                                  ref generics,\n+                                  ref unsafety,\n+                                  ref constness,\n+                                  ref abi,\n+                                  vis) => {\n+                self.rewrite_fn(indent,\n+                                ident,\n+                                fd,\n+                                None,\n+                                generics,\n+                                unsafety,\n+                                constness,\n+                                abi,\n+                                vis,\n+                                codemap::mk_sp(s.lo, b.span.lo))\n             }\n             visit::FnKind::Method(ident, ref sig, vis) => {\n-                let new_fn = self.rewrite_fn(indent,\n-                                             ident,\n-                                             fd,\n-                                             Some(&sig.explicit_self),\n-                                             &sig.generics,\n-                                             &sig.unsafety,\n-                                             &sig.constness,\n-                                             &sig.abi,\n-                                             vis.unwrap_or(ast::Visibility::Inherited),\n-                                             codemap::mk_sp(s.lo, b.span.lo));\n-                self.buffer.push_str(&new_fn);\n+                self.rewrite_fn(indent,\n+                                ident,\n+                                fd,\n+                                Some(&sig.explicit_self),\n+                                &sig.generics,\n+                                &sig.unsafety,\n+                                &sig.constness,\n+                                &sig.abi,\n+                                vis.unwrap_or(ast::Visibility::Inherited),\n+                                codemap::mk_sp(s.lo, b.span.lo))\n             }\n-            visit::FnKind::Closure => {}\n+            visit::FnKind::Closure => None,\n+        };\n+\n+        if let Some(fn_str) = rewrite {\n+            self.format_missing_with_indent(s.lo);\n+            self.buffer.push_str(&fn_str);\n+        } else {\n+            self.format_missing(b.span.lo);\n         }\n \n         self.last_pos = b.span.lo;\n@@ -239,8 +241,11 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                                   sig,\n                                                   ti.span);\n \n-            self.buffer.push_str(&new_fn);\n-            self.last_pos = ti.span.hi;\n+\n+            if let Some(fn_str) = new_fn {\n+                self.buffer.push_str(&fn_str);\n+                self.last_pos = ti.span.hi;\n+            }\n         }\n         // TODO format trait types\n "}, {"sha": "92380ea51b0c0dcbbd1a1d0458bb11b54402d501", "filename": "tests/source/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Fsource%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Fsource%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -2,8 +2,8 @@\n \n // Long import.\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n-use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n-                                                                                                ItemB};\n+use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA, ItemB};\n+use exceedingly::loooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA, ItemB};\n \n use list::{\n     // Some item"}, {"sha": "9a5513e1589a0cf2bee024c0798a75752ed62e23", "filename": "tests/source/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -1,6 +1,5 @@\n \n fn main() {\n-    // FIXME(#133): the list rewrite should fail and force a different format\n    let constellation_chan = Constellation::<layout::layout_task::LayoutTask,  script::script_task::ScriptTask> ::start(\n      compositor_proxy,\n      resource_task,"}, {"sha": "07449a5198204df2021d9cfc3253e27f76dfcc62", "filename": "tests/target/imports.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -2,8 +2,9 @@\n \n // Long import.\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n-use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n-                                                                                                ItemB};\n+use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA, ItemB};\n+use exceedingly::loooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n+                                                                                             ItemB};\n \n use list::{// Some item\n            SomeItem, // Comment"}, {"sha": "fd97bb4d71c3592a419a118554883892ef61dfb7", "filename": "tests/target/paths.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -1,16 +1,16 @@\n \n fn main() {\n-    // FIXME(#133): the list rewrite should fail and force a different format\n-    let constellation_chan = Constellation::<layout::layout_task::LayoutTask,\n-                                             script::script_task::ScriptTask>::start(compositor_proxy,\n-                                                                                     resource_task,\n-                                                                                     image_cache_task,\n-                                                                                     font_cache_task,\n-                                                                                     time_profiler_chan,\n-                                                                                     mem_profiler_chan,\n-                                                                                     devtools_chan,\n-                                                                                     storage_task,\n-                                                                                     supports_clipboard);\n+    let constellation_chan =\n+        Constellation::<layout::layout_task::LayoutTask,\n+                        script::script_task::ScriptTask>::start(compositor_proxy,\n+                                                                resource_task,\n+                                                                image_cache_task,\n+                                                                font_cache_task,\n+                                                                time_profiler_chan,\n+                                                                mem_profiler_chan,\n+                                                                devtools_chan,\n+                                                                storage_task,\n+                                                                supports_clipboard);\n \n     Quux::<ParamOne /* Comment 1 */, ParamTwo /* Comment 2 */>::some_func();\n "}, {"sha": "a5bcc7f701a717d71dd4ae510757e7647d946fa2", "filename": "tests/target/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278/tests%2Ftarget%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftuple.rs?ref=d05a41c7738fcdaa91510ba9ab0e1cfbe9dea278", "patch": "@@ -4,7 +4,7 @@ fn foo() {\n     let a = (a, a, a, a, a);\n     let aaaaaaaaaaaaaaaa = (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaa, aaaaaaaaaaaaaa);\n     let aaaaaaaaaaaaaaaaaaaaaa = (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n-                                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+                                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n                                   aaaaaaaaaaaaaaaaaaaaaaaaa,\n                                   aaaa);\n     let a = (a,);"}]}