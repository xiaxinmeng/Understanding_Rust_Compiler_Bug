{"sha": "4b46c700f4bf04331b1858e7fe3c363c0451c4cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNDZjNzAwZjRiZjA0MzMxYjE4NThlN2ZlM2MzNjNjMDQ1MWM0Y2I=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-26T23:49:13Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-28T05:08:57Z"}, "message": "hygiene for match-bound vars now implemented\n\nCloses #9384", "tree": {"sha": "2acbb41587d95589da4616d31776f7bbf59ac24b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2acbb41587d95589da4616d31776f7bbf59ac24b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b46c700f4bf04331b1858e7fe3c363c0451c4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b46c700f4bf04331b1858e7fe3c363c0451c4cb", "html_url": "https://github.com/rust-lang/rust/commit/4b46c700f4bf04331b1858e7fe3c363c0451c4cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b46c700f4bf04331b1858e7fe3c363c0451c4cb/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bad96e742b187b671500702bccb37ab1724bae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bad96e742b187b671500702bccb37ab1724bae5", "html_url": "https://github.com/rust-lang/rust/commit/7bad96e742b187b671500702bccb37ab1724bae5"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "c2bb2cd7347379c7a5725669f0474c548ffa4a36", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4b46c700f4bf04331b1858e7fe3c363c0451c4cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b46c700f4bf04331b1858e7fe3c363c0451c4cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4b46c700f4bf04331b1858e7fe3c363c0451c4cb", "patch": "@@ -608,7 +608,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                         span: span,\n                         source: source,\n                     } = **local;\n-                    // expand the pat (it might contain exprs... #:(o)>\n+                    // expand the pat (it might contain macro uses):\n                     let expanded_pat = fld.fold_pat(pat);\n                     // find the pat_idents in the pattern:\n                     // oh dear heaven... this is going to include the enum\n@@ -618,11 +618,11 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     let idents = pattern_bindings(expanded_pat);\n                     let mut new_pending_renames =\n                         idents.iter().map(|ident| (*ident, fresh_name(ident))).collect();\n+                    // rewrite the pattern using the new names (the old\n+                    // ones have already been applied):\n                     let rewritten_pat = {\n-                        let mut rename_fld =\n-                            IdentRenamer{renames: &mut new_pending_renames};\n-                        // rewrite the pattern using the new names (the old\n-                        // ones have already been applied):\n+                        // nested binding to allow borrow to expire:\n+                        let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n@@ -655,31 +655,38 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n }\n \n fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n-    if arm.pats.len() == 0 {\n+    // expand pats... they might contain macro uses:\n+    let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();\n+    if expanded_pats.len() == 0 {\n         fail!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let first_pat = arm.pats.get(0);\n+    let first_pat = expanded_pats.get(0);\n     // code duplicated from 'let', above. Perhaps this can be lifted\n     // into a separate function:\n-    let expanded_pat = fld.fold_pat(*first_pat);\n-    let mut new_pending_renames = Vec::new();\n-    for ident in pattern_bindings(expanded_pat).iter() {\n-        let new_name = fresh_name(ident);\n-        new_pending_renames.push((*ident,new_name));\n-    }\n-    let rewritten_pat = {\n-        let mut rename_fld = IdentRenamer{renames:&mut new_pending_renames};\n-        // rewrite the pattern using the new names (the old\n-        // ones have already been applied):\n-        rename_fld.fold_pat(expanded_pat)\n-    };\n+    let idents = pattern_bindings(*first_pat);\n+    let mut new_pending_renames =\n+        idents.iter().map(|id| (*id,fresh_name(id))).collect();\n+    // rewrite all of the patterns using the new names (the old\n+    // ones have already been applied). Note that we depend here\n+    // on the guarantee that after expansion, there can't be any\n+    // Path expressions (a.k.a. varrefs) left in the pattern. If\n+    // this were false, we'd need to apply this renaming only to\n+    // the bindings, and not to the varrefs, using a more targeted\n+    // fold-er.\n+    let mut rename_fld = IdentRenamer{renames:&mut new_pending_renames};\n+    let rewritten_pats =\n+        expanded_pats.iter().map(|pat| rename_fld.fold_pat(*pat)).collect();\n+    // apply renaming and then expansion to the guard and the body:\n+    let rewritten_guard =\n+        arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n+    let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n     ast::Arm {\n         attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n-        pats: arm.pats.iter().map(|x| fld.fold_pat(*x)).collect(),\n-        guard: arm.guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(arm.body),\n+        pats: rewritten_pats,\n+        guard: rewritten_guard,\n+        body: rewritten_body,\n     }    \n }\n \n@@ -851,6 +858,8 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n }\n \n // a tree-folder that applies every rename in its (mutable) list\n+// to every identifier, including both bindings and varrefs\n+// (and lots of things that will turn out to be neither)\n pub struct IdentRenamer<'a> {\n     renames: &'a mut RenameList,\n }\n@@ -1335,8 +1344,8 @@ mod test {\n                                                      invalid_name);\n                     if !(varref_name==binding_name) {\n                         println!(\"uh oh, should match but doesn't:\");\n-                        println!(\"varref: {:?}\",varref);\n-                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n+                        println!(\"varref #{:?}: {:?}\",idx, varref);\n+                        println!(\"binding #{:?}: {:?}\", binding_idx, *bindings.get(binding_idx));\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert_eq!(varref_name,binding_name);"}]}