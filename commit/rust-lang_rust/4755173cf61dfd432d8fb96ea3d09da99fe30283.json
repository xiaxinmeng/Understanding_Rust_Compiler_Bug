{"sha": "4755173cf61dfd432d8fb96ea3d09da99fe30283", "node_id": "C_kwDOAAsO6NoAKDQ3NTUxNzNjZjYxZGZkNDMyZDhmYjk2ZWEzZDA5ZGE5OWZlMzAyODM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-07-06T18:43:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-06T18:43:23Z"}, "message": "Rollup merge of #96935 - thomcc:atomicptr-strict-prov, r=dtolnay\n\nAllow arithmetic and certain bitwise ops on AtomicPtr\n\nThis is mainly to support migrating from `AtomicUsize`, for the strict provenance experiment.\n\nThis is a pretty dubious set of APIs, but it should be sufficient to allow code that's using `AtomicUsize` to manipulate a tagged pointer atomically. It's under a new feature gate, `#![feature(strict_provenance_atomic_ptr)]`, but I'm not sure if it needs its own tracking issue. I'm happy to make one, but it's not clear that it's needed.\n\nI'm unsure if it needs changes in the various non-LLVM backends. Because we just cast things to integers anyway (and were already doing so), I doubt it.\n\nAPI change proposal: https://github.com/rust-lang/libs-team/issues/60\n\nFixes #95492", "tree": {"sha": "a22f929eb63cecca112b3003f5968dc7c476f8cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a22f929eb63cecca112b3003f5968dc7c476f8cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4755173cf61dfd432d8fb96ea3d09da99fe30283", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixdfMCRBK7hj4Ov3rIwAA4R4IACp8kwwxGeym36CzjKcb1xRT\nACf4dOAWIRXGzQCd3SQ3KWVLa4Ot0MYD5XA3sFI1mRZmH/dW1/qmwCW5OTPE5F2s\nSzTvL299pP1mX81mAPPooYmxOE/mtXzdq5A3thPf7jXUpzJrlJRAhbMGIQbKMxjl\nYgUFRxM1N0dg6KNuQsp4ns/z50BMucX5PcRCHg73VqoNO/qaBaiDEdtZyfHBI2We\ns+DLsR5Gn2r6OACx5Dedk0jDeM6YCbIRppDUvwrcBPc5J9m7k03mxK6oWJ0XJuDk\nDx8RRxrt8lEM2lPIUIuJrQaUSvujzVyLIMQ0qZxb4Q53I9HACiOdb3ptrUkSIJQ=\n=nc9f\n-----END PGP SIGNATURE-----\n", "payload": "tree a22f929eb63cecca112b3003f5968dc7c476f8cd\nparent 049308cf8b48e9d67e54d6d0b01c10c79d1efc3a\nparent e65ecee90eff2c90e12164417cc31ab959c321cf\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1657133003 +0200\ncommitter GitHub <noreply@github.com> 1657133003 +0200\n\nRollup merge of #96935 - thomcc:atomicptr-strict-prov, r=dtolnay\n\nAllow arithmetic and certain bitwise ops on AtomicPtr\n\nThis is mainly to support migrating from `AtomicUsize`, for the strict provenance experiment.\n\nThis is a pretty dubious set of APIs, but it should be sufficient to allow code that's using `AtomicUsize` to manipulate a tagged pointer atomically. It's under a new feature gate, `#![feature(strict_provenance_atomic_ptr)]`, but I'm not sure if it needs its own tracking issue. I'm happy to make one, but it's not clear that it's needed.\n\nI'm unsure if it needs changes in the various non-LLVM backends. Because we just cast things to integers anyway (and were already doing so), I doubt it.\n\nAPI change proposal: https://github.com/rust-lang/libs-team/issues/60\n\nFixes #95492\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4755173cf61dfd432d8fb96ea3d09da99fe30283", "html_url": "https://github.com/rust-lang/rust/commit/4755173cf61dfd432d8fb96ea3d09da99fe30283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4755173cf61dfd432d8fb96ea3d09da99fe30283/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "049308cf8b48e9d67e54d6d0b01c10c79d1efc3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/049308cf8b48e9d67e54d6d0b01c10c79d1efc3a", "html_url": "https://github.com/rust-lang/rust/commit/049308cf8b48e9d67e54d6d0b01c10c79d1efc3a"}, {"sha": "e65ecee90eff2c90e12164417cc31ab959c321cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65ecee90eff2c90e12164417cc31ab959c321cf", "html_url": "https://github.com/rust-lang/rust/commit/e65ecee90eff2c90e12164417cc31ab959c321cf"}], "stats": {"total": 431, "additions": 428, "deletions": 3}, "files": [{"sha": "645afae30d88729b518c338f656330a0670f84bd", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4755173cf61dfd432d8fb96ea3d09da99fe30283/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4755173cf61dfd432d8fb96ea3d09da99fe30283/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=4755173cf61dfd432d8fb96ea3d09da99fe30283", "patch": "@@ -513,9 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         };\n \n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some()\n-                            || (ty.is_unsafe_ptr() && op == \"xchg\")\n-                        {\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n                             let mut ptr = args[0].immediate();\n                             let mut val = args[1].immediate();\n                             if ty.is_unsafe_ptr() {"}, {"sha": "bf8ce6971b87e12bc1477cf3bb6251b0834ae5ad", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=4755173cf61dfd432d8fb96ea3d09da99fe30283", "patch": "@@ -1451,6 +1451,347 @@ impl<T> AtomicPtr<T> {\n         }\n         Err(prev)\n     }\n+\n+    /// Offsets the pointer's address by adding `val` (in units of `T`),\n+    /// returning the previous pointer.\n+    ///\n+    /// This is equivalent to using [`wrapping_add`] to atomically perform the\n+    /// equivalent of `ptr = ptr.wrapping_add(val);`.\n+    ///\n+    /// This method operates in units of `T`, which means that it cannot be used\n+    /// to offset the pointer by an amount which is not a multiple of\n+    /// `size_of::<T>()`. This can sometimes be inconvenient, as you may want to\n+    /// work with a deliberately misaligned pointer. In such cases, you may use\n+    /// the [`fetch_byte_add`](Self::fetch_byte_add) method instead.\n+    ///\n+    /// `fetch_ptr_add` takes an [`Ordering`] argument which describes the\n+    /// memory ordering of this operation. All ordering modes are possible. Note\n+    /// that using [`Acquire`] makes the store part of this operation\n+    /// [`Relaxed`], and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// [`wrapping_add`]: pointer::wrapping_add\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let atom = AtomicPtr::<i64>::new(core::ptr::null_mut());\n+    /// assert_eq!(atom.fetch_ptr_add(1, Ordering::Relaxed).addr(), 0);\n+    /// // Note: units of `size_of::<i64>()`.\n+    /// assert_eq!(atom.load(Ordering::Relaxed).addr(), 8);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_ptr_add(&self, val: usize, order: Ordering) -> *mut T {\n+        self.fetch_byte_add(val.wrapping_mul(core::mem::size_of::<T>()), order)\n+    }\n+\n+    /// Offsets the pointer's address by subtracting `val` (in units of `T`),\n+    /// returning the previous pointer.\n+    ///\n+    /// This is equivalent to using [`wrapping_sub`] to atomically perform the\n+    /// equivalent of `ptr = ptr.wrapping_sub(val);`.\n+    ///\n+    /// This method operates in units of `T`, which means that it cannot be used\n+    /// to offset the pointer by an amount which is not a multiple of\n+    /// `size_of::<T>()`. This can sometimes be inconvenient, as you may want to\n+    /// work with a deliberately misaligned pointer. In such cases, you may use\n+    /// the [`fetch_byte_sub`](Self::fetch_byte_sub) method instead.\n+    ///\n+    /// `fetch_ptr_sub` takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation. All ordering modes are possible. Note that\n+    /// using [`Acquire`] makes the store part of this operation [`Relaxed`],\n+    /// and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// [`wrapping_sub`]: pointer::wrapping_sub\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let array = [1i32, 2i32];\n+    /// let atom = AtomicPtr::new(array.as_ptr().wrapping_add(1) as *mut _);\n+    ///\n+    /// assert!(core::ptr::eq(\n+    ///     atom.fetch_ptr_sub(1, Ordering::Relaxed),\n+    ///     &array[1],\n+    /// ));\n+    /// assert!(core::ptr::eq(atom.load(Ordering::Relaxed), &array[0]));\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_ptr_sub(&self, val: usize, order: Ordering) -> *mut T {\n+        self.fetch_byte_sub(val.wrapping_mul(core::mem::size_of::<T>()), order)\n+    }\n+\n+    /// Offsets the pointer's address by adding `val` *bytes*, returning the\n+    /// previous pointer.\n+    ///\n+    /// This is equivalent to using [`wrapping_add`] and [`cast`] to atomically\n+    /// perform `ptr = ptr.cast::<u8>().wrapping_add(val).cast::<T>()`.\n+    ///\n+    /// `fetch_byte_add` takes an [`Ordering`] argument which describes the\n+    /// memory ordering of this operation. All ordering modes are possible. Note\n+    /// that using [`Acquire`] makes the store part of this operation\n+    /// [`Relaxed`], and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// [`wrapping_add`]: pointer::wrapping_add\n+    /// [`cast`]: pointer::cast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let atom = AtomicPtr::<i64>::new(core::ptr::null_mut());\n+    /// assert_eq!(atom.fetch_byte_add(1, Ordering::Relaxed).addr(), 0);\n+    /// // Note: in units of bytes, not `size_of::<i64>()`.\n+    /// assert_eq!(atom.load(Ordering::Relaxed).addr(), 1);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_byte_add(&self, val: usize, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_add(self.p.get(), core::ptr::invalid_mut(val), order).cast()\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_add(self.p.get().cast::<usize>(), val, order) as *mut T\n+        }\n+    }\n+\n+    /// Offsets the pointer's address by subtracting `val` *bytes*, returning the\n+    /// previous pointer.\n+    ///\n+    /// This is equivalent to using [`wrapping_sub`] and [`cast`] to atomically\n+    /// perform `ptr = ptr.cast::<u8>().wrapping_sub(val).cast::<T>()`.\n+    ///\n+    /// `fetch_byte_sub` takes an [`Ordering`] argument which describes the\n+    /// memory ordering of this operation. All ordering modes are possible. Note\n+    /// that using [`Acquire`] makes the store part of this operation\n+    /// [`Relaxed`], and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// [`wrapping_sub`]: pointer::wrapping_sub\n+    /// [`cast`]: pointer::cast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let atom = AtomicPtr::<i64>::new(core::ptr::invalid_mut(1));\n+    /// assert_eq!(atom.fetch_byte_sub(1, Ordering::Relaxed).addr(), 1);\n+    /// assert_eq!(atom.load(Ordering::Relaxed).addr(), 0);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_byte_sub(&self, val: usize, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_sub(self.p.get(), core::ptr::invalid_mut(val), order).cast()\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_sub(self.p.get().cast::<usize>(), val, order) as *mut T\n+        }\n+    }\n+\n+    /// Performs a bitwise \"or\" operation on the address of the current pointer,\n+    /// and the argument `val`, and stores a pointer with provenance of the\n+    /// current pointer and the resulting address.\n+    ///\n+    /// This is equivalent equivalent to using [`map_addr`] to atomically\n+    /// perform `ptr = ptr.map_addr(|a| a | val)`. This can be used in tagged\n+    /// pointer schemes to atomically set tag bits.\n+    ///\n+    /// **Caveat**: This operation returns the previous value. To compute the\n+    /// stored value without losing provenance, you may use [`map_addr`]. For\n+    /// example: `a.fetch_or(val).map_addr(|a| a | val)`.\n+    ///\n+    /// `fetch_or` takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation. All ordering modes are possible. Note that\n+    /// using [`Acquire`] makes the store part of this operation [`Relaxed`],\n+    /// and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance\n+    /// experiment, see the [module documentation for `ptr`][crate::ptr] for\n+    /// details.\n+    ///\n+    /// [`map_addr`]: pointer::map_addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let pointer = &mut 3i64 as *mut i64;\n+    ///\n+    /// let atom = AtomicPtr::<i64>::new(pointer);\n+    /// // Tag the bottom bit of the pointer.\n+    /// assert_eq!(atom.fetch_or(1, Ordering::Relaxed).addr() & 1, 0);\n+    /// // Extract and untag.\n+    /// let tagged = atom.load(Ordering::Relaxed);\n+    /// assert_eq!(tagged.addr() & 1, 1);\n+    /// assert_eq!(tagged.map_addr(|p| p & !1), pointer);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_or(&self, val: usize, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_or(self.p.get(), core::ptr::invalid_mut(val), order).cast()\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_or(self.p.get().cast::<usize>(), val, order) as *mut T\n+        }\n+    }\n+\n+    /// Performs a bitwise \"and\" operation on the address of the current\n+    /// pointer, and the argument `val`, and stores a pointer with provenance of\n+    /// the current pointer and the resulting address.\n+    ///\n+    /// This is equivalent equivalent to using [`map_addr`] to atomically\n+    /// perform `ptr = ptr.map_addr(|a| a & val)`. This can be used in tagged\n+    /// pointer schemes to atomically unset tag bits.\n+    ///\n+    /// **Caveat**: This operation returns the previous value. To compute the\n+    /// stored value without losing provenance, you may use [`map_addr`]. For\n+    /// example: `a.fetch_and(val).map_addr(|a| a & val)`.\n+    ///\n+    /// `fetch_and` takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation. All ordering modes are possible. Note that\n+    /// using [`Acquire`] makes the store part of this operation [`Relaxed`],\n+    /// and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance\n+    /// experiment, see the [module documentation for `ptr`][crate::ptr] for\n+    /// details.\n+    ///\n+    /// [`map_addr`]: pointer::map_addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let pointer = &mut 3i64 as *mut i64;\n+    /// // A tagged pointer\n+    /// let atom = AtomicPtr::<i64>::new(pointer.map_addr(|a| a | 1));\n+    /// assert_eq!(atom.fetch_or(1, Ordering::Relaxed).addr() & 1, 1);\n+    /// // Untag, and extract the previously tagged pointer.\n+    /// let untagged = atom.fetch_and(!1, Ordering::Relaxed)\n+    ///     .map_addr(|a| a & !1);\n+    /// assert_eq!(untagged, pointer);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_and(&self, val: usize, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_and(self.p.get(), core::ptr::invalid_mut(val), order).cast()\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_and(self.p.get().cast::<usize>(), val, order) as *mut T\n+        }\n+    }\n+\n+    /// Performs a bitwise \"xor\" operation on the address of the current\n+    /// pointer, and the argument `val`, and stores a pointer with provenance of\n+    /// the current pointer and the resulting address.\n+    ///\n+    /// This is equivalent equivalent to using [`map_addr`] to atomically\n+    /// perform `ptr = ptr.map_addr(|a| a ^ val)`. This can be used in tagged\n+    /// pointer schemes to atomically toggle tag bits.\n+    ///\n+    /// **Caveat**: This operation returns the previous value. To compute the\n+    /// stored value without losing provenance, you may use [`map_addr`]. For\n+    /// example: `a.fetch_xor(val).map_addr(|a| a ^ val)`.\n+    ///\n+    /// `fetch_xor` takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation. All ordering modes are possible. Note that\n+    /// using [`Acquire`] makes the store part of this operation [`Relaxed`],\n+    /// and using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note**: This method is only available on platforms that support atomic\n+    /// operations on [`AtomicPtr`].\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance\n+    /// experiment, see the [module documentation for `ptr`][crate::ptr] for\n+    /// details.\n+    ///\n+    /// [`map_addr`]: pointer::map_addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(strict_provenance_atomic_ptr, strict_provenance)]\n+    /// use core::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let pointer = &mut 3i64 as *mut i64;\n+    /// let atom = AtomicPtr::<i64>::new(pointer);\n+    ///\n+    /// // Toggle a tag bit on the pointer.\n+    /// atom.fetch_xor(1, Ordering::Relaxed);\n+    /// assert_eq!(atom.load(Ordering::Relaxed).addr() & 1, 1);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"95228\")]\n+    pub fn fetch_xor(&self, val: usize, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_xor(self.p.get(), core::ptr::invalid_mut(val), order).cast()\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_xor(self.p.get().cast::<usize>(), val, order) as *mut T\n+        }\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"8\")]"}, {"sha": "13b12db209a76ea59415aafb61195d4b9543e376", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=4755173cf61dfd432d8fb96ea3d09da99fe30283", "patch": "@@ -127,6 +127,91 @@ fn int_max() {\n     assert_eq!(x.load(SeqCst), 0xf731);\n }\n \n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn ptr_add_null() {\n+    let atom = AtomicPtr::<i64>::new(core::ptr::null_mut());\n+    assert_eq!(atom.fetch_ptr_add(1, SeqCst).addr(), 0);\n+    assert_eq!(atom.load(SeqCst).addr(), 8);\n+\n+    assert_eq!(atom.fetch_byte_add(1, SeqCst).addr(), 8);\n+    assert_eq!(atom.load(SeqCst).addr(), 9);\n+\n+    assert_eq!(atom.fetch_ptr_sub(1, SeqCst).addr(), 9);\n+    assert_eq!(atom.load(SeqCst).addr(), 1);\n+\n+    assert_eq!(atom.fetch_byte_sub(1, SeqCst).addr(), 1);\n+    assert_eq!(atom.load(SeqCst).addr(), 0);\n+}\n+\n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn ptr_add_data() {\n+    let num = 0i64;\n+    let n = &num as *const i64 as *mut _;\n+    let atom = AtomicPtr::<i64>::new(n);\n+    assert_eq!(atom.fetch_ptr_add(1, SeqCst), n);\n+    assert_eq!(atom.load(SeqCst), n.wrapping_add(1));\n+\n+    assert_eq!(atom.fetch_ptr_sub(1, SeqCst), n.wrapping_add(1));\n+    assert_eq!(atom.load(SeqCst), n);\n+    let bytes_from_n = |b| n.cast::<u8>().wrapping_add(b).cast::<i64>();\n+\n+    assert_eq!(atom.fetch_byte_add(1, SeqCst), n);\n+    assert_eq!(atom.load(SeqCst), bytes_from_n(1));\n+\n+    assert_eq!(atom.fetch_byte_add(5, SeqCst), bytes_from_n(1));\n+    assert_eq!(atom.load(SeqCst), bytes_from_n(6));\n+\n+    assert_eq!(atom.fetch_byte_sub(1, SeqCst), bytes_from_n(6));\n+    assert_eq!(atom.load(SeqCst), bytes_from_n(5));\n+\n+    assert_eq!(atom.fetch_byte_sub(5, SeqCst), bytes_from_n(5));\n+    assert_eq!(atom.load(SeqCst), n);\n+}\n+\n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn ptr_bitops() {\n+    let atom = AtomicPtr::<i64>::new(core::ptr::null_mut());\n+    assert_eq!(atom.fetch_or(0b0111, SeqCst).addr(), 0);\n+    assert_eq!(atom.load(SeqCst).addr(), 0b0111);\n+\n+    assert_eq!(atom.fetch_and(0b1101, SeqCst).addr(), 0b0111);\n+    assert_eq!(atom.load(SeqCst).addr(), 0b0101);\n+\n+    assert_eq!(atom.fetch_xor(0b1111, SeqCst).addr(), 0b0101);\n+    assert_eq!(atom.load(SeqCst).addr(), 0b1010);\n+}\n+\n+#[test]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+fn ptr_bitops_tagging() {\n+    #[repr(align(16))]\n+    struct Tagme(u128);\n+\n+    let tagme = Tagme(1000);\n+    let ptr = &tagme as *const Tagme as *mut Tagme;\n+    let atom: AtomicPtr<Tagme> = AtomicPtr::new(ptr);\n+\n+    const MASK_TAG: usize = 0b1111;\n+    const MASK_PTR: usize = !MASK_TAG;\n+\n+    assert_eq!(ptr.addr() & MASK_TAG, 0);\n+\n+    assert_eq!(atom.fetch_or(0b0111, SeqCst), ptr);\n+    assert_eq!(atom.load(SeqCst), ptr.map_addr(|a| a | 0b111));\n+\n+    assert_eq!(atom.fetch_and(MASK_PTR | 0b0010, SeqCst), ptr.map_addr(|a| a | 0b111));\n+    assert_eq!(atom.load(SeqCst), ptr.map_addr(|a| a | 0b0010));\n+\n+    assert_eq!(atom.fetch_xor(0b1011, SeqCst), ptr.map_addr(|a| a | 0b0010));\n+    assert_eq!(atom.load(SeqCst), ptr.map_addr(|a| a | 0b1001));\n+\n+    assert_eq!(atom.fetch_and(MASK_PTR, SeqCst), ptr.map_addr(|a| a | 0b1001));\n+    assert_eq!(atom.load(SeqCst), ptr);\n+}\n+\n static S_FALSE: AtomicBool = AtomicBool::new(false);\n static S_TRUE: AtomicBool = AtomicBool::new(true);\n static S_INT: AtomicIsize = AtomicIsize::new(0);"}, {"sha": "fe89dd8c88d97614085f27468000ec72feabf503", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4755173cf61dfd432d8fb96ea3d09da99fe30283/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4755173cf61dfd432d8fb96ea3d09da99fe30283", "patch": "@@ -90,6 +90,7 @@\n #![feature(slice_group_by)]\n #![feature(split_array)]\n #![feature(strict_provenance)]\n+#![feature(strict_provenance_atomic_ptr)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n #![feature(unzip_option)]"}]}