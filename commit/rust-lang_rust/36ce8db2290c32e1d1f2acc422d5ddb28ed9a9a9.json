{"sha": "36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2Y2U4ZGIyMjkwYzMyZTFkMWYyYWNjNDIyZDVkZGIyOGVkOWE5YTk=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-01T10:50:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-01T10:50:16Z"}, "message": "Rollup merge of #79522 - ehuss:lint-check-validate, r=Mark-Simulacrum\n\nValidate lint docs separately.\n\nThis addresses some concerns raised in https://github.com/rust-lang/rust/pull/76549#issuecomment-727638552 about errors with the lint docs being confusing and cumbersome. Errors from validating the lint documentation were being generated during `x.py doc` (and `x.py dist`), since extraction and validation are being done in a single step. This changes it so that extraction and validation are separated, so that `x.py doc` will not error if there is a validation problem, and tests are moved to `x.py test src/tools/lint-docs`.\n\nThis includes the following changes:\n\n* Separate validation to `x.py test`.\n* Added some more documentation on how to more easily modify and test the docs.\n* Added more help to the error messages to hopefully provide more information on how to fix things.\n\nThe first commit just moves the code around, so you may consider looking at the other commits for a smaller diff.", "tree": {"sha": "b28d741cea9bff9c06eea361cc76e628abea6fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b28d741cea9bff9c06eea361cc76e628abea6fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfxh/pCRBK7hj4Ov3rIwAAdHIIAFDJFV82J7Xawfwv9T0UYPgR\nC754Iz5MTBBgeoe7nl1HaStFsk7dvKDk7gAhbOv20SoaimB0UeHZIq7yRCyMi0gP\nCQ0WgtEmcQYm93Pg06Ihvb1A8T44spW5qoTuuZKcFWZt6jLkBO3IojayuYkZR9/w\ncoyi1aWLF0nv8vc7KnCqtKg62YJxfhR/bG+IasewQTXo0ZatBOMlgsc0WcfIv+R3\nYcPbvbYtFBeDcejV6WR2LIF2AMl9Ikknji1uGiL8fVx23XAR5XH+X24u8VCzJyZg\nRQC01j+q+VVRsHctM1S1SGGBa7DYmYwJbwrxGdBTRkTxdoRmjeSCW+iGH6iQviA=\n=QBqM\n-----END PGP SIGNATURE-----\n", "payload": "tree b28d741cea9bff9c06eea361cc76e628abea6fcc\nparent 2404409c6c1db267fbf27c92b8ee23fafd97a377\nparent a90fdfc70178038599bfc7247aedc83bfe2e88f0\nauthor Mara Bos <m-ou.se@m-ou.se> 1606819816 +0000\ncommitter GitHub <noreply@github.com> 1606819816 +0000\n\nRollup merge of #79522 - ehuss:lint-check-validate, r=Mark-Simulacrum\n\nValidate lint docs separately.\n\nThis addresses some concerns raised in https://github.com/rust-lang/rust/pull/76549#issuecomment-727638552 about errors with the lint docs being confusing and cumbersome. Errors from validating the lint documentation were being generated during `x.py doc` (and `x.py dist`), since extraction and validation are being done in a single step. This changes it so that extraction and validation are separated, so that `x.py doc` will not error if there is a validation problem, and tests are moved to `x.py test src/tools/lint-docs`.\n\nThis includes the following changes:\n\n* Separate validation to `x.py test`.\n* Added some more documentation on how to more easily modify and test the docs.\n* Added more help to the error messages to hopefully provide more information on how to fix things.\n\nThe first commit just moves the code around, so you may consider looking at the other commits for a smaller diff.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "html_url": "https://github.com/rust-lang/rust/commit/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2404409c6c1db267fbf27c92b8ee23fafd97a377", "url": "https://api.github.com/repos/rust-lang/rust/commits/2404409c6c1db267fbf27c92b8ee23fafd97a377", "html_url": "https://github.com/rust-lang/rust/commit/2404409c6c1db267fbf27c92b8ee23fafd97a377"}, {"sha": "a90fdfc70178038599bfc7247aedc83bfe2e88f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a90fdfc70178038599bfc7247aedc83bfe2e88f0", "html_url": "https://github.com/rust-lang/rust/commit/a90fdfc70178038599bfc7247aedc83bfe2e88f0"}], "stats": {"total": 1055, "additions": 580, "deletions": 475}, "files": [{"sha": "aec0fc253ca5e4b5d059e5ce048342d2cb599507", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -366,11 +366,25 @@ impl LintBuffer {\n /// ```\n ///\n /// The `{{produces}}` tag will be automatically replaced with the output from\n-/// the example by the build system. You can build and view the rustc book\n-/// with `x.py doc --stage=1 src/doc/rustc --open`. If the lint example is too\n-/// complex to run as a simple example (for example, it needs an extern\n-/// crate), mark it with `ignore` and manually paste the expected output below\n-/// the example.\n+/// the example by the build system. If the lint example is too complex to run\n+/// as a simple example (for example, it needs an extern crate), mark the code\n+/// block with `ignore` and manually replace the `{{produces}}` line with the\n+/// expected output in a `text` code block.\n+///\n+/// If this is a rustdoc-only lint, then only include a brief introduction\n+/// with a link with the text `[rustdoc book]` so that the validator knows\n+/// that this is for rustdoc only (see BROKEN_INTRA_DOC_LINKS as an example).\n+///\n+/// Commands to view and test the documentation:\n+///\n+/// * `./x.py doc --stage=1 src/doc/rustc --open`: Builds the rustc book and opens it.\n+/// * `./x.py test src/tools/lint-docs`: Validates that the lint docs have the\n+///   correct style, and that the code example actually emits the expected\n+///   lint.\n+///\n+/// If you have already built the compiler, and you want to make changes to\n+/// just the doc comments, then use the `--keep-stage=0` flag with the above\n+/// commands to avoid rebuilding the compiler.\n #[macro_export]\n macro_rules! declare_lint {\n     ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr) => ("}, {"sha": "9336d7165ee75f93b3822958db6a57797b8f1dc1", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -413,6 +413,7 @@ impl<'a> Builder<'a> {\n                 test::TheBook,\n                 test::UnstableBook,\n                 test::RustcBook,\n+                test::LintDocs,\n                 test::RustcGuide,\n                 test::EmbeddedBook,\n                 test::EditionGuide,"}, {"sha": "bb0555c227d70c55ba9706ddf7d5466b8da3eb81", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -726,6 +726,7 @@ fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()>\n pub struct RustcBook {\n     pub compiler: Compiler,\n     pub target: TargetSelection,\n+    pub validate: bool,\n }\n \n impl Step for RustcBook {\n@@ -742,6 +743,7 @@ impl Step for RustcBook {\n         run.builder.ensure(RustcBook {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n+            validate: false,\n         });\n     }\n \n@@ -772,6 +774,9 @@ impl Step for RustcBook {\n         if builder.config.verbose() {\n             cmd.arg(\"--verbose\");\n         }\n+        if self.validate {\n+            cmd.arg(\"--validate\");\n+        }\n         // If the lib directories are in an unusual location (changed in\n         // config.toml), then this needs to explicitly update the dylib search\n         // path."}, {"sha": "611fecca0546bee1bdc35aed398f2b60abd8dfc3", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -2115,3 +2115,36 @@ impl Step for TierCheck {\n         try_run(builder, &mut cargo.into());\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct LintDocs {\n+    pub compiler: Compiler,\n+    pub target: TargetSelection,\n+}\n+\n+impl Step for LintDocs {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/lint-docs\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(LintDocs {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Tests that the lint examples in the rustc book generate the correct\n+    /// lints and have the expected format.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.ensure(crate::doc::RustcBook {\n+            compiler: self.compiler,\n+            target: self.target,\n+            validate: true,\n+        });\n+    }\n+}"}, {"sha": "0a69b18a3325413a4aa4b8642ca2e37152f3edb9", "filename": "src/tools/lint-docs/src/groups.rs", "status": "modified", "additions": 113, "deletions": 90, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -1,11 +1,11 @@\n-use crate::Lint;\n+use crate::{Lint, LintExtractor};\n use std::collections::{BTreeMap, BTreeSet};\n use std::error::Error;\n use std::fmt::Write;\n use std::fs;\n-use std::path::Path;\n use std::process::Command;\n \n+/// Descriptions of rustc lint groups.\n static GROUP_DESCRIPTIONS: &[(&str, &str)] = &[\n     (\"unused\", \"Lints that detect things being declared but not used, or excess syntax\"),\n     (\"rustdoc\", \"Rustdoc-specific lints\"),\n@@ -15,100 +15,123 @@ static GROUP_DESCRIPTIONS: &[(&str, &str)] = &[\n     (\"rust-2018-compatibility\", \"Lints used to transition code from the 2015 edition to 2018\"),\n ];\n \n-/// Updates the documentation of lint groups.\n-pub(crate) fn generate_group_docs(\n-    lints: &[Lint],\n-    rustc: crate::Rustc<'_>,\n-    out_path: &Path,\n-) -> Result<(), Box<dyn Error>> {\n-    let groups = collect_groups(rustc)?;\n-    let groups_path = out_path.join(\"groups.md\");\n-    let contents = fs::read_to_string(&groups_path)\n-        .map_err(|e| format!(\"could not read {}: {}\", groups_path.display(), e))?;\n-    let new_contents = contents.replace(\"{{groups-table}}\", &make_groups_table(lints, &groups)?);\n-    // Delete the output because rustbuild uses hard links in its copies.\n-    let _ = fs::remove_file(&groups_path);\n-    fs::write(&groups_path, new_contents)\n-        .map_err(|e| format!(\"could not write to {}: {}\", groups_path.display(), e))?;\n-    Ok(())\n-}\n-\n type LintGroups = BTreeMap<String, BTreeSet<String>>;\n \n-/// Collects the group names from rustc.\n-fn collect_groups(rustc: crate::Rustc<'_>) -> Result<LintGroups, Box<dyn Error>> {\n-    let mut result = BTreeMap::new();\n-    let mut cmd = Command::new(rustc.path);\n-    cmd.arg(\"-Whelp\");\n-    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n-    if !output.status.success() {\n-        return Err(format!(\n-            \"failed to collect lint info: {:?}\\n--- stderr\\n{}--- stdout\\n{}\\n\",\n-            output.status,\n-            std::str::from_utf8(&output.stderr).unwrap(),\n-            std::str::from_utf8(&output.stdout).unwrap(),\n-        )\n-        .into());\n+impl<'a> LintExtractor<'a> {\n+    /// Updates the documentation of lint groups.\n+    pub(crate) fn generate_group_docs(&self, lints: &[Lint]) -> Result<(), Box<dyn Error>> {\n+        let groups = self.collect_groups()?;\n+        let groups_path = self.out_path.join(\"groups.md\");\n+        let contents = fs::read_to_string(&groups_path)\n+            .map_err(|e| format!(\"could not read {}: {}\", groups_path.display(), e))?;\n+        let new_contents =\n+            contents.replace(\"{{groups-table}}\", &self.make_groups_table(lints, &groups)?);\n+        // Delete the output because rustbuild uses hard links in its copies.\n+        let _ = fs::remove_file(&groups_path);\n+        fs::write(&groups_path, new_contents)\n+            .map_err(|e| format!(\"could not write to {}: {}\", groups_path.display(), e))?;\n+        Ok(())\n     }\n-    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n-    let lines = stdout.lines();\n-    let group_start = lines.skip_while(|line| !line.contains(\"groups provided\")).skip(1);\n-    let table_start = group_start.skip_while(|line| !line.contains(\"----\")).skip(1);\n-    for line in table_start {\n-        if line.is_empty() {\n-            break;\n+\n+    /// Collects the group names from rustc.\n+    fn collect_groups(&self) -> Result<LintGroups, Box<dyn Error>> {\n+        let mut result = BTreeMap::new();\n+        let mut cmd = Command::new(self.rustc_path);\n+        cmd.arg(\"-Whelp\");\n+        let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+        if !output.status.success() {\n+            return Err(format!(\n+                \"failed to collect lint info: {:?}\\n--- stderr\\n{}--- stdout\\n{}\\n\",\n+                output.status,\n+                std::str::from_utf8(&output.stderr).unwrap(),\n+                std::str::from_utf8(&output.stdout).unwrap(),\n+            )\n+            .into());\n         }\n-        let mut parts = line.trim().splitn(2, ' ');\n-        let name = parts.next().expect(\"name in group\");\n-        if name == \"warnings\" {\n-            // This is special.\n-            continue;\n+        let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+        let lines = stdout.lines();\n+        let group_start = lines.skip_while(|line| !line.contains(\"groups provided\")).skip(1);\n+        let table_start = group_start.skip_while(|line| !line.contains(\"----\")).skip(1);\n+        for line in table_start {\n+            if line.is_empty() {\n+                break;\n+            }\n+            let mut parts = line.trim().splitn(2, ' ');\n+            let name = parts.next().expect(\"name in group\");\n+            if name == \"warnings\" {\n+                // This is special.\n+                continue;\n+            }\n+            let lints = parts\n+                .next()\n+                .ok_or_else(|| format!(\"expected lints following name, got `{}`\", line))?;\n+            let lints = lints.split(',').map(|l| l.trim().to_string()).collect();\n+            assert!(result.insert(name.to_string(), lints).is_none());\n         }\n-        let lints =\n-            parts.next().ok_or_else(|| format!(\"expected lints following name, got `{}`\", line))?;\n-        let lints = lints.split(',').map(|l| l.trim().to_string()).collect();\n-        assert!(result.insert(name.to_string(), lints).is_none());\n-    }\n-    if result.is_empty() {\n-        return Err(\n-            format!(\"expected at least one group in -Whelp output, got:\\n{}\", stdout).into()\n-        );\n+        if result.is_empty() {\n+            return Err(\n+                format!(\"expected at least one group in -Whelp output, got:\\n{}\", stdout).into()\n+            );\n+        }\n+        Ok(result)\n     }\n-    Ok(result)\n-}\n \n-fn make_groups_table(lints: &[Lint], groups: &LintGroups) -> Result<String, Box<dyn Error>> {\n-    let mut result = String::new();\n-    let mut to_link = Vec::new();\n-    result.push_str(\"| Group | Description | Lints |\\n\");\n-    result.push_str(\"|-------|-------------|-------|\\n\");\n-    result.push_str(\"| warnings | All lints that are set to issue warnings | See [warn-by-default] for the default set of warnings |\\n\");\n-    for (group_name, group_lints) in groups {\n-        let description = GROUP_DESCRIPTIONS.iter().find(|(n, _)| n == group_name)\n-            .ok_or_else(|| format!(\"lint group `{}` does not have a description, please update the GROUP_DESCRIPTIONS list\", group_name))?\n-            .1;\n-        to_link.extend(group_lints);\n-        let brackets: Vec<_> = group_lints.iter().map(|l| format!(\"[{}]\", l)).collect();\n-        write!(result, \"| {} | {} | {} |\\n\", group_name, description, brackets.join(\", \")).unwrap();\n-    }\n-    result.push('\\n');\n-    result.push_str(\"[warn-by-default]: listing/warn-by-default.md\\n\");\n-    for lint_name in to_link {\n-        let lint_def =\n-            lints.iter().find(|l| l.name == lint_name.replace(\"-\", \"_\")).ok_or_else(|| {\n-                format!(\n-                    \"`rustc -W help` defined lint `{}` but that lint does not appear to exist\",\n-                    lint_name\n-                )\n-            })?;\n-        write!(\n-            result,\n-            \"[{}]: listing/{}#{}\\n\",\n-            lint_name,\n-            lint_def.level.doc_filename(),\n-            lint_name\n-        )\n-        .unwrap();\n+    fn make_groups_table(\n+        &self,\n+        lints: &[Lint],\n+        groups: &LintGroups,\n+    ) -> Result<String, Box<dyn Error>> {\n+        let mut result = String::new();\n+        let mut to_link = Vec::new();\n+        result.push_str(\"| Group | Description | Lints |\\n\");\n+        result.push_str(\"|-------|-------------|-------|\\n\");\n+        result.push_str(\"| warnings | All lints that are set to issue warnings | See [warn-by-default] for the default set of warnings |\\n\");\n+        for (group_name, group_lints) in groups {\n+            let description = match GROUP_DESCRIPTIONS.iter().find(|(n, _)| n == group_name) {\n+                Some((_, desc)) => desc,\n+                None if self.validate => {\n+                    return Err(format!(\n+                        \"lint group `{}` does not have a description, \\\n+                         please update the GROUP_DESCRIPTIONS list in \\\n+                         src/tools/lint-docs/src/groups.rs\",\n+                        group_name\n+                    )\n+                    .into());\n+                }\n+                None => {\n+                    eprintln!(\n+                        \"warning: lint group `{}` is missing from the GROUP_DESCRIPTIONS list\\n\\\n+                         If this is a new lint group, please update the GROUP_DESCRIPTIONS in \\\n+                         src/tools/lint-docs/src/groups.rs\",\n+                        group_name\n+                    );\n+                    continue;\n+                }\n+            };\n+            to_link.extend(group_lints);\n+            let brackets: Vec<_> = group_lints.iter().map(|l| format!(\"[{}]\", l)).collect();\n+            write!(result, \"| {} | {} | {} |\\n\", group_name, description, brackets.join(\", \"))\n+                .unwrap();\n+        }\n+        result.push('\\n');\n+        result.push_str(\"[warn-by-default]: listing/warn-by-default.md\\n\");\n+        for lint_name in to_link {\n+            let lint_def =\n+                lints.iter().find(|l| l.name == lint_name.replace(\"-\", \"_\")).ok_or_else(|| {\n+                    format!(\n+                        \"`rustc -W help` defined lint `{}` but that lint does not appear to exist\",\n+                        lint_name\n+                    )\n+                })?;\n+            write!(\n+                result,\n+                \"[{}]: listing/{}#{}\\n\",\n+                lint_name,\n+                lint_def.level.doc_filename(),\n+                lint_name\n+            )\n+            .unwrap();\n+        }\n+        Ok(result)\n     }\n-    Ok(result)\n }"}, {"sha": "326b7948098540ea7a1ef3bbc36f3b81573e698c", "filename": "src/tools/lint-docs/src/lib.rs", "status": "modified", "additions": 385, "deletions": 371, "changes": 756, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -7,6 +7,22 @@ use walkdir::WalkDir;\n \n mod groups;\n \n+pub struct LintExtractor<'a> {\n+    /// Path to the `src` directory, where it will scan for `.rs` files to\n+    /// find lint declarations.\n+    pub src_path: &'a Path,\n+    /// Path where to save the output.\n+    pub out_path: &'a Path,\n+    /// Path to the `rustc` executable.\n+    pub rustc_path: &'a Path,\n+    /// The target arch to build the docs for.\n+    pub rustc_target: &'a str,\n+    /// Verbose output.\n+    pub verbose: bool,\n+    /// Validate the style and the code example.\n+    pub validate: bool,\n+}\n+\n struct Lint {\n     name: String,\n     doc: Vec<String>,\n@@ -26,6 +42,28 @@ impl Lint {\n             .filter(|line| line.starts_with(\"```rust\"))\n             .all(|line| line.contains(\",ignore\"))\n     }\n+\n+    /// Checks the doc style of the lint.\n+    fn check_style(&self) -> Result<(), Box<dyn Error>> {\n+        for &expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n+            if expected == \"{{produces}}\" && self.is_ignored() {\n+                continue;\n+            }\n+            if !self.doc_contains(expected) {\n+                return Err(format!(\"lint docs should contain the line `{}`\", expected).into());\n+            }\n+        }\n+        if let Some(first) = self.doc.first() {\n+            if !first.starts_with(&format!(\"The `{}` lint\", self.name)) {\n+                return Err(format!(\n+                    \"lint docs should start with the text \\\"The `{}` lint\\\" to introduce the lint\",\n+                    self.name\n+                )\n+                .into());\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -45,382 +83,396 @@ impl Level {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub struct Rustc<'a> {\n-    pub path: &'a Path,\n-    pub target: &'a str,\n-}\n-\n-/// Collects all lints, and writes the markdown documentation at the given directory.\n-pub fn extract_lint_docs(\n-    src_path: &Path,\n-    out_path: &Path,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut lints = gather_lints(src_path)?;\n-    for lint in &mut lints {\n-        generate_output_example(lint, rustc, verbose).map_err(|e| {\n-            format!(\n-                \"failed to test example in lint docs for `{}` in {}:{}: {}\",\n-                lint.name,\n-                lint.path.display(),\n-                lint.lineno,\n-                e\n-            )\n-        })?;\n+impl<'a> LintExtractor<'a> {\n+    /// Collects all lints, and writes the markdown documentation at the given directory.\n+    pub fn extract_lint_docs(&self) -> Result<(), Box<dyn Error>> {\n+        let mut lints = self.gather_lints()?;\n+        for lint in &mut lints {\n+            self.generate_output_example(lint).map_err(|e| {\n+                format!(\n+                    \"failed to test example in lint docs for `{}` in {}:{}: {}\",\n+                    lint.name,\n+                    lint.path.display(),\n+                    lint.lineno,\n+                    e\n+                )\n+            })?;\n+        }\n+        self.save_lints_markdown(&lints)?;\n+        self.generate_group_docs(&lints)?;\n+        Ok(())\n     }\n-    save_lints_markdown(&lints, &out_path.join(\"listing\"))?;\n-    groups::generate_group_docs(&lints, rustc, out_path)?;\n-    Ok(())\n-}\n \n-/// Collects all lints from all files in the given directory.\n-fn gather_lints(src_path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n-    let mut lints = Vec::new();\n-    for entry in WalkDir::new(src_path).into_iter().filter_map(|e| e.ok()) {\n-        if !entry.path().extension().map_or(false, |ext| ext == \"rs\") {\n-            continue;\n+    /// Collects all lints from all files in the given directory.\n+    fn gather_lints(&self) -> Result<Vec<Lint>, Box<dyn Error>> {\n+        let mut lints = Vec::new();\n+        for entry in WalkDir::new(self.src_path).into_iter().filter_map(|e| e.ok()) {\n+            if !entry.path().extension().map_or(false, |ext| ext == \"rs\") {\n+                continue;\n+            }\n+            lints.extend(self.lints_from_file(entry.path())?);\n         }\n-        lints.extend(lints_from_file(entry.path())?);\n-    }\n-    if lints.is_empty() {\n-        return Err(\"no lints were found!\".into());\n+        if lints.is_empty() {\n+            return Err(\"no lints were found!\".into());\n+        }\n+        Ok(lints)\n     }\n-    Ok(lints)\n-}\n \n-/// Collects all lints from the given file.\n-fn lints_from_file(path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n-    let mut lints = Vec::new();\n-    let contents = fs::read_to_string(path)\n-        .map_err(|e| format!(\"could not read {}: {}\", path.display(), e))?;\n-    let mut lines = contents.lines().enumerate();\n-    loop {\n-        // Find a lint declaration.\n-        let lint_start = loop {\n-            match lines.next() {\n-                Some((lineno, line)) => {\n-                    if line.trim().starts_with(\"declare_lint!\") {\n-                        break lineno + 1;\n+    /// Collects all lints from the given file.\n+    fn lints_from_file(&self, path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n+        let mut lints = Vec::new();\n+        let contents = fs::read_to_string(path)\n+            .map_err(|e| format!(\"could not read {}: {}\", path.display(), e))?;\n+        let mut lines = contents.lines().enumerate();\n+        'outer: loop {\n+            // Find a lint declaration.\n+            let lint_start = loop {\n+                match lines.next() {\n+                    Some((lineno, line)) => {\n+                        if line.trim().starts_with(\"declare_lint!\") {\n+                            break lineno + 1;\n+                        }\n+                    }\n+                    None => return Ok(lints),\n+                }\n+            };\n+            // Read the lint.\n+            let mut doc_lines = Vec::new();\n+            let (doc, name) = loop {\n+                match lines.next() {\n+                    Some((lineno, line)) => {\n+                        let line = line.trim();\n+                        if let Some(text) = line.strip_prefix(\"/// \") {\n+                            doc_lines.push(text.trim().to_string());\n+                        } else if line.starts_with(\"///\") {\n+                            doc_lines.push(\"\".to_string());\n+                        } else if line.starts_with(\"// \") {\n+                            // Ignore comments.\n+                            continue;\n+                        } else {\n+                            let name = lint_name(line).map_err(|e| {\n+                                format!(\n+                                    \"could not determine lint name in {}:{}: {}, line was `{}`\",\n+                                    path.display(),\n+                                    lineno,\n+                                    e,\n+                                    line\n+                                )\n+                            })?;\n+                            if doc_lines.is_empty() {\n+                                if self.validate {\n+                                    return Err(format!(\n+                                        \"did not find doc lines for lint `{}` in {}\",\n+                                        name,\n+                                        path.display()\n+                                    )\n+                                    .into());\n+                                } else {\n+                                    eprintln!(\n+                                        \"warning: lint `{}` in {} does not define any doc lines, \\\n+                                         these are required for the lint documentation\",\n+                                        name,\n+                                        path.display()\n+                                    );\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            break (doc_lines, name);\n+                        }\n+                    }\n+                    None => {\n+                        return Err(format!(\n+                            \"unexpected EOF for lint definition at {}:{}\",\n+                            path.display(),\n+                            lint_start\n+                        )\n+                        .into());\n                     }\n                 }\n-                None => return Ok(lints),\n+            };\n+            // These lints are specifically undocumented. This should be reserved\n+            // for internal rustc-lints only.\n+            if name == \"deprecated_in_future\" {\n+                continue;\n             }\n-        };\n-        // Read the lint.\n-        let mut doc_lines = Vec::new();\n-        let (doc, name) = loop {\n-            match lines.next() {\n-                Some((lineno, line)) => {\n-                    let line = line.trim();\n-                    if line.starts_with(\"/// \") {\n-                        doc_lines.push(line.trim()[4..].to_string());\n-                    } else if line.starts_with(\"///\") {\n-                        doc_lines.push(\"\".to_string());\n-                    } else if line.starts_with(\"// \") {\n-                        // Ignore comments.\n-                        continue;\n-                    } else {\n-                        let name = lint_name(line).map_err(|e| {\n-                            format!(\n-                                \"could not determine lint name in {}:{}: {}, line was `{}`\",\n-                                path.display(),\n-                                lineno,\n-                                e,\n-                                line\n-                            )\n-                        })?;\n-                        if doc_lines.is_empty() {\n+            // Read the level.\n+            let level = loop {\n+                match lines.next() {\n+                    // Ignore comments.\n+                    Some((_, line)) if line.trim().starts_with(\"// \") => {}\n+                    Some((lineno, line)) => match line.trim() {\n+                        \"Allow,\" => break Level::Allow,\n+                        \"Warn,\" => break Level::Warn,\n+                        \"Deny,\" => break Level::Deny,\n+                        _ => {\n                             return Err(format!(\n-                                \"did not find doc lines for lint `{}` in {}\",\n-                                name,\n-                                path.display()\n+                                \"unexpected lint level `{}` in {}:{}\",\n+                                line,\n+                                path.display(),\n+                                lineno\n                             )\n                             .into());\n                         }\n-                        break (doc_lines, name);\n-                    }\n-                }\n-                None => {\n-                    return Err(format!(\n-                        \"unexpected EOF for lint definition at {}:{}\",\n-                        path.display(),\n-                        lint_start\n-                    )\n-                    .into());\n-                }\n-            }\n-        };\n-        // These lints are specifically undocumented. This should be reserved\n-        // for internal rustc-lints only.\n-        if name == \"deprecated_in_future\" {\n-            continue;\n-        }\n-        // Read the level.\n-        let level = loop {\n-            match lines.next() {\n-                // Ignore comments.\n-                Some((_, line)) if line.trim().starts_with(\"// \") => {}\n-                Some((lineno, line)) => match line.trim() {\n-                    \"Allow,\" => break Level::Allow,\n-                    \"Warn,\" => break Level::Warn,\n-                    \"Deny,\" => break Level::Deny,\n-                    _ => {\n+                    },\n+                    None => {\n                         return Err(format!(\n-                            \"unexpected lint level `{}` in {}:{}\",\n-                            line,\n+                            \"expected lint level in {}:{}, got EOF\",\n                             path.display(),\n-                            lineno\n+                            lint_start\n                         )\n                         .into());\n                     }\n-                },\n-                None => {\n-                    return Err(format!(\n-                        \"expected lint level in {}:{}, got EOF\",\n-                        path.display(),\n-                        lint_start\n-                    )\n-                    .into());\n                 }\n-            }\n-        };\n-        // The rest of the lint definition is ignored.\n-        assert!(!doc.is_empty());\n-        lints.push(Lint { name, doc, level, path: PathBuf::from(path), lineno: lint_start });\n-    }\n-}\n-\n-/// Extracts the lint name (removing the visibility modifier, and checking validity).\n-fn lint_name(line: &str) -> Result<String, &'static str> {\n-    // Skip over any potential `pub` visibility.\n-    match line.trim().split(' ').next_back() {\n-        Some(name) => {\n-            if !name.ends_with(',') {\n-                return Err(\"lint name should end with comma\");\n-            }\n-            let name = &name[..name.len() - 1];\n-            if !name.chars().all(|ch| ch.is_uppercase() || ch == '_') || name.is_empty() {\n-                return Err(\"lint name did not have expected format\");\n-            }\n-            Ok(name.to_lowercase().to_string())\n+            };\n+            // The rest of the lint definition is ignored.\n+            assert!(!doc.is_empty());\n+            lints.push(Lint { name, doc, level, path: PathBuf::from(path), lineno: lint_start });\n         }\n-        None => Err(\"could not find lint name\"),\n-    }\n-}\n-\n-/// Mutates the lint definition to replace the `{{produces}}` marker with the\n-/// actual output from the compiler.\n-fn generate_output_example(\n-    lint: &mut Lint,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    // Explicit list of lints that are allowed to not have an example. Please\n-    // try to avoid adding to this list.\n-    if matches!(\n-        lint.name.as_str(),\n-        \"unused_features\" // broken lint\n-        | \"unstable_features\" // deprecated\n-    ) {\n-        return Ok(());\n-    }\n-    if lint.doc_contains(\"[rustdoc book]\") && !lint.doc_contains(\"{{produces}}\") {\n-        // Rustdoc lints are documented in the rustdoc book, don't check these.\n-        return Ok(());\n     }\n-    check_style(lint)?;\n-    // Unfortunately some lints have extra requirements that this simple test\n-    // setup can't handle (like extern crates). An alternative is to use a\n-    // separate test suite, and use an include mechanism such as mdbook's\n-    // `{{#rustdoc_include}}`.\n-    if !lint.is_ignored() {\n-        replace_produces(lint, rustc, verbose)?;\n-    }\n-    Ok(())\n-}\n \n-/// Checks the doc style of the lint.\n-fn check_style(lint: &Lint) -> Result<(), Box<dyn Error>> {\n-    for &expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n-        if expected == \"{{produces}}\" && lint.is_ignored() {\n-            continue;\n+    /// Mutates the lint definition to replace the `{{produces}}` marker with the\n+    /// actual output from the compiler.\n+    fn generate_output_example(&self, lint: &mut Lint) -> Result<(), Box<dyn Error>> {\n+        // Explicit list of lints that are allowed to not have an example. Please\n+        // try to avoid adding to this list.\n+        if matches!(\n+            lint.name.as_str(),\n+            \"unused_features\" // broken lint\n+            | \"unstable_features\" // deprecated\n+        ) {\n+            return Ok(());\n         }\n-        if !lint.doc_contains(expected) {\n-            return Err(format!(\"lint docs should contain the line `{}`\", expected).into());\n+        if lint.doc_contains(\"[rustdoc book]\") && !lint.doc_contains(\"{{produces}}\") {\n+            // Rustdoc lints are documented in the rustdoc book, don't check these.\n+            return Ok(());\n         }\n-    }\n-    if let Some(first) = lint.doc.first() {\n-        if !first.starts_with(&format!(\"The `{}` lint\", lint.name)) {\n-            return Err(format!(\n-                \"lint docs should start with the text \\\"The `{}` lint\\\" to introduce the lint\",\n-                lint.name\n-            )\n-            .into());\n+        if self.validate {\n+            lint.check_style()?;\n+        }\n+        // Unfortunately some lints have extra requirements that this simple test\n+        // setup can't handle (like extern crates). An alternative is to use a\n+        // separate test suite, and use an include mechanism such as mdbook's\n+        // `{{#rustdoc_include}}`.\n+        if !lint.is_ignored() {\n+            if let Err(e) = self.replace_produces(lint) {\n+                if self.validate {\n+                    return Err(e);\n+                }\n+                eprintln!(\n+                    \"warning: the code example in lint `{}` in {} failed to \\\n+                     generate the expected output: {}\",\n+                    lint.name,\n+                    lint.path.display(),\n+                    e\n+                );\n+            }\n         }\n+        Ok(())\n     }\n-    Ok(())\n-}\n \n-/// Mutates the lint docs to replace the `{{produces}}` marker with the actual\n-/// output from the compiler.\n-fn replace_produces(\n-    lint: &mut Lint,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut lines = lint.doc.iter_mut();\n-    loop {\n-        // Find start of example.\n-        let options = loop {\n-            match lines.next() {\n-                Some(line) if line.starts_with(\"```rust\") => {\n-                    break line[7..].split(',').collect::<Vec<_>>();\n+    /// Mutates the lint docs to replace the `{{produces}}` marker with the actual\n+    /// output from the compiler.\n+    fn replace_produces(&self, lint: &mut Lint) -> Result<(), Box<dyn Error>> {\n+        let mut lines = lint.doc.iter_mut();\n+        loop {\n+            // Find start of example.\n+            let options = loop {\n+                match lines.next() {\n+                    Some(line) if line.starts_with(\"```rust\") => {\n+                        break line[7..].split(',').collect::<Vec<_>>();\n+                    }\n+                    Some(line) if line.contains(\"{{produces}}\") => {\n+                        return Err(\"lint marker {{{{produces}}}} found, \\\n+                            but expected to immediately follow a rust code block\"\n+                            .into());\n+                    }\n+                    Some(_) => {}\n+                    None => return Ok(()),\n                 }\n-                Some(line) if line.contains(\"{{produces}}\") => {\n-                    return Err(\"lint marker {{{{produces}}}} found, \\\n-                        but expected to immediately follow a rust code block\"\n+            };\n+            // Find the end of example.\n+            let mut example = Vec::new();\n+            loop {\n+                match lines.next() {\n+                    Some(line) if line == \"```\" => break,\n+                    Some(line) => example.push(line),\n+                    None => {\n+                        return Err(format!(\n+                            \"did not find end of example triple ticks ```, docs were:\\n{:?}\",\n+                            lint.doc\n+                        )\n                         .into());\n-                }\n-                Some(_) => {}\n-                None => return Ok(()),\n-            }\n-        };\n-        // Find the end of example.\n-        let mut example = Vec::new();\n-        loop {\n-            match lines.next() {\n-                Some(line) if line == \"```\" => break,\n-                Some(line) => example.push(line),\n-                None => {\n-                    return Err(format!(\n-                        \"did not find end of example triple ticks ```, docs were:\\n{:?}\",\n-                        lint.doc\n-                    )\n-                    .into());\n+                    }\n                 }\n             }\n-        }\n-        // Find the {{produces}} line.\n-        loop {\n-            match lines.next() {\n-                Some(line) if line.is_empty() => {}\n-                Some(line) if line == \"{{produces}}\" => {\n-                    let output =\n-                        generate_lint_output(&lint.name, &example, &options, rustc, verbose)?;\n-                    line.replace_range(\n-                        ..,\n-                        &format!(\n-                            \"This will produce:\\n\\\n-                        \\n\\\n-                        ```text\\n\\\n-                        {}\\\n-                        ```\",\n-                            output\n-                        ),\n-                    );\n-                    break;\n+            // Find the {{produces}} line.\n+            loop {\n+                match lines.next() {\n+                    Some(line) if line.is_empty() => {}\n+                    Some(line) if line == \"{{produces}}\" => {\n+                        let output = self.generate_lint_output(&lint.name, &example, &options)?;\n+                        line.replace_range(\n+                            ..,\n+                            &format!(\n+                                \"This will produce:\\n\\\n+                            \\n\\\n+                            ```text\\n\\\n+                            {}\\\n+                            ```\",\n+                                output\n+                            ),\n+                        );\n+                        break;\n+                    }\n+                    // No {{produces}} after example, find next example.\n+                    Some(_line) => break,\n+                    None => return Ok(()),\n                 }\n-                // No {{produces}} after example, find next example.\n-                Some(_line) => break,\n-                None => return Ok(()),\n             }\n         }\n     }\n-}\n \n-/// Runs the compiler against the example, and extracts the output.\n-fn generate_lint_output(\n-    name: &str,\n-    example: &[&mut String],\n-    options: &[&str],\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<String, Box<dyn Error>> {\n-    if verbose {\n-        eprintln!(\"compiling lint {}\", name);\n-    }\n-    let tempdir = tempfile::TempDir::new()?;\n-    let tempfile = tempdir.path().join(\"lint_example.rs\");\n-    let mut source = String::new();\n-    let needs_main = !example.iter().any(|line| line.contains(\"fn main\"));\n-    // Remove `# ` prefix for hidden lines.\n-    let unhidden =\n-        example.iter().map(|line| if line.starts_with(\"# \") { &line[2..] } else { line });\n-    let mut lines = unhidden.peekable();\n-    while let Some(line) = lines.peek() {\n-        if line.starts_with(\"#!\") {\n+    /// Runs the compiler against the example, and extracts the output.\n+    fn generate_lint_output(\n+        &self,\n+        name: &str,\n+        example: &[&mut String],\n+        options: &[&str],\n+    ) -> Result<String, Box<dyn Error>> {\n+        if self.verbose {\n+            eprintln!(\"compiling lint {}\", name);\n+        }\n+        let tempdir = tempfile::TempDir::new()?;\n+        let tempfile = tempdir.path().join(\"lint_example.rs\");\n+        let mut source = String::new();\n+        let needs_main = !example.iter().any(|line| line.contains(\"fn main\"));\n+        // Remove `# ` prefix for hidden lines.\n+        let unhidden = example.iter().map(|line| line.strip_prefix(\"# \").unwrap_or(line));\n+        let mut lines = unhidden.peekable();\n+        while let Some(line) = lines.peek() {\n+            if line.starts_with(\"#!\") {\n+                source.push_str(line);\n+                source.push('\\n');\n+                lines.next();\n+            } else {\n+                break;\n+            }\n+        }\n+        if needs_main {\n+            source.push_str(\"fn main() {\\n\");\n+        }\n+        for line in lines {\n             source.push_str(line);\n-            source.push('\\n');\n-            lines.next();\n+            source.push('\\n')\n+        }\n+        if needs_main {\n+            source.push_str(\"}\\n\");\n+        }\n+        fs::write(&tempfile, source)\n+            .map_err(|e| format!(\"failed to write {}: {}\", tempfile.display(), e))?;\n+        let mut cmd = Command::new(self.rustc_path);\n+        if options.contains(&\"edition2015\") {\n+            cmd.arg(\"--edition=2015\");\n         } else {\n-            break;\n+            cmd.arg(\"--edition=2018\");\n+        }\n+        cmd.arg(\"--error-format=json\");\n+        cmd.arg(\"--target\").arg(self.rustc_target);\n+        if options.contains(&\"test\") {\n+            cmd.arg(\"--test\");\n+        }\n+        cmd.arg(\"lint_example.rs\");\n+        cmd.current_dir(tempdir.path());\n+        let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+        let stderr = std::str::from_utf8(&output.stderr).unwrap();\n+        let msgs = stderr\n+            .lines()\n+            .filter(|line| line.starts_with('{'))\n+            .map(serde_json::from_str)\n+            .collect::<Result<Vec<serde_json::Value>, _>>()?;\n+        match msgs\n+            .iter()\n+            .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n+        {\n+            Some(msg) => {\n+                let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+                Ok(rendered.to_string())\n+            }\n+            None => {\n+                match msgs.iter().find(\n+                    |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n+                ) {\n+                    Some(msg) => {\n+                        let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+                        Ok(rendered.to_string())\n+                    }\n+                    None => {\n+                        let rendered: Vec<&str> =\n+                            msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n+                        let non_json: Vec<&str> =\n+                            stderr.lines().filter(|line| !line.starts_with('{')).collect();\n+                        Err(format!(\n+                            \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n+                            name,\n+                            non_json.join(\"\\n\"),\n+                            rendered.join(\"\\n\")\n+                        )\n+                        .into())\n+                    }\n+                }\n+            }\n         }\n     }\n-    if needs_main {\n-        source.push_str(\"fn main() {\\n\");\n-    }\n-    for line in lines {\n-        source.push_str(line);\n-        source.push('\\n')\n-    }\n-    if needs_main {\n-        source.push_str(\"}\\n\");\n-    }\n-    fs::write(&tempfile, source)\n-        .map_err(|e| format!(\"failed to write {}: {}\", tempfile.display(), e))?;\n-    let mut cmd = Command::new(rustc.path);\n-    if options.contains(&\"edition2015\") {\n-        cmd.arg(\"--edition=2015\");\n-    } else {\n-        cmd.arg(\"--edition=2018\");\n-    }\n-    cmd.arg(\"--error-format=json\");\n-    cmd.arg(\"--target\").arg(rustc.target);\n-    if options.contains(&\"test\") {\n-        cmd.arg(\"--test\");\n+\n+    /// Saves the mdbook lint chapters at the given path.\n+    fn save_lints_markdown(&self, lints: &[Lint]) -> Result<(), Box<dyn Error>> {\n+        self.save_level(lints, Level::Allow, ALLOWED_MD)?;\n+        self.save_level(lints, Level::Warn, WARN_MD)?;\n+        self.save_level(lints, Level::Deny, DENY_MD)?;\n+        Ok(())\n     }\n-    cmd.arg(\"lint_example.rs\");\n-    cmd.current_dir(tempdir.path());\n-    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n-    let stderr = std::str::from_utf8(&output.stderr).unwrap();\n-    let msgs = stderr\n-        .lines()\n-        .filter(|line| line.starts_with('{'))\n-        .map(serde_json::from_str)\n-        .collect::<Result<Vec<serde_json::Value>, _>>()?;\n-    match msgs\n-        .iter()\n-        .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n-    {\n-        Some(msg) => {\n-            let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-            Ok(rendered.to_string())\n+\n+    fn save_level(&self, lints: &[Lint], level: Level, header: &str) -> Result<(), Box<dyn Error>> {\n+        let mut result = String::new();\n+        result.push_str(header);\n+        let mut these_lints: Vec<_> = lints.iter().filter(|lint| lint.level == level).collect();\n+        these_lints.sort_unstable_by_key(|lint| &lint.name);\n+        for lint in &these_lints {\n+            write!(result, \"* [`{}`](#{})\\n\", lint.name, lint.name.replace(\"_\", \"-\")).unwrap();\n         }\n-        None => {\n-            match msgs.iter().find(\n-                |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n-            ) {\n-                Some(msg) => {\n-                    let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-                    Ok(rendered.to_string())\n-                }\n-                None => {\n-                    let rendered: Vec<&str> =\n-                        msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n-                    let non_json: Vec<&str> =\n-                        stderr.lines().filter(|line| !line.starts_with('{')).collect();\n-                    Err(format!(\n-                        \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n-                        name,\n-                        non_json.join(\"\\n\"),\n-                        rendered.join(\"\\n\")\n-                    )\n-                    .into())\n-                }\n+        result.push('\\n');\n+        for lint in &these_lints {\n+            write!(result, \"## {}\\n\\n\", lint.name.replace(\"_\", \"-\")).unwrap();\n+            for line in &lint.doc {\n+                result.push_str(line);\n+                result.push('\\n');\n+            }\n+            result.push('\\n');\n+        }\n+        let out_path = self.out_path.join(\"listing\").join(level.doc_filename());\n+        // Delete the output because rustbuild uses hard links in its copies.\n+        let _ = fs::remove_file(&out_path);\n+        fs::write(&out_path, result)\n+            .map_err(|e| format!(\"could not write to {}: {}\", out_path.display(), e))?;\n+        Ok(())\n+    }\n+}\n+\n+/// Extracts the lint name (removing the visibility modifier, and checking validity).\n+fn lint_name(line: &str) -> Result<String, &'static str> {\n+    // Skip over any potential `pub` visibility.\n+    match line.trim().split(' ').next_back() {\n+        Some(name) => {\n+            if !name.ends_with(',') {\n+                return Err(\"lint name should end with comma\");\n             }\n+            let name = &name[..name.len() - 1];\n+            if !name.chars().all(|ch| ch.is_uppercase() || ch == '_') || name.is_empty() {\n+                return Err(\"lint name did not have expected format\");\n+            }\n+            Ok(name.to_lowercase().to_string())\n         }\n+        None => Err(\"could not find lint name\"),\n     }\n }\n \n@@ -442,41 +494,3 @@ static DENY_MD: &str = r#\"# Deny-by-default lints\n These lints are all set to the 'deny' level by default.\n \n \"#;\n-\n-/// Saves the mdbook lint chapters at the given path.\n-fn save_lints_markdown(lints: &[Lint], out_dir: &Path) -> Result<(), Box<dyn Error>> {\n-    save_level(lints, Level::Allow, out_dir, ALLOWED_MD)?;\n-    save_level(lints, Level::Warn, out_dir, WARN_MD)?;\n-    save_level(lints, Level::Deny, out_dir, DENY_MD)?;\n-    Ok(())\n-}\n-\n-fn save_level(\n-    lints: &[Lint],\n-    level: Level,\n-    out_dir: &Path,\n-    header: &str,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut result = String::new();\n-    result.push_str(header);\n-    let mut these_lints: Vec<_> = lints.iter().filter(|lint| lint.level == level).collect();\n-    these_lints.sort_unstable_by_key(|lint| &lint.name);\n-    for lint in &these_lints {\n-        write!(result, \"* [`{}`](#{})\\n\", lint.name, lint.name.replace(\"_\", \"-\")).unwrap();\n-    }\n-    result.push('\\n');\n-    for lint in &these_lints {\n-        write!(result, \"## {}\\n\\n\", lint.name.replace(\"_\", \"-\")).unwrap();\n-        for line in &lint.doc {\n-            result.push_str(line);\n-            result.push('\\n');\n-        }\n-        result.push('\\n');\n-    }\n-    let out_path = out_dir.join(level.doc_filename());\n-    // Delete the output because rustbuild uses hard links in its copies.\n-    let _ = fs::remove_file(&out_path);\n-    fs::write(&out_path, result)\n-        .map_err(|e| format!(\"could not write to {}: {}\", out_path.display(), e))?;\n-    Ok(())\n-}"}, {"sha": "2055fed2b480c0b8ef021afdb80c38864ef586f5", "filename": "src/tools/lint-docs/src/main.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs?ref=36ce8db2290c32e1d1f2acc422d5ddb28ed9a9a9", "patch": "@@ -3,7 +3,20 @@ use std::path::PathBuf;\n \n fn main() {\n     if let Err(e) = doit() {\n-        println!(\"error: {}\", e);\n+        eprintln!(\"error: {}\", e);\n+        eprintln!(\n+            \"\n+This error was generated by the lint-docs tool.\n+This tool extracts documentation for lints from the source code and places\n+them in the rustc book. See the declare_lint! documentation\n+https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/macro.declare_lint.html\n+for an example of the format of documentation this tool expects.\n+\n+To re-run these tests, run: ./x.py test --keep-stage=0 src/tools/lint-docs\n+The --keep-stage flag should be used if you have already built the compiler\n+and are only modifying the doc comments to avoid rebuilding the compiler.\n+\"\n+        );\n         std::process::exit(1);\n     }\n }\n@@ -15,6 +28,7 @@ fn doit() -> Result<(), Box<dyn Error>> {\n     let mut rustc_path = None;\n     let mut rustc_target = None;\n     let mut verbose = false;\n+    let mut validate = false;\n     while let Some(arg) = args.next() {\n         match arg.as_str() {\n             \"--src\" => {\n@@ -42,6 +56,7 @@ fn doit() -> Result<(), Box<dyn Error>> {\n                 };\n             }\n             \"-v\" | \"--verbose\" => verbose = true,\n+            \"--validate\" => validate = true,\n             s => return Err(format!(\"unexpected argument `{}`\", s).into()),\n         }\n     }\n@@ -57,13 +72,13 @@ fn doit() -> Result<(), Box<dyn Error>> {\n     if rustc_target.is_none() {\n         return Err(\"--rustc-target must be specified to the rustc target\".into());\n     }\n-    lint_docs::extract_lint_docs(\n-        &src_path.unwrap(),\n-        &out_path.unwrap(),\n-        lint_docs::Rustc {\n-            path: rustc_path.as_deref().unwrap(),\n-            target: rustc_target.as_deref().unwrap(),\n-        },\n+    let le = lint_docs::LintExtractor {\n+        src_path: &src_path.unwrap(),\n+        out_path: &out_path.unwrap(),\n+        rustc_path: &rustc_path.unwrap(),\n+        rustc_target: &rustc_target.unwrap(),\n         verbose,\n-    )\n+        validate,\n+    };\n+    le.extract_lint_docs()\n }"}]}