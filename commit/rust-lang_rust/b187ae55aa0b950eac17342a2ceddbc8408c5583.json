{"sha": "b187ae55aa0b950eac17342a2ceddbc8408c5583", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODdhZTU1YWEwYjk1MGVhYzE3MzQyYTJjZWRkYmM4NDA4YzU1ODM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:04:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:27:36Z"}, "message": "rollup merge of #20066: aturon/stab-2-cell\n\nThis patch finalizes stabilization for the `cell` module, settling on\nthe current names `Cell`, `RefCell`, `UnsafeCell`, `Ref` and `RefMut`.\n\nWhile we had considered improving these names, no one was able to\nproduce a truly compelling alternative.\n\nThere is one substantive change here: the `get` method of `UnsafeSell`\nis now marked `unsafe`. Merely getting a raw pointer to the contents is\nnot, by itself, an unsafe operation. (Consider that you can always\nsafely turn a reference into a raw pointer, and that raw pointer may\nthen be aliased by subsequent references.)\n\nr? @alexcrichton", "tree": {"sha": "fed7cda87041e485779a35550eeacc88a5f38860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed7cda87041e485779a35550eeacc88a5f38860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b187ae55aa0b950eac17342a2ceddbc8408c5583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b187ae55aa0b950eac17342a2ceddbc8408c5583", "html_url": "https://github.com/rust-lang/rust/commit/b187ae55aa0b950eac17342a2ceddbc8408c5583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b187ae55aa0b950eac17342a2ceddbc8408c5583/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6a7388210e40741e9e5d50ef376ceba3cb34e61", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a7388210e40741e9e5d50ef376ceba3cb34e61", "html_url": "https://github.com/rust-lang/rust/commit/f6a7388210e40741e9e5d50ef376ceba3cb34e61"}, {"sha": "e473e700ccb94177cdc8e799b9f08bceb1c75601", "url": "https://api.github.com/repos/rust-lang/rust/commits/e473e700ccb94177cdc8e799b9f08bceb1c75601", "html_url": "https://github.com/rust-lang/rust/commit/e473e700ccb94177cdc8e799b9f08bceb1c75601"}], "stats": {"total": 32, "additions": 13, "deletions": 19}, "files": [{"sha": "03eb4504448a3da6e805f9c06866afdd8c536f0a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b187ae55aa0b950eac17342a2ceddbc8408c5583/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b187ae55aa0b950eac17342a2ceddbc8408c5583/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b187ae55aa0b950eac17342a2ceddbc8408c5583", "patch": "@@ -164,7 +164,7 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n-#[unstable = \"likely to be renamed; otherwise stable\"]\n+#[stable]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n     noshare: marker::NoSync,\n@@ -231,7 +231,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n-#[unstable = \"likely to be renamed; otherwise stable\"]\n+#[stable]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -256,7 +256,7 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n-    #[unstable = \"recently renamed per RFC 430\"]\n+    #[stable]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -275,7 +275,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable = \"may be renamed, depending on global conventions\"]\n+    #[unstable = \"may be renamed or removed\"]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -291,7 +291,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n-    #[unstable]\n+    #[stable]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -305,7 +305,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable = \"may be renamed, depending on global conventions\"]\n+    #[unstable = \"may be renamed or removed\"]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -321,7 +321,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n-    #[unstable]\n+    #[stable]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -400,7 +400,7 @@ impl<'b> Clone for BorrowRef<'b> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n+#[stable]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -456,7 +456,7 @@ impl<'b> BorrowRefMut<'b> {\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n+#[stable]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -517,7 +517,7 @@ impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n /// is not recommended to access its fields directly, `get` should be used\n /// instead.\n #[lang=\"unsafe\"]\n-#[unstable = \"this type may be renamed in the future\"]\n+#[stable]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n@@ -539,22 +539,16 @@ impl<T> UnsafeCell<T> {\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n-    ///\n-    /// This function is unsafe as the pointer returned is an unsafe pointer and\n-    /// no guarantees are made about the aliasing of the pointers being handed\n-    /// out in this or other tasks.\n     #[inline]\n-    #[unstable = \"conventions around acquiring an inner reference are still \\\n-                  under development\"]\n-    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n+    #[stable]\n+    pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n     /// This function is unsafe because there is no guarantee that this or other\n     /// tasks are currently inspecting the inner value.\n     #[inline]\n-    #[unstable = \"conventions around the name `unwrap` are still under \\\n-                  development\"]\n+    #[stable]\n     pub unsafe fn into_inner(self) -> T { self.value }\n \n     /// Deprecated, use into_inner() instead"}]}