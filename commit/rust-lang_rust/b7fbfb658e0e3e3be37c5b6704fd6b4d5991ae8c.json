{"sha": "b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZmJmYjY1OGUwZTNlM2JlMzdjNWI2NzA0ZmQ2YjRkNTk5MWFlOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-03T03:06:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-03T03:06:03Z"}, "message": "Auto merge of #29285 - eefriedman:libsyntax-panic, r=nrc\n\nA set of commits which pushes some panics out of core parser methods, and into users of those parser methods.", "tree": {"sha": "9795a4c94d2336c920d9be3f12d62df0292b273e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9795a4c94d2336c920d9be3f12d62df0292b273e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "html_url": "https://github.com/rust-lang/rust/commit/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749625ad6d15d0254b90e3d16f79d1cb1e260969", "url": "https://api.github.com/repos/rust-lang/rust/commits/749625ad6d15d0254b90e3d16f79d1cb1e260969", "html_url": "https://github.com/rust-lang/rust/commit/749625ad6d15d0254b90e3d16f79d1cb1e260969"}, {"sha": "e7d3ae606ed496144554dae499b69207da3b09c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7d3ae606ed496144554dae499b69207da3b09c5", "html_url": "https://github.com/rust-lang/rust/commit/e7d3ae606ed496144554dae499b69207da3b09c5"}], "stats": {"total": 364, "additions": 174, "deletions": 190}, "files": [{"sha": "3714a43744fe569eaef087a1ab832f9dd9308efd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -657,15 +657,15 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal(&format!(\"Error loading target specification: {}\", e));\n+            panic!(sp.handler().fatal(&format!(\"Error loading target specification: {}\", e)));\n         }\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n-                                             target-pointer-width {}\", w))\n+        w    => panic!(sp.handler().fatal(&format!(\"target specification was invalid: \\\n+                                                    unrecognized target-pointer-width {}\", w))),\n     };\n \n     Config {"}, {"sha": "29ac2d3abb569be4936ca6290d81590ce6009c94", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -94,7 +94,7 @@ impl Session {\n         if self.opts.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.diagnostic().handler().fatal(msg)\n+        panic!(self.diagnostic().handler().fatal(msg))\n     }\n     pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n         if is_warning {\n@@ -415,8 +415,8 @@ pub fn build_session_(sopts: config::Options,\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            span_diagnostic.handler()\n-                .fatal(&format!(\"Error loading host specification: {}\", e));\n+            panic!(span_diagnostic.handler()\n+                                  .fatal(&format!(\"Error loading host specification: {}\", e)));\n     }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);"}, {"sha": "078a767c0ca3b3ebf10015b1866b77bc54a0f3e4", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -268,8 +268,10 @@ impl Target {\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n-                None =>\n-                    handler.fatal(&format!(\"Field {} in target specification is required\", name))\n+                None => {\n+                    panic!(handler.fatal(&format!(\"Field {} in target specification is required\",\n+                                                  name)))\n+                }\n             }\n         };\n "}, {"sha": "17c8d9aa9e1daf1a571e65b2c99cf20860047ff9", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -38,14 +38,12 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(&msg[..]);\n+            panic!(handler.fatal(&msg[..]));\n         } else {\n             let err = CStr::from_ptr(cstr).to_bytes();\n             let err = String::from_utf8_lossy(err).to_string();\n             libc::free(cstr as *mut _);\n-            handler.fatal(&format!(\"{}: {}\",\n-                                  &msg[..],\n-                                  &err[..]));\n+            panic!(handler.fatal(&format!(\"{}: {}\", &msg[..], &err[..])));\n         }\n     }\n }"}, {"sha": "2b34db3f6eafbd19b1e0487bbf9842332da57c09", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -206,13 +206,9 @@ impl Handler {\n             can_emit_warnings: can_emit_warnings\n         }\n     }\n-    pub fn fatal(&self, msg: &str) -> ! {\n+    pub fn fatal(&self, msg: &str) -> FatalError {\n         self.emit.borrow_mut().emit(None, msg, None, Fatal);\n-\n-        // Suppress the fatal error message from the panic below as we've\n-        // already terminated in our own \"legitimate\" fashion.\n-        io::set_panic(Box::new(io::sink()));\n-        panic!(FatalError);\n+        FatalError\n     }\n     pub fn err(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Error);\n@@ -230,14 +226,15 @@ impl Handler {\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n-          0 => return,\n-          1 => s = \"aborting due to previous error\".to_string(),\n-          _   => {\n-            s = format!(\"aborting due to {} previous errors\",\n-                        self.err_count.get());\n-          }\n+            0 => return,\n+            1 => s = \"aborting due to previous error\".to_string(),\n+            _  => {\n+                s = format!(\"aborting due to {} previous errors\",\n+                            self.err_count.get());\n+            }\n         }\n-        self.fatal(&s[..]);\n+\n+        panic!(self.fatal(&s[..]));\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);"}, {"sha": "984e73f85f610656a72263de4e1c64ce5eb65837", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -79,7 +79,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     cx.span_err(sp, \"malformed inline assembly\");\n                     return DummyResult::expr(sp);\n                 }\n-                let (s, style) = match expr_to_string(cx, p.parse_expr(),\n+                let (s, style) = match expr_to_string(cx, panictry!(p.parse_expr_nopanic()),\n                                                    \"inline assembly must be a string literal\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n@@ -102,7 +102,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let span = p.last_span;\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let out = p.parse_expr();\n+                    let out = panictry!(p.parse_expr_nopanic());\n                     panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     // Expands a read+write operand into two operands.\n@@ -146,7 +146,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     }\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let input = p.parse_expr();\n+                    let input = panictry!(p.parse_expr_nopanic());\n                     panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     inputs.push((constraint, input));"}, {"sha": "e0ef8701cdff918881f005ed605be28ed5546edb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -809,7 +809,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n-    let ret = cx.expander().fold_expr(p.parse_expr());\n+    let ret = cx.expander().fold_expr(panictry!(p.parse_expr_nopanic()));\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n@@ -826,7 +826,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        es.push(cx.expander().fold_expr(p.parse_expr()));\n+        es.push(cx.expander().fold_expr(panictry!(p.parse_expr_nopanic())));\n         if panictry!(p.eat(&token::Comma)){\n             continue;\n         }"}, {"sha": "d354a4ae2152710a472e40e03df8abef6bf28774", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -19,15 +19,14 @@ use ext::base;\n use ext::build::AstBuilder;\n use attr;\n use attr::*;\n-use parse::attr::ParserAttr;\n use parse::token;\n \n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n-    let cfg = p.parse_meta_item();\n+    let cfg = panictry!(p.parse_meta_item());\n \n     if !panictry!(p.eat(&token::Eof)){\n         cx.span_err(sp, \"expected 1 cfg-pattern\");"}, {"sha": "c56342371c84ed9a72dc305763626be38e3baea1", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -93,7 +93,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         ecx.span_err(sp, \"requires at least a format string argument\");\n         return None;\n     }\n-    let fmtstr = p.parse_expr();\n+    let fmtstr = panictry!(p.parse_expr_nopanic());\n     let mut named = false;\n     while p.token != token::Eof {\n         if !panictry!(p.eat(&token::Comma)) {\n@@ -124,7 +124,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let name: &str = &ident.name.as_str();\n \n             panictry!(p.expect(&token::Eq));\n-            let e = p.parse_expr();\n+            let e = panictry!(p.parse_expr_nopanic());\n             match names.get(name) {\n                 None => {}\n                 Some(prev) => {\n@@ -138,7 +138,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             order.push(name.to_string());\n             names.insert(name.to_string(), e);\n         } else {\n-            args.push(p.parse_expr());\n+            args.push(panictry!(p.parse_expr_nopanic()));\n         }\n     }\n     Some((fmtstr, args, order, names))"}, {"sha": "59e8533a83d3198117db470f68ca6545a5dc71c5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -327,55 +327,55 @@ pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_item<'cx>(cx: &mut ExtCtxt,\n                               sp: Span,\n                               tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_item\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n                              sp: Span,\n                              tts: &[ast::TokenTree])\n                              -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_pat\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_arm(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[ast::TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_arm\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_ty\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])\n                          -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_stmt\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_attr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])\n                          -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_attribute\",\n+    let expanded = expand_parse_call(cx, sp, \"parse_attribute_panic\",\n                                     vec!(cx.expr_bool(sp, true)), tts);\n \n     base::MacEager::expr(expanded)\n@@ -694,7 +694,7 @@ fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[ast::TokenTree])\n     let mut p = cx.new_parser_from_tts(tts);\n     p.quote_depth += 1;\n \n-    let cx_expr = p.parse_expr();\n+    let cx_expr = panictry!(p.parse_expr_nopanic());\n     if !panictry!(p.eat(&token::Comma)) {\n         panic!(p.fatal(\"expected token `,`\"));\n     }"}, {"sha": "72ba7359d4d94798ae0ce8da3945dbd982d8a7dc", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -109,13 +109,13 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n-            Some(self.p.parse_expr())\n+            Some(panictry!(self.p.parse_expr_nopanic()))\n         }\n         fn make_items(mut self: Box<ExpandResult<'a>>)\n                       -> Option<SmallVector<P<ast::Item>>> {\n             let mut ret = SmallVector::zero();\n             while self.p.token != token::Eof {\n-                match self.p.parse_item() {\n+                match panictry!(self.p.parse_item_nopanic()) {\n                     Some(item) => ret.push(item),\n                     None => panic!(self.p.span_fatal(\n                         self.p.span,"}, {"sha": "a4c99018bb9cc73f08f3e6a912081715dde8185c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -85,7 +85,6 @@ use codemap::{BytePos, mk_sp, Span};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Eof, DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Nonterminal};\n@@ -503,18 +502,18 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     // check at the beginning and the parser checks after each bump\n     panictry!(p.check_unknown_macro_variable());\n     match name {\n-        \"item\" => match p.parse_item() {\n+        \"item\" => match panictry!(p.parse_item_nopanic()) {\n             Some(i) => token::NtItem(i),\n             None => panic!(p.fatal(\"expected an item keyword\"))\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n-        \"stmt\" => match p.parse_stmt() {\n+        \"stmt\" => match panictry!(p.parse_stmt_nopanic()) {\n             Some(s) => token::NtStmt(s),\n             None => panic!(p.fatal(\"expected a statement\"))\n         },\n-        \"pat\" => token::NtPat(p.parse_pat()),\n-        \"expr\" => token::NtExpr(p.parse_expr()),\n-        \"ty\" => token::NtTy(p.parse_ty()),\n+        \"pat\" => token::NtPat(panictry!(p.parse_pat_nopanic())),\n+        \"expr\" => token::NtExpr(panictry!(p.parse_expr_nopanic())),\n+        \"ty\" => token::NtTy(panictry!(p.parse_ty_nopanic())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n             token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n@@ -527,7 +526,7 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n         \"path\" => {\n             token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n         },\n-        \"meta\" => token::NtMeta(p.parse_meta_item()),\n+        \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         _ => {\n             panic!(p.span_fatal_help(sp,\n                             &format!(\"invalid fragment specifier `{}`\", name),"}, {"sha": "a98c001dc0e60cd0baf795eb27901700adca1968", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -66,18 +66,18 @@ impl<'a> ParserAnyMacro<'a> {\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n     fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n-        let ret = self.parser.borrow_mut().parse_expr();\n+        let ret = panictry!(self.parser.borrow_mut().parse_expr_nopanic());\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n     fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n-        let ret = self.parser.borrow_mut().parse_pat();\n+        let ret = panictry!(self.parser.borrow_mut().parse_pat_nopanic());\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n     fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n-        while let Some(item) = self.parser.borrow_mut().parse_item() {\n+        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item_nopanic()) {\n             ret.push(item);\n         }\n         self.ensure_complete_parse(false);\n@@ -119,7 +119,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n     }\n \n     fn make_ty(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Ty>> {\n-        let ret = self.parser.borrow_mut().parse_ty();\n+        let ret = panictry!(self.parser.borrow_mut().parse_ty_nopanic());\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }"}, {"sha": "8b001f2419c56696b8ec3a196f267ad583e11757", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -30,7 +30,6 @@\n #![feature(filling_drop)]\n #![feature(libc)]\n #![feature(rustc_private)]\n-#![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(str_escape)]"}, {"sha": "5df2478d4875809c8fe5c6e381ba44658952913f", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -12,30 +12,21 @@ use attr;\n use ast;\n use codemap::{spanned, Spanned, mk_sp, Span};\n use parse::common::*; //resolve bug?\n+use parse::PResult;\n use parse::token;\n use parse::parser::{Parser, TokenType};\n use ptr::P;\n \n-/// A parser that can parse attributes.\n-pub trait ParserAttr {\n-    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n-    fn parse_inner_attributes(&mut self) -> Vec<ast::Attribute>;\n-    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n-    fn parse_meta_item(&mut self) -> P<ast::MetaItem>;\n-    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>>;\n-    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>>;\n-}\n-\n-impl<'a> ParserAttr for Parser<'a> {\n+impl<'a> Parser<'a> {\n     /// Parse attributes that appear before an item\n-    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n+    pub fn parse_outer_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match self.token {\n               token::Pound => {\n-                attrs.push(self.parse_attribute(false));\n+                attrs.push(try!(self.parse_attribute(false)));\n               }\n               token::DocComment(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n@@ -45,32 +36,32 @@ impl<'a> ParserAttr for Parser<'a> {\n                     self.span.hi\n                 );\n                 if attr.node.style != ast::AttrStyle::Outer {\n-                  panic!(self.fatal(\"expected outer comment\"));\n+                  return Err(self.fatal(\"expected outer comment\"));\n                 }\n                 attrs.push(attr);\n-                panictry!(self.bump());\n+                try!(self.bump());\n               }\n               _ => break\n             }\n         }\n-        return attrs;\n+        return Ok(attrs);\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`\n     ///\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n-    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n+    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<ast::Attribute> {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n-                panictry!(self.bump());\n+                try!(self.bump());\n \n                 if permit_inner { self.expected_tokens.push(TokenType::Token(token::Not)); }\n                 let style = if self.token == token::Not {\n-                    panictry!(self.bump());\n+                    try!(self.bump());\n                     if !permit_inner {\n                         let span = self.span;\n                         self.span_err(span,\n@@ -84,43 +75,43 @@ impl<'a> ParserAttr for Parser<'a> {\n                     ast::AttrStyle::Outer\n                 };\n \n-                panictry!(self.expect(&token::OpenDelim(token::Bracket)));\n-                let meta_item = self.parse_meta_item();\n+                try!(self.expect(&token::OpenDelim(token::Bracket)));\n+                let meta_item = try!(self.parse_meta_item());\n                 let hi = self.span.hi;\n-                panictry!(self.expect(&token::CloseDelim(token::Bracket)));\n+                try!(self.expect(&token::CloseDelim(token::Bracket)));\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                panic!(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n+                return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n             }\n         };\n \n         if permit_inner && self.token == token::Semi {\n-            panictry!(self.bump());\n+            try!(self.bump());\n             self.span_warn(span, \"this inner attribute syntax is deprecated. \\\n                            The new syntax is `#![foo]`, with a bang and no semicolon\");\n             style = ast::AttrStyle::Inner;\n         }\n \n-        return Spanned {\n+        Ok(Spanned {\n             span: span,\n             node: ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: style,\n                 value: value,\n                 is_sugared_doc: false\n             }\n-        };\n+        })\n     }\n \n     /// Parse attributes that appear after the opening of an item. These should\n     /// be preceded by an exclamation mark, but we accept and warn about one\n     /// terminated by a semicolon.\n \n     /// matches inner_attrs*\n-    fn parse_inner_attributes(&mut self) -> Vec<ast::Attribute> {\n+    pub fn parse_inner_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             match self.token {\n@@ -130,7 +121,7 @@ impl<'a> ParserAttr for Parser<'a> {\n                         break;\n                     }\n \n-                    let attr = self.parse_attribute(true);\n+                    let attr = try!(self.parse_attribute(true));\n                     assert!(attr.node.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n@@ -141,21 +132,21 @@ impl<'a> ParserAttr for Parser<'a> {\n                     let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n                     if attr.node.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n-                        panictry!(self.bump());\n+                        try!(self.bump());\n                     } else {\n                         break;\n                     }\n                 }\n                 _ => break\n             }\n         }\n-        attrs\n+        Ok(attrs)\n     }\n \n     /// matches meta_item = IDENT\n     /// | IDENT = lit\n     /// | IDENT meta_seq\n-    fn parse_meta_item(&mut self) -> P<ast::MetaItem> {\n+    pub fn parse_meta_item(&mut self) -> PResult<P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n             token::Interpolated(token::NtMeta(ref e)) => {\n                 Some(e.clone())\n@@ -165,19 +156,19 @@ impl<'a> ParserAttr for Parser<'a> {\n \n         match nt_meta {\n             Some(meta) => {\n-                panictry!(self.bump());\n-                return meta;\n+                try!(self.bump());\n+                return Ok(meta);\n             }\n             None => {}\n         }\n \n         let lo = self.span.lo;\n-        let ident = panictry!(self.parse_ident());\n+        let ident = try!(self.parse_ident());\n         let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::Eq => {\n-                panictry!(self.bump());\n-                let lit = panictry!(self.parse_lit());\n+                try!(self.bump());\n+                let lit = try!(self.parse_lit());\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n@@ -189,32 +180,25 @@ impl<'a> ParserAttr for Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                P(spanned(lo, hi, ast::MetaNameValue(name, lit)))\n+                Ok(P(spanned(lo, hi, ast::MetaNameValue(name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n-                let inner_items = self.parse_meta_seq();\n+                let inner_items = try!(self.parse_meta_seq());\n                 let hi = self.span.hi;\n-                P(spanned(lo, hi, ast::MetaList(name, inner_items)))\n+                Ok(P(spanned(lo, hi, ast::MetaList(name, inner_items))))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                P(spanned(lo, hi, ast::MetaWord(name)))\n+                Ok(P(spanned(lo, hi, ast::MetaWord(name))))\n             }\n         }\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n-        panictry!(self.parse_seq(&token::OpenDelim(token::Paren),\n-                       &token::CloseDelim(token::Paren),\n-                       seq_sep_trailing_allowed(token::Comma),\n-                       |p| Ok(p.parse_meta_item()))).node\n-    }\n-\n-    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>> {\n-        match self.token {\n-            token::OpenDelim(token::Paren) => self.parse_meta_seq(),\n-            _ => Vec::new()\n-        }\n+    fn parse_meta_seq(&mut self) -> PResult<Vec<P<ast::MetaItem>>> {\n+        self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n+                                 &token::CloseDelim(token::Paren),\n+                                 seq_sep_trailing_allowed(token::Comma),\n+                                 |p| p.parse_meta_item())\n     }\n }"}, {"sha": "e5e2c3a986db374b76b03711b51daf16f9eabbee", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -270,7 +270,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n-                rdr.fatal(\"unterminated block comment\");\n+                panic!(rdr.fatal(\"unterminated block comment\"));\n             }\n             if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines,"}, {"sha": "9e38ffe7f0dc423c062fa15803c42cb89d26afbc", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -11,6 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n+use diagnostic::FatalError;\n use diagnostic::SpanHandler;\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n@@ -30,7 +31,7 @@ pub trait Reader {\n     fn is_eof(&self) -> bool;\n     fn next_token(&mut self) -> TokenAndSpan;\n     /// Report a fatal error with the current span.\n-    fn fatal(&self, &str) -> !;\n+    fn fatal(&self, &str) -> FatalError;\n     /// Report a non-fatal error with the current span.\n     fn err(&self, &str);\n     fn peek(&self) -> TokenAndSpan;\n@@ -86,7 +87,7 @@ impl<'a> Reader for StringReader<'a> {\n         self.advance_token();\n         ret_val\n     }\n-    fn fatal(&self, m: &str) -> ! {\n+    fn fatal(&self, m: &str) -> FatalError {\n         self.fatal_span(self.peek_span, m)\n     }\n     fn err(&self, m: &str) {\n@@ -110,8 +111,8 @@ impl<'a> Reader for TtReader<'a> {\n         debug!(\"TtReader: r={:?}\", r);\n         r\n     }\n-    fn fatal(&self, m: &str) -> ! {\n-        panic!(self.sp_diag.span_fatal(self.cur_span, m));\n+    fn fatal(&self, m: &str) -> FatalError {\n+        self.sp_diag.span_fatal(self.cur_span, m)\n     }\n     fn err(&self, m: &str) {\n         self.sp_diag.span_err(self.cur_span, m);\n@@ -163,8 +164,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Report a fatal lexical error with a given span.\n-    pub fn fatal_span(&self, sp: Span, m: &str) -> ! {\n-        panic!(self.span_diagnostic.span_fatal(sp, m))\n+    pub fn fatal_span(&self, sp: Span, m: &str) -> FatalError {\n+        self.span_diagnostic.span_fatal(sp, m)\n     }\n \n     /// Report a lexical error with a given span.\n@@ -178,7 +179,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n-    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n+    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n         self.fatal_span(codemap::mk_sp(from_pos, to_pos), m)\n     }\n \n@@ -194,11 +195,11 @@ impl<'a> StringReader<'a> {\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n+    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> FatalError {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, &m[..]);\n+        self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -212,12 +213,12 @@ impl<'a> StringReader<'a> {\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n     /// offending string to the error message\n-    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n+    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_usize();\n         let to = self.byte_offset(to_pos).to_usize();\n         m.push_str(&self.source_text[from..to]);\n-        self.fatal_span_(from_pos, to_pos, &m[..]);\n+        self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -538,7 +539,7 @@ impl<'a> StringReader<'a> {\n                     \"unterminated block comment\"\n                 };\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, msg);\n+                panic!(self.fatal_span_(start_bpos, last_bpos, msg));\n             }\n             let n = self.curr.unwrap();\n             match n {\n@@ -682,7 +683,9 @@ impl<'a> StringReader<'a> {\n         for _ in 0..n_digits {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n+                panic!(self.fatal_span_(start_bpos,\n+                                        last_bpos,\n+                                        \"unterminated numeric character escape\"));\n             }\n             if self.curr_is(delim) {\n                 let last_bpos = self.last_pos;\n@@ -835,15 +838,15 @@ impl<'a> StringReader<'a> {\n             let c = match self.curr {\n                 Some(c) => c,\n                 None => {\n-                    self.fatal_span_(start_bpos, self.last_pos,\n-                                     \"unterminated unicode escape (found EOF)\");\n+                    panic!(self.fatal_span_(start_bpos, self.last_pos,\n+                                            \"unterminated unicode escape (found EOF)\"));\n                 }\n             };\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 if c == delim {\n-                    self.fatal_span_(self.last_pos, self.pos,\n-                                     \"unterminated unicode escape (needed a `}`)\");\n+                    panic!(self.fatal_span_(self.last_pos, self.pos,\n+                                            \"unterminated unicode escape (needed a `}`)\"));\n                 } else {\n                     self.err_span_char(self.last_pos, self.pos,\n                                    \"invalid character in unicode escape\", c);\n@@ -1077,12 +1080,12 @@ impl<'a> StringReader<'a> {\n             let valid = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'');\n             if !self.curr_is('\\'') {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_verbose(\n+                panic!(self.fatal_span_verbose(\n                                    // Byte offsetting here is okay because the\n                                    // character before position `start` is an\n                                    // ascii single quote.\n                                    start - BytePos(1), last_bpos,\n-                                   \"unterminated character constant\".to_string());\n+                                   \"unterminated character constant\".to_string()));\n             }\n             let id = if valid { self.name_from(start) } else { token::intern(\"0\") };\n             self.bump(); // advance curr past token\n@@ -1107,7 +1110,9 @@ impl<'a> StringReader<'a> {\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_bpos, \"unterminated double quote string\");\n+                    panic!(self.fatal_span_(start_bpos,\n+                                            last_bpos,\n+                                            \"unterminated double quote string\"));\n                 }\n \n                 let ch_start = self.last_pos;\n@@ -1133,14 +1138,14 @@ impl<'a> StringReader<'a> {\n \n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n+                panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n             } else if !self.curr_is('\"') {\n                 let last_bpos = self.last_pos;\n                 let curr_char = self.curr.unwrap();\n-                self.fatal_span_char(start_bpos, last_bpos,\n+                panic!(self.fatal_span_char(start_bpos, last_bpos,\n                                 \"found invalid character; \\\n                                  only `#` is allowed in raw string delimitation\",\n-                                curr_char);\n+                                curr_char));\n             }\n             self.bump();\n             let content_start_bpos = self.last_pos;\n@@ -1149,7 +1154,7 @@ impl<'a> StringReader<'a> {\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n+                    panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n                 }\n                 //if self.curr_is('\"') {\n                     //content_end_bpos = self.last_pos;\n@@ -1218,7 +1223,7 @@ impl<'a> StringReader<'a> {\n           c => {\n               let last_bpos = self.last_pos;\n               let bpos = self.pos;\n-              self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c);\n+              panic!(self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c));\n           }\n         }\n     }\n@@ -1271,9 +1276,9 @@ impl<'a> StringReader<'a> {\n             // character before position `start` are an\n             // ascii single quote and ascii 'b'.\n             let last_pos = self.last_pos;\n-            self.fatal_span_verbose(\n+            panic!(self.fatal_span_verbose(\n                 start - BytePos(2), last_pos,\n-                \"unterminated byte constant\".to_string());\n+                \"unterminated byte constant\".to_string()));\n         }\n \n         let id = if valid { self.name_from(start) } else { token::intern(\"?\") };\n@@ -1293,8 +1298,7 @@ impl<'a> StringReader<'a> {\n         while !self.curr_is('\"') {\n             if self.is_eof() {\n                 let last_pos = self.last_pos;\n-                self.fatal_span_(start, last_pos,\n-                                  \"unterminated double quote byte string\");\n+                panic!(self.fatal_span_(start, last_pos, \"unterminated double quote byte string\"));\n             }\n \n             let ch_start = self.last_pos;\n@@ -1318,14 +1322,14 @@ impl<'a> StringReader<'a> {\n \n         if self.is_eof() {\n             let last_pos = self.last_pos;\n-            self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n+            panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"));\n         } else if !self.curr_is('\"') {\n             let last_pos = self.last_pos;\n             let ch = self.curr.unwrap();\n-            self.fatal_span_char(start_bpos, last_pos,\n+            panic!(self.fatal_span_char(start_bpos, last_pos,\n                             \"found invalid character; \\\n                              only `#` is allowed in raw string delimitation\",\n-                            ch);\n+                            ch));\n         }\n         self.bump();\n         let content_start_bpos = self.last_pos;\n@@ -1334,7 +1338,7 @@ impl<'a> StringReader<'a> {\n             match self.curr {\n                 None => {\n                     let last_pos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n+                    panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"))\n                 },\n                 Some('\"') => {\n                     content_end_bpos = self.last_pos;"}, {"sha": "a468f0d1d98f1ae4b762a253d6105cc8d7d0c6d7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -13,7 +13,6 @@\n use ast;\n use codemap::{self, Span, CodeMap, FileMap};\n use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n-use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n@@ -83,7 +82,8 @@ pub fn parse_crate_attrs_from_file(\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> Vec<ast::Attribute> {\n-    new_parser_from_file(sess, cfg, input).parse_inner_attributes()\n+    // FIXME: maybe_aborted?\n+    panictry!(new_parser_from_file(sess, cfg, input).parse_inner_attributes())\n }\n \n pub fn parse_crate_from_source_str(name: String,\n@@ -107,7 +107,7 @@ pub fn parse_crate_attrs_from_source_str(name: String,\n                                            cfg,\n                                            name,\n                                            source);\n-    maybe_aborted(p.parse_inner_attributes(), p)\n+    maybe_aborted(panictry!(p.parse_inner_attributes()), p)\n }\n \n pub fn parse_expr_from_source_str(name: String,\n@@ -116,7 +116,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> P<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(p.parse_expr(), p)\n+    maybe_aborted(panictry!(p.parse_expr_nopanic()), p)\n }\n \n pub fn parse_item_from_source_str(name: String,\n@@ -125,7 +125,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> Option<P<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(p.parse_item(),p)\n+    maybe_aborted(panictry!(p.parse_item_nopanic()), p)\n }\n \n pub fn parse_meta_from_source_str(name: String,\n@@ -134,7 +134,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> P<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(p.parse_meta_item(),p)\n+    maybe_aborted(panictry!(p.parse_meta_item()), p)\n }\n \n pub fn parse_stmt_from_source_str(name: String,\n@@ -148,7 +148,7 @@ pub fn parse_stmt_from_source_str(name: String,\n         name,\n         source\n     );\n-    maybe_aborted(p.parse_stmt(), p)\n+    maybe_aborted(panictry!(p.parse_stmt_nopanic()), p)\n }\n \n // Warning: This parses with quote_depth > 0, which is not the default.\n@@ -235,7 +235,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n                 Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, &msg)),\n-                None => sess.span_diagnostic.handler().fatal(&msg)\n+                None => panic!(sess.span_diagnostic.handler().fatal(&msg))\n             }\n         }\n     }\n@@ -856,7 +856,7 @@ mod tests {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   P(Spanned{\n+                   Some(P(Spanned{\n                        node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(None, ast::Path {\n@@ -871,7 +871,7 @@ mod tests {\n                             }),\n                            span: sp(0,1)}),\n                                            ast::DUMMY_NODE_ID),\n-                       span: sp(0,1)}))\n+                       span: sp(0,1)})))\n \n     }\n "}, {"sha": "2401f6be78f9c7458efd5be3c4b1d25fb2106d98", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -63,7 +63,6 @@ use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n-use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n@@ -358,31 +357,36 @@ impl<'a> Parser<'a> {\n     }\n \n     // Panicing fns (for now!)\n-    // This is so that the quote_*!() syntax extensions\n-    pub fn parse_expr(&mut self) -> P<Expr> {\n+    // These functions are used by the quote_*!() syntax extensions, but shouldn't\n+    // be used otherwise.\n+    pub fn parse_expr_panic(&mut self) -> P<Expr> {\n         panictry!(self.parse_expr_nopanic())\n     }\n \n-    pub fn parse_item(&mut self) -> Option<P<Item>> {\n+    pub fn parse_item_panic(&mut self) -> Option<P<Item>> {\n         panictry!(self.parse_item_nopanic())\n     }\n \n-    pub fn parse_pat(&mut self) -> P<Pat> {\n+    pub fn parse_pat_panic(&mut self) -> P<Pat> {\n         panictry!(self.parse_pat_nopanic())\n     }\n \n-    pub fn parse_arm(&mut self) -> Arm {\n+    pub fn parse_arm_panic(&mut self) -> Arm {\n         panictry!(self.parse_arm_nopanic())\n     }\n \n-    pub fn parse_ty(&mut self) -> P<Ty> {\n+    pub fn parse_ty_panic(&mut self) -> P<Ty> {\n         panictry!(self.parse_ty_nopanic())\n     }\n \n-    pub fn parse_stmt(&mut self) -> Option<P<Stmt>> {\n+    pub fn parse_stmt_panic(&mut self) -> Option<P<Stmt>> {\n         panictry!(self.parse_stmt_nopanic())\n     }\n \n+    pub fn parse_attribute_panic(&mut self, permit_inner: bool) -> ast::Attribute {\n+        panictry!(self.parse_attribute(permit_inner))\n+    }\n+\n     /// Convert a token to a string using self's reader\n     pub fn token_to_string(token: &token::Token) -> String {\n         pprust::token_to_string(token)\n@@ -1173,7 +1177,7 @@ impl<'a> Parser<'a> {\n             seq_sep_none(),\n             |p| -> PResult<P<TraitItem>> {\n             maybe_whole!(no_clone p, NtTraitItem);\n-            let mut attrs = p.parse_outer_attributes();\n+            let mut attrs = try!(p.parse_outer_attributes());\n             let lo = p.span.lo;\n \n             let (name, node) = if try!(p.eat_keyword(keywords::Type)) {\n@@ -2961,7 +2965,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_arm_nopanic(&mut self) -> PResult<Arm> {\n         maybe_whole!(no_clone self, NtArm);\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let pats = try!(self.parse_pats());\n         let mut guard = None;\n         if try!(self.eat_keyword(keywords::If) ){\n@@ -3470,7 +3474,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n@@ -3612,7 +3616,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n-        Ok((self.parse_inner_attributes(),\n+        Ok((try!(self.parse_inner_attributes()),\n          try!(self.parse_block_tail(lo, DefaultBlock))))\n     }\n \n@@ -4436,7 +4440,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_impl_item(&mut self) -> PResult<P<ImplItem>> {\n         maybe_whole!(no_clone self, NtImplItem);\n \n-        let mut attrs = self.parse_outer_attributes();\n+        let mut attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let vis = try!(self.parse_visibility());\n         let (name, node) = if try!(self.eat_keyword(keywords::Type)) {\n@@ -4613,7 +4617,7 @@ impl<'a> Parser<'a> {\n             generics.where_clause = try!(self.parse_where_clause());\n \n             try!(self.expect(&token::OpenDelim(token::Brace)));\n-            let attrs = self.parse_inner_attributes();\n+            let attrs = try!(self.parse_inner_attributes());\n \n             let mut impl_items = vec![];\n             while !try!(self.eat(&token::CloseDelim(token::Brace))) {\n@@ -4732,7 +4736,7 @@ impl<'a> Parser<'a> {\n             &token::CloseDelim(token::Paren),\n             seq_sep_trailing_allowed(token::Comma),\n             |p| {\n-                let attrs = p.parse_outer_attributes();\n+                let attrs = try!(p.parse_outer_attributes());\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(try!(p.parse_visibility())),\n@@ -4774,7 +4778,7 @@ impl<'a> Parser<'a> {\n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self, allow_pub: bool) -> PResult<StructField> {\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n \n         if try!(self.eat_keyword(keywords::Pub) ){\n             if !allow_pub {\n@@ -4846,7 +4850,7 @@ impl<'a> Parser<'a> {\n             let mod_inner_lo = self.span.lo;\n             let old_owns_directory = self.owns_directory;\n             self.owns_directory = true;\n-            let attrs = self.parse_inner_attributes();\n+            let attrs = try!(self.parse_inner_attributes());\n             let m = try!(self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo));\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n@@ -4995,7 +4999,7 @@ impl<'a> Parser<'a> {\n                                               Some(name),\n                                               id_sp);\n         let mod_inner_lo = p0.span.lo;\n-        let mod_attrs = p0.parse_inner_attributes();\n+        let mod_attrs = try!(p0.parse_inner_attributes());\n         let m0 = try!(p0.parse_mod_items(&token::Eof, mod_inner_lo));\n         self.sess.included_mod_stack.borrow_mut().pop();\n         Ok((ast::ItemMod(m0), mod_attrs))\n@@ -5098,7 +5102,7 @@ impl<'a> Parser<'a> {\n \n         let abi = opt_abi.unwrap_or(abi::C);\n \n-        attrs.extend(self.parse_inner_attributes());\n+        attrs.extend(try!(self.parse_inner_attributes()));\n \n         let mut foreign_items = vec![];\n         while let Some(item) = try!(self.parse_foreign_item()) {\n@@ -5148,7 +5152,7 @@ impl<'a> Parser<'a> {\n         let mut all_nullary = true;\n         let mut any_disr = None;\n         while self.token != token::CloseDelim(token::Brace) {\n-            let variant_attrs = self.parse_outer_attributes();\n+            let variant_attrs = try!(self.parse_outer_attributes());\n             let vlo = self.span.lo;\n \n             let struct_def;\n@@ -5510,7 +5514,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a foreign item.\n     fn parse_foreign_item(&mut self) -> PResult<Option<P<ForeignItem>>> {\n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let visibility = try!(self.parse_visibility());\n \n@@ -5610,7 +5614,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_item_nopanic(&mut self) -> PResult<Option<P<Item>>> {\n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         self.parse_item_(attrs, true)\n     }\n \n@@ -5729,7 +5733,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_crate_mod(&mut self) -> PResult<Crate> {\n         let lo = self.span.lo;\n         Ok(ast::Crate {\n-            attrs: self.parse_inner_attributes(),\n+            attrs: try!(self.parse_inner_attributes()),\n             module: try!(self.parse_mod_items(&token::Eof, lo)),\n             config: self.cfg.clone(),\n             span: mk_sp(lo, self.span.lo),"}, {"sha": "57138bf26ee069040b9e588b157c03c26ad567ce", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use parse::{ParseSess,filemap_to_tts};\n+use parse::{ParseSess,PResult,filemap_to_tts};\n use parse::new_parser_from_source_str;\n use parse::parser::Parser;\n use parse::token;\n@@ -31,51 +31,49 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a>\n }\n \n fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n-    F: FnOnce(&mut Parser) -> T,\n+    F: FnOnce(&mut Parser) -> PResult<T>,\n {\n     let ps = ParseSess::new();\n     let mut p = string_to_parser(&ps, s);\n-    let x = f(&mut p);\n+    let x = panictry!(f(&mut p));\n     p.abort_if_errors();\n     x\n }\n \n /// Parse a string, return a crate.\n pub fn string_to_crate (source_str : String) -> ast::Crate {\n     with_error_checking_parse(source_str, |p| {\n-        panictry!(p.parse_crate_mod())\n+        p.parse_crate_mod()\n     })\n }\n \n /// Parse a string, return an expr\n pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_expr()\n+        p.parse_expr_nopanic()\n     })\n }\n \n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_item()\n+        p.parse_item_nopanic()\n     })\n }\n \n /// Parse a string, return a stmt\n-pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n+pub fn string_to_stmt(source_str : String) -> Option<P<ast::Stmt>> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_stmt().unwrap()\n+        p.parse_stmt_nopanic()\n     })\n }\n \n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    // Binding `sess` and `parser` works around dropck-injected\n-    // region-inference issues; see #25212, #22323, #22321.\n-    let sess = ParseSess::new();\n-    let mut parser = string_to_parser(&sess, source_str);\n-    parser.parse_pat()\n+    with_error_checking_parse(source_str, |p| {\n+        p.parse_pat_nopanic()\n+    })\n }\n \n /// Convert a vector of strings to a vector of ast::Ident's"}, {"sha": "0bb5c05aaf5bac88280fe41f9a2e19446db50ed6", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=b7fbfb658e0e3e3be37c5b6704fd6b4d5991ae8c", "patch": "@@ -54,7 +54,7 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n     // Parse an expression and emit it unchanged.\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n         cx.cfg(), tts.to_vec());\n-    let expr = parser.parse_expr();\n+    let expr = parser.parse_expr_panic();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }\n "}]}