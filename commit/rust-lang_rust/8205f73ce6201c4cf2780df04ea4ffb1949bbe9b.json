{"sha": "8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMDVmNzNjZTYyMDFjNGNmMjc4MGRmMDRlYTRmZmIxOTQ5YmJlOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T18:09:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T18:09:50Z"}, "message": "auto merge of #6001 : jld/rust/enum-nullable, r=pcwalton\n\nSpecifically: all enums with two variants, where one has zero size (and thus at most one inhabitant) and the other has a field where the null value would not be allowed (such as a safe pointer), are now represented by storing a null pointer in the field in question.\r\n\r\nThis is a generalization of representing `Option<~T>`, `Option<@T>`, and `Option<&T>` with nullable pointers, thus fixing Tony Hoare's \u201cbillion dollar mistake\u201d.", "tree": {"sha": "3d65545b4607f66b70812622324a1eaf5f999928", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d65545b4607f66b70812622324a1eaf5f999928"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "html_url": "https://github.com/rust-lang/rust/commit/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aee2567eca278c0632de09138977aa13ad0f46fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee2567eca278c0632de09138977aa13ad0f46fd", "html_url": "https://github.com/rust-lang/rust/commit/aee2567eca278c0632de09138977aa13ad0f46fd"}, {"sha": "edc1324e7e665080e6695625ba6a5ede3e32f5a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc1324e7e665080e6695625ba6a5ede3e32f5a8", "html_url": "https://github.com/rust-lang/rust/commit/edc1324e7e665080e6695625ba6a5ede3e32f5a8"}], "stats": {"total": 377, "additions": 328, "deletions": 49}, "files": [{"sha": "7db6e44adcf160983bc194f5d39f2a7793a2e880", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 150, "deletions": 36, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -29,11 +29,6 @@\n  *   that might contain one and adjust GEP indices accordingly.  See\n  *   issue #4578.\n  *\n- * - Rendering `Option<&T>` as a possibly-null `*T` instead of using\n- *   an extra word (and likewise for `@T` and `~T`).  Can and probably\n- *   should also apply to any enum with one empty case and one case\n- *   starting with a non-null pointer (e.g., `Result<(), ~str>`).\n- *\n  * - Using smaller integer types for discriminants.\n  *\n  * - Store nested enums' discriminants in the same word.  Rather, if\n@@ -54,7 +49,8 @@ use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n \n-use lib::llvm::{ValueRef, TypeRef, True};\n+use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n+use lib::llvm::llvm::LLVMDumpValue;\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -81,7 +77,20 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(~[Struct])\n+    General(~[Struct]),\n+    /**\n+     * Two cases distinguished by a nullable pointer: the case with discriminant\n+     * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n+     * field is known to be nonnull due to its type; if that field is null, then\n+     * it represents the other case, which is inhabited by at most one value\n+     * (and all other fields are undefined/unused).\n+     *\n+     * For example, `core::option::Option` instantiated at a safe pointer type\n+     * is represented such that `None` is a null pointer and `Some` is the\n+     * identity function.\n+     */\n+    NullablePointer{ nonnull: Struct, nndiscr: int, ptrfield: uint,\n+                     nullfields: ~[ty::t] }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n@@ -108,9 +117,16 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n         Some(repr) => return *repr,\n         None => { }\n     }\n-    let repr = @match ty::get(t).sty {\n+    let repr = @represent_type_uncached(cx, t);\n+    debug!(\"Represented as: %?\", repr)\n+    cx.adt_reprs.insert(t, repr);\n+    return repr;\n+}\n+\n+fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n+    match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems, false), false)\n+            return Univariant(mk_struct(cx, *elems, false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n@@ -121,45 +137,78 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n             let ftys =\n                 if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n-            Univariant(mk_struct(cx, ftys, packed), dtor)\n+            return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n+            impl Case {\n+                fn is_zerolen(&self, cx: @CrateContext) -> bool {\n+                    mk_struct(cx, self.tys, false).size == 0\n+                }\n+                fn find_ptr(&self) -> Option<uint> {\n+                    self.tys.position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+                }\n+            }\n \n             let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n                 let arg_tys = do vi.args.map |&raw_ty| {\n                     ty::subst(cx.tcx, substs, raw_ty)\n                 };\n                 Case { discr: vi.disr_val, tys: arg_tys }\n             };\n+\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                Univariant(mk_struct(cx, ~[], false), false)\n-            } else if cases.all(|c| c.tys.len() == 0) {\n+                return Univariant(mk_struct(cx, ~[], false), false);\n+            }\n+\n+            if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                CEnum(discrs.min(), discrs.max())\n-            } else if cases.len() == 1 {\n+                return CEnum(discrs.min(), discrs.max());\n+            }\n+\n+            if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n                 assert!(cases[0].discr == 0);\n-                Univariant(mk_struct(cx, cases[0].tys, false), false)\n-            } else {\n-                // The general case.  Since there's at least one\n-                // non-empty body, explicit discriminants should have\n-                // been rejected by a checker before this point.\n-                if !cases.alli(|i,c| c.discr == (i as int)) {\n-                    cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n-                                      discriminants\",\n-                                     ty::item_path_str(cx.tcx, def_id)))\n+                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+            }\n+\n+            // Since there's at least one\n+            // non-empty body, explicit discriminants should have\n+            // been rejected by a checker before this point.\n+            if !cases.alli(|i,c| c.discr == (i as int)) {\n+                cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                                  discriminants\",\n+                                 ty::item_path_str(cx.tcx, def_id)))\n+            }\n+\n+            if cases.len() == 2 {\n+                let mut discr = 0;\n+                while discr < 2 {\n+                    if cases[1 - discr].is_zerolen(cx) {\n+                        match cases[discr].find_ptr() {\n+                            Some(ptrfield) => {\n+                                return NullablePointer {\n+                                    nndiscr: discr,\n+                                    nonnull: mk_struct(cx, cases[discr].tys, false),\n+                                    ptrfield: ptrfield,\n+                                    nullfields: copy cases[1 - discr].tys\n+                                }\n+                            }\n+                            None => { }\n+                        }\n+                    }\n+                    discr += 1;\n                 }\n-                let discr = ~[ty::mk_int(cx.tcx)];\n-                General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n             }\n+\n+            // The general case.\n+            let discr = ~[ty::mk_int(cx.tcx)];\n+            return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n-    };\n-    cx.adt_reprs.insert(t, repr);\n-    return repr;\n+    }\n }\n \n fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n@@ -190,6 +239,7 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     match *r {\n         CEnum(*) => ~[T_enum_discrim(cx)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n+        NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n         General(ref sts) => {\n             // To get \"the\" type of a general enum, we pick the case\n             // with the largest alignment (so it will always align\n@@ -239,23 +289,40 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n         CEnum(*) | General(*) => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n+        }\n         Univariant(*) => {\n             (_match::single, None)\n         }\n     }\n }\n \n+\n+\n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n         Univariant(*) => C_int(bcx.ccx(), 0),\n         General(ref cases) => load_discr(bcx, scrutinee, 0,\n-                                         (cases.len() - 1) as int)\n+                                         (cases.len() - 1) as int),\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n+                 T_enum_discrim(bcx.ccx()))\n+        }\n     }\n }\n \n+fn nullable_bitdiscr(bcx: block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n+                     scrutinee: ValueRef) -> ValueRef {\n+    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n+    let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+    ICmp(bcx, cmp, llptr, C_null(llptrty))\n+}\n+\n /// Helper for cases where the discriminant is simply loaded.\n fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n     -> ValueRef {\n@@ -286,12 +353,16 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n         CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n-        Univariant(*)=> {\n+        Univariant(*) => {\n             bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n         }\n         General(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n+        NullablePointer{ _ } => {\n+            assert!(discr == 0 || discr == 1);\n+            _match::single_result(rslt(bcx, C_i1(discr != 0)))\n+        }\n     }\n }\n \n@@ -317,6 +388,13 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            if discr != nndiscr {\n+                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n+                let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+                Store(bcx, C_null(llptrty), llptrptr)\n+            }\n+        }\n     }\n }\n \n@@ -331,7 +409,10 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n             assert!(discr == 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr as uint].fields.len() - 1\n+        General(ref cases) => cases[discr as uint].fields.len() - 1,\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, _ } => {\n+            if discr == nndiscr { nonnull.fields.len() } else { 0 }\n+        }\n     }\n }\n \n@@ -352,6 +433,19 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n         General(ref cases) => {\n             struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n         }\n+        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n+            if (discr == nndiscr) {\n+                struct_field_ptr(bcx, nonnull, val, ix, false)\n+            } else {\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.g., Result or Either with () as one side.)\n+                let llty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                assert!(machine::llsize_of_alloc(bcx.ccx(), llty) == 0);\n+                // The contents of memory at this pointer can't matter, but use\n+                // the value that's \"reasonable\" in case of pointer comparison.\n+                PointerCast(bcx, val, T_ptr(llty))\n+            }\n+        }\n     }\n }\n \n@@ -420,6 +514,18 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                                               ~[C_int(ccx, discr)] + vals);\n             C_struct(contents + [padding(max_sz - case.size)])\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            if discr == nndiscr {\n+                C_struct(build_const_struct(ccx, nonnull, vals))\n+            } else {\n+                assert!(vals.len() == 0);\n+                let vals = do nonnull.fields.mapi |i, &ty| {\n+                    let llty = type_of::sizing_type_of(ccx, ty);\n+                    if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n+                };\n+                C_struct(build_const_struct(ccx, nonnull, vals))\n+            }\n+        }\n     }\n }\n \n@@ -451,10 +557,14 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n             cfields.push(padding(target_offset - offset));\n             offset = target_offset;\n         }\n-        assert!(!is_undef(vals[i]));\n-        // If that assert fails, could change it to wrap in a struct?\n-        // (See `const_struct_field` for why real fields must not be undef.)\n-        cfields.push(vals[i]);\n+        let val = if is_undef(vals[i]) {\n+            let wrapped = C_struct([vals[i]]);\n+            assert!(!is_undef(wrapped));\n+            wrapped\n+        } else {\n+            vals[i]\n+        };\n+        cfields.push(val);\n     }\n \n     return cfields;\n@@ -475,6 +585,9 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n         CEnum(*) => const_to_int(val) as int,\n         Univariant(*) => 0,\n         General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n+        NullablePointer{ nndiscr, ptrfield, _ } => {\n+            if is_null(const_struct_field(ccx, val, ptrfield)) { 1 - nndiscr } else { nndiscr }\n+        }\n     }\n }\n \n@@ -490,7 +603,8 @@ pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n     match *r {\n         CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n-        General(*) => const_struct_field(ccx, val, ix + 1)\n+        General(*) => const_struct_field(ccx, val, ix + 1),\n+        NullablePointer{ _ } => const_struct_field(ccx, val, ix)\n     }\n }\n "}, {"sha": "2d9f834040a8e70f642af308d8174ac72014c52e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -2007,6 +2007,11 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n     // XXX is there a better way to reconstruct the ty::t?\n     let repr = adt::represent_type(ccx, enum_ty);\n \n+    debug!(\"trans_enum_variant: name=%s tps=%s repr=%? enum_ty=%s\",\n+           unsafe { str::raw::from_c_str(llvm::LLVMGetValueName(llfndecl)) },\n+           ~\"[\" + str::connect(ty_param_substs.map(|&t| ty_to_str(ccx.tcx, t)), \", \") + ~\"]\",\n+           repr, ty_to_str(ccx.tcx, enum_ty));\n+\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n     for vec::eachi(args) |i, va| {\n         let lldestptr = adt::trans_field_ptr(bcx,"}, {"sha": "83fe135d8721f4e6fe2d270488bc2c67d95434c5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -1304,17 +1304,48 @@ pub fn is_undef(val: ValueRef) -> bool {\n     }\n }\n \n+pub fn is_null(val: ValueRef) -> bool {\n+    unsafe {\n+        llvm::LLVMIsNull(val) != False\n+    }\n+}\n+\n // Used to identify cached monomorphized functions and vtables\n #[deriving(Eq)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<~[mono_id]>),\n     mono_any,\n     mono_repr(uint /* size */,\n               uint /* align */,\n-              bool /* is_float */,\n+              MonoDataClass,\n               datum::DatumMode),\n }\n \n+#[deriving(Eq)]\n+pub enum MonoDataClass {\n+    MonoBits,    // Anything not treated differently from arbitrary integer data\n+    MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n+    // FIXME(#3547)---scalars and floats are\n+    // treated differently in most ABIs.  But we\n+    // should be doing something more detailed\n+    // here.\n+    MonoFloat\n+}\n+\n+pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n+    match ty::get(t).sty {\n+        ty::ty_float(_) => MonoFloat,\n+        ty::ty_rptr(*) | ty::ty_uniq(*) |\n+        ty::ty_box(*) | ty::ty_opaque_box(*) |\n+        ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) |\n+        ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_bare_fn(*) => MonoNonNull,\n+        // Is that everything?  Would closures or slices qualify?\n+        _ => MonoBits\n+    }\n+}\n+\n+\n #[deriving(Eq)]\n pub struct mono_id_ {\n     def: ast::def_id,\n@@ -1338,6 +1369,12 @@ impl to_bytes::IterBytes for mono_param_id {\n     }\n }\n \n+impl to_bytes::IterBytes for MonoDataClass {\n+    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl to_bytes::IterBytes for mono_id_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);"}, {"sha": "a0fcdf7fde8bd1e0f705c6f8556a0fd353060c5f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -395,22 +395,14 @@ pub fn make_mono_id(ccx: @CrateContext,\n                             let size = machine::llbitsize_of_real(ccx, llty);\n                             let align = machine::llalign_of_pref(ccx, llty);\n                             let mode = datum::appropriate_mode(subst);\n-\n-                            // FIXME(#3547)---scalars and floats are\n-                            // treated differently in most ABIs.  But we\n-                            // should be doing something more detailed\n-                            // here.\n-                            let is_float = match ty::get(subst).sty {\n-                                ty::ty_float(_) => true,\n-                                _ => false\n-                            };\n+                            let data_class = mono_data_classify(subst);\n \n                             // Special value for nil to prevent problems\n                             // with undef return pointers.\n                             if size <= 8u && ty::type_is_nil(subst) {\n-                                mono_repr(0u, 0u, is_float, mode)\n+                                mono_repr(0u, 0u, data_class, mode)\n                             } else {\n-                                mono_repr(size, align, is_float, mode)\n+                                mono_repr(size, align, data_class, mode)\n                             }\n                         } else {\n                             mono_precise(subst, None)"}, {"sha": "2e9f0d21fe321849a4759a01fc28eae82ef196d6", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -1 +1 @@\n-Subproject commit 56dd407f4f97a01b8df6554c569170d2fc276fcb\n+Subproject commit 2e9f0d21fe321849a4759a01fc28eae82ef196d6"}, {"sha": "0c4d297403cfb8d3996e49b7e73347cdc2a199d3", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::{option, cast};\n+\n+// Iota-reduction is a rule in the Calculus of (Co-)Inductive Constructions,\n+// which \"says that a destructor applied to an object built from a constructor\n+// behaves as expected\".  -- http://coq.inria.fr/doc/Reference-Manual006.html\n+//\n+// It's a little more complicated here, because of pointers and regions and\n+// trying to get assert failure messages that at least identify which case\n+// failed.\n+\n+enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n+impl<T> E<T> {\n+    fn is_none(&self) -> bool { \n+        match *self {\n+            Thing(*) => false,\n+            Nothing(*) => true\n+        }\n+    }\n+    fn get_ref<'r>(&'r self) -> (int, &'r T) {\n+        match *self {\n+            Nothing(*) => fail!(fmt!(\"E::get_ref(Nothing::<%s>)\",  stringify!($T))),\n+            Thing(x, ref y) => (x, y)\n+        }\n+    }\n+}\n+\n+macro_rules! check_option {\n+    ($e:expr: $T:ty) => {{\n+        // FIXME #6000: remove the copy\n+        check_option!(copy $e: $T, |ptr| assert!(*ptr == $e));\n+    }};\n+    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+        assert!(option::None::<$T>.is_none());\n+        let s_ = option::Some::<$T>($e);\n+        let $v = s_.get_ref();\n+        $chk\n+    }}\n+}\n+\n+macro_rules! check_fancy {\n+    ($e:expr: $T:ty) => {{\n+        // FIXME #6000: remove the copy\n+        check_fancy!(copy $e: $T, |ptr| assert!(*ptr == $e));\n+    }};\n+    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+        assert!(Nothing::<$T>((), ((), ()), [23i8, ..0]).is_none());\n+        let t_ = Thing::<$T>(23, $e);\n+        match t_.get_ref() {\n+            (23, $v) => { $chk }\n+            _ => fail!(fmt!(\"Thing::<%s>(23, %s).get_ref() != (23, _)\",\n+                            stringify!($T), stringify!($e)))\n+        }\n+    }}\n+}\n+\n+macro_rules! check_type {\n+    ($($a:tt)*) => {{\n+        check_option!($($a)*);\n+        check_fancy!($($a)*);\n+    }}\n+}\n+\n+pub fn main() {\n+    check_type!(&17: &int);\n+    check_type!(~18: ~int);\n+    check_type!(@19: @int);\n+    check_type!(~\"foo\": ~str);\n+    check_type!(@\"bar\": @str);\n+    check_type!(~[]: ~[int]);\n+    check_type!(~[20, 22]: ~[int]);\n+    check_type!(@[]: @[int]);\n+    check_type!(@[24, 26]: @[int]);\n+    let mint: uint = unsafe { cast::transmute(main) };\n+    check_type!(main: extern fn(), |pthing| {\n+        assert!(mint == unsafe { cast::transmute(*pthing) })\n+    });\n+}"}, {"sha": "246fc4e304df383420b25317055a790629fff4e1", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8205f73ce6201c4cf2780df04ea4ffb1949bbe9b/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=8205f73ce6201c4cf2780df04ea4ffb1949bbe9b", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n+struct S<T>(int, T);\n+\n+// These are macros so we get useful assert messages.\n+\n+macro_rules! check_option {\n+    ($T:ty) => {\n+        assert!(sys::size_of::<Option<$T>>() == sys::size_of::<$T>());\n+    }\n+}\n+\n+macro_rules! check_fancy {\n+    ($T:ty) => {\n+        assert!(sys::size_of::<E<$T>>() == sys::size_of::<S<$T>>());\n+    }\n+}\n+\n+macro_rules! check_type {\n+    ($T:ty) => {{\n+        check_option!($T);\n+        check_fancy!($T);\n+    }}\n+}\n+\n+pub fn main() {\n+    check_type!(&'static int);\n+    check_type!(~int);\n+    check_type!(@int);\n+    check_type!(~str);\n+    check_type!(@str);\n+    check_type!(~[int]);\n+    check_type!(@[int]);\n+    check_type!(extern fn());\n+}"}]}