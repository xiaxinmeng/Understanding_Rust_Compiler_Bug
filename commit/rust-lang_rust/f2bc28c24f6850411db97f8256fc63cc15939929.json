{"sha": "f2bc28c24f6850411db97f8256fc63cc15939929", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYmMyOGMyNGY2ODUwNDExZGI5N2Y4MjU2ZmM2M2NjMTU5Mzk5Mjk=", "commit": {"author": {"name": "Matthijs Hofstra", "email": "thiezz@gmail.com", "date": "2013-03-28T19:13:38Z"}, "committer": {"name": "Matthijs Hofstra", "email": "thiezz@gmail.com", "date": "2013-04-02T19:15:11Z"}, "message": "Removed all uses of Mut from workcache, replaced with @mut", "tree": {"sha": "8c80cd908d4d4ba537ebddfdd980635e3289417e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c80cd908d4d4ba537ebddfdd980635e3289417e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2bc28c24f6850411db97f8256fc63cc15939929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2bc28c24f6850411db97f8256fc63cc15939929", "html_url": "https://github.com/rust-lang/rust/commit/f2bc28c24f6850411db97f8256fc63cc15939929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2bc28c24f6850411db97f8256fc63cc15939929/comments", "author": {"login": "Thiez", "id": 204550, "node_id": "MDQ6VXNlcjIwNDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/204550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thiez", "html_url": "https://github.com/Thiez", "followers_url": "https://api.github.com/users/Thiez/followers", "following_url": "https://api.github.com/users/Thiez/following{/other_user}", "gists_url": "https://api.github.com/users/Thiez/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thiez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thiez/subscriptions", "organizations_url": "https://api.github.com/users/Thiez/orgs", "repos_url": "https://api.github.com/users/Thiez/repos", "events_url": "https://api.github.com/users/Thiez/events{/privacy}", "received_events_url": "https://api.github.com/users/Thiez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Thiez", "id": 204550, "node_id": "MDQ6VXNlcjIwNDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/204550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thiez", "html_url": "https://github.com/Thiez", "followers_url": "https://api.github.com/users/Thiez/followers", "following_url": "https://api.github.com/users/Thiez/following{/other_user}", "gists_url": "https://api.github.com/users/Thiez/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thiez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thiez/subscriptions", "organizations_url": "https://api.github.com/users/Thiez/orgs", "repos_url": "https://api.github.com/users/Thiez/repos", "events_url": "https://api.github.com/users/Thiez/events{/privacy}", "received_events_url": "https://api.github.com/users/Thiez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca52d08c4b62a8e501387d305eea1ccccaeb3984", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca52d08c4b62a8e501387d305eea1ccccaeb3984", "html_url": "https://github.com/rust-lang/rust/commit/ca52d08c4b62a8e501387d305eea1ccccaeb3984"}], "stats": {"total": 132, "additions": 60, "deletions": 72}, "files": [{"sha": "6ed1364d7fcb208e7efee3671e6edd2c6b0dab39", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 60, "deletions": 72, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f2bc28c24f6850411db97f8256fc63cc15939929/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2bc28c24f6850411db97f8256fc63cc15939929/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=f2bc28c24f6850411db97f8256fc63cc15939929", "patch": "@@ -27,7 +27,6 @@ use core::run;\n use core::hashmap::linear::LinearMap;\n use core::task;\n use core::to_bytes;\n-use core::mutable::Mut;\n \n /**\n *\n@@ -168,7 +167,7 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n struct Database {\n     db_filename: Path,\n     db_cache: LinearMap<~str, ~str>,\n-    mut db_dirty: bool\n+    db_dirty: bool\n }\n \n pub impl Database {\n@@ -210,8 +209,8 @@ pub impl Logger {\n }\n \n struct Context {\n-    db: @Mut<Database>,\n-    logger: @Mut<Logger>,\n+    db: @mut Database,\n+    logger: @mut Logger,\n     cfg: @json::Object,\n     freshness: LinearMap<~str,@fn(&str,&str)->bool>\n }\n@@ -228,7 +227,7 @@ struct Exec {\n }\n \n struct Work<T> {\n-    prep: @Mut<Prep>,\n+    prep: @mut Prep,\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n@@ -261,8 +260,8 @@ fn digest_file(path: &Path) -> ~str {\n \n pub impl Context {\n \n-    fn new(db: @Mut<Database>,\n-                  lg: @Mut<Logger>,\n+    fn new(db: @mut Database,\n+                  lg: @mut Logger,\n                   cfg: @json::Object) -> Context {\n         Context {\n             db: db,\n@@ -277,19 +276,19 @@ pub impl Context {\n               Decodable<json::Decoder>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n-                  blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n-        let p = @Mut(Prep {\n+                  blk: &fn(@mut Prep)->Work<T>) -> Work<T> {\n+        let p = @mut Prep {\n             ctxt: self,\n             fn_name: fn_name.to_owned(),\n             declared_inputs: WorkMap::new()\n-        });\n+        };\n         blk(p)\n     }\n }\n \n \n trait TPrep {\n-    fn declare_input(&self, kind:&str, name:&str, val:&str);\n+    fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n     fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n     fn exec<T:Owned +\n@@ -298,30 +297,25 @@ trait TPrep {\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n-impl TPrep for @Mut<Prep> {\n-    fn declare_input(&self, kind:&str, name:&str, val:&str) {\n-        do self.borrow_mut |p| {\n-            p.declared_inputs.insert(WorkKey::new(kind, name),\n-                                     val.to_owned());\n-        }\n+impl TPrep for Prep {\n+    fn declare_input(&mut self, kind:&str, name:&str, val:&str) {\n+        self.declared_inputs.insert(WorkKey::new(kind, name),\n+                                 val.to_owned());\n     }\n \n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n-        do self.borrow_imm |p| {\n-            let k = kind.to_owned();\n-            let f = (*p.ctxt.freshness.get(&k))(name, val);\n-            do p.ctxt.logger.borrow_imm |lg| {\n-                if f {\n-                    lg.info(fmt!(\"%s %s:%s is fresh\",\n-                                 cat, kind, name));\n-                } else {\n-                    lg.info(fmt!(\"%s %s:%s is not fresh\",\n-                                 cat, kind, name))\n-                }\n+        let k = kind.to_owned();\n+        let f = (*self.ctxt.freshness.get(&k))(name, val);\n+        let lg = self.ctxt.logger;\n+            if f {\n+                lg.info(fmt!(\"%s %s:%s is fresh\",\n+                             cat, kind, name));\n+            } else {\n+                lg.info(fmt!(\"%s %s:%s is not fresh\",\n+                             cat, kind, name))\n             }\n-            f\n-        }\n+        f\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n@@ -339,38 +333,34 @@ impl TPrep for @Mut<Prep> {\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n-        do self.borrow_imm |p| {\n-            let cached = do p.ctxt.db.borrow_mut |db| {\n-                db.prepare(p.fn_name, &p.declared_inputs)\n-            };\n+        let cached = self.ctxt.db.prepare(self.fn_name, &self.declared_inputs);\n \n-            match cached {\n-                Some((ref disc_in, ref disc_out, ref res))\n-                if self.all_fresh(\"declared input\",\n-                                  &p.declared_inputs) &&\n-                self.all_fresh(\"discovered input\", disc_in) &&\n-                self.all_fresh(\"discovered output\", disc_out) => {\n-                    Work::new(*self, Left(json_decode(*res)))\n-                }\n+        match cached {\n+            Some((ref disc_in, ref disc_out, ref res))\n+            if self.all_fresh(\"declared input\",\n+                              &self.declared_inputs) &&\n+            self.all_fresh(\"discovered input\", disc_in) &&\n+            self.all_fresh(\"discovered output\", disc_out) => {\n+                Work::new(@mut *self, Left(json_decode(*res)))\n+            }\n \n-                _ => {\n-                    let (chan, port) = oneshot::init();\n-                    let mut blk = None;\n-                    blk <-> bo;\n-                    let blk = blk.unwrap();\n-                    let chan = Cell(chan);\n-                    do task::spawn || {\n-                        let exe = Exec {\n-                            discovered_inputs: WorkMap::new(),\n-                            discovered_outputs: WorkMap::new(),\n-                        };\n-                        let chan = chan.take();\n-                        let v = blk(&exe);\n-                        send_one(chan, (exe, v));\n-                    }\n-\n-                    Work::new(*self, Right(port))\n+            _ => {\n+                let (chan, port) = oneshot::init();\n+                let mut blk = None;\n+                blk <-> bo;\n+                let blk = blk.unwrap();\n+                let chan = Cell(chan);\n+\n+                do task::spawn || {\n+                    let exe = Exec {\n+                        discovered_inputs: WorkMap::new(),\n+                        discovered_outputs: WorkMap::new(),\n+                    };\n+                    let chan = chan.take();\n+                    let v = blk(&exe);\n+                    send_one(chan, (exe, v));\n                 }\n+                Work::new(@mut *self, Right(port))\n             }\n         }\n     }\n@@ -379,7 +369,7 @@ impl TPrep for @Mut<Prep> {\n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n          Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+    fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }\n@@ -404,15 +394,13 @@ fn unwrap<T:Owned +\n \n             let s = json_encode(&v);\n \n-            do ww.prep.borrow_imm |p| {\n-                do p.ctxt.db.borrow_mut |db| {\n-                    db.cache(p.fn_name,\n-                             &p.declared_inputs,\n-                             &exe.discovered_inputs,\n-                             &exe.discovered_outputs,\n-                             s);\n-                }\n-            }\n+            let p = &*ww.prep;\n+            let db = p.ctxt.db;\n+            db.cache(p.fn_name,\n+                 &p.declared_inputs,\n+                 &exe.discovered_inputs,\n+                 &exe.discovered_outputs,\n+                 s);\n             v\n         }\n     }\n@@ -422,10 +410,10 @@ fn unwrap<T:Owned +\n fn test() {\n     use core::io::WriterUtil;\n \n-    let db = @Mut(Database { db_filename: Path(\"db.json\"),\n+    let db = @mut Database { db_filename: Path(\"db.json\"),\n                              db_cache: LinearMap::new(),\n-                             db_dirty: false });\n-    let lg = @Mut(Logger { a: () });\n+                             db_dirty: false };\n+    let lg = @mut Logger { a: () };\n     let cfg = @LinearMap::new();\n     let cx = @Context::new(db, lg, cfg);\n     let w:Work<~str> = do cx.prep(\"test1\") |prep| {"}]}