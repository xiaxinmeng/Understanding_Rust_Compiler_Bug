{"sha": "3682a06dcff54a6b9188fd4395e26b316c7652f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ODJhMDZkY2ZmNTRhNmI5MTg4ZmQ0Mzk1ZTI2YjMxNmM3NjUyZjc=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-01-22T14:30:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-22T14:30:19Z"}, "message": "Rollup merge of #81236 - estebank:everybody-loop-now, r=oli-obk\n\nGracefully handle loop labels missing leading `'` in different positions\n\nFix #81192.\n\n* Account for labels when suggesting `loop` instead of `while true`\n* Suggest `'a` when given `a` only when appropriate\n* Add loop head span to hir\n* Tweak error for invalid `break expr`\n* Add more misspelled label tests\n* Avoid emitting redundant \"unused label\" lint\n* Parse loop labels missing a leading `'`\n\nEach commit can be reviewed in isolation.", "tree": {"sha": "6a70f0305b8249f6234af4a372220a7d4745b05e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a70f0305b8249f6234af4a372220a7d4745b05e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3682a06dcff54a6b9188fd4395e26b316c7652f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgCuF7CRBK7hj4Ov3rIwAAdHIIAAtbwmMX2D+DaPWtvlMvJT/D\nAqfwVQjUuLJFHjiORJxj0+7jzTP1zYo2jT2o5uSCVjbAYX1f2bOm9mW4nEhva7gw\n/+plP4a/gDLKlS62UyHsaSXlsCUXT/SxdH5lf0loOZxBEp4pwT00PhSA+1uqlkOG\nkpIf7xWyRf5MnnpUlCVqXUyoSSo+hghwgAPTKQID8GQkbuD+nOkqvdBk2DtcJrg/\nRVQal6voNhmMakdmVN7gX0b2ofjZKnrS6tOn5S17ZRDiTwPYXuCPr0/zu8jBZTdw\nekTH3VH6t0uQ9GJBhexOX/Kx0VCkLXhYX8dgKHEuUIq97aULRgBr8/tVXnOS5Kw=\n=B2EG\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a70f0305b8249f6234af4a372220a7d4745b05e\nparent 81a60b7aa8dca83e2c9543390cf116016192871a\nparent 9e82329c8f621e59833f4e2d747acdd83b188054\nauthor Mara Bos <m-ou.se@m-ou.se> 1611325819 +0000\ncommitter GitHub <noreply@github.com> 1611325819 +0000\n\nRollup merge of #81236 - estebank:everybody-loop-now, r=oli-obk\n\nGracefully handle loop labels missing leading `'` in different positions\n\nFix #81192.\n\n* Account for labels when suggesting `loop` instead of `while true`\n* Suggest `'a` when given `a` only when appropriate\n* Add loop head span to hir\n* Tweak error for invalid `break expr`\n* Add more misspelled label tests\n* Avoid emitting redundant \"unused label\" lint\n* Parse loop labels missing a leading `'`\n\nEach commit can be reviewed in isolation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3682a06dcff54a6b9188fd4395e26b316c7652f7", "html_url": "https://github.com/rust-lang/rust/commit/3682a06dcff54a6b9188fd4395e26b316c7652f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3682a06dcff54a6b9188fd4395e26b316c7652f7/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a60b7aa8dca83e2c9543390cf116016192871a", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a60b7aa8dca83e2c9543390cf116016192871a", "html_url": "https://github.com/rust-lang/rust/commit/81a60b7aa8dca83e2c9543390cf116016192871a"}, {"sha": "9e82329c8f621e59833f4e2d747acdd83b188054", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e82329c8f621e59833f4e2d747acdd83b188054", "html_url": "https://github.com/rust-lang/rust/commit/9e82329c8f621e59833f4e2d747acdd83b188054"}], "stats": {"total": 660, "additions": 522, "deletions": 138}, "files": [{"sha": "31360158e2b4e3afc5ccda8ee96f67cd5e8fc540", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -10,9 +10,9 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_session::parse::feature_err;\n-use rustc_span::hygiene::ForLoopLoc;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -102,6 +102,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_block(body, false),\n                         opt_label,\n                         hir::LoopSource::Loop,\n+                        DUMMY_SP,\n                     )\n                 }),\n                 ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n@@ -453,7 +454,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             self.expr_match(span, scrutinee, arena_vec![self; then_arm, else_arm], desugar);\n \n         // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(self.block_expr(self.arena.alloc(match_expr)), opt_label, source)\n+        hir::ExprKind::Loop(\n+            self.block_expr(self.arena.alloc(match_expr)),\n+            opt_label,\n+            source,\n+            span.with_hi(cond.span.hi()),\n+        )\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n@@ -748,7 +754,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // loop { .. }\n         let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: loop_hir_id,\n-            kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop),\n+            kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop, span),\n             span,\n             attrs: ThinVec::new(),\n         });\n@@ -1709,7 +1715,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         // `[opt_ident]: loop { ... }`\n-        let kind = hir::ExprKind::Loop(loop_block, opt_label, hir::LoopSource::ForLoop);\n+        let kind = hir::ExprKind::Loop(\n+            loop_block,\n+            opt_label,\n+            hir::LoopSource::ForLoop,\n+            e.span.with_hi(orig_head_span.hi()),\n+        );\n         let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n             kind,"}, {"sha": "35170fa7c1d0250cd27e7430b13a0b61c3fcf927", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1617,7 +1617,9 @@ pub enum ExprKind<'hir> {\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n-    Loop(&'hir Block<'hir>, Option<Label>, LoopSource),\n+    ///\n+    /// The `Span` is the loop header (`for x in y`/`while let pat = expr`).\n+    Loop(&'hir Block<'hir>, Option<Label>, LoopSource, Span),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),"}, {"sha": "6c1bee2335a00552c8a260ebe887546f5ca72243", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1151,7 +1151,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(then);\n             walk_list!(visitor, visit_expr, else_opt);\n         }\n-        ExprKind::Loop(ref block, ref opt_label, _) => {\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }"}, {"sha": "f1c2a6b7e6e85af5f75e70c3e8089d836f66ffbe", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1396,7 +1396,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));\n             }\n-            hir::ExprKind::Loop(ref blk, opt_label, _) => {\n+            hir::ExprKind::Loop(ref blk, opt_label, _, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "b37660e4a90d3bb46b8b2656ae078dd55f327f62", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -96,18 +96,24 @@ fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n \n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::While(cond, ..) = &e.kind {\n+        if let ast::ExprKind::While(cond, _, label) = &e.kind {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n                 if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.sess.source_map().guess_head_span(e.span);\n+                        let condition_span = e.span.with_hi(cond.span.hi());\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                             lint.build(msg)\n                                 .span_suggestion_short(\n                                     condition_span,\n                                     \"use `loop`\",\n-                                    \"loop\".to_owned(),\n+                                    format!(\n+                                        \"{}loop\",\n+                                        label.map_or_else(String::new, |label| format!(\n+                                            \"{}: \",\n+                                            label.ident,\n+                                        ))\n+                                    ),\n                                     Applicability::MachineApplicable,\n                                 )\n                                 .emit();"}, {"sha": "2962cbe8157f64b0f98bcbe710b36d7ec99388a1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -546,9 +546,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             scrutinee: discr.to_ref(),\n             arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n         },\n-        hir::ExprKind::Loop(ref body, _, _) => {\n-            ExprKind::Loop { body: block::to_expr_ref(cx, body) }\n-        }\n+        hir::ExprKind::Loop(ref body, ..) => ExprKind::Loop { body: block::to_expr_ref(cx, body) },\n         hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n             lhs: source.to_ref(),\n             name: Field::new(cx.tcx.field_index(expr.hir_id, cx.typeck_results)),"}, {"sha": "cfd7ad48222a25a5c2fb97d619deace7689f2037", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -585,7 +585,7 @@ impl<'a> Parser<'a> {\n         lhs_span: Span,\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n-        let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n+        let mk_expr = |this: &mut Self, lhs: P<Expr>, rhs: P<Ty>| {\n             this.mk_expr(\n                 this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n                 expr_kind(lhs, rhs),\n@@ -597,13 +597,49 @@ impl<'a> Parser<'a> {\n         // LessThan comparison after this cast.\n         let parser_snapshot_before_type = self.clone();\n         let cast_expr = match self.parse_ty_no_plus() {\n-            Ok(rhs) => mk_expr(self, rhs),\n+            Ok(rhs) => mk_expr(self, lhs, rhs),\n             Err(mut type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n                 let parser_snapshot_after_type = mem::replace(self, parser_snapshot_before_type);\n \n+                // Check for typo of `'a: loop { break 'a }` with a missing `'`.\n+                match (&lhs.kind, &self.token.kind) {\n+                    (\n+                        // `foo: `\n+                        ExprKind::Path(None, ast::Path { segments, .. }),\n+                        TokenKind::Ident(kw::For | kw::Loop | kw::While, false),\n+                    ) if segments.len() == 1 => {\n+                        let snapshot = self.clone();\n+                        let label = Label {\n+                            ident: Ident::from_str_and_span(\n+                                &format!(\"'{}\", segments[0].ident),\n+                                segments[0].ident.span,\n+                            ),\n+                        };\n+                        match self.parse_labeled_expr(label, AttrVec::new(), false) {\n+                            Ok(expr) => {\n+                                type_err.cancel();\n+                                self.struct_span_err(label.ident.span, \"malformed loop label\")\n+                                    .span_suggestion(\n+                                        label.ident.span,\n+                                        \"use the correct loop label format\",\n+                                        label.ident.to_string(),\n+                                        Applicability::MachineApplicable,\n+                                    )\n+                                    .emit();\n+                                return Ok(expr);\n+                            }\n+                            Err(mut err) => {\n+                                err.cancel();\n+                                *self = snapshot;\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n                         let (op_noun, op_verb) = match self.token.kind {\n@@ -630,7 +666,8 @@ impl<'a> Parser<'a> {\n                             op_noun,\n                         );\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr = mk_expr(self, self.mk_ty(path.span, TyKind::Path(None, path)));\n+                        let expr =\n+                            mk_expr(self, lhs, self.mk_ty(path.span, TyKind::Path(None, path)));\n \n                         let expr_str = self\n                             .span_to_snippet(expr.span)\n@@ -1067,7 +1104,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::While) {\n             self.parse_while_expr(None, self.prev_token.span, attrs)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, attrs)\n+            self.parse_labeled_expr(label, attrs, true)\n         } else if self.eat_keyword(kw::Loop) {\n             self.parse_loop_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::Continue) {\n@@ -1228,7 +1265,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_labeled_expr(\n+        &mut self,\n+        label: Label,\n+        attrs: AttrVec,\n+        consume_colon: bool,\n+    ) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n         let label = Some(label);\n         let ate_colon = self.eat(&token::Colon);\n@@ -1247,7 +1289,7 @@ impl<'a> Parser<'a> {\n             self.parse_expr()\n         }?;\n \n-        if !ate_colon {\n+        if !ate_colon && consume_colon {\n             self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n         }\n "}, {"sha": "8950f9b33b6dac3ee4d1084d27839a3eca5de028", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -199,7 +199,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n             // Skip the following checks if we are not currently in a const context.\n             _ if self.const_kind.is_none() => {}\n \n-            hir::ExprKind::Loop(_, _, source) => {\n+            hir::ExprKind::Loop(_, _, source, _) => {\n                 self.const_check_violated(NonConstExpr::Loop(*source), e.span);\n             }\n "}, {"sha": "c11dc231d482c446ee672934fc472b4ece4bd391", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident\n-            hir::ExprKind::Loop(ref blk, _, _) => self.propagate_through_loop(expr, &blk, succ),\n+            hir::ExprKind::Loop(ref blk, ..) => self.propagate_through_loop(expr, &blk, succ),\n \n             hir::ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 //"}, {"sha": "4bfac1b72983eba1db0c674e346a9fa9ec7a49ea", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n         match e.kind {\n-            hir::ExprKind::Loop(ref b, _, source) => {\n+            hir::ExprKind::Loop(ref b, _, source, _) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Closure(_, ref function_decl, b, span, movability) => {\n@@ -68,18 +68,18 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Break(label, ref opt_expr) => {\n+            hir::ExprKind::Break(break_label, ref opt_expr) => {\n                 if let Some(e) = opt_expr {\n                     self.visit_expr(e);\n                 }\n \n-                if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n+                if self.require_label_in_labeled_block(e.span, &break_label, \"break\") {\n                     // If we emitted an error about an unlabeled break in a labeled\n                     // block, we don't need any further checking for this break any more\n                     return;\n                 }\n \n-                let loop_id = match label.target_id {\n+                let loop_id = match break_label.target_id {\n                     Ok(loop_id) => Some(loop_id),\n                     Err(hir::LoopIdError::OutsideLoopScope) => None,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n@@ -89,49 +89,89 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Err(hir::LoopIdError::UnresolvedLabel) => None,\n                 };\n \n-                if let Some(loop_id) = loop_id {\n-                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n-                        return;\n-                    }\n+                if let Some(Node::Block(_)) = loop_id.and_then(|id| self.hir_map.find(id)) {\n+                    return;\n                 }\n \n-                if opt_expr.is_some() {\n-                    let loop_kind = if let Some(loop_id) = loop_id {\n-                        Some(match self.hir_map.expect_expr(loop_id).kind {\n-                            hir::ExprKind::Loop(_, _, source) => source,\n+                if let Some(break_expr) = opt_expr {\n+                    let (head, loop_label, loop_kind) = if let Some(loop_id) = loop_id {\n+                        match self.hir_map.expect_expr(loop_id).kind {\n+                            hir::ExprKind::Loop(_, label, source, sp) => {\n+                                (Some(sp), label, Some(source))\n+                            }\n                             ref r => {\n                                 span_bug!(e.span, \"break label resolved to a non-loop: {:?}\", r)\n                             }\n-                        })\n+                        }\n                     } else {\n-                        None\n+                        (None, None, None)\n                     };\n                     match loop_kind {\n                         None | Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n-                            struct_span_err!(\n+                            let mut err = struct_span_err!(\n                                 self.sess,\n                                 e.span,\n                                 E0571,\n                                 \"`break` with value from a `{}` loop\",\n                                 kind.name()\n-                            )\n-                            .span_label(\n+                            );\n+                            err.span_label(\n                                 e.span,\n-                                \"can only break with a value inside \\\n-                                            `loop` or breakable block\",\n-                            )\n-                            .span_suggestion(\n+                                \"can only break with a value inside `loop` or breakable block\",\n+                            );\n+                            if let Some(head) = head {\n+                                err.span_label(\n+                                    head,\n+                                    &format!(\n+                                        \"you can't `break` with a value in a `{}` loop\",\n+                                        kind.name()\n+                                    ),\n+                                );\n+                            }\n+                            err.span_suggestion(\n                                 e.span,\n                                 &format!(\n-                                    \"instead, use `break` on its own \\\n-                                        without a value inside this `{}` loop\",\n-                                    kind.name()\n+                                    \"use `break` on its own without a value inside this `{}` loop\",\n+                                    kind.name(),\n+                                ),\n+                                format!(\n+                                    \"break{}\",\n+                                    break_label\n+                                        .label\n+                                        .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n                                 ),\n-                                \"break\".to_string(),\n                                 Applicability::MaybeIncorrect,\n-                            )\n-                            .emit();\n+                            );\n+                            if let (Some(label), None) = (loop_label, break_label.label) {\n+                                match break_expr.kind {\n+                                    hir::ExprKind::Path(hir::QPath::Resolved(\n+                                        None,\n+                                        hir::Path {\n+                                            segments: [segment],\n+                                            res: hir::def::Res::Err,\n+                                            ..\n+                                        },\n+                                    )) if label.ident.to_string()\n+                                        == format!(\"'{}\", segment.ident) =>\n+                                    {\n+                                        // This error is redundant, we will have already emitted a\n+                                        // suggestion to use the label when `segment` wasn't found\n+                                        // (hence the `Res::Err` check).\n+                                        err.delay_as_bug();\n+                                    }\n+                                    _ => {\n+                                        err.span_suggestion(\n+                                            break_expr.span,\n+                                            \"alternatively, you might have meant to use the \\\n+                                             available loop label\",\n+                                            label.ident.to_string(),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                            err.emit();\n                         }\n                     }\n                 }"}, {"sha": "64356f73f6c65f6e76c74249a4d1f6cdbedc2c18", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -252,7 +252,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Loop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n "}, {"sha": "eaeb28388d4f0e1fd082b8da863efd191cb24356", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -2266,6 +2266,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 visit::walk_expr(self, expr);\n             }\n \n+            ExprKind::Break(None, Some(ref e)) => {\n+                // We use this instead of `visit::walk_expr` to keep the parent expr around for\n+                // better diagnostics.\n+                self.resolve_expr(e, Some(&expr));\n+            }\n+\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 self.visit_expr(scrutinee);\n                 self.resolve_pattern_top(pat, PatternSource::Let);"}, {"sha": "bed7a350ea86daf6f721258a0d8543039653d94d", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -545,17 +545,23 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let Some(err_code) = &err.code {\n             if err_code == &rustc_errors::error_code!(E0425) {\n                 for label_rib in &self.label_ribs {\n-                    for (label_ident, _) in &label_rib.bindings {\n+                    for (label_ident, node_id) in &label_rib.bindings {\n                         if format!(\"'{}\", ident) == label_ident.to_string() {\n-                            let msg = \"a label with a similar name exists\";\n-                            // FIXME: consider only emitting this suggestion if a label would be valid here\n-                            // which is pretty much only the case for `break` expressions.\n-                            err.span_suggestion(\n-                                span,\n-                                &msg,\n-                                label_ident.name.to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.span_label(label_ident.span, \"a label with a similar name exists\");\n+                            if let PathSource::Expr(Some(Expr {\n+                                kind: ExprKind::Break(None, Some(_)),\n+                                ..\n+                            })) = source\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use the similarly named label\",\n+                                    label_ident.name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                // Do not lint against unused label when we suggest them.\n+                                self.diagnostic_metadata.unused_labels.remove(node_id);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "95ac2a31dd321a0930e46dd0d126f76d5878f5a1", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1173,7 +1173,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     }\n \n     fn expression_label(ex: &hir::Expr<'_>) -> Option<Ident> {\n-        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n+        if let hir::ExprKind::Loop(_, Some(label), ..) = ex.kind { Some(label.ident) } else { None }\n     }\n \n     fn check_if_label_shadows_lifetime(tcx: TyCtxt<'_>, mut scope: ScopeRef<'_>, label: Ident) {"}, {"sha": "8f463af73c4774f037dfdedd5e9ce8d054f557b5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Loop(ref body, _, source) => {\n+            ExprKind::Loop(ref body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n             ExprKind::Match(ref discrim, ref arms, match_src) => {"}, {"sha": "24364c6954e490e5d4f9a5dc3ba8f2a8f9a95041", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Err => {}\n \n-            hir::ExprKind::Loop(ref blk, _, _) => {\n+            hir::ExprKind::Loop(ref blk, ..) => {\n                 self.walk_block(blk);\n             }\n "}, {"sha": "897fd172b29f34bc8fbfafe520b557f18ffb7999", "filename": "src/test/ui/issues/issue-1962.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.fixed?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -3,8 +3,8 @@\n \n fn main() {\n     let mut i = 0;\n-    loop { //~ ERROR denote infinite loops with `loop\n+    'a: loop { //~ ERROR denote infinite loops with `loop\n         i += 1;\n-        if i == 5 { break; }\n+        if i == 5 { break 'a; }\n     }\n }"}, {"sha": "71e874100874f4fba0367ae8a2a093f124fc8e3b", "filename": "src/test/ui/issues/issue-1962.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -3,8 +3,8 @@\n \n fn main() {\n     let mut i = 0;\n-    while true { //~ ERROR denote infinite loops with `loop\n+    'a: while true { //~ ERROR denote infinite loops with `loop\n         i += 1;\n-        if i == 5 { break; }\n+        if i == 5 { break 'a; }\n     }\n }"}, {"sha": "4c32a4cf3dd5946ac7bfae466c77724938ccb2fe", "filename": "src/test/ui/issues/issue-1962.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1962.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1,8 +1,8 @@\n error: denote infinite loops with `loop { ... }`\n   --> $DIR/issue-1962.rs:6:5\n    |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n+LL |     'a: while true {\n+   |     ^^^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: requested on the command line with `-D while-true`\n "}, {"sha": "59ef28481d0e6e35b05d20a0d032c4b8036040c5", "filename": "src/test/ui/issues/issue-27042.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -4,7 +4,7 @@ warning: denote infinite loops with `loop { ... }`\n LL | /         'b:\n LL | |\n LL | |         while true { break }; // but here we cite the whole loop\n-   | |____________________________^ help: use `loop`\n+   | |__________________^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n "}, {"sha": "e3180b06ecb2bfa33694e7c94c64efde0a8d801e", "filename": "src/test/ui/label/label_misspelled.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1,18 +1,62 @@\n+#![warn(unused_labels)]\n+\n fn main() {\n+    'while_loop: while true { //~ WARN denote infinite loops with\n+        //~^ WARN unused label\n+        while_loop;\n+        //~^ ERROR cannot find value `while_loop` in this scope\n+    };\n+    'while_let: while let Some(_) = Some(()) {\n+        //~^ WARN unused label\n+        while_let;\n+        //~^ ERROR cannot find value `while_let` in this scope\n+    }\n+    'for_loop: for _ in 0..3 {\n+        //~^ WARN unused label\n+        for_loop;\n+        //~^ ERROR cannot find value `for_loop` in this scope\n+    };\n     'LOOP: loop {\n+        //~^ WARN unused label\n         LOOP;\n         //~^ ERROR cannot find value `LOOP` in this scope\n     };\n+}\n+\n+fn foo() {\n+    'LOOP: loop {\n+        break LOOP;\n+        //~^ ERROR cannot find value `LOOP` in this scope\n+    };\n     'while_loop: while true { //~ WARN denote infinite loops with\n-        while_loop;\n+        break while_loop;\n         //~^ ERROR cannot find value `while_loop` in this scope\n     };\n     'while_let: while let Some(_) = Some(()) {\n-        while_let;\n+        break while_let;\n         //~^ ERROR cannot find value `while_let` in this scope\n     }\n     'for_loop: for _ in 0..3 {\n-        for_loop;\n+        break for_loop;\n         //~^ ERROR cannot find value `for_loop` in this scope\n     };\n }\n+\n+fn bar() {\n+    let foo = ();\n+    'while_loop: while true { //~ WARN denote infinite loops with\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `while` loop\n+    };\n+    'while_let: while let Some(_) = Some(()) {\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `while` loop\n+    }\n+    'for_loop: for _ in 0..3 {\n+        //~^ WARN unused label\n+        break foo;\n+        //~^ ERROR `break` with value from a `for` loop\n+    };\n+}"}, {"sha": "b09695787a443ae6108a5c200d15c00352c66e55", "filename": "src/test/ui/label/label_misspelled.stderr", "status": "modified", "additions": 185, "deletions": 26, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1,47 +1,206 @@\n-error[E0425]: cannot find value `LOOP` in this scope\n-  --> $DIR/label_misspelled.rs:3:9\n-   |\n-LL |         LOOP;\n-   |         ^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'LOOP`\n-\n error[E0425]: cannot find value `while_loop` in this scope\n-  --> $DIR/label_misspelled.rs:7:9\n+  --> $DIR/label_misspelled.rs:6:9\n    |\n+LL |     'while_loop: while true {\n+   |     ----------- a label with a similar name exists\n+LL |\n LL |         while_loop;\n-   |         ^^^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'while_loop`\n+   |         ^^^^^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `while_let` in this scope\n   --> $DIR/label_misspelled.rs:11:9\n    |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------- a label with a similar name exists\n+LL |\n LL |         while_let;\n-   |         ^^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'while_let`\n+   |         ^^^^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `for_loop` in this scope\n-  --> $DIR/label_misspelled.rs:15:9\n+  --> $DIR/label_misspelled.rs:16:9\n    |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     --------- a label with a similar name exists\n+LL |\n LL |         for_loop;\n-   |         ^^^^^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: a label with a similar name exists: `'for_loop`\n+   |         ^^^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `LOOP` in this scope\n+  --> $DIR/label_misspelled.rs:21:9\n+   |\n+LL |     'LOOP: loop {\n+   |     ----- a label with a similar name exists\n+LL |\n+LL |         LOOP;\n+   |         ^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `LOOP` in this scope\n+  --> $DIR/label_misspelled.rs:28:15\n+   |\n+LL |     'LOOP: loop {\n+   |     ----- a label with a similar name exists\n+LL |         break LOOP;\n+   |               ^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'LOOP`\n+\n+error[E0425]: cannot find value `while_loop` in this scope\n+  --> $DIR/label_misspelled.rs:32:15\n+   |\n+LL |     'while_loop: while true {\n+   |     ----------- a label with a similar name exists\n+LL |         break while_loop;\n+   |               ^^^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'while_loop`\n+\n+error[E0425]: cannot find value `while_let` in this scope\n+  --> $DIR/label_misspelled.rs:36:15\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------- a label with a similar name exists\n+LL |         break while_let;\n+   |               ^^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'while_let`\n+\n+error[E0425]: cannot find value `for_loop` in this scope\n+  --> $DIR/label_misspelled.rs:40:15\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     --------- a label with a similar name exists\n+LL |         break for_loop;\n+   |               ^^^^^^^^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'for_loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:4:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/label_misspelled.rs:1:9\n+   |\n+LL | #![warn(unused_labels)]\n+   |         ^^^^^^^^^^^^^\n \n warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/label_misspelled.rs:6:5\n+  --> $DIR/label_misspelled.rs:4:5\n    |\n LL |     'while_loop: while true {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n \n-error: aborting due to 4 previous errors; 1 warning emitted\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:9:5\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ^^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:14:5\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:19:5\n+   |\n+LL |     'LOOP: loop {\n+   |     ^^^^^\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/label_misspelled.rs:31:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:47:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/label_misspelled.rs:47:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:52:5\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ^^^^^^^^^^\n+\n+warning: unused label\n+  --> $DIR/label_misspelled.rs:57:5\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `while` loop\n+  --> $DIR/label_misspelled.rs:49:9\n+   |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `while` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_loop;\n+   |               ^^^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `while` loop\n+  --> $DIR/label_misspelled.rs:54:9\n+   |\n+LL |     'while_let: while let Some(_) = Some(()) {\n+   |     ---------------------------------------- you can't `break` with a value in a `while` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `while` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_let;\n+   |               ^^^^^^^^^^\n+\n+error[E0571]: `break` with value from a `for` loop\n+  --> $DIR/label_misspelled.rs:59:9\n+   |\n+LL |     'for_loop: for _ in 0..3 {\n+   |     ------------------------ you can't `break` with a value in a `for` loop\n+LL |\n+LL |         break foo;\n+   |         ^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+   |\n+help: use `break` on its own without a value inside this `for` loop\n+   |\n+LL |         break;\n+   |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'for_loop;\n+   |               ^^^^^^^^^\n+\n+error: aborting due to 11 previous errors; 10 warnings emitted\n \n-For more information about this error, try `rustc --explain E0425`.\n+Some errors have detailed explanations: E0425, E0571.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "55bbe6b30a5930382dbd75afac17550f22749d44", "filename": "src/test/ui/label/label_misspelled_2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -0,0 +1,16 @@\n+#![warn(unused_labels)]\n+\n+fn main() {\n+    'a: for _ in 0..1 {\n+        break 'a;\n+    }\n+    'b: for _ in 0..1 {\n+        break b; //~ ERROR cannot find value `b` in this scope\n+    }\n+    c: for _ in 0..1 { //~ ERROR malformed loop label\n+        break 'c;\n+    }\n+    d: for _ in 0..1 { //~ ERROR malformed loop label\n+        break d; //~ ERROR cannot find value `d` in this scope\n+    }\n+}"}, {"sha": "960646d9894d1158774e6d5369ecd7e350e24c38", "filename": "src/test/ui/label/label_misspelled_2.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_misspelled_2.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -0,0 +1,37 @@\n+error: malformed loop label\n+  --> $DIR/label_misspelled_2.rs:10:5\n+   |\n+LL |     c: for _ in 0..1 {\n+   |     ^ help: use the correct loop label format: `'c`\n+\n+error: malformed loop label\n+  --> $DIR/label_misspelled_2.rs:13:5\n+   |\n+LL |     d: for _ in 0..1 {\n+   |     ^ help: use the correct loop label format: `'d`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/label_misspelled_2.rs:8:15\n+   |\n+LL |     'b: for _ in 0..1 {\n+   |     -- a label with a similar name exists\n+LL |         break b;\n+   |               ^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'b`\n+\n+error[E0425]: cannot find value `d` in this scope\n+  --> $DIR/label_misspelled_2.rs:14:15\n+   |\n+LL |     d: for _ in 0..1 {\n+   |     - a label with a similar name exists\n+LL |         break d;\n+   |               ^\n+   |               |\n+   |               not found in this scope\n+   |               help: use the similarly named label: `'d`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "1c0d39a6e5ad738983fa19f94cd1cd28f23f7303", "filename": "src/test/ui/loops/loop-break-value-no-repeat.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value-no-repeat.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1,10 +1,12 @@\n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value-no-repeat.rs:12:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n LL |         break 22\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break\n    |         ^^^^^"}, {"sha": "51c9a36a0395641c7575c35e402bd3db29927890", "filename": "src/test/ui/loops/loop-break-value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -94,6 +94,5 @@ fn main() {\n     'LOOP: for _ in 0 .. 9 {\n         break LOOP;\n         //~^ ERROR cannot find value `LOOP` in this scope\n-        //~| ERROR `break` with value from a `for` loop\n     }\n }"}, {"sha": "adb099f9b1769ed0f26048775866844c4604c4fe", "filename": "src/test/ui/loops/loop-break-value.stderr", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -1,11 +1,13 @@\n error[E0425]: cannot find value `LOOP` in this scope\n   --> $DIR/loop-break-value.rs:95:15\n    |\n+LL |     'LOOP: for _ in 0 .. 9 {\n+   |     ----- a label with a similar name exists\n LL |         break LOOP;\n    |               ^^^^\n    |               |\n    |               not found in this scope\n-   |               help: a label with a similar name exists: `'LOOP`\n+   |               help: use the similarly named label: `'LOOP`\n \n warning: denote infinite loops with `loop { ... }`\n   --> $DIR/loop-break-value.rs:26:5\n@@ -18,101 +20,115 @@ LL |     'while_loop: while true {\n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:28:9\n    |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+LL |         break;\n LL |         break ();\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         break;\n    |         ^^^^^\n+help: alternatively, you might have meant to use the available loop label\n+   |\n+LL |         break 'while_loop;\n+   |               ^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:30:13\n    |\n+LL |     'while_loop: while true {\n+   |     ----------------------- you can't `break` with a value in a `while` loop\n+...\n LL |             break 'while_loop 123;\n    |             ^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n-LL |             break;\n-   |             ^^^^^\n+LL |             break 'while_loop;\n+   |             ^^^^^^^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:38:12\n    |\n+LL |     while let Some(_) = Some(()) {\n+   |     ---------------------------- you can't `break` with a value in a `while` loop\n LL |         if break () {\n    |            ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         if break {\n    |            ^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:43:9\n    |\n+LL |     while let Some(_) = Some(()) {\n+   |     ---------------------------- you can't `break` with a value in a `while` loop\n LL |         break None;\n    |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:49:13\n    |\n+LL |     'while_let_loop: while let Some(_) = Some(()) {\n+   |     --------------------------------------------- you can't `break` with a value in a `while` loop\n+LL |         loop {\n LL |             break 'while_let_loop \"nope\";\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `while` loop\n+help: use `break` on its own without a value inside this `while` loop\n    |\n-LL |             break;\n-   |             ^^^^^\n+LL |             break 'while_let_loop;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:56:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n LL |         break ();\n    |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:57:9\n    |\n+LL |     for _ in &[1,2,3] {\n+   |     ----------------- you can't `break` with a value in a `for` loop\n+LL |         break ();\n LL |         break [()];\n    |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n+help: use `break` on its own without a value inside this `for` loop\n    |\n LL |         break;\n    |         ^^^^^\n \n error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value.rs:64:13\n    |\n+LL |     'for_loop: for _ in &[1,2,3] {\n+   |     ---------------------------- you can't `break` with a value in a `for` loop\n+...\n LL |             break 'for_loop Some(17);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n-   |\n-LL |             break;\n-   |             ^^^^^\n-\n-error[E0571]: `break` with value from a `for` loop\n-  --> $DIR/loop-break-value.rs:95:9\n-   |\n-LL |         break LOOP;\n-   |         ^^^^^^^^^^ can only break with a value inside `loop` or breakable block\n+help: use `break` on its own without a value inside this `for` loop\n    |\n-help: instead, use `break` on its own without a value inside this `for` loop\n-   |\n-LL |         break;\n-   |         ^^^^^\n+LL |             break 'for_loop;\n+   |             ^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/loop-break-value.rs:4:31\n@@ -171,7 +187,7 @@ LL |         break;\n    |         expected integer, found `()`\n    |         help: give it a value of the expected type: `break value`\n \n-error: aborting due to 18 previous errors; 1 warning emitted\n+error: aborting due to 17 previous errors; 1 warning emitted\n \n Some errors have detailed explanations: E0308, E0425, E0571.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "bbcea387de2cb81bb38838ce5cf1e001d5a91230", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -533,7 +533,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        if let ExprKind::Loop(ref block, _, _) = expr.kind {\n+        if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n             match never_loop_block(block, expr.hir_id) {\n                 NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n                 NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -543,7 +543,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             if block.stmts.is_empty() && block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n                 let msg = \"empty `loop {}` wastes CPU cycles\";\n@@ -738,7 +738,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Assign(ref e1, ref e2, _)\n         | ExprKind::AssignOp(_, ref e1, ref e2)\n         | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprKind::Loop(ref b, _, _) => {\n+        ExprKind::Loop(ref b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             // Non-determinism may occur ... don't give a lint\n-            ExprKind::Loop(_, _, _) | ExprKind::Match(_, _, _) => self.should_lint = false,\n+            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n             ExprKind::Block(block, _) => self.visit_block(block),\n             _ => {},\n         }"}, {"sha": "603071a5f4ac4659fef61816e436507b54fc5ada", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -221,7 +221,7 @@ where\n {\n     if let ast::ExprKind::While(_, loop_block, label)\n     | ast::ExprKind::ForLoop(_, _, loop_block, label)\n-    | ast::ExprKind::Loop(loop_block, label) = &expr.kind\n+    | ast::ExprKind::Loop(loop_block, label, ..) = &expr.kind\n     {\n         func(loop_block, label.as_ref());\n     }"}, {"sha": "d5b1767e945b9ea4a81b4b9a07d5ed70d56c0cb1", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -325,7 +325,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n         | ExprKind::Field(ref e, _)\n         | ExprKind::AddrOf(_, _, ref e)\n         | ExprKind::Box(ref e) => check_expr(cx, e, bindings),\n-        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n+        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, ..) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n         ExprKind::Array(v) | ExprKind::Tup(v) => {"}, {"sha": "ca60d335262b3bda975431d92c0f7ecc987dde10", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -317,7 +317,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Loop(ref body, _, desugaring) => {\n+            ExprKind::Loop(ref body, _, desugaring, _) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");"}, {"sha": "42ab9a1e7d2472f01173d2d42fc7076ba92b5a40", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -142,7 +142,7 @@ pub fn for_loop<'tcx>(\n         if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.kind;\n+        if let hir::ExprKind::Loop(ref block, ..) = arms[0].body.kind;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n         if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n@@ -158,7 +158,7 @@ pub fn for_loop<'tcx>(\n /// `while cond { body }` becomes `(cond, body)`.\n pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if_chain! {\n-        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While) = &expr.kind;\n+        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While, _) = &expr.kind;\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n         if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n         if let hir::ExprKind::DropTemps(cond) = &cond.kind;"}, {"sha": "6066383f2ef424f84e2c1f529cd3eb45d53fd80c", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3682a06dcff54a6b9188fd4395e26b316c7652f7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=3682a06dcff54a6b9188fd4395e26b316c7652f7", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n-            (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n+            (&ExprKind::Loop(ref lb, ref ll, ref lls, _), &ExprKind::Loop(ref rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);\n             },\n-            ExprKind::Loop(ref b, ref i, _) => {\n+            ExprKind::Loop(ref b, ref i, ..) => {\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);"}]}