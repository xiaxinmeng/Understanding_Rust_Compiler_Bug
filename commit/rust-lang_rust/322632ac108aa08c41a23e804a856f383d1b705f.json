{"sha": "322632ac108aa08c41a23e804a856f383d1b705f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjYzMmFjMTA4YWEwOGM0MWEyM2U4MDRhODU2ZjM4M2QxYjcwNWY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-11T18:38:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-11T18:38:33Z"}, "message": "Rollup merge of #51952 - petrochenkov:transmark, r=alexcrichton\n\n hygiene: Decouple transparencies from expansion IDs\n\nAnd remove fallback to parent modules during resolution of names in scope.\n\nThis is a breaking change for users of unstable macros 2.0 (both procedural and declarative), code like this:\n```rust\n#![feature(decl_macro)]\n\nmacro m($S: ident) {\n    struct $S;\n    mod m {\n        type A = $S;\n    }\n}\n\nfn main() {\n    m!(S);\n}\n```\nor equivalent\n```rust\n#![feature(decl_macro)]\n\nmacro m($S: ident) {\n    mod m {\n        type A = $S;\n    }\n}\n\nfn main() {\n    struct S;\n    m!(S);\n}\n```\nstops working due to module boundaries being properly enforced.\n\nFor proc macro derives this is still reported as a compatibility warning to give `actix_derive`, `diesel_derives` and `palette_derive` time to fix their issues.\n\nFixes https://github.com/rust-lang/rust/issues/50504 in accordance with [this comment](https://github.com/rust-lang/rust/issues/50504#issuecomment-399764767).", "tree": {"sha": "fa88ca4f8ded2c6bd2422ff8cd9f1f94228c41d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa88ca4f8ded2c6bd2422ff8cd9f1f94228c41d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/322632ac108aa08c41a23e804a856f383d1b705f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbRk6pCRBK7hj4Ov3rIwAAdHIIACnehhPVlyuTqqC8wjoRGbvU\nnecMiFZaoKd2ez/M4tQlQ7E0EGUCcujp8IHhfGJTMDvx5qM+qOGglvAMZh4G1VUd\n1LNxsNBirHrLuL8zbpzNt/dhl3fSsdPqQaZf5zKLSMMFugsH7D4r8Jo3yGjLvdg0\ntLhez+JVXf6HW+bo8rp9UT20/CoQe5jt4qIAURG6uHVeyrnxZnVYAzebGed4Xryb\nhxRCA6HAsd2cUgzvnIPGFPsLbU+Z5uyO1pOLwRoB63bI6huQB4UpYurIlj+bG/W5\nnNR633upXJCUiLYTrAc4H0zPD+jB2k5f53YdQGF4/7yrm5VVY17NztGfelJ6oB8=\n=sSX3\n-----END PGP SIGNATURE-----\n", "payload": "tree fa88ca4f8ded2c6bd2422ff8cd9f1f94228c41d5\nparent d2a8a2b34a26b73dfd9e0179d67cff7c8f8ef07d\nparent fc74e359819002fad402f68728f6e5ba2d4cb704\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1531334313 -0600\ncommitter GitHub <noreply@github.com> 1531334313 -0600\n\nRollup merge of #51952 - petrochenkov:transmark, r=alexcrichton\n\n hygiene: Decouple transparencies from expansion IDs\n\nAnd remove fallback to parent modules during resolution of names in scope.\n\nThis is a breaking change for users of unstable macros 2.0 (both procedural and declarative), code like this:\n```rust\n#![feature(decl_macro)]\n\nmacro m($S: ident) {\n    struct $S;\n    mod m {\n        type A = $S;\n    }\n}\n\nfn main() {\n    m!(S);\n}\n```\nor equivalent\n```rust\n#![feature(decl_macro)]\n\nmacro m($S: ident) {\n    mod m {\n        type A = $S;\n    }\n}\n\nfn main() {\n    struct S;\n    m!(S);\n}\n```\nstops working due to module boundaries being properly enforced.\n\nFor proc macro derives this is still reported as a compatibility warning to give `actix_derive`, `diesel_derives` and `palette_derive` time to fix their issues.\n\nFixes https://github.com/rust-lang/rust/issues/50504 in accordance with [this comment](https://github.com/rust-lang/rust/issues/50504#issuecomment-399764767).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/322632ac108aa08c41a23e804a856f383d1b705f", "html_url": "https://github.com/rust-lang/rust/commit/322632ac108aa08c41a23e804a856f383d1b705f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/322632ac108aa08c41a23e804a856f383d1b705f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a8a2b34a26b73dfd9e0179d67cff7c8f8ef07d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a8a2b34a26b73dfd9e0179d67cff7c8f8ef07d", "html_url": "https://github.com/rust-lang/rust/commit/d2a8a2b34a26b73dfd9e0179d67cff7c8f8ef07d"}, {"sha": "fc74e359819002fad402f68728f6e5ba2d4cb704", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc74e359819002fad402f68728f6e5ba2d4cb704", "html_url": "https://github.com/rust-lang/rust/commit/fc74e359819002fad402f68728f6e5ba2d4cb704"}], "stats": {"total": 623, "additions": 450, "deletions": 173}, "files": [{"sha": "876cf295acc1ba984c3037f2b630191a097dc3e6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -1351,7 +1351,7 @@ pub mod __internal {\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n     use syntax_pos::{BytePos, Loc, DUMMY_SP};\n-    use syntax_pos::hygiene::{Mark, SyntaxContext, Transparency};\n+    use syntax_pos::hygiene::{SyntaxContext, Transparency};\n \n     use super::{TokenStream, LexError, Span};\n \n@@ -1436,20 +1436,15 @@ pub mod __internal {\n \n             // No way to determine def location for a proc macro right now, so use call location.\n             let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n-            // Opaque mark was already created by expansion, now create its transparent twin.\n-            // We can't use the call-site span literally here, even if it appears to provide\n-            // correct name resolution, because it has all the `ExpnInfo` wrong, so the edition\n-            // checks, lint macro checks, macro backtraces will all break.\n-            let opaque_mark = cx.current_expansion.mark;\n-            let transparent_mark = Mark::fresh_cloned(opaque_mark);\n-            transparent_mark.set_transparency(Transparency::Transparent);\n-\n-            let to_span = |mark| Span(location.with_ctxt(SyntaxContext::empty().apply_mark(mark)));\n+            let to_span = |transparency| Span(location.with_ctxt(\n+                SyntaxContext::empty().apply_mark_with_transparency(cx.current_expansion.mark,\n+                                                                    transparency))\n+            );\n             p.set(ProcMacroSess {\n                 parse_sess: cx.parse_sess,\n                 data: ProcMacroData {\n-                    def_site: to_span(opaque_mark),\n-                    call_site: to_span(transparent_mark),\n+                    def_site: to_span(Transparency::Opaque),\n+                    call_site: to_span(Transparency::Transparent),\n                 },\n             });\n             f()"}, {"sha": "7a26a239aeffadb777733841e1411434752f789a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -129,6 +129,16 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+impl Namespace {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            TypeNS => \"type\",\n+            ValueNS => \"value\",\n+            MacroNS => \"macro\",\n+        }\n+    }\n+}\n+\n /// Just a helper \u2012 separate structure for each namespace.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct PerNS<T> {"}, {"sha": "49a4a1b78a1a8714edf8d7808b6870e2fe04f19b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -153,6 +153,7 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n+#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n@@ -161,34 +162,12 @@ pub struct Definitions {\n     /// If `Mark` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n     parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n-    /// Item with a given `DefIndex` was defined during opaque macro expansion with ID `Mark`.\n-    /// It can actually be defined during transparent macro expansions inside that opaque expansion,\n-    /// but transparent expansions are ignored here.\n-    opaque_expansions_that_defined: FxHashMap<DefIndex, Mark>,\n+    /// Item with a given `DefIndex` was defined during macro expansion with ID `Mark`.\n+    expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n \n-// Unfortunately we have to provide a manual impl of Clone because of the\n-// fixed-sized array field.\n-impl Clone for Definitions {\n-    fn clone(&self) -> Self {\n-        Definitions {\n-            table: self.table.clone(),\n-            node_to_def_index: self.node_to_def_index.clone(),\n-            def_index_to_node: [\n-                self.def_index_to_node[0].clone(),\n-                self.def_index_to_node[1].clone(),\n-            ],\n-            node_to_hir_id: self.node_to_hir_id.clone(),\n-            parent_modules_of_macro_defs: self.parent_modules_of_macro_defs.clone(),\n-            opaque_expansions_that_defined: self.opaque_expansions_that_defined.clone(),\n-            next_disambiguator: self.next_disambiguator.clone(),\n-            def_index_to_span: self.def_index_to_span.clone(),\n-        }\n-    }\n-}\n-\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n@@ -409,7 +388,7 @@ impl Definitions {\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n             parent_modules_of_macro_defs: FxHashMap(),\n-            opaque_expansions_that_defined: FxHashMap(),\n+            expansions_that_defined: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n             def_index_to_span: FxHashMap(),\n         }\n@@ -584,9 +563,8 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        let expansion = expansion.modern();\n         if expansion != Mark::root() {\n-            self.opaque_expansions_that_defined.insert(index, expansion);\n+            self.expansions_that_defined.insert(index, expansion);\n         }\n \n         // The span is added if it isn't dummy\n@@ -606,8 +584,8 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn opaque_expansion_that_defined(&self, index: DefIndex) -> Mark {\n-        self.opaque_expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn expansion_that_defined(&self, index: DefIndex) -> Mark {\n+        self.expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {"}, {"sha": "efc2d9311c1dcbe67ee58d39cc4d14e7e2da43a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -316,6 +316,12 @@ declare_lint! {\n     \"checks the object safety of where clauses\"\n }\n \n+declare_lint! {\n+    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+    Warn,\n+    \"detects proc macro derives using inaccessible names from parent modules\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -372,6 +378,7 @@ impl LintPass for HardwiredLints {\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             WHERE_CLAUSES_OBJECT_SAFETY,\n+            PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         )\n     }\n }\n@@ -384,6 +391,7 @@ pub enum BuiltinLintDiagnostics {\n     BareTraitObject(Span, /* is_global */ bool),\n     AbsPathWithModule(Span),\n     DuplicatedMacroExports(ast::Ident, Span, Span),\n+    ProcMacroDeriveResolutionFallback(Span),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -420,6 +428,10 @@ impl BuiltinLintDiagnostics {\n                 db.span_label(later_span, format!(\"`{}` already exported\", ident));\n                 db.span_note(earlier_span, \"previous macro export is now shadowed\");\n             }\n+            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n+                db.span_label(span, \"names from parent modules are not \\\n+                                     accessible without an explicit import\");\n+            }\n         }\n     }\n }"}, {"sha": "4a76cc683f6800ecf8715ee725d12006bae4ddbf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -2724,7 +2724,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().opaque_expansion_that_defined(scope.index),\n+            LOCAL_CRATE => self.hir.definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n         let scope = match ident.span.adjust(target_expansion) {"}, {"sha": "359b056b5a2d1f5da0fe7e14e6cbeb10e31c14a1", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -293,6 +293,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n+            reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "8a47b8ea6485a341ab8de71453186ccd5b562260", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -55,7 +55,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n-use syntax::ast::{Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{CRATE_NODE_ID, Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n@@ -1891,7 +1891,12 @@ impl<'a> Resolver<'a> {\n \n         ident.span = ident.span.modern();\n         loop {\n-            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.span), break);\n+            let (opt_module, poisoned) = if record_used {\n+                self.hygienic_lexical_parent_with_compatibility_fallback(module, &mut ident.span)\n+            } else {\n+                (self.hygienic_lexical_parent(module, &mut ident.span), false)\n+            };\n+            module = unwrap_or!(opt_module, break);\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1900,7 +1905,19 @@ impl<'a> Resolver<'a> {\n             self.current_module = orig_current_module;\n \n             match result {\n-                Ok(binding) => return Some(LexicalScopeBinding::Item(binding)),\n+                Ok(binding) => {\n+                    if poisoned {\n+                        self.session.buffer_lint_with_diagnostic(\n+                            lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                            CRATE_NODE_ID, ident.span,\n+                            &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n+                            lint::builtin::BuiltinLintDiagnostics::\n+                                ProcMacroDeriveResolutionFallback(ident.span),\n+                        );\n+                    }\n+                    return Some(LexicalScopeBinding::Item(binding))\n+                }\n+                _ if poisoned => break,\n                 Err(Undetermined) => return None,\n                 Err(Determined) => {}\n             }\n@@ -1935,7 +1952,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n+    fn hygienic_lexical_parent(&mut self, module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n         if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n             return Some(self.macro_def_scope(span.remove_mark()));\n@@ -1945,22 +1962,41 @@ impl<'a> Resolver<'a> {\n             return Some(module.parent.unwrap());\n         }\n \n-        let mut module_expansion = module.expansion.modern(); // for backward compatibility\n-        while let Some(parent) = module.parent {\n-            let parent_expansion = parent.expansion.modern();\n-            if module_expansion.is_descendant_of(parent_expansion) &&\n-               parent_expansion != module_expansion {\n-                return if parent_expansion.is_descendant_of(span.ctxt().outer()) {\n-                    Some(parent)\n-                } else {\n-                    None\n-                };\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent_with_compatibility_fallback(\n+        &mut self, module: Module<'a>, span: &mut Span) -> (Option<Module<'a>>, /* poisoned */ bool\n+    ) {\n+        if let module @ Some(..) = self.hygienic_lexical_parent(module, span) {\n+            return (module, false);\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if let Some(parent) = module.parent {\n+            // Inner module is inside the macro, parent module is outside of the macro.\n+            if module.expansion != parent.expansion &&\n+            module.expansion.is_descendant_of(parent.expansion) {\n+                // The macro is a proc macro derive\n+                if module.expansion.looks_like_proc_macro_derive() {\n+                    if parent.expansion.is_descendant_of(span.ctxt().outer()) {\n+                        return (module.parent, true);\n+                    }\n+                }\n             }\n-            module = parent;\n-            module_expansion = parent_expansion;\n         }\n \n-        None\n+        (None, false)\n     }\n \n     fn resolve_ident_in_module(&mut self,\n@@ -1996,17 +2032,17 @@ impl<'a> Resolver<'a> {\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n             // Find the last modern mark from the end if it exists.\n-            while let Some(&mark) = iter.peek() {\n-                if mark.transparency() == Transparency::Opaque {\n+            while let Some(&(mark, transparency)) = iter.peek() {\n+                if transparency == Transparency::Opaque {\n                     result = Some(mark);\n                     iter.next();\n                 } else {\n                     break;\n                 }\n             }\n             // Then find the last legacy mark from the end if it exists.\n-            for mark in iter {\n-                if mark.transparency() == Transparency::SemiTransparent {\n+            for (mark, transparency) in iter {\n+                if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n                 } else {\n                     break;\n@@ -4037,8 +4073,9 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n-            search_module =\n-                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.span), break);\n+            search_module = unwrap_or!(\n+                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n+            );\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -4406,12 +4443,6 @@ impl<'a> Resolver<'a> {\n             (TypeNS, _) => \"type\",\n         };\n \n-        let namespace = match ns {\n-            ValueNS => \"value\",\n-            MacroNS => \"macro\",\n-            TypeNS => \"type\",\n-        };\n-\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n@@ -4429,7 +4460,7 @@ impl<'a> Resolver<'a> {\n \n         err.note(&format!(\"`{}` must be defined only once in the {} namespace of this {}\",\n                           name,\n-                          namespace,\n+                          ns.descr(),\n                           container));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));"}, {"sha": "9ce1e21d0d03ebfef3fb899ed2a8db6f5820d63d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -24,7 +24,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark, Transparency};\n+use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n@@ -331,13 +331,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n-        if ext.is_modern() {\n-            let transparency =\n-                if ext.is_transparent() { Transparency::Transparent } else { Transparency::Opaque };\n-            invoc.expansion_data.mark.set_transparency(transparency);\n-        } else if def_id.krate == BUILTIN_MACROS_CRATE {\n-            invoc.expansion_data.mark.set_is_builtin(true);\n-        }\n+        invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n+        invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n         Ok(Some(ext))\n     }\n "}, {"sha": "2e9c7d6f96c454db7897db7868d530192ef5baa0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use ext::expand::{self, AstFragment, Invocation};\n-use ext::hygiene::{self, Mark, SyntaxContext};\n+use ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n@@ -673,20 +673,14 @@ impl SyntaxExtension {\n         }\n     }\n \n-    pub fn is_modern(&self) -> bool {\n+    pub fn default_transparency(&self) -> Transparency {\n         match *self {\n-            SyntaxExtension::DeclMacro { .. } |\n             SyntaxExtension::ProcMacro { .. } |\n             SyntaxExtension::AttrProcMacro(..) |\n-            SyntaxExtension::ProcMacroDerive(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_transparent(&self) -> bool {\n-        match *self {\n-            SyntaxExtension::DeclMacro { is_transparent, .. } => is_transparent,\n-            _ => false,\n+            SyntaxExtension::ProcMacroDerive(..) |\n+            SyntaxExtension::DeclMacro { is_transparent: false, .. } => Transparency::Opaque,\n+            SyntaxExtension::DeclMacro { is_transparent: true, .. } => Transparency::Transparent,\n+            _ => Transparency::SemiTransparent,\n         }\n     }\n "}, {"sha": "c7076478332f4c01b1fb7c3ca22ef089576a0c99", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 79, "deletions": 61, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -27,16 +27,17 @@ use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n-pub struct SyntaxContext(pub(super) u32);\n+pub struct SyntaxContext(u32);\n \n #[derive(Copy, Clone, Debug)]\n-pub struct SyntaxContextData {\n-    pub outer_mark: Mark,\n-    pub prev_ctxt: SyntaxContext,\n+struct SyntaxContextData {\n+    outer_mark: Mark,\n+    transparency: Transparency,\n+    prev_ctxt: SyntaxContext,\n     // This context, but with all transparent and semi-transparent marks filtered away.\n-    pub opaque: SyntaxContext,\n+    opaque: SyntaxContext,\n     // This context, but with all transparent marks filtered away.\n-    pub opaque_and_semitransparent: SyntaxContext,\n+    opaque_and_semitransparent: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n@@ -46,14 +47,14 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    transparency: Transparency,\n+    default_transparency: Transparency,\n     is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -71,26 +72,16 @@ pub enum Transparency {\n }\n \n impl Mark {\n-    fn fresh_with_data(mark_data: MarkData, data: &mut HygieneData) -> Self {\n-        data.marks.push(mark_data);\n-        Mark(data.marks.len() as u32 - 1)\n-    }\n-\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            Mark::fresh_with_data(MarkData {\n+            data.marks.push(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n-            }, data)\n-        })\n-    }\n-\n-    pub fn fresh_cloned(clone_from: Mark) -> Self {\n-        HygieneData::with(|data| {\n-            Mark::fresh_with_data(data.marks[clone_from.0 as usize].clone(), data)\n+            });\n+            Mark(data.marks.len() as u32 - 1)\n         })\n     }\n \n@@ -127,34 +118,21 @@ impl Mark {\n         })\n     }\n \n-    pub fn modern(mut self) -> Mark {\n-        HygieneData::with(|data| {\n-            while data.marks[self.0 as usize].transparency != Transparency::Opaque {\n-                self = data.marks[self.0 as usize].parent;\n-            }\n-            self\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn transparency(self) -> Transparency {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency)\n-    }\n-\n     #[inline]\n-    pub fn set_transparency(self, transparency: Transparency) {\n+    pub fn set_default_transparency(self, transparency: Transparency) {\n         assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency = transparency)\n+        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n     }\n \n     #[inline]\n     pub fn is_builtin(self) -> bool {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n     }\n \n     #[inline]\n     pub fn set_is_builtin(self, is_builtin: bool) {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n     }\n \n@@ -195,29 +173,48 @@ impl Mark {\n             b\n         })\n     }\n+\n+    // Used for enabling some compatibility fallback in resolve.\n+    #[inline]\n+    pub fn looks_like_proc_macro_derive(self) -> bool {\n+        HygieneData::with(|data| {\n+            let mark_data = &data.marks[self.0 as usize];\n+            if mark_data.default_transparency == Transparency::Opaque {\n+                if let Some(expn_info) = &mark_data.expn_info {\n+                    if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n+                        if name.as_str().starts_with(\"derive(\") {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        })\n+    }\n }\n \n #[derive(Debug)]\n-pub struct HygieneData {\n+crate struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n-    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    markings: HashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n     default_edition: Edition,\n }\n \n impl HygieneData {\n-    pub fn new() -> Self {\n+    crate fn new() -> Self {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n                 // If the root is opaque, then loops searching for an opaque mark\n                 // will automatically stop after reaching it.\n-                transparency: Transparency::Opaque,\n+                default_transparency: Transparency::Opaque,\n                 is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n+                transparency: Transparency::Opaque,\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n@@ -249,6 +246,14 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n+    crate fn as_u32(self) -> u32 {\n+        self.0\n+    }\n+\n+    crate fn from_u32(raw: u32) -> SyntaxContext {\n+        SyntaxContext(raw)\n+    }\n+\n     // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n     // deserializing Spans from the incr. comp. cache.\n     // FIXME(mw): This method does not restore MarkData::parent or\n@@ -259,7 +264,7 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: Some(expansion_info),\n             });\n@@ -268,6 +273,7 @@ impl SyntaxContext {\n \n             data.syntax_contexts.push(SyntaxContextData {\n                 outer_mark: mark,\n+                transparency: Transparency::SemiTransparent,\n                 prev_ctxt: SyntaxContext::empty(),\n                 opaque: SyntaxContext::empty(),\n                 opaque_and_semitransparent: SyntaxContext::empty(),\n@@ -276,22 +282,32 @@ impl SyntaxContext {\n         })\n     }\n \n-    /// Extend a syntax context with a given mark\n+    /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        if mark.transparency() == Transparency::Opaque {\n-            return self.apply_mark_internal(mark);\n+        assert_ne!(mark, Mark::root());\n+        self.apply_mark_with_transparency(\n+            mark, HygieneData::with(|data| data.marks[mark.0 as usize].default_transparency)\n+        )\n+    }\n+\n+    /// Extend a syntax context with a given mark and transparency\n+    pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n+                                        -> SyntaxContext {\n+        assert_ne!(mark, Mark::root());\n+        if transparency == Transparency::Opaque {\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         let call_site_ctxt =\n             mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n-        let call_site_ctxt = if mark.transparency() == Transparency::SemiTransparent {\n+        let call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             call_site_ctxt.modern()\n         } else {\n             call_site_ctxt.modern_and_legacy()\n         };\n \n         if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(mark);\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n@@ -304,27 +320,26 @@ impl SyntaxContext {\n         //\n         // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n         let mut ctxt = call_site_ctxt;\n-        for mark in self.marks() {\n-            ctxt = ctxt.apply_mark_internal(mark);\n+        for (mark, transparency) in self.marks() {\n+            ctxt = ctxt.apply_mark_internal(mark, transparency);\n         }\n-        ctxt.apply_mark_internal(mark)\n+        ctxt.apply_mark_internal(mark, transparency)\n     }\n \n-    fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n+    fn apply_mark_internal(self, mark: Mark, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n-            let transparency = data.marks[mark.0 as usize].transparency;\n-\n             let mut opaque = syntax_contexts[self.0 as usize].opaque;\n             let mut opaque_and_semitransparent =\n                 syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n \n             if transparency >= Transparency::Opaque {\n                 let prev_ctxt = opaque;\n-                opaque = *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                opaque = *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque: new_opaque,\n                         opaque_and_semitransparent: new_opaque,\n@@ -336,11 +351,12 @@ impl SyntaxContext {\n             if transparency >= Transparency::SemiTransparent {\n                 let prev_ctxt = opaque_and_semitransparent;\n                 opaque_and_semitransparent =\n-                        *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                        *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque_and_semitransparent =\n                         SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque,\n                         opaque_and_semitransparent: new_opaque_and_semitransparent,\n@@ -350,11 +366,12 @@ impl SyntaxContext {\n             }\n \n             let prev_ctxt = self;\n-            *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+            *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                 let new_opaque_and_semitransparent_and_transparent =\n                     SyntaxContext(syntax_contexts.len() as u32);\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n+                    transparency,\n                     prev_ctxt,\n                     opaque,\n                     opaque_and_semitransparent,\n@@ -388,12 +405,13 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn marks(mut self) -> Vec<Mark> {\n+    pub fn marks(mut self) -> Vec<(Mark, Transparency)> {\n         HygieneData::with(|data| {\n             let mut marks = Vec::new();\n             while self != SyntaxContext::empty() {\n-                marks.push(data.syntax_contexts[self.0 as usize].outer_mark);\n-                self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+                let ctxt_data = &data.syntax_contexts[self.0 as usize];\n+                marks.push((ctxt_data.outer_mark, ctxt_data.transparency));\n+                self = ctxt_data.prev_ctxt;\n             }\n             marks.reverse();\n             marks"}, {"sha": "61af70af47d85a42287a303669ffbcdf77977156", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -19,10 +19,10 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(const_fn)]\n+#![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n-#![allow(unused_attributes)]\n #![feature(specialization)]\n #![feature(stdsimd)]\n "}, {"sha": "473aa1bd1b8a471e2e1c6de98169c8cc9965818d", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -100,7 +100,7 @@ const INTERNED_INDEX_OFFSET: u32 = 1;\n \n #[inline]\n fn encode(sd: &SpanData) -> Span {\n-    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.0);\n+    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.as_u32());\n \n     let val = if (base >> INLINE_SIZES[BASE_INDEX]) == 0 &&\n                  (len >> INLINE_SIZES[LEN_INDEX]) == 0 &&\n@@ -132,7 +132,7 @@ fn decode(span: Span) -> SpanData {\n         let index = extract(INTERNED_INDEX_OFFSET, INTERNED_INDEX_SIZE);\n         return with_span_interner(|interner| *interner.get(index));\n     };\n-    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext(ctxt) }\n+    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext::from_u32(ctxt) }\n }\n \n #[derive(Default)]"}, {"sha": "6a8d545db49b966241cf62aaa97b36f350907391", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/generate-mod.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn check(_: TokenStream) -> TokenStream {\n+    \"\n+    type Alias = FromOutside; // OK\n+    struct Outer;\n+    mod inner {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = Outer; // `Outer` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn check_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n+    \"\n+    type AliasAttr = FromOutside; // OK\n+    struct OuterAttr;\n+    mod inner_attr {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterAttr; // `OuterAttr` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}\n+\n+#[proc_macro_derive(CheckDerive)]\n+pub fn check_derive(_: TokenStream) -> TokenStream {\n+    \"\n+    type AliasDerive = FromOutside; // OK\n+    struct OuterDerive;\n+    mod inner_derive {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterDerive; // `OuterDerive` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "ff64421047fb8b4b7799f3bdae6379af4934600d", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Modules generated by transparent proc macros still acts as barriers for names (issue #50504).\n+\n+// aux-build:generate-mod.rs\n+\n+#![feature(proc_macro, proc_macro_gen, proc_macro_path_invoc)]\n+\n+extern crate generate_mod;\n+\n+struct FromOutside;\n+\n+generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+                        //~| ERROR cannot find type `Outer` in this scope\n+\n+#[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+                            //~| ERROR cannot find type `OuterAttr` in this scope\n+struct S;\n+\n+#[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+                                     //~| WARN cannot find type `OuterDerive` in this scope\n+                                     //~| WARN this was previously accepted\n+                                     //~| WARN this was previously accepted\n+struct Z;\n+\n+fn main() {}"}, {"sha": "c024aeffbb08675a33f0c1ad24e213f2e47a285b", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -0,0 +1,46 @@\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:21:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:21:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `OuterAttr` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = note: #[warn(proc_macro_derive_resolution_fallback)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+warning: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "958133e7ec5891b30a4ef2d93dba768df61c1947", "filename": "src/test/ui/hygiene/arguments.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -23,5 +23,5 @@ macro m($t:ty, $e:expr) {\n \n fn main() {\n     struct S;\n-    m!(S, S);\n+    m!(S, S); //~ ERROR cannot find type `S` in this scope\n }", "previous_filename": "src/test/run-pass/hygiene/arguments.rs"}, {"sha": "1b0c23eff297e95cdceb12391892f124f9ea3c79", "filename": "src/test/ui/hygiene/arguments.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/arguments.rs:26:8\n+   |\n+LL |     m!(S, S); //~ ERROR cannot find type `S` in this scope\n+   |        ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "2b2108558a0f385908c02d0b9b75a3f1afd8badd", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -12,13 +12,46 @@\n \n #![feature(decl_macro, rustc_attrs)]\n \n+macro genmod($FromOutside: ident, $Outer: ident) {\n+    type A = $FromOutside;\n+    struct $Outer;\n+    mod inner {\n+        type A = $FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = $Outer; // `Outer` shouldn't be available from here\n+    }\n+}\n+\n #[rustc_transparent_macro]\n-macro genmod() {\n-    mod m {\n-        type A = S; //~ ERROR cannot find type `S` in this scope\n+macro genmod_transparent() {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n     }\n }\n \n-struct S;\n+macro_rules! genmod_legacy { () => {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+    }\n+}}\n \n-genmod!();\n+fn check() {\n+    struct FromOutside;\n+    genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+                                 //~| ERROR cannot find type `Outer` in this scope\n+}\n+\n+fn check_transparent() {\n+    struct FromOutside;\n+    genmod_transparent!();\n+}\n+\n+fn check_legacy() {\n+    struct FromOutside;\n+    genmod_legacy!();\n+}"}, {"sha": "0c5905c5acb4fdc9ba2f93595feabfc269f30b66", "filename": "src/test/ui/hygiene/generate-mod.stderr", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -1,17 +1,56 @@\n-error[E0412]: cannot find type `S` in this scope\n-  --> $DIR/generate-mod.rs:18:18\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:45:13\n    |\n-LL |         type A = S; //~ ERROR cannot find type `S` in this scope\n-   |                  ^ did you mean `A`?\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |             ^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:45:26\n+   |\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |                          ^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:29:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:30:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:38:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:39:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n ...\n-LL | genmod!();\n-   | ---------- in this macro invocation\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n \n error[E0601]: `main` function not found in crate `generate_mod`\n    |\n    = note: consider adding a `main` function to `$DIR/generate-mod.rs`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 7 previous errors\n \n Some errors occurred: E0412, E0601.\n For more information about an error, try `rustc --explain E0412`."}, {"sha": "9785ce6c0048eae04227e9dc0a34130237f751b9", "filename": "src/test/ui/hygiene/globs.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -57,12 +57,26 @@ macro n($i:ident) {\n                 }\n             }\n         }\n+        macro n_with_super($j:ident) {\n+            mod test {\n+                use super::*;\n+                fn g() {\n+                    let _: u32 = $i();\n+                    let _: () = f();\n+                    super::$j();\n+                }\n+            }\n+        }\n \n-        n!(f);\n+        n!(f); //~ ERROR cannot find function `f` in this scope\n+        n_with_super!(f);\n         mod test2 {\n             super::n! {\n                 f //~ ERROR cannot find function `f` in this scope\n             }\n+            super::n_with_super! {\n+                f\n+            }\n         }\n     }\n }"}, {"sha": "7df2e31f9a752f79edac498a4564590ebd7f61a5", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322632ac108aa08c41a23e804a856f383d1b705f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=322632ac108aa08c41a23e804a856f383d1b705f", "patch": "@@ -30,20 +30,30 @@ LL | use bar::g;\n    |\n LL | use foo::test2::test::g;\n    |\n-LL | use foo::test::g;\n+LL | use foo::test2::test::g;\n    |\n LL | use foo::test::g;\n    |\n+and 2 other candidates\n+\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/globs.rs:71:12\n+   |\n+LL | n!(f);\n+   | ------ in this macro invocation\n+...\n+LL |         n!(f); //~ ERROR cannot find function `f` in this scope\n+   |            ^ not found in this scope\n \n error[E0425]: cannot find function `f` in this scope\n-  --> $DIR/globs.rs:64:17\n+  --> $DIR/globs.rs:75:17\n    |\n LL | n!(f);\n    | ------ in this macro invocation\n ...\n LL |                 f //~ ERROR cannot find function `f` in this scope\n    |                 ^ not found in this scope\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}