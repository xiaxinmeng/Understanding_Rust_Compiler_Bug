{"sha": "ee2e115995bdb485cfe2ee71e66cca29206714c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMmUxMTU5OTViZGI0ODVjZmUyZWU3MWU2NmNjYTI5MjA2NzE0YzQ=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-09-27T00:29:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T00:29:49Z"}, "message": "Rollup merge of #36729 - frewsxcv:rustdoc, r=alexcrichton\n\nlibrustdoc refactoring and cleanup.\n\nSee each commit for more information. Biggest changes here is the addition of a `passes` module and each pass now lives in its own submodule.", "tree": {"sha": "d62e1ddda241f6b39e0f50cac6d9872dfa3c4cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d62e1ddda241f6b39e0f50cac6d9872dfa3c4cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee2e115995bdb485cfe2ee71e66cca29206714c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2e115995bdb485cfe2ee71e66cca29206714c4", "html_url": "https://github.com/rust-lang/rust/commit/ee2e115995bdb485cfe2ee71e66cca29206714c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee2e115995bdb485cfe2ee71e66cca29206714c4/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df52628ee39724b365ba7dc3f60a1856ea7b0566", "url": "https://api.github.com/repos/rust-lang/rust/commits/df52628ee39724b365ba7dc3f60a1856ea7b0566", "html_url": "https://github.com/rust-lang/rust/commit/df52628ee39724b365ba7dc3f60a1856ea7b0566"}, {"sha": "99e1b9cfa6891077509d183975d96a923775a26c", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e1b9cfa6891077509d183975d96a923775a26c", "html_url": "https://github.com/rust-lang/rust/commit/99e1b9cfa6891077509d183975d96a923775a26c"}], "stats": {"total": 1003, "additions": 552, "deletions": 451}, "files": [{"sha": "1ff84b95da6a4c54414f9418b5a0d84d1dfd2e0c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -91,39 +91,14 @@ pub mod test;\n \n use clean::Attributes;\n \n-type Pass = (&'static str,                                      // name\n-             fn(clean::Crate) -> plugins::PluginResult,         // fn\n-             &'static str);                                     // description\n-\n-const PASSES: &'static [Pass] = &[\n-    (\"strip-hidden\", passes::strip_hidden,\n-     \"strips all doc(hidden) items from the output\"),\n-    (\"unindent-comments\", passes::unindent_comments,\n-     \"removes excess indentation on comments in order for markdown to like it\"),\n-    (\"collapse-docs\", passes::collapse_docs,\n-     \"concatenates all document attributes into one document attribute\"),\n-    (\"strip-private\", passes::strip_private,\n-     \"strips all private items from a crate which cannot be seen externally, \\\n-      implies strip-priv-imports\"),\n-    (\"strip-priv-imports\", passes::strip_priv_imports,\n-     \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n-];\n-\n-const DEFAULT_PASSES: &'static [&'static str] = &[\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-];\n-\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n     passes: Vec<String>,\n }\n \n pub fn main() {\n-    const STACK_SIZE: usize = 32000000; // 32MB\n+    const STACK_SIZE: usize = 32_000_000; // 32MB\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n@@ -223,11 +198,11 @@ pub fn main_args(args: &[String]) -> isize {\n \n     if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n-        for &(name, _, description) in PASSES {\n+        for &(name, _, description) in passes::PASSES {\n             println!(\"{:>20} - {}\", name, description);\n         }\n         println!(\"\\nDefault passes for rustdoc:\");\n-        for &name in DEFAULT_PASSES {\n+        for &name in passes::DEFAULT_PASSES {\n             println!(\"{:>20}\", name);\n         }\n         return 0;\n@@ -236,7 +211,8 @@ pub fn main_args(args: &[String]) -> isize {\n     if matches.free.is_empty() {\n         println!(\"expected an input file to act on\");\n         return 1;\n-    } if matches.free.len() > 1 {\n+    }\n+    if matches.free.len() > 1 {\n         println!(\"only one input file may be specified\");\n         return 1;\n     }\n@@ -412,7 +388,7 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     }\n \n     if default_passes {\n-        for name in DEFAULT_PASSES.iter().rev() {\n+        for name in passes::DEFAULT_PASSES.iter().rev() {\n             passes.insert(0, name.to_string());\n         }\n     }\n@@ -422,11 +398,11 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n                       .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n     let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n     for pass in &passes {\n-        let plugin = match PASSES.iter()\n-                                 .position(|&(p, ..)| {\n-                                     p == *pass\n-                                 }) {\n-            Some(i) => PASSES[i].1,\n+        let plugin = match passes::PASSES.iter()\n+                                         .position(|&(p, ..)| {\n+                                             p == *pass\n+                                         }) {\n+            Some(i) => passes::PASSES[i].1,\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n                 continue"}, {"sha": "c60e22824965f97248cee5444111f0b20758c88d", "filename": "src/librustdoc/passes.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/df52628ee39724b365ba7dc3f60a1856ea7b0566/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df52628ee39724b365ba7dc3f60a1856ea7b0566/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=df52628ee39724b365ba7dc3f60a1856ea7b0566", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::privacy::AccessLevels;\n-use rustc::util::nodemap::DefIdSet;\n-use std::cmp;\n-use std::mem;\n-use std::string::String;\n-use std::usize;\n-\n-use clean::{self, Attributes, GetDefId};\n-use clean::Item;\n-use plugins;\n-use fold;\n-use fold::DocFolder;\n-use fold::FoldItem::Strip;\n-\n-/// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut retained = DefIdSet();\n-\n-    // strip all #[doc(hidden)] items\n-    let krate = {\n-        struct Stripper<'a> {\n-            retained: &'a mut DefIdSet,\n-            update_retained: bool,\n-        }\n-        impl<'a> fold::DocFolder for Stripper<'a> {\n-            fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if i.attrs.list(\"doc\").has_word(\"hidden\") {\n-                    debug!(\"found one in strip_hidden; removing\");\n-                    // use a dedicated hidden item for given item type if any\n-                    match i.inner {\n-                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n-                            // We need to recurse into stripped modules to\n-                            // strip things like impl methods but when doing so\n-                            // we must not add any items to the `retained` set.\n-                            let old = mem::replace(&mut self.update_retained, false);\n-                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                            self.update_retained = old;\n-                            return ret;\n-                        }\n-                        _ => return None,\n-                    }\n-                } else {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                }\n-                self.fold_item_recur(i)\n-            }\n-        }\n-        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n-        stripper.fold_crate(krate)\n-    };\n-\n-    // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-/// Strip private items from the point of view of a crate or externally from a\n-/// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n-    // This stripper collects all *retained* nodes.\n-    let mut retained = DefIdSet();\n-    let access_levels = krate.access_levels.clone();\n-\n-    // strip all private items\n-    {\n-        let mut stripper = Stripper {\n-            retained: &mut retained,\n-            access_levels: &access_levels,\n-            update_retained: true,\n-        };\n-        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n-    }\n-\n-    // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n-    access_levels: &'a AccessLevels<DefId>,\n-    update_retained: bool,\n-}\n-\n-impl<'a> fold::DocFolder for Stripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::StrippedItem(..) => {\n-                // We need to recurse into stripped modules to strip things\n-                // like impl methods but when doing so we must not add any\n-                // items to the `retained` set.\n-                let old = mem::replace(&mut self.update_retained, false);\n-                let ret = self.fold_item_recur(i);\n-                self.update_retained = old;\n-                return ret;\n-            }\n-            // These items can all get re-exported\n-            clean::TypedefItem(..) | clean::StaticItem(..) |\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TraitItem(..) | clean::FunctionItem(..) |\n-            clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::UnionItem(..) => {\n-                if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            clean::StructFieldItem(..) => {\n-                if i.visibility != Some(clean::Public) {\n-                    return Strip(i).fold();\n-                }\n-            }\n-\n-            clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                    self.update_retained = old;\n-                    return ret;\n-                }\n-            }\n-\n-            // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n-\n-            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n-\n-            // tymethods/macros have no control over privacy\n-            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n-\n-            // Primitives are never stripped\n-            clean::PrimitiveItem(..) => {}\n-\n-            // Associated consts and types are never stripped\n-            clean::AssociatedConstItem(..) |\n-            clean::AssociatedTypeItem(..) => {}\n-        }\n-\n-        let fastreturn = match i.inner {\n-            // nothing left to do for traits (don't want to filter their\n-            // methods out, visibility controlled by the trait)\n-            clean::TraitItem(..) => true,\n-\n-            // implementations of traits are always public.\n-            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant {\n-                kind: clean::StructVariant(..)\n-            }) => true,\n-            _ => false,\n-        };\n-\n-        let i = if fastreturn {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-            return Some(i);\n-        } else {\n-            self.fold_item_recur(i)\n-        };\n-\n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                _ => {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                    Some(i)\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-// This stripper discards all impls which reference stripped items\n-struct ImplStripper<'a> {\n-    retained: &'a DefIdSet\n-}\n-\n-impl<'a> fold::DocFolder for ImplStripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n-                return None;\n-            }\n-            if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() &&\n-                    !self.retained.contains(&did)\n-                {\n-                    return None;\n-                }\n-            }\n-            if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n-                    return None;\n-                }\n-            }\n-        }\n-        self.fold_item_recur(i)\n-    }\n-}\n-\n-// This stripper discards all private import statements (`use`, `extern crate`)\n-struct ImportStripper;\n-impl fold::DocFolder for ImportStripper {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ExternCrateItem(..) |\n-            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n-            _ => self.fold_item_recur(i)\n-        }\n-    }\n-}\n-\n-pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n-    ImportStripper.fold_crate(krate)\n-}\n-\n-pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n-    struct CommentCleaner;\n-    impl fold::DocFolder for CommentCleaner {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut avec: Vec<clean::Attribute> = Vec::new();\n-            for attr in &i.attrs {\n-                match attr {\n-                    &clean::NameValue(ref x, ref s)\n-                            if \"doc\" == *x => {\n-                        avec.push(clean::NameValue(\"doc\".to_string(),\n-                                                   unindent(s)))\n-                    }\n-                    x => avec.push(x.clone())\n-                }\n-            }\n-            i.attrs = avec;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut cleaner = CommentCleaner;\n-    let krate = cleaner.fold_crate(krate);\n-    krate\n-}\n-\n-pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n-    struct Collapser;\n-    impl fold::DocFolder for Collapser {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut docstr = String::new();\n-            for attr in &i.attrs {\n-                if let clean::NameValue(ref x, ref s) = *attr {\n-                    if \"doc\" == *x {\n-                        docstr.push_str(s);\n-                        docstr.push('\\n');\n-                    }\n-                }\n-            }\n-            let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n-                _ => true\n-            }).cloned().collect();\n-            if !docstr.is_empty() {\n-                a.push(clean::NameValue(\"doc\".to_string(), docstr));\n-            }\n-            i.attrs = a;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut collapser = Collapser;\n-    let krate = collapser.fold_crate(krate);\n-    krate\n-}\n-\n-pub fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str> >();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line &&\n-            !saw_second_line &&\n-            !line.chars().all(|c| c.is_whitespace());\n-\n-        let min_indent = if ignore_previous_indents {\n-            usize::MAX\n-        } else {\n-            min_indent\n-        };\n-\n-        if saw_first_line {\n-            saw_second_line = true;\n-        }\n-\n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n-        } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n-                } else {\n-                    false\n-                }\n-            });\n-            cmp::min(min_indent, whitespace)\n-        }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![ lines[0].trim().to_string() ];\n-        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n-            if line.chars().all(|c| c.is_whitespace()) {\n-                line.to_string()\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line[min_indent..].to_string()\n-            }\n-        }).collect::<Vec<_>>());\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod unindent_tests {\n-    use super::unindent;\n-\n-    #[test]\n-    fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_leave_multiple_indent_levels() {\n-        // Line 2 is indented another level beyond the\n-        // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_ignore_first_line_indent() {\n-        // The first line of the first paragraph may not be indented as\n-        // far due to the way the doc string was written:\n-        //\n-        // #[doc = \"Start way over here\n-        //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_tabs() {\n-        let s = \"\\tline1\\n\\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_trim_mixed_indentation() {\n-        let s = \"\\t    line1\\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-\n-        let s = \"    \\tline1\\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-}"}, {"sha": "c034ef9326846c349b7761606918c72bd1fad35d", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::string::String;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+\n+pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut collapser = Collapser;\n+    let krate = collapser.fold_crate(krate);\n+    krate\n+}\n+\n+struct Collapser;\n+\n+impl fold::DocFolder for Collapser {\n+    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+        let mut docstr = String::new();\n+        for attr in &i.attrs {\n+            if let clean::NameValue(ref x, ref s) = *attr {\n+                if \"doc\" == *x {\n+                    docstr.push_str(s);\n+                    docstr.push('\\n');\n+                }\n+            }\n+        }\n+        let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n+            &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n+            _ => true\n+        }).cloned().collect();\n+        if !docstr.is_empty() {\n+            a.push(clean::NameValue(\"doc\".to_string(), docstr));\n+        }\n+        i.attrs = a;\n+        self.fold_item_recur(i)\n+    }\n+}"}, {"sha": "a1b330e9b842349e72f68f3d37b7846a2723e5e0", "filename": "src/librustdoc/passes/mod.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,204 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, GetDefId, Item};\n+use fold;\n+use fold::FoldItem::Strip;\n+use plugins;\n+\n+mod collapse_docs;\n+pub use self::collapse_docs::collapse_docs;\n+\n+mod strip_hidden;\n+pub use self::strip_hidden::strip_hidden;\n+\n+mod strip_private;\n+pub use self::strip_private::strip_private;\n+\n+mod strip_priv_imports;\n+pub use self::strip_priv_imports::strip_priv_imports;\n+\n+mod unindent_comments;\n+pub use self::unindent_comments::unindent_comments;\n+\n+type Pass = (&'static str,                                      // name\n+             fn(clean::Crate) -> plugins::PluginResult,         // fn\n+             &'static str);                                     // description\n+\n+pub const PASSES: &'static [Pass] = &[\n+    (\"strip-hidden\", strip_hidden,\n+     \"strips all doc(hidden) items from the output\"),\n+    (\"unindent-comments\", unindent_comments,\n+     \"removes excess indentation on comments in order for markdown to like it\"),\n+    (\"collapse-docs\", collapse_docs,\n+     \"concatenates all document attributes into one document attribute\"),\n+    (\"strip-private\", strip_private,\n+     \"strips all private items from a crate which cannot be seen externally, \\\n+      implies strip-priv-imports\"),\n+    (\"strip-priv-imports\", strip_priv_imports,\n+     \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n+];\n+\n+pub const DEFAULT_PASSES: &'static [&'static str] = &[\n+    \"strip-hidden\",\n+    \"strip-private\",\n+    \"collapse-docs\",\n+    \"unindent-comments\",\n+];\n+\n+\n+struct Stripper<'a> {\n+    retained: &'a mut DefIdSet,\n+    access_levels: &'a AccessLevels<DefId>,\n+    update_retained: bool,\n+}\n+\n+impl<'a> fold::DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n+            // These items can all get re-exported\n+            clean::TypedefItem(..) | clean::StaticItem(..) |\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TraitItem(..) | clean::FunctionItem(..) |\n+            clean::VariantItem(..) | clean::MethodItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::UnionItem(..) => {\n+                if i.def_id.is_local() {\n+                    if !self.access_levels.is_exported(i.def_id) {\n+                        return None;\n+                    }\n+                }\n+            }\n+\n+            clean::StructFieldItem(..) => {\n+                if i.visibility != Some(clean::Public) {\n+                    return Strip(i).fold();\n+                }\n+            }\n+\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+            }\n+\n+            // handled in the `strip-priv-imports` pass\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n+\n+            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n+\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n+\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n+            clean::AssociatedTypeItem(..) => {}\n+        }\n+\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(..) => true,\n+\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // Struct variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant {\n+                kind: clean::StructVariant(..)\n+            }) => true,\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                _ => {\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n+                    Some(i)\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+// This stripper discards all impls which reference stripped items\n+struct ImplStripper<'a> {\n+    retained: &'a DefIdSet\n+}\n+\n+impl<'a> fold::DocFolder for ImplStripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !imp.for_.is_generic() &&\n+                    !self.retained.contains(&did)\n+                {\n+                    return None;\n+                }\n+            }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    return None;\n+                }\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+// This stripper discards all private import statements (`use`, `extern crate`)\n+struct ImportStripper;\n+impl fold::DocFolder for ImportStripper {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ExternCrateItem(..) |\n+            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n+            _ => self.fold_item_recur(i)\n+        }\n+    }\n+}"}, {"sha": "927ccf917199978221c2488262aa97e838869e03", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, Attributes};\n+use clean::Item;\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+use fold::FoldItem::Strip;\n+use passes::ImplStripper;\n+\n+/// Strip items marked `#[doc(hidden)]`\n+pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut retained = DefIdSet();\n+\n+    // strip all #[doc(hidden)] items\n+    let krate = {\n+        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n+        stripper.fold_crate(krate)\n+    };\n+\n+    // strip all impls referencing stripped items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}\n+\n+struct Stripper<'a> {\n+    retained: &'a mut DefIdSet,\n+    update_retained: bool,\n+}\n+\n+impl<'a> fold::DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if i.attrs.list(\"doc\").has_word(\"hidden\") {\n+            debug!(\"found one in strip_hidden; removing\");\n+            // use a dedicated hidden item for given item type if any\n+            match i.inner {\n+                clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                    // We need to recurse into stripped modules to\n+                    // strip things like impl methods but when doing so\n+                    // we must not add any items to the `retained` set.\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+                _ => return None,\n+            }\n+        } else {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}"}, {"sha": "91f8be43c281a629de133d6de245e973fc35191c", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean;\n+use fold::DocFolder;\n+use plugins;\n+use passes::ImportStripper;\n+\n+pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n+    ImportStripper.fold_crate(krate)\n+}"}, {"sha": "acd735739e4887520b3c36a605f487239d6a7de8", "filename": "src/librustdoc/passes/strip_private.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+\n+use clean;\n+use plugins;\n+use fold::DocFolder;\n+use passes::{ImplStripper, ImportStripper, Stripper};\n+\n+/// Strip private items from the point of view of a crate or externally from a\n+/// crate, specified by the `xcrate` flag.\n+pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n+    // This stripper collects all *retained* nodes.\n+    let mut retained = DefIdSet();\n+    let access_levels = krate.access_levels.clone();\n+\n+    // strip all private items\n+    {\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            access_levels: &access_levels,\n+            update_retained: true,\n+        };\n+        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n+    }\n+\n+    // strip all impls referencing private items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}"}, {"sha": "20640f3f88518f98d2c8f7269a9377a9f698559e", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2e115995bdb485cfe2ee71e66cca29206714c4/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=ee2e115995bdb485cfe2ee71e66cca29206714c4", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+use std::string::String;\n+use std::usize;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold::{self, DocFolder};\n+\n+pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut cleaner = CommentCleaner;\n+    let krate = cleaner.fold_crate(krate);\n+    krate\n+}\n+\n+struct CommentCleaner;\n+\n+impl fold::DocFolder for CommentCleaner {\n+    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+        let mut avec: Vec<clean::Attribute> = Vec::new();\n+        for attr in &i.attrs {\n+            match attr {\n+                &clean::NameValue(ref x, ref s)\n+                        if \"doc\" == *x => {\n+                    avec.push(clean::NameValue(\"doc\".to_string(),\n+                                               unindent(s)))\n+                }\n+                x => avec.push(x.clone())\n+            }\n+        }\n+        i.attrs = avec;\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+fn unindent(s: &str) -> String {\n+    let lines = s.lines().collect::<Vec<&str> >();\n+    let mut saw_first_line = false;\n+    let mut saw_second_line = false;\n+    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n+\n+        // After we see the first non-whitespace line, look at\n+        // the line we have. If it is not whitespace, and therefore\n+        // part of the first paragraph, then ignore the indentation\n+        // level of the first line\n+        let ignore_previous_indents =\n+            saw_first_line &&\n+            !saw_second_line &&\n+            !line.chars().all(|c| c.is_whitespace());\n+\n+        let min_indent = if ignore_previous_indents {\n+            usize::MAX\n+        } else {\n+            min_indent\n+        };\n+\n+        if saw_first_line {\n+            saw_second_line = true;\n+        }\n+\n+        if line.chars().all(|c| c.is_whitespace()) {\n+            min_indent\n+        } else {\n+            saw_first_line = true;\n+            let mut whitespace = 0;\n+            line.chars().all(|char| {\n+                // Compare against either space or tab, ignoring whether they\n+                // are mixed or not\n+                if char == ' ' || char == '\\t' {\n+                    whitespace += 1;\n+                    true\n+                } else {\n+                    false\n+                }\n+            });\n+            cmp::min(min_indent, whitespace)\n+        }\n+    });\n+\n+    if !lines.is_empty() {\n+        let mut unindented = vec![ lines[0].trim().to_string() ];\n+        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n+            if line.chars().all(|c| c.is_whitespace()) {\n+                line.to_string()\n+            } else {\n+                assert!(line.len() >= min_indent);\n+                line[min_indent..].to_string()\n+            }\n+        }).collect::<Vec<_>>());\n+        unindented.join(\"\\n\")\n+    } else {\n+        s.to_string()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod unindent_tests {\n+    use super::unindent;\n+\n+    #[test]\n+    fn should_unindent() {\n+        let s = \"    line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_multiple_paragraphs() {\n+        let s = \"    line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_leave_multiple_indent_levels() {\n+        // Line 2 is indented another level beyond the\n+        // base indentation and should be preserved\n+        let s = \"    line1\\n\\n        line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_ignore_first_line_indent() {\n+        // The first line of the first paragraph may not be indented as\n+        // far due to the way the doc string was written:\n+        //\n+        // #[doc = \"Start way over here\n+        //          and continue here\"]\n+        let s = \"line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n+        let s = \"line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_tabs() {\n+        let s = \"\\tline1\\n\\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_trim_mixed_indentation() {\n+        let s = \"\\t    line1\\n\\t    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+\n+        let s = \"    \\tline1\\n    \\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+}"}]}