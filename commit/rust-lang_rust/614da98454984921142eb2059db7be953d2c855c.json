{"sha": "614da98454984921142eb2059db7be953d2c855c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNGRhOTg0NTQ5ODQ5MjExNDJlYjIwNTlkYjdiZTk1M2QyYzg1NWM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-17T19:27:48Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-18T19:46:14Z"}, "message": "review comments", "tree": {"sha": "676ab4468dfcf92cb94cc9343da1a759a3e8dc02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/676ab4468dfcf92cb94cc9343da1a759a3e8dc02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/614da98454984921142eb2059db7be953d2c855c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/614da98454984921142eb2059db7be953d2c855c", "html_url": "https://github.com/rust-lang/rust/commit/614da98454984921142eb2059db7be953d2c855c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/614da98454984921142eb2059db7be953d2c855c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "html_url": "https://github.com/rust-lang/rust/commit/d7efa5bd6a22a07cf50a7abe0542a830d91aa182"}], "stats": {"total": 78, "additions": 45, "deletions": 33}, "files": [{"sha": "18f083e154a86eb523d22eefb95563452e9a76ad", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/614da98454984921142eb2059db7be953d2c855c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/614da98454984921142eb2059db7be953d2c855c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=614da98454984921142eb2059db7be953d2c855c", "patch": "@@ -1244,6 +1244,42 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n     }\n \n+    /// Given a closure's `DefId`, return the given name of the closure.\n+    ///\n+    /// This doesn't account for reassignments, but it's only used for suggestions.\n+    fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String> {\n+        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n+            // Get the local name of this closure. This can be inaccurate because\n+            // of the possibility of reassignment, but this should be good enough.\n+            match &kind {\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                    Some(format!(\"{}\", name))\n+                }\n+                _ => {\n+                    err.note(&msg);\n+                    None\n+                }\n+            }\n+        };\n+\n+        let hir = self.tcx.hir();\n+        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let parent_node = hir.get_parent_node(hir_id);\n+        match hir.find(parent_node) {\n+            Some(hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Local(local), ..\n+            })) => get_name(err, &local.pat.kind),\n+            // Different to previous arm because one is `&hir::Local` and the other\n+            // is `P<hir::Local>`.\n+            Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n+            _ => return None,\n+        }\n+    }\n \n     /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n     /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n@@ -1274,19 +1310,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             obligation.param_env,\n         );\n \n-        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n-            // Get the local name of this closure. This can be inaccurate because\n-            // of the possibility of reassignment, but this should be good enough.\n-            match &kind {\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n-                    Some(format!(\"{}\", name))\n-                }\n-                _ => {\n-                    err.note(&msg);\n-                    None\n-                }\n-            }\n-        };\n         match self.evaluate_obligation(&obligation) {\n             Ok(EvaluationResult::EvaluatedToOk) |\n             Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n@@ -1301,29 +1324,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ..\n             })) => {\n                 err.span_label(*span, \"consider calling this closure\");\n-                let hir_id = match hir.as_local_hir_id(def_id) {\n-                    Some(hir_id) => hir_id,\n+                let name = match self.get_closure_name(def_id, err, &msg) {\n+                    Some(name) => name,\n                     None => return,\n                 };\n-                let parent_node = hir.get_parent_node(hir_id);\n-                let name = match hir.find(parent_node) {\n-                    Some(hir::Node::Stmt(hir::Stmt {\n-                        kind: hir::StmtKind::Local(local), ..\n-                    })) => match get_name(err, &local.pat.kind) {\n-                        Some(name) => name,\n-                        None => return,\n-                    },\n-                    // Different to previous arm because one is `&hir::Local` and the other\n-                    // is `P<hir::Local>`.\n-                    Some(hir::Node::Local(local)) => match get_name(err, &local.pat.kind) {\n-                        Some(name) => name,\n-                        None => return,\n-                    },\n-                    _ => return,\n-                };\n                 let args = decl.inputs.iter()\n                     .map(|_| \"_\")\n-                    .collect::<Vec<_>>().join(\", \");\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n                 format!(\"{}({})\", name, args)\n             }\n             Some(hir::Node::Item(hir::Item {\n@@ -1336,9 +1344,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let args = body.params.iter()\n                     .map(|arg| match &arg.pat.kind {\n                         hir::PatKind::Binding(_, _, ident, None)\n+                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n+                        // should suggest a method call.\n                         if ident.name != kw::SelfLower => ident.to_string(),\n                         _ => \"_\".to_string(),\n-                    }).collect::<Vec<_>>().join(\", \");\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n                 format!(\"{}({})\", ident, args)\n             }\n             _ => return,"}]}