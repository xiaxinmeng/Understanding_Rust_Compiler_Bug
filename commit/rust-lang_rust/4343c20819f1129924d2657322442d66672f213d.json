{"sha": "4343c20819f1129924d2657322442d66672f213d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNDNjMjA4MTlmMTEyOTkyNGQyNjU3MzIyNDQyZDY2NjcyZjIxM2Q=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-15T10:45:12Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:23:46Z"}, "message": "Use ty::Generics instead of hir::Generics for various checks", "tree": {"sha": "5ab039e443d88f64634c934ed152e7c2a3068faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab039e443d88f64634c934ed152e7c2a3068faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4343c20819f1129924d2657322442d66672f213d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4343c20819f1129924d2657322442d66672f213d", "html_url": "https://github.com/rust-lang/rust/commit/4343c20819f1129924d2657322442d66672f213d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4343c20819f1129924d2657322442d66672f213d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde942bb646b07e6cf3cddf9bf379e42a6c79ed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde942bb646b07e6cf3cddf9bf379e42a6c79ed8", "html_url": "https://github.com/rust-lang/rust/commit/dde942bb646b07e6cf3cddf9bf379e42a6c79ed8"}], "stats": {"total": 69, "additions": 40, "deletions": 29}, "files": [{"sha": "7f81af7e46c7d28eba9d3e59007261fef30e62f8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4343c20819f1129924d2657322442d66672f213d", "patch": "@@ -20,7 +20,7 @@ use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, GenericParamDefKind};\n use ty::query::Providers;\n use middle::privacy;\n use session::config;\n@@ -29,19 +29,19 @@ use util::nodemap::{NodeSet, FxHashSet};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use hir::{self, GenericParamKind};\n+use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n-fn generics_require_inlining(generics: &hir::Generics) -> bool {\n+fn generics_require_inlining(generics: &ty::Generics) -> bool {\n     for param in &generics.params {\n         match param.kind {\n-            GenericParamKind::Lifetime { .. } => {}\n-            GenericParamKind::Type { .. } => return true,\n+            GenericParamDefKind::Lifetime { .. } => {}\n+            GenericParamDefKind::Type { .. } => return true,\n         }\n     }\n     false\n@@ -50,14 +50,17 @@ fn generics_require_inlining(generics: &hir::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         item: &hir::Item,\n+                         attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n \n     match item.node {\n-        hir::ItemImpl(_, _, _, ref generics, ..) |\n-        hir::ItemFn(.., ref generics, _) => {\n+        hir::ItemImpl(..) |\n+        hir::ItemFn(..) => {\n+            let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -68,14 +71,14 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    if codegen_fn_attrs.requests_inline() ||\n-        generics_require_inlining(&impl_item.generics) {\n+    let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n+    if codegen_fn_attrs.requests_inline() || generics_require_inlining(generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item, codegen_fn_attrs),\n+                item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -169,7 +172,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(..) =>\n-                        item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)),\n+                        item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -186,7 +189,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        if generics_require_inlining(&impl_item.generics) ||\n+                        let generics = self.tcx.generics_of(def_id);\n+                        if generics_require_inlining(&generics) ||\n                                 attrs.requests_inline() {\n                             true\n                         } else {\n@@ -198,8 +202,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n-                                hir::ItemImpl(_, _, _, ref generics, ..) => {\n-                                    generics_require_inlining(generics)\n+                                hir::ItemImpl(..) => {\n+                                    let generics = self.tcx.generics_of(impl_did);\n+                                    generics_require_inlining(&generics)\n                                 }\n                                 _ => false\n                             }\n@@ -257,7 +262,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n-                        if item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)) {\n+                        if item_might_be_inlined(self.tcx,\n+                                                 &item,\n+                                                 self.tcx.codegen_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "50492ae073720b62fef99564f6df441697fa2407", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4343c20819f1129924d2657322442d66672f213d", "patch": "@@ -810,15 +810,16 @@ impl LintPass for VariantSizeDifferences {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemEnum(ref enum_definition, ref generics) = it.node {\n+        if let hir::ItemEnum(ref enum_definition, _) = it.node {\n+            let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+            let generics = cx.tcx.generics_of(item_def_id);\n             for param in &generics.params {\n                 match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {},\n-                    hir::GenericParamKind::Type { .. } => return,\n+                    ty::GenericParamDefKind::Lifetime { .. } => {},\n+                    ty::GenericParamDefKind::Type { .. } => return,\n                 }\n             }\n             // Sizes only make sense for non-generic types.\n-            let item_def_id = cx.tcx.hir.local_def_id(it.id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n             match cx.layout_of(ty) {"}, {"sha": "cbe9615c69397c644e18b5c44652198aaaad30c5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4343c20819f1129924d2657322442d66672f213d", "patch": "@@ -1235,9 +1235,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     self.encode_optimized_mir(def_id)\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemFn(_, _, constness, _, ref generics, _) => {\n+                hir::ItemFn(_, _, constness, ..) => {\n+                    let generics = tcx.generics_of(def_id);\n                     let has_types = generics.params.iter().any(|param| match param.kind {\n-                        hir::GenericParamKind::Type { .. } => true,\n+                        ty::GenericParamDefKind::Type { .. } => true,\n                         _ => false,\n                     });\n                     let needs_inline ="}, {"sha": "0a16cbeccd103d9db1cc04c32fc8795f73f19f66", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343c20819f1129924d2657322442d66672f213d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4343c20819f1129924d2657322442d66672f213d", "patch": "@@ -1261,10 +1261,11 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n       hir::ItemUnion(..) => {\n         check_union(tcx, it.id, it.span);\n       }\n-      hir::ItemTy(_, ref generics) => {\n+      hir::ItemTy(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         let pty_ty = tcx.type_of(def_id);\n-        check_bounds_are_used(tcx, generics, pty_ty);\n+        let generics = tcx.generics_of(def_id);\n+        check_bounds_are_used(tcx, &generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n         check_abi(tcx, it.span, m.abi);\n@@ -5178,7 +5179,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       generics: &hir::Generics,\n+                                       generics: &ty::Generics,\n                                        ty: Ty<'tcx>) {\n     let own_counts = generics.own_counts();\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\", own_counts.types, ty);\n@@ -5202,14 +5203,15 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let types = generics.params.iter().filter(|param| match param.kind {\n-        hir::GenericParamKind::Type { .. } => true,\n+        ty::GenericParamDefKind::Type { .. } => true,\n         _ => false,\n     });\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n-            struct_span_err!(tcx.sess, param.span, E0091, \"type parameter `{}` is unused\",\n-                             param.name.name())\n-                .span_label(param.span, \"unused type parameter\")\n+            let id = tcx.hir.as_local_node_id(param.def_id).unwrap();\n+            let span = tcx.hir.span(id);\n+            struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n+                .span_label(span, \"unused type parameter\")\n                 .emit();\n         }\n     }"}]}