{"sha": "a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NjVkMGFkNzM2ZDc2MjgxZmU0N2RjZGY4YzBjMDk1ZTc3ZWRhZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T06:40:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T06:40:13Z"}, "message": "Auto merge of #4649 - Lythenas:use_match_function_call, r=phansch\n\nUse match_function_call wherever possible\n\nMove `match_function_call` to `utils` and use it wherever possible as discussed in #4635.\n\nchangelog: none", "tree": {"sha": "55cc9cad2b84f9120395cf5aa505cfb610c8ce7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55cc9cad2b84f9120395cf5aa505cfb610c8ce7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "html_url": "https://github.com/rust-lang/rust/commit/a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0e89739412c6ddd8cc97c9de3d142da6fa9f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0e89739412c6ddd8cc97c9de3d142da6fa9f10", "html_url": "https://github.com/rust-lang/rust/commit/4d0e89739412c6ddd8cc97c9de3d142da6fa9f10"}, {"sha": "15b433af48c3d4c4cc0e0e4871275b0dd05a35d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b433af48c3d4c4cc0e0e4871275b0dd05a35d1", "html_url": "https://github.com/rust-lang/rust/commit/15b433af48c3d4c4cc0e0e4871275b0dd05a35d1"}], "stats": {"total": 107, "additions": 45, "deletions": 62}, "files": [{"sha": "853c3100674ba7cddaf20adb8c10b2b1fea8fd8c", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,6 +1,6 @@\n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, snippet_opt, span_help_and_lint};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_function_call, snippet_opt, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -145,23 +145,3 @@ fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx E\n     }\n     None\n }\n-\n-/// Matches a function call with the given path and returns the arguments.\n-///\n-/// Usage:\n-///\n-/// ```rust,ignore\n-/// if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n-/// ```\n-fn match_function_call<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, path: &[&str]) -> Option<&'a [Expr]> {\n-    if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(fun_def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, path);\n-        then {\n-            return Some(&args)\n-        }\n-    };\n-    None\n-}"}, {"sha": "7b7839c502d89d56124e76e01751be9f682082de", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_expn_of, match_def_path, paths, resolve_node, span_lint, span_lint_and_sugg};\n+use crate::utils::{is_expn_of, match_function_call, paths, span_lint, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -41,12 +41,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n-            if let ExprKind::Call(ref dest_fun, _) = write_args[0].kind;\n-            if let ExprKind::Path(ref qpath) = dest_fun.kind;\n-            if let Some(dest_fun_id) = resolve_node(cx, qpath, dest_fun.hir_id).opt_def_id();\n-            if let Some(dest_name) = if match_def_path(cx, dest_fun_id, &paths::STDOUT) {\n+            if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n-            } else if match_def_path(cx, dest_fun_id, &paths::STDERR) {\n+            } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None"}, {"sha": "e5f22828d34c4588366eae4096b492dc40fcf64f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_expn_of, last_path_segment, match_def_path, match_type, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty,\n+    is_expn_of, last_path_segment, match_def_path, match_function_call, match_type, snippet, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -70,19 +71,16 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'a [Arm]) -> Option<String> {\n+fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'tcx [Arm]) -> Option<String> {\n     if_chain! {\n         if let ExprKind::AddrOf(_, ref format_args) = expr.kind;\n         if let ExprKind::Array(ref elems) = arms[0].body.kind;\n         if elems.len() == 1;\n-        if let ExprKind::Call(ref fun, ref args) = elems[0].kind;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::FMT_ARGUMENTV1_NEW);\n+        if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n         // matches `core::fmt::Display::fmt`\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n+        if let Some(did) = cx.tables.qpath_res(qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n@@ -114,11 +112,8 @@ fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arm\n \n fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1);\n         // Argument 1 in `new_v1()`\n         if let ExprKind::AddrOf(_, ref arr) = args[0].kind;\n         if let ExprKind::Array(ref pieces) = arr.kind;\n@@ -144,11 +139,8 @@ fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<S\n \n fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n         if args.len() == 3;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n         if check_unformatted(&args[2]);\n         // Argument 1 in `new_v1_formatted()`\n         if let ExprKind::AddrOf(_, ref arr) = args[0].kind;"}, {"sha": "da2110485efa4dc1b6c234bde551531db8591eb3", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,7 +1,6 @@\n use crate::utils::{\n-    match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then,\n+    match_def_path, match_trait_method, paths, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then,\n };\n-use crate::utils::{paths, resolve_node};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, impl_lint_pass};\n@@ -88,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n \n             ExprKind::Call(ref path, ref args) => {\n                 if let ExprKind::Path(ref qpath) = path.kind {\n-                    if let Some(def_id) = resolve_node(cx, qpath, path.hir_id).opt_def_id() {\n+                    if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id() {\n                         if match_def_path(cx, def_id, &paths::FROM_FROM) {\n                             let a = cx.tables.expr_ty(e);\n                             let b = cx.tables.expr_ty(&args[0]);"}, {"sha": "c6cf021af01fd211d33355b1f8b854dc726d617d", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{\n     match_def_path,\n     paths::{BEGIN_PANIC, BEGIN_PANIC_FMT},\n-    resolve_node, snippet_opt, span_lint_and_then,\n+    snippet_opt, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc::{\n@@ -109,7 +109,7 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n         ExprKind::Call(expr, ..) => {\n             if_chain! {\n                 if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = resolve_node(cx, qpath, expr.hir_id).opt_def_id();\n+                if let Some(path_def_id) = cx.tables.qpath_res(qpath, expr.hir_id).opt_def_id();\n                 if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n                 then { }"}, {"sha": "762003179134682afe18eeb4fd9b2934c586b8fb", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -1,6 +1,5 @@\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, paths, resolve_node, span_lint};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_function_call, paths, span_lint};\n use if_chain::if_chain;\n-use rustc::hir::ptr::P;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -49,10 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n         if_chain! {\n             if let ExprKind::Block(ref block, _) = expr.kind;\n             if let Some(ref ex) = block.expr;\n-            if let ExprKind::Call(ref fun, ref params) = ex.kind;\n-            if let ExprKind::Path(ref qpath) = fun.kind;\n-            if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-            if match_def_path(cx, fun_def_id, &paths::BEGIN_PANIC);\n+            if let Some(params) = match_function_call(cx, ex, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n             then {\n                 if is_expn_of(expr.span, \"unimplemented\").is_some() {\n@@ -81,7 +77,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n     }\n }\n \n-fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n+fn match_panic(params: &[Expr], expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].kind;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();"}, {"sha": "de974eb3d274c1fec5deed57dbd2b1e1e2385e23", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n+use crate::utils::{is_expn_of, match_def_path, match_qpath, paths};\n use if_chain::if_chain;\n use rustc::lint::LateContext;\n use rustc::{hir, ty};\n@@ -250,9 +250,9 @@ pub enum VecArgs<'a> {\n pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n-        if let hir::ExprKind::Path(ref path) = fun.kind;\n+        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = resolve_node(cx, path, fun.hir_id).opt_def_id();\n+        if let Some(fun_def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n         then {\n             return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case"}, {"sha": "88553bf1d764e4993f8f228bd251737a4f920e99", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a865d0ad736d76281fe47dcdf8c0c095e77edaf4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a865d0ad736d76281fe47dcdf8c0c095e77edaf4", "patch": "@@ -358,11 +358,6 @@ pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-/// Resolves the definition of a node from its `HirId`.\n-pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> Res {\n-    cx.tables.qpath_res(qpath, id)\n-}\n-\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls(expr: &Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&[Expr]>, Vec<Span>) {\n@@ -1085,6 +1080,30 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n     None\n }\n \n+/// Matches a function call with the given path and returns the arguments.\n+///\n+/// Usage:\n+///\n+/// ```rust,ignore\n+/// if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n+/// ```\n+pub fn match_function_call<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    path: &[&str],\n+) -> Option<&'tcx [Expr]> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, fun_def_id, path);\n+        then {\n+            return Some(&args)\n+        }\n+    };\n+    None\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{trim_multiline, without_block_comments};"}]}