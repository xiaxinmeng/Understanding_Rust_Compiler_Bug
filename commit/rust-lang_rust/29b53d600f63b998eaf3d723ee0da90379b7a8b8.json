{"sha": "29b53d600f63b998eaf3d723ee0da90379b7a8b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YjUzZDYwMGY2M2I5OThlYWYzZDcyM2VlMGRhOTAzNzliN2E4Yjg=", "commit": {"author": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-12-27T22:15:09Z"}, "committer": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-12-27T22:15:09Z"}, "message": "Replace `match_method_chain()` with `method_chain_args()`", "tree": {"sha": "793b8e2b675fa1407a7758944c651ccc642da1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/793b8e2b675fa1407a7758944c651ccc642da1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29b53d600f63b998eaf3d723ee0da90379b7a8b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29b53d600f63b998eaf3d723ee0da90379b7a8b8", "html_url": "https://github.com/rust-lang/rust/commit/29b53d600f63b998eaf3d723ee0da90379b7a8b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29b53d600f63b998eaf3d723ee0da90379b7a8b8/comments", "author": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "committer": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1aac931bdb687c12b77980e52458ae921f90f21", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1aac931bdb687c12b77980e52458ae921f90f21", "html_url": "https://github.com/rust-lang/rust/commit/f1aac931bdb687c12b77980e52458ae921f90f21"}], "stats": {"total": 117, "additions": 44, "deletions": 73}, "files": [{"sha": "d4809d374a31e081f008757cc448d381ff7a8ae0", "filename": "src/methods.rs", "status": "modified", "additions": 28, "deletions": 64, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/29b53d600f63b998eaf3d723ee0da90379b7a8b8/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b53d600f63b998eaf3d723ee0da90379b7a8b8/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=29b53d600f63b998eaf3d723ee0da90379b7a8b8", "patch": "@@ -5,9 +5,10 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, match_method_chain,\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n             walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n+use utils::MethodArgs;\n \n use self::SelfKind::*;\n use self::OutType::*;\n@@ -158,20 +159,20 @@ impl LintPass for MethodsPass {\n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(_, _, _) = expr.node {\n-            if match_method_chain(expr, &[\"unwrap\"]) {\n-                lint_unwrap(cx, expr);\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                lint_unwrap(cx, expr, arglists[0]);\n             }\n-            else if match_method_chain(expr, &[\"to_string\"]) {\n-                lint_to_string(cx, expr);\n+            else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+                lint_to_string(cx, expr, arglists[0]);\n             }\n-            else if match_method_chain(expr, &[\"ok\", \"expect\"]) {\n-                lint_ok_expect(cx, expr);\n+            else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+                lint_ok_expect(cx, expr, arglists[0]);\n             }\n-            else if match_method_chain(expr, &[\"map\", \"unwrap_or\"]) {\n-                lint_map_unwrap_or(cx, expr);\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+                lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n             }\n-            else if match_method_chain(expr, &[\"map\", \"unwrap_or_else\"]) {\n-                lint_map_unwrap_or_else(cx, expr);\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n             }\n         }\n     }\n@@ -218,15 +219,10 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &Expr) {\n-    let args = match expr.node {\n-        ExprMethodCall(_, _, ref args) => args,\n-        _ => panic!(\"clippy methods.rs: should not have called `lint_unwrap()` on a non-matching \\\n-                     expression!\"),\n-    };\n-\n-    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n+fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n \n     if match_type(cx, obj_ty, &OPTION_PATH) {\n         span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n@@ -239,18 +235,13 @@ fn lint_unwrap(cx: &LateContext, expr: &Expr) {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `to_string()` for `&str`s and `String`s\n-fn lint_to_string(cx: &LateContext, expr: &Expr) {\n-    let args = match expr.node {\n-        ExprMethodCall(_, _, ref args) => args,\n-        _ => panic!(\"clippy methods.rs: should not have called `lint_to_string()` on a \\\n-                     non-matching expression!\"),\n-    };\n-\n-    let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n+fn lint_to_string(cx: &LateContext, expr: &Expr, to_string_args: &MethodArgs) {\n+    let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&to_string_args[0]));\n \n     if obj_ty.sty == ty::TyStr {\n-        let mut arg_str = snippet(cx, args[0].span, \"_\");\n+        let mut arg_str = snippet(cx, to_string_args[0].span, \"_\");\n         if ptr_depth > 1 {\n             arg_str = Cow::Owned(format!(\n                 \"({}{})\",\n@@ -266,19 +257,9 @@ fn lint_to_string(cx: &LateContext, expr: &Expr) {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &Expr) {\n-    let expect_args = match expr.node {\n-        ExprMethodCall(_, _, ref expect_args) => expect_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_ok_expect()` on a \\\n-                     non-matching expression!\")\n-    };\n-    let ok_args = match expect_args[0].node {\n-        ExprMethodCall(_, _, ref ok_args) => ok_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_ok_expect()` on a \\\n-                     non-matching expression!\")\n-    };\n-\n+fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n         let result_type = cx.tcx.expr_ty(&ok_args[0]);\n@@ -292,19 +273,10 @@ fn lint_ok_expect(cx: &LateContext, expr: &Expr) {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr) {\n-    let unwrap_args = match expr.node {\n-        ExprMethodCall(_, _, ref unwrap_args) => unwrap_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or()` on a \\\n-                     non-matching expression!\")\n-    };\n-    let map_args = match unwrap_args[0].node {\n-        ExprMethodCall(_, _, ref map_args) => map_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or()` on a \\\n-                     non-matching expression!\")\n-    };\n-\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n+                      map_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n@@ -330,19 +302,11 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr) {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr) {\n-    let unwrap_args = match expr.node {\n-        ExprMethodCall(_, _, ref unwrap_args) => unwrap_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or_else()` on a \\\n-                     non-matching expression!\")\n-    };\n-    let map_args = match unwrap_args[0].node {\n-        ExprMethodCall(_, _, ref map_args) => map_args,\n-        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or_else()` on a \\\n-                     non-matching expression!\")\n-    };\n-\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n+                           map_args: &MethodArgs) {\n+    // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more \\"}, {"sha": "2ff498b564644af08d99473ebbf8fd658602b9ad", "filename": "src/utils.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/29b53d600f63b998eaf3d723ee0da90379b7a8b8/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b53d600f63b998eaf3d723ee0da90379b7a8b8/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=29b53d600f63b998eaf3d723ee0da90379b7a8b8", "patch": "@@ -8,10 +8,13 @@ use rustc::middle::ty;\n use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::ptr::P;\n \n use rustc::session::Session;\n use std::str::FromStr;\n \n+pub type MethodArgs = HirVec<P<Expr>>;\n+\n // module DefPaths for certain structs/enums we check for\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n@@ -164,24 +167,28 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n-/// match an Expr against a chain of methods. For example, if `expr` represents the `.baz()` in\n-/// `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return true.\n-pub fn match_method_chain(expr: &Expr, methods: &[&str]) -> bool {\n-    let mut current = &expr.node ;\n+/// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n+/// represents the `.baz()` in `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])`\n+/// will return a Vec containing the Exprs for `.bar()` and `.baz()`\n+pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n+    let mut current = expr;\n+    let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() { // method chains are stored last -> first\n-        if let ExprMethodCall(ref name, _, ref args) = *current {\n+        if let ExprMethodCall(ref name, _, ref args) = current.node {\n             if name.node.as_str() == *method_name {\n-                current = &args[0].node\n+                matched.push(args); // build up `matched` backwards\n+                current = &args[0] // go to parent expression\n             }\n             else {\n-                return false;\n+                return None;\n             }\n         }\n         else {\n-            return false;\n+            return None;\n         }\n     }\n-    true\n+    matched.reverse(); // reverse `matched`, so that it is in the same order as `methods`\n+    Some(matched)\n }\n \n "}]}