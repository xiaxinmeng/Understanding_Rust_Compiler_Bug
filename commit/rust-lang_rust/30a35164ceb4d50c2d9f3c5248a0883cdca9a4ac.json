{"sha": "30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTM1MTY0Y2ViNGQ1MGMyZDlmM2M1MjQ4YTA4ODNjZGNhOWE0YWM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-01-12T18:26:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-12T18:26:23Z"}, "message": "Rollup merge of #47069 - Kagamihime:master, r=nrc\n\nrustfmt libarena/lib.rs\n\nNote: it's my very first pull request. I'm trying to do something very simple to see how it works here, even if it's a tiny change or maybe it's not correct (sorry if it is the case).\n\nr? @nrc", "tree": {"sha": "e70e2aa60aedf1fe1bef00cd3881ae2cd749c8ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e70e2aa60aedf1fe1bef00cd3881ae2cd749c8ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac", "html_url": "https://github.com/rust-lang/rust/commit/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "743b976b369bec2784544b0e48d915ca8d44cfbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/743b976b369bec2784544b0e48d915ca8d44cfbc", "html_url": "https://github.com/rust-lang/rust/commit/743b976b369bec2784544b0e48d915ca8d44cfbc"}, {"sha": "b2d0d184c3d69f499f3a2d4df1d99a548928ec53", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d0d184c3d69f499f3a2d4df1d99a548928ec53", "html_url": "https://github.com/rust-lang/rust/commit/b2d0d184c3d69f499f3a2d4df1d99a548928ec53"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "72fa3148fe54aba3563439947fb212864f3d7e3f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=30a35164ceb4d50c2d9f3c5248a0883cdca9a4ac", "patch": "@@ -69,7 +69,9 @@ struct TypedArenaChunk<T> {\n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: RawVec::with_capacity(capacity) }\n+        TypedArenaChunk {\n+            storage: RawVec::with_capacity(capacity),\n+        }\n     }\n \n     /// Destroys this arena chunk.\n@@ -132,7 +134,9 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                self.ptr\n+                    .set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1)\n+                        as *mut T);\n                 let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n@@ -157,7 +161,9 @@ impl<T> TypedArena<T> {\n     ///  - Zero-length slices\n     #[inline]\n     pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-        where T: Copy {\n+    where\n+        T: Copy,\n+    {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n \n@@ -321,7 +327,10 @@ impl DroplessArena {\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n+                if last_chunk\n+                    .storage\n+                    .reserve_in_place(used_bytes, needed_bytes)\n+                {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n@@ -357,9 +366,9 @@ impl DroplessArena {\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n-            self.ptr.set(intrinsics::arith_offset(\n-                    self.ptr.get(), mem::size_of::<T>() as isize\n-            ) as *mut u8);\n+            self.ptr.set(\n+                intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize) as *mut u8,\n+            );\n             // Write into uninitialized memory.\n             ptr::write(ptr as *mut T, object);\n             &mut *(ptr as *mut T)\n@@ -375,7 +384,9 @@ impl DroplessArena {\n     ///  - Zero-length slices\n     #[inline]\n     pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n-        where T: Copy {\n+    where\n+        T: Copy,\n+    {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -391,7 +402,8 @@ impl DroplessArena {\n         unsafe {\n             let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n             self.ptr.set(intrinsics::arith_offset(\n-                    self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize\n+                self.ptr.get(),\n+                (slice.len() * mem::size_of::<T>()) as isize,\n             ) as *mut u8);\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n@@ -456,8 +468,9 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result =\n-            arena.alloc_outer(|| Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+        let result = arena.alloc_outer(|| Outer {\n+            inner: arena.alloc_inner(|| Inner { value: 10 }),\n+        });\n \n         assert_eq!(result.inner.value, 10);\n     }"}]}