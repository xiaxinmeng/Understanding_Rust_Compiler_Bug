{"sha": "dc240faed5ec55968b2468002d2139e1e44d873b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMjQwZmFlZDVlYzU1OTY4YjI0NjgwMDJkMjEzOWUxZTQ0ZDg3M2I=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-20T21:21:02Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-20T21:38:49Z"}, "message": "Cleanup LLVM debuginfo module docs\n\n* Use Markdown list syntax and unindent a bit to prevent Markdown\n  interpreting the nested lists as code blocks\n* A few more small typographical cleanups", "tree": {"sha": "c80e401a0f6ebbc1377ed93eeabcdb7411405ec2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c80e401a0f6ebbc1377ed93eeabcdb7411405ec2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc240faed5ec55968b2468002d2139e1e44d873b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc240faed5ec55968b2468002d2139e1e44d873b", "html_url": "https://github.com/rust-lang/rust/commit/dc240faed5ec55968b2468002d2139e1e44d873b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc240faed5ec55968b2468002d2139e1e44d873b/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2e9374048f1c04f025469dde88e13a5037d8db7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e9374048f1c04f025469dde88e13a5037d8db7", "html_url": "https://github.com/rust-lang/rust/commit/a2e9374048f1c04f025469dde88e13a5037d8db7"}], "stats": {"total": 29, "additions": 15, "deletions": 14}, "files": [{"sha": "f983d09203904dd1c439139230db9671f855722f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dc240faed5ec55968b2468002d2139e1e44d873b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc240faed5ec55968b2468002d2139e1e44d873b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=dc240faed5ec55968b2468002d2139e1e44d873b", "patch": "@@ -96,9 +96,9 @@ allow to map machine code locations back to source code locations in order\n to be useful. This functionality is also handled in this module. The\n following functions allow to control source mappings:\n \n-+ set_source_location()\n-+ clear_source_location()\n-+ start_emitting_source_locations()\n++ `set_source_location()`\n++ `clear_source_location()`\n++ `start_emitting_source_locations()`\n \n `set_source_location()` allows to set the current source location. All IR\n instructions created after a call to this function will be linked to the\n@@ -142,21 +142,22 @@ type identifier that tells it across compilation units which types are the\n same as others. This type identifier is created by\n `TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n \n-(1) Primitive types have their name as ID\n-(2) Structs, enums and traits have a multipart identifier\n+1. Primitive types have their name as ID\n \n-    (1) The first part is the SVH (strict version hash) of the crate they\n-         were originally defined in\n+2. Structs, enums and traits have a multipart identifier\n \n-    (2) The second part is the ast::NodeId of the definition in their\n-         original crate\n+  1. The first part is the SVH (strict version hash) of the crate they\n+     were originally defined in\n \n-    (3) The final part is a concatenation of the type IDs of their concrete\n-         type arguments if they are generic types.\n+  2. The second part is the ast::NodeId of the definition in their\n+     original crate\n \n-(3) Tuple-, pointer and function types are structurally identified, which\n-    means that they are equivalent if their component types are equivalent\n-    (i.e., (i32, i32) is the same regardless in which crate it is used).\n+  3. The final part is a concatenation of the type IDs of their concrete\n+     type arguments if they are generic types.\n+\n+3. Tuple-, pointer-, and function types are structurally identified, which\n+   means that they are equivalent if their component types are equivalent\n+   (i.e., `(i32, i32)` is the same regardless in which crate it is used).\n \n This algorithm also provides a stable ID for types that are defined in one\n crate but instantiated from metadata within another crate. We just have to"}]}