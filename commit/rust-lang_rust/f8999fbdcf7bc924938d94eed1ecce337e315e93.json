{"sha": "f8999fbdcf7bc924938d94eed1ecce337e315e93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTk5ZmJkY2Y3YmM5MjQ5MzhkOTRlZWQxZWNjZTMzN2UzMTVlOTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-17T21:59:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-18T08:50:11Z"}, "message": "miri value visitor: fix some wrong assumptions about layout; improve error messages", "tree": {"sha": "ccb0272b3da751c4ed5002453452109b76c2a116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccb0272b3da751c4ed5002453452109b76c2a116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8999fbdcf7bc924938d94eed1ecce337e315e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8999fbdcf7bc924938d94eed1ecce337e315e93", "html_url": "https://github.com/rust-lang/rust/commit/f8999fbdcf7bc924938d94eed1ecce337e315e93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8999fbdcf7bc924938d94eed1ecce337e315e93/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee49e95e787b353c0697862ca2d703c7b9480d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee49e95e787b353c0697862ca2d703c7b9480d25", "html_url": "https://github.com/rust-lang/rust/commit/ee49e95e787b353c0697862ca2d703c7b9480d25"}], "stats": {"total": 354, "additions": 174, "deletions": 180}, "files": [{"sha": "13d5f5f6a375cc87787ac029dd48d6728ed22ca5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -187,7 +187,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n         self.walk_aggregate(mplace, fields)\n     }\n \n-    fn visit_primitive(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let ty = mplace.layout.ty;\n@@ -263,8 +263,11 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                     None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n                 }\n             }\n+            Ok(())\n+        } else {\n+            // Not a reference -- proceed recursively.\n+            self.walk_value(mplace)\n         }\n-        Ok(())\n     }\n }\n "}, {"sha": "e90a598567779bc8c527c2439f9be9a061d085db", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 117, "deletions": 64, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -201,13 +201,16 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n             // enums\n             ty::Adt(def, ..) if def.is_enum() => {\n-                // we might be projecting *to* a variant, or to a field *in*a variant.\n+                // we might be projecting *to* a variant, or to a field *in* a variant.\n                 match layout.variants {\n                     layout::Variants::Single { index } => {\n                         // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name)\n                     }\n-                    _ => bug!(),\n+                    layout::Variants::Multiple { discr_index, .. } => {\n+                        assert_eq!(discr_index, field);\n+                        PathElem::Tag\n+                    }\n                 }\n             }\n \n@@ -288,62 +291,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n         Ok(())\n     }\n-}\n-\n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n-    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n-{\n-    type V = OpTy<'tcx, M::PointerTag>;\n-\n-    #[inline(always)]\n-    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n-        &self.ecx\n-    }\n-\n-    #[inline]\n-    fn visit_field(\n-        &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n-        field: usize,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        let elem = self.aggregate_field_path_elem(old_op.layout, field);\n-        self.visit_elem(new_op, elem)\n-    }\n-\n-    #[inline]\n-    fn visit_variant(\n-        &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n-        variant_id: VariantIdx,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        let name = match old_op.layout.ty.kind {\n-            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n-            // Generators also have variants\n-            ty::Generator(..) => PathElem::GeneratorState(variant_id),\n-            _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n-        };\n-        self.visit_elem(new_op, name)\n-    }\n-\n-    #[inline]\n-    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n-        // Translate some possible errors to something nicer.\n-        match self.walk_value(op) {\n-            Ok(()) => Ok(()),\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n-                }\n-                err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n-                }\n-                _ => Err(err),\n-            },\n-        }\n-    }\n \n     fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         let value = self.ecx.read_immediate(value)?;\n@@ -421,7 +368,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 throw_validation_failure!(\n                                     format_args!(\n                                         \"unaligned reference \\\n-                                    (required {} byte alignment but found {})\",\n+                                         (required {} byte alignment but found {})\",\n                                         required.bytes(),\n                                         has.bytes()\n                                     ),\n@@ -485,16 +432,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n                 // FIXME: Check if the signature matches\n             }\n-            // This should be all the primitive types\n+            // This should be all the (inhabited) primitive types\n             _ => bug!(\"Unexpected primitive type {}\", value.layout.ty),\n         }\n         Ok(())\n     }\n \n-    fn visit_uninhabited(&mut self) -> InterpResult<'tcx> {\n-        throw_validation_failure!(\"a value of an uninhabited type\", self.path)\n-    }\n-\n     fn visit_scalar(\n         &mut self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -559,6 +502,116 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             )\n         }\n     }\n+}\n+\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n+{\n+    type V = OpTy<'tcx, M::PointerTag>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n+        &self.ecx\n+    }\n+\n+    #[inline]\n+    fn visit_field(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        field: usize,\n+        new_op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        let elem = self.aggregate_field_path_elem(old_op.layout, field);\n+        self.visit_elem(new_op, elem)\n+    }\n+\n+    #[inline]\n+    fn visit_variant(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        variant_id: VariantIdx,\n+        new_op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        let name = match old_op.layout.ty.kind {\n+            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n+            // Generators also have variants\n+            ty::Generator(..) => PathElem::GeneratorState(variant_id),\n+            _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n+        };\n+        self.visit_elem(new_op, name)\n+    }\n+\n+    #[inline(always)]\n+    fn visit_union(&mut self, _v: Self::V, fields: usize) -> InterpResult<'tcx> {\n+        // Empty unions are not accepted by rustc. That's great, it means we can\n+        // use that as a signal for detecting primitives.  Make sure\n+        // we did not miss any primitive.\n+        assert!(fields > 0);\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n+\n+        if op.layout.abi.is_uninhabited() {\n+            // Uninhabited types do not have sensible layout, stop right here.\n+            throw_validation_failure!(\n+                format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n+                self.path\n+            )\n+        }\n+\n+        // Check primitive types.  We do this after checking for uninhabited types,\n+        // to exclude fieldless enums (that also appear as fieldless unions here).\n+        // Primitives can have varying layout, so we check them separately and before aggregate\n+        // handling.\n+        // It is CRITICAL that we get this check right, or we might be validating the wrong thing!\n+        let primitive = match op.layout.fields {\n+            // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n+            // (Fieldless enums also appear here, but they are uninhabited and thus handled above.)\n+            layout::FieldPlacement::Union(0) => true,\n+            _ => op.layout.ty.builtin_deref(true).is_some(),\n+        };\n+        if primitive {\n+            // No need to recurse further or check scalar layout, this is a leaf type.\n+            return self.visit_primitive(op);\n+        }\n+\n+        // Recursively walk the type. Translate some possible errors to something nicer.\n+        match self.walk_value(op) {\n+            Ok(()) => {}\n+            Err(err) => match err.kind {\n+                err_ub!(InvalidDiscriminant(val)) => {\n+                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n+                }\n+                err_unsup!(ReadPointerAsBytes) => {\n+                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n+                }\n+                _ => return Err(err),\n+            },\n+        }\n+\n+        // *After* all of this, check the ABI.  We need to check the ABI to handle\n+        // types like `NonNull` where the `Scalar` info is more restrictive than what\n+        // the fields say. But in most cases, this will just propagate what the fields say,\n+        // and then we want the error to point at the field -- so, first recurse,\n+        // then check ABI.\n+        //\n+        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+        // scalars, we do the same check on every \"level\" (e.g., first we check\n+        // MyNewtype and then the scalar in there).\n+        match op.layout.abi {\n+            layout::Abi::Uninhabited => unreachable!(), // checked above\n+            layout::Abi::Scalar(ref layout) => {\n+                self.visit_scalar(op, layout)?;\n+            }\n+            // FIXME: Should we do something for ScalarPair? Vector?\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n \n     fn visit_aggregate(\n         &mut self,"}, {"sha": "8808fc70cf76b05f5a9b9c8f46843e36f5d341a4", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 29, "deletions": 91, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -120,7 +120,7 @@ macro_rules! make_value_visitor {\n             }\n             /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n-            fn visit_union(&mut self, _v: Self::V) -> InterpResult<'tcx>\n+            fn visit_union(&mut self, _v: Self::V, _fields: usize) -> InterpResult<'tcx>\n             {\n                 Ok(())\n             }\n@@ -150,8 +150,9 @@ macro_rules! make_value_visitor {\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n-\n             /// Called when recursing into an enum variant.\n+            /// This gives the visitor the chance to track the stack of nested fields that\n+            /// we are descending through.\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n@@ -162,33 +163,6 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n-            /// Called whenever we reach a value with uninhabited layout.\n-            /// Recursing to fields will *always* continue after this!  This is not meant to control\n-            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n-            /// it is meant to provide the chance for additional checks when a value of uninhabited\n-            /// layout is detected.\n-            #[inline(always)]\n-            fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n-            { Ok(()) }\n-            /// Called whenever we reach a value with scalar layout.\n-            /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the\n-            /// visitor is not even interested in scalars.\n-            /// Recursing to fields will *always* continue after this!  This is not meant to control\n-            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n-            /// it is meant to provide the chance for additional checks when a value of scalar\n-            /// layout is detected.\n-            #[inline(always)]\n-            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> InterpResult<'tcx>\n-            { Ok(()) }\n-\n-            /// Called whenever we reach a value of primitive type. There can be no recursion\n-            /// below such a value. This is the leaf function.\n-            /// We do *not* provide an `ImmTy` here because some implementations might want\n-            /// to write to the place this primitive lives in.\n-            #[inline(always)]\n-            fn visit_primitive(&mut self, _v: Self::V) -> InterpResult<'tcx>\n-            { Ok(()) }\n-\n             // Default recursors. Not meant to be overloaded.\n             fn walk_aggregate(\n                 &mut self,\n@@ -204,23 +178,10 @@ macro_rules! make_value_visitor {\n             fn walk_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n-                // If this is a multi-variant layout, we have to find the right one and proceed with\n-                // that.\n-                match v.layout().variants {\n-                    layout::Variants::Multiple { .. } => {\n-                        let op = v.to_op(self.ecx())?;\n-                        let idx = self.ecx().read_discriminant(op)?.1;\n-                        let inner = v.project_downcast(self.ecx(), idx)?;\n-                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n-                        // recurse with the inner type\n-                        return self.visit_variant(v, idx, inner);\n-                    }\n-                    layout::Variants::Single { .. } => {}\n-                }\n \n-                // Even for single variants, we might be able to get a more refined type:\n-                // If it is a trait object, switch to the actual type that was used to create it.\n+                // Special treatment for special types, where the (static) layout is not sufficient.\n                 match v.layout().ty.kind {\n+                    // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n                         let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n@@ -229,56 +190,16 @@ macro_rules! make_value_visitor {\n                         // recurse with the inner type\n                         return self.visit_field(v, 0, Value::from_mem_place(inner));\n                     },\n-                    ty::Generator(..) => {\n-                        // FIXME: Generator layout is lying: it claims a whole bunch of fields exist\n-                        // when really many of them can be uninitialized.\n-                        // Just treat them as a union for now, until hopefully the layout\n-                        // computation is fixed.\n-                        return self.visit_union(v);\n-                    }\n+                    // Slices do not need special handling here: they have `Array` field\n+                    // placement with length 0, so we enter the `Array` case below which\n+                    // indirectly uses the metadata to determine the actual length.\n                     _ => {},\n                 };\n \n-                // If this is a scalar, visit it as such.\n-                // Things can be aggregates and have scalar layout at the same time, and that\n-                // is very relevant for `NonNull` and similar structs: We need to visit them\n-                // at their scalar layout *before* descending into their fields.\n-                // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-                // scalars, we do the same check on every \"level\" (e.g., first we check\n-                // MyNewtype and then the scalar in there).\n-                match v.layout().abi {\n-                    layout::Abi::Uninhabited => {\n-                        self.visit_uninhabited()?;\n-                    }\n-                    layout::Abi::Scalar(ref layout) => {\n-                        self.visit_scalar(v, layout)?;\n-                    }\n-                    // FIXME: Should we do something for ScalarPair? Vector?\n-                    _ => {}\n-                }\n-\n-                // Check primitive types.  We do this after checking the scalar layout,\n-                // just to have that done as well.  Primitives can have varying layout,\n-                // so we check them separately and before aggregate handling.\n-                // It is CRITICAL that we get this check right, or we might be\n-                // validating the wrong thing!\n-                let primitive = match v.layout().fields {\n-                    // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n-                    layout::FieldPlacement::Union(0) => true,\n-                    _ => v.layout().ty.builtin_deref(true).is_some(),\n-                };\n-                if primitive {\n-                    return self.visit_primitive(v);\n-                }\n-\n-                // Proceed into the fields.\n+                // Visit the fields of this value.\n                 match v.layout().fields {\n                     layout::FieldPlacement::Union(fields) => {\n-                        // Empty unions are not accepted by rustc. That's great, it means we can\n-                        // use that as an unambiguous signal for detecting primitives.  Make sure\n-                        // we did not miss any primitive.\n-                        assert!(fields > 0);\n-                        self.visit_union(v)\n+                        self.visit_union(v, fields)?;\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n@@ -288,18 +209,35 @@ macro_rules! make_value_visitor {\n                                 v.project_field(self.ecx(), i as u64)\n                             })\n                             .collect();\n-                        self.visit_aggregate(v, fields.into_iter())\n+                        self.visit_aggregate(v, fields.into_iter())?;\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n                         let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields.\n+                        // This uses the *run-time length*, i.e., if we are a slice,\n+                        // the dynamic info from the metadata is used.\n                         let iter = self.ecx().mplace_array_fields(mplace)?\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n-                        self.visit_aggregate(v, iter)\n+                        self.visit_aggregate(v, iter)?;\n+                    }\n+                }\n+\n+                match v.layout().variants {\n+                    // If this is a multi-variant layout, find the right variant and proceed\n+                    // with *its* fields.\n+                    layout::Variants::Multiple { .. } => {\n+                        let op = v.to_op(self.ecx())?;\n+                        let idx = self.ecx().read_discriminant(op)?.1;\n+                        let inner = v.project_downcast(self.ecx(), idx)?;\n+                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n+                        // recurse with the inner type\n+                        self.visit_variant(v, idx, inner)\n                     }\n+                    // For single-variant layouts, we already did anything there is to do.\n+                    layout::Variants::Single { .. } => Ok(())\n                 }\n             }\n         }"}, {"sha": "e93a6887ba8f7c06fdb4cf415d342e4738aae6cb", "filename": "src/test/ui/consts/const-eval/transmute-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/transmute-const.rs:5:1\n    |\n LL | static FOO: bool = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "3680f4f2ac2ad4b6874877064274f8ee537d063e", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -10,15 +10,15 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:26:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:29:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -34,39 +34,39 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:52:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:56:1\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:60:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:71:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected a valid unicode codepoint\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "ec0561870576f763a2c7cb1d2742e06ddd16f09b", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -44,7 +44,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:32:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .0, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "86d5d17c5388d56051568938f67201b0e890ba08", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -10,7 +10,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:11:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered NULL reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "4fef9aa84ea1916c99abedf6a8b202f0418fcbd6", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:15:1\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:18:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:21:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Bar; 1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "c1df447cd8565c7d22c6792f92c99b725e98d187", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered 0 at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n+   | |__^ type validation failed: encountered NULL reference at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "170037b44da0d346f1217ed0209b1298810fa12e", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -66,23 +66,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -122,7 +122,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:147:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "9d90d6e8548d886ead73763fca4ebfed9887c684", "filename": "src/test/ui/consts/const-eval/union-ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub.rs:31:1\n    |\n LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "2a338e276402c16408cd9b59312447db58ea3f1d", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -20,7 +20,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_uninhabited_zsts.rs:17:1\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Empty; 3]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "203620a771b8f492c2e4acb3d46fe846765216c9", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8999fbdcf7bc924938d94eed1ecce337e315e93/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=f8999fbdcf7bc924938d94eed1ecce337e315e93", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:3:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [!; 1] at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:7:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}