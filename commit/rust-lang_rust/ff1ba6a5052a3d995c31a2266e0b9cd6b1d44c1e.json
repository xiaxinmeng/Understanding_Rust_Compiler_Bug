{"sha": "ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMWJhNmE1MDUyYTNkOTk1YzMxYTIyNjZlMGI5Y2Q2YjFkNDRjMWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-11-30T17:14:17Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-11-30T20:33:18Z"}, "message": "Adds `-Z mir-stats`, which is similar to `-Z hir-stats`.\n\nSome notes:\n\n* This code attempts to present the breakdown of each variant for\n  every enum in the MIR. This is meant to guide decisions about how to\n  revise representations e.g. when to box payloads for rare variants\n  to shrink the size of the enum overall.\n\n* I left out the \"Total:\" line that hir-stats presents, because this\n  implementation uses the MIR Visitor infrastructure, and the memory\n  usage of structures directly embedded in other structures (e.g. the\n  `func: Operand` in a `TerminatorKind:Call`) is not distinguished\n  from similar structures allocated in a `Vec` (e.g. the `args:\n  Vec<Operand>` in a `TerminatorKind::Call`). This means that a naive\n  summation of all the accumulated sizes is misleading, because it\n  will double-count the contribution of the `Operand` of the `func` as\n  well as the size of the whole `TerminatorKind`.\n\n  * I did consider abandoning the MIR Visitor and instead hand-coding\n    a traversal that distinguished embedded storage from indirect\n    storage. But such code would be fragile; better to just require\n    people to take care when interpreting the presented results.\n\n* This traverses the `mir.promoted` rvalues to capture stats for MIR\n  stored there, even though the MIR visitor super_mir method does not\n  do so. (I did not observe any new mir being traversed when compiling\n  the rustc crate, however.)\n\n* It might be nice to try to unify this code with hir-stats.  Then\n  again, the reporting portion is the only common code (I think), and\n  it is small compared to the visitors in hir-stats and mir-stats.", "tree": {"sha": "b232b0491bc68c92d26bcf44d4acb43421f172bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b232b0491bc68c92d26bcf44d4acb43421f172bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "html_url": "https://github.com/rust-lang/rust/commit/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0248068c693c64f74623e9a6f7504b900df8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0248068c693c64f74623e9a6f7504b900df8a6", "html_url": "https://github.com/rust-lang/rust/commit/5a0248068c693c64f74623e9a6f7504b900df8a6"}], "stats": {"total": 336, "additions": 335, "deletions": 1}, "files": [{"sha": "d5555a919fe050f38f50796d317056febd0ae6e0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "patch": "@@ -923,6 +923,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some statistics about AST and HIR\"),\n+    mir_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some statistics about MIR\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "f55656c7fcc4d79e3bfb78c13290cfa39f0316ce", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "patch": "@@ -37,7 +37,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n-                   static_recursion, hir_stats};\n+                   static_recursion, hir_stats, mir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -932,6 +932,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n \n+        if sess.opts.debugging_opts.mir_stats {\n+            mir_stats::print_mir_stats(tcx, \"PRE CLEANUP MIR STATS\");\n+        }\n+\n         time(time_passes, \"MIR cleanup and validation\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in validation passes.\n@@ -1000,6 +1004,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n+    if tcx.sess.opts.debugging_opts.mir_stats {\n+        mir_stats::print_mir_stats(tcx, \"PRE OPTIMISATION MIR STATS\");\n+    }\n+\n     // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n     // code.\n     time(time_passes, \"MIR optimisations\", || {\n@@ -1028,6 +1036,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.run_passes(tcx);\n     });\n \n+    if tcx.sess.opts.debugging_opts.mir_stats {\n+        mir_stats::print_mir_stats(tcx, \"POST OPTIMISATION MIR STATS\");\n+    }\n+\n     let translation =\n         time(time_passes,\n              \"translation\","}, {"sha": "aea0b929f35cb8d44640f1fbc7a80c4808a920a5", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "patch": "@@ -47,6 +47,7 @@ pub mod ast_validation;\n pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n+pub mod mir_stats;\n pub mod no_asm;\n pub mod rvalues;\n pub mod static_recursion;"}, {"sha": "cec1c20519bd6c62b4bfa8370332a5bfdc45dc77", "filename": "src/librustc_passes/mir_stats.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=ff1ba6a5052a3d995c31a2266e0b9cd6b1d44c1e", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The visitors in this module collect sizes and counts of the most important\n+// pieces of MIR. The resulting numbers are good approximations but not\n+// completely accurate (some things might be counted twice, others missed).\n+\n+use rustc_const_math::{ConstUsize};\n+use rustc::middle::const_val::{ConstVal};\n+use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n+use rustc::mir::{Constant, Literal, Location, LocalDecl};\n+use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n+use rustc::mir::{Mir, Operand, ProjectionElem};\n+use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind, TypedConstVal, VisibilityScope, VisibilityScopeData};\n+use rustc::mir::visit as mir_visit;\n+use rustc::mir::visit::Visitor;\n+use rustc::ty::{ClosureSubsts, TyCtxt};\n+use rustc::util::common::to_readable_str;\n+use rustc::util::nodemap::{FxHashMap};\n+\n+struct NodeData {\n+    count: usize,\n+    size: usize,\n+}\n+\n+struct StatCollector<'a, 'tcx: 'a> {\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    data: FxHashMap<&'static str, NodeData>,\n+}\n+\n+pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n+    let mut collector = StatCollector {\n+        _tcx: tcx,\n+        data: FxHashMap(),\n+    };\n+    // For debugging instrumentation like this, we don't need to worry\n+    // about maintaining the dep graph.\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let mir_map = tcx.mir_map.borrow();\n+    for def_id in mir_map.keys() {\n+        let mir = mir_map.get(&def_id).unwrap();\n+        collector.visit_mir(&mir.borrow());\n+    }\n+    collector.print(title);\n+}\n+\n+impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n+\n+    fn record_with_size(&mut self, label: &'static str, node_size: usize) {\n+        let entry = self.data.entry(label).or_insert(NodeData {\n+            count: 0,\n+            size: 0,\n+        });\n+\n+        entry.count += 1;\n+        entry.size = node_size;\n+    }\n+\n+    fn record<T>(&mut self, label: &'static str, node: &T) {\n+        self.record_with_size(label, ::std::mem::size_of_val(node));\n+    }\n+\n+    fn print(&self, title: &str) {\n+        let mut stats: Vec<_> = self.data.iter().collect();\n+\n+        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n+\n+        println!(\"\\n{}\\n\", title);\n+\n+        println!(\"{:<32}{:>18}{:>14}{:>14}\",\n+            \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n+        println!(\"------------------------------------------------------------------------------\");\n+\n+        for (label, data) in stats {\n+            println!(\"{:<32}{:>18}{:>14}{:>14}\",\n+                label,\n+                to_readable_str(data.count * data.size),\n+                to_readable_str(data.count),\n+                to_readable_str(data.size));\n+        }\n+        println!(\"------------------------------------------------------------------------------\");\n+    }\n+}\n+\n+impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        self.record(\"Mir\", mir);\n+\n+        // since the `super_mir` method does not traverse the MIR of\n+        // promoted rvalues, (but we still want to gather statistics\n+        // on the structures represented there) we manually traverse\n+        // the promoted rvalues here.\n+        for promoted_mir in &mir.promoted {\n+            self.visit_mir(promoted_mir);\n+        }\n+\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_basic_block_data(&mut self,\n+                              block: BasicBlock,\n+                              data: &BasicBlockData<'tcx>) {\n+        self.record(\"BasicBlockData\", data);\n+        self.super_basic_block_data(block, data);\n+    }\n+\n+    fn visit_visibility_scope_data(&mut self,\n+                                   scope_data: &VisibilityScopeData) {\n+        self.record(\"VisibilityScopeData\", scope_data);\n+        self.super_visibility_scope_data(scope_data);\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location) {\n+        self.record(\"Statement\", statement);\n+        self.record(match statement.kind {\n+            StatementKind::Assign(..) => \"StatementKind::Assign\",\n+            StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n+            StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n+            StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n+            StatementKind::Nop => \"StatementKind::Nop\",\n+        }, &statement.kind);\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location) {\n+        self.record(\"Terminator\", terminator);\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n+    fn visit_terminator_kind(&mut self,\n+                             block: BasicBlock,\n+                             kind: &TerminatorKind<'tcx>,\n+                             location: Location) {\n+        self.record(\"TerminatorKind\", kind);\n+        self.record(match *kind {\n+            TerminatorKind::Goto { .. } => \"TerminatorKind::Goto\",\n+            TerminatorKind::If { .. } => \"TerminatorKind::If\",\n+            TerminatorKind::Switch { .. } => \"TerminatorKind::Switch\",\n+            TerminatorKind::SwitchInt { .. } => \"TerminatorKind::SwitchInt\",\n+            TerminatorKind::Resume => \"TerminatorKind::Resume\",\n+            TerminatorKind::Return => \"TerminatorKind::Return\",\n+            TerminatorKind::Unreachable => \"TerminatorKind::Unreachable\",\n+            TerminatorKind::Drop { .. } => \"TerminatorKind::Drop\",\n+            TerminatorKind::DropAndReplace { .. } => \"TerminatorKind::DropAndReplace\",\n+            TerminatorKind::Call { .. } => \"TerminatorKind::Call\",\n+            TerminatorKind::Assert { .. } => \"TerminatorKind::Assert\",\n+        }, kind);\n+        self.super_terminator_kind(block, kind, location);\n+    }\n+\n+    fn visit_assert_message(&mut self,\n+                            msg: &AssertMessage<'tcx>,\n+                            location: Location) {\n+        self.record(\"AssertMessage\", msg);\n+        self.record(match *msg {\n+            AssertMessage::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n+            AssertMessage::Math(..) => \"AssertMessage::Math\",\n+        }, msg);\n+        self.super_assert_message(msg, location);\n+    }\n+\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        self.record(\"Rvalue\", rvalue);\n+        let rvalue_kind = match *rvalue {\n+            Rvalue::Use(..) => \"Rvalue::Use\",\n+            Rvalue::Repeat(..) => \"Rvalue::Repeat\",\n+            Rvalue::Ref(..) => \"Rvalue::Ref\",\n+            Rvalue::Len(..) => \"Rvalue::Len\",\n+            Rvalue::Cast(..) => \"Rvalue::Cast\",\n+            Rvalue::BinaryOp(..) => \"Rvalue::BinaryOp\",\n+            Rvalue::CheckedBinaryOp(..) => \"Rvalue::CheckedBinaryOp\",\n+            Rvalue::UnaryOp(..) => \"Rvalue::UnaryOp\",\n+            Rvalue::Box(..) => \"Rvalue::Box\",\n+            Rvalue::Aggregate(ref kind, ref _operands) => {\n+                // AggregateKind is not distinguished by visit API, so\n+                // record it. (`super_rvalue` handles `_operands`.)\n+                self.record(match *kind {\n+                    AggregateKind::Array => \"AggregateKind::Array\",\n+                    AggregateKind::Tuple => \"AggregateKind::Tuple\",\n+                    AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n+                    AggregateKind::Closure(..) => \"AggregateKind::Closure\",\n+                }, kind);\n+\n+                \"Rvalue::Aggregate\"\n+            }\n+            Rvalue::InlineAsm { .. } => \"Rvalue::InlineAsm\",\n+        };\n+        self.record(rvalue_kind, rvalue);\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_operand(&mut self,\n+                     operand: &Operand<'tcx>,\n+                     location: Location) {\n+        self.record(\"Operand\", operand);\n+        self.record(match *operand {\n+            Operand::Consume(..) => \"Operand::Consume\",\n+            Operand::Constant(..) => \"Operand::Constant\",\n+        }, operand);\n+        self.super_operand(operand, location);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: mir_visit::LvalueContext<'tcx>,\n+                    location: Location) {\n+        self.record(\"Lvalue\", lvalue);\n+        self.record(match *lvalue {\n+            Lvalue::Local(..) => \"Lvalue::Local\",\n+            Lvalue::Static(..) => \"Lvalue::Static\",\n+            Lvalue::Projection(..) => \"Lvalue::Projection\",\n+        }, lvalue);\n+        self.super_lvalue(lvalue, context, location);\n+    }\n+\n+    fn visit_projection(&mut self,\n+                        lvalue: &LvalueProjection<'tcx>,\n+                        context: mir_visit::LvalueContext<'tcx>,\n+                        location: Location) {\n+        self.record(\"LvalueProjection\", lvalue);\n+        self.super_projection(lvalue, context, location);\n+    }\n+\n+    fn visit_projection_elem(&mut self,\n+                             lvalue: &LvalueElem<'tcx>,\n+                             context: mir_visit::LvalueContext<'tcx>,\n+                             location: Location) {\n+        self.record(\"LvalueElem\", lvalue);\n+        self.record(match *lvalue {\n+            ProjectionElem::Deref => \"LvalueElem::Deref\",\n+            ProjectionElem::Subslice { .. } => \"LvalueElem::Subslice\",\n+            ProjectionElem::Field(..) => \"LvalueElem::Field\",\n+            ProjectionElem::Index(..) => \"LvalueElem::Index\",\n+            ProjectionElem::ConstantIndex { .. } => \"LvalueElem::ConstantIndex\",\n+            ProjectionElem::Downcast(..) => \"LvalueElem::Downcast\",\n+        }, lvalue);\n+        self.super_projection_elem(lvalue, context, location);\n+    }\n+\n+    fn visit_constant(&mut self,\n+                      constant: &Constant<'tcx>,\n+                      location: Location) {\n+        self.record(\"Constant\", constant);\n+        self.super_constant(constant, location);\n+    }\n+\n+    fn visit_literal(&mut self,\n+                     literal: &Literal<'tcx>,\n+                     location: Location) {\n+        self.record(\"Literal\", literal);\n+        self.record(match *literal {\n+            Literal::Item { .. } => \"Literal::Item\",\n+            Literal::Value { .. } => \"Literal::Value\",\n+            Literal::Promoted { .. } => \"Literal::Promoted\",\n+        }, literal);\n+        self.super_literal(literal, location);\n+    }\n+\n+    fn visit_source_info(&mut self,\n+                         source_info: &SourceInfo) {\n+        self.record(\"SourceInfo\", source_info);\n+        self.super_source_info(source_info);\n+    }\n+\n+    fn visit_closure_substs(&mut self,\n+                            substs: &ClosureSubsts<'tcx>) {\n+        self.record(\"ClosureSubsts\", substs);\n+        self.super_closure_substs(substs);\n+    }\n+\n+    fn visit_const_val(&mut self,\n+                       const_val: &ConstVal,\n+                       _: Location) {\n+        self.record(\"ConstVal\", const_val);\n+        self.super_const_val(const_val);\n+    }\n+\n+    fn visit_const_usize(&mut self,\n+                         const_usize: &ConstUsize,\n+                         _: Location) {\n+        self.record(\"ConstUsize\", const_usize);\n+        self.super_const_usize(const_usize);\n+    }\n+\n+    fn visit_typed_const_val(&mut self,\n+                             val: &TypedConstVal<'tcx>,\n+                             location: Location) {\n+        self.record(\"TypedConstVal\", val);\n+        self.super_typed_const_val(val, location);\n+    }\n+\n+    fn visit_local_decl(&mut self,\n+                        local_decl: &LocalDecl<'tcx>) {\n+        self.record(\"LocalDecl\", local_decl);\n+        self.super_local_decl(local_decl);\n+    }\n+\n+    fn visit_visibility_scope(&mut self,\n+                              scope: &VisibilityScope) {\n+        self.record(\"VisiblityScope\", scope);\n+        self.super_visibility_scope(scope);\n+    }\n+}"}]}