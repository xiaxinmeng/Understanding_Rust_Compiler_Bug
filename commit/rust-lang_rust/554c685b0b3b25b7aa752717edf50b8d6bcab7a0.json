{"sha": "554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NGM2ODViMGIzYjI1YjdhYTc1MjcxN2VkZjUwYjhkNmJjYWI3YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-14T11:17:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-14T11:17:31Z"}, "message": "Auto merge of #42523 - clarcharr:refactor_ops, r=brson\n\nRefactor ops.rs\n\nThis refactors ops.rs into several different modules internally, as the file has gotten quite big. None of these modules are actually exported, but this should make maintaining it much easier. I've avoided the ambition of exporting the modules because they can more easily be rearranged after this commit goes through, even though it'd be cool to potentially export the modules in the future.\n\nI've separated the creation of each file into a separate commit so that this is easier to read.\n\nRedone version of #42269 with the movement of `RangeArgument` moved.", "tree": {"sha": "e048f4f5b938bbaba5c4ee0704cc627cffd52067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e048f4f5b938bbaba5c4ee0704cc627cffd52067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "html_url": "https://github.com/rust-lang/rust/commit/554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfa7e21e4ee555d04c0fb86069f5acffee3550ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa7e21e4ee555d04c0fb86069f5acffee3550ad", "html_url": "https://github.com/rust-lang/rust/commit/dfa7e21e4ee555d04c0fb86069f5acffee3550ad"}, {"sha": "f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "html_url": "https://github.com/rust-lang/rust/commit/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285"}], "stats": {"total": 6200, "additions": 3171, "deletions": 3029}, "files": [{"sha": "a1de8fe76e2580cb79d2fcf1b166ee8aff237935", "filename": "src/libcore/ops.rs", "status": "removed", "additions": 0, "deletions": 3021, "changes": 3021, "blob_url": "https://github.com/rust-lang/rust/blob/dfa7e21e4ee555d04c0fb86069f5acffee3550ad/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfa7e21e4ee555d04c0fb86069f5acffee3550ad/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=dfa7e21e4ee555d04c0fb86069f5acffee3550ad"}, {"sha": "c6fb75f6acefc8bce4a6b2eb815e18ff92f8708a", "filename": "src/libcore/ops/arith.rs", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,873 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The addition operator `+`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Add` trait, and\n+/// then demonstrates adding two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Add for Point {\n+///     type Output = Point;\n+///\n+///     fn add(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Here is an example of the same `Point` struct implementing the `Add` trait\n+/// using generics.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point<T> {\n+///     x: T,\n+///     y: T,\n+/// }\n+///\n+/// // Notice that the implementation uses the `Output` associated type\n+/// impl<T: Add<Output=T>> Add for Point<T> {\n+///     type Output = Point<T>;\n+///\n+///     fn add(self, other: Point<T>) -> Point<T> {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl<T: PartialEq> PartialEq for Point<T> {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"add\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n+pub trait Add<RHS=Self> {\n+    /// The resulting type after applying the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! add_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n+    )*)\n+}\n+\n+add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction operator `-`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Sub` trait, and\n+/// then demonstrates subtracting two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Sub;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Sub for Point {\n+///     type Output = Point;\n+///\n+///     fn sub(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///                Point { x: 1, y: 0 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"sub\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n+pub trait Sub<RHS=Self> {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! sub_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Sub for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub(self, other: $t) -> $t { self - other }\n+        }\n+\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n+    )*)\n+}\n+\n+sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication operator `*`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Mul`tipliable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Mul for Rational {\n+///     // The multiplication of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn mul(self, rhs: Self) -> Self {\n+///         let nominator = self.nominator * rhs.nominator;\n+///         let denominator = self.denominator * rhs.denominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n+///            Rational::new(1, 2));\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables multiplication of vectors by scalars, as is\n+/// done in linear algebra.\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// struct Scalar {value: usize};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<usize>};\n+///\n+/// impl Mul<Vector> for Scalar {\n+///     type Output = Vector;\n+///\n+///     fn mul(self, rhs: Vector) -> Vector {\n+///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 3};\n+/// let vector = Vector{value: vec![2, 4, 6]};\n+/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// ```\n+#[lang = \"mul\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n+pub trait Mul<RHS=Self> {\n+    /// The resulting type after applying the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! mul_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Mul for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul(self, other: $t) -> $t { self * other }\n+        }\n+\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n+    )*)\n+}\n+\n+mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division operator `/`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Div`idable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Div for Rational {\n+///     // The division of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn div(self, rhs: Self) -> Self {\n+///         if rhs.nominator == 0 {\n+///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n+///         }\n+///\n+///         let nominator = self.nominator * rhs.denominator;\n+///         let denominator = self.denominator * rhs.nominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///                Rational::new(2, 3));\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables division of vectors by scalars, as is done in\n+/// linear algebra.\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// struct Scalar {value: f32};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<f32>};\n+///\n+/// impl Div<Scalar> for Vector {\n+///     type Output = Vector;\n+///\n+///     fn div(self, rhs: Scalar) -> Vector {\n+///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 2f32};\n+/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n+/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// ```\n+#[lang = \"div\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n+pub trait Div<RHS=Self> {\n+    /// The resulting type after applying the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn div(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! div_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation rounds towards zero, truncating any\n+        /// fractional part of the exact result.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! div_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_float! { f32 f64 }\n+\n+/// The remainder operator `%`.\n+///\n+/// # Examples\n+///\n+/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n+/// implemented, one can use the `%` operator to find out what the remaining\n+/// elements of the slice would be after splitting it into equal slices of a\n+/// given length.\n+///\n+/// ```\n+/// use std::ops::Rem;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SplitSlice<'a, T: 'a> {\n+///     slice: &'a [T],\n+/// }\n+///\n+/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n+///     type Output = SplitSlice<'a, T>;\n+///\n+///     fn rem(self, modulus: usize) -> Self {\n+///         let len = self.slice.len();\n+///         let rem = len % modulus;\n+///         let start = len - rem;\n+///         SplitSlice {slice: &self.slice[start..]}\n+///     }\n+/// }\n+///\n+/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n+/// // the remainder would be &[6, 7]\n+/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n+///            SplitSlice { slice: &[6, 7] });\n+/// ```\n+#[lang = \"rem\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n+pub trait Rem<RHS=Self> {\n+    /// The resulting type after applying the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output = Self;\n+\n+    /// The method for the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! rem_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// result has the same sign as the left operand.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+\n+macro_rules! rem_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_float! { f32 f64 }\n+\n+/// The unary negation operator `-`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n+/// negate its value.\n+///\n+/// ```\n+/// use std::ops::Neg;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Sign {\n+///     Negative,\n+///     Zero,\n+///     Positive,\n+/// }\n+///\n+/// impl Neg for Sign {\n+///     type Output = Sign;\n+///\n+///     fn neg(self) -> Sign {\n+///         match self {\n+///             Sign::Negative => Sign::Positive,\n+///             Sign::Zero => Sign::Zero,\n+///             Sign::Positive => Sign::Negative,\n+///         }\n+///     }\n+/// }\n+///\n+/// // a negative positive is a negative\n+/// assert_eq!(-Sign::Positive, Sign::Negative);\n+/// // a double negative is a positive\n+/// assert_eq!(-Sign::Negative, Sign::Positive);\n+/// // zero is its own negation\n+/// assert_eq!(-Sign::Zero, Sign::Zero);\n+/// ```\n+#[lang = \"neg\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Neg {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn neg(self) -> Self::Output;\n+}\n+\n+\n+\n+macro_rules! neg_impl_core {\n+    ($id:ident => $body:expr, $($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Neg for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn neg(self) -> $t { let $id = self; $body }\n+        }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n+    )*)\n+}\n+\n+macro_rules! neg_impl_numeric {\n+    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! neg_impl_unsigned {\n+    ($($t:ty)*) => {\n+        neg_impl_core!{ x => {\n+            !x.wrapping_add(1)\n+        }, $($t)*} }\n+}\n+\n+// neg_impl_unsigned! { usize u8 u16 u32 u64 }\n+neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The addition assignment operator `+=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `AddAssign`\n+/// trait, and then demonstrates add-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::AddAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl AddAssign for Point {\n+///     fn add_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 1, y: 0 };\n+/// point += Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point { x: 3, y: 3 });\n+/// ```\n+#[lang = \"add_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n+pub trait AddAssign<Rhs=Self> {\n+    /// The method for the `+=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn add_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! add_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl AddAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add_assign(&mut self, other: $t) { *self += other }\n+        }\n+    )+)\n+}\n+\n+add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction assignment operator `-=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `SubAssign`\n+/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::SubAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl SubAssign for Point {\n+///     fn sub_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 3, y: 3 };\n+/// point -= Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point {x: 1, y: 0});\n+/// ```\n+#[lang = \"sub_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n+pub trait SubAssign<Rhs=Self> {\n+    /// The method for the `-=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn sub_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! sub_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl SubAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub_assign(&mut self, other: $t) { *self -= other }\n+        }\n+    )+)\n+}\n+\n+sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication assignment operator `*=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n+/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```\n+/// use std::ops::MulAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl MulAssign for Foo {\n+///     fn mul_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Multiplying!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo *= Foo;\n+/// }\n+/// ```\n+#[lang = \"mul_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n+pub trait MulAssign<Rhs=Self> {\n+    /// The method for the `*=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn mul_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! mul_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl MulAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul_assign(&mut self, other: $t) { *self *= other }\n+        }\n+    )+)\n+}\n+\n+mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division assignment operator `/=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n+/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// use std::ops::DivAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl DivAssign for Foo {\n+///     fn div_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Dividing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo /= Foo;\n+/// }\n+/// ```\n+#[lang = \"div_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n+pub trait DivAssign<Rhs=Self> {\n+    /// The method for the `/=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn div_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! div_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl DivAssign for $t {\n+            #[inline]\n+            fn div_assign(&mut self, other: $t) { *self /= other }\n+        }\n+    )+)\n+}\n+\n+div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The remainder assignment operator `%=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n+/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// use std::ops::RemAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl RemAssign for Foo {\n+///     fn rem_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Remainder-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo %= Foo;\n+/// }\n+/// ```\n+#[lang = \"rem_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n+pub trait RemAssign<Rhs=Self> {\n+    /// The method for the `%=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn rem_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! rem_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl RemAssign for $t {\n+            #[inline]\n+            fn rem_assign(&mut self, other: $t) { *self %= other }\n+        }\n+    )+)\n+}\n+\n+rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }"}, {"sha": "8743be3557cc4e31f793f4a6d570785de637761a", "filename": "src/libcore/ops/bit.rs", "status": "added", "additions": 839, "deletions": 0, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,839 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The unary logical negation operator `!`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n+/// invert its value.\n+///\n+/// ```\n+/// use std::ops::Not;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Answer {\n+///     Yes,\n+///     No,\n+/// }\n+///\n+/// impl Not for Answer {\n+///     type Output = Answer;\n+///\n+///     fn not(self) -> Answer {\n+///         match self {\n+///             Answer::Yes => Answer::No,\n+///             Answer::No => Answer::Yes\n+///         }\n+///     }\n+/// }\n+///\n+/// assert_eq!(!Answer::Yes, Answer::No);\n+/// assert_eq!(!Answer::No, Answer::Yes);\n+/// ```\n+#[lang = \"not\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Not {\n+    /// The resulting type after applying the `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn not(self) -> Self::Output;\n+}\n+\n+macro_rules! not_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Not for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn not(self) -> $t { !self }\n+        }\n+\n+        forward_ref_unop! { impl Not, not for $t }\n+    )*)\n+}\n+\n+not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise AND operator `&`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAnd for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a & b`\n+///     fn bitand(self, rhs: Self) -> Self {\n+///         Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAnd for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv1 & bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n+pub trait BitAnd<RHS=Self> {\n+    /// The resulting type after applying the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitand(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitand_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitAnd for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitand(self, rhs: $t) -> $t { self & rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n+    )*)\n+}\n+\n+bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR operator `|`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitOr for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a | b`\n+///     fn bitor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 | rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitOr for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, true, true, false]);\n+///     assert_eq!(bv1 | bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n+pub trait BitOr<RHS=Self> {\n+    /// The resulting type after applying the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitOr for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitor(self, rhs: $t) -> $t { self | rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n+    )*)\n+}\n+\n+bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR operator `^`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitXor for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n+///     fn bitxor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 ^ rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitXor for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitxor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter()\n+///                          .zip(rhs.iter())\n+///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n+///                          .collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![false, true, true, false]);\n+///     assert_eq!(bv1 ^ bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitxor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n+pub trait BitXor<RHS=Self> {\n+    /// The resulting type after applying the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitxor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitxor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitXor for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitxor(self, other: $t) -> $t { self ^ other }\n+        }\n+\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n+    )*)\n+}\n+\n+bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift operator `<<`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shl<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs << rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shl` that spins a vector leftward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shl(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n+/// }\n+/// ```\n+#[lang = \"shl\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n+pub trait Shl<RHS> {\n+    /// The resulting type after applying the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shl_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl(self, other: $f) -> $t {\n+                self << other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n+    )\n+}\n+\n+macro_rules! shl_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_impl! { $t, u8 }\n+        shl_impl! { $t, u16 }\n+        shl_impl! { $t, u32 }\n+        shl_impl! { $t, u64 }\n+        shl_impl! { $t, u128 }\n+        shl_impl! { $t, usize }\n+\n+        shl_impl! { $t, i8 }\n+        shl_impl! { $t, i16 }\n+        shl_impl! { $t, i32 }\n+        shl_impl! { $t, i64 }\n+        shl_impl! { $t, i128 }\n+        shl_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n+\n+/// The right shift operator `>>`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shr<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs >> rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shr` that spins a vector rightward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shr(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n+/// }\n+/// ```\n+#[lang = \"shr\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n+pub trait Shr<RHS> {\n+    /// The resulting type after applying the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shr(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shr_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr(self, other: $f) -> $t {\n+                self >> other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n+    )\n+}\n+\n+macro_rules! shr_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_impl! { $t, u8 }\n+        shr_impl! { $t, u16 }\n+        shr_impl! { $t, u32 }\n+        shr_impl! { $t, u64 }\n+        shr_impl! { $t, u128 }\n+        shr_impl! { $t, usize }\n+\n+        shr_impl! { $t, i8 }\n+        shr_impl! { $t, i16 }\n+        shr_impl! { $t, i32 }\n+        shr_impl! { $t, i64 }\n+        shr_impl! { $t, i128 }\n+        shr_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The bitwise AND assignment operator `&=`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAndAssign for Scalar {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         *self = Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(true));\n+///\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAndAssign` trait is implemented for a\n+/// `BooleanVector` struct.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAndAssign for BooleanVector {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         assert_eq!(self.0.len(), rhs.0.len());\n+///         *self = BooleanVector(self.0\n+///                                   .iter()\n+///                                   .zip(rhs.0.iter())\n+///                                   .map(|(x, y)| *x && *y)\n+///                                   .collect());\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut bv = BooleanVector(vec![true, true, false, false]);\n+///     bv &= BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n+pub trait BitAndAssign<Rhs=Self> {\n+    /// The method for the `&=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitand_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitand_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitAndAssign for $t {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: $t) { *self &= other }\n+        }\n+    )+)\n+}\n+\n+bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR assignment operator `|=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n+/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitOrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitOrAssign for Foo {\n+///     fn bitor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Or-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo |= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n+pub trait BitOrAssign<Rhs=Self> {\n+    /// The method for the `|=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitOrAssign for $t {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: $t) { *self |= other }\n+        }\n+    )+)\n+}\n+\n+bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR assignment operator `^=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n+/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitXorAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitXorAssign for Foo {\n+///     fn bitxor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Xor-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo ^= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitxor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n+pub trait BitXorAssign<Rhs=Self> {\n+    /// The method for the `^=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitxor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitxor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitXorAssign for $t {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n+        }\n+    )+)\n+}\n+\n+bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift assignment operator `<<=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n+/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// use std::ops::ShlAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShlAssign<Foo> for Foo {\n+///     fn shl_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting left!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo <<= Foo;\n+/// }\n+/// ```\n+#[lang = \"shl_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n+pub trait ShlAssign<Rhs> {\n+    /// The method for the `<<=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shl_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shl_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShlAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self <<= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shl_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_assign_impl! { $t, u8 }\n+        shl_assign_impl! { $t, u16 }\n+        shl_assign_impl! { $t, u32 }\n+        shl_assign_impl! { $t, u64 }\n+        shl_assign_impl! { $t, u128 }\n+        shl_assign_impl! { $t, usize }\n+\n+        shl_assign_impl! { $t, i8 }\n+        shl_assign_impl! { $t, i16 }\n+        shl_assign_impl! { $t, i32 }\n+        shl_assign_impl! { $t, i64 }\n+        shl_assign_impl! { $t, i128 }\n+        shl_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The right shift assignment operator `>>=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n+/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// use std::ops::ShrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShrAssign<Foo> for Foo {\n+///     fn shr_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting right!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo >>= Foo;\n+/// }\n+/// ```\n+#[lang = \"shr_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n+pub trait ShrAssign<Rhs=Self> {\n+    /// The method for the `>>=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shr_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shr_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShrAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self >>= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shr_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_assign_impl! { $t, u8 }\n+        shr_assign_impl! { $t, u16 }\n+        shr_assign_impl! { $t, u32 }\n+        shr_assign_impl! { $t, u64 }\n+        shr_assign_impl! { $t, u128 }\n+        shr_assign_impl! { $t, usize }\n+\n+        shr_assign_impl! { $t, i8 }\n+        shr_assign_impl! { $t, i16 }\n+        shr_assign_impl! { $t, i32 }\n+        shr_assign_impl! { $t, i64 }\n+        shr_assign_impl! { $t, i128 }\n+        shr_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }"}, {"sha": "3f4dabbbc0ce2d26cc802c540f668190605af720", "filename": "src/libcore/ops/deref.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Deref` trait is used to specify the functionality of dereferencing\n+/// operations, like `*v`.\n+///\n+/// `Deref` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n+/// # Examples\n+///\n+/// A struct with a single field which is accessible via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::Deref;\n+///\n+/// struct DerefExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref for DerefExample<T> {\n+///     type Target = T;\n+///\n+///     fn deref(&self) -> &T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let x = DerefExample { value: 'a' };\n+///     assert_eq!('a', *x);\n+/// }\n+/// ```\n+#[lang = \"deref\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Deref {\n+    /// The resulting type after dereferencing\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Target: ?Sized;\n+\n+    /// The method called to dereference a value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Deref for &'a T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { *self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Deref for &'a mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { *self }\n+}\n+\n+/// The `DerefMut` trait is used to specify the functionality of dereferencing\n+/// mutably like `*v = 1;`\n+///\n+/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n+/// # Examples\n+///\n+/// A struct with a single field which is modifiable via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::{Deref, DerefMut};\n+///\n+/// struct DerefMutExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref for DerefMutExample<T> {\n+///     type Target = T;\n+///\n+///     fn deref(&self) -> &T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// impl<T> DerefMut for DerefMutExample<T> {\n+///     fn deref_mut(&mut self) -> &mut T {\n+///         &mut self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut x = DerefMutExample { value: 'a' };\n+///     *x = 'b';\n+///     assert_eq!('b', *x);\n+/// }\n+/// ```\n+#[lang = \"deref_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DerefMut: Deref {\n+    /// The method called to mutably dereference a value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> DerefMut for &'a mut T {\n+    fn deref_mut(&mut self) -> &mut T { *self }\n+}"}, {"sha": "92f3cb256c8335f42ea4b233dcf54de9dcc84bd3", "filename": "src/libcore/ops/drop.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// This is sometimes called a 'destructor'.\n+///\n+/// When a value goes out of scope, if it implements this trait, it will have\n+/// its `drop` method called. Then any fields the value contains will also\n+/// be dropped recursively.\n+///\n+/// Because of the recursive dropping, you do not need to implement this trait\n+/// unless your type needs its own destructor logic.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n+/// goes out of scope, and therefore `main` prints `Dropping!`.\n+///\n+/// ```\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = HasDrop;\n+/// }\n+/// ```\n+///\n+/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n+/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n+/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n+///\n+/// ```\n+/// struct Inner;\n+/// struct Outer(Inner);\n+///\n+/// impl Drop for Inner {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Inner!\");\n+///     }\n+/// }\n+///\n+/// impl Drop for Outer {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Outer!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = Outer(Inner);\n+/// }\n+/// ```\n+///\n+/// Because variables are dropped in the reverse order they are declared,\n+/// `main` will print `Declared second!` and then `Declared first!`.\n+///\n+/// ```\n+/// struct PrintOnDrop(&'static str);\n+///\n+/// fn main() {\n+///     let _first = PrintOnDrop(\"Declared first!\");\n+///     let _second = PrintOnDrop(\"Declared second!\");\n+/// }\n+/// ```\n+#[lang = \"drop\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Drop {\n+    /// A method called when the value goes out of scope.\n+    ///\n+    /// When this method has been called, `self` has not yet been deallocated.\n+    /// If it were, `self` would be a dangling reference.\n+    ///\n+    /// After this function is over, the memory of `self` will be deallocated.\n+    ///\n+    /// This function cannot be called explicitly. This is compiler error\n+    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n+    /// used to call the argument's `Drop` implementation.\n+    ///\n+    /// [E0040]: ../../error-index.html#E0040\n+    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n+    /// a `drop()` implementation will likely abort.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn drop(&mut self);\n+}"}, {"sha": "62bf69336a398ebdb6015319562fac3ccbb19f46", "filename": "src/libcore/ops/function.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A version of the call operator that takes an immutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures automatically implement this trait, which allows them to be\n+/// invoked. Note, however, that `Fn` takes an immutable reference to any\n+/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n+/// consume the capture, implement [`FnOnce`].\n+///\n+/// [`FnMut`]: trait.FnMut.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `Fn`\n+/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n+/// `Fn`).\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n+#[lang = \"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait Fn<Args> : FnMut<Args> {\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures that mutably capture variables automatically implement this trait,\n+/// which allows them to be invoked.\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `FnMut`\n+/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n+#[lang = \"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+///\n+/// # Examples\n+///\n+/// By-value closures automatically implement this trait, which allows them to\n+/// be invoked.\n+///\n+/// ```\n+/// let x = 5;\n+/// let square_x = move || x * x;\n+/// assert_eq!(square_x(), 25);\n+/// ```\n+///\n+/// By-value Closures can also be passed to higher-level functions through a\n+/// `FnOnce` parameter.\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n+#[lang = \"fn_once\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait FnOnce<Args> {\n+    /// The returned type after the call operator is used.\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+mod impls {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> Fn<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}, {"sha": "b16b956778744d29a9ee2642866ed0c1550e884b", "filename": "src/libcore/ops/index.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Index` trait is used to specify the functionality of indexing operations\n+/// like `container[index]` when used in an immutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n+/// but only when used as an immutable value. If a mutable value is requested,\n+/// [`IndexMut`] is used instead. This allows nice things such as\n+/// `let value = v[index]` if `value` implements [`Copy`].\n+///\n+/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n+/// # Examples\n+///\n+/// The following example implements `Index` on a read-only `NucleotideCount`\n+/// container, enabling individual counts to be retrieved with index syntax.\n+///\n+/// ```\n+/// use std::ops::Index;\n+///\n+/// enum Nucleotide {\n+///     A,\n+///     C,\n+///     G,\n+///     T,\n+/// }\n+///\n+/// struct NucleotideCount {\n+///     a: usize,\n+///     c: usize,\n+///     g: usize,\n+///     t: usize,\n+/// }\n+///\n+/// impl Index<Nucleotide> for NucleotideCount {\n+///     type Output = usize;\n+///\n+///     fn index(&self, nucleotide: Nucleotide) -> &usize {\n+///         match nucleotide {\n+///             Nucleotide::A => &self.a,\n+///             Nucleotide::C => &self.c,\n+///             Nucleotide::G => &self.g,\n+///             Nucleotide::T => &self.t,\n+///         }\n+///     }\n+/// }\n+///\n+/// let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};\n+/// assert_eq!(nucleotide_count[Nucleotide::A], 14);\n+/// assert_eq!(nucleotide_count[Nucleotide::C], 9);\n+/// assert_eq!(nucleotide_count[Nucleotide::G], 10);\n+/// assert_eq!(nucleotide_count[Nucleotide::T], 12);\n+/// ```\n+#[lang = \"index\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Index<Idx: ?Sized> {\n+    /// The returned type after indexing\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output: ?Sized;\n+\n+    /// The method for the indexing (`container[index]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+/// The `IndexMut` trait is used to specify the functionality of indexing\n+/// operations like `container[index]` when used in a mutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for\n+/// `*container.index_mut(index)`, but only when used as a mutable value. If\n+/// an immutable value is requested, the [`Index`] trait is used instead. This\n+/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+///\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n+/// # Examples\n+///\n+/// A very simple implementation of a `Balance` struct that has two sides, where\n+/// each can be indexed mutably and immutably.\n+///\n+/// ```\n+/// use std::ops::{Index,IndexMut};\n+///\n+/// #[derive(Debug)]\n+/// enum Side {\n+///     Left,\n+///     Right,\n+/// }\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Weight {\n+///     Kilogram(f32),\n+///     Pound(f32),\n+/// }\n+///\n+/// struct Balance {\n+///     pub left: Weight,\n+///     pub right:Weight,\n+/// }\n+///\n+/// impl Index<Side> for Balance {\n+///     type Output = Weight;\n+///\n+///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///         println!(\"Accessing {:?}-side of balance immutably\", index);\n+///         match index {\n+///             Side::Left => &self.left,\n+///             Side::Right => &self.right,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl IndexMut<Side> for Balance {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///         println!(\"Accessing {:?}-side of balance mutably\", index);\n+///         match index {\n+///             Side::Left => &mut self.left,\n+///             Side::Right => &mut self.right,\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut balance = Balance {\n+///         right: Weight::Kilogram(2.5),\n+///         left: Weight::Pound(1.5),\n+///     };\n+///\n+///     // In this case balance[Side::Right] is sugar for\n+///     // *balance.index(Side::Right), since we are only reading\n+///     // balance[Side::Right], not writing it.\n+///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n+///\n+///     // However in this case balance[Side::Left] is sugar for\n+///     // *balance.index_mut(Side::Left), since we are writing\n+///     // balance[Side::Left].\n+///     balance[Side::Left] = Weight::Kilogram(3.0);\n+/// }\n+/// ```\n+#[lang = \"index_mut\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n+    /// The method for the mutable indexing (`container[index]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n+}"}, {"sha": "4e0389e5de4eb24157a74afe4dfaab0cba30a03d", "filename": "src/libcore/ops/mod.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Overloadable operators.\n+//!\n+//! Implementing these traits allows you to overload certain operators.\n+//!\n+//! Some of these traits are imported by the prelude, so they are available in\n+//! every Rust program. Only operators backed by traits can be overloaded. For\n+//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n+//! trait, but since the assignment operator (`=`) has no backing trait, there\n+//! is no way of overloading its semantics. Additionally, this module does not\n+//! provide any mechanism to create new operators. If traitless overloading or\n+//! custom operators are required, you should look toward macros or compiler\n+//! plugins to extend Rust's syntax.\n+//!\n+//! Note that the `&&` and `||` operators short-circuit, i.e. they only\n+//! evaluate their second operand if it contributes to the result. Since this\n+//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n+//! overloadable operators.\n+//!\n+//! Many of the operators take their operands by value. In non-generic\n+//! contexts involving built-in types, this is usually not a problem.\n+//! However, using these operators in generic code, requires some\n+//! attention if values have to be reused as opposed to letting the operators\n+//! consume them. One option is to occasionally use [`clone`].\n+//! Another option is to rely on the types involved providing additional\n+//! operator implementations for references. For example, for a user-defined\n+//! type `T` which is supposed to support addition, it is probably a good\n+//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n+//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n+//! cloning.\n+//!\n+//! # Examples\n+//!\n+//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n+//! and then demonstrates adding and subtracting two `Point`s.\n+//!\n+//! ```rust\n+//! use std::ops::{Add, Sub};\n+//!\n+//! #[derive(Debug)]\n+//! struct Point {\n+//!     x: i32,\n+//!     y: i32,\n+//! }\n+//!\n+//! impl Add for Point {\n+//!     type Output = Point;\n+//!\n+//!     fn add(self, other: Point) -> Point {\n+//!         Point {x: self.x + other.x, y: self.y + other.y}\n+//!     }\n+//! }\n+//!\n+//! impl Sub for Point {\n+//!     type Output = Point;\n+//!\n+//!     fn sub(self, other: Point) -> Point {\n+//!         Point {x: self.x - other.x, y: self.y - other.y}\n+//!     }\n+//! }\n+//! fn main() {\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n+//! }\n+//! ```\n+//!\n+//! See the documentation for each trait for an example implementation.\n+//!\n+//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n+//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n+//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n+//! methods that can be invoked on an instance: call-by-reference,\n+//! call-by-mutable-reference, and call-by-value. The most common use of these\n+//! traits is to act as bounds to higher-level functions that take functions or\n+//! closures as arguments.\n+//!\n+//! Taking a [`Fn`] as a parameter:\n+//!\n+//! ```rust\n+//! fn call_with_one<F>(func: F) -> usize\n+//!     where F: Fn(usize) -> usize\n+//! {\n+//!     func(1)\n+//! }\n+//!\n+//! let double = |x| x * 2;\n+//! assert_eq!(call_with_one(double), 2);\n+//! ```\n+//!\n+//! Taking a [`FnMut`] as a parameter:\n+//!\n+//! ```rust\n+//! fn do_twice<F>(mut func: F)\n+//!     where F: FnMut()\n+//! {\n+//!     func();\n+//!     func();\n+//! }\n+//!\n+//! let mut x: usize = 1;\n+//! {\n+//!     let add_two_to_x = || x += 2;\n+//!     do_twice(add_two_to_x);\n+//! }\n+//!\n+//! assert_eq!(x, 5);\n+//! ```\n+//!\n+//! Taking a [`FnOnce`] as a parameter:\n+//!\n+//! ```rust\n+//! fn consume_with_relish<F>(func: F)\n+//!     where F: FnOnce() -> String\n+//! {\n+//!     // `func` consumes its captured variables, so it cannot be run more\n+//!     // than once\n+//!     println!(\"Consumed: {}\", func());\n+//!\n+//!     println!(\"Delicious!\");\n+//!\n+//!     // Attempting to invoke `func()` again will throw a `use of moved\n+//!     // value` error for `func`\n+//! }\n+//!\n+//! let x = String::from(\"x\");\n+//! let consume_and_return_x = move || x;\n+//! consume_with_relish(consume_and_return_x);\n+//!\n+//! // `consume_and_return_x` can no longer be invoked at this point\n+//! ```\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//! [`Add`]: trait.Add.html\n+//! [`Sub`]: trait.Sub.html\n+//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+mod arith;\n+mod bit;\n+mod deref;\n+mod drop;\n+mod function;\n+mod index;\n+mod place;\n+mod range;\n+mod try;\n+mod unsize;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::deref::{Deref, DerefMut};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::drop::Drop;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::function::{Fn, FnMut, FnOnce};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::index::{Index, IndexMut};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub use self::range::{RangeInclusive, RangeToInclusive};\n+\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+#[cfg(stage0)]\n+pub use self::try::Carrier;\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+pub use self::try::Try;\n+\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+pub use self::unsize::CoerceUnsized;"}, {"sha": "996a741c96f9372fc1b95e313317d8ce3a786b52", "filename": "src/libcore/ops/place.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then it is up to the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `PLACE <- EXPR`.\n+///\n+/// `PLACE <- EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n+    ///\n+    /// Note that when `PLACE <- EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place: BoxPlace<Self::Data>;\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}, {"sha": "70c35df87ddaf8d1aef329b7ff44a783d4a6623b", "filename": "src/libcore/ops/range.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,366 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+\n+/// An unbounded range. Use `..` (two dots) for its shorthand.\n+///\n+/// Its primary use case is slicing index. It cannot serve as an iterator\n+/// because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..` syntax is a `RangeFull`:\n+///\n+/// ```\n+/// assert_eq!((..), std::ops::RangeFull);\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in .. {\n+///    // ...\n+/// }\n+/// ```\n+///\n+/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFull;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for RangeFull {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..\")\n+    }\n+}\n+\n+/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n+/// Use `start..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3..6).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Range<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..5).contains(2));\n+    ///     assert!(   (3..5).contains(3));\n+    ///     assert!(   (3..5).contains(4));\n+    ///     assert!( ! (3..5).contains(5));\n+    ///\n+    ///     assert!( ! (3..3).contains(3));\n+    ///     assert!( ! (3..2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item) && (item < self.end)\n+    }\n+}\n+\n+/// A range which is only bounded below: { x | start <= x }.\n+/// Use `start..` for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// Note: Currently, no overflow checking is done for the iterator\n+/// implementation; if you use an integer range and the integer overflows, it\n+/// might panic in debug mode or create an endless loop in release mode. This\n+/// overflow behavior might change in the future.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n+///     assert_eq!(2+3+4, (2..).take(3).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFrom<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..\", self.start)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..).contains(2));\n+    ///     assert!(   (3..).contains(3));\n+    ///     assert!(   (3..).contains(1_000_000_000));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item)\n+    }\n+}\n+\n+/// A range which is only bounded above: { x | x < end }.\n+/// Use `..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..{integer}` syntax is a `RangeTo`:\n+///\n+/// ```\n+/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ..5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// elements before the index indicated by `end`.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeTo<Idx> {\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!(   (..5).contains(-1_000_000_000));\n+    ///     assert!(   (..5).contains(4));\n+    ///     assert!( ! (..5).contains(5));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item < self.end)\n+    }\n+}\n+\n+/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n+/// Use `start...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// fn main() {\n+///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3...5).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);\n+///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeInclusive<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!( ! (3...5).contains(2));\n+    ///     assert!(   (3...5).contains(3));\n+    ///     assert!(   (3...5).contains(4));\n+    ///     assert!(   (3...5).contains(5));\n+    ///     assert!( ! (3...5).contains(6));\n+    ///\n+    ///     assert!(   (3...3).contains(3));\n+    ///     assert!( ! (3...2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        self.start <= item && item <= self.end\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above: { x | x <= end }.\n+/// Use `...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `...{integer}` syntax is a `RangeToInclusive`:\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ...5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// array elements up to and including the index indicated by `end`.\n+///\n+/// ```\n+/// #![feature(inclusive_range_syntax)]\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeToInclusive<Idx> {\n+    /// The upper bound of the range (inclusive)\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"...{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!(   (...5).contains(-1_000_000_000));\n+    ///     assert!(   (...5).contains(5));\n+    ///     assert!( ! (...5).contains(6));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item <= self.end)\n+    }\n+}\n+\n+// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n+// because underflow would be possible with (..0).into()"}, {"sha": "cf75cf79fae6989f9667a10e1eb5eb5c33abded4", "filename": "src/libcore/ops/try.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// This trait has been superseded by the `Try` trait, but must remain\n+/// here as `?` is still lowered to it in stage0 .\n+#[cfg(stage0)]\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+pub trait Carrier {\n+    /// The type of the value when computation succeeds.\n+    type Success;\n+    /// The type of the value when computation errors out.\n+    type Error;\n+\n+    /// Create a `Carrier` from a success value.\n+    fn from_success(_: Self::Success) -> Self;\n+\n+    /// Create a `Carrier` from an error value.\n+    fn from_error(_: Self::Error) -> Self;\n+\n+    /// Translate this `Carrier` to another implementation of `Carrier` with the\n+    /// same associated types.\n+    fn translate<T>(self) -> T where T: Carrier<Success=Self::Success, Error=Self::Error>;\n+}\n+\n+#[cfg(stage0)]\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl<U, V> Carrier for Result<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> Result<U, V> {\n+        Ok(u)\n+    }\n+\n+    fn from_error(e: V) -> Result<U, V> {\n+        Err(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            Ok(u) => T::from_success(u),\n+            Err(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+struct _DummyErrorType;\n+\n+impl Try for _DummyErrorType {\n+    type Ok = ();\n+    type Error = ();\n+\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn from_ok(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+\n+    fn from_error(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+}\n+\n+/// A trait for customizing the behaviour of the `?` operator.\n+///\n+/// A type implementing `Try` is one that has a canonical way to view it\n+/// in terms of a success/failure dichotomy.  This trait allows both\n+/// extracting those success or failure values from an existing instance and\n+/// creating a new instance from a success or failure value.\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+pub trait Try {\n+    /// The type of this value when viewed as successful.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    type Ok;\n+    /// The type of this value when viewed as failed.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    type Error;\n+\n+    /// Applies the \"?\" operator. A return of `Ok(t)` means that the\n+    /// execution should continue normally, and the result of `?` is the\n+    /// value `t`. A return of `Err(e)` means that execution should branch\n+    /// to the innermost enclosing `catch`, or return from the function.\n+    ///\n+    /// If an `Err(e)` result is returned, the value `e` will be \"wrapped\"\n+    /// in the return type of the enclosing scope (which must itself implement\n+    /// `Try`). Specifically, the value `X::from_error(From::from(e))`\n+    /// is returned, where `X` is the return type of the enclosing function.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error>;\n+\n+    /// Wrap an error value to construct the composite result. For example,\n+    /// `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn from_error(v: Self::Error) -> Self;\n+\n+    /// Wrap an OK value to construct the composite result. For example,\n+    /// `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn from_ok(v: Self::Ok) -> Self;\n+}"}, {"sha": "1914216e9f08a97b78b36983db7444e4ef0989b6", "filename": "src/libcore/ops/unsize.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use marker::Unsize;\n+\n+/// Trait that indicates that this is a pointer or a wrapper for one,\n+/// where unsizing can be performed on the pointee.\n+///\n+/// See the [DST coercion RfC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n+/// for more details.\n+///\n+/// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`\n+/// by converting from a thin pointer to a fat pointer.\n+///\n+/// For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>`\n+/// provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.\n+/// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n+/// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n+/// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n+/// by coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n+/// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n+/// field and coerce that.\n+///\n+/// Generally, for smart pointers you will implement\n+/// `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an\n+/// optional `?Sized` bound on `T` itself. For wrapper types that directly embed `T`\n+/// like `Cell<T>` and `RefCell<T>`, you\n+/// can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.\n+/// This will let coercions of types like `Cell<Box<T>>` work.\n+///\n+/// [`Unsize`][unsize] is used to mark types which can be coerced to DSTs if behind\n+/// pointers. It is implemented automatically by the compiler.\n+///\n+/// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+/// [unsize]: ../marker/trait.Unsize.html\n+/// [nomicon-coerce]: ../../nomicon/coercions.html\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+#[lang=\"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {\n+    // Empty.\n+}\n+\n+// &mut T -> &mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+// &mut T -> &U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+// &mut T -> *mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+// &mut T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+// &T -> &U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+// &T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+// *mut T -> *mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+// *mut T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+\n+// *const T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "c3d46ff5314fe0b6cd6d0c05e12419e06a5074cb", "filename": "src/test/codegen-units/item-collection/function-as-argument.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -28,12 +28,12 @@ fn main() {\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<u32, &str>\n-    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n     take_fn_once(function, 0u32, \"abc\");\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<char, f64>\n-    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n     take_fn_once(function, 'c', 0f64);\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>"}, {"sha": "21c9c254e51cfe7cffaa492f19449d3a9ee284c2", "filename": "src/test/codegen-units/item-collection/trait-method-as-argument.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554c685b0b3b25b7aa752717edf50b8d6bcab7a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs?ref=554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "patch": "@@ -40,27 +40,27 @@ fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n fn main() {\n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n     //~ TRANS_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n-    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n     take_foo_once(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n     //~ TRANS_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n-    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n     take_foo_once(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n     take_foo(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n-    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n     take_foo(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n     take_foo_mut(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n-    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n+    //~ TRANS_ITEM fn core::ops[0]::function[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n     take_foo_mut(Trait::foo, 'c');\n }"}]}