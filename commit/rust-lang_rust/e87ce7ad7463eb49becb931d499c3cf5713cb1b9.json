{"sha": "e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "node_id": "C_kwDOAAsO6NoAKGU4N2NlN2FkNzQ2M2ViNDliZWNiOTMxZDQ5OWMzY2Y1NzEzY2IxYjk", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-12-29T10:47:19Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-10T10:11:44Z"}, "message": "expand: Pick `cfg`s and `cfg_attrs` one by one, like other attributes", "tree": {"sha": "072682b6c49fb2999cb4c0cd942d8ef50e7a16b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072682b6c49fb2999cb4c0cd942d8ef50e7a16b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "html_url": "https://github.com/rust-lang/rust/commit/e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "html_url": "https://github.com/rust-lang/rust/commit/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c"}], "stats": {"total": 405, "additions": 240, "deletions": 165}, "files": [{"sha": "5fa7ffd554ef12b4edaa39ebb966e705cd38bb75", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 96, "deletions": 82, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -328,18 +328,18 @@ impl<'a> StripUnconfigured<'a> {\n         });\n     }\n \n+    fn process_cfg_attr(&self, attr: Attribute) -> Vec<Attribute> {\n+        if attr.has_name(sym::cfg_attr) { self.expand_cfg_attr(attr, true) } else { vec![attr] }\n+    }\n+\n     /// Parse and expand a single `cfg_attr` attribute into a list of attributes\n     /// when the configuration predicate is true, or otherwise expand into an\n     /// empty list of attributes.\n     ///\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    fn process_cfg_attr(&self, attr: Attribute) -> Vec<Attribute> {\n-        if !attr.has_name(sym::cfg_attr) {\n-            return vec![attr];\n-        }\n-\n+    crate fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n         let (cfg_predicate, expanded_attrs) =\n             match rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) {\n                 None => return vec![],\n@@ -348,95 +348,109 @@ impl<'a> StripUnconfigured<'a> {\n \n         // Lint on zero attributes in source.\n         if expanded_attrs.is_empty() {\n-            return vec![attr];\n+            self.sess.parse_sess.buffer_lint(\n+                rustc_lint_defs::builtin::UNUSED_ATTRIBUTES,\n+                attr.span,\n+                ast::CRATE_NODE_ID,\n+                \"`#[cfg_attr]` does not expand to any attributes\",\n+            );\n         }\n \n         if !attr::cfg_matches(&cfg_predicate, &self.sess.parse_sess, self.features) {\n             return vec![];\n         }\n \n-        // We call `process_cfg_attr` recursively in case there's a\n-        // `cfg_attr` inside of another `cfg_attr`. E.g.\n-        //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n-        expanded_attrs\n-            .into_iter()\n-            .flat_map(|(item, span)| {\n-                let orig_tokens = attr.tokens().to_tokenstream();\n-\n-                // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n-                // and producing an attribute of the form `#[attr]`. We\n-                // have captured tokens for `attr` itself, but we need to\n-                // synthesize tokens for the wrapper `#` and `[]`, which\n-                // we do below.\n-\n-                // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n-                // for `attr` when we expand it to `#[attr]`\n-                let mut orig_trees = orig_tokens.trees();\n-                let pound_token = match orig_trees.next().unwrap() {\n-                    TokenTree::Token(token @ Token { kind: TokenKind::Pound, .. }) => token,\n-                    _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n-                };\n-                let pound_span = pound_token.span;\n-\n-                let mut trees = vec![(AttrAnnotatedTokenTree::Token(pound_token), Spacing::Alone)];\n-                if attr.style == AttrStyle::Inner {\n-                    // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n-                    let bang_token = match orig_trees.next().unwrap() {\n-                        TokenTree::Token(token @ Token { kind: TokenKind::Not, .. }) => token,\n-                        _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n-                    };\n-                    trees.push((AttrAnnotatedTokenTree::Token(bang_token), Spacing::Alone));\n-                }\n-                // We don't really have a good span to use for the syntheized `[]`\n-                // in `#[attr]`, so just use the span of the `#` token.\n-                let bracket_group = AttrAnnotatedTokenTree::Delimited(\n-                    DelimSpan::from_single(pound_span),\n-                    DelimToken::Bracket,\n-                    item.tokens\n-                        .as_ref()\n-                        .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n-                        .create_token_stream(),\n-                );\n-                trees.push((bracket_group, Spacing::Alone));\n-                let tokens = Some(LazyTokenStream::new(AttrAnnotatedTokenStream::new(trees)));\n-                let attr = attr::mk_attr_from_item(item, tokens, attr.style, span);\n-                if attr.has_name(sym::crate_type) {\n-                    self.sess.parse_sess.buffer_lint(\n-                        rustc_lint_defs::builtin::DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n-                        attr.span,\n-                        ast::CRATE_NODE_ID,\n-                        \"`crate_type` within an `#![cfg_attr] attribute is deprecated`\",\n-                    );\n-                }\n-                if attr.has_name(sym::crate_name) {\n-                    self.sess.parse_sess.buffer_lint(\n-                        rustc_lint_defs::builtin::DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n-                        attr.span,\n-                        ast::CRATE_NODE_ID,\n-                        \"`crate_name` within an `#![cfg_attr] attribute is deprecated`\",\n-                    );\n-                }\n-                self.process_cfg_attr(attr)\n-            })\n-            .collect()\n+        if recursive {\n+            // We call `process_cfg_attr` recursively in case there's a\n+            // `cfg_attr` inside of another `cfg_attr`. E.g.\n+            //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n+            expanded_attrs\n+                .into_iter()\n+                .flat_map(|item| self.process_cfg_attr(self.expand_cfg_attr_item(&attr, item)))\n+                .collect()\n+        } else {\n+            expanded_attrs.into_iter().map(|item| self.expand_cfg_attr_item(&attr, item)).collect()\n+        }\n+    }\n+\n+    fn expand_cfg_attr_item(\n+        &self,\n+        attr: &Attribute,\n+        (item, item_span): (ast::AttrItem, Span),\n+    ) -> Attribute {\n+        let orig_tokens = attr.tokens().to_tokenstream();\n+\n+        // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n+        // and producing an attribute of the form `#[attr]`. We\n+        // have captured tokens for `attr` itself, but we need to\n+        // synthesize tokens for the wrapper `#` and `[]`, which\n+        // we do below.\n+\n+        // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n+        // for `attr` when we expand it to `#[attr]`\n+        let mut orig_trees = orig_tokens.trees();\n+        let pound_token = match orig_trees.next().unwrap() {\n+            TokenTree::Token(token @ Token { kind: TokenKind::Pound, .. }) => token,\n+            _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+        };\n+        let pound_span = pound_token.span;\n+\n+        let mut trees = vec![(AttrAnnotatedTokenTree::Token(pound_token), Spacing::Alone)];\n+        if attr.style == AttrStyle::Inner {\n+            // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n+            let bang_token = match orig_trees.next().unwrap() {\n+                TokenTree::Token(token @ Token { kind: TokenKind::Not, .. }) => token,\n+                _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+            };\n+            trees.push((AttrAnnotatedTokenTree::Token(bang_token), Spacing::Alone));\n+        }\n+        // We don't really have a good span to use for the syntheized `[]`\n+        // in `#[attr]`, so just use the span of the `#` token.\n+        let bracket_group = AttrAnnotatedTokenTree::Delimited(\n+            DelimSpan::from_single(pound_span),\n+            DelimToken::Bracket,\n+            item.tokens\n+                .as_ref()\n+                .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n+                .create_token_stream(),\n+        );\n+        trees.push((bracket_group, Spacing::Alone));\n+        let tokens = Some(LazyTokenStream::new(AttrAnnotatedTokenStream::new(trees)));\n+        let attr = attr::mk_attr_from_item(item, tokens, attr.style, item_span);\n+        if attr.has_name(sym::crate_type) {\n+            self.sess.parse_sess.buffer_lint(\n+                rustc_lint_defs::builtin::DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n+                attr.span,\n+                ast::CRATE_NODE_ID,\n+                \"`crate_type` within an `#![cfg_attr] attribute is deprecated`\",\n+            );\n+        }\n+        if attr.has_name(sym::crate_name) {\n+            self.sess.parse_sess.buffer_lint(\n+                rustc_lint_defs::builtin::DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n+                attr.span,\n+                ast::CRATE_NODE_ID,\n+                \"`crate_name` within an `#![cfg_attr] attribute is deprecated`\",\n+            );\n+        }\n+        attr\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n     fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n-        attrs.iter().all(|attr| {\n-            if !is_cfg(attr) {\n+        attrs.iter().all(|attr| !is_cfg(attr) || self.cfg_true(attr))\n+    }\n+\n+    crate fn cfg_true(&self, attr: &Attribute) -> bool {\n+        let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n+            Ok(meta_item) => meta_item,\n+            Err(mut err) => {\n+                err.emit();\n                 return true;\n             }\n-            let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n-                Ok(meta_item) => meta_item,\n-                Err(mut err) => {\n-                    err.emit();\n-                    return true;\n-                }\n-            };\n-            parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n-                attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.features)\n-            })\n+        };\n+        parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n+            attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.features)\n         })\n     }\n "}, {"sha": "7604a464be2ffd51affdc8623035bde56c2f145b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 132, "deletions": 48, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -15,7 +15,6 @@ use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, For\n use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n-use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n@@ -1014,6 +1013,9 @@ trait InvocationCollectorNode: AstLike {\n     fn to_annotatable(self) -> Annotatable;\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n     fn id(&mut self) -> &mut NodeId;\n+    fn descr() -> &'static str {\n+        unreachable!()\n+    }\n     fn noop_flat_map<V: MutVisitor>(self, _visitor: &mut V) -> Self::OutputTy {\n         unreachable!()\n     }\n@@ -1477,6 +1479,9 @@ impl InvocationCollectorNode for P<ast::Expr> {\n     fn id(&mut self) -> &mut NodeId {\n         &mut self.id\n     }\n+    fn descr() -> &'static str {\n+        \"an expression\"\n+    }\n     fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n         noop_visit_expr(self, visitor)\n     }\n@@ -1576,13 +1581,28 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     ) -> Option<(ast::Attribute, usize, Vec<ast::Path>)> {\n         let mut attr = None;\n \n+        let mut cfg_pos = None;\n+        let mut attr_pos = None;\n+        for (pos, attr) in item.attrs().iter().enumerate() {\n+            if !attr.is_doc_comment() && !self.cx.expanded_inert_attrs.is_marked(attr) {\n+                let name = attr.ident().map(|ident| ident.name);\n+                if name == Some(sym::cfg) || name == Some(sym::cfg_attr) {\n+                    cfg_pos = Some(pos); // a cfg attr found, no need to search anymore\n+                    break;\n+                } else if attr_pos.is_none()\n+                    && !name.map_or(false, rustc_feature::is_builtin_attr_name)\n+                {\n+                    attr_pos = Some(pos); // a non-cfg attr found, still may find a cfg attr\n+                }\n+            }\n+        }\n+\n         item.visit_attrs(|attrs| {\n-            attr = attrs\n-                .iter()\n-                .position(|a| !self.cx.expanded_inert_attrs.is_marked(a) && !is_builtin_attr(a))\n-                .map(|attr_pos| {\n-                    let attr = attrs.remove(attr_pos);\n-                    let following_derives = attrs[attr_pos..]\n+            attr = Some(match (cfg_pos, attr_pos) {\n+                (Some(pos), _) => (attrs.remove(pos), pos, Vec::new()),\n+                (_, Some(pos)) => {\n+                    let attr = attrs.remove(pos);\n+                    let following_derives = attrs[pos..]\n                         .iter()\n                         .filter(|a| a.has_name(sym::derive))\n                         .flat_map(|a| a.meta_item_list().unwrap_or_default())\n@@ -1596,17 +1616,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         })\n                         .collect();\n \n-                    (attr, attr_pos, following_derives)\n-                })\n+                    (attr, pos, following_derives)\n+                }\n+                _ => return,\n+            });\n         });\n \n         attr\n     }\n \n-    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n-        self.cfg.configure(node)\n-    }\n-\n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n     fn check_attributes(&self, attrs: &[ast::Attribute], call: &ast::MacCall) {\n@@ -1653,48 +1671,112 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         }\n     }\n \n+    fn expand_cfg_true(\n+        &mut self,\n+        node: &mut impl AstLike,\n+        attr: ast::Attribute,\n+        pos: usize,\n+    ) -> bool {\n+        let res = self.cfg.cfg_true(&attr);\n+        if res {\n+            // FIXME: `cfg(TRUE)` attributes do not currently remove themselves during expansion,\n+            // and some tools like rustdoc and clippy rely on that. Find a way to remove them\n+            // while keeping the tools working.\n+            self.cx.expanded_inert_attrs.mark(&attr);\n+            node.visit_attrs(|attrs| attrs.insert(pos, attr));\n+        }\n+        res\n+    }\n+\n+    fn expand_cfg_attr(&self, node: &mut impl AstLike, attr: ast::Attribute, pos: usize) {\n+        node.visit_attrs(|attrs| {\n+            attrs.splice(pos..pos, self.cfg.expand_cfg_attr(attr, false));\n+        });\n+    }\n+\n     fn flat_map_node<Node: InvocationCollectorNode<OutputTy: Default>>(\n         &mut self,\n-        node: Node,\n+        mut node: Node,\n     ) -> Node::OutputTy {\n-        let mut node = configure!(self, node);\n-\n-        if let Some(attr) = self.take_first_attr(&mut node) {\n-            Node::pre_flat_map_node_collect_attr(&self.cfg, &attr.0);\n-            self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n-        } else if node.is_mac_call() {\n-            let (mac, attrs, add_semicolon) = node.take_mac_call();\n-            self.check_attributes(&attrs, &mac);\n-            let mut res = self.collect_bang(mac, Node::KIND).make_ast::<Node>();\n-            Node::post_flat_map_node_collect_bang(&mut res, add_semicolon);\n-            res\n-        } else {\n-            match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n-                assign_id!(this, node.id(), || node.noop_flat_map(this))\n-            }) {\n-                Ok(output) => output,\n-                Err(node) => self.flat_map_node(node),\n-            }\n+        loop {\n+            return match self.take_first_attr(&mut node) {\n+                Some((attr, pos, derives)) => match attr.name_or_empty() {\n+                    sym::cfg => {\n+                        if self.expand_cfg_true(&mut node, attr, pos) {\n+                            continue;\n+                        }\n+                        Default::default()\n+                    }\n+                    sym::cfg_attr => {\n+                        self.expand_cfg_attr(&mut node, attr, pos);\n+                        continue;\n+                    }\n+                    _ => {\n+                        Node::pre_flat_map_node_collect_attr(&self.cfg, &attr);\n+                        self.collect_attr((attr, pos, derives), node.to_annotatable(), Node::KIND)\n+                            .make_ast::<Node>()\n+                    }\n+                },\n+                None if node.is_mac_call() => {\n+                    let (mac, attrs, add_semicolon) = node.take_mac_call();\n+                    self.check_attributes(&attrs, &mac);\n+                    let mut res = self.collect_bang(mac, Node::KIND).make_ast::<Node>();\n+                    Node::post_flat_map_node_collect_bang(&mut res, add_semicolon);\n+                    res\n+                }\n+                None => {\n+                    match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n+                        assign_id!(this, node.id(), || node.noop_flat_map(this))\n+                    }) {\n+                        Ok(output) => output,\n+                        Err(returned_node) => {\n+                            node = returned_node;\n+                            continue;\n+                        }\n+                    }\n+                }\n+            };\n         }\n     }\n \n     fn visit_node<Node: InvocationCollectorNode<OutputTy = Node> + DummyAstNode>(\n         &mut self,\n         node: &mut Node,\n     ) {\n-        if let Some(attr) = self.take_first_attr(node) {\n-            visit_clobber(node, |node| {\n-                self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n-            })\n-        } else if node.is_mac_call() {\n-            visit_clobber(node, |node| {\n-                // Do not clobber unless it's actually a macro (uncommon case).\n-                let (mac, attrs, _) = node.take_mac_call();\n-                self.check_attributes(&attrs, &mac);\n-                self.collect_bang(mac, Node::KIND).make_ast::<Node>()\n-            })\n-        } else {\n-            assign_id!(self, node.id(), || node.noop_visit(self))\n+        loop {\n+            return match self.take_first_attr(node) {\n+                Some((attr, pos, derives)) => match attr.name_or_empty() {\n+                    sym::cfg => {\n+                        let span = attr.span;\n+                        if self.expand_cfg_true(node, attr, pos) {\n+                            continue;\n+                        }\n+                        let msg =\n+                            format!(\"removing {} is not supported in this position\", Node::descr());\n+                        self.cx.span_err(span, &msg);\n+                        continue;\n+                    }\n+                    sym::cfg_attr => {\n+                        self.expand_cfg_attr(node, attr, pos);\n+                        continue;\n+                    }\n+                    _ => visit_clobber(node, |node| {\n+                        self.collect_attr((attr, pos, derives), node.to_annotatable(), Node::KIND)\n+                            .make_ast::<Node>()\n+                    }),\n+                },\n+                None if node.is_mac_call() => {\n+                    visit_clobber(node, |node| {\n+                        // Do not clobber unless it's actually a macro (uncommon case).\n+                        let (mac, attrs, _) = node.take_mac_call();\n+                        self.check_attributes(&attrs, &mac);\n+                        self.collect_bang(mac, Node::KIND).make_ast::<Node>()\n+                    })\n+                }\n+                None => {\n+                    assign_id!(self, node.id(), || node.noop_visit(self))\n+                }\n+            };\n         }\n     }\n }\n@@ -1750,7 +1832,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.flat_map_node(node)\n     }\n \n-    fn flat_map_stmt(&mut self, node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+    fn flat_map_stmt(&mut self, mut node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n         // changing that requires some compatibility measures.\n         if node.is_expr() {\n@@ -1761,7 +1843,6 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n             // See #78991 for an investigation of treating macros in this position\n             // as statements, rather than expressions, during parsing.\n-            let mut node = configure!(self, node);\n             return match &node.kind {\n                 StmtKind::Expr(expr)\n                     if matches!(**expr, ast::Expr { kind: ExprKind::MacCall(..), .. }) =>\n@@ -1793,7 +1874,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_expr(&mut self, node: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(node);\n+        // FIXME: Feature gating is performed inconsistently between `Expr` and `OptExpr`.\n+        if let Some(attr) = node.attrs.first() {\n+            self.cfg.maybe_emit_expr_attr_err(attr);\n+        }\n         self.visit_node(node)\n     }\n "}, {"sha": "6e52efe75c19e72347dbd0133a45c19154ee7d36", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -134,7 +134,6 @@ impl CheckAttrVisitor<'_> {\n                 }\n                 sym::macro_use | sym::macro_escape => self.check_macro_use(hir_id, attr, target),\n                 sym::path => self.check_generic_attr(hir_id, attr, target, &[Target::Mod]),\n-                sym::cfg_attr => self.check_cfg_attr(hir_id, attr),\n                 sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n                 sym::macro_export => self.check_macro_export(hir_id, attr, target),\n                 sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n@@ -1823,16 +1822,6 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n-    fn check_cfg_attr(&self, hir_id: HirId, attr: &Attribute) {\n-        if let Some((_, attrs)) = rustc_parse::parse_cfg_attr(&attr, &self.tcx.sess.parse_sess) {\n-            if attrs.is_empty() {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[cfg_attr]` does not expand to any attributes\").emit();\n-                });\n-            }\n-        }\n-    }\n-\n     fn check_plugin_registrar(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::Fn {\n             self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {"}, {"sha": "d005dc3ad456dc4c16afbd64794da7b4bf1a1d19", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-abi.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.rs?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -1,7 +1,9 @@\n #[cfg(target_abi = \"x\")] //~ ERROR `cfg(target_abi)` is experimental\n-#[cfg_attr(target_abi = \"x\", x)] //~ ERROR `cfg(target_abi)` is experimental\n struct Foo(u64, u64);\n \n+#[cfg_attr(target_abi = \"x\", x)] //~ ERROR `cfg(target_abi)` is experimental\n+struct Bar(u64, u64);\n+\n #[cfg(not(any(all(target_abi = \"x\"))))] //~ ERROR `cfg(target_abi)` is experimental\n fn foo() {}\n "}, {"sha": "013705d4886deae884ce52fe6cb6d5292b5300a5", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-abi.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-abi.stderr?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -1,23 +1,23 @@\n error[E0658]: `cfg(target_abi)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-target-abi.rs:2:12\n+  --> $DIR/feature-gate-cfg-target-abi.rs:1:7\n    |\n-LL | #[cfg_attr(target_abi = \"x\", x)]\n-   |            ^^^^^^^^^^^^^^^^\n+LL | #[cfg(target_abi = \"x\")]\n+   |       ^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #80970 <https://github.com/rust-lang/rust/issues/80970> for more information\n    = help: add `#![feature(cfg_target_abi)]` to the crate attributes to enable\n \n error[E0658]: `cfg(target_abi)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-target-abi.rs:1:7\n+  --> $DIR/feature-gate-cfg-target-abi.rs:4:12\n    |\n-LL | #[cfg(target_abi = \"x\")]\n-   |       ^^^^^^^^^^^^^^^^\n+LL | #[cfg_attr(target_abi = \"x\", x)]\n+   |            ^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #80970 <https://github.com/rust-lang/rust/issues/80970> for more information\n    = help: add `#![feature(cfg_target_abi)]` to the crate attributes to enable\n \n error[E0658]: `cfg(target_abi)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-target-abi.rs:5:19\n+  --> $DIR/feature-gate-cfg-target-abi.rs:7:19\n    |\n LL | #[cfg(not(any(all(target_abi = \"x\"))))]\n    |                   ^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL | #[cfg(not(any(all(target_abi = \"x\"))))]\n    = help: add `#![feature(cfg_target_abi)]` to the crate attributes to enable\n \n error[E0658]: `cfg(target_abi)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-target-abi.rs:9:10\n+  --> $DIR/feature-gate-cfg-target-abi.rs:11:10\n    |\n LL |     cfg!(target_abi = \"x\");\n    |          ^^^^^^^^^^^^^^^^"}, {"sha": "a259aa2e6ec0c5d145d31a9c4040a353ac6f510a", "filename": "src/test/ui/proc-macro/cfg-eval-fail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -4,6 +4,4 @@\n fn main() {\n     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n     //~^ ERROR removing an expression is not supported in this position\n-    //~| ERROR removing an expression is not supported in this position\n-    //~| ERROR removing an expression is not supported in this position\n }"}, {"sha": "df8b6d5f382a19f73755e5594f0380c8bd992be0", "filename": "src/test/ui/proc-macro/cfg-eval-fail.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e87ce7ad7463eb49becb931d499c3cf5713cb1b9/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr?ref=e87ce7ad7463eb49becb931d499c3cf5713cb1b9", "patch": "@@ -4,17 +4,5 @@ error: removing an expression is not supported in this position\n LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n    |                         ^^^^^^^^^^^^^\n \n-error: removing an expression is not supported in this position\n-  --> $DIR/cfg-eval-fail.rs:5:25\n-   |\n-LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n-   |                         ^^^^^^^^^^^^^\n-\n-error: removing an expression is not supported in this position\n-  --> $DIR/cfg-eval-fail.rs:5:25\n-   |\n-LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n-   |                         ^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}]}