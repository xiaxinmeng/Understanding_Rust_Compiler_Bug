{"sha": "7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZmJmZWE4ZDA4YzBhYWY2Y2I2MzUzYWNhZTIzZThmYTEwYzI0OTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T23:52:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T23:55:48Z"}, "message": "Convert rustc::syntax::ext::base to istrs. Issue #855", "tree": {"sha": "3409e7bceb9bd39e5067b5768d788537060e44a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3409e7bceb9bd39e5067b5768d788537060e44a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "html_url": "https://github.com/rust-lang/rust/commit/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9857048929c1adc90a19b2027931ac73a28f21dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9857048929c1adc90a19b2027931ac73a28f21dc", "html_url": "https://github.com/rust-lang/rust/commit/9857048929c1adc90a19b2027931ac73a28f21dc"}], "stats": {"total": 169, "additions": 87, "deletions": 82}, "files": [{"sha": "24efb38be860b3d7c251dc04b1ad4e60c16301ed", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -9,7 +9,7 @@ import codemap;\n \n type syntax_expander =\n     fn(&ext_ctxt, span, @ast::expr, &option::t<istr>) -> @ast::expr;\n-type macro_def = {ident: str, ext: syntax_extension};\n+type macro_def = {ident: istr, ext: syntax_extension};\n type macro_definer =\n     fn(&ext_ctxt, span, @ast::expr, &option::t<istr>) -> macro_def;\n \n@@ -36,9 +36,9 @@ fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n }\n \n obj ext_ctxt(sess: @session,\n-             crate_file_name_hack: str,\n+             crate_file_name_hack: istr,\n              mutable backtrace: codemap::opt_span) {\n-    fn crate_file_name() -> str { ret crate_file_name_hack; }\n+    fn crate_file_name() -> istr { ret crate_file_name_hack; }\n \n     fn session() -> @session { ret sess; }\n \n@@ -58,29 +58,29 @@ obj ext_ctxt(sess: @session,\n             let tmp = pre;\n             backtrace = tmp;\n           }\n-          _ { self.bug(\"tried to pop without a push\"); }\n+          _ { self.bug(~\"tried to pop without a push\"); }\n         }\n     }\n \n-    fn span_fatal(sp: span, msg: str) -> ! {\n+    fn span_fatal(sp: span, msg: istr) -> ! {\n         self.print_backtrace();\n-        sess.span_fatal(sp, istr::from_estr(msg));\n+        sess.span_fatal(sp, msg);\n     }\n-    fn span_err(sp: span, msg: str) {\n+    fn span_err(sp: span, msg: istr) {\n         self.print_backtrace();\n-        sess.span_err(sp, istr::from_estr(msg));\n+        sess.span_err(sp, msg);\n     }\n-    fn span_unimpl(sp: span, msg: str) -> ! {\n+    fn span_unimpl(sp: span, msg: istr) -> ! {\n         self.print_backtrace();\n-        sess.span_unimpl(sp, istr::from_estr(msg));\n+        sess.span_unimpl(sp, msg);\n     }\n-    fn span_bug(sp: span, msg: str) -> ! {\n+    fn span_bug(sp: span, msg: istr) -> ! {\n         self.print_backtrace();\n-        sess.span_bug(sp, istr::from_estr(msg));\n+        sess.span_bug(sp, msg);\n     }\n-    fn bug(msg: str) -> ! {\n+    fn bug(msg: istr) -> ! {\n         self.print_backtrace();\n-        sess.bug(istr::from_estr(msg));\n+        sess.bug(msg);\n     }\n     fn next_id() -> ast::node_id { ret sess.next_node_id(); }\n \n@@ -96,23 +96,24 @@ fn mk_ctxt(sess: &session) -> ext_ctxt {\n     // super-ugly and needs a better solution.\n     let crate_file_name_hack = sess.get_codemap().files[0].name;\n \n-    ret ext_ctxt(@sess, istr::to_estr(crate_file_name_hack),\n+    ret ext_ctxt(@sess, crate_file_name_hack,\n                  codemap::os_none);\n }\n \n-fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: str) -> str {\n+fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &istr) -> istr {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n-          ast::lit_str(s, _) { ret istr::to_estr(s); }\n+          ast::lit_str(s, _) { ret s; }\n           _ { cx.span_fatal(l.span, error); }\n         }\n       }\n       _ { cx.span_fatal(expr.span, error); }\n     }\n }\n \n-fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n+fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr,\n+                 error: &istr) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n         if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {"}, {"sha": "f5ce004ea00a1b7abce87ee2ce547636aa1a423c", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -8,12 +8,12 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, \"#concat_idents requires a vector argument .\")\n+            cx.span_fatal(sp, ~\"#concat_idents requires a vector argument .\")\n           }\n         };\n     let res: ast::ident = ~\"\";\n     for e: @ast::expr in args {\n-        res += expr_to_ident(cx, e, \"expected an ident\");\n+        res += expr_to_ident(cx, e, ~\"expected an ident\");\n     }\n \n     ret @{id: cx.next_id(),"}, {"sha": "a183e8f3455390c4f2e7320525f56ea249ca8b7e", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -17,17 +17,17 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\")\n+            cx.span_fatal(sp, ~\"#env requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) != 1u {\n-        cx.span_fatal(sp, \"malformed #env call\");\n+        cx.span_fatal(sp, ~\"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args[0], \"#env requires a string\");\n-    alt generic_os::getenv(istr::from_estr(var)) {\n+    let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n+    alt generic_os::getenv(var) {\n       option::none. { ret make_new_str(cx, sp, \"\"); }\n       option::some(s) {\n         ret make_new_str(cx, sp, istr::to_estr(s));"}, {"sha": "c8bf5cfa495d6d8dfaa320741a7180fa4fb5edcc", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -26,9 +26,9 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                 let extname = pth.node.idents[0];\n                 alt exts.find(extname) {\n                   none. {\n-                    cx.span_fatal(pth.span,\n+                    cx.span_fatal(pth.span, istr::from_estr(\n                                   #fmt[\"macro undefined: '%s'\",\n-                                       istr::to_estr(extname)])\n+                                       istr::to_estr(extname)]))\n                   }\n                   some(normal(ext)) {\n                     let expanded = ext(cx, pth.span, args, body);\n@@ -43,13 +43,13 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n                     exts.insert(\n-                        istr::from_estr(named_extension.ident),\n+                        named_extension.ident,\n                         named_extension.ext);\n                     ast::expr_rec([], none)\n                   }\n                 }\n               }\n-              _ { cx.span_bug(mac.span, \"naked syntactic bit\") }\n+              _ { cx.span_bug(mac.span, ~\"naked syntactic bit\") }\n             }\n           }\n           _ { orig(e, fld) }"}, {"sha": "1bdd819d7086944610fa8a47740c9ebca7bff6f7", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -22,23 +22,24 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\")\n+            cx.span_fatal(sp, ~\"#fmt requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, \"#fmt requires a format string\");\n+        cx.span_fatal(sp, ~\"#fmt requires a format string\");\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    \"first argument to #fmt must be a \" + \"string literal.\");\n+                    ~\"first argument to #fmt must be a \"\n+                    + ~\"string literal.\");\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n     log fmt;\n     fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: str) -> ! {\n-        cx.span_fatal(sp, msg);\n+        cx.span_fatal(sp, istr::from_estr(msg));\n     }\n     let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n-    let pieces = parse_fmt_string(fmt, parse_fmt_err);\n+    let pieces = parse_fmt_string(istr::to_estr(fmt), parse_fmt_err);\n     ret pieces_to_expr(cx, sp, pieces, args);\n }\n \n@@ -102,7 +103,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n         fn compiling_std(cx: &ext_ctxt) -> bool {\n-            ret str::find(cx.crate_file_name(), \"std.rc\") >= 0;\n+            ret istr::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n             ret [~\"extfmt\", ~\"rt\", ident];\n@@ -149,7 +150,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n+              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n@@ -203,7 +204,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { ret false; }\n             }\n         }\n-        let unsupported = \"conversion not supported in #fmt string\";\n+        let unsupported = ~\"conversion not supported in #fmt string\";\n         alt cnv.param {\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -214,15 +215,15 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               flag_sign_always. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  \"+ flag only valid in \" +\n-                                      \"signed #fmt conversion\");\n+                                  ~\"+ flag only valid in \" +\n+                                      ~\"signed #fmt conversion\");\n                 }\n               }\n               flag_space_for_sign. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  \"space flag only valid in \" +\n-                                      \"signed #fmt conversions\");\n+                                  ~\"space flag only valid in \" +\n+                                      ~\"signed #fmt conversions\");\n                 }\n               }\n               flag_left_zero_pad. { }\n@@ -330,8 +331,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              \"not enough arguments to #fmt \" +\n-                                  \"for the given format string\");\n+                              ~\"not enough arguments to #fmt \" +\n+                                  ~\"for the given format string\");\n             }\n             log \"Building conversion:\";\n             log_conv(conv);\n@@ -345,9 +346,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n \n     if expected_nargs < nargs {\n         cx.span_fatal(\n-            sp,\n+            sp, istr::from_estr(\n             #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                 nargs, expected_nargs]);\n+                 nargs, expected_nargs]));\n     }\n     ret tmp_expr;\n }"}, {"sha": "298fef31ec5e6f8e176519eb4369b3f665141975", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -10,16 +10,16 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\")\n+            cx.span_fatal(sp, ~\"#ident_to_str requires a vector argument .\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) != 1u {\n-        cx.span_fatal(sp, \"malformed #ident_to_str call\");\n+        cx.span_fatal(sp, ~\"malformed #ident_to_str call\");\n     }\n \n     ret make_new_lit(cx, sp,\n                      ast::lit_str(expr_to_ident(cx, args[0u],\n-                                                \"expected an ident\"),\n+                                                ~\"expected an ident\"),\n                                   ast::sk_rc));\n \n }"}, {"sha": "247b5aee150f327683e1d2a711c9907d6f6d6fe3", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "patch": "@@ -58,28 +58,29 @@ tag matchable {\n \n /* for when given an incompatible bit of AST */\n fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n+    let expected = istr::from_estr(expected);\n     alt m {\n       match_expr(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is an expr, expected \" + expected);\n+                      ~\"this argument is an expr, expected \" + expected);\n       }\n       match_path(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a path, expected \" + expected);\n+                      ~\"this argument is a path, expected \" + expected);\n       }\n       match_ident(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is an ident, expected \" + expected);\n+                      ~\"this argument is an ident, expected \" + expected);\n       }\n       match_ty(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a type, expected \" + expected);\n+                      ~\"this argument is a type, expected \" + expected);\n       }\n       match_block(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a block, expected \" + expected);\n+                      ~\"this argument is a block, expected \" + expected);\n       }\n-      match_exact. { cx.bug(\"what is a match_exact doing in a bindings?\"); }\n+      match_exact. { cx.bug(~\"what is a match_exact doing in a bindings?\"); }\n     }\n }\n \n@@ -102,7 +103,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr]) ->\n             alt m.node {\n               ast::mac_ellipsis. {\n                 if res != none {\n-                    cx.span_fatal(m.span, \"only one ellipsis allowed\");\n+                    cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n                     some({pre: vec::slice(elts, 0u, idx - 1u),\n@@ -252,8 +253,8 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n         ret alt follow(m, idx_path) {\n               seq(_, sp) {\n                 cx.span_fatal(sp,\n-                              \"syntax matched under ... but not \" +\n-                                  \"used that way.\")\n+                              ~\"syntax matched under ... but not \" +\n+                                  ~\"used that way.\")\n               }\n               leaf(m) { ret some(m) }\n             }\n@@ -314,7 +315,8 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                                     #fmt[\"'%s' occurs %u times\",\n                                          istr::to_estr(old_name),\n                                          old_len];\n-                            cx.span_fatal(repeat_me.span, msg);\n+                            cx.span_fatal(\n+                                repeat_me.span, istr::from_estr(msg));\n                         }\n                       }\n                     }\n@@ -324,8 +326,8 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             alt repeat {\n               none. {\n                 cx.span_fatal(repeat_me.span,\n-                              \"'...' surrounds an expression without any\" +\n-                                  \" repeating syntax variables\");\n+                              ~\"'...' surrounds an expression without any\" +\n+                                  ~\" repeating syntax variables\");\n               }\n               some({rep_count: rc, _}) {\n                 /* Whew, we now know how how many times to repeat */\n@@ -468,12 +470,12 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n \n                 if vec::len(post) > 0u {\n                     cx.span_unimpl(e.span,\n-                                   \"matching after `...` not yet supported\");\n+                                   ~\"matching after `...` not yet supported\");\n                 }\n               }\n               {pre: pre, rep: none., post: post} {\n                 if post != [] {\n-                    cx.bug(\"elts_to_ell provided an invalid result\");\n+                    cx.bug(~\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);\n                 p_t_s_r_actual_vector(cx, pre, false, s, b);\n@@ -493,7 +495,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n                       match_expr(e) {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n-                      _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                      _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                     }\n             }\n             b.literal_ast_matchers += [bind select(cx, _, e)];\n@@ -529,11 +531,11 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n         fn select(cx: &ext_ctxt, m: &matchable) -> match_result {\n             ret alt m {\n                   match_expr(e) { some(leaf(specialize_match(m))) }\n-                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         if b.real_binders.contains_key(p_id) {\n-            cx.span_fatal(p.span, \"duplicate binding identifier\");\n+            cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n         }\n         b.real_binders.insert(p_id,\n                               compose_sels(s, bind select(cx, _)));\n@@ -559,14 +561,15 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n               }\n-              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n             }\n     }\n     fn no_des(cx: &ext_ctxt, sp: &span, syn: &str) -> ! {\n-        cx.span_fatal(sp, \"destructuring \" + syn + \" is not yet supported\");\n+        cx.span_fatal(sp, ~\"destructuring \"\n+                      + istr::from_estr(syn) + ~\" is not yet supported\");\n     }\n     alt mac.node {\n-      ast::mac_ellipsis. { cx.span_fatal(mac.span, \"misused `...`\"); }\n+      ast::mac_ellipsis. { cx.span_fatal(mac.span, ~\"misused `...`\"); }\n       ast::mac_invoc(_, _, _) { no_des(cx, mac.span, \"macro calls\"); }\n       ast::mac_embed_type(ty) {\n         alt ty.node {\n@@ -633,7 +636,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                   _ { none }\n                 }\n               }\n-              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n@@ -678,7 +681,7 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n                       _ { none }\n                     }\n                   }\n-                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n@@ -694,7 +697,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n           ast::expr_vec(elts, _) { elts }\n           _ {\n             cx.span_fatal(sp,\n-                          \"#macro requires arguments of the form `[...]`.\")\n+                          ~\"#macro requires arguments of the form `[...]`.\")\n           }\n         };\n \n@@ -705,8 +708,8 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n           expr_vec(elts, mut) {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n-                              \"extension clause must consist of [\" +\n-                                  \"macro invocation, expansion body]\");\n+                              ~\"extension clause must consist of [\" +\n+                                  ~\"macro invocation, expansion body]\");\n             }\n \n \n@@ -721,15 +724,15 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                           some(other_id) {\n                             if id != other_id {\n                                 cx.span_fatal(pth.span,\n-                                              \"macro name must be \" +\n-                                                  \"consistent\");\n+                                              ~\"macro name must be \" +\n+                                                  ~\"consistent\");\n                             }\n                           }\n                         }\n                       }\n                       none. {\n                         cx.span_fatal(pth.span,\n-                                      \"macro name must not be a path\");\n+                                      ~\"macro name must not be a path\");\n                       }\n                     }\n                     clauses +=\n@@ -742,14 +745,14 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n               }\n               _ {\n                 cx.span_fatal(elts[0u].span,\n-                              \"extension clause must\" +\n-                                  \" start with a macro invocation.\");\n+                              ~\"extension clause must\" +\n+                                  ~\" start with a macro invocation.\");\n               }\n             }\n           }\n           _ {\n             cx.span_fatal((*arg).span,\n-                          \"extension must be [clause, \" + \" ...]\");\n+                          ~\"extension must be [clause, \" + ~\" ...]\");\n           }\n         }\n     }\n@@ -758,11 +761,11 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n \n     ret {ident:\n              alt macro_name {\n-               some(id) { istr::to_estr(id) }\n+               some(id) { id }\n                none. {\n                  cx.span_fatal(sp,\n-                               \"macro definition must have \" +\n-                                   \"at least one clause\")\n+                               ~\"macro definition must have \" +\n+                                   ~\"at least one clause\")\n                }\n              },\n          ext: normal(ext)};\n@@ -776,7 +779,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n               none. { cont; }\n             }\n         }\n-        cx.span_fatal(sp, \"no clauses match macro invocation\");\n+        cx.span_fatal(sp, ~\"no clauses match macro invocation\");\n     }\n }\n "}]}