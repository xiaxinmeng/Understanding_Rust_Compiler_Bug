{"sha": "80fe467ce864de077d2f5a4e29e1a4d5fe535dc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZmU0NjdjZTg2NGRlMDc3ZDJmNWE0ZTI5ZTFhNGQ1ZmU1MzVkYzM=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-11-19T16:12:48Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-11-19T16:12:48Z"}, "message": "Improve insert_whitespaces", "tree": {"sha": "d6006c6c852ef28471b9c023324775ff3b5642c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6006c6c852ef28471b9c023324775ff3b5642c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3", "html_url": "https://github.com/rust-lang/rust/commit/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4012da07fd22223660a21c65d54d10a9a632eda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4012da07fd22223660a21c65d54d10a9a632eda0", "html_url": "https://github.com/rust-lang/rust/commit/4012da07fd22223660a21c65d54d10a9a632eda0"}], "stats": {"total": 94, "additions": 77, "deletions": 17}, "files": [{"sha": "07a7c738a14b8497f22ae0e8429a2277ee66b7e6", "filename": "crates/ra_ide_api/src/expand_macro.rs", "status": "modified", "additions": 77, "deletions": 17, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe467ce864de077d2f5a4e29e1a4d5fe535dc3/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs?ref=80fe467ce864de077d2f5a4e29e1a4d5fe535dc3", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use ra_syntax::{\n     algo::{find_node_at_offset, replace_descendants},\n     ast::{self},\n-    AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent,\n+    AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T,\n };\n \n pub struct ExpandedMacro {\n@@ -55,9 +55,12 @@ fn expand_macro_recur(\n     Some(replace_descendants(&expanded, &replaces))\n }\n \n+// FIXME: It would also be cool to share logic here and in the mbe tests,\n+// which are pretty unreadable at the moment.\n fn insert_whitespaces(syn: SyntaxNode) -> String {\n-    let mut res = String::new();\n+    use SyntaxKind::*;\n \n+    let mut res = String::new();\n     let mut token_iter = syn\n         .preorder_with_tokens()\n         .filter_map(|event| {\n@@ -69,36 +72,63 @@ fn insert_whitespaces(syn: SyntaxNode) -> String {\n         })\n         .peekable();\n \n+    let mut indent = 0;\n+    let mut last: Option<SyntaxKind> = None;\n+\n     while let Some(token) = token_iter.next() {\n-        res += &token.text().to_string();\n-        if token.kind().is_keyword()\n-            || token.kind().is_literal()\n-            || token.kind() == SyntaxKind::IDENT\n-        {\n-            if !token_iter.peek().map(|it| it.kind().is_punct()).unwrap_or(false) {\n-                res += \" \";\n+        let mut is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            token_iter.peek().map(|it| f(it.kind())).unwrap_or(default)\n+        };\n+        let is_last = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            last.map(|it| f(it)).unwrap_or(default)\n+        };\n+\n+        res += &match token.kind() {\n+            k @ _\n+                if (k.is_keyword() || k.is_literal() || k == IDENT)\n+                    && is_next(|it| !it.is_punct(), true) =>\n+            {\n+                token.text().to_string() + \" \"\n             }\n-        }\n+            L_CURLY if is_next(|it| it != R_CURLY, true) => {\n+                indent += 1;\n+                format!(\" {{\\n{}\", \"  \".repeat(indent))\n+            }\n+            R_CURLY if is_last(|it| it != L_CURLY, true) => {\n+                indent = indent.checked_sub(1).unwrap_or(0);\n+                format!(\"\\n}}{}\", \"  \".repeat(indent))\n+            }\n+            R_CURLY => {\n+                indent = indent.checked_sub(1).unwrap_or(0);\n+                format!(\"}}\\n{}\", \"  \".repeat(indent))\n+            }\n+            T![;] => format!(\";\\n{}\", \"  \".repeat(indent)),\n+            T![->] => \" -> \".to_string(),\n+            T![=] => \" = \".to_string(),\n+            T![=>] => \" => \".to_string(),\n+            _ => token.text().to_string(),\n+        };\n+\n+        last = Some(token.kind());\n     }\n \n     res\n }\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n     use crate::mock_analysis::analysis_and_position;\n+    use insta::assert_snapshot;\n \n-    fn check_expand_macro(fixture: &str, expected: (&str, &str)) {\n+    fn check_expand_macro(fixture: &str) -> ExpandedMacro {\n         let (analysis, pos) = analysis_and_position(fixture);\n-\n-        let result = analysis.expand_macro(pos).unwrap().unwrap();\n-        assert_eq!(result.name, expected.0.to_string());\n-        assert_eq!(result.expansion, expected.1.to_string());\n+        analysis.expand_macro(pos).unwrap().unwrap()\n     }\n \n     #[test]\n     fn macro_expand_recursive_expansion() {\n-        check_expand_macro(\n+        let res = check_expand_macro(\n             r#\"\n         //- /lib.rs\n         macro_rules! bar {\n@@ -112,7 +142,37 @@ mod tests {\n         }        \n         f<|>oo!();\n         \"#,\n-            (\"foo\", \"fn b(){}\"),\n         );\n+\n+        assert_eq!(res.name, \"foo\");\n+        assert_snapshot!(res.expansion, @r###\"\n+fn b(){}\n+\"###);\n+    }\n+\n+    #[test]\n+    fn macro_expand_multiple_lines() {\n+        let res = check_expand_macro(\n+            r#\"\n+        //- /lib.rs\n+        macro_rules! foo {\n+            () => { \n+                fn some_thing() -> u32 {\n+                    let a = 0;\n+                    a + 10\n+                }\n+            }\n+        }\n+        f<|>oo!();\n+        \"#,\n+        );\n+\n+        assert_eq!(res.name, \"foo\");\n+        assert_snapshot!(res.expansion, @r###\"\n+fn some_thing() -> u32 {\n+  let a = 0;\n+  a+10\n+}        \n+\"###);\n     }\n }"}]}