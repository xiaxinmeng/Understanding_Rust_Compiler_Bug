{"sha": "9a140454ea47b7fd107b6e963b7ea2aef74e9518", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMTQwNDU0ZWE0N2I3ZmQxMDdiNmU5NjNiN2VhMmFlZjc0ZTk1MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T15:47:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T15:47:53Z"}, "message": "Auto merge of #33476 - nikomatsakis:incr-comp-xcrate, r=mw\n\ntrack incr. comp. dependencies across crates\n\nThis PR refactors the compiler's incremental compilation hashing so that it can track dependencies across crates. The main bits are:\n\n- computing a hash representing the metadata for an item we are emitting\n  - we do this by making `MetaData(X)` be the current task while computing metadata for an item\n  - this naturally registers reads from any tables and things that we read for that purpose\n  - we can then hash all the inputs to those tables\n- tracking when we access metadata\n  - we do this by registering a read of `MetaData(X)` for each foreign item `X` whose metadata we read\n- hashing metadata from foreign items\n  - we do this by loading up metadata from a file in the incr. comp. directory\n  - if there is no file, we use the SVH for the entire crate\n\nThere is one very simple test only at this point. The next PR will be focused on expanding out the tests.\n\nNote that this is based on top of https://github.com/rust-lang/rust/pull/33228\n\nr? @michaelwoerister", "tree": {"sha": "9f792544e0cef474b45be01fe69ec9c945be45a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f792544e0cef474b45be01fe69ec9c945be45a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a140454ea47b7fd107b6e963b7ea2aef74e9518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a140454ea47b7fd107b6e963b7ea2aef74e9518", "html_url": "https://github.com/rust-lang/rust/commit/9a140454ea47b7fd107b6e963b7ea2aef74e9518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a140454ea47b7fd107b6e963b7ea2aef74e9518/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "html_url": "https://github.com/rust-lang/rust/commit/9743c661b0e768997cf4af1c8da8d5838e1c2c2f"}, {"sha": "f860f8b7c9bf32137f5bd929e88925debbcc0b2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f860f8b7c9bf32137f5bd929e88925debbcc0b2c", "html_url": "https://github.com/rust-lang/rust/commit/f860f8b7c9bf32137f5bd929e88925debbcc0b2c"}], "stats": {"total": 1407, "additions": 1037, "deletions": 370}, "files": [{"sha": "d06f51073df06f359567595d036b48d93ce1b1c4", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -64,7 +64,7 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry)\n+        self.graph.depth_traverse(self.entry, graph::OUTGOING)\n                   .any(|idx| self.graph.node_data(idx).id() == id)\n     }\n }"}, {"sha": "15b0380374c6946208672e9049927a46557610ce", "filename": "src/librustc/dep_graph/debug.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for debugging the dep-graph.\n+\n+use super::dep_node::DepNode;\n+use std::error::Error;\n+use std::fmt::Debug;\n+\n+/// A dep-node filter goes from a user-defined string to a query over\n+/// nodes. Right now the format is like this:\n+///\n+///     x & y & z\n+///\n+/// where the format-string of the dep-node must contain `x`, `y`, and\n+/// `z`.\n+#[derive(Debug)]\n+pub struct DepNodeFilter {\n+    text: String\n+}\n+\n+impl DepNodeFilter {\n+    pub fn new(text: &str) -> Self {\n+        DepNodeFilter {\n+            text: text.trim().to_string()\n+        }\n+    }\n+\n+    /// True if all nodes always pass the filter.\n+    pub fn accepts_all(&self) -> bool {\n+        self.text.is_empty()\n+    }\n+\n+    /// Tests whether `node` meets the filter, returning true if so.\n+    pub fn test<D: Clone + Debug>(&self, node: &DepNode<D>) -> bool {\n+        let debug_str = format!(\"{:?}\", node);\n+        self.text.split(\"&\")\n+                 .map(|s| s.trim())\n+                 .all(|f| debug_str.contains(f))\n+    }\n+}\n+\n+/// A filter like `F -> G` where `F` and `G` are valid dep-node\n+/// filters. This can be used to test the source/target independently.\n+pub struct EdgeFilter {\n+    pub source: DepNodeFilter,\n+    pub target: DepNodeFilter,\n+}\n+\n+impl EdgeFilter {\n+    pub fn new(test: &str) -> Result<EdgeFilter, Box<Error>> {\n+        let parts: Vec<_> = test.split(\"->\").collect();\n+        if parts.len() != 2 {\n+            Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())\n+        } else {\n+            Ok(EdgeFilter {\n+                source: DepNodeFilter::new(parts[0]),\n+                target: DepNodeFilter::new(parts[1]),\n+            })\n+        }\n+    }\n+}"}, {"sha": "84c84a7ed57a2656af76de3a0a0428d53c0d10f3", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -32,6 +32,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // Represents the HIR node with the given node-id\n     Hir(D),\n \n+    // Represents the metadata for a given HIR node, typically found\n+    // in an extern crate.\n+    MetaData(D),\n+\n     // Represents different phases in the compiler.\n     CrateReader,\n     CollectLanguageItems,\n@@ -77,6 +81,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TransCrateItem(D),\n     TransInlinedItem(D),\n     TransWriteMetadata,\n+    LinkBinary,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n@@ -174,7 +179,9 @@ impl<D: Clone + Debug> DepNode<D> {\n             LateLintCheck => Some(LateLintCheck),\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n+            LinkBinary => Some(LinkBinary),\n             Hir(ref d) => op(d).map(Hir),\n+            MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),"}, {"sha": "e65f6bbcf7aab672acdf3028b794582cf6180450", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod debug;\n mod dep_node;\n mod dep_tracking_map;\n mod edges;\n@@ -22,3 +23,4 @@ pub use self::dep_node::DepNode;\n pub use self::graph::DepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::visit::visit_all_items_in_krate;\n+pub use self::raii::DepTask;"}, {"sha": "93248edb197c625e9f4fec25559171ff4245ece5", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc_data_structures::graph::{Graph, NodeIndex};\n+use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n use std::fmt::Debug;\n use std::hash::Hash;\n \n@@ -63,20 +63,29 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n                   .collect()\n     }\n \n-    /// All nodes reachable from `node`. In other words, things that\n-    /// will have to be recomputed if `node` changes.\n-    pub fn transitive_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    fn reachable_nodes(&self, node: DepNode<D>, direction: Direction) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n-            self.graph.depth_traverse(index)\n+            self.graph.depth_traverse(index, direction)\n                       .map(|s| self.graph.node_data(s).clone())\n                       .collect()\n         } else {\n             vec![]\n         }\n     }\n \n+    /// All nodes reachable from `node`. In other words, things that\n+    /// will have to be recomputed if `node` changes.\n+    pub fn transitive_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        self.reachable_nodes(node, OUTGOING)\n+    }\n+\n+    /// All nodes that can reach `node`.\n+    pub fn transitive_predecessors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        self.reachable_nodes(node, INCOMING)\n+    }\n+\n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn immediate_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n                       .map(|s| self.graph.node_data(s).clone())"}, {"sha": "70d0a4e315c3743501a9e2a1afc43c9baf5b6449", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -28,6 +28,7 @@ use super::DepGraphQuery;\n use super::DepNode;\n use super::edges::DepGraphEdges;\n \n+#[derive(Debug)]\n pub enum DepMessage {\n     Read(DepNode<DefId>),\n     Write(DepNode<DefId>),\n@@ -117,6 +118,8 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n+        debug!(\"enqueue: {:?} tasks_pushed={}\", message, self.tasks_pushed.get());\n+\n         // Regardless of whether dep graph construction is enabled, we\n         // still want to check that we always have a valid task on the\n         // stack when a read/write/etc event occurs."}, {"sha": "9133b4d22eeb2ec0693757d90045b6f8e0140817", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -42,7 +42,8 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let _task = self.tcx.dep_graph.in_task(task_id);\n             debug!(\"Started task {:?}\", task_id);\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i)\n+            self.visitor.visit_item(i);\n+            debug!(\"Ended task {:?}\", task_id);\n         }\n     }\n "}, {"sha": "ba655b35eda151f75c209d3aa3323d8e3a922778", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -45,6 +45,7 @@ use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n+use session::Session;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -97,8 +98,16 @@ impl Resolver for DummyResolver {\n     }\n }\n \n-pub fn lower_crate(krate: &Crate, id_assigner: &NodeIdAssigner, resolver: &mut Resolver)\n+pub fn lower_crate(sess: &Session,\n+                   krate: &Crate,\n+                   id_assigner: &NodeIdAssigner,\n+                   resolver: &mut Resolver)\n                    -> hir::Crate {\n+    // We're constructing the HIR here; we don't care what we will\n+    // read, since we haven't even constructed the *input* to\n+    // incr. comp. yet.\n+    let _ignore = sess.dep_graph.in_ignore();\n+\n     LoweringContext {\n         crate_root: if std_inject::no_core(krate) {\n             None"}, {"sha": "457511cdbc3b17057283d670b8df41f2f84b6946", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -82,8 +82,10 @@ impl DefPath {\n         let mut data = vec![];\n         let mut index = Some(start_index);\n         loop {\n+            debug!(\"DefPath::make: krate={:?} index={:?}\", krate, index);\n             let p = index.unwrap();\n             let key = get_key(p);\n+            debug!(\"DefPath::make: key={:?}\", key);\n             match key.disambiguated_data.data {\n                 DefPathData::CrateRoot => {\n                     assert!(key.parent.is_none());\n@@ -178,6 +180,10 @@ impl Definitions {\n         self.data[index.as_usize()].key.clone()\n     }\n \n+    pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n+        self.key_map.get(&key).cloned()\n+    }\n+\n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this\n@@ -208,37 +214,6 @@ impl Definitions {\n         }\n     }\n \n-    pub fn retrace_path(&self, path: &DefPath) -> Option<DefIndex> {\n-        debug!(\"retrace_path(path={:?})\", path);\n-\n-        // we assume that we only want to retrace paths relative to\n-        // the crate root\n-        assert!(path.is_local());\n-\n-        let root_key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n-        let root_id = self.key_map[&root_key];\n-\n-        debug!(\"retrace_path: root_id={:?}\", root_id);\n-\n-        let mut id = root_id;\n-        for data in &path.data {\n-            let key = DefKey { parent: Some(id), disambiguated_data: data.clone() };\n-            debug!(\"key = {:?}\", key);\n-            id = match self.key_map.get(&key) {\n-                Some(&id) => id,\n-                None => return None\n-            };\n-        }\n-\n-        Some(id)\n-    }\n-\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,"}, {"sha": "2f310806a7420fa068b4d71ffeec5f661627d415", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -19,7 +19,7 @@ use dep_graph::{DepGraph, DepNode};\n \n use middle::cstore::InlinedItem;\n use middle::cstore::InlinedItem as II;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n@@ -160,10 +160,10 @@ pub struct Forest {\n }\n \n impl Forest {\n-    pub fn new(krate: Crate, dep_graph: DepGraph) -> Forest {\n+    pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n         Forest {\n             krate: krate,\n-            dep_graph: dep_graph,\n+            dep_graph: dep_graph.clone(),\n             inlined_items: TypedArena::new()\n         }\n     }\n@@ -285,9 +285,8 @@ impl<'ast> Map<'ast> {\n         self.definitions.borrow().def_path(def_id.index)\n     }\n \n-    pub fn retrace_path(&self, path: &DefPath) -> Option<DefId> {\n-        self.definitions.borrow().retrace_path(path)\n-                                 .map(DefId::local)\n+    pub fn def_index_for_def_key(&self, def_key: DefKey) -> Option<DefIndex> {\n+        self.definitions.borrow().def_index_for_def_key(def_key)\n     }\n \n     pub fn local_def_id(&self, node: NodeId) -> DefId {"}, {"sha": "d4e797c9f2d25b758cea756355739c4be43158ee", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -10,78 +10,44 @@\n \n //! Calculation and management of a Strict Version Hash for crates\n //!\n-//! # Today's ABI problem\n-//!\n-//! In today's implementation of rustc, it is incredibly difficult to achieve\n-//! forward binary compatibility without resorting to C-like interfaces. Within\n-//! rust code itself, abi details such as symbol names suffer from a variety of\n-//! unrelated factors to code changing such as the \"def id drift\" problem. This\n-//! ends up yielding confusing error messages about metadata mismatches and\n-//! such.\n-//!\n-//! The core of this problem is when an upstream dependency changes and\n-//! downstream dependents are not recompiled. This causes compile errors because\n-//! the upstream crate's metadata has changed but the downstream crates are\n-//! still referencing the older crate's metadata.\n-//!\n-//! This problem exists for many reasons, the primary of which is that rust does\n-//! not currently support forwards ABI compatibility (in place upgrades of a\n-//! crate).\n-//!\n-//! # SVH and how it alleviates the problem\n-//!\n-//! With all of this knowledge on hand, this module contains the implementation\n-//! of a notion of a \"Strict Version Hash\" for a crate. This is essentially a\n-//! hash of all contents of a crate which can somehow be exposed to downstream\n-//! crates.\n-//!\n-//! This hash is currently calculated by just hashing the AST, but this is\n-//! obviously wrong (doc changes should not result in an incompatible ABI).\n-//! Implementation-wise, this is required at this moment in time.\n-//!\n-//! By encoding this strict version hash into all crate's metadata, stale crates\n-//! can be detected immediately and error'd about by rustc itself.\n-//!\n-//! # Relevant links\n-//!\n-//! Original issue: https://github.com/rust-lang/rust/issues/10207\n+//! The SVH is used for incremental compilation to track when HIR\n+//! nodes have changed between compilations, and also to detect\n+//! mismatches where we have two versions of the same crate that were\n+//! compiled from distinct sources.\n \n use std::fmt;\n+use std::hash::{Hash, Hasher};\n \n-#[derive(Clone, Eq, Hash, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct Svh {\n-    hash: String,\n+    hash: u64,\n }\n \n impl Svh {\n     /// Create a new `Svh` given the hash. If you actually want to\n     /// compute the SVH from some HIR, you want the `calculate_svh`\n-    /// function found in `librustc_trans`.\n-    pub fn new(hash: String) -> Svh {\n-        assert!(hash.len() == 16);\n+    /// function found in `librustc_incremental`.\n+    pub fn new(hash: u64) -> Svh {\n         Svh { hash: hash }\n     }\n \n-    pub fn from_hash(hash: u64) -> Svh {\n-        return Svh::new((0..64).step_by(4).map(|i| hex(hash >> i)).collect());\n+    pub fn as_u64(&self) -> u64 {\n+        self.hash\n+    }\n \n-        fn hex(b: u64) -> char {\n-            let b = (b & 0xf) as u8;\n-            let b = match b {\n-                0 ... 9 => '0' as u8 + b,\n-                _ => 'a' as u8 + b - 10,\n-            };\n-            b as char\n-        }\n+    pub fn to_string(&self) -> String {\n+        format!(\"{:016x}\", self.hash)\n     }\n+}\n \n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        &self.hash\n+impl Hash for Svh {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        self.hash.to_le().hash(state);\n     }\n }\n \n impl fmt::Display for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(self.as_str())\n+        f.pad(&self.to_string())\n     }\n }"}, {"sha": "5312d03052552817810dac087fd68b88602309c3", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -20,7 +20,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n-use rustc_data_structures::graph::{self, Direction, NodeIndex};\n+use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n@@ -872,7 +872,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let seeds: Vec<_> = givens.iter().cloned().collect();\n         for (fr, vid) in seeds {\n             let seed_index = NodeIndex(vid.index as usize);\n-            for succ_index in graph.depth_traverse(seed_index) {\n+            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0 as u32;\n                 if succ_index < self.num_vars() {\n                     let succ_vid = RegionVid { index: succ_index };"}, {"sha": "e1fb701e641bf1da7e977c3793da271588d08e5c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -37,7 +37,6 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n #![feature(question_mark)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "e5a8c1d1b4e6fe3542aee6b7446651c327c5bfcc", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -22,19 +22,19 @@\n // are *mostly* used as a part of that interface, but these should\n // probably get a better home if someone can find one.\n \n-use hir::svh::Svh;\n-use hir::map as hir_map;\n use hir::def::{self, Def};\n+use hir::def_id::{DefId, DefIndex};\n+use hir::map as hir_map;\n+use hir::map::definitions::DefKey;\n+use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt, VariantKind};\n-use hir::def_id::{DefId, DefIndex};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n-use std::any::Any;\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::path::PathBuf;\n@@ -150,12 +150,7 @@ pub struct ExternCrate {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n-///\n-/// The `: Any` bound is a temporary measure that allows access\n-/// to the backing `rustc_metadata::cstore::CStore` object. It\n-/// will be removed in the near future - if you need to access\n-/// internal APIs, please tell us.\n-pub trait CrateStore<'tcx> : Any {\n+pub trait CrateStore<'tcx> {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n@@ -240,6 +235,10 @@ pub trait CrateStore<'tcx> : Any {\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n \n     // resolve\n+    fn def_index_for_def_key(&self,\n+                             cnum: ast::CrateNum,\n+                             def: DefKey)\n+                             -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n@@ -367,6 +366,12 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                                   -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n+    fn def_index_for_def_key(&self,\n+                             cnum: ast::CrateNum,\n+                             def: DefKey)\n+                             -> Option<DefIndex> {\n+        None\n+    }\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>"}, {"sha": "7bb96c5ab2b44faf72d56981226673d47c36f1b6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -1420,6 +1420,7 @@ impl fmt::Display for CrateType {\n \n #[cfg(test)]\n mod tests {\n+    use dep_graph::DepGraph;\n     use middle::cstore::DummyCrateStore;\n     use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n@@ -1439,14 +1440,15 @@ mod tests {\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n+        let dep_graph = DepGraph::new(false);\n         let matches =\n             &match getopts(&[\"--test\".to_string()], &optgroups()) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None, registry, Rc::new(DummyCrateStore));\n+        let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n         assert!((attr::contains_name(&cfg[..], \"test\")));\n     }\n@@ -1455,6 +1457,7 @@ mod tests {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        let dep_graph = DepGraph::new(false);\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n                            &optgroups()) {\n@@ -1465,7 +1468,7 @@ mod tests {\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None, registry,\n+        let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n         let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n@@ -1475,13 +1478,14 @@ mod tests {\n \n     #[test]\n     fn test_can_print_warnings() {\n+        let dep_graph = DepGraph::new(false);\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry,\n+            let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(!sess.diagnostic().can_emit_warnings);\n         }\n@@ -1493,7 +1497,7 @@ mod tests {\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry,\n+            let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(sess.diagnostic().can_emit_warnings);\n         }\n@@ -1504,7 +1508,7 @@ mod tests {\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry,\n+            let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n             assert!(sess.diagnostic().can_emit_warnings);\n         }"}, {"sha": "907241d1746d6f7317310245dcb29cdaad7fad8f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepGraph;\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -49,6 +50,7 @@ pub mod search_paths;\n // Represents the data associated with a compilation\n // session for a single crate.\n pub struct Session {\n+    pub dep_graph: DepGraph,\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n@@ -408,18 +410,21 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n }\n \n pub fn build_session(sopts: config::Options,\n+                     dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n                      registry: diagnostics::registry::Registry,\n                      cstore: Rc<for<'a> CrateStore<'a>>)\n                      -> Session {\n     build_session_with_codemap(sopts,\n-                              local_crate_source_file,\n-                              registry,\n-                              cstore,\n-                              Rc::new(codemap::CodeMap::new()))\n+                               dep_graph,\n+                               local_crate_source_file,\n+                               registry,\n+                               cstore,\n+                               Rc::new(codemap::CodeMap::new()))\n }\n \n pub fn build_session_with_codemap(sopts: config::Options,\n+                                  dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: diagnostics::registry::Registry,\n                                   cstore: Rc<for<'a> CrateStore<'a>>,\n@@ -450,10 +455,16 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                                       treat_err_as_bug,\n                                       emitter);\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap, cstore)\n+    build_session_(sopts,\n+                   dep_graph,\n+                   local_crate_source_file,\n+                   diagnostic_handler,\n+                   codemap,\n+                   cstore)\n }\n \n pub fn build_session_(sopts: config::Options,\n+                      dep_graph: &DepGraph,\n                       local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: errors::Handler,\n                       codemap: Rc<codemap::CodeMap>,\n@@ -482,6 +493,7 @@ pub fn build_session_(sopts: config::Options,\n     );\n \n     let sess = Session {\n+        dep_graph: dep_graph.clone(),\n         target: target_cfg,\n         host: host,\n         opts: sopts,\n@@ -616,9 +628,9 @@ pub fn span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n }\n \n fn opt_span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n-                                          line: u32,\n-                                          span: Option<S>,\n-                                          args: fmt::Arguments) -> ! {\n+                                        line: u32,\n+                                        span: Option<S>,\n+                                        args: fmt::Arguments) -> ! {\n     tls::with_opt(move |tcx| {\n         let msg = format!(\"{}:{}: {}\", file, line, args);\n         match (tcx, span) {"}, {"sha": "45aa6f881e8e70652a1fc79dd716378ea263191a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -11,13 +11,14 @@\n //! type context book-keeping\n \n use dep_graph::{DepGraph, DepTrackingMap};\n-use hir::map as ast_map;\n use session::Session;\n use lint;\n use middle;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::DefMap;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex};\n+use hir::map as ast_map;\n+use hir::map::{DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n@@ -513,6 +514,49 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given a def-key `key` and a crate `krate`, finds the def-index\n+    /// that `krate` assigned to `key`. This `DefIndex` will always be\n+    /// relative to `krate`.\n+    ///\n+    /// Returns `None` if there is no `DefIndex` with that key.\n+    pub fn def_index_for_def_key(self, krate: ast::CrateNum, key: DefKey)\n+                                 -> Option<DefIndex> {\n+        if krate == LOCAL_CRATE {\n+            self.map.def_index_for_def_key(key)\n+        } else {\n+            self.sess.cstore.def_index_for_def_key(krate, key)\n+        }\n+    }\n+\n+    pub fn retrace_path(self, path: &DefPath) -> Option<DefId> {\n+        debug!(\"retrace_path(path={:?})\", path);\n+\n+        let root_key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+\n+        let root_index = self.def_index_for_def_key(path.krate, root_key)\n+                             .expect(\"no root key?\");\n+\n+        debug!(\"retrace_path: root_index={:?}\", root_index);\n+\n+        let mut index = root_index;\n+        for data in &path.data {\n+            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n+            debug!(\"retrace_path: key={:?}\", key);\n+            match self.def_index_for_def_key(path.krate, key) {\n+                Some(i) => index = i,\n+                None => return None,\n+            }\n+        }\n+\n+        Some(DefId { krate: path.krate, index: index })\n+    }\n+\n     pub fn type_parameter_def(self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>"}, {"sha": "4f6188ea3c51f5936006f79a9ae689e3f542047d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     tcx.sess.cstore.crate_hash(did.krate)\n                 };\n-                h.as_str().hash(state);\n+                h.hash(state);\n                 did.index.hash(state);\n             };\n             let mt = |state: &mut SipHasher, mt: TypeAndMut| {"}, {"sha": "731471b0600f3cfe635e813d997d6d5f3223bb52", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -292,11 +292,15 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         }\n     }\n \n-    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E> {\n+    pub fn depth_traverse<'a>(&'a self,\n+                              start: NodeIndex,\n+                              direction: Direction)\n+                              -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n             visited: BitVector::new(self.nodes.len()),\n+            direction: direction,\n         }\n     }\n }\n@@ -371,6 +375,7 @@ pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n     visited: BitVector,\n+    direction: Direction,\n }\n \n impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n@@ -382,9 +387,10 @@ impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n                 continue;\n             }\n \n-            for (_, edge) in self.graph.outgoing_edges(idx) {\n-                if !self.visited.contains(edge.target().node_id()) {\n-                    self.stack.push(edge.target());\n+            for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n+                let target = edge.source_or_target(self.direction);\n+                if !self.visited.contains(target.node_id()) {\n+                    self.stack.push(target);\n                 }\n             }\n "}, {"sha": "1d60c2eb43788b3d52217cbd02a4e42aa6ead598", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -152,7 +152,6 @@ pub fn compile_input(sess: &Session,\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n-        let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n \n         // Collect defintions for def ids.\n         let mut defs = time(sess.time_passes(),\n@@ -161,15 +160,15 @@ pub fn compile_input(sess: &Session,\n \n         time(sess.time_passes(),\n              \"external crate/lib resolution\",\n-             || read_local_crates(sess, &cstore, &defs, &expanded_crate, &id, &dep_graph));\n+             || read_local_crates(sess, &cstore, &defs, &expanded_crate, &id, &sess.dep_graph));\n \n         time(sess.time_passes(),\n              \"early lint checks\",\n              || lint::check_ast_crate(sess, &expanded_crate));\n \n         let (analysis, resolutions, mut hir_forest) = {\n-            lower_and_resolve(sess, &id, &mut defs, &expanded_crate, dep_graph,\n-                              control.make_glob_map)\n+            lower_and_resolve(sess, &id, &mut defs, &expanded_crate,\n+                              &sess.dep_graph, control.make_glob_map)\n         };\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n@@ -805,7 +804,7 @@ pub fn lower_and_resolve<'a>(sess: &Session,\n                              id: &'a str,\n                              defs: &mut hir_map::Definitions,\n                              krate: &ast::Crate,\n-                             dep_graph: DepGraph,\n+                             dep_graph: &DepGraph,\n                              make_glob_map: resolve::MakeGlobMap)\n                              -> (ty::CrateAnalysis<'a>, Resolutions, hir_map::Forest) {\n     resolve::with_resolver(sess, defs, make_glob_map, |mut resolver| {\n@@ -815,7 +814,7 @@ pub fn lower_and_resolve<'a>(sess: &Session,\n \n         // Lower ast -> hir.\n         let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n-            hir_map::Forest::new(lower_crate(krate, sess, &mut resolver), dep_graph)\n+            hir_map::Forest::new(lower_crate(sess, krate, sess, &mut resolver), dep_graph)\n         });\n \n         (ty::CrateAnalysis {"}, {"sha": "06133c508d9f027cfd97178c0c9b9de994031db0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -67,6 +67,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_trans::back::link;\n+use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::session::config::{get_unstable_features_setting, nightly_options};\n@@ -196,9 +197,11 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n         },\n     };\n \n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let dep_graph = DepGraph::new(sopts.build_dep_graph());\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n     let sess = session::build_session_with_codemap(sopts,\n+                                                   &dep_graph,\n                                                    input_file_path,\n                                                    descriptions,\n                                                    cstore.clone(),\n@@ -425,9 +428,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     describe_lints(&ls, false);\n                     return None;\n                 }\n-                let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-                let sess = build_session(sopts.clone(), None, descriptions.clone(),\n-                                         cstore.clone());\n+                let dep_graph = DepGraph::new(sopts.build_dep_graph());\n+                let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+                let sess = build_session(sopts.clone(),\n+                    &dep_graph,\n+                    None,\n+                    descriptions.clone(),\n+                    cstore.clone());\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let should_stop = RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n                 if should_stop == Compilation::Stop {"}, {"sha": "8c84e561e317a033704f4e7e40ce9d41ff69b0ba", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -18,10 +18,10 @@ use self::NodesMatchingUII::*;\n use abort_on_err;\n use driver::{self, Resolutions};\n \n-use rustc::dep_graph::DepGraph;\n use rustc::ty::{self, TyCtxt};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n+use rustc::dep_graph::DepGraph;\n use rustc::session::Session;\n use rustc::session::config::Input;\n use rustc_borrowck as borrowck;"}, {"sha": "e0d693c423096db41c145ab159494e080fdf760e", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -104,8 +104,10 @@ fn test_env<F>(source_string: &str,\n     options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = session::build_session_(options, None, diagnostic_handler,\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n                                        Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n@@ -117,15 +119,14 @@ fn test_env<F>(source_string: &str,\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n \n-    let dep_graph = DepGraph::new(false);\n     let krate = driver::assign_node_ids(&sess, krate);\n     let mut defs = hir_map::collect_definitions(&krate);\n     read_local_crates(&sess, &cstore, &defs, &krate, \"test_crate\", &dep_graph);\n     let _ignore = dep_graph.in_ignore();\n \n     let (_, resolutions, mut hir_forest) = {\n-        driver::lower_and_resolve(&sess, \"test-crate\", &mut defs, &krate, dep_graph.clone(),\n-                                  MakeGlobMap::No)\n+        driver::lower_and_resolve(&sess, \"test-crate\", &mut defs, &krate,\n+                                  &sess.dep_graph, MakeGlobMap::No)\n     };\n \n     let arenas = ty::CtxtArenas::new();"}, {"sha": "9dc50a6306406d8684afcab039c98331e75f4417", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -44,6 +44,7 @@\n \n use graphviz as dot;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n@@ -195,7 +196,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         for &(_, source_def_id, source_dep_node) in sources {\n-            let dependents = query.transitive_dependents(source_dep_node);\n+            let dependents = query.transitive_successors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n                     tcx.sess.span_err(\n@@ -220,12 +221,11 @@ fn dump_graph(tcx: TyCtxt) {\n     let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n         Ok(string) => {\n             // Expect one of: \"-> target\", \"source -> target\", or \"source ->\".\n-            let parts: Vec<_> = string.split(\"->\").collect();\n-            if parts.len() > 2 {\n-                bug!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n-            }\n-            let sources = node_set(&query, &parts[0]);\n-            let targets = node_set(&query, &parts[1]);\n+            let edge_filter = EdgeFilter::new(&string).unwrap_or_else(|e| {\n+                bug!(\"invalid filter: {}\", e)\n+            });\n+            let sources = node_set(&query, &edge_filter.source);\n+            let targets = node_set(&query, &edge_filter.target);\n             filter_nodes(&query, &sources, &targets)\n         }\n         Err(_) => {\n@@ -295,26 +295,16 @@ impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set(query: &DepGraphQuery<DefId>, filter: &str)\n+fn node_set(query: &DepGraphQuery<DefId>, filter: &DepNodeFilter)\n             -> Option<FnvHashSet<DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n-    if filter.trim().is_empty() {\n+    if filter.accepts_all() {\n         return None;\n     }\n \n-    let filters: Vec<&str> = filter.split(\"&\").map(|s| s.trim()).collect();\n-\n-    debug!(\"node_set: filters={:?}\", filters);\n-\n-    Some(query.nodes()\n-         .into_iter()\n-         .filter(|n| {\n-             let s = format!(\"{:?}\", n);\n-             filters.iter().all(|f| s.contains(f))\n-         })\n-        .collect())\n+    Some(query.nodes().into_iter().filter(|n| filter.test(n)).collect())\n }\n \n fn filter_nodes(query: &DepGraphQuery<DefId>,"}, {"sha": "24ecce1148745428ce56ba0feb22a4cd91e15ba3", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -72,12 +72,14 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n             attr.node.value.hash(&mut state);\n         }\n \n-        Svh::from_hash(state.finish())\n+        Svh::new(state.finish())\n     }\n \n     fn calculate_item_hash(self, def_id: DefId) -> u64 {\n         assert!(def_id.is_local());\n \n+        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n+\n         let mut state = SipHasher::new();\n \n         {\n@@ -89,11 +91,16 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n                 intravisit::walk_crate(&mut visit, krate);\n             } else {\n                 let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                visit.visit_item(self.map.expect_item(node_id));\n+                let item = self.map.expect_item(node_id);\n+                visit.visit_item(item);\n             }\n         }\n \n-        state.finish()\n+        let hash = state.finish();\n+\n+        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n+\n+        hash\n     }\n }\n "}, {"sha": "f57ab19a5256e397b1c4baca8e3a7661c0d26d5e", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -11,21 +11,80 @@\n //! The data that we will serialize and deserialize.\n \n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefIndex;\n \n use super::directory::DefPathIndex;\n \n+/// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n     pub nodes: Vec<DepNode<DefPathIndex>>,\n     pub edges: Vec<SerializedEdge>,\n+\n+    /// These are hashes of two things:\n+    /// - the HIR nodes in this crate\n+    /// - the metadata nodes from dependent crates we use\n+    ///\n+    /// In each case, we store a hash summarizing the contents of\n+    /// those items as they were at the time we did this compilation.\n+    /// In the case of HIR nodes, this hash is derived by walking the\n+    /// HIR itself. In the case of metadata nodes, the hash is loaded\n+    /// from saved state.\n+    ///\n+    /// When we do the next compile, we will load these back up and\n+    /// compare them against the hashes we see at that time, which\n+    /// will tell us what has changed, either in this crate or in some\n+    /// crate that we depend on.\n+    ///\n+    /// Because they will be reloaded, we don't store the DefId (which\n+    /// will be different when we next compile) related to each node,\n+    /// but rather the `DefPathIndex`. This can then be retraced\n+    /// to find the current def-id.\n     pub hashes: Vec<SerializedHash>,\n }\n \n pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {\n-    pub index: DefPathIndex,\n+    /// node being hashed; either a Hir or MetaData variant, in\n+    /// practice\n+    pub node: DepNode<DefPathIndex>,\n+\n+    /// the hash itself, computed by `calculate_item_hash`\n+    pub hash: u64,\n+}\n+\n+/// Data for use when downstream crates get recompiled.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedMetadataHashes {\n+    /// For each def-id defined in this crate that appears in the\n+    /// metadata, we hash all the inputs that were used when producing\n+    /// the metadata. We save this after compilation is done. Then,\n+    /// when some downstream crate is being recompiled, it can compare\n+    /// the hashes we saved against the hashes that it saw from\n+    /// before; this will tell it which of the items in this crate\n+    /// changed, which in turn implies what items in the downstream\n+    /// crate need to be recompiled.\n+    ///\n+    /// Note that we store the def-ids here. This is because we don't\n+    /// reload this file when we recompile this crate, we will just\n+    /// regenerate it completely with the current hashes and new def-ids.\n+    ///\n+    /// Then downstream creates will load up their\n+    /// `SerializedDepGraph`, which may contain `MetaData(X)` nodes\n+    /// where `X` refers to some item in this crate. That `X` will be\n+    /// a `DefPathIndex` that gets retracted to the current `DefId`\n+    /// (matching the one found in this structure).\n+    pub hashes: Vec<SerializedMetadataHash>,\n+}\n+\n+/// The hash for some metadata that (when saving) will be exported\n+/// from this crate, or which (when importing) was exported by an\n+/// upstream crate.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedMetadataHash {\n+    pub def_index: DefIndex,\n \n     /// the hash itself, computed by `calculate_item_hash`\n     pub hash: u64,"}, {"sha": "f9e90f393219dcc7d6462d16628a55d576e46004", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -41,7 +41,7 @@ impl DefIdDirectory {\n \n     pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n         let ids = self.paths.iter()\n-                            .map(|path| tcx.map.retrace_path(path))\n+                            .map(|path| tcx.retrace_path(path))\n                             .collect();\n         RetracedDefIdDirectory { ids: ids }\n     }\n@@ -64,7 +64,7 @@ impl RetracedDefIdDirectory {\n \n pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hash: DefIdMap<Option<DefPathIndex>>,\n+    hash: DefIdMap<DefPathIndex>,\n     directory: DefIdDirectory,\n }\n \n@@ -77,29 +77,22 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n         }\n     }\n \n-    pub fn add(&mut self, def_id: DefId) -> Option<DefPathIndex> {\n-        if !def_id.is_local() {\n-            // FIXME(#32015) clarify story about cross-crate dep tracking\n-            return None;\n-        }\n-\n+    pub fn add(&mut self, def_id: DefId) -> DefPathIndex {\n+        debug!(\"DefIdDirectoryBuilder: def_id={:?}\", def_id);\n         let tcx = self.tcx;\n         let paths = &mut self.directory.paths;\n         self.hash.entry(def_id)\n                  .or_insert_with(|| {\n                      let def_path = tcx.def_path(def_id);\n-                     if !def_path.is_local() {\n-                         return None;\n-                     }\n                      let index = paths.len() as u32;\n                      paths.push(def_path);\n-                     Some(DefPathIndex { index: index })\n+                     DefPathIndex { index: index }\n                  })\n                  .clone()\n     }\n \n-    pub fn map(&mut self, node: DepNode<DefId>) -> Option<DepNode<DefPathIndex>> {\n-        node.map_def(|&def_id| self.add(def_id))\n+    pub fn map(&mut self, node: DepNode<DefId>) -> DepNode<DefPathIndex> {\n+        node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }\n \n     pub fn into_directory(self) -> DefIdDirectory {"}, {"sha": "b729f25b873d4f05ec8df2b45e7239c4cb02fa7f", "filename": "src/librustc_incremental/persist/hash.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use calculate_svh::SvhCalculate;\n+use rbml::Error;\n+use rbml::opaque::Decoder;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::svh::Svh;\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_serialize::Decodable;\n+use std::io::{ErrorKind, Read};\n+use std::fs::File;\n+use syntax::ast;\n+\n+use super::data::*;\n+use super::util::*;\n+\n+pub struct HashContext<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item_metadata_hashes: FnvHashMap<DefId, u64>,\n+    crate_hashes: FnvHashMap<ast::CrateNum, Svh>,\n+}\n+\n+impl<'a, 'tcx> HashContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        HashContext {\n+            tcx: tcx,\n+            item_metadata_hashes: FnvHashMap(),\n+            crate_hashes: FnvHashMap(),\n+        }\n+    }\n+\n+    pub fn hash(&mut self, dep_node: DepNode<DefId>) -> Option<u64> {\n+        match dep_node {\n+            // HIR nodes (which always come from our crate) are an input:\n+            DepNode::Hir(def_id) => {\n+                assert!(def_id.is_local());\n+                Some(self.hir_hash(def_id))\n+            }\n+\n+            // MetaData from other crates is an *input* to us.\n+            // MetaData nodes from *our* crates are an *output*; we\n+            // don't hash them, but we do compute a hash for them and\n+            // save it for others to use.\n+            DepNode::MetaData(def_id) if !def_id.is_local() => {\n+                Some(self.metadata_hash(def_id))\n+            }\n+\n+            _ => {\n+                // Other kinds of nodes represent computed by-products\n+                // that we don't hash directly; instead, they should\n+                // have some transitive dependency on a Hir or\n+                // MetaData node, so we'll just hash that\n+                None\n+            }\n+        }\n+    }\n+\n+    fn hir_hash(&mut self, def_id: DefId) -> u64 {\n+        assert!(def_id.is_local());\n+        // FIXME(#32753) -- should we use a distinct hash here\n+        self.tcx.calculate_item_hash(def_id)\n+    }\n+\n+    fn metadata_hash(&mut self, def_id: DefId) -> u64 {\n+        debug!(\"metadata_hash(def_id={:?})\", def_id);\n+\n+        assert!(!def_id.is_local());\n+        loop {\n+            // check whether we have a result cached for this def-id\n+            if let Some(&hash) = self.item_metadata_hashes.get(&def_id) {\n+                debug!(\"metadata_hash: def_id={:?} hash={:?}\", def_id, hash);\n+                return hash;\n+            }\n+\n+            // check whether we did not find detailed metadata for this\n+            // krate; in that case, we just use the krate's overall hash\n+            if let Some(&hash) = self.crate_hashes.get(&def_id.krate) {\n+                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, hash);\n+\n+                // micro-\"optimization\": avoid a cache miss if we ask\n+                // for metadata from this particular def-id again.\n+                self.item_metadata_hashes.insert(def_id, hash.as_u64());\n+\n+                return hash.as_u64();\n+            }\n+\n+            // otherwise, load the data and repeat.\n+            self.load_data(def_id.krate);\n+            assert!(self.crate_hashes.contains_key(&def_id.krate));\n+        }\n+    }\n+\n+    fn load_data(&mut self, cnum: ast::CrateNum) {\n+        debug!(\"load_data(cnum={})\", cnum);\n+\n+        let svh = self.tcx.sess.cstore.crate_hash(cnum);\n+        let old = self.crate_hashes.insert(cnum, svh);\n+        debug!(\"load_data: svh={}\", svh);\n+        assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);\n+\n+        if let Some(path) = metadata_hash_path(self.tcx, cnum) {\n+            debug!(\"load_data: path={:?}\", path);\n+            let mut data = vec![];\n+            match\n+                File::open(&path)\n+                .and_then(|mut file| file.read_to_end(&mut data))\n+            {\n+                Ok(_) => {\n+                    match self.load_from_data(cnum, &data) {\n+                        Ok(()) => { }\n+                        Err(err) => {\n+                            bug!(\"decoding error in dep-graph from `{}`: {}\",\n+                                 path.display(), err);\n+                        }\n+                    }\n+                }\n+                Err(err) => {\n+                    match err.kind() {\n+                        ErrorKind::NotFound => {\n+                            // If the file is not found, that's ok.\n+                        }\n+                        _ => {\n+                            self.tcx.sess.err(\n+                                &format!(\"could not load dep information from `{}`: {}\",\n+                                         path.display(), err));\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn load_from_data(&mut self, cnum: ast::CrateNum, data: &[u8]) -> Result<(), Error> {\n+        debug!(\"load_from_data(cnum={})\", cnum);\n+\n+        // Load up the hashes for the def-ids from this crate.\n+        let mut decoder = Decoder::new(data, 0);\n+        let serialized_hashes = try!(SerializedMetadataHashes::decode(&mut decoder));\n+        for serialized_hash in serialized_hashes.hashes {\n+            // the hashes are stored with just a def-index, which is\n+            // always relative to the old crate; convert that to use\n+            // our internal crate number\n+            let def_id = DefId { krate: cnum, index: serialized_hash.def_index };\n+\n+            // record the hash for this dep-node\n+            let old = self.item_metadata_hashes.insert(def_id, serialized_hash.hash);\n+            debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n+            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "e3fd290443c11bf38ceb002c0bb23d2400b0f748", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -10,7 +10,6 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use calculate_svh::SvhCalculate;\n use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n@@ -25,6 +24,7 @@ use std::path::Path;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;\n+use super::hash::*;\n use super::util::*;\n \n type DirtyNodes = FnvHashSet<DepNode<DefId>>;\n@@ -131,20 +131,20 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 hashed_items: &[SerializedHash],\n+                                 hashes: &[SerializedHash],\n                                  retraced: &RetracedDefIdDirectory)\n                                  -> DirtyNodes {\n+    let mut hcx = HashContext::new(tcx);\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n-    for hashed_item in hashed_items {\n-        match retraced.def_id(hashed_item.index) {\n-            Some(def_id) => {\n-                // FIXME(#32753) -- should we use a distinct hash here\n-                let current_hash = tcx.calculate_item_hash(def_id);\n+    for hash in hashes {\n+        match hash.node.map_def(|&i| retraced.def_id(i)) {\n+            Some(dep_node) => {\n+                let current_hash = hcx.hash(dep_node).unwrap();\n                 debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n-                       def_id, current_hash, hashed_item.hash);\n-                if current_hash != hashed_item.hash {\n-                    dirty_nodes.insert(DepNode::Hir(def_id));\n+                       dep_node, current_hash, hash.hash);\n+                if current_hash != hash.hash {\n+                    dirty_nodes.insert(dep_node);\n                 }\n             }\n             None => {"}, {"sha": "72ccc29c97b63f6214069fad9accf984dca803d0", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -15,6 +15,7 @@\n mod data;\n mod directory;\n mod dirty_clean;\n+mod hash;\n mod load;\n mod save;\n mod util;"}, {"sha": "7deb1ca36dbded0451760ab5e15ac870434bbcc7", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 128, "deletions": 69, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -8,116 +8,115 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use calculate_svh::SvhCalculate;\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n+use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n+use std::hash::{Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n+use std::path::PathBuf;\n \n use super::data::*;\n use super::directory::*;\n+use super::hash::*;\n use super::util::*;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let mut hcx = HashContext::new(tcx);\n+    save_in(&mut hcx, dep_graph_path(tcx), encode_dep_graph);\n+    save_in(&mut hcx, metadata_hash_path(tcx, LOCAL_CRATE), encode_metadata_hashes);\n+}\n \n-    if let Some(dep_graph) = dep_graph_path(tcx) {\n-        // FIXME(#32754) lock file?\n-\n-        // delete the old dep-graph, if any\n-        if dep_graph.exists() {\n-            match fs::remove_file(&dep_graph) {\n-                Ok(()) => { }\n-                Err(err) => {\n-                    tcx.sess.err(\n-                        &format!(\"unable to delete old dep-graph at `{}`: {}\",\n-                                 dep_graph.display(), err));\n-                    return;\n-                }\n-            }\n-        }\n+fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n+                        opt_path_buf: Option<PathBuf>,\n+                        encode: F)\n+    where F: FnOnce(&mut HashContext<'a, 'tcx>, &mut Encoder) -> io::Result<()>\n+{\n+    let tcx = hcx.tcx;\n+\n+    let path_buf = match opt_path_buf {\n+        Some(p) => p,\n+        None => return\n+    };\n+\n+    // FIXME(#32754) lock file?\n \n-        // generate the data in a memory buffer\n-        let mut wr = Cursor::new(Vec::new());\n-        match encode_dep_graph(tcx, &mut Encoder::new(&mut wr)) {\n+    // delete the old dep-graph, if any\n+    if path_buf.exists() {\n+        match fs::remove_file(&path_buf) {\n             Ok(()) => { }\n             Err(err) => {\n                 tcx.sess.err(\n-                    &format!(\"could not encode dep-graph to `{}`: {}\",\n-                             dep_graph.display(), err));\n+                    &format!(\"unable to delete old dep-graph at `{}`: {}\",\n+                             path_buf.display(), err));\n                 return;\n             }\n         }\n+    }\n \n-        // write the data out\n-        let data = wr.into_inner();\n-        match\n-            File::create(&dep_graph)\n-            .and_then(|mut file| file.write_all(&data))\n-        {\n-            Ok(_) => { }\n-            Err(err) => {\n-                tcx.sess.err(\n-                    &format!(\"failed to write dep-graph to `{}`: {}\",\n-                             dep_graph.display(), err));\n-                return;\n-            }\n+    // generate the data in a memory buffer\n+    let mut wr = Cursor::new(Vec::new());\n+    match encode(hcx, &mut Encoder::new(&mut wr)) {\n+        Ok(()) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"could not encode dep-graph to `{}`: {}\",\n+                         path_buf.display(), err));\n+            return;\n+        }\n+    }\n+\n+    // write the data out\n+    let data = wr.into_inner();\n+    match\n+        File::create(&path_buf)\n+        .and_then(|mut file| file.write_all(&data))\n+    {\n+        Ok(_) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"failed to write dep-graph to `{}`: {}\",\n+                         path_buf.display(), err));\n+            return;\n         }\n     }\n }\n \n-pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                                   encoder: &mut Encoder)\n-                                  -> io::Result<()> {\n-    // Here we take advantage of how RBML allows us to skip around\n-    // and encode the depgraph as a two-part structure:\n-    //\n-    // ```\n-    // <dep-graph>[SerializedDepGraph]</dep-graph> // tag 0\n-    // <directory>[DefIdDirectory]</directory>     // tag 1\n-    // ```\n-    //\n-    // Then later we can load the directory by skipping to find tag 1.\n-\n+                                  -> io::Result<()>\n+{\n+    let tcx = hcx.tcx;\n     let query = tcx.dep_graph.query();\n \n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n \n-    // Create hashes for things we can persist.\n+    // Create hashes for inputs.\n     let hashes =\n         query.nodes()\n              .into_iter()\n-             .filter_map(|dep_node| match dep_node {\n-                 DepNode::Hir(def_id) => {\n-                     assert!(def_id.is_local());\n-                     builder.add(def_id)\n-                            .map(|index| {\n-                                // FIXME(#32753) -- should we use a distinct hash here\n-                                let hash = tcx.calculate_item_hash(def_id);\n-                                SerializedHash { index: index, hash: hash }\n-                            })\n-                 }\n-                 _ => None\n+             .filter_map(|dep_node| {\n+                 hcx.hash(dep_node)\n+                    .map(|hash| {\n+                        let node = builder.map(dep_node);\n+                        SerializedHash { node: node, hash: hash }\n+                    })\n              })\n              .collect();\n \n-    // Create the serialized dep-graph, dropping nodes that are\n-    // from other crates or from inlined items.\n-    //\n-    // FIXME(#32015) fix handling of other crates\n+    // Create the serialized dep-graph.\n     let graph = SerializedDepGraph {\n         nodes: query.nodes().into_iter()\n-                            .flat_map(|node| builder.map(node))\n+                            .map(|node| builder.map(node))\n                             .collect(),\n         edges: query.edges().into_iter()\n-                            .flat_map(|(source_node, target_node)| {\n-                                builder.map(source_node)\n-                                       .and_then(|source| {\n-                                           builder.map(target_node)\n-                                                  .map(|target| (source, target))\n-                                       })\n+                            .map(|(source_node, target_node)| {\n+                                let source = builder.map(source_node);\n+                                let target = builder.map(target_node);\n+                                (source, target)\n                             })\n                             .collect(),\n         hashes: hashes,\n@@ -133,3 +132,63 @@ pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n+pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n+                                        encoder: &mut Encoder)\n+                                        -> io::Result<()>\n+{\n+    let tcx = hcx.tcx;\n+    let query = tcx.dep_graph.query();\n+\n+    let serialized_hashes = {\n+        // Identify the `MetaData(X)` nodes where `X` is local. These are\n+        // the metadata items we export. Downstream crates will want to\n+        // see a hash that tells them whether we might have changed the\n+        // metadata for a given item since they last compiled.\n+        let meta_data_def_ids =\n+            query.nodes()\n+                 .into_iter()\n+                 .filter_map(|dep_node| match dep_node {\n+                     DepNode::MetaData(def_id) if def_id.is_local() => Some(def_id),\n+                     _ => None,\n+                 });\n+\n+        // To create the hash for each item `X`, we don't hash the raw\n+        // bytes of the metadata (though in principle we\n+        // could). Instead, we walk the predecessors of `MetaData(X)`\n+        // from the dep-graph. This corresponds to all the inputs that\n+        // were read to construct the metadata. To create the hash for\n+        // the metadata, we hash (the hash of) all of those inputs.\n+        let hashes =\n+            meta_data_def_ids\n+            .map(|def_id| {\n+                assert!(def_id.is_local());\n+                let dep_node = DepNode::MetaData(def_id);\n+                let mut state = SipHasher::new();\n+                debug!(\"save: computing metadata hash for {:?}\", dep_node);\n+                for node in query.transitive_predecessors(dep_node) {\n+                    if let Some(hash) = hcx.hash(node) {\n+                        debug!(\"save: predecessor {:?} has hash {}\", node, hash);\n+                        state.write_u64(hash.to_le());\n+                    } else {\n+                        debug!(\"save: predecessor {:?} cannot be hashed\", node);\n+                    }\n+                }\n+                let hash = state.finish();\n+                debug!(\"save: metadata hash for {:?} is {}\", dep_node, hash);\n+                SerializedMetadataHash {\n+                    def_index: def_id.index,\n+                    hash: hash,\n+                }\n+            });\n+\n+        // Collect these up into a vector.\n+        SerializedMetadataHashes {\n+            hashes: hashes.collect()\n+        }\n+    };\n+\n+    // Encode everything.\n+    try!(serialized_hashes.encode(encoder));\n+\n+    Ok(())\n+}"}, {"sha": "a77a9607e7734decf10dcc375c989867234b3ab5", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -8,13 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n \n use std::fs;\n use std::io;\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n+use syntax::ast;\n \n pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    path(tcx, LOCAL_CRATE, \"local\")\n+}\n+\n+pub fn metadata_hash_path(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n+    path(tcx, cnum, \"metadata\")\n+}\n+\n+fn path(tcx: TyCtxt, cnum: ast::CrateNum, suffix: &str) -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n     tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n@@ -28,7 +38,13 @@ pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n             }\n         }\n \n-        Some(incr_dir.join(\"dep_graph.rbml\"))\n+        let crate_name = tcx.crate_name(cnum);\n+        let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+        let file_name = format!(\"{}-{}.{}.bin\",\n+                                crate_name,\n+                                crate_disambiguator,\n+                                suffix);\n+        Some(incr_dir.join(file_name))\n     })\n }\n \n@@ -52,3 +68,4 @@ fn create_dir_racy(path: &Path) -> io::Result<()> {\n         Err(e) => Err(e),\n     }\n }\n+"}, {"sha": "0eacc0907bc25b2ce151cb6938a7a435009675dd", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -319,6 +319,7 @@ impl<'a> CrateReader<'a> {\n             extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n             xref_index: decoder::load_xrefs(metadata.as_slice()),\n+            key_map: decoder::load_key_map(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,"}, {"sha": "b87b5492f0440405151b4545c6990ebce4edaf5f", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -20,7 +20,9 @@ use middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt, VariantKind};\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n \n+use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n+use rustc::hir::map::DefKey;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n@@ -37,106 +39,120 @@ use rustc_back::target::Target;\n use rustc::hir;\n \n impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n-    fn stability(&self, def: DefId) -> Option<attr::Stability>\n-    {\n+    fn stability(&self, def: DefId) -> Option<attr::Stability> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_stability(&cdata, def.index)\n     }\n \n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>\n-    {\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_deprecation(&cdata, def.index)\n     }\n \n     fn visibility(&self, def: DefId) -> ty::Visibility {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_visibility(&cdata, def.index)\n     }\n \n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::closure_kind(&cdata, def_id.index)\n     }\n \n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n-    {\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n         assert!(!def_id.is_local());\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::closure_ty(&cdata, def_id.index, tcx)\n     }\n \n     fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_item_variances(&cdata, def.index)\n     }\n \n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_repr_attrs(&cdata, def.index)\n     }\n \n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> ty::TypeScheme<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_type(&cdata, def.index, tcx)\n     }\n \n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_predicates(&cdata, def.index, tcx)\n     }\n \n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_super_predicates(&cdata, def.index, tcx)\n     }\n \n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_item_attrs(&cdata, def_id.index)\n     }\n \n     fn item_symbol(&self, def: DefId) -> String\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_symbol(&cdata, def.index)\n     }\n \n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_trait_def(&cdata, def.index, tcx)\n     }\n \n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n     }\n \n     fn method_arg_names(&self, did: DefId) -> Vec<String>\n     {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::get_method_arg_names(&cdata, did.index)\n     }\n \n     fn item_name(&self, def: DefId) -> ast::Name {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_item_name(&self.intr, &cdata, def.index)\n     }\n \n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::each_inherent_implementation_for_type(&cdata, def_id.index,\n@@ -146,6 +162,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n             decoder::each_implementation_for_trait(cdata, def_id, &mut |iid| {\n@@ -158,64 +175,74 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                   -> Vec<Rc<ty::Method<'tcx>>>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_trait_item_def_ids(&cdata, def.index)\n     }\n \n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(impl_def_id));\n         let cdata = self.get_crate_data(impl_def_id.krate);\n         decoder::get_impl_items(&cdata, impl_def_id.index)\n     }\n \n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_polarity(&cdata, def.index)\n     }\n \n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_trait(&cdata, def.index, tcx)\n     }\n \n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_custom_coerce_unsized_kind(&cdata, def.index)\n     }\n \n     // FIXME: killme\n     fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n+        self.dep_graph.read(DepNode::MetaData(impl_def));\n         let cdata = self.get_crate_data(impl_def.krate);\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n     fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n     }\n \n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item(\n             self.intr.clone(),\n@@ -226,34 +253,40 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn is_const_fn(&self, did: DefId) -> bool\n     {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_const_fn(&cdata, did.index)\n     }\n \n     fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n     {\n+        self.dep_graph.read(DepNode::MetaData(trait_def_id));\n         let cdata = self.get_crate_data(trait_def_id.krate);\n         decoder::is_defaulted_trait(&cdata, trait_def_id.index)\n     }\n \n     fn is_impl(&self, did: DefId) -> bool\n     {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_impl(&cdata, did.index)\n     }\n \n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(impl_did));\n         let cdata = self.get_crate_data(impl_did.krate);\n         decoder::is_default_impl(&cdata, impl_did.index)\n     }\n \n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n \n     fn is_static_method(&self, def: DefId) -> bool\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::is_static_method(&cdata, def.index)\n     }\n@@ -264,6 +297,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn is_typedef(&self, did: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_typedef(&cdata, did.index)\n     }\n@@ -375,44 +409,59 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_reachable_ids(&cdata)\n     }\n \n+    fn def_index_for_def_key(&self,\n+                             cnum: ast::CrateNum,\n+                             def: DefKey)\n+                             -> Option<DefIndex> {\n+        let cdata = self.get_crate_data(cnum);\n+        cdata.key_map.get(&def).cloned()\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n     fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::def_key(&cdata, def.index)\n     }\n \n     fn relative_def_path(&self, def: DefId) -> hir_map::DefPath {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::def_path(&cdata, def.index)\n     }\n \n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_variant_kind(&cdata, def_id.index)\n     }\n \n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(struct_def_id));\n         let cdata = self.get_crate_data(struct_def_id.krate);\n         decoder::get_struct_ctor_def_id(&cdata, struct_def_id.index)\n     }\n \n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n     {\n+        self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n         decoder::get_tuple_struct_definition_if_ctor(&cdata, did.index)\n     }\n \n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_struct_field_names(&self.intr, &cdata, def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n@@ -445,17 +494,20 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> FoundAst<'tcx>\n     {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::is_item_mir_available(&cdata, def.index)\n     }"}, {"sha": "2e1bdf21c9a5ac072a675c9316a75dd66207f0ed", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -20,7 +20,9 @@ use decoder;\n use index;\n use loader;\n \n-use rustc::hir::def_id::DefId;\n+use rustc::dep_graph::DepGraph;\n+use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{ExternCrate};\n use rustc::session::config::PanicStrategy;\n@@ -78,6 +80,13 @@ pub struct crate_metadata {\n     pub index: index::Index,\n     pub xref_index: index::DenseIndex,\n \n+    /// For each public item in this crate, we encode a key.  When the\n+    /// crate is loaded, we read all the keys and put them in this\n+    /// hashmap, which gives the reverse mapping.  This allows us to\n+    /// quickly retrace a `DefPath`, which is needed for incremental\n+    /// compilation support.\n+    pub key_map: FnvHashMap<DefKey, DefIndex>,\n+\n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate\n     /// where this is false is when an allocator crate is injected into the\n@@ -86,6 +95,7 @@ pub struct crate_metadata {\n }\n \n pub struct CStore {\n+    pub dep_graph: DepGraph,\n     metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n@@ -98,8 +108,10 @@ pub struct CStore {\n }\n \n impl CStore {\n-    pub fn new(intr: Rc<IdentInterner>) -> CStore {\n+    pub fn new(dep_graph: &DepGraph,\n+               intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n+            dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FnvHashMap()),\n             extern_mod_crate_map: RefCell::new(FnvHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),"}, {"sha": "b6f35074b7dc701cf7a8f0d79339311561e84e57", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -25,6 +25,7 @@ use tydecode::TyDecoder;\n \n use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n+use rustc::hir::map::DefKey;\n use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n@@ -71,7 +72,10 @@ impl crate_metadata {\n \n     fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n         match self.get_item(item_id) {\n-            None => bug!(\"lookup_item: id not found: {:?}\", item_id),\n+            None => bug!(\"lookup_item: id not found: {:?} in crate {:?} with number {}\",\n+                         item_id,\n+                         self.name,\n+                         self.cnum),\n             Some(d) => d\n         }\n     }\n@@ -92,6 +96,29 @@ pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n     index::DenseIndex::from_buf(index.data, index.start, index.end)\n }\n \n+// Go through each item in the metadata and create a map from that\n+// item's def-key to the item's DefIndex.\n+pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n+    let root_doc = rbml::Doc::new(data);\n+    let items_doc = reader::get_doc(root_doc, tag_items);\n+    let items_data_doc = reader::get_doc(items_doc, tag_items_data);\n+    reader::docs(items_data_doc)\n+        .filter(|&(tag, _)| tag == tag_items_data_item)\n+        .map(|(_, item_doc)| {\n+            // load def-key from item\n+            let key = item_def_key(item_doc);\n+\n+            // load def-index from item; we only encode the full def-id,\n+            // so just pull out the index\n+            let def_id_doc = reader::get_doc(item_doc, tag_def_id);\n+            let def_id = untranslated_def_id(def_id_doc);\n+            assert!(def_id.is_local()); // local to the crate we are decoding, that is\n+\n+            (key, def_id.index)\n+        })\n+        .collect()\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c\n@@ -190,10 +217,14 @@ fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n+fn untranslated_def_id(d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n     let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n-    let def_id = DefId { krate: (id >> 32) as u32, index: index };\n+    DefId { krate: (id >> 32) as u32, index: index }\n+}\n+\n+fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n+    let def_id = untranslated_def_id(d);\n     translate_def_id(cdata, def_id)\n }\n \n@@ -1248,7 +1279,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n     reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n+        let hash = Svh::new(reader::doc_as_u64(reader::get_doc(depdoc, tag_crate_dep_hash)));\n         let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n         let explicitly_linked = reader::doc_as_u8(doc) != 0;\n         CrateDep {\n@@ -1272,14 +1303,14 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n-        Svh::new(doc.as_str_slice().to_string())\n+        Svh::new(reader::doc_as_u64(doc))\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n     let cratedoc = rbml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    Svh::new(hashdoc.as_str_slice().to_string())\n+    Svh::new(reader::doc_as_u64(hashdoc))\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {\n@@ -1747,6 +1778,10 @@ pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 't\n pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n     debug!(\"def_key: id={:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n+    item_def_key(item_doc)\n+}\n+\n+fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n     match reader::maybe_get_doc(item_doc, tag_def_key) {\n         Some(def_key_doc) => {\n             let mut decoder = reader::Decoder::new(def_key_doc);"}, {"sha": "928601095b078055ad0c809f3d598c3af4ea6589", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -25,6 +25,7 @@ use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n+use rustc::dep_graph::{DepGraph, DepNode, DepTask};\n use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -76,15 +77,23 @@ impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n #[derive(PartialEq, Eq, Hash)]\n pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n-struct CrateIndex<'tcx> {\n+struct CrateIndex<'a, 'tcx> {\n+    dep_graph: &'a DepGraph,\n     items: IndexData,\n     xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n }\n \n-impl<'tcx> CrateIndex<'tcx> {\n-    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) {\n+impl<'a, 'tcx> CrateIndex<'a, 'tcx> {\n+    /// Records that `id` is being emitted at the current offset.\n+    /// This data is later used to construct the item index in the\n+    /// metadata so we can quickly find the data for a given item.\n+    ///\n+    /// Returns a dep-graph task that you should keep live as long as\n+    /// the data for this item is being emitted.\n+    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) -> DepTask<'a> {\n         let position = rbml_w.mark_stable_position();\n         self.items.record(id, position);\n+        self.dep_graph.in_task(DepNode::MetaData(id))\n     }\n \n     fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n@@ -154,7 +163,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              ecx: &EncodeContext<'a, 'tcx>,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n@@ -165,7 +174,7 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n-                                    index: &mut CrateIndex<'tcx>,\n+                                    index: &mut CrateIndex<'a, 'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n     encode_generics(rbml_w, ecx, index,\n@@ -248,7 +257,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n                                       did: DefId,\n                                       vis: &hir::Visibility,\n-                                      index: &mut CrateIndex<'tcx>) {\n+                                      index: &mut CrateIndex<'a, 'tcx>) {\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n     let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n@@ -258,15 +267,11 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let vid = variant.did;\n         let variant_node_id = ecx.local_id(vid);\n \n-        if let ty::VariantKind::Struct = variant.kind() {\n-            // tuple-like enum variant fields aren't really items so\n-            // don't try to encode them.\n-            for field in &variant.fields {\n-                encode_field(ecx, rbml_w, field, index);\n-            }\n+        for field in &variant.fields {\n+            encode_field(ecx, rbml_w, field, index);\n         }\n \n-        index.record(vid, rbml_w);\n+        let _task = index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n@@ -297,6 +302,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n \n         rbml_w.end_tag();\n+\n         disr_val = disr_val.wrap_incr();\n     }\n }\n@@ -471,11 +477,11 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          index: &mut CrateIndex<'tcx>) {\n+                          index: &mut CrateIndex<'a, 'tcx>) {\n     let nm = field.name;\n     let id = ecx.local_id(field.did);\n \n-    index.record(field.did, rbml_w);\n+    let _task = index.record(field.did, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n@@ -495,12 +501,12 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                          rbml_w: &mut Encoder,\n                                          name: Name,\n                                          struct_def: &hir::VariantData,\n-                                         index: &mut CrateIndex<'tcx>,\n+                                         index: &mut CrateIndex<'a, 'tcx>,\n                                          struct_id: NodeId) {\n     let ctor_id = struct_def.id();\n     let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n-    index.record(ctor_def_id, rbml_w);\n+    let _task = index.record(ctor_def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n     encode_family(rbml_w, match *struct_def {\n@@ -531,7 +537,7 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n-                             index: &mut CrateIndex<'tcx>,\n+                             index: &mut CrateIndex<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n                              tag: usize)\n@@ -576,7 +582,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n \n fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n                                              _ecx: &EncodeContext<'a,'tcx>,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              predicates: &ty::GenericPredicates<'tcx>)\n {\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n@@ -593,7 +599,7 @@ fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n-                              index: &mut CrateIndex<'tcx>,\n+                              index: &mut CrateIndex<'a, 'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n@@ -604,7 +610,7 @@ fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n \n fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n-                                     index: &mut CrateIndex<'tcx>,\n+                                     index: &mut CrateIndex<'a, 'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n     encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n@@ -623,15 +629,15 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                               rbml_w: &mut Encoder,\n-                                              index: &mut CrateIndex<'tcx>,\n+                                              index: &mut CrateIndex<'a, 'tcx>,\n                                               associated_const: &ty::AssociatedConst,\n                                               parent_id: NodeId,\n                                               impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n            associated_const.name);\n \n-    index.record(associated_const.def_id, rbml_w);\n+    let _task = index.record(associated_const.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n@@ -665,15 +671,15 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n-                                    index: &mut CrateIndex<'tcx>,\n+                                    index: &mut CrateIndex<'a, 'tcx>,\n                                     m: &ty::Method<'tcx>,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n                                     impl_item_opt: Option<&hir::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n-    index.record(m.def_id, rbml_w);\n+    let _task = index.record(m.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, index, m);\n@@ -717,15 +723,15 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              rbml_w: &mut Encoder,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n                                              parent_id: NodeId,\n                                              impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            associated_type.name);\n \n-    index.record(associated_type.def_id, rbml_w);\n+    let _task = index.record(associated_type.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n@@ -863,20 +869,23 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   item: &hir::Item,\n-                                  index: &mut CrateIndex<'tcx>) {\n+                                  index: &mut CrateIndex<'a, 'tcx>) {\n     let tcx = ecx.tcx;\n \n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n     let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id));\n-    let depr = tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id));\n+\n+    let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n+        (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n+         tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n+    });\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         if m == hir::MutMutable {\n@@ -894,7 +903,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemConst(_, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n@@ -909,7 +918,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n@@ -933,7 +942,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n@@ -943,7 +952,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             &item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n@@ -960,7 +969,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n@@ -972,7 +981,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n \n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1003,12 +1012,12 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                  index);\n       }\n       hir::ItemStruct(ref struct_def, _) => {\n+        /* Index the class*/\n+        let _task = index.record(def_id, rbml_w);\n+\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n-        /* Index the class*/\n-        index.record(def_id, rbml_w);\n-\n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1056,7 +1065,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n-          index.record(def_id, rbml_w);\n+          let _task = index.record(def_id, rbml_w);\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id_and_key(ecx, rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n@@ -1068,12 +1077,13 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n           rbml_w.end_tag();\n       }\n       hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n+        let _task = index.record(def_id, rbml_w);\n+\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n         let items = impl_items.get(&def_id).unwrap();\n \n-        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n@@ -1170,7 +1180,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n       }\n       hir::ItemTrait(_, _, _, ref ms) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n@@ -1225,7 +1235,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.record(item_def_id.def_id(), rbml_w);\n+            let _task = index.record(item_def_id.def_id(), rbml_w);\n             rbml_w.start_tag(tag_items_data_item);\n \n             encode_parent_item(rbml_w, def_id);\n@@ -1336,12 +1346,12 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           rbml_w: &mut Encoder,\n                                           nitem: &hir::ForeignItem,\n-                                          index: &mut CrateIndex<'tcx>) {\n+                                          index: &mut CrateIndex<'a, 'tcx>) {\n     debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n     let def_id = ecx.tcx.map.local_def_id(nitem.id);\n     let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n-    index.record(def_id, rbml_w);\n+    let _task = index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n     encode_visibility(rbml_w, &nitem.vis);\n@@ -1390,7 +1400,7 @@ fn my_visit_expr(expr: &hir::Expr,\n         hir::ExprClosure(..) => {\n             let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-            index.record(def_id, rbml_w);\n+            let _task = index.record(def_id, rbml_w);\n \n             rbml_w.start_tag(tag_items_data_item);\n             encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1414,8 +1424,8 @@ fn my_visit_expr(expr: &hir::Expr,\n \n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut CrateIndex<'tcx>,\n+    ecx: &'a EncodeContext<'c, 'tcx>,\n+    index: &'a mut CrateIndex<'c, 'tcx>,\n }\n \n impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n@@ -1435,23 +1445,26 @@ impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n \n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    rbml_w: &mut Encoder)\n-                                   -> CrateIndex<'tcx> {\n+                                   -> CrateIndex<'a, 'tcx> {\n     let krate = ecx.tcx.map.krate();\n \n     let mut index = CrateIndex {\n+        dep_graph: &ecx.tcx.dep_graph,\n         items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n         xrefs: FnvHashMap()\n     };\n     rbml_w.start_tag(tag_items_data);\n \n-    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n-    encode_info_for_mod(ecx,\n-                        rbml_w,\n-                        &krate.module,\n-                        &[],\n-                        CRATE_NODE_ID,\n-                        syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                        &hir::Public);\n+    {\n+        let _task = index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n+        encode_info_for_mod(ecx,\n+                            rbml_w,\n+                            &krate.module,\n+                            &[],\n+                            CRATE_NODE_ID,\n+                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                            &hir::Public);\n+    }\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,\n@@ -1780,14 +1793,14 @@ fn encode_crate_dep(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n     let hash = decoder::get_crate_hash(dep.data());\n-    rbml_w.wr_tagged_str(tag_crate_dep_hash, hash.as_str());\n+    rbml_w.wr_tagged_u64(tag_crate_dep_hash, hash.as_u64());\n     rbml_w.wr_tagged_u8(tag_crate_dep_explicitly_linked,\n                         dep.explicitly_linked.get() as u8);\n     rbml_w.end_tag();\n }\n \n fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n-    rbml_w.wr_tagged_str(tag_crate_hash, hash.as_str());\n+    rbml_w.wr_tagged_u64(tag_crate_hash, hash.as_u64());\n }\n \n fn encode_rustc_version(rbml_w: &mut Encoder) {"}, {"sha": "b850073462f5a87a2e666825897d236dce6ded35", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -75,7 +75,7 @@ impl IndexData {\n \n     pub fn record(&mut self, def_id: DefId, position: u64) {\n         assert!(def_id.is_local());\n-        self.record_index(def_id.index, position)\n+        self.record_index(def_id.index, position);\n     }\n \n     pub fn record_index(&mut self, item: DefIndex, position: u64) {"}, {"sha": "a5b1c3d301b1060a84ed3c9936100ebca790432c", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -620,7 +620,7 @@ impl<'a> Context<'a> {\n                 info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n-                    got: myhash.as_str().to_string()\n+                    got: myhash.to_string()\n                 });\n                 return None;\n             }"}, {"sha": "61ed88ec173d4e2c8445afd482b72ccfe870f643", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -3624,6 +3624,7 @@ pub fn resolve_crate<'a, 'b>(resolver: &'b mut Resolver<'a>, krate: &'b Crate) {\n     // reflects not just its contents but the results of name\n     // resolution on those contents. Hopefully we'll push this back at\n     // some point.\n+    let _ignore = resolver.session.dep_graph.in_ignore();\n \n     resolver.build_reduced_graph(krate);\n     resolve_imports::resolve_imports(resolver);"}, {"sha": "b5248c209a30a16d283929afa5a198ee0faf3f12", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -25,6 +25,7 @@ use middle::dependency_format::Linkage;\n use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::dep_graph::DepNode;\n use rustc::ty::TyCtxt;\n use rustc_back::tempdir::TempDir;\n \n@@ -183,6 +184,8 @@ pub fn link_binary(sess: &Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n                    crate_name: &str) -> Vec<PathBuf> {\n+    let _task = sess.dep_graph.in_task(DepNode::LinkBinary);\n+\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {"}, {"sha": "481154ba29f8c52889b6605756c06542eed046f1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -47,6 +47,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n+use rustc_data_structures::graph::OUTGOING;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use _match;\n@@ -1368,7 +1369,7 @@ fn build_cfg<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // return slot alloca. This can cause errors related to clean-up due to\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n-    for index in cfg.graph.depth_traverse(cfg.entry) {\n+    for index in cfg.graph.depth_traverse(cfg.entry, OUTGOING) {\n         let n = cfg.graph.node_data(index);\n         match tcx.map.find(n.id()) {\n             Some(hir_map::NodeExpr(ex)) => {"}, {"sha": "4ae869c325976f0dcd5146a3c094093f42e74348", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -134,8 +134,10 @@ pub fn run_core(search_paths: SearchPaths,\n                                                                false,\n                                                                codemap.clone());\n \n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = session::build_session_(sessopts, cpath, diagnostic_handler,\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let sess = session::build_session_(sessopts, &dep_graph, cpath, diagnostic_handler,\n                                        codemap, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -151,15 +153,14 @@ pub fn run_core(search_paths: SearchPaths,\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n-    let dep_graph = DepGraph::new(false);\n \n     let mut defs = hir_map::collect_definitions(&krate);\n     read_local_crates(&sess, &cstore, &defs, &krate, &name, &dep_graph);\n \n     // Lower ast -> hir and resolve.\n     let (analysis, resolutions, mut hir_forest) = {\n-        driver::lower_and_resolve(&sess, &name, &mut defs, &krate, dep_graph,\n-                                  resolve::MakeGlobMap::No)\n+        driver::lower_and_resolve(&sess, &name, &mut defs, &krate,\n+                                  &sess.dep_graph, resolve::MakeGlobMap::No)\n     };\n \n     let arenas = ty::CtxtArenas::new();\n@@ -177,7 +178,6 @@ pub fn run_core(search_paths: SearchPaths,\n             return None\n         }\n \n-        let _ignore = tcx.dep_graph.in_ignore();\n         let ty::CrateAnalysis { access_levels, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access"}, {"sha": "2754f77444c67544a24cb442d09e0828a3c39f98", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -79,8 +79,11 @@ pub fn run(input: &str,\n                                                                false,\n                                                                codemap.clone());\n \n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n     let sess = session::build_session_(sessopts,\n+                                       &dep_graph,\n                                        Some(input_path.clone()),\n                                        diagnostic_handler,\n                                        codemap,\n@@ -98,12 +101,12 @@ pub fn run(input: &str,\n     let defs = hir_map::collect_definitions(&krate);\n \n     let mut dummy_resolver = DummyResolver;\n-    let krate = lower_crate(&krate, &sess, &mut dummy_resolver);\n+    let krate = lower_crate(&sess, &krate, &sess, &mut dummy_resolver);\n \n     let opts = scrape_test_config(&krate);\n \n     let _ignore = dep_graph.in_ignore();\n-    let mut forest = hir_map::Forest::new(krate, dep_graph.clone());\n+    let mut forest = hir_map::Forest::new(krate, &dep_graph);\n     let map = hir_map::map_crate(&mut forest, defs);\n \n     let ctx = core::DocContext {\n@@ -238,8 +241,10 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     // Compile the code\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let dep_graph = DepGraph::new(false);\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n     let sess = session::build_session_(sessopts,\n+                                       &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n                                        codemap,"}, {"sha": "d802c9a8352eb675af47f076a0036fa7d2dc9ac8", "filename": "src/test/incremental/callee_caller_cross_crate/auxiliary/a.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+#[cfg(rpass1)]\n+pub fn function0(x: u32) -> u32 {\n+    x\n+}\n+\n+#[cfg(rpass2)]\n+pub fn function0(x: i32) -> i32 {\n+    x\n+}\n+\n+pub fn function1(x: u32) {\n+}"}, {"sha": "e81f828beb19fd4d3fd9b25588de8c382c6400ba", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate a;\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn call_function0() {\n+    a::function0(77);\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn call_function1() {\n+    a::function1(77);\n+}\n+\n+pub fn main() { }"}, {"sha": "2494dca0509b16ea79923b3681388b21e0422adb", "filename": "src/test/incremental/type_alias_cross_crate/auxiliary/a.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+#[cfg(rpass1)]\n+pub type X = u32;\n+\n+#[cfg(rpass2)]\n+pub type X = i32;\n+\n+pub type Y = char;\n+\n+pub fn foo() { }"}, {"sha": "b4e9b7601010a9e69c5b0f1d5ff0b41f278f768c", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate a;\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X() -> u32 {\n+    let x: a::X = 22;\n+    x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: a::Y = 'c';\n+}\n+\n+pub fn main() { }"}, {"sha": "0e84a0f52218c4bb75c9e01cec89c21135dfa2e5", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -223,8 +223,12 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n     let handle = thread.spawn(move || {\n         let opts = build_exec_options(sysroot);\n-        let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS),\n+        let dep_graph = DepGraph::new(opts.build_dep_graph());\n+        let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+        let sess = build_session(opts,\n+                                 &dep_graph,\n+                                 None,\n+                                 Registry::new(&rustc::DIAGNOSTICS),\n                                  cstore.clone());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -237,12 +241,12 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");\n \n-        let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n         let krate = driver::assign_node_ids(&sess, krate);\n         let mut defs = ast_map::collect_definitions(&krate);\n         read_local_crates(&sess, &cstore, &defs, &krate, &id, &dep_graph);\n         let (analysis, resolutions, mut hir_forest) = {\n-            driver::lower_and_resolve(&sess, &id, &mut defs, &krate, dep_graph, MakeGlobMap::No)\n+            driver::lower_and_resolve(&sess, &id, &mut defs, &krate,\n+                                      &sess.dep_graph, MakeGlobMap::No)\n         };\n \n         let arenas = ty::CtxtArenas::new();"}, {"sha": "41d250eadec4e1a64d2c53fe435f2bcdd6836664", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -16,6 +16,7 @@ extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate syntax;\n \n+use rustc::dep_graph::DepGraph;\n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n@@ -54,8 +55,9 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     opts.maybe_sysroot = Some(sysroot);\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n-    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = build_session(opts, None, descriptions, cstore.clone());\n+    let dep_graph = DepGraph::new(opts.build_dep_graph());\n+    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)\n }"}, {"sha": "7593033ffe3991f9c9791aedae294056a9f335bf", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -162,6 +162,11 @@ pub struct TestProps {\n     pub forbid_output: Vec<String>,\n     // Revisions to test for incremental compilation.\n     pub revisions: Vec<String>,\n+    // Directory (if any) to use for incremental compilation.  This is\n+    // not set by end-users; rather it is set by the incremental\n+    // testing harness and used when generating compilation\n+    // arguments. (In particular, it propagates to the aux-builds.)\n+    pub incremental_dir: Option<PathBuf>,\n }\n \n impl TestProps {\n@@ -197,9 +202,20 @@ impl TestProps {\n             pretty_mode: format!(\"normal\"),\n             pretty_compare_only: pretty_compare_only,\n             forbid_output: forbid_output,\n+            incremental_dir: None,\n         }\n     }\n \n+    pub fn from_aux_file(&self, testfile: &Path, cfg: Option<&str>) -> Self {\n+        let mut props = TestProps::new();\n+\n+        // copy over select properties to the aux build:\n+        props.incremental_dir = self.incremental_dir.clone();\n+        props.load_from(testfile, cfg);\n+\n+        props\n+    }\n+\n     pub fn from_file(testfile: &Path) -> Self {\n         let mut props = TestProps::new();\n         props.load_from(testfile, None);"}, {"sha": "f89ff6b38492048443a7443b82f170bc2935e4ab", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a140454ea47b7fd107b6e963b7ea2aef74e9518/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=9a140454ea47b7fd107b6e963b7ea2aef74e9518", "patch": "@@ -63,10 +63,6 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         for revision in &base_props.revisions {\n             let mut revision_props = base_props.clone();\n             revision_props.load_from(&testpaths.file, Some(&revision));\n-            revision_props.compile_flags.extend(vec![\n-                format!(\"--cfg\"),\n-                format!(\"{}\", revision),\n-            ]);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n@@ -383,6 +379,12 @@ actual:\\n\\\n                             self.config.build_base.to_str().unwrap().to_owned(),\n                             \"-L\".to_owned(),\n                             aux_dir.to_str().unwrap().to_owned());\n+        if let Some(revision) = self.revision {\n+            args.extend(vec![\n+                format!(\"--cfg\"),\n+                format!(\"{}\", revision),\n+            ]);\n+        }\n         args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n         args.extend(self.props.compile_flags.iter().cloned());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1102,7 +1104,7 @@ actual:\\n\\\n         if self.props.build_aux_docs {\n             for rel_ab in &self.props.aux_builds {\n                 let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-                let aux_props = TestProps::from_file(&aux_testpaths.file);\n+                let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n                 let aux_cx = TestCx {\n                     config: self.config,\n                     props: &aux_props,\n@@ -1186,7 +1188,7 @@ actual:\\n\\\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-            let aux_props = TestProps::from_file(&aux_testpaths.file);\n+            let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n             let mut crate_type = if aux_props.no_prefer_dynamic {\n                 Vec::new()\n             } else {\n@@ -1291,6 +1293,21 @@ actual:\\n\\\n                             self.config.build_base.to_str().unwrap().to_owned(),\n                             format!(\"--target={}\", target));\n \n+        if let Some(revision) = self.revision {\n+            args.extend(vec![\n+                format!(\"--cfg\"),\n+                format!(\"{}\", revision),\n+            ]);\n+        }\n+\n+        if let Some(ref incremental_dir) = self.props.incremental_dir {\n+            args.extend(vec![\n+                format!(\"-Z\"),\n+                format!(\"incremental={}\", incremental_dir.display()),\n+            ]);\n+        }\n+\n+\n         match self.config.mode {\n             CompileFail |\n             ParseFail |\n@@ -1980,10 +1997,7 @@ actual:\\n\\\n \n         // Add an extra flag pointing at the incremental directory.\n         let mut revision_props = self.props.clone();\n-        revision_props.compile_flags.extend(vec![\n-            format!(\"-Z\"),\n-            format!(\"incremental={}\", incremental_dir.display()),\n-        ]);\n+        revision_props.incremental_dir = Some(incremental_dir);\n \n         let revision_cx = TestCx {\n             config: self.config,"}]}