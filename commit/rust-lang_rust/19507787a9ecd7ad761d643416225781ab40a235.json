{"sha": "19507787a9ecd7ad761d643416225781ab40a235", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NTA3Nzg3YTllY2Q3YWQ3NjFkNjQzNDE2MjI1NzgxYWI0MGEyMzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T15:37:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T15:41:00Z"}, "message": "Add support for bracey record types and literals\n\n    type foo = {mutable x: int, y: int};\n    auto myfoo = {mutable x: 10, y: 20u};\n\nThe old syntax is also still supported.", "tree": {"sha": "839102fa53f94eadacfc8a3c7d8483cc7d46f9e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/839102fa53f94eadacfc8a3c7d8483cc7d46f9e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19507787a9ecd7ad761d643416225781ab40a235", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19507787a9ecd7ad761d643416225781ab40a235", "html_url": "https://github.com/rust-lang/rust/commit/19507787a9ecd7ad761d643416225781ab40a235", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19507787a9ecd7ad761d643416225781ab40a235/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cce1b4667bb84497a350e746b65a7645c20de406", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce1b4667bb84497a350e746b65a7645c20de406", "html_url": "https://github.com/rust-lang/rust/commit/cce1b4667bb84497a350e746b65a7645c20de406"}], "stats": {"total": 54, "additions": 46, "deletions": 8}, "files": [{"sha": "221c97b8dac8b3de9db5ff19c900e024c673dc14", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/19507787a9ecd7ad761d643416225781ab40a235/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19507787a9ecd7ad761d643416225781ab40a235/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=19507787a9ecd7ad761d643416225781ab40a235", "patch": "@@ -102,8 +102,8 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn look_ahead(uint distance) -> token::token {\n             while ivec::len(buffer) < distance {\n                 auto next = lexer::next_token(rdr);\n-                buffer =\n-                    ~[tup(next._0, rec(lo=next._1, hi=rdr.get_chpos()))] + buffer;\n+                auto sp = rec(lo=next._1, hi=rdr.get_chpos());\n+                buffer = ~[tup(next._0, sp)] + buffer;\n             }\n             ret buffer.(distance-1u)._0;\n         }\n@@ -344,6 +344,15 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n     ret spanned(lo, mt.ty.span.hi, rec(ident=id, mt=mt));\n }\n \n+// FIXME rename to parse_ty_field once the other one is dropped\n+fn parse_ty_field_modern(&parser p) -> ast::ty_field {\n+    auto lo = p.get_lo_pos();\n+    auto mut = parse_mutability(p);\n+    auto id = parse_ident(p);\n+    expect(p, token::COLON);\n+    auto ty = parse_ty(p);\n+    ret spanned(lo, ty.span.hi, rec(ident=id, mt=rec(ty=ty, mut=mut)));\n+}\n \n // if i is the jth ident in args, return j\n // otherwise, fail\n@@ -540,6 +549,16 @@ fn parse_ty(&parser p) -> @ast::ty {\n         auto mt = parse_mt(p);\n         hi = mt.ty.span.hi;\n         t = ast::ty_ptr(mt);\n+    } else if (p.peek() == token::LBRACE) {\n+        auto elems = parse_seq(token::LBRACE, token::RBRACE,\n+                               some(token::COMMA), parse_ty_field_modern, p);\n+        hi = elems.span.hi;\n+        t = ast::ty_rec(elems.node);\n+        if (p.peek() == token::COLON) {\n+            p.bump();\n+            t = ast::ty_constr(@spanned(lo, hi, t),\n+                               parse_type_constraints(p));\n+        }\n     } else if (eat_word(p, \"vec\")) {\n         expect(p, token::LBRACKET);\n         t = ast::ty_vec(parse_mt(p));\n@@ -738,11 +757,11 @@ fn parse_mutability(&parser p) -> ast::mutability {\n     ret ast::imm;\n }\n \n-fn parse_field(&parser p) -> ast::field {\n+fn parse_field(&parser p, &token::token sep) -> ast::field {\n     auto lo = p.get_lo_pos();\n     auto m = parse_mutability(p);\n     auto i = parse_ident(p);\n-    expect(p, token::EQ);\n+    expect(p, sep);\n     auto e = parse_expr(p);\n     ret spanned(lo, e.span.hi, rec(mut=m, ident=i, expr=e));\n }\n@@ -783,8 +802,27 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         expect(p, token::RPAREN);\n         ret mk_expr(p, lo, hi, e.node);\n     } else if (p.peek() == token::LBRACE) {\n-        auto blk = parse_block(p);\n-        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+        p.bump();\n+        if (is_word(p, \"mutable\") ||\n+            alt p.peek() { token::IDENT(_, false) { true } _ { false } } &&\n+            p.look_ahead(1u) == token::COLON) {\n+            auto fields = ~[parse_field(p, token::COLON)];\n+            auto base = none;\n+            while p.peek() != token::RBRACE {\n+                if eat_word(p, \"with\") {\n+                    base = some(parse_expr(p));\n+                    break;\n+                }\n+                expect(p, token::COMMA);\n+                fields += ~[parse_field(p, token::COLON)];\n+            }\n+            hi = p.get_hi_pos();\n+            expect(p, token::RBRACE);\n+            ex = ast::expr_rec(fields, base);\n+        } else {\n+            auto blk = parse_block_tail(p);\n+            ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+        }\n     } else if (eat_word(p, \"if\")) {\n         ret parse_if_expr(p);\n     } else if (eat_word(p, \"for\")) {\n@@ -883,7 +921,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_anon_obj(ob);\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n-        auto fields = ~[parse_field(p)];\n+        auto fields = ~[parse_field(p, token::EQ)];\n         auto more = true;\n         auto base = none;\n         while (more) {\n@@ -898,7 +936,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 more = false;\n             } else if (p.peek() == token::COMMA) {\n                 p.bump();\n-                fields += ~[parse_field(p)];\n+                fields += ~[parse_field(p, token::EQ)];\n             } else { unexpected(p, p.peek()); }\n         }\n         ex = ast::expr_rec(fields, base);"}]}