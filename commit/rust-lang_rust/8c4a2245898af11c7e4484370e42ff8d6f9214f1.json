{"sha": "8c4a2245898af11c7e4484370e42ff8d6f9214f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNGEyMjQ1ODk4YWYxMWM3ZTQ0ODQzNzBlNDJmZjhkNmY5MjE0ZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-14T22:38:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:45Z"}, "message": "extract encode_info_for_trait_item into method", "tree": {"sha": "7642036b9720482f96688034c74604220232f1b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7642036b9720482f96688034c74604220232f1b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4a2245898af11c7e4484370e42ff8d6f9214f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4a2245898af11c7e4484370e42ff8d6f9214f1", "html_url": "https://github.com/rust-lang/rust/commit/8c4a2245898af11c7e4484370e42ff8d6f9214f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4a2245898af11c7e4484370e42ff8d6f9214f1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "html_url": "https://github.com/rust-lang/rust/commit/8dc8151b495b3237f06821a0b6fd6f0c89b5d438"}], "stats": {"total": 209, "additions": 109, "deletions": 100}, "files": [{"sha": "cc9b2e213b9f447daf7ee15b64cdcf68492212a0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 109, "deletions": 100, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/8c4a2245898af11c7e4484370e42ff8d6f9214f1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4a2245898af11c7e4484370e42ff8d6f9214f1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8c4a2245898af11c7e4484370e42ff8d6f9214f1", "patch": "@@ -21,7 +21,7 @@ use def_key;\n use tyencode;\n use index::{self, IndexData};\n \n-use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n+use middle::cstore::{InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n@@ -531,6 +531,109 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_trait_item(&mut self,\n+                                  trait_def_id: DefId,\n+                                  item_def_id: DefId,\n+                                  trait_item: &hir::TraitItem) {\n+        let ecx = self.ecx;\n+        let tcx = ecx.tcx;\n+\n+        self.encode_parent_item(trait_def_id);\n+\n+        let stab = tcx.lookup_stability(item_def_id);\n+        let depr = tcx.lookup_deprecation(item_def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        let trait_item_type =\n+            tcx.impl_or_trait_item(item_def_id);\n+        let is_nonstatic_method;\n+        match trait_item_type {\n+            ty::ConstTraitItem(associated_const) => {\n+                encode_name(self.rbml_w, associated_const.name);\n+                encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n+                self.encode_visibility(associated_const.vis);\n+\n+                encode_family(self.rbml_w, 'C');\n+\n+                self.encode_bounds_and_type_for_item(\n+                    ecx.local_id(associated_const.def_id));\n+\n+                is_nonstatic_method = false;\n+            }\n+            ty::MethodTraitItem(method_ty) => {\n+                let method_def_id = item_def_id;\n+\n+                self.encode_method_ty_fields(&method_ty);\n+\n+                match method_ty.explicit_self {\n+                    ty::ExplicitSelfCategory::Static => {\n+                        encode_family(self.rbml_w,\n+                                      STATIC_METHOD_FAMILY);\n+                    }\n+                    _ => {\n+                        encode_family(self.rbml_w,\n+                                      METHOD_FAMILY);\n+                    }\n+                }\n+                self.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n+\n+                is_nonstatic_method = method_ty.explicit_self !=\n+                    ty::ExplicitSelfCategory::Static;\n+            }\n+            ty::TypeTraitItem(associated_type) => {\n+                encode_name(self.rbml_w, associated_type.name);\n+                encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n+                encode_item_sort(self.rbml_w, 't');\n+                encode_family(self.rbml_w, 'y');\n+\n+                if let Some(ty) = associated_type.ty {\n+                    self.encode_type(ty);\n+                }\n+\n+                is_nonstatic_method = false;\n+            }\n+        }\n+\n+        encode_attributes(self.rbml_w, &trait_item.attrs);\n+        match trait_item.node {\n+            hir::ConstTraitItem(_, ref default) => {\n+                if default.is_some() {\n+                    encode_item_sort(self.rbml_w, 'C');\n+                } else {\n+                    encode_item_sort(self.rbml_w, 'c');\n+                }\n+\n+                encode_inlined_item(ecx, self.rbml_w,\n+                                    InlinedItemRef::TraitItem(trait_def_id, trait_item));\n+                self.encode_mir(trait_item.id);\n+            }\n+            hir::MethodTraitItem(ref sig, ref body) => {\n+                // If this is a static method, we've already\n+                // encoded self.\n+                if is_nonstatic_method {\n+                    self.encode_bounds_and_type_for_item(\n+                        ecx.local_id(item_def_id));\n+                }\n+\n+                if body.is_some() {\n+                    encode_item_sort(self.rbml_w, 'p');\n+                    encode_inlined_item(ecx,\n+                                        self.rbml_w,\n+                                        InlinedItemRef::TraitItem(\n+                                            trait_def_id,\n+                                            trait_item));\n+                    self.encode_mir(trait_item.id);\n+                } else {\n+                    encode_item_sort(self.rbml_w, 'r');\n+                }\n+                self.encode_method_argument_names(&sig.decl);\n+            }\n+\n+            hir::TypeTraitItem(..) => {}\n+        }\n+    }\n+\n     fn encode_info_for_impl_item(&mut self,\n                                  impl_id: NodeId,\n                                  impl_item_def_id: DefId,\n@@ -1145,107 +1248,13 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                               def_id: DefId,\n                               trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n-        let ecx = self.ecx;\n         let tcx = self.ecx.tcx;\n         let r = tcx.trait_item_def_ids(def_id);\n-        for (&item_def_id, trait_item) in r.iter().zip(trait_items) {\n-            assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n-\n-            self.record(item_def_id.def_id(), |this| {\n-                this.encode_parent_item(def_id);\n-\n-                let stab = tcx.lookup_stability(item_def_id.def_id());\n-                let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-                encode_stability(this.rbml_w, stab);\n-                encode_deprecation(this.rbml_w, depr);\n-\n-                let trait_item_type =\n-                    tcx.impl_or_trait_item(item_def_id.def_id());\n-                let is_nonstatic_method;\n-                match trait_item_type {\n-                    ty::ConstTraitItem(associated_const) => {\n-                        encode_name(this.rbml_w, associated_const.name);\n-                        encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n-                        this.encode_visibility(associated_const.vis);\n-\n-                        encode_family(this.rbml_w, 'C');\n-\n-                        this.encode_bounds_and_type_for_item(\n-                            ecx.local_id(associated_const.def_id));\n-\n-                        is_nonstatic_method = false;\n-                    }\n-                    ty::MethodTraitItem(method_ty) => {\n-                        let method_def_id = item_def_id.def_id();\n-\n-                        this.encode_method_ty_fields(&method_ty);\n-\n-                        match method_ty.explicit_self {\n-                            ty::ExplicitSelfCategory::Static => {\n-                                encode_family(this.rbml_w,\n-                                              STATIC_METHOD_FAMILY);\n-                            }\n-                            _ => {\n-                                encode_family(this.rbml_w,\n-                                              METHOD_FAMILY);\n-                            }\n-                        }\n-                        this.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n-\n-                        is_nonstatic_method = method_ty.explicit_self !=\n-                            ty::ExplicitSelfCategory::Static;\n-                    }\n-                    ty::TypeTraitItem(associated_type) => {\n-                        encode_name(this.rbml_w, associated_type.name);\n-                        encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n-                        encode_item_sort(this.rbml_w, 't');\n-                        encode_family(this.rbml_w, 'y');\n-\n-                        if let Some(ty) = associated_type.ty {\n-                            this.encode_type(ty);\n-                        }\n-\n-                        is_nonstatic_method = false;\n-                    }\n-                }\n-\n-                encode_attributes(this.rbml_w, &trait_item.attrs);\n-                match trait_item.node {\n-                    hir::ConstTraitItem(_, ref default) => {\n-                        if default.is_some() {\n-                            encode_item_sort(this.rbml_w, 'C');\n-                        } else {\n-                            encode_item_sort(this.rbml_w, 'c');\n-                        }\n-\n-                        encode_inlined_item(ecx, this.rbml_w,\n-                                            InlinedItemRef::TraitItem(def_id, trait_item));\n-                        this.encode_mir(trait_item.id);\n-                    }\n-                    hir::MethodTraitItem(ref sig, ref body) => {\n-                        // If this is a static method, we've already\n-                        // encoded this.\n-                        if is_nonstatic_method {\n-                            this.encode_bounds_and_type_for_item(\n-                                ecx.local_id(item_def_id.def_id()));\n-                        }\n-\n-                        if body.is_some() {\n-                            encode_item_sort(this.rbml_w, 'p');\n-                            encode_inlined_item(ecx,\n-                                                this.rbml_w,\n-                                                InlinedItemRef::TraitItem(\n-                                                    def_id,\n-                                                    trait_item));\n-                            this.encode_mir(trait_item.id);\n-                        } else {\n-                            encode_item_sort(this.rbml_w, 'r');\n-                        }\n-                        this.encode_method_argument_names(&sig.decl);\n-                    }\n-\n-                    hir::TypeTraitItem(..) => {}\n-                }\n+        for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n+            let item_def_id = item_def_id.def_id();\n+            assert!(item_def_id.is_local());\n+            self.record(item_def_id, |this| {\n+                this.encode_info_for_trait_item(def_id, item_def_id, trait_item)\n             });\n         }\n     }"}]}