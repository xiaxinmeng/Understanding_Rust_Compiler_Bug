{"sha": "91b71f5e9416b570b3e4c1997056c3879e5029af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjcxZjVlOTQxNmI1NzBiM2U0YzE5OTcwNTZjMzg3OWU1MDI5YWY=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-05T15:05:33Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-07T14:03:06Z"}, "message": "Identify borrows captured by trait objects.\n\nThis commit enhances `LaterUseKind` detection to identify when a borrow\nis captured by a trait object which helps explain why there is a borrow\nerror.", "tree": {"sha": "e5150b03d15b24e6725a7d18d90ff50b77b83093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5150b03d15b24e6725a7d18d90ff50b77b83093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b71f5e9416b570b3e4c1997056c3879e5029af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlu6EhoACgkQAXYLT59T\n8VS/ehAAtRDBO0nZ8pYRjqMkDsIsTrP46eGmgIGgLCwkQ51K2LboX97hpxCeDmWW\nVxFkfYCXKS3b4JiKD42yHe3rBSQmbMO7vS1l6Cg8JZEUOiBa7ruiE2El56Fd/bET\nRHI2IVbEzmuAW+XLn2budqLyTw+58Dz5mHErOgRLeeBpGLoF8OMHBJrlO3Tu/nSk\nArjyiyiZn/utcL9I9LFuOR7apBnwldOA79rlbRaw0FdJY7ptkh4T3aHGVHeiBvEi\nExn/DB7CWdS7vqV2sLpJ6igVa14iJEW9My0vF2++vNh8IZAsV4lw8mBgA8w7CH+x\ntzcQuDNvbat6ZSSzOpbpb6mHyMDMi634O61hB8tRfACFzwuwo+PsRHfq/SE331dS\nSej5gIdkDlMP9KBN+16SpTN/1AsPH+YJhpphZnzO2Q3f+msZpIsvJLn2dns79Qd8\nPEi9ASPgxaU60+NC7Hdzs3TKbjkJ2LiwwNylv1+ZQ3B/Ti0U2hk3dJ10e+9lAlFf\nxiUelFnUDl5Bxb8TxSNF5KqqJyWajM9QuYdUKF4Alj0oG3JpODkOuWyhoXpj9Ps6\nUnwHUgYUSlZzcrwdcH+fd7xlWTktJn+hQZrdgpBIPjisasUFu9QTTKCYrR6P18U3\nVwZ4SJiwDksS+Jj3plhzfTCmwWkcDLcnL1xK/V4+8SyYQUElyfM=\n=4+cx\n-----END PGP SIGNATURE-----", "payload": "tree e5150b03d15b24e6725a7d18d90ff50b77b83093\nparent 987a50bab3329a55d7b782da454456d5d4f4b9a1\nauthor David Wood <david@davidtw.co> 1538751933 +0200\ncommitter David Wood <david@davidtw.co> 1538920986 +0200\n\nIdentify borrows captured by trait objects.\n\nThis commit enhances `LaterUseKind` detection to identify when a borrow\nis captured by a trait object which helps explain why there is a borrow\nerror.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b71f5e9416b570b3e4c1997056c3879e5029af", "html_url": "https://github.com/rust-lang/rust/commit/91b71f5e9416b570b3e4c1997056c3879e5029af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b71f5e9416b570b3e4c1997056c3879e5029af/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "987a50bab3329a55d7b782da454456d5d4f4b9a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/987a50bab3329a55d7b782da454456d5d4f4b9a1", "html_url": "https://github.com/rust-lang/rust/commit/987a50bab3329a55d7b782da454456d5d4f4b9a1"}], "stats": {"total": 175, "additions": 137, "deletions": 38}, "files": [{"sha": "74bbdebe7a3adb9da6f5c00f7c400d624123dab6", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 136, "deletions": 37, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/91b71f5e9416b570b3e4c1997056c3879e5029af/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b71f5e9416b570b3e4c1997056c3879e5029af/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=91b71f5e9416b570b3e4c1997056c3879e5029af", "patch": "@@ -13,8 +13,10 @@ use borrow_check::error_reporting::UseSpans;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n use rustc::ty::{self, Region, TyCtxt};\n-use rustc::mir::{FakeReadCause, Local, Location, Mir, Operand};\n-use rustc::mir::{Place, StatementKind, TerminatorKind};\n+use rustc::mir::{\n+    FakeReadCause, Local, Location, Mir, Operand, Place, Rvalue, Statement, StatementKind,\n+    TerminatorKind\n+};\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -34,6 +36,7 @@ pub(in borrow_check) enum BorrowExplanation<'tcx> {\n \n #[derive(Clone, Copy)]\n pub(in borrow_check) enum LaterUseKind {\n+    TraitCapture,\n     ClosureCapture,\n     Call,\n     FakeLetRead,\n@@ -51,6 +54,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n         match *self {\n             BorrowExplanation::UsedLater(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n+                    LaterUseKind::TraitCapture => \"borrow later captured here by trait object\",\n                     LaterUseKind::ClosureCapture => \"borrow later captured here by closure\",\n                     LaterUseKind::Call =>  \"borrow later used by call\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n@@ -60,9 +64,10 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             },\n             BorrowExplanation::UsedLaterInLoop(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n-                    LaterUseKind::ClosureCapture => {\n-                        \"borrow captured here by closure, in later iteration of loop\"\n-                    },\n+                    LaterUseKind::TraitCapture =>\n+                        \"borrow later captured here by trait object, in later iteration of loop\",\n+                    LaterUseKind::ClosureCapture =>\n+                        \"borrow captured here by closure, in later iteration of loop\",\n                     LaterUseKind::Call =>  \"borrow used by call, in later iteration of loop\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow used here, in later iteration of loop\",\n@@ -200,13 +205,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 if self.is_borrow_location_in_loop(context.loc) {\n-                    let later_use = self.later_use_kind(spans, location);\n+                    let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)\n                 } else {\n                     // Check if the location represents a `FakeRead`, and adapt the error\n                     // message to the `FakeReadCause` it is from: in particular,\n                     // the ones inserted in optimized `let var = <expr>` patterns.\n-                    let later_use = self.later_use_kind(spans, location);\n+                    let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLater(later_use.0, later_use.1)\n                 }\n             }\n@@ -316,42 +321,136 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         false\n     }\n \n-    fn later_use_kind(&self, use_spans: UseSpans, location: Location) -> (LaterUseKind, Span) {\n-        use self::LaterUseKind::*;\n-\n-        let block = &self.mir.basic_blocks()[location.block];\n+    /// Determine how the borrow was later used.\n+    fn later_use_kind(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+        use_spans: UseSpans,\n+        location: Location\n+    ) -> (LaterUseKind, Span) {\n         match use_spans {\n-            UseSpans::ClosureUse { var_span, .. } => (LaterUseKind::ClosureCapture, var_span),\n+            UseSpans::ClosureUse { var_span, .. } => {\n+                // Used in a closure.\n+                (LaterUseKind::ClosureCapture, var_span)\n+            },\n             UseSpans::OtherUse(span) => {\n-                (if let Some(stmt) = block.statements.get(location.statement_index) {\n-                    match stmt.kind {\n-                        StatementKind::FakeRead(FakeReadCause::ForLet, _) => FakeLetRead,\n-                        _ => Other,\n+                let block = &self.mir.basic_blocks()[location.block];\n+\n+                let kind = if let Some(&Statement {\n+                    kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n+                    ..\n+                }) = block.statements.get(location.statement_index) {\n+                    LaterUseKind::FakeLetRead\n+                } else if self.was_captured_by_trait_object(borrow) {\n+                    LaterUseKind::TraitCapture\n+                } else if location.statement_index == block.statements.len() {\n+                    if let TerminatorKind::Call {\n+                        ref func, from_hir_call: true, ..\n+                    } = block.terminator().kind {\n+                        // Just point to the function, to reduce the chance of overlapping spans.\n+                        let function_span = match func {\n+                            Operand::Constant(c) => c.span,\n+                            Operand::Copy(Place::Local(l)) | Operand::Move(Place::Local(l)) => {\n+                                let local_decl = &self.mir.local_decls[*l];\n+                                if local_decl.name.is_none() {\n+                                    local_decl.source_info.span\n+                                } else {\n+                                    span\n+                                }\n+                            },\n+                            _ => span,\n+                        };\n+                        return (LaterUseKind::Call, function_span);\n+                    } else {\n+                        LaterUseKind::Other\n                     }\n                 } else {\n-                    assert_eq!(location.statement_index, block.statements.len());\n-                    match block.terminator().kind {\n-                        TerminatorKind::Call { ref func, from_hir_call: true, .. } => {\n-                            // Just point to the function, to reduce the chance\n-                            // of overlapping spans.\n-                            let function_span = match func {\n-                                Operand::Constant(c) => c.span,\n-                                Operand::Copy(Place::Local(l)) | Operand::Move(Place::Local(l)) => {\n-                                    let local_decl = &self.mir.local_decls[*l];\n-                                    if local_decl.name.is_none() {\n-                                        local_decl.source_info.span\n-                                    } else {\n-                                        span\n-                                    }\n-                                },\n-                                _ => span,\n-                            };\n-                            return (Call, function_span);\n-                        },\n-                        _ => Other,\n+                    LaterUseKind::Other\n+                };\n+\n+                (kind, span)\n+            }\n+        }\n+    }\n+\n+    /// Check if a borrowed value was captured by a trait object.\n+    fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n+        // In order to check if a value was captured by a trait object, we want to look through\n+        // statements after the reserve location in the current block. We expect the reserve\n+        // location to be a statement assigning to a local. We follow that local in the subsequent\n+        // statements, checking for an assignment of our local (or something intermediate that\n+        // it was assigned into) that results in a trait object.\n+        let location = borrow.reserve_location;\n+        let block = &self.mir[location.block];\n+        let stmt = block.statements.get(location.statement_index);\n+        debug!(\n+            \"was_captured_by_trait_object: location={:?} block={:?} stmt={:?}\",\n+            location, block, stmt\n+        );\n+        let mut target = if let Some(&Statement {\n+            kind: StatementKind::Assign(Place::Local(local), _),\n+            ..\n+        }) = stmt {\n+            local\n+        } else {\n+            return false;\n+        };\n+\n+        debug!(\"was_captured_by_trait_object: target={:?}\", target);\n+        for stmt in &block.statements[location.statement_index + 1..] {\n+            debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n+            // Simple case where our target is assigned into another local, and we start\n+            // watching that local instead.\n+            if let StatementKind::Assign(\n+                Place::Local(into),\n+                box Rvalue::Use(operand),\n+            ) = &stmt.kind {\n+                debug!(\"was_captured_by_trait_object: target={:?} operand={:?}\", target, operand);\n+                match operand {\n+                    Operand::Copy(Place::Local(from)) |\n+                    Operand::Move(Place::Local(from)) if *from == target => target = *into,\n+                    _ => {},\n+                }\n+            }\n+        }\n+\n+        if let Some(terminator) = &block.terminator {\n+            if let TerminatorKind::Call {\n+                destination: Some((Place::Local(dest), _)),\n+                args,\n+                ..\n+            } = &terminator.kind {\n+                debug!(\n+                    \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                    target, dest, args\n+                );\n+                let mut found_target = false;\n+                for arg in args {\n+                    if let Operand::Move(Place::Local(potential)) = arg {\n+                        if *potential == target {\n+                            found_target = true;\n+                        }\n+                    }\n+                }\n+\n+                if found_target {\n+                    let local_decl_ty = &self.mir.local_decls[*dest].ty;\n+                    debug!(\"was_captured_by_trait_object: local_decl_ty={:?}\", local_decl_ty);\n+                    match local_decl_ty.sty {\n+                        // `&dyn Trait`\n+                        ty::TyKind::Ref(_, ty, _) if ty.is_trait() => return true,\n+                        // `Box<dyn Trait>`\n+                        _ if local_decl_ty.is_box() && local_decl_ty.boxed_ty().is_trait() =>\n+                            return true,\n+                        // `dyn Trait`\n+                        _ if local_decl_ty.is_trait() => return true,\n+                        // Anything else.\n+                        _ => return false,\n                     }\n-                }, span)\n+                }\n             }\n         }\n+\n+        false\n     }\n }"}, {"sha": "11fa447b5489a0e7739e0271bde49cd3a9ff647c", "filename": "src/test/ui/span/regions-close-over-type-parameter-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b71f5e9416b570b3e4c1997056c3879e5029af/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b71f5e9416b570b3e4c1997056c3879e5029af/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr?ref=91b71f5e9416b570b3e4c1997056c3879e5029af", "patch": "@@ -4,7 +4,7 @@ error[E0597]: `tmp0` does not live long enough\n LL |         let tmp1 = &tmp0;\n    |                    ^^^^^ borrowed value does not live long enough\n LL |         repeater3(tmp1)\n-   |         --------------- borrow later used here\n+   |         --------------- borrow later captured here by trait object\n LL |     };\n    |     - `tmp0` dropped here while still borrowed\n "}]}