{"sha": "15ba0c310a2bfe2ab69670d0d87529a29d527973", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YmEwYzMxMGEyYmZlMmFiNjk2NzBkMGQ4NzUyOWEyOWQ1Mjc5NzM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-27T12:18:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-27T12:31:24Z"}, "message": "Demote self to an (almost) regular argument and remove the env param.\nFixes #10667 and closes #10259.", "tree": {"sha": "0335308a02e566557ba2200fd0b50e8d7b2d5ab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0335308a02e566557ba2200fd0b50e8d7b2d5ab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ba0c310a2bfe2ab69670d0d87529a29d527973", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ba0c310a2bfe2ab69670d0d87529a29d527973", "html_url": "https://github.com/rust-lang/rust/commit/15ba0c310a2bfe2ab69670d0d87529a29d527973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ba0c310a2bfe2ab69670d0d87529a29d527973/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0280ac5385433bd663e825e24f6990a816a5f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0280ac5385433bd663e825e24f6990a816a5f40", "html_url": "https://github.com/rust-lang/rust/commit/b0280ac5385433bd663e825e24f6990a816a5f40"}], "stats": {"total": 3574, "additions": 1436, "deletions": 2138}, "files": [{"sha": "c621461fc36a05a20df443345664d89340b6f737", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -895,7 +895,7 @@ pub fn run_test(force_ignore: bool,\n             return;\n         }\n         StaticBenchFn(benchfn) => {\n-            let bs = ::test::bench::benchmark(benchfn);\n+            let bs = ::test::bench::benchmark(|harness| benchfn(harness));\n             monitor_ch.send((desc, TrBench(bs)));\n             return;\n         }"}, {"sha": "e8cfa97c0e1c881bc1fe0e3a1ae2d2119feb0f12", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -176,24 +176,23 @@ pub static tag_link_args_arg: uint = 0x7a;\n \n pub static tag_item_method_tps: uint = 0x7b;\n pub static tag_item_method_fty: uint = 0x7c;\n-pub static tag_item_method_transformed_self_ty: uint = 0x7d;\n \n-pub static tag_mod_child: uint = 0x7e;\n-pub static tag_misc_info: uint = 0x7f;\n-pub static tag_misc_info_crate_items: uint = 0x80;\n+pub static tag_mod_child: uint = 0x7d;\n+pub static tag_misc_info: uint = 0x7e;\n+pub static tag_misc_info_crate_items: uint = 0x7f;\n \n-pub static tag_item_method_provided_source: uint = 0x81;\n-pub static tag_item_impl_vtables: uint = 0x82;\n+pub static tag_item_method_provided_source: uint = 0x80;\n+pub static tag_item_impl_vtables: uint = 0x81;\n \n-pub static tag_impls: uint = 0x83;\n-pub static tag_impls_impl: uint = 0x84;\n+pub static tag_impls: uint = 0x82;\n+pub static tag_impls_impl: uint = 0x83;\n \n-pub static tag_items_data_item_inherent_impl: uint = 0x85;\n-pub static tag_items_data_item_extension_impl: uint = 0x86;\n+pub static tag_items_data_item_inherent_impl: uint = 0x84;\n+pub static tag_items_data_item_extension_impl: uint = 0x85;\n \n-pub static tag_path_elem_pretty_name: uint = 0x87;\n-pub static tag_path_elem_pretty_name_ident: uint = 0x88;\n-pub static tag_path_elem_pretty_name_extra: uint = 0x89;\n+pub static tag_path_elem_pretty_name: uint = 0x86;\n+pub static tag_path_elem_pretty_name_ident: uint = 0x87;\n+pub static tag_path_elem_pretty_name_extra: uint = 0x88;\n \n pub static tag_region_param_def: uint = 0x100;\n pub static tag_region_param_def_ident: uint = 0x101;"}, {"sha": "11fab9cced7f7ac240ac1fcc967fd65c0e1b6daa", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -227,16 +227,6 @@ fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n                           |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_transformed_self_ty(doc: ebml::Doc,\n-                           tcx: ty::ctxt,\n-                           cdata: Cmd) -> Option<ty::t>\n-{\n-    reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map(|tp| {\n-        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n-                      |_, did| translate_def_id(cdata, did))\n-    })\n-}\n-\n pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n@@ -781,9 +771,9 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     let explicit_self_kind = string[0];\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n-        'v' => ast::SelfValue(get_mutability(string[1])),\n+        'v' => ast::SelfValue,\n         '@' => ast::SelfBox,\n-        '~' => ast::SelfUniq(get_mutability(string[1])),\n+        '~' => ast::SelfUniq,\n         // FIXME(#4846) expl. region\n         '&' => ast::SelfRegion(None, get_mutability(string[1])),\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n@@ -847,7 +837,6 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n     let rp_defs = item_region_param_defs(method_doc, tcx, cdata);\n-    let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n@@ -859,7 +848,6 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n             type_param_defs: type_param_defs,\n             region_param_defs: rp_defs,\n         },\n-        transformed_self_ty,\n         fty,\n         explicit_self,\n         vis,"}, {"sha": "8a2c56cbcd35ab3baae8889d9781412eb6f5029f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -261,16 +261,6 @@ fn encode_type(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_transformed_self_ty(ecx: &EncodeContext,\n-                              ebml_w: &mut writer::Encoder,\n-                              opt_typ: Option<ty::t>) {\n-    for &typ in opt_typ.iter() {\n-        ebml_w.start_tag(tag_item_method_transformed_self_ty);\n-        write_type(ecx, ebml_w, typ);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n fn encode_method_fty(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      typ: &ty::BareFnTy) {\n@@ -679,23 +669,13 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     // Encode the base self type.\n     match explicit_self {\n-        SelfStatic => {\n-            ebml_w.writer.write(&[ 's' as u8 ]);\n-        }\n-        SelfValue(m) => {\n-            ebml_w.writer.write(&[ 'v' as u8 ]);\n-            encode_mutability(ebml_w, m);\n-        }\n+        SelfStatic => ebml_w.writer.write(&[ 's' as u8 ]),\n+        SelfValue  => ebml_w.writer.write(&[ 'v' as u8 ]),\n+        SelfBox    => ebml_w.writer.write(&[ '@' as u8 ]),\n+        SelfUniq   => ebml_w.writer.write(&[ '~' as u8 ]),\n         SelfRegion(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            ebml_w.writer.write(&[ '&' as u8 ]);\n-            encode_mutability(ebml_w, m);\n-        }\n-        SelfBox => {\n-            ebml_w.writer.write(&[ '@' as u8 ]);\n-        }\n-        SelfUniq(m) => {\n-            ebml_w.writer.write(&[ '~' as u8 ]);\n+            ebml_w.writer.write(&['&' as u8]);\n             encode_mutability(ebml_w, m);\n         }\n     }\n@@ -807,7 +787,6 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_ty_type_param_defs(ebml_w, ecx,\n                               method_ty.generics.type_param_defs,\n                               tag_item_method_tps);\n-    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n     encode_explicit_self(ebml_w, method_ty.explicit_self);"}, {"sha": "a40ba4a44a5db62904d70f5d96e4cc477e6df6fd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -374,10 +374,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n-      'C' => {\n-        let sigil = parse_sigil(st);\n-        return ty::mk_opaque_closure_ptr(st.tcx, sigil);\n-      }\n       '#' => {\n         let pos = parse_hex(st);\n         assert_eq!(next(st), ':');"}, {"sha": "23e96110c066568dd1e32f341f3501d15a5bf7f2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -327,10 +327,6 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             mywrite!(w, \"s{}|\", (cx.ds)(did));\n         }\n         ty::ty_type => mywrite!(w, \"Y\"),\n-        ty::ty_opaque_closure_ptr(p) => {\n-            mywrite!(w, \"C&\");\n-            enc_sigil(w, p);\n-        }\n         ty::ty_struct(def, ref substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);"}, {"sha": "a601b624c1979f6f6185350b94219380641bceb5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -435,7 +435,6 @@ impl tr for ast::Def {\n             ast::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n           ast::DefSelfTy(nid) => { ast::DefSelfTy(xcx.tr_id(nid)) }\n-          ast::DefSelf(nid, m) => { ast::DefSelf(xcx.tr_id(nid), m) }\n           ast::DefMod(did) => { ast::DefMod(did.tr(xcx)) }\n           ast::DefForeignMod(did) => { ast::DefForeignMod(did.tr(xcx)) }\n           ast::DefStatic(did, m) => { ast::DefStatic(did.tr(xcx), m) }\n@@ -579,16 +578,8 @@ trait read_method_map_entry_helper {\n                              -> method_map_entry;\n }\n \n-fn encode_method_map_entry(ecx: &e::EncodeContext,\n-                           ebml_w: &mut writer::Encoder,\n-                           mme: method_map_entry) {\n+fn encode_method_map_entry(ebml_w: &mut writer::Encoder, mme: method_map_entry) {\n     ebml_w.emit_struct(\"method_map_entry\", 3, |ebml_w| {\n-        ebml_w.emit_struct_field(\"self_ty\", 0u, |ebml_w| {\n-            ebml_w.emit_ty(ecx, mme.self_ty);\n-        });\n-        ebml_w.emit_struct_field(\"explicit_self\", 2u, |ebml_w| {\n-            mme.explicit_self.encode(ebml_w);\n-        });\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             mme.origin.encode(ebml_w);\n         });\n@@ -600,15 +591,6 @@ impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n                              -> method_map_entry {\n         self.read_struct(\"method_map_entry\", 3, |this| {\n             method_map_entry {\n-                self_ty: this.read_struct_field(\"self_ty\", 0u, |this| {\n-                    this.read_ty(xcx)\n-                }),\n-                explicit_self: this.read_struct_field(\"explicit_self\",\n-                                                      2,\n-                                                      |this| {\n-                    let explicit_self: ast::ExplicitSelf_ = Decodable::decode(this);\n-                    explicit_self\n-                }),\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: method_origin =\n                         Decodable::decode(this);\n@@ -1043,7 +1025,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    encode_method_map_entry(ecx, ebml_w, *mme)\n+                    encode_method_map_entry(ebml_w, *mme)\n                 })\n             })\n         }"}, {"sha": "59310d722e426441f3f5a3ae93acc72b463cec61", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -371,9 +371,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 debug!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n                 match cmt.cat {\n-                    mc::cat_local(id) |\n-                    mc::cat_arg(id) |\n-                    mc::cat_self(id) => {\n+                    mc::cat_local(id) | mc::cat_arg(id) => {\n                         let mut used_mut_nodes = this.tcx()\n                                                      .used_mut_nodes\n                                                      .borrow_mut();\n@@ -459,7 +457,6 @@ impl<'a> CheckLoanCtxt<'a> {\n                     mc::cat_rvalue(..) |\n                     mc::cat_local(..) |\n                     mc::cat_arg(_) |\n-                    mc::cat_self(..) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n                     mc::cat_static_item(..) |\n                     mc::cat_deref(_, _, mc::gc_ptr) |\n@@ -790,7 +787,6 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n \n     let method_map = this.bccx.method_map.borrow();\n     match expr.node {\n-      ast::ExprSelf |\n       ast::ExprPath(..) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n@@ -808,32 +804,24 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       ast::ExprCall(f, ref args, _) => {\n         this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::ExprMethodCall(callee_id, _, _, _, ref args, _) => {\n+      ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n         this.check_call(expr, None, callee_id, expr.span, *args);\n       }\n       ast::ExprIndex(callee_id, _, rval) |\n       ast::ExprBinary(callee_id, _, _, rval)\n       if method_map.get().contains_key(&expr.id) => {\n-        this.check_call(expr,\n-                        None,\n-                        callee_id,\n-                        expr.span,\n-                        [rval]);\n+        this.check_call(expr, None, callee_id, expr.span, [rval]);\n       }\n       ast::ExprUnary(callee_id, _, _) | ast::ExprIndex(callee_id, _, _)\n       if method_map.get().contains_key(&expr.id) => {\n-        this.check_call(expr,\n-                        None,\n-                        callee_id,\n-                        expr.span,\n-                        []);\n+        this.check_call(expr, None, callee_id, expr.span, []);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, out) in ia.outputs.iter() {\n               this.check_assignment(out);\n           }\n       }\n-      _ => { }\n+      _ => {}\n     }\n }\n "}, {"sha": "78350a993b483c205c72d31db9794d7445f60581", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -133,8 +133,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n \n         mc::cat_rvalue(..) |\n         mc::cat_local(..) |\n-        mc::cat_arg(..) |\n-        mc::cat_self(..) => {\n+        mc::cat_arg(..) => {\n             true\n         }\n "}, {"sha": "4c2f0986d9cc21e5ff7180ed618929d053a6a468", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -76,7 +76,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n             mc::cat_arg(..) |                           // L-Local\n-            mc::cat_self(..) |                          // L-Local\n             mc::cat_deref(_, _, mc::region_ptr(..)) |   // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n                 let scope = self.scope(cmt);\n@@ -261,7 +260,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n \n         match cmt.guarantor().cat {\n             mc::cat_local(id) |\n-            mc::cat_self(id) |\n             mc::cat_arg(id) => {\n                 let moved_variables_set = self.bccx\n                                               .moved_variables_set\n@@ -303,8 +301,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 ty::ReStatic\n             }\n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) |\n-            mc::cat_self(local_id) => {\n+            mc::cat_arg(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n             mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {"}, {"sha": "22e64064c9ce56ec46200ac3dae42888104c3bdd", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -74,8 +74,7 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) |\n-            mc::cat_self(local_id) => {\n+            mc::cat_arg(local_id) => {\n                 // R-Variable\n                 let lp = @LpVar(local_id);\n                 SafeIf(lp, ~[Restriction {loan_path: lp,"}, {"sha": "90c9a61b18b170266a3aa69286a8546070bce9fd", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -25,6 +25,7 @@ use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n@@ -294,9 +295,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n             None\n         }\n \n-        mc::cat_local(id) |\n-        mc::cat_arg(id) |\n-        mc::cat_self(id) => {\n+        mc::cat_local(id) | mc::cat_arg(id) => {\n             Some(@LpVar(id))\n         }\n \n@@ -771,8 +770,18 @@ impl BorrowckCtxt {\n         match *loan_path {\n             LpVar(id) => {\n                 match self.tcx.items.find(id) {\n-                    Some(ast_map::NodeLocal(ref ident, _)) => {\n-                        out.push_str(token::ident_to_str(ident));\n+                    Some(ast_map::NodeLocal(pat)) => {\n+                        match pat.node {\n+                            ast::PatIdent(_, ref path, _) => {\n+                                let ident = ast_util::path_to_ident(path);\n+                                out.push_str(token::ident_to_str(&ident));\n+                            }\n+                            _ => {\n+                                self.tcx.sess.bug(\n+                                    format!(\"Loan path LpVar({:?}) maps to {:?}, not local\",\n+                                        id, pat));\n+                            }\n+                        }\n                     }\n                     r => {\n                         self.tcx.sess.bug("}, {"sha": "923e5eba109473d6d30089abada9a7b90780c8da", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -355,8 +355,8 @@ impl CFGBuilder {\n                 self.call(expr, pred, func, *args)\n             }\n \n-            ast::ExprMethodCall(_, rcvr, _, _, ref args, _) => {\n-                self.call(expr, pred, rcvr, *args)\n+            ast::ExprMethodCall(_, _, _, ref args, _) => {\n+                self.call(expr, pred, args[0], args.slice_from(1))\n             }\n \n             ast::ExprIndex(_, l, r) |\n@@ -410,7 +410,6 @@ impl CFGBuilder {\n             ast::ExprLogLevel |\n             ast::ExprMac(..) |\n             ast::ExprInlineAsm(..) |\n-            ast::ExprSelf |\n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) |\n             ast::ExprLit(..) |"}, {"sha": "a0ef6e503a1271cd48866d6b70d6a84b6470b678", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -668,24 +668,21 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprCall(f, ref args, _) => {\n-                self.walk_call(f.id, expr.id,\n-                               f, *args, in_out, loop_scopes);\n+                self.walk_expr(f, in_out, loop_scopes);\n+                self.walk_call(f.id, expr.id, *args, in_out, loop_scopes);\n             }\n \n-            ast::ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n-                self.walk_call(callee_id, expr.id,\n-                               rcvr, *args, in_out, loop_scopes);\n+            ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+                self.walk_call(callee_id, expr.id, *args, in_out, loop_scopes);\n             }\n \n             ast::ExprIndex(callee_id, l, r) |\n             ast::ExprBinary(callee_id, _, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(callee_id, expr.id,\n-                               l, [r], in_out, loop_scopes);\n+                self.walk_call(callee_id, expr.id, [l, r], in_out, loop_scopes);\n             }\n \n             ast::ExprUnary(callee_id, _, e) if self.is_method_call(expr) => {\n-                self.walk_call(callee_id, expr.id,\n-                               e, [], in_out, loop_scopes);\n+                self.walk_call(callee_id, expr.id, [e], in_out, loop_scopes);\n             }\n \n             ast::ExprTup(ref exprs) => {\n@@ -706,9 +703,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprLogLevel |\n             ast::ExprLit(..) |\n-            ast::ExprPath(..) |\n-            ast::ExprSelf => {\n-            }\n+            ast::ExprPath(..) => {}\n \n             ast::ExprAddrOf(_, e) |\n             ast::ExprDoBody(e) |\n@@ -813,11 +808,9 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_call(&mut self,\n                  _callee_id: ast::NodeId,\n                  call_id: ast::NodeId,\n-                 arg0: &ast::Expr,\n                  args: &[@ast::Expr],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n-        self.walk_expr(arg0, in_out, loop_scopes);\n         self.walk_exprs(args, in_out, loop_scopes);\n \n         // FIXME(#6268) nested method calls"}, {"sha": "36dd46388c6243691db329282c292b62c270607f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -120,7 +120,7 @@ impl Visitor<()> for EffectCheckVisitor {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n-            ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n+            ast::ExprMethodCall(callee_id, _, _, _, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, callee_id);\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));"}, {"sha": "635fbf7eea81662007f59469dae7a86a0b832dd2", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -48,7 +48,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n             ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n                 visit::walk_expr(self, expr, depth + 1)\n             }\n-            ast::ExprPath(..) | ast::ExprSelf => {\n+            ast::ExprPath(..) => {\n                 let mut i = 0;\n                 let def_map = self.def_map.borrow();\n                 match def_map.get().find(&expr.id) {"}, {"sha": "81a00e27fa05615b08dda5013070a8298afe1dc2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -454,9 +454,8 @@ fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n                 sp,\n                 \"mutable variables cannot be implicitly captured\");\n         }\n-        DefLocal(..) | DefArg(..) => { /* ok */ }\n+        DefLocal(..) | DefArg(..) | DefBinding(..) => { /* ok */ }\n         DefUpvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n-        DefBinding(..) | DefSelf(..) => { /*ok*/ }\n         _ => {\n             cx.tcx.sess.span_bug(\n                 sp,"}, {"sha": "dfe9af9f3f039a0f38854af2820bf4d94486edb8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -405,20 +405,6 @@ fn visit_fn(v: &mut LivenessVisitor,\n         })\n     };\n \n-    // Add `this`, whether explicit or implicit.\n-    match *fk {\n-        visit::FkMethod(_, _, method) => {\n-            match method.explicit_self.node {\n-                SelfValue(_) | SelfRegion(..) | SelfBox | SelfUniq(_) => {\n-                    fn_maps.add_variable(Arg(method.self_id,\n-                                             special_idents::self_));\n-                }\n-                SelfStatic => {}\n-            }\n-        }\n-        visit::FkItemFn(..) | visit::FkFnBlock(..) => {}\n-    }\n-\n     // gather up the various local variables, significant expressions,\n     // and so forth:\n     visit::walk_fn(v, fk, decl, body, sp, id, fn_maps);\n@@ -493,7 +479,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @IrMaps) {\n fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ExprPath(_) | ExprSelf => {\n+      ExprPath(_) => {\n         let def_map = this.tcx.def_map.borrow();\n         let def = def_map.get().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n@@ -1050,7 +1036,7 @@ impl Liveness {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ExprPath(_) | ExprSelf => {\n+          ExprPath(_) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n@@ -1229,14 +1215,13 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n-          ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n+          ExprMethodCall(callee_id, _, _, ref args, _) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, callee_id));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            let succ = self.propagate_through_exprs(*args, succ);\n-            self.propagate_through_expr(rcvr, succ)\n+            self.propagate_through_exprs(*args, succ)\n           }\n \n           ExprTup(ref exprs) => {\n@@ -1549,7 +1534,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprPath(..) |\n-      ExprSelf(..) | ExprBox(..) => {\n+      ExprBox(..) => {\n         visit::walk_expr(this, expr, ());\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n@@ -1694,9 +1679,13 @@ impl Liveness {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(self.tcx.def_map,\n                                    arg.pat,\n-                                   |_bm, p_id, sp, _n| {\n+                                   |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);\n-                self.warn_about_unused(sp, p_id, entry_ln, var);\n+                // Ignore unused self.\n+                let ident = ast_util::path_to_ident(path);\n+                if ident.name != special_idents::self_.name {\n+                    self.warn_about_unused(sp, p_id, entry_ln, var);\n+                }\n             })\n         }\n     }"}, {"sha": "b6271b68046ad9b769a14d27ac1cebf9b3a830d9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -70,7 +70,6 @@ pub enum categorization {\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (..)\n     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n-    cat_self(ast::NodeId),             // explicit `self`\n \n     // (..) downcast is only required if the enum has more than one variant\n }\n@@ -426,7 +425,7 @@ impl mem_categorization_ctxt {\n             self.cat_index(expr, base_cmt, 0)\n           }\n \n-          ast::ExprPath(_) | ast::ExprSelf => {\n+          ast::ExprPath(_) => {\n             let def_map = self.tcx.def_map.borrow();\n             let def = def_map.get().get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n@@ -503,16 +502,6 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::DefSelf(self_id, mutbl) => {\n-            @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_self(self_id),\n-                mutbl: if mutbl { McDeclared } else { McImmutable },\n-                ty:expr_ty\n-            }\n-          }\n-\n           ast::DefUpvar(upvar_id, inner, fn_node_id, _) => {\n               let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n               match ty::get(ty).sty {\n@@ -1032,9 +1021,6 @@ impl mem_categorization_ctxt {\n           cat_local(_) => {\n               ~\"local variable\"\n           }\n-          cat_self(_) => {\n-              ~\"self value\"\n-          }\n           cat_arg(..) => {\n               ~\"argument\"\n           }\n@@ -1129,7 +1115,6 @@ impl cmt_ {\n             cat_static_item |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_self(..) |\n             cat_arg(..) |\n             cat_deref(_, _, unsafe_ptr(..)) |\n             cat_deref(_, _, gc_ptr) |\n@@ -1165,7 +1150,6 @@ impl cmt_ {\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_arg(_) |\n-            cat_self(..) |\n             cat_deref(_, _, unsafe_ptr(..)) | // of course it is aliasable, but...\n             cat_deref(_, _, region_ptr(MutMutable, _)) => {\n                 None\n@@ -1212,7 +1196,6 @@ impl Repr for categorization {\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_self(..) |\n             cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }"}, {"sha": "054e2936439371f9b28b05db9e78b196199b77b4", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -227,10 +227,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n \n pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n     match def {\n-      DefBinding(nid, _) |\n-      DefArg(nid, _) |\n-      DefLocal(nid, _) |\n-      DefSelf(nid, _) => Some(nid),\n+        DefBinding(nid, _) |\n+        DefArg(nid, _) |\n+        DefLocal(nid, _) => Some(nid),\n \n       _ => None\n     }\n@@ -344,7 +343,7 @@ impl VisitContext {\n         debug!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n-            ExprPath(..) | ExprSelf => {\n+            ExprPath(..) => {\n                 match comp_mode {\n                     Move => {\n                         let def_map = self.tcx.def_map.borrow();\n@@ -413,10 +412,7 @@ impl VisitContext {\n                 self.use_fn_args(callee.id, *args);\n             }\n \n-            ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n-                // Implicit self is equivalent to & mode, but every\n-                // other kind should be + mode.\n-                self.use_receiver(rcvr);\n+            ExprMethodCall(callee_id, _, _, ref args, _) => { // callee.m(args)\n                 self.use_fn_args(callee_id, *args);\n             }\n \n@@ -620,7 +616,7 @@ impl VisitContext {\n             return false;\n         }\n \n-        self.use_receiver(receiver_expr);\n+        self.use_fn_arg(receiver_expr);\n \n         // for overloaded operatrs, we are always passing in a\n         // reference, so it's always read mode:\n@@ -675,11 +671,6 @@ impl VisitContext {\n         })\n     }\n \n-    pub fn use_receiver(&mut self,\n-                        receiver_expr: @Expr) {\n-        self.use_fn_arg(receiver_expr);\n-    }\n-\n     pub fn use_fn_args(&mut self,\n                        _: NodeId,\n                        arg_exprs: &[@Expr]) {"}, {"sha": "2562c34b54b00e4661de9362727a93abbce3400c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -688,9 +688,9 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     _ => {}\n                 }\n             }\n-            ast::ExprMethodCall(_, base, ident, _, _, _) => {\n+            ast::ExprMethodCall(_, ident, _, ref args, _) => {\n                 // see above\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n+                let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n                         let method_map = self.method_map.borrow();"}, {"sha": "4ebbd097f2922b693b6931d546217991bb48b175", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -820,12 +820,6 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     // The arguments and `self` are parented to the body of the fn.\n     let decl_cx = Context {parent: Some(body.id),\n                            var_parent: Some(body.id)};\n-    match *fk {\n-        visit::FkMethod(_, _, method) => {\n-            visitor.region_maps.record_var_scope(method.self_id, body.id);\n-        }\n-        _ => {}\n-    }\n     visit::walk_fn_decl(visitor, decl, decl_cx);\n \n     // The body of the fn itself is either a root scope (top-level fn)"}, {"sha": "dab9c7c71d9685f3047148fa062197366c5cfc3b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 21, "deletions": 126, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -130,11 +130,6 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-enum SelfBinding {\n-    NoSelfBinding,\n-    HasSelfBinding(NodeId, ExplicitSelf)\n-}\n-\n impl Visitor<()> for Resolver {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         self.resolve_item(item);\n@@ -258,12 +253,6 @@ enum ModulePrefixResult {\n     PrefixFound(@Module, uint)\n }\n \n-#[deriving(Eq)]\n-enum AllowCapturingSelfFlag {\n-    AllowCapturingSelf,         //< The \"self\" definition can be captured.\n-    DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n-}\n-\n #[deriving(Eq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -294,15 +283,13 @@ enum DuplicateCheckingMode {\n /// One local scope.\n struct Rib {\n     bindings: RefCell<HashMap<Name, DefLike>>,\n-    self_binding: RefCell<Option<DefLike>>,\n     kind: RibKind,\n }\n \n impl Rib {\n     fn new(kind: RibKind) -> Rib {\n         Rib {\n             bindings: RefCell::new(HashMap::new()),\n-            self_binding: RefCell::new(None),\n             kind: kind\n         }\n     }\n@@ -1746,8 +1733,8 @@ impl Resolver {\n                       ignoring {:?}\", def);\n               // Ignored; handled elsewhere.\n           }\n-          DefSelf(..) | DefArg(..) | DefLocal(..) |\n-          DefPrimTy(..) | DefTyParam(..) | DefBinding(..) |\n+          DefArg(..) | DefLocal(..) | DefPrimTy(..) |\n+          DefTyParam(..) | DefBinding(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n             fail!(\"didn't expect `{:?}`\", def);\n@@ -3469,8 +3456,7 @@ impl Resolver {\n                     ribs: &mut ~[@Rib],\n                     rib_index: uint,\n                     def_like: DefLike,\n-                    span: Span,\n-                    allow_capturing_self: AllowCapturingSelfFlag)\n+                    span: Span)\n                     -> Option<DefLike> {\n         let mut def;\n         let is_ty_param;\n@@ -3485,11 +3471,6 @@ impl Resolver {\n                 def = d;\n                 is_ty_param = true;\n             }\n-            DlDef(d @ DefSelf(..))\n-                    if allow_capturing_self == DontAllowCapturingSelf => {\n-                def = d;\n-                is_ty_param = false;\n-            }\n             _ => {\n                 return Some(def_like);\n             }\n@@ -3589,8 +3570,7 @@ impl Resolver {\n     fn search_ribs(&mut self,\n                        ribs: &mut ~[@Rib],\n                        name: Name,\n-                       span: Span,\n-                       allow_capturing_self: AllowCapturingSelfFlag)\n+                       span: Span)\n                        -> Option<DefLike> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n@@ -3604,8 +3584,7 @@ impl Resolver {\n             };\n             match binding_opt {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs, i, def_like, span,\n-                                         allow_capturing_self);\n+                    return self.upvarify(ribs, i, def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -3786,8 +3765,7 @@ impl Resolver {\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n-                                      block,\n-                                      NoSelfBinding);\n+                                      block);\n             }\n \n             ItemStatic(..) => {\n@@ -3883,11 +3861,10 @@ impl Resolver {\n     }\n \n     fn resolve_function(&mut self,\n-                            rib_kind: RibKind,\n-                            optional_declaration: Option<P<FnDecl>>,\n-                            type_parameters: TypeParameters,\n-                            block: P<Block>,\n-                            self_binding: SelfBinding) {\n+                        rib_kind: RibKind,\n+                        optional_declaration: Option<P<FnDecl>>,\n+                        type_parameters: TypeParameters,\n+                        block: P<Block>) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib::new(rib_kind);\n         {\n@@ -3914,21 +3891,6 @@ impl Resolver {\n                 }\n             }\n \n-            // Add self to the rib, if necessary.\n-            match self_binding {\n-                NoSelfBinding => {\n-                    // Nothing to do.\n-                }\n-                HasSelfBinding(self_node_id, explicit_self) => {\n-                    let mutable = match explicit_self.node {\n-                        SelfUniq(m) | SelfValue(m) if m == MutMutable => true,\n-                        _ => false\n-                    };\n-                    let def_like = DlDef(DefSelf(self_node_id, mutable));\n-                    function_value_rib.self_binding.set(Some(def_like));\n-                }\n-            }\n-\n             // Add each argument to the rib.\n             match optional_declaration {\n                 None => {\n@@ -4050,26 +4012,17 @@ impl Resolver {\n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n     fn resolve_method(&mut self,\n-                          rib_kind: RibKind,\n-                          method: @Method,\n-                          outer_type_parameter_count: uint) {\n+                      rib_kind: RibKind,\n+                      method: @Method,\n+                      outer_type_parameter_count: uint) {\n         let method_generics = &method.generics;\n         let type_parameters =\n             HasTypeParameters(method_generics,\n                               method.id,\n                               outer_type_parameter_count,\n                               rib_kind);\n-        // we only have self ty if it is a non static method\n-        let self_binding = match method.explicit_self.node {\n-            SelfStatic => NoSelfBinding,\n-            _ => HasSelfBinding(method.self_id, method.explicit_self)\n-        };\n \n-        self.resolve_function(rib_kind,\n-                              Some(method.decl),\n-                              type_parameters,\n-                              method.body,\n-                              self_binding);\n+        self.resolve_function(rib_kind, Some(method.decl), type_parameters, method.body);\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -4135,9 +4088,7 @@ impl Resolver {\n                                              method.id,\n                                              outer_type_parameter_count,\n                                              NormalRibKind),\n-                                          method.body,\n-                                          HasSelfBinding(method.self_id),\n-                                          visitor);\n+                                          method.body);\n */\n             }\n \n@@ -4974,16 +4925,14 @@ impl Resolver {\n                 let mut value_ribs = self.value_ribs.borrow_mut();\n                 search_result = self.search_ribs(value_ribs.get(),\n                                                  renamed,\n-                                                 span,\n-                                                 DontAllowCapturingSelf);\n+                                                 span);\n             }\n             TypeNS => {\n                 let name = ident.name;\n                 let mut type_ribs = self.type_ribs.borrow_mut();\n                 search_result = self.search_ribs(type_ribs.get(),\n                                                  name,\n-                                                 span,\n-                                                 AllowCapturingSelf);\n+                                                 span);\n             }\n         }\n \n@@ -5001,46 +4950,6 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_self_value_in_local_ribs(&mut self, span: Span)\n-                                            -> Option<Def> {\n-        // FIXME #4950: This should not use a while loop.\n-        let mut i = {\n-            let value_ribs = self.value_ribs.borrow();\n-            value_ribs.get().len()\n-        };\n-        while i != 0 {\n-            i -= 1;\n-            let self_binding_opt = {\n-                let value_ribs = self.value_ribs.borrow();\n-                value_ribs.get()[i].self_binding.get()\n-            };\n-            match self_binding_opt {\n-                Some(def_like) => {\n-                    let mut value_ribs = self.value_ribs.borrow_mut();\n-                    match self.upvarify(value_ribs.get(),\n-                                        i,\n-                                        def_like,\n-                                        span,\n-                                        DontAllowCapturingSelf) {\n-                        Some(DlDef(def)) => return Some(def),\n-                        _ => {\n-                            if self.session.has_errors() {\n-                                // May happen inside a nested fn item, cf #6642.\n-                                return None;\n-                            } else {\n-                                self.session.span_bug(span,\n-                                        \"self wasn't mapped to a def?!\")\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn resolve_item_by_identifier_in_lexical_scope(&mut self,\n                                                    ident: Ident,\n                                                    namespace: Namespace)\n@@ -5224,10 +5133,8 @@ impl Resolver {\n             ExprFnBlock(fn_decl, block) |\n             ExprProc(fn_decl, block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n-                                      Some(fn_decl),\n-                                      NoTypeParameters,\n-                                      block,\n-                                      NoSelfBinding);\n+                                      Some(fn_decl), NoTypeParameters,\n+                                      block);\n             }\n \n             ExprStruct(ref path, _, _) => {\n@@ -5274,8 +5181,7 @@ impl Resolver {\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let mut label_ribs = self.label_ribs.borrow_mut();\n-                match self.search_ribs(label_ribs.get(), label, expr.span,\n-                                       DontAllowCapturingSelf) {\n+                match self.search_ribs(label_ribs.get(), label, expr.span) {\n                     None =>\n                         self.resolve_error(expr.span,\n                                               format!(\"use of undeclared label \\\n@@ -5293,17 +5199,6 @@ impl Resolver {\n                 }\n             }\n \n-            ExprSelf => {\n-                match self.resolve_self_value_in_local_ribs(expr.span) {\n-                    None => {\n-                        self.resolve_error(expr.span,\n-                                              \"`self` is not allowed in \\\n-                                               this context\")\n-                    }\n-                    Some(def) => self.record_def(expr.id, (def, AllPublic)),\n-                }\n-            }\n-\n             _ => {\n                 visit::walk_expr(self, expr, ());\n             }\n@@ -5320,7 +5215,7 @@ impl Resolver {\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @RefCell::new(traits));\n             }\n-            ExprMethodCall(_, _, ident, _, _, _) => {\n+            ExprMethodCall(_, ident, _, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);"}, {"sha": "d5022b2a4df16830e4d9c6fbf01ff53cf8638daa", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -337,8 +337,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             return adt::trans_case(bcx, repr, disr_val);\n         }\n         range(l1, l2) => {\n-            let (l1, _) = consts::const_expr(ccx, l1);\n-            let (l2, _) = consts::const_expr(ccx, l2);\n+            let (l1, _) = consts::const_expr(ccx, l1, true);\n+            let (l2, _) = consts::const_expr(ccx, l2, true);\n             return range_result(rslt(bcx, l1), rslt(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {"}, {"sha": "c71469f0c3db0817d3c18eae33a1b43e78ec8f3a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 92, "deletions": 155, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -240,7 +240,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n         }\n     }\n \n-    let f = decl_rust_fn(ccx, None, inputs, output, name);\n+    let f = decl_rust_fn(ccx, false, inputs, output, name);\n     csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n@@ -250,16 +250,15 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     f\n }\n \n-fn decl_rust_fn(ccx: &CrateContext,\n-                self_ty: Option<ty::t>,\n-                inputs: &[ty::t],\n-                output: ty::t,\n-                name: &str) -> ValueRef {\n-    let llfty = type_of_rust_fn(ccx, self_ty, inputs, output);\n+pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n+                    inputs: &[ty::t], output: ty::t,\n+                    name: &str) -> ValueRef {\n+    let llfty = type_of_rust_fn(ccx, has_env, inputs, output);\n     let llfn = decl_cdecl_fn(ccx.llmod, name, llfty, output);\n \n     let uses_outptr = type_of::return_uses_outptr(ccx, output);\n-    let offset = if uses_outptr { 2 } else { 1 };\n+    let offset = if uses_outptr { 1 } else { 0 };\n+    let offset = if has_env { offset + 1 } else { offset };\n \n     for (i, &arg_ty) in inputs.iter().enumerate() {\n         let llarg = unsafe { llvm::LLVMGetParam(llfn, (offset + i) as c_uint) };\n@@ -292,10 +291,10 @@ fn decl_rust_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext,\n-                             self_ty: Option<ty::t>, inputs: &[ty::t],\n-                             output: ty::t, name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, self_ty, inputs, output, name);\n+pub fn decl_internal_rust_fn(ccx: &CrateContext, has_env: bool,\n+                             inputs: &[ty::t], output: ty::t,\n+                             name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, has_env, inputs, output, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     llfn\n }\n@@ -318,14 +317,10 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-//\n-// The runtime equivalent is box_body() in \"rust_internal.h\".\n-pub fn opaque_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef)\n-                       -> ValueRef {\n-    let _icx = push_ctxt(\"opaque_box_body\");\n+pub fn at_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n-    let ty = type_of(ccx, body_t);\n-    let ty = Type::smart_ptr(ccx, &ty);\n+    let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n@@ -882,10 +877,6 @@ pub fn fail_if_zero<'a>(\n     })\n }\n \n-pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n-    C_null(Type::opaque_box(ccx).ptr_to())\n-}\n-\n pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n@@ -898,7 +889,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n-                    let llty = type_of_fn_from_ty(ccx, None, t);\n+                    let llty = type_of_fn_from_ty(ccx, t);\n                     let mut externs = ccx.externs.borrow_mut();\n                     get_extern_fn(externs.get(), ccx.llmod, name,\n                                   cconv, llty, fn_ty.sig.output)\n@@ -1241,6 +1232,7 @@ pub fn new_fn_ctxt_detailed(ccx: @CrateContext,\n                             path: ast_map::Path,\n                             llfndecl: ValueRef,\n                             id: ast::NodeId,\n+                            has_env: bool,\n                             output_type: ty::t,\n                             param_substs: Option<@param_substs>,\n                             sp: Option<Span>)\n@@ -1263,33 +1255,33 @@ pub fn new_fn_ctxt_detailed(ccx: @CrateContext,\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n-    let fcx = FunctionContext {\n-          llfn: llfndecl,\n-          llenv: unsafe {\n-              Cell::new(llvm::LLVMGetUndef(Type::i8p().to_ref()))\n-          },\n-          llretptr: Cell::new(None),\n-          entry_bcx: RefCell::new(None),\n-          alloca_insert_pt: Cell::new(None),\n-          llreturn: Cell::new(None),\n-          llself: Cell::new(None),\n-          personality: Cell::new(None),\n-          caller_expects_out_pointer: uses_outptr,\n-          llargs: RefCell::new(HashMap::new()),\n-          lllocals: RefCell::new(HashMap::new()),\n-          llupvars: RefCell::new(HashMap::new()),\n-          id: id,\n-          param_substs: param_substs,\n-          span: sp,\n-          path: path,\n-          block_arena: TypedArena::new(),\n-          ccx: ccx,\n-          debug_context: debug_context,\n-          scopes: RefCell::new(~[])\n+    let mut fcx = FunctionContext {\n+        llfn: llfndecl,\n+        llenv: None,\n+        llretptr: Cell::new(None),\n+        entry_bcx: RefCell::new(None),\n+        alloca_insert_pt: Cell::new(None),\n+        llreturn: Cell::new(None),\n+        personality: Cell::new(None),\n+        caller_expects_out_pointer: uses_outptr,\n+        llargs: RefCell::new(HashMap::new()),\n+        lllocals: RefCell::new(HashMap::new()),\n+        llupvars: RefCell::new(HashMap::new()),\n+        id: id,\n+        param_substs: param_substs,\n+        span: sp,\n+        path: path,\n+        block_arena: TypedArena::new(),\n+        ccx: ccx,\n+        debug_context: debug_context,\n+        scopes: RefCell::new(~[])\n     };\n-    fcx.llenv.set(unsafe {\n-          llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n-    });\n+\n+    if has_env {\n+        fcx.llenv = Some(unsafe {\n+            llvm::LLVMGetParam(fcx.llfn, fcx.env_arg_pos() as c_uint)\n+        });\n+    }\n \n     fcx\n }\n@@ -1301,14 +1293,16 @@ pub fn init_function<'a>(\n                      skip_retptr: bool,\n                      output_type: ty::t,\n                      param_substs: Option<@param_substs>) {\n-    unsafe {\n-        let entry_bcx = fcx.new_temp_block(\"entry-block\");\n-        Load(entry_bcx, C_null(Type::i8p()));\n+    let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n-        fcx.entry_bcx.set(Some(entry_bcx));\n-        fcx.alloca_insert_pt.set(Some(\n-                llvm::LLVMGetFirstInstruction(entry_bcx.llbb)));\n-    }\n+    fcx.entry_bcx.set(Some(entry_bcx));\n+\n+    // Use a dummy instruction as the insertion point for all allocas.\n+    // This is later removed in FunctionContext::cleanup.\n+    fcx.alloca_insert_pt.set(Some(unsafe {\n+        Load(entry_bcx, C_null(Type::i8p()));\n+        llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n+    }));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n@@ -1327,21 +1321,21 @@ pub fn init_function<'a>(\n             // Otherwise, we normally allocate the llretptr, unless we\n             // have been instructed to skip it for immediate return\n             // values.\n-            fcx.llretptr.set(Some(make_return_pointer(fcx,\n-                                                      substd_output_type)));\n+            fcx.llretptr.set(Some(make_return_pointer(fcx, substd_output_type)));\n         }\n     }\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n                    path: ast_map::Path,\n                    llfndecl: ValueRef,\n+                   has_env: bool,\n                    output_type: ty::t,\n                    sp: Option<Span>)\n                    -> FunctionContext {\n     // FIXME(#11385): Do not call `init_function` here; it will typecheck\n     // but segfault.\n-    new_fn_ctxt_detailed(ccx, path, llfndecl, -1, output_type, None, sp)\n+    new_fn_ctxt_detailed(ccx, path, llfndecl, -1, has_env, output_type, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1363,35 +1357,28 @@ fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n type RvalueDatum = datum::Datum<datum::Rvalue>;\n type LvalueDatum = datum::Datum<datum::Lvalue>;\n \n-// create_datums_for_fn_args: creates rvalue datums for `self` and each of the\n+// create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into\n // appropriate lvalue datums.\n-fn create_datums_for_fn_args(cx: &FunctionContext,\n-                             self_arg: Option<ty::t>,\n-                             arg_tys: &[ty::t])\n-                             -> (Option<RvalueDatum>, ~[RvalueDatum]) {\n+pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n+                                 arg_tys: &[ty::t])\n+                                 -> ~[RvalueDatum] {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n-    let self_datum = self_arg.map(\n-        |t| datum::Datum(cx.llenv.get(), t, arg_kind(cx, t)));\n-\n     // Return an array wrapping the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument into datums.\n-    let arg_datums = arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n-            let llarg = unsafe {\n-                llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint)\n-            };\n-            datum::Datum(llarg, arg_ty, arg_kind(cx, arg_ty))\n-        }).collect();\n-\n-    (self_datum, arg_datums)\n+    arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n+        let llarg = unsafe {\n+            llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as c_uint)\n+        };\n+        datum::Datum(llarg, arg_ty, arg_kind(fcx, arg_ty))\n+    }).collect()\n }\n \n fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             arg_scope: cleanup::CustomScopeIndex,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            self_datum: Option<RvalueDatum>,\n                             arg_datums: ~[RvalueDatum])\n                             -> &'a Block<'a> {\n     debug!(\"copy_args_to_allocas\");\n@@ -1400,18 +1387,6 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n     let mut bcx = bcx;\n \n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n-    match self_datum {\n-        Some(slf_rv) => {\n-            let slf = unpack_datum!(\n-                bcx, slf_rv.to_lvalue_datum_in_scope(bcx, \"__self\",\n-                                                     arg_scope_id));\n-            fcx.llself.set(Some(slf));\n-            if fcx.ccx.sess.opts.extra_debuginfo {\n-                debuginfo::create_self_argument_metadata(bcx, slf.ty, slf.val);\n-            }\n-        }\n-        _ => {}\n-    }\n \n     for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n         // For certain mode/type combinations, the raw llarg values are passed\n@@ -1429,7 +1404,7 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n         }\n     }\n \n-    return bcx;\n+    bcx\n }\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n@@ -1488,7 +1463,6 @@ pub fn trans_closure(ccx: @CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n-                     self_arg: Option<ty::t>,\n                      param_substs: Option<@param_substs>,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n@@ -1502,13 +1476,13 @@ pub fn trans_closure(ccx: @CrateContext,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx));\n \n-    let fcx = new_fn_ctxt_detailed(ccx,\n-                                   path,\n-                                   llfndecl,\n-                                   id,\n-                                   output_type,\n-                                   param_substs,\n-                                   Some(body.span));\n+    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n+        ty::ty_closure(_) => true,\n+        _ => false\n+    };\n+\n+    let fcx = new_fn_ctxt_detailed(ccx, path, llfndecl, id, has_env, output_type,\n+                                   param_substs, Some(body.span));\n     init_function(&fcx, false, output_type, param_substs);\n \n     // cleanup scope for the incoming arguments\n@@ -1522,11 +1496,9 @@ pub fn trans_closure(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let (self_datum, arg_datums) =\n-        create_datums_for_fn_args(&fcx, self_arg, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, arg_scope, bcx,\n-                               decl.inputs, self_datum, arg_datums);\n+    bcx = copy_args_to_allocas(&fcx, arg_scope, bcx, decl.inputs, arg_datums);\n \n     maybe_load_env(&fcx);\n \n@@ -1578,23 +1550,19 @@ pub fn trans_fn(ccx: @CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n-                self_arg: Option<ty::t>,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n-    debug!(\"trans_fn(self_arg={:?}, param_substs={})\",\n-           self_arg,\n-           param_substs.repr(ccx.tcx));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n     trans_closure(ccx,\n                   path.clone(),\n                   decl,\n                   body,\n                   llfndecl,\n-                  self_arg,\n                   param_substs,\n                   id,\n                   attrs,\n@@ -1664,18 +1632,13 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n                  ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n-    let fcx = new_fn_ctxt_detailed(ccx,\n-                                   ~[],\n-                                   llfndecl,\n-                                   ctor_id,\n-                                   result_ty,\n-                                   param_substs,\n-                                   None);\n+    let fcx = new_fn_ctxt_detailed(ccx, ~[], llfndecl, ctor_id, false,\n+                                   result_ty, param_substs, None);\n     init_function(&fcx, false, result_ty, param_substs);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let (_, arg_datums) = create_datums_for_fn_args(&fcx, None, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n@@ -1750,16 +1713,9 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n                 llfndecl,\n                 item.id);\n         } else if !generics.is_type_parameterized() {\n-            let llfndecl = get_item_val(ccx, item.id);\n-            trans_fn(ccx,\n-                     vec::append_one((*path).clone(), PathName(item.ident)),\n-                     decl,\n-                     body,\n-                     llfndecl,\n-                     None,\n-                     None,\n-                     item.id,\n-                     item.attrs);\n+            let path = vec::append_one((*path).clone(), PathName(item.ident));\n+            let llfn = get_item_val(ccx, item.id);\n+            trans_fn(ccx, path, decl, body, llfn, None, item.id, item.attrs);\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n@@ -1874,8 +1830,7 @@ fn register_fn(ccx: @CrateContext,\n                sp: Span,\n                sym: ~str,\n                node_id: ast::NodeId,\n-               node_type: ty::t,\n-               self_ty: Option<ty::t>)\n+               node_type: ty::t)\n                -> ValueRef {\n     let f = match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n@@ -1885,7 +1840,7 @@ fn register_fn(ccx: @CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, sym);\n+    let llfn = decl_rust_fn(ccx, false, f.sig.inputs, f.sig.output, sym);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1963,7 +1918,6 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                     });\n \n                     ~[\n-                        C_null(Type::opaque_box(ccx).ptr_to()),\n                         opaque_rust_main,\n                         llvm::LLVMGetParam(llfn, 0),\n                         llvm::LLVMGetParam(llfn, 1)\n@@ -1973,7 +1927,6 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             } else {\n                 debug!(\"using user-defined start fn\");\n                 let args = ~[\n-                    C_null(Type::opaque_box(ccx).ptr_to()),\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n                     llvm::LLVMGetParam(llfn, 1 as c_uint)\n                 ];\n@@ -1990,18 +1943,6 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n     }\n }\n \n-pub fn fill_fn_pair(bcx: &Block,\n-                    pair: ValueRef,\n-                    llfn: ValueRef,\n-                    llenvptr: ValueRef) {\n-    let ccx = bcx.ccx();\n-    let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n-    Store(bcx, llfn, code_cell);\n-    let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-    let llenvblobptr = PointerCast(bcx, llenvptr, Type::opaque_box(ccx).ptr_to());\n-    Store(bcx, llenvblobptr, env_cell);\n-}\n-\n pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> ast_map::Path {\n     ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n@@ -2049,22 +1990,22 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             // using the current crate's name/version\n                             // information in the hash of the symbol\n                             debug!(\"making {}\", sym);\n-                            let sym = {\n+                            let (sym, is_local) = {\n                                 let external_srcs = ccx.external_srcs\n                                                        .borrow();\n                                 match external_srcs.get().find(&i.id) {\n                                     Some(&did) => {\n                                         debug!(\"but found in other crate...\");\n-                                        csearch::get_symbol(ccx.sess.cstore,\n-                                                            did)\n+                                        (csearch::get_symbol(ccx.sess.cstore,\n+                                                             did), false)\n                                     }\n-                                    None => sym\n+                                    None => (sym, true)\n                                 }\n                             };\n \n                             // We need the translated value here, because for enums the\n                             // LLVM type is not fully determined by the Rust type.\n-                            let (v, inlineable) = consts::const_expr(ccx, expr);\n+                            let (v, inlineable) = consts::const_expr(ccx, expr, is_local);\n                             {\n                                 let mut const_values = ccx.const_values\n                                                           .borrow_mut();\n@@ -2142,7 +2083,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         ast::ItemFn(_, purity, _, _, _) => {\n                             let llfn = if purity != ast::ExternFn {\n-                                register_fn(ccx, i.span, sym, i.id, ty, None)\n+                                register_fn(ccx, i.span, sym, i.id, ty)\n                             } else {\n                                 foreign::register_rust_fn_with_foreign_abi(ccx,\n                                                                            i.span,\n@@ -2246,7 +2187,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n-                                    register_fn(ccx, (*v).span, sym, id, ty, None)\n+                                    register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n                                 _ => fail!(\"NodeVariant, shouldn't happen\")\n                             };\n@@ -2271,7 +2212,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let sym = exported_name(ccx, (*struct_path).clone(), ty,\n                                                     struct_item.attrs);\n                             let llfn = register_fn(ccx, struct_item.span,\n-                                                   sym, ctor_id, ty, None);\n+                                                   sym, ctor_id, ty);\n                             set_inline_hint(llfn);\n                             llfn\n                         }\n@@ -2312,11 +2253,7 @@ fn register_method(ccx: @CrateContext,\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n \n-    let self_ty = match m.explicit_self.node {\n-        ast::SelfStatic => None,\n-        _ => Some(ty::node_id_to_type(ccx.tcx, m.self_id))\n-    };\n-    let llfn = register_fn(ccx, m.span, sym, id, mty, self_ty);\n+    let llfn = register_fn(ccx, m.span, sym, id, mty);\n     set_llvm_fn_attrs(m.attrs, llfn);\n     llfn\n }"}, {"sha": "71b25b79feb4af5fd0e99b819b9d960636913bff", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -797,6 +797,11 @@ impl Builder {\n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n                 attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n         self.count_insn(\"call\");\n+\n+        debug!(\"Call {} with args ({})\",\n+               self.ccx.tn.val_to_str(llfn),\n+               args.map(|&v| self.ccx.tn.val_to_str(v)).connect(\", \"));\n+\n         unsafe {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());"}, {"sha": "e10c7af7f313d0c168ab8d981400a9a56af341eb", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 104, "deletions": 92, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -52,22 +52,20 @@ use syntax::ast;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n \n-// Represents a (possibly monomorphized) top-level fn item or method\n-// item.  Note that this is just the fn-ptr and is not a Rust closure\n-// value (which is a pair).\n-pub struct FnData {\n-    llfn: ValueRef,\n-}\n-\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n }\n \n pub enum CalleeData {\n     Closure(Datum<Lvalue>),\n-    Fn(FnData),\n-    Method(MethodData)\n+\n+    // Represents a (possibly monomorphized) top-level fn item or method\n+    // item. Note that this is just the fn-ptr and is not a Rust closure\n+    // value (which is a pair).\n+    Fn(/* llfn */ ValueRef),\n+\n+    TraitMethod(MethodData)\n }\n \n pub struct Callee<'a> {\n@@ -95,7 +93,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n                 let llval = datum.to_llscalarish(bcx);\n-                return Callee {bcx: bcx, data: Fn(FnData {llfn: llval})};\n+                return Callee {bcx: bcx, data: Fn(llval)};\n             }\n             ty::ty_closure(..) => {\n                 let datum = unpack_datum!(\n@@ -111,8 +109,8 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         }\n     }\n \n-    fn fn_callee<'a>(bcx: &'a Block<'a>, fd: FnData) -> Callee<'a> {\n-        return Callee {bcx: bcx, data: Fn(fd)};\n+    fn fn_callee<'a>(bcx: &'a Block<'a>, llfn: ValueRef) -> Callee<'a> {\n+        return Callee {bcx: bcx, data: Fn(llfn)};\n     }\n \n     fn trans_def<'a>(bcx: &'a Block<'a>, def: ast::Def, ref_expr: &ast::Expr)\n@@ -143,8 +141,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n             ast::DefArg(..) |\n             ast::DefLocal(..) |\n             ast::DefBinding(..) |\n-            ast::DefUpvar(..) |\n-            ast::DefSelf(..) => {\n+            ast::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n             ast::DefMod(..) | ast::DefForeignMod(..) | ast::DefTrait(..) |\n@@ -171,7 +168,7 @@ pub fn trans_fn_ref_to_callee<'a>(\n }\n \n pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, ref_id: ast::NodeId)\n-                    -> FnData {\n+                    -> ValueRef {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -248,7 +245,7 @@ pub fn trans_fn_ref_with_vtables(\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n-     -> FnData {\n+     -> ValueRef {\n     /*!\n      * Translates a reference to a fn/method item, monomorphizing and\n      * inlining as it goes.\n@@ -399,9 +396,9 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = common::node_id_type(bcx, ref_id);\n \n             val = PointerCast(\n-                bcx, val, type_of::type_of_fn_from_ty(ccx, None, ref_ty).ptr_to());\n+                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n         }\n-        return FnData {llfn: val};\n+        return val;\n     }\n \n     // Find the actual function pointer.\n@@ -438,13 +435,13 @@ pub fn trans_fn_ref_with_vtables(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, None, fn_tpt.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         val = BitCast(bcx, val, llptrty);\n     }\n \n-    return FnData {llfn: val};\n+    val\n }\n \n // ______________________________________________________________________\n@@ -465,8 +462,7 @@ pub fn trans_call<'a>(\n                      node_id_type(in_cx, id),\n                      |cx, _| trans(cx, f),\n                      args,\n-                     Some(dest),\n-                     DontAutorefArg).bcx\n+                     Some(dest)).bcx\n }\n \n pub fn trans_method_call<'a>(\n@@ -478,9 +474,7 @@ pub fn trans_method_call<'a>(\n                          dest: expr::Dest)\n                          -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex={}, rcvr={})\",\n-           call_ex.repr(in_cx.tcx()),\n-           rcvr.repr(in_cx.tcx()));\n+    debug!(\"trans_method_call(call_ex={})\", call_ex.repr(in_cx.tcx()));\n     trans_call_inner(\n         in_cx,\n         Some(common::expr_info(call_ex)),\n@@ -509,8 +503,7 @@ pub fn trans_method_call<'a>(\n             }\n         },\n         args,\n-        Some(dest),\n-        DontAutorefArg).bcx\n+        Some(dest)).bcx\n }\n \n pub fn trans_lang_call<'a>(\n@@ -537,8 +530,7 @@ pub fn trans_lang_call<'a>(\n                                                                     None)\n                              },\n                              ArgVals(args),\n-                             dest,\n-                             DontAutorefArg)\n+                             dest)\n }\n \n pub fn trans_lang_call_with_type_params<'a>(\n@@ -569,20 +561,20 @@ pub fn trans_lang_call_with_type_params<'a>(\n \n             let new_llval;\n             match callee.data {\n-                Fn(fn_data) => {\n+                Fn(llfn) => {\n                     let substituted = ty::subst_tps(callee.bcx.tcx(),\n                                                     type_params,\n                                                     None,\n                                                     fty);\n                     let llfnty = type_of::type_of(callee.bcx.ccx(),\n                                                       substituted);\n-                    new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n+                    new_llval = PointerCast(callee.bcx, llfn, llfnty);\n                 }\n                 _ => fail!()\n             }\n-            Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n+            Callee { bcx: callee.bcx, data: Fn(new_llval) }\n         },\n-        ArgVals(args), Some(dest), DontAutorefArg).bcx;\n+        ArgVals(args), Some(dest)).bcx;\n }\n \n pub fn trans_call_inner<'a>(\n@@ -594,8 +586,7 @@ pub fn trans_call_inner<'a>(\n                                      arg_cleanup_scope: cleanup::ScopeId|\n                                      -> Callee<'a>,\n                         args: CallArgs,\n-                        dest: Option<expr::Dest>,\n-                        autoref_arg: AutorefArg)\n+                        dest: Option<expr::Dest>)\n                         -> Result<'a> {\n     /*!\n      * This behemoth of a function translates function calls.\n@@ -627,25 +618,22 @@ pub fn trans_call_inner<'a>(\n     let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n     let mut bcx = callee.bcx;\n \n-    let (llfn, llenv) = unsafe {\n-        match callee.data {\n-            Fn(d) => {\n-                (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to().to_ref()))\n-            }\n-            Method(d) => {\n-                // Weird but true: we pass self in the *environment* slot!\n-                (d.llfn, d.llself)\n-            }\n-            Closure(d) => {\n-                // Closures are represented as (llfn, llclosure) pair:\n-                // load the requisite values out.\n-                let pair = d.to_llref();\n-                let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n-                let llfn = Load(bcx, llfn);\n-                let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-                let llenv = Load(bcx, llenv);\n-                (llfn, llenv)\n-            }\n+    let (llfn, llenv, llself) = match callee.data {\n+        Fn(llfn) => {\n+            (llfn, None, None)\n+        }\n+        TraitMethod(d) => {\n+            (d.llfn, None, Some(d.llself))\n+        }\n+        Closure(d) => {\n+            // Closures are represented as (llfn, llclosure) pair:\n+            // load the requisite values out.\n+            let pair = d.to_llref();\n+            let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+            let llfn = Load(bcx, llfn);\n+            let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+            let llenv = Load(bcx, llenv);\n+            (llfn, Some(llenv), None)\n         }\n     };\n \n@@ -694,13 +682,17 @@ pub fn trans_call_inner<'a>(\n             llargs.push(opt_llretslot.unwrap());\n         }\n \n-        // Push the environment.\n-        llargs.push(llenv);\n+        // Push the environment (or a trait object's self).\n+        match (llenv, llself) {\n+            (Some(llenv), None) => llargs.push(llenv),\n+            (None, Some(llself)) => llargs.push(llself),\n+            _ => {}\n+        }\n \n         // Push the arguments.\n-        bcx = trans_args(bcx, args, callee_ty,\n-                         autoref_arg, &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope));\n+        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope),\n+                         llself.is_some());\n \n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n@@ -718,11 +710,10 @@ pub fn trans_call_inner<'a>(\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n-            ty::ty_uniq(..) |\n-                ty::ty_vec(_, ty::vstore_uniq) => {\n+            ty::ty_uniq(..) | ty::ty_vec(_, ty::vstore_uniq) => {\n                 attrs.push((0, NoAliasAttribute));\n             }\n-            _ => ()\n+            _ => {}\n         }\n \n         // Invoke the actual rust fn and update bcx/llresult.\n@@ -748,13 +739,12 @@ pub fn trans_call_inner<'a>(\n         assert!(dest.is_some());\n \n         let mut llargs = ~[];\n-        bcx = trans_args(bcx, args, callee_ty,\n-                         autoref_arg, &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope));\n+        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope), false);\n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n         let arg_tys = match args {\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n-            ArgVals(_) => fail!(\"expected arg exprs.\")\n+            _ => fail!(\"expected arg exprs.\")\n         };\n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n@@ -782,18 +772,18 @@ pub fn trans_call_inner<'a>(\n \n pub enum CallArgs<'a> {\n     ArgExprs(&'a [@ast::Expr]),\n+    // HACK used only by trans_overloaded_op.\n+    ArgAutorefSecond(&'a ast::Expr, Option<&'a ast::Expr>),\n     ArgVals(&'a [ValueRef])\n }\n \n-pub fn trans_args<'a>(\n-                  cx: &'a Block<'a>,\n+fn trans_args<'a>(cx: &'a Block<'a>,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n-                  autoref_arg: AutorefArg,\n                   llargs: &mut ~[ValueRef],\n-                  arg_cleanup_scope: cleanup::ScopeId)\n-                  -> &'a Block<'a>\n-{\n+                  arg_cleanup_scope: cleanup::ScopeId,\n+                  ignore_self: bool)\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_args\");\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let variadic = ty::fn_is_variadic(fn_ty);\n@@ -804,28 +794,50 @@ pub fn trans_args<'a>(\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n     match args {\n-      ArgExprs(arg_exprs) => {\n-        let num_formal_args = arg_tys.len();\n-        for (i, arg_expr) in arg_exprs.iter().enumerate() {\n-            let arg_ty = if i >= num_formal_args {\n-                assert!(variadic);\n-                expr_ty_adjusted(cx, *arg_expr)\n-            } else {\n-                arg_tys[i]\n-            };\n-            let arg_val = unpack_result!(bcx, {\n-                trans_arg_expr(bcx,\n-                               arg_ty,\n-                               *arg_expr,\n+        ArgExprs(arg_exprs) => {\n+            let num_formal_args = arg_tys.len();\n+            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n+                if i == 0 && ignore_self {\n+                    continue;\n+                }\n+                let arg_ty = if i >= num_formal_args {\n+                    assert!(variadic);\n+                    expr_ty_adjusted(cx, *arg_expr)\n+                } else {\n+                    arg_tys[i]\n+                };\n+                llargs.push(unpack_result!(bcx, {\n+                    trans_arg_expr(bcx, arg_ty, *arg_expr,\n+                                   arg_cleanup_scope,\n+                                   DontAutorefArg)\n+                }));\n+            }\n+        }\n+        ArgAutorefSecond(arg_expr, arg2) => {\n+            assert!(!variadic);\n+\n+            llargs.push(unpack_result!(bcx, {\n+                trans_arg_expr(bcx, arg_tys[0], arg_expr,\n                                arg_cleanup_scope,\n-                               autoref_arg)\n-            });\n-            llargs.push(arg_val);\n+                               DontAutorefArg)\n+            }));\n+\n+            match arg2 {\n+                Some(arg2_expr) => {\n+                    assert_eq!(arg_tys.len(), 2);\n+\n+                    llargs.push(unpack_result!(bcx, {\n+                        trans_arg_expr(bcx, arg_tys[1], arg2_expr,\n+                                       arg_cleanup_scope,\n+                                       DoAutorefArg)\n+                    }));\n+                }\n+                None => assert_eq!(arg_tys.len(), 1)\n+            }\n+        }\n+        ArgVals(vs) => {\n+            llargs.push_all(vs);\n         }\n-      }\n-      ArgVals(vs) => {\n-        llargs.push_all(vs);\n-      }\n     }\n \n     bcx"}, {"sha": "6e92ea9f11e51b3607263e829302faea69f59944", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -680,7 +680,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n-        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0).llfn;\n+        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0);\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);"}, {"sha": "4d171bc86b1b01067c79b0d824bdeb3555421dbe", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 116, "deletions": 108, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -10,18 +10,19 @@\n \n \n use back::abi;\n-use back::link::{mangle_internal_name_by_path_and_seq};\n+use back::link::mangle_internal_name_by_path_and_seq;\n use lib::llvm::ValueRef;\n use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n-use middle::trans::datum::{Datum, Lvalue};\n+use middle::trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n-use middle::trans::glue;\n use middle::trans::type_of::*;\n+use middle::trans::type_::Type;\n use middle::ty;\n+use util::ppaux::Repr;\n use util::ppaux::ty_to_str;\n \n use std::vec;\n@@ -69,9 +70,9 @@ use syntax::parse::token::special_idents;\n // closure\".\n //\n // Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine Type::opaque_box().ptr_to() returns an\n-// appropriate type for such an opaque closure; it allows access to\n-// the box fields, but not the closure_data itself.\n+// by ptr.  The routine Type::at_box().ptr_to() returns an appropriate\n+// type for such an opaque closure; it allows access to the box fields,\n+// but not the closure_data itself.\n //\n // But sometimes, such as when cloning or freeing a closure, we need\n // to know the full information.  That is where the type descriptor\n@@ -244,8 +245,7 @@ pub fn store_environment<'a>(\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-pub fn build_closure<'a>(\n-                     bcx0: &'a Block<'a>,\n+fn build_closure<'a>(bcx0: &'a Block<'a>,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil)\n                      -> ClosureResult<'a> {\n@@ -282,10 +282,8 @@ pub fn build_closure<'a>(\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-pub fn load_environment(fcx: &FunctionContext,\n-                        cdata_ty: ty::t,\n-                        cap_vars: &[moves::CaptureVar],\n-                        sigil: ast::Sigil) {\n+fn load_environment(fcx: &FunctionContext, cdata_ty: ty::t,\n+                    cap_vars: &[moves::CaptureVar], sigil: ast::Sigil) {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n@@ -296,7 +294,7 @@ pub fn load_environment(fcx: &FunctionContext,\n     let bcx = fcx.entry_bcx.get().unwrap();\n \n     // Load a pointer to the closure data, skipping over the box header:\n-    let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv.get());\n+    let llcdata = at_box_body(bcx, cdata_ty, fcx.llenv.unwrap());\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n     // llvm.dbg.declare intrinsic expects\n@@ -338,6 +336,12 @@ pub fn load_environment(fcx: &FunctionContext,\n     }\n }\n \n+fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n+    Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n+    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p());\n+    Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n+}\n+\n pub fn trans_expr_fn<'a>(\n                      bcx: &'a Block<'a>,\n                      sigil: ast::Sigil,\n@@ -388,115 +392,119 @@ pub fn trans_expr_fn<'a>(\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),\n                                                  \"expr_fn\");\n-    let llfn = decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, s);\n+    let llfn = decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let Result {bcx: bcx, val: closure} = match sigil {\n-        ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n-            let cap_vars = {\n-                let capture_map = ccx.maps.capture_map.borrow();\n-                capture_map.get().get_copy(&user_id)\n-            };\n-            let ClosureResult {llbox, cdata_ty, bcx}\n-                = build_closure(bcx, cap_vars, sigil);\n-            trans_closure(ccx,\n-                          sub_path,\n-                          decl,\n-                          body,\n-                          llfn,\n-                          None,\n-                          bcx.fcx.param_substs,\n-                          user_id,\n-                          [],\n-                          ty::ty_fn_ret(fty),\n-                          |fcx| load_environment(fcx, cdata_ty, cap_vars, sigil));\n-            rslt(bcx, llbox)\n-        }\n+    let cap_vars = {\n+        let capture_map = ccx.maps.capture_map.borrow();\n+        capture_map.get().get_copy(&user_id)\n     };\n-    fill_fn_pair(bcx, dest_addr, llfn, closure);\n-\n-    return bcx;\n+    let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil);\n+    trans_closure(ccx, sub_path, decl, body, llfn,\n+                    bcx.fcx.param_substs, user_id,\n+                    [], ty::ty_fn_ret(fty),\n+                    |fcx| load_environment(fcx, cdata_ty, cap_vars, sigil));\n+    fill_fn_pair(bcx, dest_addr, llfn, llbox);\n+\n+    bcx\n }\n \n-pub fn make_closure_glue<'a>(\n-                         cx: &'a Block<'a>,\n-                         v: ValueRef,\n-                         t: ty::t,\n-                         glue_fn: |&'a Block<'a>, v: ValueRef, t: ty::t|\n-                                   -> &'a Block<'a>)\n-                         -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"closure::make_closure_glue\");\n-    let bcx = cx;\n-    let tcx = cx.tcx();\n-\n-    let sigil = ty::ty_closure_sigil(t);\n-    match sigil {\n-        ast::BorrowedSigil => bcx,\n-        ast::OwnedSigil | ast::ManagedSigil => {\n-            let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n-            let box_ptr_v = Load(cx, box_cell_v);\n-            with_cond(cx, IsNotNull(cx, box_ptr_v), |bcx| {\n-                let closure_ty = ty::mk_opaque_closure_ptr(tcx, sigil);\n-                glue_fn(bcx, box_cell_v, closure_ty)\n-            })\n+pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n+                               closure_ty: ty::t,\n+                               def: ast::Def,\n+                               fn_ptr: ValueRef,\n+                               is_local: bool) -> ValueRef {\n+\n+    let def_id = match def {\n+        ast::DefFn(did, _) | ast::DefStaticMethod(did, _, _) |\n+        ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n+        _ => {\n+            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                  expected a statically resolved fn, got {:?}\",\n+                                  def));\n         }\n-    }\n-}\n+    };\n \n-pub fn make_opaque_cbox_drop_glue<'a>(\n-                                  bcx: &'a Block<'a>,\n-                                  sigil: ast::Sigil,\n-                                  cboxptr: ValueRef)    // opaque closure ptr\n-                                  -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n-    match sigil {\n-        ast::BorrowedSigil => bcx,\n-        ast::ManagedSigil => {\n-            bcx.tcx().sess.bug(\"trying to trans drop glue of @fn\")\n-        }\n-        ast::OwnedSigil => {\n-            glue::make_free_glue(\n-                bcx, cboxptr,\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n+    {\n+        let cache = ccx.closure_bare_wrapper_cache.borrow();\n+        match cache.get().find(&fn_ptr) {\n+            Some(&llval) => return llval,\n+            None => {}\n         }\n     }\n-}\n \n-/// `cbox` is a pointer to a pointer to an opaque closure.\n-pub fn make_opaque_cbox_free_glue<'a>(\n-                                  bcx: &'a Block<'a>,\n-                                  sigil: ast::Sigil,\n-                                  cbox: ValueRef)\n-                                  -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n-    match sigil {\n-        ast::BorrowedSigil => {\n-            return bcx;\n+    let tcx = ccx.tcx;\n+\n+    debug!(\"get_wrapper_for_bare_fn(closure_ty={})\", closure_ty.repr(tcx));\n+\n+    let f = match ty::get(closure_ty).sty {\n+        ty::ty_closure(ref f) => f,\n+        _ => {\n+            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                  expected a closure ty, got {}\",\n+                                  closure_ty.repr(tcx)));\n         }\n-        ast::ManagedSigil | ast::OwnedSigil => {\n-            /* hard cases: fallthrough to code below */\n+    };\n+\n+    let path = ty::item_path(tcx, def_id);\n+    let name = mangle_internal_name_by_path_and_seq(ccx, path, \"as_closure\");\n+    let llfn = if is_local {\n+        decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+    } else {\n+        decl_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+    };\n+\n+    {\n+        let mut cache = ccx.closure_bare_wrapper_cache.borrow_mut();\n+        cache.get().insert(fn_ptr, llfn);\n+    }\n+\n+    // This is only used by statics inlined from a different crate.\n+    if !is_local {\n+        // Don't regenerate the wrapper, just reuse the original one.\n+        return llfn;\n+    }\n+\n+    let _icx = push_ctxt(\"closure::get_wrapper_for_bare_fn\");\n+\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, true, f.sig.output, None);\n+    init_function(&fcx, true, f.sig.output, None);\n+    let bcx = fcx.entry_bcx.get().unwrap();\n+\n+    let args = create_datums_for_fn_args(&fcx, ty::ty_fn_args(closure_ty));\n+    let mut llargs = ~[];\n+    match fcx.llretptr.get() {\n+        Some(llretptr) => {\n+            llargs.push(llretptr);\n         }\n+        None => {}\n     }\n+    llargs.extend(&mut args.iter().map(|arg| arg.val));\n \n-    let ccx = bcx.ccx();\n-    with_cond(bcx, IsNotNull(bcx, cbox), |bcx| {\n-        // Load the type descr found in the cbox\n-        let lltydescty = ccx.tydesc_type.ptr_to();\n-        let cbox = Load(bcx, cbox);\n-        let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n-        let tydesc = Load(bcx, tydescptr);\n-        let tydesc = PointerCast(bcx, tydesc, lltydescty);\n-\n-        // Drop the tuple data then free the descriptor\n-        let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]);\n-        glue::call_tydesc_glue_full(bcx, cdata, tydesc,\n-                                    abi::tydesc_field_drop_glue, None);\n-\n-        // Free the ty descr (if necc) and the box itself\n-        glue::trans_exchange_free(bcx, cbox);\n-\n-        bcx\n-    })\n+    let retval = Call(bcx, fn_ptr, llargs, []);\n+    if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n+        RetVoid(bcx);\n+    } else {\n+        Ret(bcx, retval);\n+    }\n+\n+    // HACK(eddyb) finish_fn cannot be used here, we returned directly.\n+    debuginfo::clear_source_location(&fcx);\n+    fcx.cleanup();\n+\n+    llfn\n+}\n+\n+pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n+                                     closure_ty: ty::t,\n+                                     def: ast::Def,\n+                                     fn_ptr: ValueRef)\n+                                     -> DatumBlock<'a, Expr>  {\n+    let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n+    let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n+    fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p()));\n+\n+    DatumBlock(bcx, scratch.to_expr_datum())\n }"}, {"sha": "45f5d84eb8ae4c65ded9f5861e6ab3622ff664e3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -230,9 +230,8 @@ pub struct FunctionContext<'a> {\n     // section of the executable we're generating.\n     llfn: ValueRef,\n \n-    // The implicit environment argument that arrives in the function we're\n-    // creating.\n-    llenv: Cell<ValueRef>,\n+    // The environment argument in a closure.\n+    llenv: Option<ValueRef>,\n \n     // The place to store the return value. If the return type is immediate,\n     // this is an alloca in the function. Otherwise, it's the hidden first\n@@ -250,14 +249,6 @@ pub struct FunctionContext<'a> {\n     alloca_insert_pt: Cell<Option<ValueRef>>,\n     llreturn: Cell<Option<BasicBlockRef>>,\n \n-    // The 'self' value currently in use in this function, if there\n-    // is one.\n-    //\n-    // NB: This is the type of the self *variable*, not the self *type*. The\n-    // self type is set only for default methods, while the self variable is\n-    // set for all methods.\n-    llself: Cell<Option<LvalueDatum>>,\n-\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     personality: Cell<Option<ValueRef>>,\n@@ -305,10 +296,11 @@ pub struct FunctionContext<'a> {\n \n impl<'a> FunctionContext<'a> {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n-        if self.caller_expects_out_pointer {\n-            arg + 2u\n+        let arg = self.env_arg_pos() + arg;\n+        if self.llenv.is_some() {\n+            arg + 1\n         } else {\n-            arg + 1u\n+            arg\n         }\n     }\n "}, {"sha": "da4be012dc0b343ac56a1fd74aa73b24a1990ba6", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -19,6 +19,7 @@ use middle::const_eval;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::push_ctxt;\n+use middle::trans::closure;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::expr;\n@@ -85,11 +86,12 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-fn const_vec(cx: @CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n+fn const_vec(cx: @CrateContext, e: &ast::Expr,\n+             es: &[@ast::Expr], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx, e);\n     let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(vs, false)\n@@ -187,11 +189,12 @@ pub fn get_const_val(cx: @CrateContext,\n      !non_inlineable_statics.get().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n-    let (llconst, inlineable) = const_expr_unadjusted(cx, e);\n+pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n+    let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx, e);\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n     let adjustment = {\n         let adjustments = cx.tcx.adjustments.borrow();\n         adjustments.get().find_copy(&e.id)\n@@ -201,10 +204,13 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n         Some(adj) => {\n             match *adj {\n                 ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n-                    llconst = C_struct([\n-                        llconst,\n-                        C_null(Type::opaque_box(cx).ptr_to())\n-                    ], false)\n+                    let def = ty::resolve_expr(cx.tcx, e);\n+                    let wrapper = closure::get_wrapper_for_bare_fn(cx,\n+                                                                   ety_adjusted,\n+                                                                   def,\n+                                                                   llconst,\n+                                                                   is_local);\n+                    llconst = C_struct([wrapper, C_null(Type::i8p())], false)\n                 }\n                 ty::AutoAddEnv(ref r, ref s) => {\n                     cx.sess\n@@ -277,7 +283,6 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n         }\n     }\n \n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n     let llty = type_of::sizing_type_of(cx, ety_adjusted);\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n@@ -296,22 +301,21 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: @CrateContext,\n-                         e: &ast::Expr) -> (ValueRef, bool) {\n-    fn map_list(cx: @CrateContext,\n-                exprs: &[@ast::Expr]) -> (~[ValueRef], bool) {\n-        exprs.iter().map(|&e| const_expr(cx, e))\n+fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n+                         is_local: bool) -> (ValueRef, bool) {\n+    let map_list = |exprs: &[@ast::Expr]| {\n+        exprs.iter().map(|&e| const_expr(cx, e, is_local))\n              .fold((~[], true), |(L, all_inlineable), (val, inlineable)| {\n-                    (vec::append_one(L, val), all_inlineable && inlineable)\n+                (vec::append_one(L, val), all_inlineable && inlineable)\n              })\n-    }\n+    };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(lit) => (consts::const_lit(cx, e, *lit), true),\n           ast::ExprBinary(_, b, e1, e2) => {\n-            let (te1, _) = const_expr(cx, e1);\n-            let (te2, _) = const_expr(cx, e2);\n+            let (te1, _) = const_expr(cx, e1, is_local);\n+            let (te2, _) = const_expr(cx, e2, is_local);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -392,7 +396,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n             }, true)\n           },\n           ast::ExprUnary(_, u, e) => {\n-            let (te, _) = const_expr(cx, e);\n+            let (te, _) = const_expr(cx, e, is_local);\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n@@ -421,7 +425,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n           ast::ExprField(base, field, _) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n-              let (bv, inlineable) = const_expr(cx, base);\n+              let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n                   (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n@@ -430,7 +434,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n \n           ast::ExprIndex(_, base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n-              let (bv, inlineable) = const_expr(cx, base);\n+              let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -471,7 +475,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n             let ety = ty::expr_ty(cx.tcx, e);\n             let llty = type_of::type_of(cx, ety);\n             let basety = ty::expr_ty(cx.tcx, base);\n-            let (v, inlineable) = const_expr(cx, base);\n+            let (v, inlineable) = const_expr(cx, base, is_local);\n             return (match (expr::cast_type_kind(basety),\n                            expr::cast_type_kind(ety)) {\n \n@@ -522,13 +526,13 @@ fn const_expr_unadjusted(cx: @CrateContext,\n             }, inlineable)\n           }\n           ast::ExprAddrOf(ast::MutImmutable, sub) => {\n-              let (e, _) = const_expr(cx, sub);\n+              let (e, _) = const_expr(cx, sub, is_local);\n               (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              let (vals, inlineable) = map_list(cx, *es);\n+              let (vals, inlineable) = map_list(*es);\n               (adt::trans_const(cx, repr, 0, vals), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n@@ -537,15 +541,15 @@ fn const_expr_unadjusted(cx: @CrateContext,\n               let tcx = cx.tcx;\n \n               let base_val = match *base_opt {\n-                Some(base) => Some(const_expr(cx, base)),\n+                Some(base) => Some(const_expr(cx, base, is_local)),\n                 None => None\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(f) => const_expr(cx, (*f).expr),\n+                          Some(f) => const_expr(cx, (*f).expr, is_local),\n                           None => {\n                               match base_val {\n                                 Some((bv, inlineable)) => {\n@@ -563,19 +567,19 @@ fn const_expr_unadjusted(cx: @CrateContext,\n               })\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, inlineable) = const_vec(cx, e, *es);\n+            let (v, _, inlineable) = const_vec(cx, e, *es, is_local);\n             (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n             match sub.node {\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n-                    ast::LitStr(..) => { const_expr(cx, sub) }\n+                    ast::LitStr(..) => { const_expr(cx, sub, is_local) }\n                     _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, llunitty, _) = const_vec(cx, e, *es);\n+                let (cv, llunitty, _) = const_vec(cx, e, *es, is_local);\n                 let llty = val_ty(cv);\n                 let gv = \"const\".with_c_str(|name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -598,7 +602,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess.span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = vec::from_elem(n, const_expr(cx, elem).first());\n+            let vs = vec::from_elem(n, const_expr(cx, elem, is_local).first());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(vs, false)\n             } else {\n@@ -656,7 +660,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n                   Some(ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let (arg_vals, inlineable) = map_list(cx, *args);\n+                      let (arg_vals, inlineable) = map_list(*args);\n                       (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n@@ -665,14 +669,14 @@ fn const_expr_unadjusted(cx: @CrateContext,\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      let (arg_vals, inlineable) = map_list(cx, *args);\n+                      let (arg_vals, inlineable) = map_list(*args);\n                       (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n                        inlineable)\n                   }\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(e) => { const_expr(cx, e) }\n+          ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n           _ => cx.sess.span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };"}, {"sha": "010408246815e6ec6b8b1c39a1e0e3e447598a2f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -91,6 +91,9 @@ pub struct CrateContext {\n \n      impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n+     // Cache of closure wrappers for bare fn's.\n+     closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+\n      module_data: RefCell<HashMap<~str, ValueRef>>,\n      lltypes: RefCell<HashMap<ty::t, Type>>,\n      llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n@@ -201,6 +204,7 @@ impl CrateContext {\n                   const_values: RefCell::new(HashMap::new()),\n                   extern_const_values: RefCell::new(HashMap::new()),\n                   impl_method_cache: RefCell::new(HashMap::new()),\n+                  closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n                   module_data: RefCell::new(HashMap::new()),\n                   lltypes: RefCell::new(HashMap::new()),\n                   llsizingtypes: RefCell::new(HashMap::new()),"}, {"sha": "8c8c6829e49fd6f5a46b71460ad4ac5f69934c5c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -309,7 +309,7 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n         Some(x) => {\n             bcx = expr::trans_into(bcx, x, dest);\n         }\n-        _ => ()\n+        _ => {}\n     }\n     let cleanup_llbb = fcx.return_exit_block();\n     Br(bcx, cleanup_llbb);"}, {"sha": "c4fdc895670328cb92d0788bb0580efd2399a07e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 88, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -130,8 +130,6 @@ use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n use middle::trans::adt;\n-use middle::trans::base;\n-use middle::trans::build;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::machine;\n@@ -328,8 +326,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n         }\n-        Some(ast_map::NodeLocal(ident, _)) => ident,\n-        Some(ast_map::NodeArg(pat)) => {\n+        Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n                 ast::PatIdent(_, ref path, _) => {\n                     ast_util::path_to_ident(path)\n@@ -410,83 +407,6 @@ pub fn create_match_binding_metadata(bcx: &Block,\n                   span);\n }\n \n-/// Creates debug information for the self argument of a method.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_self_argument_metadata(bcx: &Block,\n-                                     type_of_self: ty::t,\n-                                     llptr: ValueRef) {\n-    if fn_should_be_ignored(bcx.fcx) {\n-        return;\n-    }\n-\n-    // Extract the span of the self argument from the method's AST\n-    let fnitem = bcx.ccx().tcx.items.get(bcx.fcx.id);\n-    let span = match fnitem {\n-        ast_map::NodeMethod(method, _, _) => {\n-            method.explicit_self.span\n-        }\n-        ast_map::NodeTraitMethod(trait_method, _, _) => {\n-            match *trait_method {\n-                ast::Provided(method) => method.explicit_self.span,\n-                _ => {\n-                    bcx.ccx()\n-                       .sess\n-                       .bug(format!(\"create_self_argument_metadata: \\\n-                                     unexpected sort of node: {:?}\",\n-                                     fnitem))\n-                }\n-            }\n-        }\n-        _ => bcx.ccx().sess.bug(\n-                format!(\"create_self_argument_metadata: unexpected sort of node: {:?}\", fnitem))\n-    };\n-\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n-\n-    let argument_index = {\n-        let counter = &bcx.fcx.debug_context.get_ref(bcx.ccx(), span).argument_counter;\n-        let argument_index = counter.get();\n-        counter.set(argument_index + 1);\n-        argument_index\n-    };\n-\n-    let address_operations = &[unsafe { llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()) }];\n-\n-    // The self argument comes in one of two forms:\n-    // (1) For `&self`, `~self`, and `@self` it is an alloca containing a pointer to the data. That\n-    //     is the `{&~@}self` pointer is contained by value in the alloca, and `type_of_self` will\n-    //     be `{&~@}Self`\n-    // (2) For by-value `self`, `llptr` will not be an alloca, but a pointer to the self-value. That\n-    //     is by-value `self` is always implicitly passed by reference (sic!). So we have a couple\n-    //     of problems here:\n-    //     (a) There is no alloca to give to `llvm.dbg.declare` and\n-    //     (b) `type_of_self` is `Self`, but `llptr` is of type `*Self`\n-    //     In order to solve this problem, the else branch below creates a helper alloca which\n-    //     contains a copy of `llptr`. We then describe the `self` parameter by pointing\n-    //     `llvm.dbg.declare` to this helper alloca and tell it that the pointer there needs to be\n-    //     dereferenced once to get to the actual data (similar to non-immediate by-value args).\n-    let variable_access = if unsafe { llvm::LLVMIsAAllocaInst(llptr) } != ptr::null() {\n-        DirectVariable { alloca: llptr }\n-    } else {\n-        // Create a helper alloca that allows us to track the self-argument properly. The alloca\n-        // contains a pointer to the self-value.\n-        let ptr_type = ty::mk_mut_ptr(bcx.tcx(), type_of_self);\n-        let helper_alloca = base::alloc_ty(bcx, ptr_type, \"__self\");\n-        build::Store(bcx, llptr, helper_alloca);\n-\n-        IndirectVariable { alloca: helper_alloca, address_operations: address_operations }\n-    };\n-\n-    declare_local(bcx,\n-                  special_idents::self_,\n-                  type_of_self,\n-                  scope_metadata,\n-                  variable_access,\n-                  ArgumentVariable(argument_index),\n-                  span);\n-}\n-\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n@@ -1768,7 +1688,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n         None                    => ~\"BoxedType\"\n     };\n \n-    let box_llvm_type = Type::smart_ptr(cx, &content_llvm_type);\n+    let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n \n@@ -2584,11 +2504,10 @@ fn populate_scope_map(cx: &CrateContext,\n \n         match exp.node {\n             ast::ExprLogLevel |\n-            ast::ExprSelf     |\n             ast::ExprLit(_)   |\n             ast::ExprBreak(_) |\n             ast::ExprAgain(_) |\n-            ast::ExprPath(_)  => (),\n+            ast::ExprPath(_)  => {}\n \n             ast::ExprVstore(sub_exp, _)   |\n             ast::ExprCast(sub_exp, _)     |\n@@ -2697,8 +2616,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            // ast::expr_loop_body(inner_exp) |\n-            ast::ExprDoBody(inner_exp)   => {\n+            ast::ExprDoBody(inner_exp) => {\n                 let inner_expr_is_expr_fn_block = match *inner_exp {\n                     ast::Expr { node: ast::ExprFnBlock(..), .. } => true,\n                     _ => false\n@@ -2720,9 +2638,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::ExprMethodCall(node_id, receiver_exp, _, _, ref args, _) => {\n+            ast::ExprMethodCall(node_id, _, _, ref args, _) => {\n                 scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, receiver_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {\n                     walk_expr(cx, *arg_exp, scope_stack, scope_map);"}, {"sha": "8de2c1d4cb228c1c518cfe33a9ebcf1c863e084c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 48, "deletions": 95, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -42,7 +42,6 @@ use middle::trans::asm;\n use middle::trans::base::*;\n use middle::trans::base;\n use middle::trans::build::*;\n-use middle::trans::callee::DoAutorefArg;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n@@ -316,16 +315,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         // code and keep it DRY that accommodates that use case at the\n         // moment.\n \n-        let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n-        let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n-        let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        let llval = datum.to_llscalarish(bcx);\n-        Store(bcx, llval, llfn);\n-        let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n-        Store(bcx, base::null_env_ptr(bcx.ccx()), llenv);\n-        DatumBlock(bcx, scratch.to_expr_datum())\n+        let fn_ptr = datum.to_llscalarish(bcx);\n+        let def = ty::resolve_expr(bcx.tcx(), expr);\n+        closure::make_closure_from_bare_fn(bcx, closure_ty, def, fn_ptr)\n     }\n \n     fn auto_slice_and_ref<'a>(\n@@ -517,7 +510,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprParen(e) => {\n             trans(bcx, e)\n         }\n-        ast::ExprPath(_) | ast::ExprSelf => {\n+        ast::ExprPath(_) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         ast::ExprField(base, ident, _) => {\n@@ -669,7 +662,8 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        ast::DefFn(..) | ast::DefStaticMethod(..) => {\n+        ast::DefFn(..) | ast::DefStaticMethod(..) |\n+        ast::DefStruct(_) | ast::DefVariant(..) => {\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n         ast::DefStatic(did, _) => {\n@@ -817,34 +811,33 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n \n     match expr.node {\n         ast::ExprParen(e) => {\n-            return trans_into(bcx, e, dest);\n+            trans_into(bcx, e, dest)\n         }\n-        ast::ExprPath(_) | ast::ExprSelf => {\n-            return trans_def_dps_unadjusted(bcx, expr,\n-                                            bcx.def(expr.id), dest);\n+        ast::ExprPath(_) => {\n+            trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n         ast::ExprIf(cond, thn, els) => {\n-            return controlflow::trans_if(bcx, expr.id, cond, thn, els, dest);\n+            controlflow::trans_if(bcx, expr.id, cond, thn, els, dest)\n         }\n         ast::ExprMatch(discr, ref arms) => {\n-            return _match::trans_match(bcx, expr, discr, *arms, dest);\n+            _match::trans_match(bcx, expr, discr, *arms, dest)\n         }\n         ast::ExprBlock(blk) => {\n             controlflow::trans_block(bcx, blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n-            return trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest);\n+            trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest)\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: ~[(uint, @ast::Expr)] =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n+            trans_adt(bcx, repr, 0, numbered_fields, None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n                 ast::LitStr(s, _) => {\n-                    return tvec::trans_lit_str(bcx, expr, s, dest);\n+                    tvec::trans_lit_str(bcx, expr, s, dest)\n                 }\n                 _ => {\n                     bcx.tcx()\n@@ -859,10 +852,10 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n             bcx = tvec::trans_slice_vstore(bcx, expr, contents, dest);\n-            return fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+            fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id)\n         }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n-            return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n+            tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n         }\n         ast::ExprFnBlock(decl, body) |\n         ast::ExprProc(decl, body) => {\n@@ -871,60 +864,41 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_str(expr, tcx.sess.intr()),\n                    expr_ty.repr(tcx));\n-            return closure::trans_expr_fn(bcx, sigil, decl, body,\n-                                          expr.id, expr.id, dest);\n+            closure::trans_expr_fn(bcx, sigil, decl, body,\n+                                   expr.id, expr.id, dest)\n         }\n         ast::ExprDoBody(blk) => {\n-            return trans_into(bcx, blk, dest);\n+            trans_into(bcx, blk, dest)\n         }\n         ast::ExprCall(f, ref args, _) => {\n-            return callee::trans_call(\n-                bcx, expr, f, callee::ArgExprs(*args), expr.id, dest);\n+            callee::trans_call(bcx, expr, f,\n+                               callee::ArgExprs(*args), expr.id, dest)\n         }\n-        ast::ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n-            return callee::trans_method_call(bcx,\n-                                             expr,\n-                                             callee_id,\n-                                             rcvr,\n-                                             callee::ArgExprs(*args),\n-                                             dest);\n+        ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+            callee::trans_method_call(bcx, expr, callee_id, args[0],\n+                                      callee::ArgExprs(*args), dest)\n         }\n         ast::ExprBinary(callee_id, _, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx,\n-                                       expr,\n-                                       callee_id,\n-                                       lhs,\n-                                       ~[rhs],\n-                                       expr_ty(bcx, expr),\n-                                       dest);\n+            trans_overloaded_op(bcx, expr, callee_id, lhs,\n+                                Some(&*rhs), expr_ty(bcx, expr), dest)\n         }\n         ast::ExprUnary(callee_id, _, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx,\n-                                       expr,\n-                                       callee_id,\n-                                       subexpr,\n-                                       ~[],\n-                                       expr_ty(bcx, expr),\n-                                       dest);\n+            trans_overloaded_op(bcx, expr, callee_id, subexpr,\n+                                None, expr_ty(bcx, expr), dest)\n         }\n         ast::ExprIndex(callee_id, base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx,\n-                                       expr,\n-                                       callee_id,\n-                                       base,\n-                                       ~[idx],\n-                                       expr_ty(bcx, expr),\n-                                       dest);\n+            trans_overloaded_op(bcx, expr, callee_id, base,\n+                                Some(&*idx), expr_ty(bcx, expr), dest)\n         }\n         ast::ExprCast(val, _) => {\n             // DPS output mode means this is a trait cast:\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(..) => {\n                     let datum = unpack_datum!(bcx, trans(bcx, val));\n-                    return meth::trans_trait_cast(bcx, datum, expr.id, dest);\n+                    meth::trans_trait_cast(bcx, datum, expr.id, dest)\n                 }\n                 _ => {\n                     bcx.tcx().sess.span_bug(expr.span,\n@@ -933,12 +907,12 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             }\n         }\n         ast::ExprAssignOp(callee_id, op, dst, src) => {\n-            return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n+            trans_assign_op(bcx, expr, callee_id, op, dst, src)\n         }\n         ast::ExprBox(_, contents) => {\n             // Special case for `Gc<T>` for now. The other case, for unique\n             // pointers, is handled in `trans_rvalue_datum_unadjusted`.\n-            return trans_gc(bcx, expr, contents, dest)\n+            trans_gc(bcx, expr, contents, dest)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -968,8 +942,8 @@ fn trans_def_dps_unadjusted<'a>(\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n-                let fn_data = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n-                Store(bcx, fn_data.llfn, lldest);\n+                let llfn = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n+                Store(bcx, llfn, lldest);\n                 return bcx;\n             } else {\n                 // Nullary variant.\n@@ -980,20 +954,16 @@ fn trans_def_dps_unadjusted<'a>(\n                 return bcx;\n             }\n         }\n-        ast::DefStruct(def_id) => {\n+        ast::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(ccx.tcx, did) => {\n                     let repr = adt::represent_type(ccx, ty);\n                     adt::trans_start_init(bcx, repr, lldest, 0);\n                 }\n-                ty::ty_bare_fn(..) => {\n-                    let fn_data = callee::trans_fn_ref(bcx, def_id, ref_expr.id);\n-                    Store(bcx, fn_data.llfn, lldest);\n-                }\n-                _ => ()\n+                _ => {}\n             }\n-            return bcx;\n+            bcx\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n@@ -1009,16 +979,15 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n-    let fn_data = match def {\n+    let llfn = match def {\n         ast::DefFn(did, _) |\n+        ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n         ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ref_expr.id)\n         }\n         ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n-            meth::trans_static_method_callee(bcx,\n-                                             impl_did,\n-                                             trait_did,\n-                                             ref_expr.id)\n+            meth::trans_static_method_callee(bcx, impl_did,\n+                                             trait_did, ref_expr.id)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n@@ -1029,7 +998,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n     };\n \n     let fn_ty = expr_ty(bcx, ref_expr);\n-    DatumBlock(bcx, Datum(fn_data.llfn, fn_ty, RvalueExpr(Rvalue(ByValue))))\n+    DatumBlock(bcx, Datum(llfn, fn_ty, RvalueExpr(Rvalue(ByValue))))\n }\n \n pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n@@ -1063,21 +1032,6 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n             let lllocals = bcx.fcx.lllocals.borrow();\n             take_local(bcx, lllocals.get(), nid)\n         }\n-        ast::DefSelf(nid, _) => {\n-            let self_info = match bcx.fcx.llself.get() {\n-                Some(self_info) => self_info,\n-                None => {\n-                    bcx.sess().bug(format!(\n-                        \"trans_local_var: reference to self \\\n-                         out of context with id {:?}\", nid));\n-                }\n-            };\n-\n-            debug!(\"def_self() reference, self_info.ty={}\",\n-                   self_info.ty.repr(bcx.tcx()));\n-\n-            self_info\n-        }\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {:?}\", def));\n@@ -1630,12 +1584,12 @@ fn trans_binary<'a>(\n     }\n }\n \n-fn trans_overloaded_op<'a>(\n+fn trans_overloaded_op<'a, 'b>(\n                        bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n-                       rcvr: &ast::Expr,\n-                       args: ~[@ast::Expr],\n+                       rcvr: &'b ast::Expr,\n+                       arg: Option<&'b ast::Expr>,\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> &'a Block<'a> {\n@@ -1655,9 +1609,8 @@ fn trans_overloaded_op<'a>(\n                                                           origin,\n                                                           arg_cleanup_scope)\n                              },\n-                             callee::ArgExprs(args),\n-                             Some(dest),\n-                             DoAutorefArg).bcx\n+                             callee::ArgAutorefSecond(rcvr, arg),\n+                             Some(dest)).bcx\n }\n \n fn int_cast(bcx: &Block,"}, {"sha": "fd0d8a890e33313686272f0165d6a07d3bb3a413", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -480,18 +480,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                id,\n                t.repr(tcx));\n \n-        let llfndecl = base::decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, ps);\n-        base::set_llvm_fn_attrs(attrs, llfndecl);\n-        base::trans_fn(ccx,\n-                       (*path).clone(),\n-                       decl,\n-                       body,\n-                       llfndecl,\n-                       None,\n-                       None,\n-                       id,\n-                       []);\n-        return llfndecl;\n+        let llfn = base::decl_internal_rust_fn(ccx, false, f.sig.inputs, f.sig.output, ps);\n+        base::set_llvm_fn_attrs(attrs, llfn);\n+        base::trans_fn(ccx, (*path).clone(), decl, body, llfn, None, id, []);\n+        llfn\n     }\n \n     unsafe fn build_wrap_fn(ccx: @CrateContext,\n@@ -597,11 +589,6 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n             return_alloca = None;\n         };\n \n-        // Push an (null) env pointer\n-        let env_pointer = base::null_env_ptr(ccx);\n-        debug!(\"env pointer={}\", ccx.tn.val_to_str(env_pointer));\n-        llrust_args.push(env_pointer);\n-\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa."}, {"sha": "5004bcca91e3c1f34e3d428a9fcdf548e89aa949", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 153, "deletions": 167, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -23,7 +23,6 @@ use middle::trans::base::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n-use middle::trans::closure;\n use middle::trans::common::*;\n use middle::trans::build::*;\n use middle::trans::expr;\n@@ -202,37 +201,34 @@ fn lazily_emit_tydesc_glue(ccx: @CrateContext, field: uint, ti: @tydesc_info) {\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: &Block,\n-                             v: ValueRef,\n-                             tydesc: ValueRef,\n-                             field: uint,\n-                             static_ti: Option<@tydesc_info>) {\n+pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n+                             field: uint, static_ti: Option<@tydesc_info>) {\n     let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     if bcx.unreachable.get() && !ccx.sess.no_landing_pads() { return; }\n \n     let static_glue_fn = match static_ti {\n-      None => None,\n-      Some(sti) => {\n-        lazily_emit_tydesc_glue(ccx, field, sti);\n-        if field == abi::tydesc_field_take_glue {\n-            sti.take_glue.get()\n-        } else if field == abi::tydesc_field_drop_glue {\n-            sti.drop_glue.get()\n-        } else if field == abi::tydesc_field_visit_glue {\n-            sti.visit_glue.get()\n-        } else {\n-            None\n+        None => None,\n+        Some(sti) => {\n+            lazily_emit_tydesc_glue(ccx, field, sti);\n+            if field == abi::tydesc_field_take_glue {\n+                sti.take_glue.get()\n+            } else if field == abi::tydesc_field_drop_glue {\n+                sti.drop_glue.get()\n+            } else if field == abi::tydesc_field_visit_glue {\n+                sti.visit_glue.get()\n+            } else {\n+                None\n+            }\n         }\n-      }\n     };\n \n     // When static type info is available, avoid casting parameter unless the\n     // glue is using a simplified type, because the function already has the\n     // right type. Otherwise cast to generic pointer.\n-    let llrawptr = if static_ti.is_none() || static_glue_fn.is_none() {\n+    let llrawptr = if static_glue_fn.is_none() {\n         PointerCast(bcx, v, Type::i8p())\n     } else {\n         let ty = static_ti.unwrap().ty;\n@@ -246,16 +242,16 @@ pub fn call_tydesc_glue_full(bcx: &Block,\n \n     let llfn = {\n         match static_glue_fn {\n-          None => {\n-            // Select out the glue function to call from the tydesc\n-            let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n-            Load(bcx, llfnptr)\n-          }\n-          Some(sgf) => sgf\n+            None => {\n+                // Select out the glue function to call from the tydesc\n+                let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n+                Load(bcx, llfnptr)\n+            }\n+            Some(sgf) => sgf\n         }\n     };\n \n-    Call(bcx, llfn, [C_null(Type::nil().ptr_to()), llrawptr], []);\n+    Call(bcx, llfn, [llrawptr], []);\n }\n \n // See [Note-arg-mode]\n@@ -283,43 +279,7 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-pub fn make_free_glue<'a>(bcx: &'a Block<'a>,\n-                          v: ValueRef,\n-                          t: ty::t)\n-                          -> &'a Block<'a> {\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = push_ctxt(\"make_free_glue\");\n-    match ty::get(t).sty {\n-      ty::ty_box(body_ty) => {\n-        let v = Load(bcx, v);\n-        let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n-        let bcx = drop_ty(bcx, body, body_ty);\n-        trans_free(bcx, v)\n-      }\n-      ty::ty_uniq(content_ty) => {\n-        let llbox = Load(bcx, v);\n-        let not_null = IsNotNull(bcx, llbox);\n-        with_cond(bcx, not_null, |bcx| {\n-                    let bcx = drop_ty(bcx, llbox, content_ty);\n-                    trans_exchange_free(bcx, llbox)\n-                })\n-      }\n-      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n-      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n-        make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n-      }\n-      ty::ty_closure(_) => {\n-        closure::make_closure_glue(bcx, v, t, make_free_glue)\n-      }\n-      ty::ty_opaque_closure_ptr(ck) => {\n-        closure::make_opaque_cbox_free_glue(bcx, ck, v)\n-      }\n-      _ => bcx\n-    }\n-}\n-\n-pub fn trans_struct_drop_flag<'a>(\n-                              bcx: &'a Block<'a>,\n+fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               t: ty::t,\n                               v0: ValueRef,\n                               dtor_did: ast::DefId,\n@@ -333,8 +293,7 @@ pub fn trans_struct_drop_flag<'a>(\n     })\n }\n \n-pub fn trans_struct_drop<'a>(\n-                         bcx: &'a Block<'a>,\n+fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n                          t: ty::t,\n                          v0: ValueRef,\n                          dtor_did: ast::DefId,\n@@ -380,72 +339,99 @@ pub fn trans_struct_drop<'a>(\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, field_scope)\n }\n \n-pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n-                      -> &'a Block<'a> {\n+fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     match ty::get(t).sty {\n-      ty::ty_box(_) |\n-      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n-        decr_refcnt_maybe_free(bcx, v0, Some(t))\n-      }\n-      ty::ty_uniq(_) |\n-      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n-        make_free_glue(bcx, v0, t)\n-      }\n-      ty::ty_unboxed_vec(_) => {\n-        tvec::make_drop_glue_unboxed(bcx, v0, t)\n-      }\n-      ty::ty_struct(did, ref substs) => {\n-        let tcx = bcx.tcx();\n-        match ty::ty_dtor(tcx, did) {\n-          ty::TraitDtor(dtor, true) => {\n-            trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n-          }\n-          ty::TraitDtor(dtor, false) => {\n-            trans_struct_drop(bcx, t, v0, dtor, did, substs)\n-          }\n-          ty::NoDtor => {\n-            // No dtor? Just the default case\n-            iter_structural_ty(bcx, v0, t, drop_ty)\n-          }\n+        ty::ty_box(body_ty) => {\n+            decr_refcnt_maybe_free(bcx, v0, Some(body_ty))\n+        }\n+        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n+            let unit_ty = ty::sequence_element_type(ccx.tcx, t);\n+            let unboxed_vec_ty = ty::mk_mut_unboxed_vec(ccx.tcx, unit_ty);\n+            decr_refcnt_maybe_free(bcx, v0, Some(unboxed_vec_ty))\n+        }\n+        ty::ty_uniq(content_ty) => {\n+            let llbox = Load(bcx, v0);\n+            let not_null = IsNotNull(bcx, llbox);\n+            with_cond(bcx, not_null, |bcx| {\n+                let bcx = drop_ty(bcx, llbox, content_ty);\n+                trans_exchange_free(bcx, llbox)\n+            })\n+        }\n+        ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n+            make_drop_glue(bcx, v0, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n+        }\n+        ty::ty_unboxed_vec(_) => {\n+            tvec::make_drop_glue_unboxed(bcx, v0, t)\n+        }\n+        ty::ty_struct(did, ref substs) => {\n+            let tcx = bcx.tcx();\n+            match ty::ty_dtor(tcx, did) {\n+                ty::TraitDtor(dtor, true) => {\n+                    trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                }\n+                ty::TraitDtor(dtor, false) => {\n+                    trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                }\n+                ty::NoDtor => {\n+                    // No dtor? Just the default case\n+                    iter_structural_ty(bcx, v0, t, drop_ty)\n+                }\n+            }\n+        }\n+        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n+            let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n+            decr_refcnt_maybe_free(bcx, llbox_ptr, None)\n+        }\n+        ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n+            let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+            // Only drop the value when it is non-null\n+            with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n+                let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+\n+                // Cast the vtable to a pointer to a pointer to a tydesc.\n+                let llvtable = PointerCast(bcx, llvtable,\n+                                           ccx.tydesc_type.ptr_to().ptr_to());\n+                let lltydesc = Load(bcx, llvtable);\n+                call_tydesc_glue_full(bcx,\n+                                      lluniquevalue,\n+                                      lltydesc,\n+                                      abi::tydesc_field_drop_glue,\n+                                      None);\n+                bcx\n+            })\n+        }\n+        ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => {\n+            let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n+            let env = Load(bcx, box_cell_v);\n+            let env_ptr_ty = Type::at_box(ccx, Type::i8()).ptr_to();\n+            let env = PointerCast(bcx, env, env_ptr_ty);\n+            with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n+                // Load the type descr found in the env\n+                let lltydescty = ccx.tydesc_type.ptr_to();\n+                let tydescptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n+                let tydesc = Load(bcx, tydescptr);\n+                let tydesc = PointerCast(bcx, tydesc, lltydescty);\n+\n+                // Drop the tuple data then free the descriptor\n+                let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n+                call_tydesc_glue_full(bcx, cdata, tydesc,\n+                                      abi::tydesc_field_drop_glue, None);\n+\n+                // Free the ty descr (if necc) and the env itself\n+                trans_exchange_free(bcx, env)\n+            })\n+        }\n+        _ => {\n+            if ty::type_needs_drop(ccx.tcx, t) &&\n+                ty::type_is_structural(t) {\n+                iter_structural_ty(bcx, v0, t, drop_ty)\n+            } else {\n+                bcx\n+            }\n         }\n-      }\n-      ty::ty_closure(_) => {\n-        closure::make_closure_glue(bcx, v0, t, drop_ty)\n-      }\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n-          let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n-          decr_refcnt_maybe_free(bcx, llbox_ptr, None)\n-      }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n-          let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n-          // Only drop the value when it is non-null\n-          with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n-              let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n-\n-              // Cast the vtable to a pointer to a pointer to a tydesc.\n-              let llvtable = PointerCast(bcx, llvtable,\n-                                         ccx.tydesc_type.ptr_to().ptr_to());\n-              let lltydesc = Load(bcx, llvtable);\n-              call_tydesc_glue_full(bcx,\n-                                    lluniquevalue,\n-                                    lltydesc,\n-                                    abi::tydesc_field_drop_glue,\n-                                    None);\n-              bcx\n-          })\n-      }\n-      ty::ty_opaque_closure_ptr(ck) => {\n-        closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n-      }\n-      _ => {\n-        if ty::type_needs_drop(ccx.tcx, t) &&\n-            ty::type_is_structural(t) {\n-            iter_structural_ty(bcx, v0, t, drop_ty)\n-        } else { bcx }\n-      }\n     }\n }\n \n@@ -468,18 +454,19 @@ fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>, box_ptr_ptr: ValueRef,\n     Store(decr_bcx, rc, rc_ptr);\n     CondBr(decr_bcx, IsNull(decr_bcx, rc), free_bcx.llbb, next_bcx.llbb);\n \n+    let v = Load(free_bcx, box_ptr_ptr);\n+    let body = GEPi(free_bcx, v, [0u, abi::box_field_body]);\n     let free_bcx = match t {\n-        Some(t) => make_free_glue(free_bcx, box_ptr_ptr, t),\n+        Some(t) => drop_ty(free_bcx, body, t),\n         None => {\n-            let v = Load(free_bcx, box_ptr_ptr);\n-            let td = Load(free_bcx, GEPi(free_bcx, v, [0u, abi::box_field_tydesc]));\n-            let valptr = GEPi(free_bcx, v, [0u, abi::box_field_body]);\n             // Generate code that, dynamically, indexes into the\n             // tydesc and calls the drop glue that got set dynamically\n-            call_tydesc_glue_full(free_bcx, valptr, td, abi::tydesc_field_drop_glue, None);\n-            trans_free(free_bcx, v)\n+            let td = Load(free_bcx, GEPi(free_bcx, v, [0u, abi::box_field_tydesc]));\n+            call_tydesc_glue_full(free_bcx, body, td, abi::tydesc_field_drop_glue, None);\n+            free_bcx\n         }\n     };\n+    let free_bcx = trans_free(free_bcx, v);\n     Br(free_bcx, next_bcx.llbb);\n \n     next_bcx\n@@ -489,40 +476,39 @@ fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t) -> &'a Block<'a\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n-      ty::ty_box(_) |\n-      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n-        incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n-      }\n-      ty::ty_vec(_, ty::vstore_slice(_))\n-      | ty::ty_str(ty::vstore_slice(_)) => {\n-        bcx\n-      }\n-      ty::ty_closure(_) => bcx,\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n-        incr_refcnt_of_boxed(bcx, llbox);\n-        bcx\n-      }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n-          let lluniquevalue = GEPi(bcx, v, [0, abi::trt_field_box]);\n-          let llvtable = Load(bcx, GEPi(bcx, v, [0, abi::trt_field_vtable]));\n-\n-          // Cast the vtable to a pointer to a pointer to a tydesc.\n-          let llvtable = PointerCast(bcx, llvtable,\n-                                     bcx.ccx().tydesc_type.ptr_to().ptr_to());\n-          let lltydesc = Load(bcx, llvtable);\n-          call_tydesc_glue_full(bcx,\n-                                lluniquevalue,\n-                                lltydesc,\n-                                abi::tydesc_field_take_glue,\n-                                None);\n-          bcx\n-      }\n-      ty::ty_opaque_closure_ptr(_) => bcx,\n-      _ if ty::type_is_structural(t) => {\n-        iter_structural_ty(bcx, v, t, take_ty)\n-      }\n-      _ => bcx\n+        ty::ty_box(_) |\n+        ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n+            incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n+        }\n+        ty::ty_vec(_, ty::vstore_slice(_))\n+        | ty::ty_str(ty::vstore_slice(_)) => {\n+            bcx\n+        }\n+        ty::ty_closure(_) => bcx,\n+        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n+            let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n+            incr_refcnt_of_boxed(bcx, llbox);\n+            bcx\n+        }\n+        ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n+            let lluniquevalue = GEPi(bcx, v, [0, abi::trt_field_box]);\n+            let llvtable = Load(bcx, GEPi(bcx, v, [0, abi::trt_field_vtable]));\n+\n+            // Cast the vtable to a pointer to a pointer to a tydesc.\n+            let llvtable = PointerCast(bcx, llvtable,\n+                                       bcx.ccx().tydesc_type.ptr_to().ptr_to());\n+            let lltydesc = Load(bcx, llvtable);\n+            call_tydesc_glue_full(bcx,\n+                                  lluniquevalue,\n+                                  lltydesc,\n+                                  abi::tydesc_field_take_glue,\n+                                  None);\n+            bcx\n+        }\n+        _ if ty::type_is_structural(t) => {\n+            iter_structural_ty(bcx, v, t, take_ty)\n+        }\n+        _ => bcx\n     }\n }\n \n@@ -595,7 +581,7 @@ fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, false, ty::mk_nil(), None);\n     init_function(&fcx, false, ty::mk_nil(), None);\n \n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);"}, {"sha": "3a0b97813df50b19b135f925fe24a7fc690cdbbd", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -14,7 +14,6 @@ use middle::astencode;\n use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n \n use std::vec;\n use syntax::ast;\n@@ -160,25 +159,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n               let llfn = get_item_val(ccx, mth.id);\n               let path = vec::append_one(\n                   ty::item_path(ccx.tcx, impl_did), PathName(mth.ident));\n-              let self_kind = match mth.explicit_self.node {\n-                  ast::SelfStatic => None,\n-                  _ => {\n-                      let self_ty = ty::node_id_to_type(ccx.tcx,\n-                                                        mth.self_id);\n-                      debug!(\"calling inline trans_fn with self_ty {}\",\n-                             ty_to_str(ccx.tcx, self_ty));\n-                      Some(self_ty)\n-                  }\n-              };\n-              trans_fn(ccx,\n-                       path,\n-                       mth.decl,\n-                       mth.body,\n-                       llfn,\n-                       self_kind,\n-                       None,\n-                       mth.id,\n-                       []);\n+              trans_fn(ccx, path, mth.decl, mth.body, llfn, None, mth.id, []);\n           }\n           local_def(mth.id)\n         }"}, {"sha": "eb71f6b8f198d12699f8bc7c3b82b879e937da57", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -153,13 +153,8 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n-    let fcx = new_fn_ctxt_detailed(ccx,\n-                                   path,\n-                                   decl,\n-                                   item.id,\n-                                   output_type,\n-                                   Some(substs),\n-                                   Some(item.span));\n+    let fcx = new_fn_ctxt_detailed(ccx, path, decl, item.id, false, output_type,\n+                                   Some(substs), Some(item.span));\n     init_function(&fcx, true, output_type, Some(substs));\n \n     set_always_inline(fcx.llfn);\n@@ -420,7 +415,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // FIXME This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n-            let llfty = type_of_rust_fn(bcx.ccx(), None, [], ty::mk_nil());\n+            let llfty = type_of_rust_fn(bcx.ccx(), false, [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(bcx.ccx().llmod, \"__morestack\",\n                                                llfty, ty::mk_nil());\n             let morestack_addr = PointerCast(bcx, morestack_addr,"}, {"sha": "0301bbf5979abe8a7743ac19ca0519f57541aa0c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 48, "deletions": 120, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -51,7 +51,7 @@ pub fn trans_impl(ccx: @CrateContext,\n                   methods: &[@ast::Method],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n-    let _icx = push_ctxt(\"impl::trans_impl\");\n+    let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx;\n \n     debug!(\"trans_impl(path={}, name={}, id={:?})\",\n@@ -73,11 +73,8 @@ pub fn trans_impl(ccx: @CrateContext,\n             let path = vec::append_one(sub_path.clone(),\n                                        PathName(method.ident));\n \n-            trans_method(ccx,\n-                         path,\n-                         *method,\n-                         None,\n-                         |_| llfn);\n+            trans_fn(ccx, path, method.decl, method.body,\n+                     llfn, None, method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n             visit::walk_method_helper(&mut v, *method, ());\n@@ -91,49 +88,15 @@ pub fn trans_impl(ccx: @CrateContext,\n /// * `path`: the path to the method\n /// * `method`: the AST node for the method\n /// * `param_substs`: if this is a generic method, the current values for\n-///   type parameters and so forth, else none\n-/// * `llfn`: a closure returning the LLVM ValueRef for the method\n-/// * `impl_id`: the node ID of the impl this method is inside\n+///   type parameters and so forth, else None\n+/// * `llfn`: the LLVM ValueRef for the method\n ///\n /// FIXME(pcwalton) Can we take `path` by reference?\n-pub fn trans_method(ccx: @CrateContext,\n-                    path: Path,\n-                    method: &ast::Method,\n+pub fn trans_method(ccx: @CrateContext, path: Path, method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n-                    llfn_with_self: |Option<ty::t>| -> ValueRef) -> ValueRef {\n-    // figure out how self is being passed\n-    let self_ty = match method.explicit_self.node {\n-      ast::SelfStatic => None,\n-      _ => {\n-        // determine the (monomorphized) type that `self` maps to for\n-        // this method\n-        let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n-        let self_ty = match param_substs {\n-            None => self_ty,\n-            Some(param_substs) => {\n-                ty::subst_tps(ccx.tcx,\n-                              param_substs.tys,\n-                              param_substs.self_ty,\n-                              self_ty)\n-            }\n-        };\n-        debug!(\"calling trans_fn with self_ty {}\", self_ty.repr(ccx.tcx));\n-        Some(self_ty)\n-      }\n-    };\n-\n-    let llfn = llfn_with_self(self_ty);\n-\n-    // generate the actual code\n-    trans_fn(ccx,\n-             path,\n-             method.decl,\n-             method.body,\n-             llfn,\n-             self_ty,\n-             param_substs,\n-             method.id,\n-             []);\n+                    llfn: ValueRef) -> ValueRef {\n+    trans_fn(ccx, path, method.decl, method.body,\n+             llfn, param_substs, method.id, []);\n     llfn\n }\n \n@@ -144,31 +107,17 @@ pub fn trans_method_callee<'a>(\n                            mentry: typeck::method_map_entry,\n                            arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n-    let _icx = push_ctxt(\"impl::trans_method_callee\");\n+    let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    debug!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n+    debug!(\"trans_method_callee(callee_id={:?}, mentry={})\",\n            callee_id,\n-           bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n \n     match mentry.origin {\n         typeck::method_static(did) => {\n-            let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-            let Result {bcx, val} = trans_arg_expr(bcx, self_ty, this,\n-                                                   arg_cleanup_scope,\n-                                                   DontAutorefArg);\n-            // HACK should not need the pointer cast, eventually trans_fn_ref\n-            // should return a function type with the right type for self.\n-            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n-            let fn_ty = node_id_type(bcx, callee_id);\n-            let llfn_ty = type_of_fn_from_ty(bcx.ccx(), Some(self_ty), fn_ty).ptr_to();\n-            let llfn_val = PointerCast(bcx, callee_fn.llfn, llfn_ty);\n             Callee {\n                 bcx: bcx,\n-                data: Method(MethodData {\n-                    llfn: llfn_val,\n-                    llself: val,\n-                })\n+                data: Fn(callee::trans_fn_ref(bcx, did, callee_id))\n             }\n         }\n         typeck::method_param(typeck::method_param {\n@@ -184,9 +133,8 @@ pub fn trans_method_callee<'a>(\n                         trait_id);\n \n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, callee_id, this, mentry,\n-                                               trait_id, off, vtbl,\n-                                               arg_cleanup_scope)\n+                    trans_monomorphized_callee(bcx, callee_id,\n+                                               trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n                 None => fail!(\"trans_method_callee: missing param_substs\")\n@@ -207,8 +155,8 @@ pub fn trans_static_method_callee(bcx: &Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   callee_id: ast::NodeId)\n-                                  -> FnData {\n-    let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n+                                  -> ValueRef {\n+    let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n@@ -271,16 +219,13 @@ pub fn trans_static_method_callee(bcx: &Block,\n                     bcx, mth_id, callee_id,\n                     *rcvr_substs, rcvr_origins);\n \n-            let FnData {llfn: lval} =\n-                trans_fn_ref_with_vtables(bcx,\n-                                          mth_id,\n-                                          callee_id,\n-                                          callee_substs,\n-                                          Some(callee_origins));\n+            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, callee_id,\n+                                                 callee_substs,\n+                                                 Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n-            let llty = type_of_fn_from_ty(ccx, None, callee_ty).ptr_to();\n-            FnData {llfn: PointerCast(bcx, lval, llty)}\n+            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n+            PointerCast(bcx, llfn, llty)\n         }\n         _ => {\n             fail!(\"vtable_param left in monomorphized \\\n@@ -312,29 +257,19 @@ pub fn method_with_name(ccx: &CrateContext,\n     meth.def_id\n }\n \n-pub fn trans_monomorphized_callee<'a>(\n-                                  bcx: &'a Block<'a>,\n+fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n                                   callee_id: ast::NodeId,\n-                                  base: &ast::Expr,\n-                                  mentry: typeck::method_map_entry,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n-                                  vtbl: typeck::vtable_origin,\n-                                  arg_cleanup_scope: cleanup::ScopeId)\n+                                  vtbl: typeck::vtable_origin)\n                                   -> Callee<'a> {\n-    let _icx = push_ctxt(\"impl::trans_monomorphized_callee\");\n+    let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n-          // obtain the `self` value:\n-          let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-          let Result {bcx, val} = trans_arg_expr(bcx, self_ty, base,\n-                                                 arg_cleanup_scope,\n-                                                 DontAutorefArg);\n-\n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n@@ -343,26 +278,13 @@ pub fn trans_monomorphized_callee<'a>(\n                   *rcvr_substs, rcvr_origins);\n \n           // translate the function\n-          let callee = trans_fn_ref_with_vtables(bcx,\n-                                                 mth_id,\n-                                                 callee_id,\n-                                                 callee_substs,\n-                                                 Some(callee_origins));\n+          let llfn = trans_fn_ref_with_vtables(bcx,\n+                                               mth_id,\n+                                               callee_id,\n+                                               callee_substs,\n+                                               Some(callee_origins));\n \n-          // create a llvalue that represents the fn ptr\n-          // HACK should not need the pointer cast (add self in trans_fn_ref_with_vtables).\n-          let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = type_of_fn_from_ty(ccx, Some(self_ty), fn_ty).ptr_to();\n-          let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n-\n-          // combine the self environment with the rest\n-          Callee {\n-              bcx: bcx,\n-              data: Method(MethodData {\n-                  llfn: llfn_val,\n-                  llself: val,\n-              })\n-          }\n+          Callee { bcx: bcx, data: Fn(llfn) }\n       }\n       typeck::vtable_param(..) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n@@ -420,8 +342,7 @@ pub fn combine_impl_and_methods_tps(bcx: &Block,\n     return (ty_substs, vtables);\n }\n \n-pub fn trans_trait_callee<'a>(\n-                          bcx: &'a Block<'a>,\n+fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n                           self_expr: &ast::Expr,\n@@ -436,7 +357,7 @@ pub fn trans_trait_callee<'a>(\n      * pair.\n      */\n \n-    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let mut bcx = bcx;\n \n     // Translate self_datum and take ownership of the value by\n@@ -469,18 +390,26 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n      * a by-ref pointer to the object pair.\n      */\n \n-    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n-    let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n+    let llself = PointerCast(bcx, llbox, Type::i8p());\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n-    let llcallee_ty = type_of_fn_from_ty(ccx, None, callee_ty);\n+    // Replace the self type (&Self or ~Self) with an opaque pointer.\n+    let llcallee_ty = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref f) if f.abis.is_rust() => {\n+            type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n+        }\n+        _ => {\n+            ccx.sess.bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n+        }\n+    };\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n@@ -491,7 +420,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n \n     return Callee {\n         bcx: bcx,\n-        data: Method(MethodData {\n+        data: TraitMethod(MethodData {\n             llfn: mptr,\n             llself: llself,\n         })\n@@ -528,7 +457,7 @@ pub fn get_vtable(bcx: &Block,\n                   origins: typeck::vtable_param_res)\n                   -> ValueRef {\n     let ccx = bcx.ccx();\n-    let _icx = push_ctxt(\"impl::get_vtable\");\n+    let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n     let hash_id = (self_ty, vtable_id(ccx, &origins[0]));\n@@ -567,7 +496,7 @@ pub fn make_vtable(ccx: &CrateContext,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n-        let _icx = push_ctxt(\"impl::make_vtable\");\n+        let _icx = push_ctxt(\"meth::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n         for &ptr in ptrs.iter() {\n@@ -618,8 +547,7 @@ fn emit_vtable_methods(bcx: &Block,\n                    tcx.sess.str_of(ident));\n             C_null(Type::nil().ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, 0,\n-                                      substs, Some(vtables)).llfn\n+            trans_fn_ref_with_vtables(bcx, m_id, 0, substs, Some(vtables))\n         }\n     })\n }\n@@ -637,7 +565,7 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n      */\n \n     let mut bcx = bcx;\n-    let _icx = push_ctxt(\"impl::trans_cast\");\n+    let _icx = push_ctxt(\"meth::trans_cast\");\n \n     let lldest = match dest {\n         Ignore => {"}, {"sha": "678d23c0e1931348f04b372fc424be25efb9f60f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -213,8 +213,10 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n     debug!(\"monomorphize_fn mangled to {}\", s);\n \n-    let mk_lldecl = |self_ty| {\n-        let lldecl = decl_internal_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, s);\n+    let mk_lldecl = || {\n+        let lldecl = decl_internal_rust_fn(ccx, false,\n+                                           f.sig.inputs,\n+                                           f.sig.output, s);\n         let mut monomorphized = ccx.monomorphized.borrow_mut();\n         monomorphized.get().insert(hash_id, lldecl);\n         lldecl\n@@ -227,17 +229,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                 node: ast::ItemFn(decl, _, _, _, body),\n                 ..\n             } => {\n-                let d = mk_lldecl(None);\n+                let d = mk_lldecl();\n                 set_llvm_fn_attrs(i.attrs, d);\n-                trans_fn(ccx,\n-                         pt,\n-                         decl,\n-                         body,\n-                         d,\n-                         None,\n-                         Some(psubsts),\n-                         fn_id.node,\n-                         []);\n+                trans_fn(ccx, pt, decl, body, d, Some(psubsts), fn_id.node, []);\n                 d\n             }\n             _ => {\n@@ -246,15 +240,15 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n           }\n       }\n       ast_map::NodeForeignItem(i, _, _, _) => {\n-          let d = mk_lldecl(None);\n+          let d = mk_lldecl();\n           intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n                                      ref_id);\n           d\n       }\n       ast_map::NodeVariant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n-        let d = mk_lldecl(None);\n+        let d = mk_lldecl();\n         set_inline_hint(d);\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) => {\n@@ -272,24 +266,19 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         d\n       }\n       ast_map::NodeMethod(mth, _, _) => {\n-        meth::trans_method(ccx, pt, mth, Some(psubsts), |self_ty| {\n-            let d = mk_lldecl(self_ty);\n-            set_llvm_fn_attrs(mth.attrs, d);\n-            d\n-        })\n+        let d = mk_lldecl();\n+        set_llvm_fn_attrs(mth.attrs, d);\n+        trans_fn(ccx, pt, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n+        d\n       }\n       ast_map::NodeTraitMethod(method, _, pt) => {\n           match *method {\n               ast::Provided(mth) => {\n-                meth::trans_method(ccx,\n-                                   (*pt).clone(),\n-                                   mth,\n-                                   Some(psubsts),\n-                                   |self_ty| {\n-                    let d = mk_lldecl(self_ty);\n-                    set_llvm_fn_attrs(mth.attrs, d);\n-                    d\n-                })\n+                  let d = mk_lldecl();\n+                  set_llvm_fn_attrs(mth.attrs, d);\n+                  trans_fn(ccx, (*pt).clone(), mth.decl, mth.body,\n+                           d, Some(psubsts), mth.id, []);\n+                  d\n               }\n               _ => {\n                 ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\",\n@@ -298,7 +287,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n           }\n       }\n       ast_map::NodeStructCtor(struct_def, _, _) => {\n-        let d = mk_lldecl(None);\n+        let d = mk_lldecl();\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n                                  struct_def.fields,"}, {"sha": "46086828329242183619feb6daa7daa489667cea", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -13,7 +13,7 @@ use lib::llvm::{ValueRef, llvm};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n-use middle::trans::callee::{ArgVals, DontAutorefArg};\n+use middle::trans::callee::ArgVals;\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n@@ -111,7 +111,7 @@ impl<'a> Reflector<'a> {\n                                                          mth_ty,\n                                                          mth_idx,\n                                                          v),\n-            ArgVals(args), None, DontAutorefArg));\n+            ArgVals(args), None));\n         let result = bool_to_i1(bcx, result);\n         let next_bcx = fcx.new_temp_block(\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n@@ -292,12 +292,10 @@ impl<'a> Reflector<'a> {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, None, [opaqueptrty], ty::mk_u64(), sym);\n-                let fcx = new_fn_ctxt(ccx,\n-                                      ~[],\n-                                      llfdecl,\n-                                      ty::mk_u64(),\n-                                      None);\n+                let llfdecl = decl_internal_rust_fn(ccx, false,\n+                                                    [opaqueptrty],\n+                                                    ty::mk_u64(), sym);\n+                let fcx = new_fn_ctxt(ccx, ~[], llfdecl, false, ty::mk_u64(), None);\n                 init_function(&fcx, false, ty::mk_u64(), None);\n \n                 let arg = unsafe {\n@@ -358,12 +356,7 @@ impl<'a> Reflector<'a> {\n               self.visit(\"param\", extra)\n           }\n           ty::ty_self(..) => self.leaf(\"self\"),\n-          ty::ty_type => self.leaf(\"type\"),\n-          ty::ty_opaque_closure_ptr(ck) => {\n-              let ckval = ast_sigil_constant(ck);\n-              let extra = ~[self.c_uint(ckval)];\n-              self.visit(\"closure_ptr\", extra)\n-          }\n+          ty::ty_type => self.leaf(\"type\")\n         }\n     }\n "}, {"sha": "bbaf94afabe8cee95829596804c2532358d8f8dd", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -160,10 +160,6 @@ impl Type {\n                                    args.len() as c_uint, True))\n     }\n \n-    pub fn func_pair(cx: &CrateContext, fn_ty: &Type) -> Type {\n-        Type::struct_([fn_ty.ptr_to(), Type::opaque_cbox_ptr(cx)], false)\n-    }\n-\n     pub fn ptr(ty: Type) -> Type {\n         ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n     }\n@@ -200,8 +196,7 @@ impl Type {\n     }\n \n     pub fn glue_fn(t: Type) -> Type {\n-        Type::func([ Type::nil().ptr_to(), t ],\n-            &Type::void())\n+        Type::func([t], &Type::void())\n     }\n \n     pub fn tydesc(arch: Architecture) -> Type {\n@@ -213,7 +208,6 @@ impl Type {\n         // Must mirror:\n         //\n         // std::unstable::intrinsics::TyDesc\n-        // type_desc in rt\n \n         let elems = [int_ty,     // size\n                      int_ty,     // align\n@@ -244,38 +238,18 @@ impl Type {\n         Type::vec(arch, &Type::i8())\n     }\n \n-    #[inline]\n-    pub fn box_header_fields(ctx: &CrateContext) -> ~[Type] {\n-        ~[\n+    // The box pointed to by @T.\n+    pub fn at_box(ctx: &CrateContext, ty: Type) -> Type {\n+        Type::struct_([\n             ctx.int_type, ctx.tydesc_type.ptr_to(),\n-            Type::i8().ptr_to(), Type::i8().ptr_to()\n-        ]\n-    }\n-\n-    pub fn box_header(ctx: &CrateContext) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx), false)\n-    }\n-\n-    pub fn smart_ptr(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n-    }\n-\n-    pub fn opaque() -> Type {\n-        Type::i8()\n-    }\n-\n-    pub fn opaque_box(ctx: &CrateContext) -> Type {\n-        Type::smart_ptr(ctx, &Type::opaque())\n-    }\n-\n-    pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {\n-        Type::opaque_box(cx).ptr_to()\n+            Type::i8p(), Type::i8p(), ty\n+        ], false)\n     }\n \n     pub fn opaque_trait(ctx: &CrateContext, store: ty::TraitStore) -> Type {\n         let tydesc_ptr = ctx.tydesc_type.ptr_to();\n         let box_ty = match store {\n-            ty::BoxTraitStore => Type::opaque_box(ctx),\n+            ty::BoxTraitStore => Type::at_box(ctx, Type::i8()),\n             ty::UniqTraitStore => Type::i8(),\n             ty::RegionTraitStore(..) => Type::i8()\n         };"}, {"sha": "a4228fbd17b3db731e4d2d953e9efba90ebec34a", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -38,15 +38,8 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_explicit_args(ccx: &CrateContext,\n-                             inputs: &[ty::t]) -> ~[Type] {\n-    inputs.map(|&arg_ty| type_of_explicit_arg(ccx, arg_ty))\n-}\n-\n-pub fn type_of_rust_fn(cx: &CrateContext,\n-                       self_ty: Option<ty::t>,\n-                       inputs: &[ty::t],\n-                       output: ty::t) -> Type {\n+pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n+                       inputs: &[ty::t], output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n \n     // Arg 0: Output pointer.\n@@ -58,14 +51,13 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n     }\n \n     // Arg 1: Environment\n-    let env = match self_ty {\n-        Some(t) => type_of_explicit_arg(cx, t),\n-        None => Type::opaque_box(cx).ptr_to()\n-    };\n-    atys.push(env);\n+    if has_env {\n+        atys.push(Type::i8p());\n+    }\n \n     // ... then explicit args.\n-    atys.push_all(type_of_explicit_args(cx, inputs));\n+    let mut input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n+    atys.extend(&mut input_tys);\n \n     // Use the output as the actual return value if it's immediate.\n     if use_out_pointer || return_type_is_void(cx, output) {\n@@ -76,22 +68,22 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &CrateContext, self_ty: Option<ty::t>, fty: ty::t) -> Type {\n-    return match ty::get(fty).sty {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n+    match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, None, f.sig.inputs, f.sig.output)\n+            type_of_rust_fn(cx, true, f.sig.inputs, f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abis.is_rust() || f.abis.is_intrinsic() {\n-                type_of_rust_fn(cx, self_ty, f.sig.inputs, f.sig.output)\n+                type_of_rust_fn(cx, false, f.sig.inputs, f.sig.output)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n         }\n         _ => {\n             cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n-    };\n+    }\n }\n \n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n@@ -130,8 +122,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n-        ty::ty_type |\n-        ty::ty_opaque_closure_ptr(..) => Type::i8p(),\n+        ty::ty_type => Type::i8p(),\n \n         ty::ty_str(ty::vstore_slice(..)) |\n         ty::ty_vec(_, ty::vstore_slice(..)) => {\n@@ -231,18 +222,14 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         adt::incomplete_type_of(cx, repr, name)\n       }\n       ty::ty_str(ty::vstore_box) => {\n-        Type::smart_ptr(cx,\n-                        &Type::vec(cx.sess.targ_cfg.arch,\n-                                   &Type::i8())).ptr_to()\n+          Type::at_box(cx, Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n       }\n       ty::ty_vec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n-          let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n-          Type::smart_ptr(cx, &v_ty).ptr_to()\n+          Type::at_box(cx, Type::vec(cx.sess.targ_cfg.arch, &e_ty)).ptr_to()\n       }\n       ty::ty_box(typ) => {\n-          let ty = type_of(cx, typ);\n-          Type::smart_ptr(cx, &ty).ptr_to()\n+          Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n       ty::ty_uniq(typ) => {\n           type_of(cx, typ).ptr_to()\n@@ -278,19 +265,18 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n \n       ty::ty_bare_fn(_) => {\n-          type_of_fn_from_ty(cx, None, t).ptr_to()\n+          type_of_fn_from_ty(cx, t).ptr_to()\n       }\n       ty::ty_closure(_) => {\n-          let ty = type_of_fn_from_ty(cx, None, t);\n-          Type::func_pair(cx, &ty)\n+          let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n+          Type::struct_([fn_ty, Type::i8p()], false)\n       }\n       ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, repr)\n       }\n-      ty::ty_opaque_closure_ptr(_) => Type::opaque_box(cx).ptr_to(),\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx, t) {\n               let et = ty::simd_type(cx.tcx, t);"}, {"sha": "a31b8413550a789a985cdc9d0cb49425d5f54276", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 68, "deletions": 85, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -73,7 +73,6 @@ pub enum MethodContainer {\n pub struct Method {\n     ident: ast::Ident,\n     generics: ty::Generics,\n-    transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n     explicit_self: ast::ExplicitSelf_,\n     vis: ast::Visibility,\n@@ -87,25 +86,16 @@ pub struct Method {\n impl Method {\n     pub fn new(ident: ast::Ident,\n                generics: ty::Generics,\n-               transformed_self_ty: Option<ty::t>,\n                fty: BareFnTy,\n                explicit_self: ast::ExplicitSelf_,\n                vis: ast::Visibility,\n                def_id: ast::DefId,\n                container: MethodContainer,\n                provided_source: Option<ast::DefId>)\n                -> Method {\n-        // Check the invariants.\n-        if explicit_self == ast::SelfStatic {\n-            assert!(transformed_self_ty.is_none());\n-        } else {\n-            assert!(transformed_self_ty.is_some());\n-        }\n-\n        Method {\n             ident: ident,\n             generics: generics,\n-            transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             explicit_self: explicit_self,\n             vis: vis,\n@@ -650,7 +640,6 @@ pub enum sty {\n \n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n-    ty_opaque_closure_ptr(Sigil), // ptr to env for || and proc\n     ty_unboxed_vec(mt),\n }\n \n@@ -1068,7 +1057,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= get(mt.ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str(_) | &ty_type | &ty_opaque_closure_ptr(_) => {}\n+      &ty_str(_) | &ty_type => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n       // rid of the has_ty_err flag -- likewise for ty_bot (with\n@@ -1333,10 +1322,6 @@ pub fn mk_param(cx: ctxt, n: uint, k: DefId) -> t {\n \n pub fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n-    mk_t(cx, ty_opaque_closure_ptr(sigil))\n-}\n-\n pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1346,27 +1331,27 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         return;\n     }\n     match get(ty).sty {\n-      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str(_) | ty_type | ty_self(_) |\n-      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {}\n-      ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n-      ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n-      ty_rptr(_, ref tm) => {\n-        maybe_walk_ty(tm.ty, f);\n-      }\n-      ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n-      ty_trait(_, ref substs, _, _, _) => {\n-        for subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n-      }\n-      ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n-      ty_bare_fn(ref ft) => {\n-        for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-        maybe_walk_ty(ft.sig.output, f);\n-      }\n-      ty_closure(ref ft) => {\n-        for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-        maybe_walk_ty(ft.sig.output, f);\n-      }\n+        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_str(_) | ty_type | ty_self(_) |\n+        ty_infer(_) | ty_param(_) | ty_err => {}\n+        ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n+        ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n+        ty_rptr(_, ref tm) => {\n+            maybe_walk_ty(tm.ty, f);\n+        }\n+        ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n+        ty_trait(_, ref substs, _, _, _) => {\n+            for subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n+        }\n+        ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n+        ty_bare_fn(ref ft) => {\n+            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            maybe_walk_ty(ft.sig.output, f);\n+        }\n+        ty_closure(ref ft) => {\n+            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            maybe_walk_ty(ft.sig.output, f);\n+        }\n     }\n }\n \n@@ -1608,11 +1593,8 @@ pub fn type_is_vec(ty: t) -> bool {\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_uniq(_) |\n-        ty_vec(_, vstore_uniq) |\n-        ty_str(vstore_uniq) |\n-        ty_opaque_closure_ptr(ast::OwnedSigil) => true,\n-        _ => return false\n+        ty_uniq(_) | ty_vec(_, vstore_uniq) | ty_str(vstore_uniq) => true,\n+        _ => false\n     }\n }\n \n@@ -2118,13 +2100,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC::All\n             }\n             ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n-            ty_opaque_closure_ptr(sigil) => {\n-                match sigil {\n-                    ast::BorrowedSigil => TC::ReachesBorrowed,\n-                    ast::ManagedSigil => TC::Managed,\n-                    ast::OwnedSigil => TC::OwnsOwned,\n-                }\n-            }\n \n             ty_type => TC::None,\n \n@@ -2308,7 +2283,6 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_param(_) |\n             ty_self(_) |\n             ty_type |\n-            ty_opaque_closure_ptr(_) |\n             ty_vec(_, _) |\n             ty_unboxed_vec(_) => {\n                 false\n@@ -2511,7 +2485,6 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         result = type_is_pod(cx, mt.ty);\n       }\n       ty_param(_) => result = false,\n-      ty_opaque_closure_ptr(_) => result = true,\n       ty_struct(did, ref substs) => {\n         let fields = lookup_struct_fields(cx, did);\n         result = fields.iter().all(|f| {\n@@ -3139,22 +3112,37 @@ pub fn expr_kind(tcx: ctxt,\n     }\n \n     match expr.node {\n-        ast::ExprPath(..) | ast::ExprSelf => {\n+        ast::ExprPath(..) => {\n             match resolve_expr(tcx, expr) {\n-                ast::DefVariant(..) | ast::DefStruct(..) => RvalueDpsExpr,\n+                ast::DefVariant(tid, vid, _) => {\n+                    let variant_info = enum_variant_with_id(tcx, tid, vid);\n+                    if variant_info.args.len() > 0u {\n+                        // N-ary variant.\n+                        RvalueDatumExpr\n+                    } else {\n+                        // Nullary variant.\n+                        RvalueDpsExpr\n+                    }\n+                }\n+\n+                ast::DefStruct(_) => {\n+                    match get(expr_ty(tcx, expr)).sty {\n+                        ty_bare_fn(..) => RvalueDatumExpr,\n+                        _ => RvalueDpsExpr\n+                    }\n+                }\n \n                 // Fn pointers are just scalar values.\n                 ast::DefFn(..) | ast::DefStaticMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n-                // def_args, particularly those of immediate type, ought to\n+                // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n                 ast::DefStatic(..) |\n                 ast::DefBinding(..) |\n                 ast::DefUpvar(..) |\n                 ast::DefArg(..) |\n-                ast::DefLocal(..) |\n-                ast::DefSelf(..) => LvalueExpr,\n+                ast::DefLocal(..) => LvalueExpr,\n \n                 def => {\n                     tcx.sess.span_bug(expr.span, format!(\n@@ -3343,30 +3331,29 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n \n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n-      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n-      ty_uint(_) | ty_float(_) | ty_str(_) |\n-      ty_type | ty_opaque_closure_ptr(_) => {\n-        ::util::ppaux::ty_to_str(cx, t)\n-      }\n-\n-      ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n-      ty_box(_) => ~\"@-ptr\",\n-      ty_uniq(_) => ~\"~-ptr\",\n-      ty_vec(_, _) => ~\"vector\",\n-      ty_unboxed_vec(_) => ~\"unboxed vector\",\n-      ty_ptr(_) => ~\"*-ptr\",\n-      ty_rptr(_, _) => ~\"&-ptr\",\n-      ty_bare_fn(_) => ~\"extern fn\",\n-      ty_closure(_) => ~\"fn\",\n-      ty_trait(id, _, _, _, _) => format!(\"trait {}\", item_path_str(cx, id)),\n-      ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n-      ty_tup(_) => ~\"tuple\",\n-      ty_infer(TyVar(_)) => ~\"inferred type\",\n-      ty_infer(IntVar(_)) => ~\"integral variable\",\n-      ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n-      ty_param(_) => ~\"type parameter\",\n-      ty_self(_) => ~\"self\",\n-      ty_err => ~\"type error\"\n+        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n+        ty_uint(_) | ty_float(_) | ty_str(_) | ty_type => {\n+            ::util::ppaux::ty_to_str(cx, t)\n+        }\n+\n+        ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n+        ty_box(_) => ~\"@-ptr\",\n+        ty_uniq(_) => ~\"~-ptr\",\n+        ty_vec(_, _) => ~\"vector\",\n+        ty_unboxed_vec(_) => ~\"unboxed vector\",\n+        ty_ptr(_) => ~\"*-ptr\",\n+        ty_rptr(_, _) => ~\"&-ptr\",\n+        ty_bare_fn(_) => ~\"extern fn\",\n+        ty_closure(_) => ~\"fn\",\n+        ty_trait(id, _, _, _, _) => format!(\"trait {}\", item_path_str(cx, id)),\n+        ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n+        ty_tup(_) => ~\"tuple\",\n+        ty_infer(TyVar(_)) => ~\"inferred type\",\n+        ty_infer(IntVar(_)) => ~\"integral variable\",\n+        ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n+        ty_param(_) => ~\"type parameter\",\n+        ty_self(_) => ~\"self\",\n+        ty_err => ~\"type error\"\n     }\n }\n \n@@ -4912,12 +4899,8 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n             ty_infer(_) => unreachable!(),\n             ty_err => hash.input([23]),\n             ty_type => hash.input([24]),\n-            ty_opaque_closure_ptr(s) => {\n-                hash.input([25]);\n-                iter(&mut hash, &s);\n-            }\n             ty_unboxed_vec(m) => {\n-                hash.input([26]);\n+                hash.input([25]);\n                 mt(&mut hash, m);\n             }\n         }"}, {"sha": "e322792c996802f273f72a8c6a76338e9b3a043f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -189,7 +189,6 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n         ty::ty_int(_) | ty::ty_uint(_) |\n         ty::ty_float(_) | ty::ty_type |\n-        ty::ty_opaque_closure_ptr(_) |\n         ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) | ty::ty_self(_) => {\n             (*sty).clone()"}, {"sha": "f1e1f379b0c5e0d691bce69b431aa2b2f628913f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 44, "deletions": 62, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -589,13 +589,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC:AstConv,\n-                 RS:RegionScope>(\n-                 this: &AC,\n-                 rscope: &RS,\n-                 a: &ast::Arg,\n-                 expected_ty: Option<ty::t>)\n-                 -> ty::t {\n+pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::Arg,\n+                                               expected_ty: Option<ty::t>) -> ty::t {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -614,77 +609,38 @@ pub fn ty_of_method<AC:AstConv>(\n     purity: ast::Purity,\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::ExplicitSelf,\n-    decl: &ast::FnDecl) -> (Option<ty::t>, ty::BareFnTy)\n-{\n-    let self_info = SelfInfo {\n+    decl: &ast::FnDecl) -> ty::BareFnTy {\n+    ty_of_method_or_bare_fn(this, id, purity, AbiSet::Rust(), Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self\n-    };\n-    let (a, b) = ty_of_method_or_bare_fn(\n-        this, id, purity, AbiSet::Rust(), Some(&self_info), decl);\n-    (a.unwrap(), b)\n+    }), decl)\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv>(\n-    this: &AC,\n-    id: ast::NodeId,\n-    purity: ast::Purity,\n-    abi: AbiSet,\n-    decl: &ast::FnDecl) -> ty::BareFnTy\n-{\n-    let (_, b) = ty_of_method_or_bare_fn(this, id, purity,\n-                                         abi, None, decl);\n-    b\n+pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n+                                 purity: ast::Purity, abi: AbiSet,\n+                                 decl: &ast::FnDecl) -> ty::BareFnTy {\n+    ty_of_method_or_bare_fn(this, id, purity, abi, None, decl)\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv>(\n-    this: &AC,\n-    id: ast::NodeId,\n-    purity: ast::Purity,\n-    abi: AbiSet,\n-    opt_self_info: Option<&SelfInfo>,\n-    decl: &ast::FnDecl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n-{\n+fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n+                                       purity: ast::Purity, abi: AbiSet,\n+                                       opt_self_info: Option<SelfInfo>,\n+                                       decl: &ast::FnDecl) -> ty::BareFnTy {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n-    let opt_transformed_self_ty = opt_self_info.map(|self_info| {\n-        transform_self_ty(this, &rb, self_info)\n-    });\n-\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n-\n-    let output_ty = match decl.output.node {\n-        ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n-    };\n-\n-    return (opt_transformed_self_ty,\n-            ty::BareFnTy {\n-                purity: purity,\n-                abis: abi,\n-                sig: ty::FnSig {binder_id: id,\n-                                inputs: input_tys,\n-                                output: output_ty,\n-                                variadic: decl.variadic}\n-            });\n-\n-    fn transform_self_ty<AC:AstConv,RS:RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        self_info: &SelfInfo) -> Option<ty::t>\n-    {\n+    let self_ty = opt_self_info.and_then(|self_info| {\n         match self_info.explicit_self.node {\n             ast::SelfStatic => None,\n-            ast::SelfValue(_) => {\n+            ast::SelfValue => {\n                 Some(self_info.untransformed_self_ty)\n             }\n             ast::SelfRegion(ref lifetime, mutability) => {\n                 let region =\n-                    opt_ast_region_to_region(this, rscope,\n+                    opt_ast_region_to_region(this, &rb,\n                                              self_info.explicit_self.span,\n                                              lifetime);\n                 Some(ty::mk_rptr(this.tcx(), region,\n@@ -694,11 +650,37 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n             ast::SelfBox => {\n                 Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n             }\n-            ast::SelfUniq(_) => {\n+            ast::SelfUniq => {\n                 Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n         }\n-    }\n+    });\n+\n+    // HACK(eddyb) replace the fake self type in the AST with the actual type.\n+    let input_tys = if self_ty.is_some() {\n+        decl.inputs.slice_from(1)\n+    } else {\n+        decl.inputs.as_slice()\n+    };\n+    let input_tys = input_tys.iter().map(|a| ty_of_arg(this, &rb, a, None));\n+\n+    let self_and_input_tys = self_ty.move_iter().chain(input_tys).collect();\n+\n+    let output_ty = match decl.output.node {\n+        ast::TyInfer => this.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(this, &rb, decl.output)\n+    };\n+\n+    return ty::BareFnTy {\n+        purity: purity,\n+        abis: abi,\n+        sig: ty::FnSig {\n+            binder_id: id,\n+            inputs: self_and_input_tys,\n+            output: output_ty,\n+            variadic: decl.variadic\n+        }\n+    };\n }\n \n pub fn ty_of_closure<AC:AstConv,RS:RegionScope>("}, {"sha": "398b4cca015b4e0bbb9f6ecb4a2505475edf23ae", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -80,6 +80,7 @@ obtained the type `Foo`, we would never match this method.\n */\n \n \n+use middle::subst::Subst;\n use middle::resolve;\n use middle::ty::*;\n use middle::ty;\n@@ -422,19 +423,16 @@ impl<'a> LookupContext<'a> {\n             |new_trait_ref, m, method_num, _bound_num| {\n             let vtable_index =\n                 self.get_method_index(new_trait_ref, trait_ref, method_num);\n+            let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n-            let transformed_self_ty =\n+            m.fty.sig.inputs[0] =\n                 self.construct_transformed_self_ty_for_object(\n-                    did, &rcvr_substs, m);\n-            let m = @Method {\n-                transformed_self_ty: Some(transformed_self_ty),\n-                .. (*m).clone()\n-            };\n+                    did, &rcvr_substs, &m);\n \n             Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n                 rcvr_substs: new_trait_ref.substs.clone(),\n-                method_ty: m,\n+                method_ty: @m,\n                 origin: method_object(method_object {\n                         trait_id: new_trait_ref.def_id,\n                         object_trait_id: did,\n@@ -790,8 +788,7 @@ impl<'a> LookupContext<'a> {\n \n             ty_err => None,\n \n-            ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n-            ty_type | ty_infer(TyVar(_)) => {\n+            ty_unboxed_vec(_) | ty_type | ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"Unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }\n@@ -932,32 +929,25 @@ impl<'a> LookupContext<'a> {\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                              -> method_map_entry {\n+        // This method performs two sets of substitutions, one after the other:\n+        // 1. Substitute values for any type/lifetime parameters from the impl and\n+        //    method declaration into the method type. This is the function type\n+        //    before it is called; it may still include late bound region variables.\n+        // 2. Instantiate any late bound lifetime parameters in the method itself\n+        //    with fresh region variables.\n+\n         let tcx = self.tcx();\n-        let fty = ty::mk_bare_fn(tcx, candidate.method_ty.fty.clone());\n \n-        debug!(\"confirm_candidate(expr={}, candidate={}, fty={})\",\n+        debug!(\"confirm_candidate(expr={}, candidate={})\",\n                self.expr.repr(tcx),\n-               self.cand_to_str(candidate),\n-               self.ty_to_str(fty));\n+               self.cand_to_str(candidate));\n \n-        self.enforce_object_limitations(fty, candidate);\n+        self.enforce_object_limitations(candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != SelfStatic);\n \n-        let transformed_self_ty = match candidate.origin {\n-            method_object(..) => {\n-                // For annoying reasons, we've already handled the\n-                // substitution for object calls.\n-                candidate.method_ty.transformed_self_ty.unwrap()\n-            }\n-            _ => {\n-                ty::subst(tcx, &candidate.rcvr_substs,\n-                          candidate.method_ty.transformed_self_ty.unwrap())\n-            }\n-        };\n-\n         // Determine the values for the type parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // type variables.\n@@ -990,29 +980,41 @@ impl<'a> LookupContext<'a> {\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n \n+        let ref bare_fn_ty = candidate.method_ty.fty;\n+\n         // Compute the method type with type parameters substituted\n         debug!(\"fty={} all_substs={}\",\n-               self.ty_to_str(fty),\n+               bare_fn_ty.repr(tcx),\n                ty::substs_to_str(tcx, &all_substs));\n-        let fty = ty::subst(tcx, &all_substs, fty);\n-        debug!(\"after subst, fty={}\", self.ty_to_str(fty));\n \n-        // Replace any bound regions that appear in the function\n-        // signature with region variables\n-        let bare_fn_ty = match ty::get(fty).sty {\n-            ty::ty_bare_fn(ref f) => f,\n-            ref s => {\n-                tcx.sess.span_bug(\n-                    self.expr.span,\n-                    format!(\"Invoking method with non-bare-fn ty: {:?}\", s));\n+        let fn_sig = &bare_fn_ty.sig;\n+        let inputs = match candidate.origin {\n+            method_object(..) => {\n+                // For annoying reasons, we've already handled the\n+                // substitution of self for object calls.\n+                let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n+                    t.subst(tcx, &all_substs)\n+                });\n+                Some(fn_sig.inputs[0]).move_iter().chain(args).collect()\n             }\n+            _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };\n-        let (_, opt_transformed_self_ty, fn_sig) =\n-            replace_bound_regions_in_fn_sig(\n-                tcx, Some(transformed_self_ty), &bare_fn_ty.sig,\n-                |br| self.fcx.infcx().next_region_var(\n-                    infer::BoundRegionInFnCall(self.expr.span, br)));\n-        let transformed_self_ty = opt_transformed_self_ty.unwrap();\n+        let fn_sig = ty::FnSig {\n+            binder_id: fn_sig.binder_id,\n+            inputs: inputs,\n+            output: fn_sig.output.subst(tcx, &all_substs),\n+            variadic: fn_sig.variadic\n+        };\n+\n+        debug!(\"after subst, fty={}\", fn_sig.repr(tcx));\n+\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let (_, fn_sig) = replace_bound_regions_in_fn_sig( tcx, &fn_sig, |br| {\n+            self.fcx.infcx().next_region_var(\n+                infer::BoundRegionInFnCall(self.expr.span, br))\n+        });\n+        let transformed_self_ty = fn_sig.inputs[0];\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,\n@@ -1027,7 +1029,7 @@ impl<'a> LookupContext<'a> {\n         // should never fail.\n         match self.fcx.mk_subty(false, infer::Misc(self.self_expr.span),\n                                 rcvr_ty, transformed_self_ty) {\n-            result::Ok(_) => (),\n+            result::Ok(_) => {}\n             result::Err(_) => {\n                 self.bug(format!(\"{} was a subtype of {} but now is not?\",\n                               self.ty_to_str(rcvr_ty),\n@@ -1038,9 +1040,7 @@ impl<'a> LookupContext<'a> {\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n-            self_ty: transformed_self_ty,\n-            explicit_self: candidate.method_ty.explicit_self,\n-            origin: candidate.origin,\n+            origin: candidate.origin\n         }\n     }\n \n@@ -1064,7 +1064,7 @@ impl<'a> LookupContext<'a> {\n          * result to be `&'a Foo`. Assuming that `u_method` is being\n          * called, we want the result to be `~Foo`. Of course,\n          * this transformation has already been done as part of\n-         * `method_ty.transformed_self_ty`, but there the type\n+         * `method_ty.fty.sig.inputs[0]`, but there the type\n          * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n          * Because objects are not standalone types, we can't just substitute\n          * `s/Self/Foo/`, so we must instead perform this kind of hokey\n@@ -1078,12 +1078,11 @@ impl<'a> LookupContext<'a> {\n             ast::SelfStatic => {\n                 self.bug(~\"static method for object type receiver\");\n             }\n-            ast::SelfValue(_) => {\n+            ast::SelfValue => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n-            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq(..) => {\n-                let transformed_self_ty =\n-                    method_ty.transformed_self_ty.clone().unwrap();\n+            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq => {\n+                let transformed_self_ty = method_ty.fty.sig.inputs[0];\n                 match ty::get(transformed_self_ty).sty {\n                     ty::ty_rptr(r, mt) => { // must be SelfRegion\n                         ty::mk_trait(self.tcx(), trait_def_id,\n@@ -1110,10 +1109,7 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn enforce_object_limitations(&self,\n-                                  method_fty: ty::t,\n-                                  candidate: &Candidate)\n-    {\n+    fn enforce_object_limitations(&self, candidate: &Candidate) {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n@@ -1137,21 +1133,38 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfValue(_) => { // reason (a) above\n+            ast::SelfValue => { // reason (a) above\n                 self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"cannot call a method with a by-value receiver \\\n                      through an object\");\n             }\n \n-            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq(..) => {}\n+            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq => {}\n         }\n \n-        if ty::type_has_self(method_fty) { // reason (a) above\n-            self.tcx().sess.span_err(\n-                self.expr.span,\n-                \"cannot call a method whose type contains a \\\n-                 self-type through an object\");\n+        // reason (a) above\n+        let check_for_self_ty = |ty| {\n+            if ty::type_has_self(ty) {\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"cannot call a method whose type contains a \\\n+                     self-type through an object\");\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let ref sig = candidate.method_ty.fty.sig;\n+        let mut found_self_ty = false;\n+        for &input_ty in sig.inputs.iter() {\n+            if check_for_self_ty(input_ty) {\n+                found_self_ty = true;\n+                break;\n+            }\n+        }\n+        if !found_self_ty {\n+            check_for_self_ty(sig.output);\n         }\n \n         if candidate.method_ty.generics.has_type_params() { // reason (b) above\n@@ -1198,7 +1211,7 @@ impl<'a> LookupContext<'a> {\n                 false\n             }\n \n-            SelfValue(_) => {\n+            SelfValue => {\n                 rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n             }\n \n@@ -1234,7 +1247,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfUniq(_) => {\n+            SelfUniq => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {"}, {"sha": "a0b50f65f202c07982a25254fca5ccbb17626982", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 104, "deletions": 209, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -142,12 +142,6 @@ pub mod regionck;\n pub mod demand;\n pub mod method;\n \n-pub struct SelfInfo {\n-    self_ty: ty::t,\n-    self_id: ast::NodeId,\n-    span: Span\n-}\n-\n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n ///\n@@ -320,23 +314,21 @@ pub fn check_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n     visit::walk_crate(&mut visit, crate, ());\n }\n \n-pub fn check_bare_fn(ccx: @CrateCtxt,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     id: ast::NodeId,\n-                     self_info: Option<SelfInfo>,\n-                     fty: ty::t,\n-                     param_env: ty::ParameterEnvironment) {\n+fn check_bare_fn(ccx: @CrateCtxt,\n+                 decl: &ast::FnDecl,\n+                 body: &ast::Block,\n+                 id: ast::NodeId,\n+                 fty: ty::t,\n+                 param_env: ty::ParameterEnvironment) {\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let fcx =\n-                check_fn(ccx, self_info, fn_ty.purity,\n-                         &fn_ty.sig, decl, id, body, Vanilla,\n-                         @Inherited::new(ccx.tcx, param_env));\n+                check_fn(ccx, fn_ty.purity, &fn_ty.sig, decl, id, body,\n+                         Vanilla, @Inherited::new(ccx.tcx, param_env));\n \n             vtable::resolve_in_block(fcx, body);\n             regionck::regionck_fn(fcx, body);\n-            writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n+            writeback::resolve_type_vars_in_fn(fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -419,15 +411,14 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n }\n \n-pub fn check_fn(ccx: @CrateCtxt,\n-                opt_self_info: Option<SelfInfo>,\n-                purity: ast::Purity,\n-                fn_sig: &ty::FnSig,\n-                decl: &ast::FnDecl,\n-                id: ast::NodeId,\n-                body: &ast::Block,\n-                fn_kind: FnKind,\n-                inherited: @Inherited) -> @FnCtxt\n+fn check_fn(ccx: @CrateCtxt,\n+            purity: ast::Purity,\n+            fn_sig: &ty::FnSig,\n+            decl: &ast::FnDecl,\n+            id: ast::NodeId,\n+            body: &ast::Block,\n+            fn_kind: FnKind,\n+            inherited: @Inherited) -> @FnCtxt\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -442,99 +433,44 @@ pub fn check_fn(ccx: @CrateCtxt,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    // First, we have to replace any bound regions in the fn and self\n-    // types with free ones.  The free region references will be bound\n-    // the node_id of the body block.\n-    let (opt_self_info, fn_sig) = {\n-        let opt_self_ty = opt_self_info.map(|i| i.self_ty);\n-        let (_, opt_self_ty, fn_sig) =\n-            replace_bound_regions_in_fn_sig(\n-                tcx, opt_self_ty, fn_sig,\n-                |br| ty::ReFree(ty::FreeRegion {scope_id: body.id,\n-                                                 bound_region: br}));\n-        let opt_self_info =\n-            opt_self_info.map(\n-                |si| SelfInfo {self_ty: opt_self_ty.unwrap(), .. si});\n-        (opt_self_info, fn_sig)\n-    };\n+    // First, we have to replace any bound regions in the fn type with free ones.\n+    // The free region references will be bound the node_id of the body block.\n+    let (_, fn_sig) = replace_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n+        ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n+    });\n \n-    relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n+    relate_free_regions(tcx, &fn_sig);\n \n-    let arg_tys = fn_sig.inputs.map(|a| *a);\n+    let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, opt_self_ty={:?})\",\n+    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?})\",\n            arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n-           ppaux::ty_to_str(tcx, ret_ty),\n-           opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n+           ppaux::ty_to_str(tcx, ret_ty));\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx: @FnCtxt = {\n-        @FnCtxt {\n-            err_count_on_creation: err_count_on_creation,\n-            ret_ty: ret_ty,\n-            ps: RefCell::new(PurityState::function(purity, id)),\n-            region_lb: Cell::new(body.id),\n-            fn_kind: fn_kind,\n-            inh: inherited,\n-            ccx: ccx\n-        }\n+    let fcx = @FnCtxt {\n+        err_count_on_creation: err_count_on_creation,\n+        ret_ty: ret_ty,\n+        ps: RefCell::new(PurityState::function(purity, id)),\n+        region_lb: Cell::new(body.id),\n+        fn_kind: fn_kind,\n+        inh: inherited,\n+        ccx: ccx\n     };\n \n-    gather_locals(fcx, decl, body, arg_tys, opt_self_info);\n-    check_block_with_expected(fcx, body, Some(ret_ty));\n-\n-    // We unify the tail expr's type with the\n-    // function result type, if there is a tail expr.\n-    match body.expr {\n-      Some(tail_expr) => {\n-        let tail_expr_ty = fcx.expr_ty(tail_expr);\n-        // Special case: we print a special error if there appears\n-        // to be do-block/for-loop confusion\n-        demand::suptype_with_fn(fcx, tail_expr.span, false,\n-            fcx.ret_ty, tail_expr_ty,\n-            |sp, e, a, s| {\n-                fcx.report_mismatched_return_types(sp, e, a, s) });\n-      }\n-      None => ()\n-    }\n-\n-    for self_info in opt_self_info.iter() {\n-        fcx.write_ty(self_info.self_id, self_info.self_ty);\n-    }\n-    for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n-        fcx.write_ty(input.id, *arg);\n-    }\n-\n-    return fcx;\n-\n-    fn gather_locals(fcx: @FnCtxt,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     arg_tys: &[ty::t],\n-                     opt_self_info: Option<SelfInfo>) {\n-        let tcx = fcx.ccx.tcx;\n+    {\n \n         let mut visit = GatherLocalsVisitor { fcx: fcx, tcx: tcx, };\n-\n-        // Add the self parameter\n-        for self_info in opt_self_info.iter() {\n-            visit.assign(self_info.self_id, Some(self_info.self_ty));\n-            let locals = fcx.inh.locals.borrow();\n-            debug!(\"self is assigned to {}\",\n-                   fcx.infcx().ty_to_str(\n-                       locals.get().get_copy(&self_info.self_id)));\n-        }\n-\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n             pat_util::pat_bindings(tcx.def_map,\n                                    input.pat,\n                                    |_bm, pat_id, _sp, _path| {\n-                visit.assign(pat_id, None);\n-            });\n+                                       visit.assign(pat_id, None);\n+                                   });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n@@ -546,6 +482,29 @@ pub fn check_fn(ccx: @CrateCtxt,\n \n         visit.visit_block(body, ());\n     }\n+\n+    check_block_with_expected(fcx, body, Some(ret_ty));\n+\n+    // We unify the tail expr's type with the\n+    // function result type, if there is a tail expr.\n+    match body.expr {\n+        Some(tail_expr) => {\n+            // Special case: we print a special error if there appears\n+            // to be do-block/for-loop confusion\n+            demand::suptype_with_fn(fcx, tail_expr.span, false,\n+                fcx.ret_ty, fcx.expr_ty(tail_expr),\n+                |sp, e, a, s| {\n+                    fcx.report_mismatched_return_types(sp, e, a, s);\n+                });\n+        }\n+        None => {}\n+    }\n+\n+    for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n+        fcx.write_ty(input.id, *arg);\n+    }\n+\n+    fcx\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n@@ -606,7 +565,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n                 [],\n                 body.id);\n \n-        check_bare_fn(ccx, decl, body, it.id, None, fn_tpt.ty, param_env);\n+        check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n         debug!(\"ItemImpl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n@@ -716,23 +675,11 @@ fn check_method_body(ccx: @CrateCtxt,\n             item_generics.region_param_defs,\n             method.body.id);\n \n-    // Compute the self type and fty from point of view of inside fn\n-    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n-        SelfInfo {self_ty: ty.subst(ccx.tcx, &param_env.free_substs),\n-                  self_id: method.self_id,\n-                  span: method.explicit_self.span}\n-    });\n+    // Compute the fty from point of view of inside fn\n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n \n-    check_bare_fn(\n-        ccx,\n-        method.decl,\n-        method.body,\n-        method.id,\n-        opt_self_info,\n-        fty,\n-        param_env);\n+    check_bare_fn(ccx, method.decl, method.body, method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n@@ -815,13 +762,13 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n  * - trait_m: the method in the trait\n  * - trait_substs: the substitutions used on the type of the trait\n  */\n-pub fn compare_impl_method(tcx: ty::ctxt,\n-                           impl_generics: &ty::Generics,\n-                           impl_m: @ty::Method,\n-                           impl_m_span: Span,\n-                           impl_m_body_id: ast::NodeId,\n-                           trait_m: &ty::Method,\n-                           trait_substs: &ty::substs) {\n+fn compare_impl_method(tcx: ty::ctxt,\n+                       impl_generics: &ty::Generics,\n+                       impl_m: @ty::Method,\n+                       impl_m_span: Span,\n+                       impl_m_body_id: ast::NodeId,\n+                       trait_m: &ty::Method,\n+                       trait_substs: &ty::substs) {\n     debug!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n@@ -953,52 +900,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         regions: ty::NonerasedRegions(dummy_impl_regions),\n         self_ty: None };\n \n-    // We are going to create a synthetic fn type that includes\n-    // both the method's self argument and its normal arguments.\n-    // So a method like `fn(&self, a: uint)` would be converted\n-    // into a function `fn(self: &T, a: uint)`.\n-    let mut trait_fn_args = ~[];\n-    let mut impl_fn_args = ~[];\n-\n-    // For both the trait and the impl, create an argument to\n-    // represent the self argument (unless this is a static method).\n-    // This argument will have the *transformed* self type.\n-    for &t in trait_m.transformed_self_ty.iter() {\n-        trait_fn_args.push(t);\n-    }\n-    for &t in impl_m.transformed_self_ty.iter() {\n-        impl_fn_args.push(t);\n-    }\n-\n-    // Add in the normal arguments.\n-    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n-    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n-\n-    // Create a bare fn type for trait/impl that includes self argument\n-    let trait_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: trait_m.fty.purity,\n-                            abis: trait_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                binder_id: trait_m.fty.sig.binder_id,\n-                                inputs: trait_fn_args,\n-                                output: trait_m.fty.sig.output,\n-                                variadic: false\n-                            }\n-                        });\n-    let impl_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: impl_m.fty.purity,\n-                            abis: impl_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                binder_id: impl_m.fty.sig.binder_id,\n-                                inputs: impl_fn_args,\n-                                output: impl_m.fty.sig.output,\n-                                variadic: false\n-                            }\n-                        });\n+    // Create a bare fn type for trait/impl\n+    // It'd be nice to refactor so as to provide the bare fn types instead.\n+    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n \n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n@@ -1669,6 +1574,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n     {\n+        // HACK(eddyb) ignore provided self (it has special typeck rules).\n+        let args = args.slice_from(1);\n         if ty::type_is_error(method_fn_ty) {\n             let err_inputs = err_args(args.len());\n             check_argument_types(fcx, sp, err_inputs, callee_expr,\n@@ -1677,8 +1584,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         } else {\n             match ty::get(method_fn_ty).sty {\n                 ty::ty_bare_fn(ref fty) => {\n-                    check_argument_types(fcx, sp, fty.sig.inputs, callee_expr,\n-                                         args, sugar, deref_args, fty.sig.variadic);\n+                    // HACK(eddyb) ignore self in the definition (see above).\n+                    check_argument_types(fcx, sp, fty.sig.inputs.slice_from(1),\n+                                         callee_expr, args, sugar, deref_args,\n+                                         fty.sig.variadic);\n                     fty.sig.output\n                 }\n                 _ => {\n@@ -1923,13 +1832,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, _, fn_sig) =\n-            replace_bound_regions_in_fn_sig(fcx.tcx(),\n-                                            None,\n-                                            fn_sig,\n-                                            |br| fcx.infcx()\n-                                                    .next_region_var(\n-                    infer::BoundRegionInFnCall(call_expr.span, br)));\n+        let (_, fn_sig) = replace_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n+            fcx.infcx()\n+               .next_region_var(infer::BoundRegionInFnCall(call_expr.span, br))\n+        });\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n@@ -1942,11 +1848,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     fn check_method_call(fcx: @FnCtxt,\n                          callee_id: ast::NodeId,\n                          expr: &ast::Expr,\n-                         rcvr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n                          tps: &[ast::P<ast::Ty>],\n                          sugar: ast::CallSugar) {\n+        let rcvr = args[0];\n         check_expr(fcx, rcvr);\n \n         // no need to check for bot/err -- callee does that\n@@ -2042,7 +1948,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     fn lookup_op_method(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         op_ex: &ast::Expr,\n-                        self_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n                         args: &[@ast::Expr],\n@@ -2052,7 +1957,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         _expected_result: Option<ty::t>\n                        )\n                      -> ty::t {\n-        match method::lookup(fcx, op_ex, self_ex,\n+        match method::lookup(fcx, op_ex, args[0],\n                              callee_id, opname, self_t, [],\n                              deref_args, CheckTraitsOnly, autoderef_receiver) {\n             Some(ref origin) => {\n@@ -2084,7 +1989,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                    callee_id: ast::NodeId,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: &ast::Expr,\n+                   lhs: @ast::Expr,\n                    rhs: @ast::Expr,\n                    // Used only in the error case\n                    expected_result: Option<ty::t>,\n@@ -2172,7 +2077,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     fn check_user_binop(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         ex: &ast::Expr,\n-                        lhs_expr: &ast::Expr,\n+                        lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n                         rhs: @ast::Expr,\n@@ -2187,10 +2092,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                              ast_util::binop_to_str(op), actual)},\n                             lhs_resolved_t, None)\n                 };\n-                return lookup_op_method(fcx, callee_id, ex, lhs_expr, lhs_resolved_t,\n-                                       token::intern(*name),\n-                                       &[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n-                                       expected_result);\n+                return lookup_op_method(fcx, callee_id, ex, lhs_resolved_t,\n+                                        token::intern(*name), [lhs_expr, rhs],\n+                                        DoDerefArgs,DontAutoderefReceiver,\n+                                        if_op_unbound, expected_result);\n             }\n             None => ()\n         };\n@@ -2216,14 +2121,13 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                        op_str: &str,\n                        mname: &str,\n                        ex: &ast::Expr,\n-                       rhs_expr: &ast::Expr,\n+                       rhs_expr: @ast::Expr,\n                        rhs_t: ty::t,\n                        expected_t: Option<ty::t>)\n                     -> ty::t {\n        lookup_op_method(\n-            fcx, callee_id, ex, rhs_expr, rhs_t,\n-            token::intern(mname), &[],\n-            DoDerefArgs, DontAutoderefReceiver,\n+            fcx, callee_id, ex, rhs_t, token::intern(mname),\n+            [rhs_expr], DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n                     format!(\"cannot apply unary operator `{}` to type `{}`\",\n@@ -2280,9 +2184,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n              expected_bounds) = {\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n-                    let (_, _, sig) =\n+                    let (_, sig) =\n                         replace_bound_regions_in_fn_sig(\n-                            tcx, None, &cenv.sig,\n+                            tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     (Some(sig), cenv.purity, cenv.sigil,\n                      cenv.onceness, cenv.bounds)\n@@ -2352,7 +2256,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                            (purity, expr.id),\n                                            sigil);\n \n-        check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n+        check_fn(fcx.ccx, inherited_purity, &fty_sig,\n                  decl, id, body, fn_kind, fcx.inh);\n     }\n \n@@ -2916,12 +2820,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n-      ast::ExprSelf => {\n-        let definition = lookup_def(fcx, expr.span, id);\n-        let ty_param_bounds_and_ty =\n-            ty_param_bounds_and_ty_for_def(fcx, expr.span, definition);\n-        fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n-      }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, input) in ia.inputs.iter() {\n               check_expr(fcx, input);\n@@ -3088,18 +2986,16 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n               fcx.write_bot(id);\n           }\n       }\n-      ast::ExprMethodCall(callee_id, rcvr, ident, ref tps, ref args, sugar) => {\n-        check_method_call(fcx, callee_id, expr, rcvr, ident, *args, *tps, sugar);\n-        let f_ty = fcx.expr_ty(rcvr);\n+      ast::ExprMethodCall(callee_id, ident, ref tps, ref args, sugar) => {\n+        check_method_call(fcx, callee_id, expr, ident, *args, *tps, sugar);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n               (rest_bot || ty::type_is_bot(*a),\n                rest_err || ty::type_is_error(*a))});\n-        if ty::type_is_error(f_ty) || args_err {\n+        if args_err {\n             fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(f_ty) || args_bot {\n+        } else if args_bot {\n             fcx.write_bot(id);\n         }\n       }\n@@ -3327,10 +3223,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                       let ret_ty = lookup_op_method(fcx,\n                                                     callee_id,\n                                                     expr,\n-                                                    base,\n                                                     resolved,\n                                                     index_ident.name,\n-                                                    &[idx],\n+                                                    [base, idx],\n                                                     DoDerefArgs,\n                                                     AutoderefReceiver,\n                                                     error_message,\n@@ -3760,7 +3655,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::DefArg(nid, _) | ast::DefLocal(nid, _) | ast::DefSelf(nid, _) |\n+      ast::DefArg(nid, _) | ast::DefLocal(nid, _) |\n       ast::DefBinding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);"}, {"sha": "1653429e457c601f9e2046ffb8c3763b50e65dda", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -41,7 +41,7 @@ use middle::pat_util;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n-use syntax::ast::{DefArg, DefBinding, DefLocal, DefSelf, DefUpvar};\n+use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -64,7 +64,7 @@ fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         DefLocal(node_id, _) | DefArg(node_id, _) |\n-        DefSelf(node_id, _) | DefBinding(node_id, _) => {\n+        DefBinding(node_id, _) => {\n             tcx.region_maps.var_region(node_id)\n         }\n         DefUpvar(_, subdef, closure_id, body_id) => {\n@@ -316,8 +316,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprMethodCall(callee_id, arg0, _, _, ref args, _) => {\n-            constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n+        ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+            constrain_call(rcx, callee_id, expr, Some(args[0]),\n+                           args.slice_from(1), false);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -1012,12 +1013,10 @@ pub mod guarantor {\n                 guarantor(rcx, e)\n             }\n \n-            ast::ExprPath(..) | ast::ExprSelf => {\n-                // Either a variable or constant and hence resides\n-                // in constant memory or on the stack frame.  Either way,\n-                // not guaranteed by a region pointer.\n-                None\n-            }\n+            // Either a variable or constant and hence resides\n+            // in constant memory or on the stack frame.  Either way,\n+            // not guaranteed by a region pointer.\n+            ast::ExprPath(..) => None,\n \n             // All of these expressions are rvalues and hence their\n             // value is not guaranteed by a region pointer."}, {"sha": "0b04db882340a9c80858d33d4b609eb23ce0802b", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -21,29 +21,26 @@ use util::ppaux;\n \n pub fn replace_bound_regions_in_fn_sig(\n         tcx: ty::ctxt,\n-        opt_self_ty: Option<ty::t>,\n         fn_sig: &ty::FnSig,\n         mapf: |ty::BoundRegion| -> ty::Region)\n-        -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig) {\n-    debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n-            opt_self_ty.repr(tcx),\n-            fn_sig.repr(tcx));\n+        -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n+    debug!(\"replace_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n \n     let mut map = HashMap::new();\n-    let (fn_sig, opt_self_ty) = {\n+    let fn_sig = {\n         let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n-                debug!(\"region r={}\", r.to_str());\n-                match r {\n+            debug!(\"region r={}\", r.to_str());\n+            match r {\n                 ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n                     *map.find_or_insert_with(br, |_| mapf(br))\n                 }\n                 _ => r\n-            }});\n-        (ty_fold::super_fold_sig(&mut f, fn_sig),\n-         ty_fold::fold_opt_ty(&mut f, opt_self_ty))\n+            }\n+        });\n+        ty_fold::super_fold_sig(&mut f, fn_sig)\n     };\n     debug!(\"resulting map: {}\", map.to_str());\n-    (map, opt_self_ty, fn_sig)\n+    (map, fn_sig)\n }\n \n pub fn relate_nested_regions(tcx: ty::ctxt,\n@@ -135,11 +132,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     }\n }\n \n-pub fn relate_free_regions(\n-    tcx: ty::ctxt,\n-    self_ty: Option<ty::t>,\n-    fn_sig: &ty::FnSig)\n-{\n+pub fn relate_free_regions(tcx: ty::ctxt, fn_sig: &ty::FnSig) {\n     /*!\n      * This function populates the region map's `free_region_map`.\n      * It walks over the transformed self type and argument types\n@@ -158,9 +151,6 @@ pub fn relate_free_regions(\n     for arg in fn_sig.inputs.iter() {\n         all_tys.push(*arg);\n     }\n-    for &t in self_ty.iter() {\n-        all_tys.push(t);\n-    }\n \n     for &t in all_tys.iter() {\n         debug!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));"}, {"sha": "0a231be5d459b60343a4bd3e11f8b5d12ec18e2e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -712,7 +712,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n       ast::ExprUnary(callee_id, _, _) |\n       ast::ExprAssignOp(callee_id, _, _, _) |\n       ast::ExprIndex(callee_id, _, _) |\n-      ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n+      ast::ExprMethodCall(callee_id, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\","}, {"sha": "48b1acd3f9b37546725c0d4a7850cbfd204cc6c6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -16,13 +16,12 @@\n use middle::pat_util;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, SelfInfo};\n+use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{vtable_res, vtable_origin};\n use middle::typeck::{vtable_static, vtable_param};\n-use middle::typeck::method_map_entry;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux;\n@@ -62,7 +61,7 @@ fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_method_map_entry(fcx: @FnCtxt, id: ast::NodeId) {\n     // Resolve any method map entry\n     let method_map_entry_opt = {\n         let method_map = fcx.inh.method_map.borrow();\n@@ -71,18 +70,9 @@ fn resolve_method_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n     match method_map_entry_opt {\n         None => {}\n         Some(mme) => {\n-            {\n-                let r = resolve_type_vars_in_type(fcx, sp, mme.self_ty);\n-                for t in r.iter() {\n-                    let method_map = fcx.ccx.method_map;\n-                    let new_entry = method_map_entry { self_ty: *t, ..mme };\n-                    debug!(\"writeback::resolve_method_map_entry(id={:?}, \\\n-                            new_entry={:?})\",\n-                           id, new_entry);\n-                    let mut method_map = method_map.borrow_mut();\n-                    method_map.get().insert(id, new_entry);\n-                }\n-            }\n+            debug!(\"writeback::resolve_method_map_entry(id={:?}, entry={:?})\", id, mme);\n+            let mut method_map = fcx.ccx.method_map.borrow_mut();\n+            method_map.get().insert(id, mme);\n         }\n     }\n }\n@@ -148,19 +138,33 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                          resolve_all | force_all) {\n                         Err(e) => {\n                             // This should not, I think, happen:\n-                            fcx.ccx.tcx.sess.span_err(\n+                            tcx.sess.span_err(\n                                 sp,\n                                 format!(\"cannot resolve bound for closure: \\\n                                          {}\",\n                                         infer::fixup_err_to_str(e)));\n                         }\n                         Ok(r1) => {\n+                            // FIXME(eddyb) #2190 Allow only statically resolved\n+                            // bare functions to coerce to a closure to avoid\n+                            // constructing (slower) indirect call wrappers.\n+                            {\n+                                let def_map = tcx.def_map.borrow();\n+                                match def_map.get().find(&id) {\n+                                    Some(&ast::DefFn(..)) |\n+                                    Some(&ast::DefStaticMethod(..)) |\n+                                    Some(&ast::DefVariant(..)) |\n+                                    Some(&ast::DefStruct(_)) => {}\n+                                    _ => tcx.sess.span_err(sp,\n+                                            \"cannot coerce non-statically resolved bare fn\")\n+                                }\n+                            }\n+\n                             let resolved_adj = @ty::AutoAddEnv(r1, s);\n                             debug!(\"Adjustments for node {}: {:?}\",\n                                    id,\n                                    resolved_adj);\n-                            let mut adjustments = fcx.tcx()\n-                                                     .adjustments\n+                            let mut adjustments = tcx.adjustments\n                                                      .borrow_mut();\n                             adjustments.get().insert(id, resolved_adj);\n                         }\n@@ -175,7 +179,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                             Ok(r1) => r1,\n                             Err(e) => {\n                                 // This should not, I think, happen.\n-                                fcx.ccx.tcx.sess.span_err(\n+                                tcx.sess.span_err(\n                                     sp,\n                                     format!(\"cannot resolve scope of borrow: \\\n                                              {}\",\n@@ -195,13 +199,13 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         autoref: resolved_autoref,\n                     });\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+                    let mut adjustments = tcx.adjustments.borrow_mut();\n                     adjustments.get().insert(id, resolved_adj);\n                 }\n \n                 ty::AutoObject(..) => {\n                     debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+                    let mut adjustments = tcx.adjustments.borrow_mut();\n                     adjustments.get().insert(id, adjustment);\n                 }\n             }\n@@ -273,11 +277,11 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n \n-    resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n+    resolve_method_map_entry(wbcx.fcx, e.id);\n     {\n         let r = e.get_callee_id();\n         for callee_id in r.iter() {\n-            resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n+            resolve_method_map_entry(wbcx.fcx, *callee_id);\n         }\n     }\n \n@@ -303,7 +307,7 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n             maybe_resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n \n-        ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n+        ast::ExprMethodCall(callee_id, _, _, _, _) => {\n             // We must always have written in a callee ID type for these.\n             resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n@@ -381,18 +385,11 @@ pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @FnCtxt,\n-                               decl: &ast::FnDecl,\n-                               blk: &ast::Block,\n-                               self_info: Option<SelfInfo>) -> bool {\n+pub fn resolve_type_vars_in_fn(fcx: @FnCtxt, decl: &ast::FnDecl,\n+                               blk: &ast::Block) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_block(blk, ());\n-    for self_info in self_info.iter() {\n-        resolve_type_vars_for_node(wbcx,\n-                                   self_info.span,\n-                                   self_info.self_id);\n-    }\n     for arg in decl.inputs.iter() {\n         wbcx.visit_pat(arg.pat, ());\n         // Privacy needs the type for the whole pattern, not just each binding"}, {"sha": "0dcb3c7329ba5259af18a991f3b9406eb4aa0014", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -24,8 +24,7 @@ use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n-use middle::ty::{type_is_ty_var};\n+use middle::ty::{ty_unboxed_vec, type_is_ty_var};\n use middle::subst::Subst;\n use middle::ty;\n use middle::ty::{Impl, Method};\n@@ -84,7 +83,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_self(..) | ty_type |\n-        ty_opaque_closure_ptr(..) | ty_unboxed_vec(..) | ty_err | ty_box(_) |\n+        ty_unboxed_vec(..) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n@@ -820,9 +819,6 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n         // method types *can* appear in the generic bounds\n         method.generics.subst(tcx, &combined_substs),\n \n-        // method tps cannot appear in the self_ty, so use `substs` from trait ref\n-        method.transformed_self_ty.subst(tcx, &trait_ref.substs),\n-\n         // method types *can* appear in the fty\n         method.fty.subst(tcx, &combined_substs),\n "}, {"sha": "04d708f0638e9fd403ecda7b2af0bf6d518c2315", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -380,15 +380,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                  m_decl: &ast::FnDecl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(this, *m_id, *m_purity,\n-                                  trait_self_ty, *m_explicit_self, m_decl);\n+        let fty = astconv::ty_of_method(this, *m_id, *m_purity, trait_self_ty,\n+                                        *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.type_param_defs.len();\n         ty::Method::new(\n             *m_ident,\n             // FIXME(#5121) -- distinguish early vs late lifetime params\n             ty_generics(this, m_generics, num_trait_type_params),\n-            transformed_self_ty,\n             fty,\n             m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n@@ -512,10 +510,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_generics: &ast::Generics,\n                     rcvr_visibility: ast::Visibility) -> ty::Method\n     {\n-        let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(ccx, m.id, m.purity,\n-                                  untransformed_rcvr_ty,\n-                                  m.explicit_self, m.decl);\n+        let fty = astconv::ty_of_method(ccx, m.id, m.purity,\n+                                        untransformed_rcvr_ty,\n+                                        m.explicit_self, m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -528,7 +525,6 @@ fn convert_methods(ccx: &CrateCtxt,\n             m.ident,\n             // FIXME(#5121) -- distinguish early vs late lifetime params\n             ty_generics(ccx, &m.generics, num_rcvr_type_params),\n-            transformed_self_ty,\n             fty,\n             m.explicit_self.node,\n             method_vis,"}, {"sha": "6a4de959c2bb93bf113c29d7a58cf105af28c4b2", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -385,48 +385,37 @@ impl Coerce {\n         })))\n     }\n \n-    pub fn coerce_from_bare_fn(&self,\n-                               a: ty::t,\n-                               fn_ty_a: &ty::BareFnTy,\n-                               b: ty::t)\n-                               -> CoerceResult {\n-        self.unpack_actual_value(b, |sty_b| {\n-            self.coerce_from_bare_fn_post_unpack(a, fn_ty_a, b, sty_b)\n-        })\n-    }\n-\n-    pub fn coerce_from_bare_fn_post_unpack(&self,\n-                                           a: ty::t,\n-                                           fn_ty_a: &ty::BareFnTy,\n-                                           b: ty::t,\n-                                           sty_b: &ty::sty)\n-                                           -> CoerceResult {\n+    fn coerce_from_bare_fn(&self, a: ty::t, fn_ty_a: &ty::BareFnTy, b: ty::t)\n+                           -> CoerceResult {\n         /*!\n          *\n          * Attempts to coerce from a bare Rust function (`extern\n-         * \"rust\" fn`) into a closure.\n+         * \"Rust\" fn`) into a closure or a `proc`.\n          */\n \n-        debug!(\"coerce_from_bare_fn(a={}, b={})\",\n-               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+        self.unpack_actual_value(b, |sty_b| {\n \n-        if !fn_ty_a.abis.is_rust() || fn_ty_a.purity != ast::ImpureFn {\n-            return self.subtype(a, b);\n-        }\n+            debug!(\"coerce_from_bare_fn(a={}, b={})\",\n+                   a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n-        let fn_ty_b = match *sty_b {\n-            ty::ty_closure(ref f) => (*f).clone(),\n-            _ => return self.subtype(a, b),\n-        };\n+            if !fn_ty_a.abis.is_rust() || fn_ty_a.purity != ast::ImpureFn {\n+                return self.subtype(a, b);\n+            }\n \n-        let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n-        let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n-                                       ty::ClosureTy {\n-                                            sig: fn_ty_a.sig.clone(),\n-                                            ..fn_ty_b\n-                                       });\n-        if_ok!(self.subtype(a_closure, b));\n-        Ok(Some(adj))\n+            let fn_ty_b = match *sty_b {\n+                ty::ty_closure(ref f) => (*f).clone(),\n+                _ => return self.subtype(a, b)\n+            };\n+\n+            let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n+            let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n+                                           ty::ClosureTy {\n+                                                sig: fn_ty_a.sig.clone(),\n+                                                ..fn_ty_b\n+                                           });\n+            if_ok!(self.subtype(a_closure, b));\n+            Ok(Some(adj))\n+        })\n     }\n \n     pub fn coerce_unsafe_ptr(&self,"}, {"sha": "812b7ffd97d60dccf9fbd106bed48792a6ce5945", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -25,7 +25,7 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n-use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n+use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n@@ -809,8 +809,8 @@ impl InferCtxt {\n                                                     -> (ty::FnSig,\n                                                         HashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n-        let (map, _, fn_sig) =\n-            replace_bound_regions_in_fn_sig(self.tcx, None, fsig, |br| {\n+        let (map, fn_sig) =\n+            replace_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\","}, {"sha": "19abbecaa8a72929756416f7a5979d851a34c58b", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -171,8 +171,8 @@ impl Combine for Sub {\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let (skol_map, _, b_sig) = {\n-            replace_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, None, b, |br| {\n+        let (skol_map, b_sig) = {\n+            replace_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n                 let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.get_ref().infcx.tcx, \"\", false, br),"}, {"sha": "8837a978f439ac35ac57a00a2f1d6b56a55e0d16", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -144,13 +144,6 @@ pub struct method_object {\n \n #[deriving(Clone)]\n pub struct method_map_entry {\n-    // the type of the self parameter, which is not reflected in the fn type\n-    // (FIXME #3446)\n-    self_ty: ty::t,\n-\n-    // the type of explicit self on the method\n-    explicit_self: ast::ExplicitSelf_,\n-\n     // method details being invoked\n     origin: method_origin,\n }\n@@ -264,10 +257,10 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     let def_map = tcx.def_map.borrow();\n     match def_map.get().find(&id) {\n-      Some(&x) => x,\n-      _ => {\n-        tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n-      }\n+        Some(&x) => x,\n+        _ => {\n+            tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n+        }\n     }\n }\n "}, {"sha": "c260896731335c349b117db009b94f0a820e0ade", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -472,22 +472,6 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n             ast::ItemTrait(..) => {\n                 let methods = ty::trait_methods(tcx, did);\n                 for method in methods.iter() {\n-                    match method.transformed_self_ty {\n-                        Some(self_ty) => {\n-                            // The implicit self parameter is basically\n-                            // equivalent to a normal parameter declared\n-                            // like:\n-                            //\n-                            //     self : self_ty\n-                            //\n-                            // where self_ty is `&Self` or `&mut Self`\n-                            // or whatever.\n-                            self.add_constraints_from_ty(\n-                                self_ty, self.contravariant);\n-                        }\n-                        None => {}\n-                    }\n-\n                     self.add_constraints_from_sig(\n                         &method.fty.sig, self.covariant);\n                 }\n@@ -691,8 +675,8 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_infer(..) | ty::ty_err | ty::ty_type |\n-            ty::ty_opaque_closure_ptr(..) | ty::ty_unboxed_vec(..) => {\n+            ty::ty_infer(..) | ty::ty_err |\n+            ty::ty_type | ty::ty_unboxed_vec(..) => {\n                 self.tcx().sess.bug(\n                     format!(\"Unexpected type encountered in \\\n                             variance inference: {}\","}, {"sha": "7199c945627468fbffa1e2d33a472af10bb2f8c0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -18,10 +18,8 @@ use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_opaque_closure_ptr, ty_param};\n-use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n-use middle::ty::{ty_trait, ty_int};\n-use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n+use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_self, ty_tup, ty_type};\n+use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n use middle::ty;\n use middle::typeck;\n use syntax::abi::AbiSet;\n@@ -501,10 +499,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_vec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n-      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n-      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n-      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"~closure\",\n+      ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\")\n     }\n }\n \n@@ -800,11 +795,10 @@ impl Repr for ty::Variance {\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"method(ident: {}, generics: {}, transformed_self_ty: {}, \\\n-                fty: {}, explicit_self: {}, vis: {}, def_id: {})\",\n+        format!(\"method(ident: {}, generics: {}, fty: {}, \\\n+                explicit_self: {}, vis: {}, def_id: {})\",\n                 self.ident.repr(tcx),\n                 self.generics.repr(tcx),\n-                self.transformed_self_ty.repr(tcx),\n                 self.fty.repr(tcx),\n                 self.explicit_self.repr(tcx),\n                 self.vis.repr(tcx),\n@@ -847,12 +841,7 @@ impl Repr for ty::FnSig {\n \n impl Repr for typeck::method_map_entry {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"method_map_entry \\\\{self_arg: {}, \\\n-              explicit_self: {}, \\\n-              origin: {}\\\\}\",\n-             self.self_ty.repr(tcx),\n-             self.explicit_self.repr(tcx),\n-             self.origin.repr(tcx))\n+        format!(\"method_map_entry \\\\{origin: {}\\\\}\", self.origin.repr(tcx))\n     }\n }\n "}, {"sha": "e86122fb7d1e670fd5bfe0517aae14ddf38cd276", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -330,6 +330,16 @@ pub struct Method {\n \n impl Clean<Item> for ast::Method {\n     fn clean(&self) -> Item {\n+        let inputs = match self.explicit_self.node {\n+            ast::SelfStatic => self.decl.inputs.as_slice(),\n+            _ => self.decl.inputs.slice_from(1)\n+        };\n+        let decl = FnDecl {\n+            inputs: inputs.iter().map(|x| x.clean()).collect(),\n+            output: (self.decl.output.clean()),\n+            cf: self.decl.cf.clean(),\n+            attrs: ~[]\n+        };\n         Item {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean(),\n@@ -340,7 +350,7 @@ impl Clean<Item> for ast::Method {\n                 generics: self.generics.clean(),\n                 self_: self.explicit_self.clean(),\n                 purity: self.purity.clone(),\n-                decl: self.decl.clean(),\n+                decl: decl,\n             }),\n         }\n     }\n@@ -356,6 +366,16 @@ pub struct TyMethod {\n \n impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self) -> Item {\n+        let inputs = match self.explicit_self.node {\n+            ast::SelfStatic => self.decl.inputs.as_slice(),\n+            _ => self.decl.inputs.slice_from(1)\n+        };\n+        let decl = FnDecl {\n+            inputs: inputs.iter().map(|x| x.clean()).collect(),\n+            output: (self.decl.output.clean()),\n+            cf: self.decl.cf.clean(),\n+            attrs: ~[]\n+        };\n         Item {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean(),\n@@ -364,7 +384,7 @@ impl Clean<Item> for ast::TypeMethod {\n             visibility: None,\n             inner: TyMethodItem(TyMethod {\n                 purity: self.purity.clone(),\n-                decl: self.decl.clean(),\n+                decl: decl,\n                 self_: self.explicit_self.clean(),\n                 generics: self.generics.clean(),\n             }),\n@@ -385,8 +405,8 @@ impl Clean<SelfTy> for ast::ExplicitSelf {\n     fn clean(&self) -> SelfTy {\n         match self.node {\n             ast::SelfStatic => SelfStatic,\n-            ast::SelfValue(_) => SelfValue,\n-            ast::SelfUniq(_) => SelfOwned,\n+            ast::SelfValue => SelfValue,\n+            ast::SelfUniq => SelfOwned,\n             ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n             ast::SelfBox => SelfManaged,\n         }\n@@ -1178,7 +1198,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n \n     let (def_id, kind) = match *d {\n         ast::DefFn(i, _) => (i, TypeFunction),\n-        ast::DefSelf(i, _) | ast::DefSelfTy(i) => return Self(i),\n+        ast::DefSelfTy(i) => return Self(i),\n         ast::DefTy(i) => (i, TypeEnum),\n         ast::DefTrait(i) => {\n             debug!(\"saw DefTrait in def_to_id\");"}, {"sha": "90ed4a4c744c5ab7593ad72b9c0368307acd0ef9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -682,7 +682,7 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn crate(mut self, mut crate: clean::Crate, cache: Cache) {\n+    fn crate(self, mut crate: clean::Crate, cache: Cache) {\n         let mut item = match crate.module.take() {\n             Some(i) => i,\n             None => return"}, {"sha": "012ab9ed1226bfc85b5eea33268929e4015ee874", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -338,7 +338,7 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(mut ~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n+    fn listen(~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = ~TcpAcceptor { listener: self };\n "}, {"sha": "36a7a631943262afb8a8a845c2e03ac103c1c429", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -174,7 +174,7 @@ impl PipeListener {\n }\n \n impl RtioUnixListener for PipeListener {\n-    fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n+    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = ~PipeAcceptor { listener: self };\n "}, {"sha": "64e42c5480f28bfdf86eaf50624a954d40c916bc", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -230,7 +230,7 @@ impl<W: Writer> LineBufferedWriter<W> {\n     /// Unwraps this buffer, returning the underlying writer.\n     ///\n     /// The internal buffer is flushed before returning the writer.\n-    pub fn unwrap(mut self) -> W { self.inner.unwrap() }\n+    pub fn unwrap(self) -> W { self.inner.unwrap() }\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {"}, {"sha": "87655f5911fe700927684768f67575d0c3989c70", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -451,13 +451,8 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_opaque_box(&mut self) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_opaque_box() { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n+    // NOTE remove after next snapshot\n+    #[cfg(stage0)]\n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n         self.align_to::<proc()>();\n         if ! self.inner.visit_closure_ptr(ck) {"}, {"sha": "1ecc31ec2f4e9a5571924d20b7ac22291e27792e", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -580,14 +580,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_self(&mut self) -> bool { true }\n     fn visit_type(&mut self) -> bool { true }\n \n-    fn visit_opaque_box(&mut self) -> bool {\n-        self.writer.write(['@' as u8]);\n-        self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n-            this.visit_ptr_inner(p, b.type_desc);\n-        })\n-    }\n-\n+    // NOTE remove after next snapshot\n+    #[cfg(stage0)]\n     fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n "}, {"sha": "1988993707fce39822707ff91094f8ff9e66dfbb", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -164,7 +164,9 @@ pub trait TyVisitor {\n     fn visit_param(&mut self, i: uint) -> bool;\n     fn visit_self(&mut self) -> bool;\n     fn visit_type(&mut self) -> bool;\n-    fn visit_opaque_box(&mut self) -> bool;\n+\n+    // NOTE remove after next snapshot\n+    #[cfg(stage0)]\n     fn visit_closure_ptr(&mut self, ck: uint) -> bool;\n }\n "}, {"sha": "10b1aad81382ef90764af5074718602442a4dce8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -10,10 +10,11 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{Span, Spanned};\n+use codemap::{Span, Spanned, DUMMY_SP};\n use abi::AbiSet;\n+use ast_util;\n use opt_vec::OptVec;\n-use parse::token::{interner_get, str_to_ident};\n+use parse::token::{interner_get, str_to_ident, special_idents};\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n@@ -236,7 +237,6 @@ pub enum MethodProvenance {\n pub enum Def {\n     DefFn(DefId, Purity),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, Purity),\n-    DefSelf(NodeId, bool /* is_mutbl */),\n     DefSelfTy(/* trait id */ NodeId),\n     DefMod(DefId),\n     DefForeignMod(DefId),\n@@ -357,7 +357,7 @@ pub enum BindingMode {\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n-    // A pat_ident may either be a new bound variable,\n+    // A PatIdent may either be a new bound variable,\n     // or a nullary enum (in which case the second field\n     // is None).\n     // In the nullary enum case, the parser can't determine\n@@ -366,15 +366,15 @@ pub enum Pat_ {\n     // set (of \"pat_idents that refer to nullary enums\")\n     PatIdent(BindingMode, Path, Option<@Pat>),\n     PatEnum(Path, Option<~[@Pat]>), /* \"none\" means a * pattern where\n-                                       * we don't bind the fields to names */\n+                                     * we don't bind the fields to names */\n     PatStruct(Path, ~[FieldPat], bool),\n     PatTup(~[@Pat]),\n     PatUniq(@Pat),\n     PatRegion(@Pat), // reference pattern\n     PatLit(@Expr),\n     PatRange(@Expr, @Expr),\n     // [a, b, ..i, y, z] is represented as\n-    // pat_vec(~[a, b], Some(i), ~[y, z])\n+    // PatVec(~[a, b], Some(i), ~[y, z])\n     PatVec(~[@Pat], Option<@Pat>, ~[@Pat])\n }\n \n@@ -526,7 +526,7 @@ pub struct Expr {\n impl Expr {\n     pub fn get_callee_id(&self) -> Option<NodeId> {\n         match self.node {\n-            ExprMethodCall(callee_id, _, _, _, _, _) |\n+            ExprMethodCall(callee_id, _, _, _, _) |\n             ExprIndex(callee_id, _, _) |\n             ExprBinary(callee_id, _, _, _) |\n             ExprAssignOp(callee_id, _, _, _) |\n@@ -550,7 +550,7 @@ pub enum Expr_ {\n     ExprBox(@Expr, @Expr),\n     ExprVec(~[@Expr], Mutability),\n     ExprCall(@Expr, ~[@Expr], CallSugar),\n-    ExprMethodCall(NodeId, @Expr, Ident, ~[P<Ty>], ~[@Expr], CallSugar),\n+    ExprMethodCall(NodeId, Ident, ~[P<Ty>], ~[@Expr], CallSugar),\n     ExprTup(~[@Expr]),\n     ExprBinary(NodeId, BinOp, @Expr, @Expr),\n     ExprUnary(NodeId, UnOp, @Expr),\n@@ -579,8 +579,6 @@ pub enum Expr_ {\n     /// of a function call.\n     ExprPath(Path),\n \n-    /// The special identifier `self`.\n-    ExprSelf,\n     ExprAddrOf(Mutability, @Expr),\n     ExprBreak(Option<Name>),\n     ExprAgain(Option<Name>),\n@@ -783,7 +781,7 @@ pub enum IntTy {\n \n impl ToStr for IntTy {\n     fn to_str(&self) -> ~str {\n-        ::ast_util::int_ty_to_str(*self)\n+        ast_util::int_ty_to_str(*self)\n     }\n }\n \n@@ -798,7 +796,7 @@ pub enum UintTy {\n \n impl ToStr for UintTy {\n     fn to_str(&self) -> ~str {\n-        ::ast_util::uint_ty_to_str(*self)\n+        ast_util::uint_ty_to_str(*self)\n     }\n }\n \n@@ -810,7 +808,7 @@ pub enum FloatTy {\n \n impl ToStr for FloatTy {\n     fn to_str(&self) -> ~str {\n-        ::ast_util::float_ty_to_str(*self)\n+        ast_util::float_ty_to_str(*self)\n     }\n }\n \n@@ -886,7 +884,7 @@ pub enum Ty_ {\n     TyTup(~[P<Ty>]),\n     TyPath(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     TyTypeof(@Expr),\n-    // ty_infer means the type should be inferred instead of it having been\n+    // TyInfer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one.\n     TyInfer,\n@@ -917,6 +915,26 @@ pub struct Arg {\n     id: NodeId,\n }\n \n+impl Arg {\n+    pub fn new_self(span: Span, mutability: Mutability) -> Arg {\n+        let path = ast_util::ident_to_path(span, special_idents::self_);\n+        Arg {\n+            // HACK(eddyb) fake type for the self argument.\n+            ty: P(Ty {\n+                id: DUMMY_NODE_ID,\n+                node: TyInfer,\n+                span: DUMMY_SP,\n+            }),\n+            pat: @Pat {\n+                id: DUMMY_NODE_ID,\n+                node: PatIdent(BindByValue(mutability), path, None),\n+                span: span\n+            },\n+            id: DUMMY_NODE_ID\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct FnDecl {\n     inputs: ~[Arg],\n@@ -952,10 +970,10 @@ pub enum RetStyle {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n-    SelfValue(Mutability),                     // `self`, `mut self`\n+    SelfValue,                                 // `self`\n     SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`, `&'lt mut self`\n     SelfBox,                                   // `@self`\n-    SelfUniq(Mutability)                       // `~self`, `mut ~self`\n+    SelfUniq                                   // `~self`\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n@@ -971,7 +989,6 @@ pub struct Method {\n     body: P<Block>,\n     id: NodeId,\n     span: Span,\n-    self_id: NodeId,\n     vis: Visibility,\n }\n "}, {"sha": "bb66d620d2910392d5f6729264beb8672b3dd5ef", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -17,7 +17,6 @@ use diagnostic::SpanHandler;\n use fold::Folder;\n use fold;\n use parse::token::{get_ident_interner, IdentInterner};\n-use parse::token::special_idents;\n use print::pprust;\n use util::small_vector::SmallVector;\n \n@@ -163,10 +162,7 @@ pub enum Node {\n     NodeExpr(@Expr),\n     NodeStmt(@Stmt),\n     NodeArg(@Pat),\n-    // HACK(eddyb) should always be a pattern, but `self` is not, and thus it\n-    // is identified only by an ident and no span is available. In all other\n-    // cases, node_span will return the proper span (required by borrowck).\n-    NodeLocal(Ident, Option<@Pat>),\n+    NodeLocal(@Pat),\n     NodeBlock(P<Block>),\n \n     /// NodeStructCtor represents a tuple struct.\n@@ -246,10 +242,6 @@ impl<F> Ctx<F> {\n         let mut map = self.map.map.borrow_mut();\n         map.get().insert(id as uint, node);\n     }\n-\n-    fn map_self(&self, m: @Method) {\n-        self.insert(m.self_id, NodeLocal(special_idents::self_, None));\n-    }\n }\n \n impl<F: FoldOps> Folder for Ctx<F> {\n@@ -285,7 +277,6 @@ impl<F: FoldOps> Folder for Ctx<F> {\n                 let impl_did = ast_util::local_def(i.id);\n                 for &m in ms.iter() {\n                     self.insert(m.id, NodeMethod(m, impl_did, p));\n-                    self.map_self(m);\n                 }\n \n             }\n@@ -332,7 +323,6 @@ impl<F: FoldOps> Folder for Ctx<F> {\n                         }\n                         Provided(m) => {\n                             self.insert(m.id, NodeTraitMethod(@Provided(m), d_id, p));\n-                            self.map_self(m);\n                         }\n                     }\n                 }\n@@ -348,9 +338,9 @@ impl<F: FoldOps> Folder for Ctx<F> {\n     fn fold_pat(&mut self, pat: @Pat) -> @Pat {\n         let pat = fold::noop_fold_pat(pat, self);\n         match pat.node {\n-            PatIdent(_, ref path, _) => {\n+            PatIdent(..) => {\n                 // Note: this is at least *potentially* a pattern...\n-                self.insert(pat.id, NodeLocal(ast_util::path_to_ident(path), Some(pat)));\n+                self.insert(pat.id, NodeLocal(pat));\n             }\n             _ => {}\n         }\n@@ -467,7 +457,6 @@ pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n                 NodeMethod(m, impl_did, @path)\n             };\n             cx.insert(m.id, entry);\n-            cx.map_self(m);\n         }\n     }\n \n@@ -525,8 +514,8 @@ pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n       Some(NodeArg(pat)) => {\n         format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n-      Some(NodeLocal(ident, _)) => {\n-        format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n+      Some(NodeLocal(pat)) => {\n+        format!(\"local {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n       Some(NodeBlock(block)) => {\n         format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n@@ -559,11 +548,7 @@ pub fn node_span(items: Map, id: ast::NodeId) -> Span {\n         Some(NodeVariant(variant, _, _)) => variant.span,\n         Some(NodeExpr(expr)) => expr.span,\n         Some(NodeStmt(stmt)) => stmt.span,\n-        Some(NodeArg(pat)) => pat.span,\n-        Some(NodeLocal(_, pat)) => match pat {\n-            Some(pat) => pat.span,\n-            None => fail!(\"node_span: cannot get span from NodeLocal (likely `self`)\")\n-        },\n+        Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,\n         Some(NodeBlock(block)) => block.span,\n         Some(NodeStructCtor(_, item, _)) => item.span,\n         Some(NodeCalleeScope(expr)) => expr.span,"}, {"sha": "405de5c5542d075dc334c536fd719f9d54a46eb9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -60,19 +60,19 @@ pub fn variant_def_ids(d: Def) -> Option<(DefId, DefId)> {\n \n pub fn def_id_of_def(d: Def) -> DefId {\n     match d {\n-      DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n-      DefForeignMod(id) | DefStatic(id, _) |\n-      DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n-      DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n-        id\n-      }\n-      DefArg(id, _) | DefLocal(id, _) | DefSelf(id, _) | DefSelfTy(id)\n-      | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n-      | DefTyParamBinder(id) | DefLabel(id) => {\n-        local_def(id)\n-      }\n+        DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n+        DefForeignMod(id) | DefStatic(id, _) |\n+        DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n+        DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n+            id\n+        }\n+        DefArg(id, _) | DefLocal(id, _) | DefSelfTy(id)\n+        | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n+        | DefTyParamBinder(id) | DefLabel(id) => {\n+            local_def(id)\n+        }\n \n-      DefPrimTy(_) => fail!()\n+        DefPrimTy(_) => fail!()\n     }\n }\n \n@@ -292,16 +292,6 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     }\n }\n \n-/* True if d is either a def_self, or a chain of def_upvars\n- referring to a def_self */\n-pub fn is_self(d: ast::Def) -> bool {\n-  match d {\n-    DefSelf(..)           => true,\n-    DefUpvar(_, d, _, _) => is_self(*d),\n-    _                     => false\n-  }\n-}\n-\n /// Maps a binary operator to its precedence\n pub fn operator_prec(op: ast::BinOp) -> uint {\n   match op {\n@@ -504,11 +494,8 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         self.operation.visit_id(node_id);\n \n         match *function_kind {\n-            visit::FkItemFn(_, generics, _, _) => {\n-                self.visit_generics_helper(generics)\n-            }\n-            visit::FkMethod(_, generics, method) => {\n-                self.operation.visit_id(method.self_id);\n+            visit::FkItemFn(_, generics, _, _) |\n+            visit::FkMethod(_, generics, _) => {\n                 self.visit_generics_helper(generics)\n             }\n             visit::FkFnBlock => {}"}, {"sha": "3b43c96a184cdf656088fbb83dc07bddfbb55032", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -18,6 +18,7 @@ use ext::quote::rt::*;\n use fold::Folder;\n use opt_vec;\n use opt_vec::OptVec;\n+use parse::token::special_idents;\n \n pub struct Field {\n     ident: ast::Ident,\n@@ -478,7 +479,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> @ast::Expr {\n-        self.expr(span, ast::ExprSelf)\n+        self.expr_ident(span, special_idents::self_)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n@@ -523,9 +524,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr,\n                         ident: ast::Ident,\n-                        args: ~[@ast::Expr]) -> @ast::Expr {\n-        self.expr(span,\n-                  ast::ExprMethodCall(ast::DUMMY_NODE_ID, expr, ident, ~[], args, ast::NoSugar))\n+                        mut args: ~[@ast::Expr]) -> @ast::Expr {\n+        args.unshift(expr);\n+        self.expr(span, ast::ExprMethodCall(ast::DUMMY_NODE_ID, ident, ~[], args, ast::NoSugar))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))"}, {"sha": "e1fb80049e083a611bdcd37cee4726fa7cc35032", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -551,9 +551,14 @@ impl<'a> MethodDef<'a> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(trait_.cx, trait_.span, type_ident, generics);\n \n+        let self_arg = match explicit_self.node {\n+            ast::SelfStatic => None,\n+            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n+        };\n         let args = arg_types.move_iter().map(|(name, ty)| {\n             trait_.cx.arg(trait_.span, name, ty)\n-        }).collect();\n+        });\n+        let args = self_arg.move_iter().chain(args).collect();\n \n         let ret_type = self.get_ret_ty(trait_, generics, type_ident);\n \n@@ -578,7 +583,6 @@ impl<'a> MethodDef<'a> {\n             body: body_block,\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n-            self_id: ast::DUMMY_NODE_ID,\n             vis: ast::Inherited,\n         }\n     }"}, {"sha": "b22dcfe0da2c9a602e6132a36c426c701adad59e", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -244,13 +244,13 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfValue(ast::MutImmutable)))\n+            (self_path, respan(span, ast::SelfValue))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::SelfUniq(ast::MutImmutable),\n+                    Send => ast::SelfUniq,\n                     Managed => ast::SelfBox,\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));"}, {"sha": "c739fb911ba7fa0335ccaa9886b70780571cb88f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -306,9 +306,7 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue(_) | SelfUniq(_) | SelfBox => {\n-                *es\n-            }\n+            SelfStatic | SelfValue | SelfUniq | SelfBox => *es,\n             SelfRegion(ref lifetime, m) => {\n                 SelfRegion(fold_opt_lifetime(lifetime, self), m)\n             }\n@@ -666,7 +664,6 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n         body: folder.fold_block(m.body),\n         id: folder.new_id(m.id),\n         span: folder.new_span(m.span),\n-        self_id: folder.new_id(m.self_id),\n         vis: m.vis\n     }\n }\n@@ -737,10 +734,9 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n                      args.map(|&x| folder.fold_expr(x)),\n                      blk)\n         }\n-        ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n+        ExprMethodCall(callee_id, i, ref tps, ref args, blk) => {\n             ExprMethodCall(\n                 folder.new_id(callee_id),\n-                folder.fold_expr(f),\n                 folder.fold_ident(i),\n                 tps.map(|&x| folder.fold_ty(x)),\n                 args.map(|&x| folder.fold_expr(x)),\n@@ -811,7 +807,6 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n                       folder.fold_expr(er))\n         }\n         ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n-        ExprSelf => ExprSelf,\n         ExprLogLevel => ExprLogLevel,\n         ExprBreak(opt_ident) => ExprBreak(opt_ident),\n         ExprAgain(opt_ident) => ExprAgain(opt_ident),"}, {"sha": "61c80919b6e713113f74f3bcdb4275f6427f66e0", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -31,8 +31,8 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n       | ast::ExprForLoop(..)\n       | ast::ExprCall(_, _, ast::DoSugar)\n       | ast::ExprCall(_, _, ast::ForSugar)\n-      | ast::ExprMethodCall(_, _, _, _, _, ast::DoSugar)\n-      | ast::ExprMethodCall(_, _, _, _, _, ast::ForSugar) => false,\n+      | ast::ExprMethodCall(_, _, _, _, ast::DoSugar)\n+      | ast::ExprMethodCall(_, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }\n }"}, {"sha": "17590ccf52358320e1651c44c81c65c67c94087e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -27,8 +27,8 @@ use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n-use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc, ExprRepeat};\n-use ast::{ExprRet, ExprSelf, ExprStruct, ExprTup, ExprUnary};\n+use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n+use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprVstore, ExprVstoreSlice, ExprVstoreBox};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, ExternFn, Field, FnDecl};\n use ast::{ExprVstoreUniq, Onceness, Once, Many};\n@@ -1093,7 +1093,6 @@ impl Parser {\n                     body: body,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n-                    self_id: ast::DUMMY_NODE_ID,\n                     vis: vis,\n                 })\n               }\n@@ -1687,13 +1686,9 @@ impl Parser {\n         ExprCall(f, args, sugar)\n     }\n \n-    pub fn mk_method_call(&mut self,\n-                      rcvr: @Expr,\n-                      ident: Ident,\n-                      tps: ~[P<Ty>],\n-                      args: ~[@Expr],\n+    fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr],\n                       sugar: CallSugar) -> ast::Expr_ {\n-        ExprMethodCall(ast::DUMMY_NODE_ID, rcvr, ident, tps, args, sugar)\n+        ExprMethodCall(ast::DUMMY_NODE_ID, ident, tps, args, sugar)\n     }\n \n     pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n@@ -1794,7 +1789,8 @@ impl Parser {\n \n             return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n         } else if self.eat_keyword(keywords::Self) {\n-            ex = ExprSelf;\n+            let path = ast_util::ident_to_path(mk_sp(lo, hi), special_idents::self_);\n+            ex = ExprPath(path);\n             hi = self.span.hi;\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n@@ -1993,15 +1989,16 @@ impl Parser {\n                     // expr.f() method call\n                     match self.token {\n                         token::LPAREN => {\n-                            let es = self.parse_unspanned_seq(\n+                            let mut es = self.parse_unspanned_seq(\n                                 &token::LPAREN,\n                                 &token::RPAREN,\n                                 seq_sep_trailing_disallowed(token::COMMA),\n                                 |p| p.parse_expr()\n                             );\n                             hi = self.span.hi;\n \n-                            let nd = self.mk_method_call(e, i, tys, es, NoSugar);\n+                            es.unshift(e);\n+                            let nd = self.mk_method_call(i, tys, es, NoSugar);\n                             e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n@@ -2569,16 +2566,15 @@ impl Parser {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append((*args).clone(), [last_arg]);\n+                let args = vec::append_one((*args).clone(), last_arg);\n                 self.mk_expr(lo, block.span.hi, ExprCall(f, args, sugar))\n             }\n-            ExprMethodCall(_, f, i, ref tps, ref args, NoSugar) => {\n+            ExprMethodCall(_, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append((*args).clone(), [last_arg]);\n-                let method_call = self.mk_method_call(f,\n-                                                      i,\n+                let args = vec::append_one((*args).clone(), last_arg);\n+                let method_call = self.mk_method_call(i,\n                                                       (*tps).clone(),\n                                                       args,\n                                                       sugar);\n@@ -2588,10 +2584,9 @@ impl Parser {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let method_call = self.mk_method_call(f,\n-                                                      i,\n+                let method_call = self.mk_method_call(i,\n                                                       (*tps).clone(),\n-                                                      ~[last_arg],\n+                                                      ~[f, last_arg],\n                                                       sugar);\n                 self.mk_expr(lo, block.span.hi, method_call)\n             }\n@@ -3712,6 +3707,7 @@ impl Parser {\n         // A bit of complexity and lookahead is needed here in order to be\n         // backwards compatible.\n         let lo = self.span.lo;\n+        let mut mutbl_self = MutImmutable;\n         let explicit_self = match self.token {\n             token::BINOP(token::AND) => {\n                 maybe_parse_borrowed_explicit_self(self)\n@@ -3720,57 +3716,60 @@ impl Parser {\n                 maybe_parse_explicit_self(SelfBox, self)\n             }\n             token::TILDE => {\n-                maybe_parse_explicit_self(SelfUniq(MutImmutable), self)\n+                maybe_parse_explicit_self(SelfUniq, self)\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n                 self.bump();\n-                SelfValue(MutImmutable)\n+                SelfValue\n             }\n             token::BINOP(token::STAR) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n                 // emitting cryptic \"unexpected token\" errors.\n                 self.bump();\n-                let mutability = if Parser::token_is_mutability(&self.token) {\n+                let _mutability = if Parser::token_is_mutability(&self.token) {\n                     self.parse_mutability()\n                 } else { MutImmutable };\n                 if self.is_self_ident() {\n                     self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n                     self.bump();\n                 }\n-                SelfValue(mutability)\n+                SelfValue\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n-                let mutability = self.parse_mutability();\n+                mutbl_self = self.parse_mutability();\n                 self.expect_self_ident();\n-                SelfValue(mutability)\n+                SelfValue\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| *t == token::TILDE) &&\n                     self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n-                let mutability = self.parse_mutability();\n+                mutbl_self = self.parse_mutability();\n                 self.bump();\n                 self.expect_self_ident();\n-                SelfUniq(mutability)\n+                SelfUniq\n             }\n             _ => SelfStatic\n         };\n \n+        let explicit_self_sp = mk_sp(lo, self.span.hi);\n+\n         // If we parsed a self type, expect a comma before the argument list.\n-        let fn_inputs;\n-        if explicit_self != SelfStatic {\n+        let fn_inputs = if explicit_self != SelfStatic {\n             match self.token {\n                 token::COMMA => {\n                     self.bump();\n                     let sep = seq_sep_trailing_disallowed(token::COMMA);\n-                    fn_inputs = self.parse_seq_to_before_end(\n+                    let mut fn_inputs = self.parse_seq_to_before_end(\n                         &token::RPAREN,\n                         sep,\n                         parse_arg_fn\n                     );\n+                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self));\n+                    fn_inputs\n                 }\n                 token::RPAREN => {\n-                    fn_inputs = ~[];\n+                    ~[Arg::new_self(explicit_self_sp, mutbl_self)]\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_str();\n@@ -3780,10 +3779,8 @@ impl Parser {\n             }\n         } else {\n             let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            fn_inputs = self.parse_seq_to_before_end(&token::RPAREN,\n-                                                     sep,\n-                                                     parse_arg_fn);\n-        }\n+            self.parse_seq_to_before_end(&token::RPAREN, sep, parse_arg_fn)\n+        };\n \n         self.expect(&token::RPAREN);\n \n@@ -3918,7 +3915,6 @@ impl Parser {\n             body: body,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            self_id: ast::DUMMY_NODE_ID,\n             vis: visa,\n         }\n     }"}, {"sha": "d3c194b6af67a8852e920e3aaae09b35cfadd5b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -1213,10 +1213,10 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) {\n         print_expr(s, func);\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::ExprMethodCall(_, func, ident, ref tys, ref args, sugar) => {\n-        let mut base_args = (*args).clone();\n+      ast::ExprMethodCall(_, ident, ref tys, ref args, sugar) => {\n+        let mut base_args = args.slice_from(1).to_owned();\n         let blk = print_call_pre(s, sugar, &mut base_args);\n-        print_expr(s, func);\n+        print_expr(s, args[0]);\n         word(&mut s.s, \".\");\n         print_ident(s, ident);\n         if tys.len() > 0u {\n@@ -1445,7 +1445,6 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) {\n         word(&mut s.s, \"]\");\n       }\n       ast::ExprPath(ref path) => print_path(s, path, true),\n-      ast::ExprSelf => word(&mut s.s, \"self\"),\n       ast::ExprBreak(opt_ident) => {\n         word(&mut s.s, \"break\");\n         space(&mut s.s);\n@@ -1749,19 +1748,20 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) {\n }\n \n pub fn explicit_self_to_str(explicit_self: &ast::ExplicitSelf_, intr: @IdentInterner) -> ~str {\n-    to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n+    to_str(explicit_self, |a, &b| { print_explicit_self(a, b, ast::MutImmutable); () }, intr)\n }\n \n // Returns whether it printed anything\n-pub fn print_explicit_self(s: &mut State, explicit_self: ast::ExplicitSelf_) -> bool {\n+fn print_explicit_self(s: &mut State,\n+                       explicit_self: ast::ExplicitSelf_,\n+                       mutbl: ast::Mutability) -> bool {\n+    print_mutability(s, mutbl);\n     match explicit_self {\n         ast::SelfStatic => { return false; }\n-        ast::SelfValue(m) => {\n-            print_mutability(s, m);\n+        ast::SelfValue => {\n             word(&mut s.s, \"self\");\n         }\n-        ast::SelfUniq(m) => {\n-            print_mutability(s, m);\n+        ast::SelfUniq => {\n             word(&mut s.s, \"~self\");\n         }\n         ast::SelfRegion(ref lt, m) => {\n@@ -1799,11 +1799,25 @@ pub fn print_fn_args(s: &mut State, decl: &ast::FnDecl,\n     // self type and the args all in the same box.\n     rbox(s, 0u, Inconsistent);\n     let mut first = true;\n-    for explicit_self in opt_explicit_self.iter() {\n-        first = !print_explicit_self(s, *explicit_self);\n+    for &explicit_self in opt_explicit_self.iter() {\n+        let m = match explicit_self {\n+            ast::SelfStatic => ast::MutImmutable,\n+            _ => match decl.inputs[0].pat.node {\n+                ast::PatIdent(ast::BindByValue(m), _, _) => m,\n+                _ => ast::MutImmutable\n+            }\n+        };\n+        first = !print_explicit_self(s, explicit_self, m);\n     }\n \n-    for arg in decl.inputs.iter() {\n+    // HACK(eddyb) ignore the separately printed self argument.\n+    let args = if first {\n+        decl.inputs.as_slice()\n+    } else {\n+        decl.inputs.slice_from(1)\n+    };\n+\n+    for arg in args.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, arg);\n     }\n@@ -2090,18 +2104,7 @@ pub fn print_ty_fn(s: &mut State,\n         popen(s);\n     }\n \n-    // It is unfortunate to duplicate the commasep logic, but we want the\n-    // self type and the args all in the same box.\n-    rbox(s, 0u, Inconsistent);\n-    let mut first = true;\n-    for explicit_self in opt_explicit_self.iter() {\n-        first = !print_explicit_self(s, *explicit_self);\n-    }\n-    for arg in decl.inputs.iter() {\n-        if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, arg);\n-    }\n-    end(s);\n+    print_fn_args(s, decl, opt_explicit_self);\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n         word(&mut s.s, \"|\");"}, {"sha": "5e7ad3af526b2e8ec458e22f8c1fbb81a575a42e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -186,7 +186,7 @@ fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                explicit_self: &ExplicitSelf,\n                                                env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) | SelfBox | SelfUniq(_) => {}\n+        SelfStatic | SelfValue | SelfBox | SelfUniq => {}\n         SelfRegion(ref lifetime, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }\n@@ -654,12 +654,11 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             }\n             visitor.visit_expr(callee_expression, env.clone())\n         }\n-        ExprMethodCall(_, callee, _, ref types, ref arguments, _) => {\n+        ExprMethodCall(_, _, ref types, ref arguments, _) => {\n             walk_exprs(visitor, *arguments, env.clone());\n             for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n-            visitor.visit_expr(callee, env.clone())\n         }\n         ExprBinary(_, _, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression, env.clone());\n@@ -734,7 +733,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id, env.clone())\n         }\n-        ExprSelf | ExprBreak(_) | ExprAgain(_) => {}\n+        ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(optional_expression) => {\n             walk_expr_opt(visitor, optional_expression, env.clone())\n         }"}, {"sha": "c165802d61ffbe5cd511f2808e347075e58be7fa", "filename": "src/test/compile-fail/coerce-bare-fn-to-closure-and-proc.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() {}\n+\n+fn main() {\n+    let f = foo;\n+    let f_closure: || = f;\n+    //~^ ERROR: cannot coerce non-statically resolved bare fn\n+    let f_proc: proc() = f;\n+    //~^ ERROR: cannot coerce non-statically resolved bare fn\n+}"}, {"sha": "2c1809d4d4886f45c25a7f5ff87a679d10eeaa17", "filename": "src/test/compile-fail/issue-6642.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,11 +11,10 @@\n struct A;\n impl A {\n     fn m(&self) {\n-          fn x() {\n-              self.m()\n-              //~^ ERROR can't capture dynamic environment in a fn item\n-              //~^^ ERROR `self` is not allowed in this context\n-          }\n+        fn x() {\n+            self.m() //~ ERROR can't capture dynamic environment in a fn item\n+            //~^ ERROR unresolved name `self`\n+        }\n     }\n }\n fn main() {}"}, {"sha": "ada534ffc72a50bccfe6d9b36529e81c0e0ef43a", "filename": "src/test/compile-fail/lint-unused-mut-self.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(dead_assignment)];\n+#[allow(unused_variable)];\n+#[allow(dead_code)];\n+#[deny(unused_mut)];\n+\n+struct Foo;\n+impl Foo {\n+    fn foo(mut self) {} //~ ERROR: variable does not need to be mutable\n+    fn bar(mut ~self) {} //~ ERROR: variable does not need to be mutable\n+}\n+\n+fn main() {}"}, {"sha": "ea2062dd2720985aba0cdf0094a14db896a72c1c", "filename": "src/test/compile-fail/trait-impl-different-num-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,7 +13,7 @@ trait foo {\n }\n impl foo for int {\n     fn bar(&self) -> int {\n-        //~^ ERROR method `bar` has 0 parameters but the declaration in trait `foo::bar` has 1\n+        //~^ ERROR method `bar` has 1 parameter but the declaration in trait `foo::bar` has 2\n         *self\n     }\n }"}, {"sha": "6f643ca0f41017f9a13c9c5d5dd64736552e2be7", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+#[deriving(Eq)]\n+struct Foo<T>(T);\n+\n+#[deriving(Eq)]\n+enum Bar<T> {\n+    Bar(T)\n+}\n+\n+pub fn main() {\n+    let f: |int| -> int = id;\n+    assert_eq!(f(5), 5);\n+\n+    let f: proc(int) -> int = id;\n+    assert_eq!(f(5), 5);\n+\n+    let f: |int| -> Foo<int> = Foo;\n+    assert_eq!(f(5), Foo(5));\n+\n+    let f: proc(int) -> Foo<int> = Foo;\n+    assert_eq!(f(5), Foo(5));\n+\n+    let f: |int| -> Bar<int> = Bar;\n+    assert_eq!(f(5), Bar(5));\n+\n+    let f: proc(int) -> Bar<int> = Bar;\n+    assert_eq!(f(5), Bar(5));\n+\n+    let f: |int| -> Option<int> = Some;\n+    assert_eq!(f(5), Some(5));\n+\n+    let f: proc(int) -> Option<int> = Some;\n+    assert_eq!(f(5), Some(5));\n+}"}, {"sha": "9ca41c56dc9602174be374f0a4961da5e2fde1e5", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -13,7 +13,7 @@\n fn test_fn() {\n     type t = 'static || -> int;\n     fn ten() -> int { return 10; }\n-    let rs: t = { ten };\n+    let rs: t = ten;\n     assert!((rs() == 10));\n }\n "}, {"sha": "6dec5fdaa1cbac0a7a498c600aadc4167042e292", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -436,20 +436,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         if ! self.inner().visit_type() { return false; }\n         true\n     }\n-\n-    fn visit_opaque_box(&mut self) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner().visit_opaque_box() { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n-        self.align_to::<(uint,uint)>();\n-        if ! self.inner().visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<(uint,uint)>();\n-        true\n-    }\n }\n \n struct my_visitor(@RefCell<Stuff>);\n@@ -611,8 +597,6 @@ impl TyVisitor for my_visitor {\n     fn visit_param(&mut self, _i: uint) -> bool { true }\n     fn visit_self(&mut self) -> bool { true }\n     fn visit_type(&mut self) -> bool { true }\n-    fn visit_opaque_box(&mut self) -> bool { true }\n-    fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n fn get_tydesc_for<T>(_t: T) -> *TyDesc {"}, {"sha": "91e69028103a33536aa675b4f6d814f8926a9671", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ba0c310a2bfe2ab69670d0d87529a29d527973/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=15ba0c310a2bfe2ab69670d0d87529a29d527973", "patch": "@@ -137,8 +137,6 @@ impl TyVisitor for MyVisitor {\n     fn visit_param(&mut self, _i: uint) -> bool { true }\n     fn visit_self(&mut self) -> bool { true }\n     fn visit_type(&mut self) -> bool { true }\n-    fn visit_opaque_box(&mut self) -> bool { true }\n-    fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n fn visit_ty<T>(v: &mut MyVisitor) {"}]}