{"sha": "450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MDU1NGViZjEzOWQwYjZlY2RlODBmMTdjMmVmODlmZjdkZTc4YmI=", "commit": {"author": {"name": "Segev Finer", "email": "segev208@gmail.com", "date": "2017-01-27T09:33:24Z"}, "committer": {"name": "Segev Finer", "email": "segev208@gmail.com", "date": "2017-01-27T09:33:24Z"}, "message": "Attempt at fixing dead code lints", "tree": {"sha": "5f613be9595100b5086a4026aaa9df9d327e69cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f613be9595100b5086a4026aaa9df9d327e69cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "html_url": "https://github.com/rust-lang/rust/commit/450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/comments", "author": {"login": "segevfiner", "id": 24731903, "node_id": "MDQ6VXNlcjI0NzMxOTAz", "avatar_url": "https://avatars.githubusercontent.com/u/24731903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segevfiner", "html_url": "https://github.com/segevfiner", "followers_url": "https://api.github.com/users/segevfiner/followers", "following_url": "https://api.github.com/users/segevfiner/following{/other_user}", "gists_url": "https://api.github.com/users/segevfiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/segevfiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segevfiner/subscriptions", "organizations_url": "https://api.github.com/users/segevfiner/orgs", "repos_url": "https://api.github.com/users/segevfiner/repos", "events_url": "https://api.github.com/users/segevfiner/events{/privacy}", "received_events_url": "https://api.github.com/users/segevfiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segevfiner", "id": 24731903, "node_id": "MDQ6VXNlcjI0NzMxOTAz", "avatar_url": "https://avatars.githubusercontent.com/u/24731903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segevfiner", "html_url": "https://github.com/segevfiner", "followers_url": "https://api.github.com/users/segevfiner/followers", "following_url": "https://api.github.com/users/segevfiner/following{/other_user}", "gists_url": "https://api.github.com/users/segevfiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/segevfiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segevfiner/subscriptions", "organizations_url": "https://api.github.com/users/segevfiner/orgs", "repos_url": "https://api.github.com/users/segevfiner/repos", "events_url": "https://api.github.com/users/segevfiner/events{/privacy}", "received_events_url": "https://api.github.com/users/segevfiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4186037aaa1a6aa3ba15a10130b424e7508bd276", "url": "https://api.github.com/repos/rust-lang/rust/commits/4186037aaa1a6aa3ba15a10130b424e7508bd276", "html_url": "https://github.com/rust-lang/rust/commit/4186037aaa1a6aa3ba15a10130b424e7508bd276"}], "stats": {"total": 174, "additions": 106, "deletions": 68}, "files": [{"sha": "62e9c24ac3045875afc4a75740b238e8e059a717", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -83,16 +83,19 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n-use io;\n-use fs;\n-\n pub use self::tracing::write;\n \n // tracing impls:\n mod tracing;\n // symbol resolvers:\n mod printing;\n \n-pub fn get_executable_filename() -> io::Result<(Vec<i8>, fs::File)> {\n-    Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\")))]\n+pub mod gnu {\n+    use io;\n+    use fs;\n+\n+    pub fn get_executable_filename() -> io::Result<(Vec<i8>, fs::File)> {\n+        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n+    }\n }"}, {"sha": "94aaf439f3d576bdb7fa53cc23752da69c34d65a", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -30,13 +30,9 @@ use io;\n use libc::c_void;\n use mem;\n use ptr;\n-use path::PathBuf;\n-use fs::{OpenOptions, File};\n-use sys::ext::fs::OpenOptionsExt;\n use sys::c;\n use sys::dynamic_lib::DynamicLibrary;\n use sys::mutex::Mutex;\n-use sys::handle::Handle;\n \n macro_rules! sym {\n     ($lib:expr, $e:expr, $t:ident) => (\n@@ -55,6 +51,10 @@ mod printing;\n #[path = \"printing/gnu.rs\"]\n mod printing;\n \n+#[cfg(target_env = \"gnu\")]\n+#[path = \"backtrace_gnu.rs\"]\n+pub mod gnu;\n+\n type SymInitializeFn =\n     unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n                               c::BOOL) -> c::BOOL;\n@@ -161,47 +161,3 @@ unsafe fn _write(w: &mut Write) -> io::Result<()> {\n \n     Ok(())\n }\n-\n-fn query_full_process_image_name() -> io::Result<PathBuf> {\n-    unsafe {\n-        let process_handle = Handle::new(c::OpenProcess(c::PROCESS_QUERY_INFORMATION,\n-                                                        c::FALSE,\n-                                                        c::GetCurrentProcessId()));\n-        super::fill_utf16_buf(|buf, mut sz| {\n-            if c::QueryFullProcessImageNameW(process_handle.raw(), 0, buf, &mut sz) == 0 {\n-                0\n-            } else {\n-                sz\n-            }\n-        }, super::os2path)\n-    }\n-}\n-\n-fn lock_and_get_executable_filename() -> io::Result<(PathBuf, File)> {\n-    // We query the current image name, open the file without FILE_SHARE_DELETE so it\n-    // can't be moved and then get the current image name again. If the names are the\n-    // same than we have successfully locked the file\n-    let image_name1 = query_full_process_image_name()?;\n-    let file = OpenOptions::new()\n-                .read(true)\n-                .share_mode(c::FILE_SHARE_READ | c::FILE_SHARE_WRITE)\n-                .open(&image_name1)?;\n-    let image_name2 = query_full_process_image_name()?;\n-\n-    if image_name1 != image_name2 {\n-        return Err(io::Error::new(io::ErrorKind::Other,\n-                                  \"executable moved while trying to lock it\"));\n-    }\n-\n-    Ok((image_name1, file))\n-}\n-\n-// Get the executable filename for libbacktrace\n-// This returns the path in the ANSI code page and a File which should remain open\n-// for as long as the path should remain valid\n-pub fn get_executable_filename() -> io::Result<(Vec<i8>, File)> {\n-    let (executable, file) = lock_and_get_executable_filename()?;\n-    let u16_executable = super::to_u16s(executable.into_os_string())?;\n-    Ok((super::wide_char_to_multi_byte(c::CP_ACP, c::WC_NO_BEST_FIT_CHARS,\n-                                       &u16_executable, true)?, file))\n-}"}, {"sha": "8282174a59efef29648c20d7b45b24d01c2d4122", "filename": "src/libstd/sys/windows/backtrace_gnu.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::c;\n+use path::PathBuf;\n+use fs::{OpenOptions, File};\n+use sys::ext::fs::OpenOptionsExt;\n+use sys::handle::Handle;\n+use super::super::{fill_utf16_buf, os2path, to_u16s, wide_char_to_multi_byte};\n+\n+fn query_full_process_image_name() -> io::Result<PathBuf> {\n+    unsafe {\n+        let process_handle = Handle::new(c::OpenProcess(c::PROCESS_QUERY_INFORMATION,\n+                                                        c::FALSE,\n+                                                        c::GetCurrentProcessId()));\n+        fill_utf16_buf(|buf, mut sz| {\n+            if c::QueryFullProcessImageNameW(process_handle.raw(), 0, buf, &mut sz) == 0 {\n+                0\n+            } else {\n+                sz\n+            }\n+        }, os2path)\n+    }\n+}\n+\n+fn lock_and_get_executable_filename() -> io::Result<(PathBuf, File)> {\n+    // We query the current image name, open the file without FILE_SHARE_DELETE so it\n+    // can't be moved and then get the current image name again. If the names are the\n+    // same than we have successfully locked the file\n+    let image_name1 = query_full_process_image_name()?;\n+    let file = OpenOptions::new()\n+                .read(true)\n+                .share_mode(c::FILE_SHARE_READ | c::FILE_SHARE_WRITE)\n+                .open(&image_name1)?;\n+    let image_name2 = query_full_process_image_name()?;\n+\n+    if image_name1 != image_name2 {\n+        return Err(io::Error::new(io::ErrorKind::Other,\n+                                  \"executable moved while trying to lock it\"));\n+    }\n+\n+    Ok((image_name1, file))\n+}\n+\n+// Get the executable filename for libbacktrace\n+// This returns the path in the ANSI code page and a File which should remain open\n+// for as long as the path should remain valid\n+pub fn get_executable_filename() -> io::Result<(Vec<i8>, File)> {\n+    let (executable, file) = lock_and_get_executable_filename()?;\n+    let u16_executable = to_u16s(executable.into_os_string())?;\n+    Ok((wide_char_to_multi_byte(c::CP_ACP, c::WC_NO_BEST_FIT_CHARS,\n+                                &u16_executable, true)?, file))\n+}"}, {"sha": "1b29bf73c7aec09794eff3830c87df9842c2c53c", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -158,7 +158,6 @@ pub const WSAECONNREFUSED: c_int = 10061;\n \n pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n \n-pub const PROCESS_QUERY_INFORMATION: DWORD = 0x0400;\n pub const TOKEN_READ: DWORD = 0x20008;\n pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n pub const FSCTL_GET_REPARSE_POINT: DWORD = 0x900a8;\n@@ -220,10 +219,6 @@ pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n pub const CREATE_UNICODE_ENVIRONMENT: DWORD = 0x00000400;\n pub const STARTF_USESTDHANDLES: DWORD = 0x00000100;\n \n-pub const CP_ACP: UINT = 0;\n-\n-pub const WC_NO_BEST_FIT_CHARS: DWORD = 0x00000400;\n-\n pub const AF_INET: c_int = 2;\n pub const AF_INET6: c_int = 23;\n pub const SD_BOTH: c_int = 2;\n@@ -894,9 +889,6 @@ extern \"system\" {\n                               pNumArgs: *mut c_int) -> *mut *mut u16;\n     pub fn GetTempPathW(nBufferLength: DWORD,\n                         lpBuffer: LPCWSTR) -> DWORD;\n-    pub fn OpenProcess(dwDesiredAccess: DWORD,\n-                       bInheritHandle: BOOL,\n-                       dwProcessId: DWORD) -> HANDLE;\n     pub fn OpenProcessToken(ProcessHandle: HANDLE,\n                             DesiredAccess: DWORD,\n                             TokenHandle: *mut HANDLE) -> BOOL;\n@@ -1153,12 +1145,6 @@ compat_fn! {\n                                      _dwFlags: DWORD) -> DWORD {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }\n-    pub fn QueryFullProcessImageNameW(_hProcess: HANDLE,\n-                                      _dwFlags: DWORD,\n-                                      _lpExeName: LPWSTR,\n-                                      _lpdwSize: LPDWORD) -> BOOL {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n     pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }\n@@ -1201,3 +1187,34 @@ compat_fn! {\n         panic!(\"rwlocks not available\")\n     }\n }\n+\n+#[cfg(target_env = \"gnu\")]\n+mod gnu {\n+    use super::*;\n+\n+    pub const PROCESS_QUERY_INFORMATION: DWORD = 0x0400;\n+\n+    pub const CP_ACP: UINT = 0;\n+\n+    pub const WC_NO_BEST_FIT_CHARS: DWORD = 0x00000400;\n+\n+    extern \"system\" {\n+        pub fn OpenProcess(dwDesiredAccess: DWORD,\n+                           bInheritHandle: BOOL,\n+                           dwProcessId: DWORD) -> HANDLE;\n+    }\n+\n+    compat_fn! {\n+        kernel32:\n+\n+        pub fn QueryFullProcessImageNameW(_hProcess: HANDLE,\n+                                          _dwFlags: DWORD,\n+                                          _lpExeName: LPWSTR,\n+                                          _lpdwSize: LPDWORD) -> BOOL {\n+            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+        }\n+    }\n+}\n+\n+#[cfg(target_env = \"gnu\")]\n+pub use self::gnu::*;"}, {"sha": "4424c6c6136c5ff94521be912b206bdb0ed482c0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -172,6 +172,7 @@ fn os2path(s: &[u16]) -> PathBuf {\n     PathBuf::from(OsString::from_wide(s))\n }\n \n+#[allow(dead_code)] // Only used in backtrace::gnu::get_executable_filename()\n fn wide_char_to_multi_byte(code_page: u32,\n                            flags: u32,\n                            s: &[u16],"}, {"sha": "d464a13ad1d3f67484d986c6976af6099347bcea", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450554ebf139d0b6ecde80f17c2ef89ff7de78bb/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=450554ebf139d0b6ecde80f17c2ef89ff7de78bb", "patch": "@@ -126,7 +126,7 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n         static mut STATE: *mut backtrace_state = ptr::null_mut();\n         if !STATE.is_null() { return STATE }\n \n-        let filename = match ::sys::backtrace::get_executable_filename() {\n+        let filename = match ::sys::backtrace::gnu::get_executable_filename() {\n             Ok((filename, file)) => {\n                 // filename is purposely leaked here since libbacktrace requires\n                 // it to stay allocated permanently, file is also leaked so that"}]}