{"sha": "d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "node_id": "C_kwDOAAsO6NoAKGQzZDIzNWRjYmZiZTc4MThlMTRjMmVjZmZkMDc0YjFjM2Q4YmQzN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T10:27:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T10:27:46Z"}, "message": "Auto merge of #10345 - J-ZhengLi:issue_10049, r=xFrednet\n\nfix [`needless_return`] incorrect suggestion when returning if sequence\n\nfixes: #10049\n\n---\n\nchangelog: [`needless_return`]: fix incorrect suggestion  on if sequence", "tree": {"sha": "fe763bc2d2b12cb0763e22d3434a3e2529d5a571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe763bc2d2b12cb0763e22d3434a3e2529d5a571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "html_url": "https://github.com/rust-lang/rust/commit/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e018a2c8bd8a9ae48b8a922e5eb4d4f565274ac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e018a2c8bd8a9ae48b8a922e5eb4d4f565274ac7", "html_url": "https://github.com/rust-lang/rust/commit/e018a2c8bd8a9ae48b8a922e5eb4d4f565274ac7"}, {"sha": "8b93eb8a9b31fcaadf22ea0fbacfcea4450a5894", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b93eb8a9b31fcaadf22ea0fbacfcea4450a5894", "html_url": "https://github.com/rust-lang/rust/commit/8b93eb8a9b31fcaadf22ea0fbacfcea4450a5894"}], "stats": {"total": 148, "additions": 102, "deletions": 46}, "files": [{"sha": "f0d7dd23a67860aac6435463120dc0dd6d75b422", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "patch": "@@ -14,6 +14,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_span::{BytePos, Pos};\n+use std::borrow::Cow;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -69,31 +70,41 @@ declare_clippy_lint! {\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n-enum RetReplacement {\n+#[derive(PartialEq, Eq, Clone)]\n+enum RetReplacement<'tcx> {\n     Empty,\n     Block,\n     Unit,\n+    IfSequence(Cow<'tcx, str>, Applicability),\n+    Expr(Cow<'tcx, str>, Applicability),\n }\n \n-impl RetReplacement {\n+impl<'tcx> RetReplacement<'tcx> {\n     fn sugg_help(self) -> &'static str {\n         match self {\n-            Self::Empty => \"remove `return`\",\n+            Self::Empty | Self::Expr(..) => \"remove `return`\",\n             Self::Block => \"replace `return` with an empty block\",\n             Self::Unit => \"replace `return` with a unit value\",\n+            Self::IfSequence(..) => \"remove `return` and wrap the sequence with parentheses\",\n+        }\n+    }\n+    fn applicability(&self) -> Option<Applicability> {\n+        match self {\n+            Self::Expr(_, ap) | Self::IfSequence(_, ap) => Some(*ap),\n+            _ => None,\n         }\n     }\n }\n \n-impl ToString for RetReplacement {\n+impl<'tcx> ToString for RetReplacement<'tcx> {\n     fn to_string(&self) -> String {\n-        match *self {\n-            Self::Empty => \"\",\n-            Self::Block => \"{}\",\n-            Self::Unit => \"()\",\n+        match self {\n+            Self::Empty => String::new(),\n+            Self::Block => \"{}\".to_string(),\n+            Self::Unit => \"()\".to_string(),\n+            Self::IfSequence(inner, _) => format!(\"({inner})\"),\n+            Self::Expr(inner, _) => inner.to_string(),\n         }\n-        .to_string()\n     }\n }\n \n@@ -204,34 +215,47 @@ fn check_final_expr<'tcx>(\n     expr: &'tcx Expr<'tcx>,\n     semi_spans: Vec<Span>, /* containing all the places where we would need to remove semicolons if finding an\n                             * needless return */\n-    replacement: RetReplacement,\n+    replacement: RetReplacement<'tcx>,\n ) {\n     let peeled_drop_expr = expr.peel_drop_temps();\n     match &peeled_drop_expr.kind {\n         // simple return is always \"bad\"\n         ExprKind::Ret(ref inner) => {\n-            // if desugar of `do yeet`, don't lint\n-            if let Some(inner_expr) = inner\n-                && let ExprKind::Call(path_expr, _) = inner_expr.kind\n-                && let ExprKind::Path(QPath::LangItem(LangItem::TryTraitFromYeet, _, _)) = path_expr.kind\n-            {\n-                return;\n-            }\n+            // check if expr return nothing\n+            let ret_span = if inner.is_none() && replacement == RetReplacement::Empty {\n+                extend_span_to_previous_non_ws(cx, peeled_drop_expr.span)\n+            } else {\n+                peeled_drop_expr.span\n+            };\n+\n+            let replacement = if let Some(inner_expr) = inner {\n+                // if desugar of `do yeet`, don't lint\n+                if let ExprKind::Call(path_expr, _) = inner_expr.kind\n+                    && let ExprKind::Path(QPath::LangItem(LangItem::TryTraitFromYeet, _, _)) = path_expr.kind\n+                {\n+                    return;\n+                }\n+\n+                let mut applicability = Applicability::MachineApplicable;\n+                let (snippet, _) = snippet_with_context(cx, inner_expr.span, ret_span.ctxt(), \"..\", &mut applicability);\n+                if expr_contains_conjunctive_ifs(inner_expr) {\n+                    RetReplacement::IfSequence(snippet, applicability)\n+                } else {\n+                    RetReplacement::Expr(snippet, applicability)\n+                }\n+            } else {\n+                replacement\n+            };\n+\n             if !cx.tcx.hir().attrs(expr.hir_id).is_empty() {\n                 return;\n             }\n             let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n             if borrows {\n                 return;\n             }\n-            // check if expr return nothing\n-            let ret_span = if inner.is_none() && replacement == RetReplacement::Empty {\n-                extend_span_to_previous_non_ws(cx, peeled_drop_expr.span)\n-            } else {\n-                peeled_drop_expr.span\n-            };\n \n-            emit_return_lint(cx, ret_span, semi_spans, inner.as_ref().map(|i| i.span), replacement);\n+            emit_return_lint(cx, ret_span, semi_spans, replacement);\n         },\n         ExprKind::If(_, then, else_clause_opt) => {\n             check_block_return(cx, &then.kind, peeled_drop_expr.span, semi_spans.clone());\n@@ -253,29 +277,25 @@ fn check_final_expr<'tcx>(\n     }\n }\n \n-fn emit_return_lint(\n-    cx: &LateContext<'_>,\n-    ret_span: Span,\n-    semi_spans: Vec<Span>,\n-    inner_span: Option<Span>,\n-    replacement: RetReplacement,\n-) {\n+fn expr_contains_conjunctive_ifs<'tcx>(expr: &'tcx Expr<'tcx>) -> bool {\n+    fn contains_if(expr: &Expr<'_>, on_if: bool) -> bool {\n+        match expr.kind {\n+            ExprKind::If(..) => on_if,\n+            ExprKind::Binary(_, left, right) => contains_if(left, true) || contains_if(right, true),\n+            _ => false,\n+        }\n+    }\n+\n+    contains_if(expr, false)\n+}\n+\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, semi_spans: Vec<Span>, replacement: RetReplacement<'_>) {\n     if ret_span.from_expansion() {\n         return;\n     }\n-    let mut applicability = Applicability::MachineApplicable;\n-    let return_replacement = inner_span.map_or_else(\n-        || replacement.to_string(),\n-        |inner_span| {\n-            let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n-            snippet.to_string()\n-        },\n-    );\n-    let sugg_help = if inner_span.is_some() {\n-        \"remove `return`\"\n-    } else {\n-        replacement.sugg_help()\n-    };\n+    let applicability = replacement.applicability().unwrap_or(Applicability::MachineApplicable);\n+    let return_replacement = replacement.to_string();\n+    let sugg_help = replacement.sugg_help();\n     span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n         diag.span_suggestion_hidden(ret_span, sugg_help, return_replacement, applicability);\n         // for each parent statement, we need to remove the semicolon"}, {"sha": "0f525dd294c9b6e2b8abb3e847836a7f6861f875", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "patch": "@@ -297,4 +297,14 @@ fn issue10051() -> Result<String, String> {\n     }\n }\n \n+mod issue10049 {\n+    fn single() -> u32 {\n+        if true { 1 } else { 2 }\n+    }\n+\n+    fn multiple(b1: bool, b2: bool, b3: bool) -> u32 {\n+        (if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 })\n+    }\n+}\n+\n fn main() {}"}, {"sha": "a1db8375d95b9ac0480f407053f298bd4beca105", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "patch": "@@ -307,4 +307,14 @@ fn issue10051() -> Result<String, String> {\n     }\n }\n \n+mod issue10049 {\n+    fn single() -> u32 {\n+        return if true { 1 } else { 2 };\n+    }\n+\n+    fn multiple(b1: bool, b2: bool, b3: bool) -> u32 {\n+        return if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "87d0cd3e14cfabb315e5ebe2c528d6bc73f5cfa6", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=d3d235dcbfbe7818e14c2ecffd074b1c3d8bd37f", "patch": "@@ -418,5 +418,21 @@ LL |         return Err(format!(\"err!\"));\n    |\n    = help: remove `return`\n \n-error: aborting due to 50 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:312:9\n+   |\n+LL |         return if true { 1 } else { 2 };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: remove `return`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:316:9\n+   |\n+LL |         return if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: remove `return` and wrap the sequence with parentheses\n+\n+error: aborting due to 52 previous errors\n "}]}