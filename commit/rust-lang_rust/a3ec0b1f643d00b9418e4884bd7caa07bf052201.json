{"sha": "a3ec0b1f643d00b9418e4884bd7caa07bf052201", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZWMwYjFmNjQzZDAwYjk0MThlNDg4NGJkN2NhYTA3YmYwNTIyMDE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-06T20:13:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-06T20:51:19Z"}, "message": "Rename std modules to be camelcased\n\n(Have fun mergining your stuff with this.)", "tree": {"sha": "82000510ac9c9cf3f0c7cf4ae5f3c6b123b559cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82000510ac9c9cf3f0c7cf4ae5f3c6b123b559cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ec0b1f643d00b9418e4884bd7caa07bf052201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ec0b1f643d00b9418e4884bd7caa07bf052201", "html_url": "https://github.com/rust-lang/rust/commit/a3ec0b1f643d00b9418e4884bd7caa07bf052201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ec0b1f643d00b9418e4884bd7caa07bf052201/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44c1621525cc9d4f7ff68e832493394d8ae565e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/44c1621525cc9d4f7ff68e832493394d8ae565e9", "html_url": "https://github.com/rust-lang/rust/commit/44c1621525cc9d4f7ff68e832493394d8ae565e9"}], "stats": {"total": 4301, "additions": 2150, "deletions": 2151}, "files": [{"sha": "695d3202ff28e38e7634db03f737ee2142f2a760", "filename": "src/comp/back/Link.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fback%2FLink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fback%2FLink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2FLink.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n import driver.session;\n import lib.llvm.llvm;\n import middle.trans;\n-import std._str;\n-import std.fs;\n+import std.Str;\n+import std.FS;\n \n import lib.llvm.llvm.ModuleRef;\n import lib.llvm.llvm.ValueRef;\n@@ -19,14 +19,14 @@ tag output_type {\n }\n \n fn llvm_err(session.session sess, str msg) {\n-    sess.err(msg + \": \" + _str.str_from_cstr(llvm.LLVMRustGetLastError()));\n+    sess.err(msg + \": \" + Str.str_from_cstr(llvm.LLVMRustGetLastError()));\n     fail;\n }\n \n fn link_intrinsics(session.session sess, ModuleRef llmod) {\n-    auto path = fs.connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n+    auto path = FS.connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n     auto membuf =\n-        llvm.LLVMRustCreateMemoryBufferWithContentsOfFile(_str.buf(path));\n+        llvm.LLVMRustCreateMemoryBufferWithContentsOfFile(Str.buf(path));\n     if ((membuf as uint) == 0u) {\n         llvm_err(sess, \"installation problem: couldn't open intrinstics.bc\");\n         fail;\n@@ -58,12 +58,12 @@ mod Write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(str output_path, str extension) -> str {\n-        auto dot_pos = _str.index(output_path, '.' as u8);\n+        auto dot_pos = Str.index(output_path, '.' as u8);\n         auto stem;\n         if (dot_pos < 0) {\n             stem = output_path;\n         } else {\n-            stem = _str.substr(output_path, 0u, dot_pos as uint);\n+            stem = Str.substr(output_path, 0u, dot_pos as uint);\n         }\n         ret stem + \".\" + extension;\n     }\n@@ -86,12 +86,12 @@ mod Write {\n                         auto filename = mk_intermediate_name(output,\n                                                              \"no-opt.bc\");\n                         llvm.LLVMWriteBitcodeToFile(llmod,\n-                                                    _str.buf(filename));\n+                                                    Str.buf(filename));\n                     }\n                 }\n                 case (_) {\n                     auto filename = mk_intermediate_name(output, \"bc\");\n-                    llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(filename));\n+                    llvm.LLVMWriteBitcodeToFile(llmod, Str.buf(filename));\n                 }\n             }\n         }\n@@ -183,23 +183,23 @@ mod Write {\n                                                              \"opt.bc\");\n                         llvm.LLVMRunPassManager(pm.llpm, llmod);\n                         llvm.LLVMWriteBitcodeToFile(llmod,\n-                                                    _str.buf(filename));\n+                                                    Str.buf(filename));\n                         pm = mk_pass_manager();\n                     }\n                 }\n             }\n \n             llvm.LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                         _str.buf(x86.get_target_triple()),\n-                                         _str.buf(output),\n+                                         Str.buf(x86.get_target_triple()),\n+                                         Str.buf(output),\n                                          FileType);\n             llvm.LLVMDisposeModule(llmod);\n             ret;\n         }\n \n         llvm.LLVMRunPassManager(pm.llpm, llmod);\n \n-        llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(output));\n+        llvm.LLVMWriteBitcodeToFile(llmod, Str.buf(output));\n         llvm.LLVMDisposeModule(llmod);\n     }\n }"}, {"sha": "bad4eb3ec8e1a9cffacd4071ee002989f70413ff", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n import lib.llvm.llvm;\n import lib.llvm.llvm.ModuleRef;\n-import std._str;\n-import std._vec;\n-import std.os.target_os;\n+import std.Str;\n+import std.Vec;\n+import std.OS.target_os;\n import util.common.istr;\n \n const int wordsz = 4;\n@@ -241,7 +241,7 @@ fn native_glue(int n_args, abi.native_glue_type ngt) -> vec[str] {\n         }\n         auto m = vec(\"movl  \" + src_off + \"(%ebp),%eax\",\n                      \"movl  %eax,\" + dst_off + \"(%esp)\");\n-        ret _str.connect(m, \"\\n\\t\");\n+        ret Str.connect(m, \"\\n\\t\");\n     }\n \n     auto carg = bind copy_arg(pass_task, _);\n@@ -259,7 +259,7 @@ fn native_glue(int n_args, abi.native_glue_type ngt) -> vec[str] {\n         + vec(\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n               \"andl  $~0xf, %esp    # align esp down\")\n \n-        + _vec.init_fn[str](carg, (n_args) as uint)\n+        + Vec.init_fn[str](carg, (n_args) as uint)\n \n         +  vec(\"movl  %edx, %edi     # save task from edx to edi\",\n                \"call  *%ecx          # call *%ecx\",\n@@ -278,7 +278,7 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n     ret \"\\t.globl \" + sym + \"\\n\" +\n         \"\\t.balign \" + istr(align) + \"\\n\" +\n         sym + \":\\n\" +\n-        \"\\t\" + _str.connect(insns, \"\\n\\t\");\n+        \"\\t\" + Str.connect(insns, \"\\n\\t\");\n }\n \n \n@@ -291,8 +291,8 @@ fn decl_native_glue(int align, str prefix, abi.native_glue_type ngt, uint n)\n }\n \n fn get_symbol_prefix() -> str {\n-    if (_str.eq(target_os(), \"macos\") ||\n-        _str.eq(target_os(), \"win32\")) {\n+    if (Str.eq(target_os(), \"macos\") ||\n+        Str.eq(target_os(), \"win32\")) {\n         ret \"_\";\n     } else {\n         ret \"\";\n@@ -313,44 +313,44 @@ fn get_module_asm() -> str {\n                       abi.yield_glue_name(),\n                       rust_yield_glue()))\n \n-        + _vec.init_fn[str](bind decl_native_glue(align, prefix,\n+        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n             abi.ngt_rust, _), (abi.n_native_glues + 1) as uint)\n-        + _vec.init_fn[str](bind decl_native_glue(align, prefix,\n+        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n             abi.ngt_pure_rust, _), (abi.n_native_glues + 1) as uint)\n-        + _vec.init_fn[str](bind decl_native_glue(align, prefix,\n+        + Vec.init_fn[str](bind decl_native_glue(align, prefix,\n             abi.ngt_cdecl, _), (abi.n_native_glues + 1) as uint);\n \n \n-    ret _str.connect(glues, \"\\n\\n\");\n+    ret Str.connect(glues, \"\\n\\n\");\n }\n \n fn get_meta_sect_name() -> str {\n-    if (_str.eq(target_os(), \"macos\")) {\n+    if (Str.eq(target_os(), \"macos\")) {\n         ret \"__DATA,__note.rustc\";\n     }\n-    if (_str.eq(target_os(), \"win32\")) {\n+    if (Str.eq(target_os(), \"win32\")) {\n         ret \".note.rustc\";\n     }\n     ret \".note.rustc\";\n }\n \n fn get_data_layout() -> str {\n-    if (_str.eq(target_os(), \"macos\")) {\n+    if (Str.eq(target_os(), \"macos\")) {\n       ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64\" +\n         \"-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128\" +\n         \"-n8:16:32\";\n     }\n-    if (_str.eq(target_os(), \"win32\")) {\n+    if (Str.eq(target_os(), \"win32\")) {\n       ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> str {\n-    if (_str.eq(target_os(), \"macos\")) {\n+    if (Str.eq(target_os(), \"macos\")) {\n         ret \"i686-apple-darwin\";\n     }\n-    if (_str.eq(target_os(), \"win32\")) {\n+    if (Str.eq(target_os(), \"win32\")) {\n         ret \"i686-pc-mingw32\";\n     }\n     ret \"i686-unknown-linux-gnu\";"}, {"sha": "cb8b676d51789664512bcb410909583215fa53bc", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -15,14 +15,14 @@ import back.Link;\n import lib.llvm;\n import util.common;\n \n-import std.fs;\n-import std.map.mk_hashmap;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n-import std._str;\n-import std._vec;\n-import std.io;\n+import std.FS;\n+import std.Map.mk_hashmap;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Str;\n+import std.Vec;\n+import std.IO;\n import std.Time;\n \n import std.GetOpts;\n@@ -47,7 +47,7 @@ fn default_environment(session.session sess,\n     ret\n         vec(\n             // Target bindings.\n-            tup(\"target_os\", eval.val_str(std.os.target_os())),\n+            tup(\"target_os\", eval.val_str(std.OS.target_os())),\n             tup(\"target_arch\", eval.val_str(\"x86\")),\n             tup(\"target_libc\", eval.val_str(libc)),\n \n@@ -60,9 +60,9 @@ fn default_environment(session.session sess,\n fn parse_input(session.session sess,\n                       parser.parser p,\n                       str input) -> @ast.crate {\n-    if (_str.ends_with(input, \".rc\")) {\n+    if (Str.ends_with(input, \".rc\")) {\n         ret parser.parse_crate_from_crate_file(p);\n-    } else if (_str.ends_with(input, \".rs\")) {\n+    } else if (Str.ends_with(input, \".rs\")) {\n         ret parser.parse_crate_from_source_file(p);\n     }\n     sess.err(\"unknown input file type: \" + input);\n@@ -123,20 +123,20 @@ fn pretty_print_input(session.session sess,\n     auto def = tup(0, 0);\n     auto p = front.parser.new_parser(sess, env, def, input, 0u);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_file(crate.node.module, input, std.io.stdout());\n+    pretty.pprust.print_file(crate.node.module, input, std.IO.stdout());\n }\n \n fn version(str argv0) {\n     auto vers = \"unknown version\";\n     auto env_vers = #env(\"CFG_VERSION\");\n-    if (_str.byte_len(env_vers) != 0u) {\n+    if (Str.byte_len(env_vers) != 0u) {\n         vers = env_vers;\n     }\n-    io.stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n+    IO.stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n }\n \n fn usage(str argv0) {\n-    io.stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n+    IO.stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n options:\n \n     -h --help          display this message\n@@ -162,38 +162,38 @@ options:\n }\n \n fn get_os(str triple) -> session.os {\n-    if (_str.find(triple, \"win32\") > 0 ||\n-        _str.find(triple, \"mingw32\") > 0 ) {\n+    if (Str.find(triple, \"win32\") > 0 ||\n+        Str.find(triple, \"mingw32\") > 0 ) {\n         ret session.os_win32;\n-    } else if (_str.find(triple, \"darwin\") > 0) { ret session.os_macos; }\n-    else if (_str.find(triple, \"linux\") > 0) { ret session.os_linux; }\n+    } else if (Str.find(triple, \"darwin\") > 0) { ret session.os_macos; }\n+    else if (Str.find(triple, \"linux\") > 0) { ret session.os_linux; }\n }\n \n fn get_arch(str triple) -> session.arch {\n-    if (_str.find(triple, \"i386\") > 0 ||\n-        _str.find(triple, \"i486\") > 0 ||\n-        _str.find(triple, \"i586\") > 0 ||\n-        _str.find(triple, \"i686\") > 0 ||\n-        _str.find(triple, \"i786\") > 0 ) {\n+    if (Str.find(triple, \"i386\") > 0 ||\n+        Str.find(triple, \"i486\") > 0 ||\n+        Str.find(triple, \"i586\") > 0 ||\n+        Str.find(triple, \"i686\") > 0 ||\n+        Str.find(triple, \"i786\") > 0 ) {\n         ret session.arch_x86;\n-    } else if (_str.find(triple, \"x86_64\") > 0) {\n+    } else if (Str.find(triple, \"x86_64\") > 0) {\n         ret session.arch_x64;\n-    } else if (_str.find(triple, \"arm\") > 0 ||\n-        _str.find(triple, \"xscale\") > 0 ) {\n+    } else if (Str.find(triple, \"arm\") > 0 ||\n+        Str.find(triple, \"xscale\") > 0 ) {\n         ret session.arch_arm;\n     }\n }\n \n fn get_default_sysroot(str binary) -> str {\n-    auto dirname = fs.dirname(binary);\n-    if (_str.eq(dirname, binary)) { ret \".\"; }\n+    auto dirname = FS.dirname(binary);\n+    if (Str.eq(dirname, binary)) { ret \".\"; }\n     ret dirname;\n }\n \n fn main(vec[str] args) {\n \n     let str triple =\n-        std._str.rustrt.str_from_cstr(llvm.llvm.LLVMRustGetHostTriple());\n+        std.Str.rustrt.str_from_cstr(llvm.llvm.LLVMRustGetHostTriple());\n \n     let @session.config target_cfg =\n         @rec(os = get_os(triple),\n@@ -211,7 +211,7 @@ fn main(vec[str] args) {\n                     optflag(\"save-temps\"), optopt(\"sysroot\"),\n                     optflag(\"time-passes\"), optflag(\"no-typestate\"),\n                     optflag(\"noverify\"));\n-    auto binary = _vec.shift[str](args);\n+    auto binary = Vec.shift[str](args);\n     auto match;\n     alt (GetOpts.getopts(args, opts)) {\n         case (GetOpts.failure(?f)) {\n@@ -282,13 +282,13 @@ fn main(vec[str] args) {\n         session.session(target_crate_num, target_cfg, sopts,\n                         crate_cache, md, front.codemap.new_codemap());\n \n-    auto n_inputs = _vec.len[str](match.free);\n+    auto n_inputs = Vec.len[str](match.free);\n \n     if (glue) {\n         if (n_inputs > 0u) {\n             sess.err(\"No input files allowed with --glue.\");\n         }\n-        auto out = option.from_maybe[str](\"glue.bc\", output_file);\n+        auto out = Option.from_maybe[str](\"glue.bc\", output_file);\n         middle.trans.make_common_glue(sess, out);\n         ret;\n     }\n@@ -304,19 +304,19 @@ fn main(vec[str] args) {\n     if (pretty) {\n         pretty_print_input(sess, env, ifile);\n     } else if (ls) {\n-        front.creader.list_file_metadata(ifile, std.io.stdout());\n+        front.creader.list_file_metadata(ifile, std.IO.stdout());\n     } else {\n         alt (output_file) {\n             case (none[str]) {\n-                let vec[str] parts = _str.split(ifile, '.' as u8);\n-                _vec.pop[str](parts);\n+                let vec[str] parts = Str.split(ifile, '.' as u8);\n+                Vec.pop[str](parts);\n                 alt (output_type) {\n                     case (Link.output_type_none) { parts += vec(\"pp\"); }\n                     case (Link.output_type_bitcode) { parts += vec(\"bc\"); }\n                     case (Link.output_type_assembly) { parts += vec(\"s\"); }\n                     case (Link.output_type_object) { parts += vec(\"o\"); }\n                 }\n-                auto ofile = _str.connect(parts, \".\");\n+                auto ofile = Str.connect(parts, \".\");\n                 compile_input(sess, env, ifile, ofile);\n             }\n             case (some[str](?ofile)) {"}, {"sha": "644846d06b14b41848eb3ca91760bbc970597959", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,10 +2,10 @@ import front.ast;\n import front.codemap;\n import util.common.span;\n import util.common.ty_mach;\n-import std._uint;\n+import std.UInt;\n import std.Term;\n-import std.io;\n-import std.map;\n+import std.IO;\n+import std.Map;\n \n tag os {\n     os_win32;\n@@ -42,25 +42,25 @@ type crate_metadata = rec(str name,\n fn emit_diagnostic(span sp, str msg, str kind, u8 color, codemap.codemap cm) {\n     auto lo = codemap.lookup_pos(cm, sp.lo);\n     auto hi = codemap.lookup_pos(cm, sp.hi);\n-    io.stdout().write_str(#fmt(\"%s:%u:%u:%u:%u: \", lo.filename, lo.line,\n+    IO.stdout().write_str(#fmt(\"%s:%u:%u:%u:%u: \", lo.filename, lo.line,\n                                lo.col, hi.line, hi.col));\n \n     if (Term.color_supported()) {\n-        Term.fg(io.stdout().get_buf_writer(), color);\n+        Term.fg(IO.stdout().get_buf_writer(), color);\n     }\n \n-    io.stdout().write_str(#fmt(\"%s:\", kind));\n+    IO.stdout().write_str(#fmt(\"%s:\", kind));\n \n     if (Term.color_supported()) {\n-        Term.reset(io.stdout().get_buf_writer());\n+        Term.reset(IO.stdout().get_buf_writer());\n     }\n \n-    io.stdout().write_str(#fmt(\" %s\\n\", msg));\n+    IO.stdout().write_str(#fmt(\" %s\\n\", msg));\n }\n \n state obj session(ast.crate_num cnum,\n                   @config targ_cfg, @options opts,\n-                  map.hashmap[int, crate_metadata] crates,\n+                  Map.hashmap[int, crate_metadata] crates,\n                   mutable vec[@ast.meta_item] metadata,\n                   codemap.codemap cm) {\n "}, {"sha": "0e15c964aa6b10a5aea49e804290d42d45030086", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n \n-import std.map.hashmap;\n-import std.option;\n-import std._str;\n-import std._vec;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Str;\n+import std.Vec;\n import util.common.span;\n import util.common.spanned;\n import util.common.ty_mach;\n@@ -24,8 +24,8 @@ type ty_param = ident;\n tag ann {\n     ann_none;\n     ann_type(middle.ty.t,\n-             option.t[vec[middle.ty.t]], /* ty param substs */\n-             option.t[@ts_ann]); /* pre- and postcondition for typestate */\n+             Option.t[vec[middle.ty.t]], /* ty param substs */\n+             Option.t[@ts_ann]); /* pre- and postcondition for typestate */\n }\n \n tag def {\n@@ -79,8 +79,8 @@ tag crate_directive_ {\n     // and redirected to the use of const stmt_decls inside\n     // crate directive blocks.\n     cdir_let(ident, @expr, vec[@crate_directive]);\n-    cdir_src_mod(ident, option.t[filename]);\n-    cdir_dir_mod(ident, option.t[filename], vec[@crate_directive]);\n+    cdir_src_mod(ident, Option.t[filename]);\n+    cdir_dir_mod(ident, Option.t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n     cdir_meta(vec[@meta_item]);\n     cdir_syntax(path);\n@@ -100,7 +100,7 @@ tag block_index_entry {\n     bie_tag_variant(@item /* tag item */, uint /* variant index */);\n }\n type block_ = rec(vec[@stmt] stmts,\n-                  option.t[@expr] expr,\n+                  Option.t[@expr] expr,\n                   hashmap[ident,block_index_entry] index,\n                   ann a); /* ann is only meaningful for the ts_ann field */\n \n@@ -111,7 +111,7 @@ tag pat_ {\n     pat_wild(ann);\n     pat_bind(ident, def_id, ann);\n     pat_lit(@lit, ann);\n-    pat_tag(path, vec[@pat], option.t[variant_def], ann);\n+    pat_tag(path, vec[@pat], Option.t[variant_def], ann);\n }\n \n tag mutability {\n@@ -226,10 +226,10 @@ tag init_op {\n type initializer = rec(init_op op,\n                        @expr expr);\n \n-type local = rec(option.t[@ty] ty,\n+type local = rec(Option.t[@ty] ty,\n                  bool infer,\n                  ident ident,\n-                 option.t[initializer] init,\n+                 Option.t[initializer] init,\n                  def_id id,\n                  ann ann);\n \n@@ -253,16 +253,16 @@ type expr = spanned[expr_];\n tag expr_ {\n     expr_vec(vec[@expr], mutability, ann);\n     expr_tup(vec[elt], ann);\n-    expr_rec(vec[field], option.t[@expr], ann);\n+    expr_rec(vec[field], Option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n     expr_self_method(ident, ann);\n-    expr_bind(@expr, vec[option.t[@expr]], ann);\n-    expr_spawn(spawn_dom, option.t[str], @expr, vec[@expr], ann);\n+    expr_bind(@expr, vec[Option.t[@expr]], ann);\n+    expr_spawn(spawn_dom, Option.t[str], @expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);\n     expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, option.t[@expr], ann);\n+    expr_if(@expr, block, Option.t[@expr], ann);\n     expr_while(@expr, block, ann);\n     expr_for(@decl, @expr, block, ann);\n     expr_for_each(@decl, @expr, block, ann);\n@@ -275,13 +275,13 @@ tag expr_ {\n     expr_recv(@expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n-    expr_path(path, option.t[def], ann);\n-    expr_ext(path, vec[@expr], option.t[str], @expr, ann);\n+    expr_path(path, Option.t[def], ann);\n+    expr_ext(path, vec[@expr], Option.t[str], @expr, ann);\n     expr_fail(ann);\n     expr_break(ann);\n     expr_cont(ann);\n-    expr_ret(option.t[@expr], ann);\n-    expr_put(option.t[@expr], ann);\n+    expr_ret(Option.t[@expr], ann);\n+    expr_put(Option.t[@expr], ann);\n     expr_be(@expr, ann);\n     expr_log(int, @expr, ann);\n /* just an assert, no significance to typestate */\n@@ -331,7 +331,7 @@ tag ty_ {\n     ty_rec(vec[ty_field]);\n     ty_fn(proto, vec[ty_arg], @ty);\n     ty_obj(vec[ty_method]);\n-    ty_path(path, option.t[def]);\n+    ty_path(path, Option.t[def]);\n     ty_type;\n     ty_constr(@ty, vec[@constr]);\n }\n@@ -364,7 +364,7 @@ type method = spanned[method_];\n type obj_field = rec(@ty ty, ident ident, def_id id, ann ann);\n type _obj = rec(vec[obj_field] fields,\n                 vec[@method] methods,\n-                option.t[@method] dtor);\n+                Option.t[@method] dtor);\n \n tag mod_index_entry {\n     mie_view_item(@view_item);\n@@ -402,8 +402,8 @@ type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n tag view_item_ {\n-    view_item_use(ident, vec[@meta_item], def_id, option.t[int]);\n-    view_item_import(ident, vec[ident], def_id, option.t[def]);\n+    view_item_use(ident, vec[@meta_item], def_id, Option.t[int]);\n+    view_item_import(ident, vec[ident], def_id, Option.t[def]);\n     view_item_export(ident);\n }\n \n@@ -423,7 +423,7 @@ tag item_ {\n type native_item = spanned[native_item_];\n tag native_item_ {\n     native_item_ty(ident, def_id);\n-    native_item_fn(ident, option.t[str],\n+    native_item_fn(ident, Option.t[str],\n                    fn_decl, vec[ty_param], def_id, ann);\n }\n \n@@ -542,7 +542,7 @@ fn is_exported(ident i, _mod m) -> bool {\n     for (@ast.view_item vi in m.view_items) {\n         alt (vi.node) {\n             case (ast.view_item_export(?id)) {\n-                if (_str.eq(i, id)) {\n+                if (Str.eq(i, id)) {\n                     ret true;\n                 }\n                 count += 1;\n@@ -574,7 +574,7 @@ fn is_constraint_arg(@expr e) -> bool {\n         case (expr_lit(_,_)) {\n             ret true;\n         }\n-        case (expr_path(_, option.some[def](def_local(_)), _)) {\n+        case (expr_path(_, Option.some[def](def_local(_)), _)) {\n             ret true;\n         }\n         case (_) {"}, {"sha": "578f574b2f2102ded8a898123306dbab138344d1", "filename": "src/comp/front/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,4 +1,4 @@\n-import std._vec;\n+import std.Vec;\n \n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n@@ -24,18 +24,18 @@ fn new_filemap(str filename, uint start_pos) -> filemap {\n }\n \n fn next_line(filemap file, uint pos) {\n-    _vec.push[uint](file.lines, pos);\n+    Vec.push[uint](file.lines, pos);\n }\n \n fn lookup_pos(codemap map, uint pos) -> loc {\n-    auto a = 0u; auto b = _vec.len[filemap](map.files);\n+    auto a = 0u; auto b = Vec.len[filemap](map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (map.files.(m).start_pos > pos) { b = m; }\n         else { a = m; }\n     }\n     auto f = map.files.(a);\n-    a = 0u; b = _vec.len[uint](f.lines);\n+    a = 0u; b = Vec.len[uint](f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (f.lines.(m) > pos) { b = m; }"}, {"sha": "d5067b2518b6be5addb16b9dd23f4cf85ae2d6ee", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -14,17 +14,17 @@ import back.x86;\n import util.common;\n import util.common.span;\n \n-import std._str;\n-import std._uint;\n-import std._vec;\n-import std.ebml;\n-import std.fs;\n-import std.io;\n-import std.option;\n-import std.option.none;\n-import std.option.some;\n-import std.os;\n-import std.map.hashmap;\n+import std.Str;\n+import std.UInt;\n+import std.Vec;\n+import std.EBML;\n+import std.FS;\n+import std.IO;\n+import std.Option;\n+import std.Option.none;\n+import std.Option.some;\n+import std.OS;\n+import std.Map.hashmap;\n \n // TODO: map to a real type here.\n type env = @rec(\n@@ -122,7 +122,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n                 while (peek(st) as char != '=') {\n-                    name += _str.unsafe_from_byte(next(st));\n+                    name += Str.unsafe_from_byte(next(st));\n                 }\n                 st.pos = st.pos + 1u;\n                 fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n@@ -160,7 +160,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                 }\n                 auto name = \"\";\n                 while (peek(st) as char != '[') {\n-                    name += _str.unsafe_from_byte(next(st));\n+                    name += Str.unsafe_from_byte(next(st));\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods += vec(rec(proto=proto,\n@@ -210,7 +210,7 @@ fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n     auto def = \"\";\n     while (peek(st) as char != '|') {\n-        def += _str.unsafe_from_byte(next(st));\n+        def += Str.unsafe_from_byte(next(st));\n     }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n@@ -265,7 +265,7 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n \n fn parse_def_id(vec[u8] buf) -> ast.def_id {\n     auto colon_idx = 0u;\n-    auto len = _vec.len[u8](buf);\n+    auto len = Vec.len[u8](buf);\n     while (colon_idx < len && buf.(colon_idx) != (':' as u8)) {\n         colon_idx += 1u;\n     }\n@@ -274,30 +274,30 @@ fn parse_def_id(vec[u8] buf) -> ast.def_id {\n         fail;\n     }\n \n-    auto crate_part = _vec.slice[u8](buf, 0u, colon_idx);\n-    auto def_part = _vec.slice[u8](buf, colon_idx + 1u, len);\n-    auto crate_num = _uint.parse_buf(crate_part, 10u) as int;\n-    auto def_num = _uint.parse_buf(def_part, 10u) as int;\n+    auto crate_part = Vec.slice[u8](buf, 0u, colon_idx);\n+    auto def_part = Vec.slice[u8](buf, colon_idx + 1u, len);\n+    auto crate_num = UInt.parse_buf(crate_part, 10u) as int;\n+    auto def_num = UInt.parse_buf(def_part, 10u) as int;\n     ret tup(crate_num, def_num);\n }\n \n-fn lookup_hash(&ebml.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n-    -> option.t[ebml.doc] {\n-    auto index = ebml.get_doc(d, metadata.tag_index);\n-    auto table = ebml.get_doc(index, metadata.tag_index_table);\n+fn lookup_hash(&EBML.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n+    -> Option.t[EBML.doc] {\n+    auto index = EBML.get_doc(d, metadata.tag_index);\n+    auto table = EBML.get_doc(index, metadata.tag_index_table);\n \n     auto hash_pos = table.start + (hash % 256u) * 4u;\n-    auto pos = ebml.be_uint_from_bytes(d.data, hash_pos, 4u);\n-    auto bucket = ebml.doc_at(d.data, pos);\n+    auto pos = EBML.be_uint_from_bytes(d.data, hash_pos, 4u);\n+    auto bucket = EBML.doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n-    auto result = option.none[ebml.doc];\n+    auto result = Option.none[EBML.doc];\n     auto belt = metadata.tag_index_buckets_bucket_elt;\n-    for each (ebml.doc elt in ebml.tagged_docs(bucket, belt)) {\n+    for each (EBML.doc elt in EBML.tagged_docs(bucket, belt)) {\n         alt (result) {\n-            case (option.none[ebml.doc]) {\n-                auto pos = ebml.be_uint_from_bytes(elt.data, elt.start, 4u);\n-                if (eq_fn(_vec.slice[u8](elt.data, elt.start+4u, elt.end))) {\n-                    result = option.some[ebml.doc](ebml.doc_at(d.data, pos));\n+            case (Option.none[EBML.doc]) {\n+                auto pos = EBML.be_uint_from_bytes(elt.data, elt.start, 4u);\n+                if (eq_fn(Vec.slice[u8](elt.data, elt.start+4u, elt.end))) {\n+                    result = Option.some[EBML.doc](EBML.doc_at(d.data, pos));\n                 }\n             }\n             case (_) {}\n@@ -310,113 +310,113 @@ fn lookup_hash(&ebml.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n // definition the path refers to.\n fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n     fn eq_item(vec[u8] data, str s) -> bool {\n-        ret _str.eq(_str.unsafe_from_bytes(data), s);\n+        ret Str.eq(Str.unsafe_from_bytes(data), s);\n     }\n-    auto s = _str.connect(path, \".\");\n-    auto md = ebml.new_doc(data);\n-    auto paths = ebml.get_doc(md, metadata.tag_paths);\n+    auto s = Str.connect(path, \".\");\n+    auto md = EBML.new_doc(data);\n+    auto paths = EBML.get_doc(md, metadata.tag_paths);\n     auto eqer = bind eq_item(_, s);\n     alt (lookup_hash(paths, eqer, metadata.hash_path(s))) {\n-        case (option.some[ebml.doc](?d)) {\n-            auto did_doc = ebml.get_doc(d, metadata.tag_def_id);\n-            ret rr_ok(parse_def_id(ebml.doc_data(did_doc)));\n+        case (Option.some[EBML.doc](?d)) {\n+            auto did_doc = EBML.get_doc(d, metadata.tag_def_id);\n+            ret rr_ok(parse_def_id(EBML.doc_data(did_doc)));\n         }\n-        case (option.none[ebml.doc]) {\n+        case (Option.none[EBML.doc]) {\n             ret rr_not_found(s);\n         }\n     }\n }\n \n-fn maybe_find_item(int item_id, &ebml.doc items) -> option.t[ebml.doc] {\n+fn maybe_find_item(int item_id, &EBML.doc items) -> Option.t[EBML.doc] {\n     fn eq_item(vec[u8] bytes, int item_id) -> bool {\n-        ret ebml.be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n+        ret EBML.be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n     ret lookup_hash(items, eqer, metadata.hash_def_num(item_id));\n }\n \n-fn find_item(int item_id, &ebml.doc items) -> ebml.doc {\n+fn find_item(int item_id, &EBML.doc items) -> EBML.doc {\n     alt (maybe_find_item(item_id, items)) {\n-        case (option.some[ebml.doc](?d)) {ret d;}\n+        case (Option.some[EBML.doc](?d)) {ret d;}\n     }\n }\n \n // Looks up an item in the given metadata and returns an EBML doc pointing\n // to the item data.\n-fn lookup_item(int item_id, vec[u8] data) -> ebml.doc {\n-    auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n+fn lookup_item(int item_id, vec[u8] data) -> EBML.doc {\n+    auto items = EBML.get_doc(EBML.new_doc(data), metadata.tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_kind(&ebml.doc item) -> u8 {\n-    auto kind = ebml.get_doc(item, metadata.tag_items_data_item_kind);\n-    ret ebml.doc_as_uint(kind) as u8;\n+fn item_kind(&EBML.doc item) -> u8 {\n+    auto kind = EBML.get_doc(item, metadata.tag_items_data_item_kind);\n+    ret EBML.doc_as_uint(kind) as u8;\n }\n \n-fn item_symbol(&ebml.doc item) -> str {\n-    auto sym = ebml.get_doc(item, metadata.tag_items_data_item_symbol);\n-    ret _str.unsafe_from_bytes(ebml.doc_data(sym));\n+fn item_symbol(&EBML.doc item) -> str {\n+    auto sym = EBML.get_doc(item, metadata.tag_items_data_item_symbol);\n+    ret Str.unsafe_from_bytes(EBML.doc_data(sym));\n }\n \n-fn variant_tag_id(&ebml.doc d) -> ast.def_id {\n-    auto tagdoc = ebml.get_doc(d, metadata.tag_items_data_item_tag_id);\n-    ret parse_def_id(ebml.doc_data(tagdoc));\n+fn variant_tag_id(&EBML.doc d) -> ast.def_id {\n+    auto tagdoc = EBML.get_doc(d, metadata.tag_items_data_item_tag_id);\n+    ret parse_def_id(EBML.doc_data(tagdoc));\n }\n \n-fn item_type(&ebml.doc item, int this_cnum, ty.ctxt tcx) -> ty.t {\n+fn item_type(&EBML.doc item, int this_cnum, ty.ctxt tcx) -> ty.t {\n     fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n         // FIXME: This is completely wrong when linking against a crate\n         // that, in turn, links against another crate. We need a mapping\n         // from crate ID to crate \"meta\" attributes as part of the crate\n         // metadata.\n-        auto buf = _str.bytes(s);\n+        auto buf = Str.bytes(s);\n         auto external_def_id = parse_def_id(buf);\n         ret tup(this_cnum, external_def_id._1);\n     }\n \n-    auto tp = ebml.get_doc(item, metadata.tag_items_data_item_type);\n-    auto s = _str.unsafe_from_bytes(ebml.doc_data(tp));\n+    auto tp = EBML.get_doc(item, metadata.tag_items_data_item_type);\n+    auto s = Str.unsafe_from_bytes(EBML.doc_data(tp));\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       bind parse_external_def_id(this_cnum, _), tcx);\n }\n \n-fn item_ty_param_count(&ebml.doc item, int this_cnum) -> uint {\n+fn item_ty_param_count(&EBML.doc item, int this_cnum) -> uint {\n     let uint ty_param_count = 0u;\n     auto tp = metadata.tag_items_data_item_ty_param_count;\n-    for each (ebml.doc p in ebml.tagged_docs(item, tp)) {\n-        ty_param_count = ebml.vint_at(ebml.doc_data(p), 0u)._0;\n+    for each (EBML.doc p in EBML.tagged_docs(item, tp)) {\n+        ty_param_count = EBML.vint_at(EBML.doc_data(p), 0u)._0;\n     }\n     ret ty_param_count;\n }\n \n-fn tag_variant_ids(&ebml.doc item, int this_cnum) -> vec[ast.def_id] {\n+fn tag_variant_ids(&EBML.doc item, int this_cnum) -> vec[ast.def_id] {\n     let vec[ast.def_id] ids = vec();\n     auto v = metadata.tag_items_data_item_variant;\n-    for each (ebml.doc p in ebml.tagged_docs(item, v)) {\n-        auto ext = parse_def_id(ebml.doc_data(p));\n-        _vec.push[ast.def_id](ids, tup(this_cnum, ext._1));\n+    for each (EBML.doc p in EBML.tagged_docs(item, v)) {\n+        auto ext = parse_def_id(EBML.doc_data(p));\n+        Vec.push[ast.def_id](ids, tup(this_cnum, ext._1));\n     }\n     ret ids;\n }\n \n-fn get_metadata_section(str filename) -> option.t[vec[u8]] {\n+fn get_metadata_section(str filename) -> Option.t[vec[u8]] {\n     auto mb = llvm.LLVMRustCreateMemoryBufferWithContentsOfFile\n-        (_str.buf(filename));\n-    if (mb as int == 0) {ret option.none[vec[u8]];}\n+        (Str.buf(filename));\n+    if (mb as int == 0) {ret Option.none[vec[u8]];}\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);\n     while (llvm.LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n         auto name_buf = llvm.LLVMGetSectionName(si.llsi);\n-        auto name = _str.str_from_cstr(name_buf);\n-        if (_str.eq(name, x86.get_meta_sect_name())) {\n+        auto name = Str.str_from_cstr(name_buf);\n+        if (Str.eq(name, x86.get_meta_sect_name())) {\n             auto cbuf = llvm.LLVMGetSectionContents(si.llsi);\n             auto csz = llvm.LLVMGetSectionSize(si.llsi);\n-            auto cvbuf = cbuf as _vec.vbuf;\n-            ret option.some[vec[u8]](_vec.vec_from_vbuf[u8](cvbuf, csz));\n+            auto cvbuf = cbuf as Vec.vbuf;\n+            ret Option.some[vec[u8]](Vec.vec_from_vbuf[u8](cvbuf, csz));\n         }\n         llvm.LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option.none[vec[u8]];\n+    ret Option.none[vec[u8]];\n }\n \n \n@@ -426,9 +426,9 @@ fn load_crate(session.session sess,\n               vec[str] library_search_paths) {\n     auto filename = parser.default_native_name(sess, ident);\n     for (str library_search_path in library_search_paths) {\n-        auto path = fs.connect(library_search_path, filename);\n+        auto path = FS.connect(library_search_path, filename);\n         alt (get_metadata_section(path)) {\n-            case (option.some[vec[u8]](?cvec)) {\n+            case (Option.some[vec[u8]](?cvec)) {\n                 sess.set_external_crate(cnum, rec(name=ident, data=cvec));\n                 ret;\n             }\n@@ -442,7 +442,7 @@ fn load_crate(session.session sess,\n }\n \n fn fold_view_item_use(&env e, &span sp, ast.ident ident,\n-        vec[@ast.meta_item] meta_items, ast.def_id id, option.t[int] cnum_opt)\n+        vec[@ast.meta_item] meta_items, ast.def_id id, Option.t[int] cnum_opt)\n         -> @ast.view_item {\n     auto cnum;\n     if (!e.crate_cache.contains_key(ident)) {\n@@ -497,7 +497,7 @@ fn kind_has_type_params(u8 kind_ch) -> bool {\n // Crate metadata queries\n \n fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n-        -> option.t[ast.def] {\n+        -> Option.t[ast.def] {\n     auto data = sess.get_external_crate(cnum).data;\n \n     auto did;\n@@ -568,7 +568,7 @@ fn get_tag_variants(session.session sess, ty.ctxt tcx, ast.def_id def)\n         -> vec[trans.variant_info] {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n-    auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n+    auto items = EBML.get_doc(EBML.new_doc(data), metadata.tag_items);\n     auto item = find_item(def._1, items);\n \n     let vec[trans.variant_info] infos = vec();\n@@ -593,52 +593,52 @@ fn get_tag_variants(session.session sess, ty.ctxt tcx, ast.def_id def)\n     ret infos;\n }\n \n-fn list_file_metadata(str path, io.writer out) {\n+fn list_file_metadata(str path, IO.writer out) {\n     alt (get_metadata_section(path)) {\n-        case (option.some[vec[u8]](?bytes)) {\n+        case (Option.some[vec[u8]](?bytes)) {\n             list_crate_metadata(bytes, out);\n         }\n-        case (option.none[vec[u8]]) {\n+        case (Option.none[vec[u8]]) {\n             out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n         }\n     }\n }\n \n-fn read_path(&ebml.doc d) -> tup(str, uint) {\n-    auto desc = ebml.doc_data(d);\n-    auto pos = ebml.be_uint_from_bytes(desc, 0u, 4u);\n-    auto pathbytes = _vec.slice[u8](desc, 4u, _vec.len[u8](desc));\n-    auto path = _str.unsafe_from_bytes(pathbytes);\n+fn read_path(&EBML.doc d) -> tup(str, uint) {\n+    auto desc = EBML.doc_data(d);\n+    auto pos = EBML.be_uint_from_bytes(desc, 0u, 4u);\n+    auto pathbytes = Vec.slice[u8](desc, 4u, Vec.len[u8](desc));\n+    auto path = Str.unsafe_from_bytes(pathbytes);\n     ret tup(path, pos);\n }\n \n-fn list_crate_metadata(vec[u8] bytes, io.writer out) {\n-    auto md = ebml.new_doc(bytes);\n-    auto paths = ebml.get_doc(md, metadata.tag_paths);\n-    auto items = ebml.get_doc(md, metadata.tag_items);\n-    auto index = ebml.get_doc(paths, metadata.tag_index);\n-    auto bs = ebml.get_doc(index, metadata.tag_index_buckets);\n-    for each (ebml.doc bucket in\n-              ebml.tagged_docs(bs, metadata.tag_index_buckets_bucket)) {\n+fn list_crate_metadata(vec[u8] bytes, IO.writer out) {\n+    auto md = EBML.new_doc(bytes);\n+    auto paths = EBML.get_doc(md, metadata.tag_paths);\n+    auto items = EBML.get_doc(md, metadata.tag_items);\n+    auto index = EBML.get_doc(paths, metadata.tag_index);\n+    auto bs = EBML.get_doc(index, metadata.tag_index_buckets);\n+    for each (EBML.doc bucket in\n+              EBML.tagged_docs(bs, metadata.tag_index_buckets_bucket)) {\n         auto et = metadata.tag_index_buckets_bucket_elt;\n-        for each (ebml.doc elt in ebml.tagged_docs(bucket, et)) {\n+        for each (EBML.doc elt in EBML.tagged_docs(bucket, et)) {\n             auto data = read_path(elt);\n-            auto def = ebml.doc_at(bytes, data._1);\n-            auto did_doc = ebml.get_doc(def, metadata.tag_def_id);\n-            auto did = parse_def_id(ebml.doc_data(did_doc));\n+            auto def = EBML.doc_at(bytes, data._1);\n+            auto did_doc = EBML.get_doc(def, metadata.tag_def_id);\n+            auto did = parse_def_id(EBML.doc_data(did_doc));\n             out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n                                describe_def(items, did)));\n         }\n     }\n }\n \n-fn describe_def(&ebml.doc items, ast.def_id id) -> str {\n+fn describe_def(&EBML.doc items, ast.def_id id) -> str {\n     if (id._0 != 0) {ret \"external\";}\n     alt (maybe_find_item(id._1 as int, items)) {\n-        case (option.some[ebml.doc](?item)) {\n+        case (Option.some[EBML.doc](?item)) {\n             ret item_kind_to_str(item_kind(item));\n         }\n-        case (option.none[ebml.doc]) {\n+        case (Option.none[EBML.doc]) {\n             ret \"??\"; // Native modules don't seem to get item entries.\n         }\n     }"}, {"sha": "e1ad59bc5b7fa25e23783667c77c37027dcc2204", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,9 +1,9 @@\n-import std._vec;\n-import std._str;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n-import std.map.hashmap;\n+import std.Vec;\n+import std.Str;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Map.hashmap;\n \n import driver.session;\n import ast.ident;\n@@ -91,7 +91,7 @@ fn val_as_str(val v) -> str {\n \n fn lookup(session.session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n-        if (_str.eq(i, pair._0)) {\n+        if (Str.eq(i, pair._0)) {\n             ret pair._1;\n         }\n     }\n@@ -114,8 +114,8 @@ fn eval_lit(ctx cx, span sp, @ast.lit lit) -> val {\n fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n     alt (x.node) {\n         case (ast.expr_path(?pth, _, _)) {\n-            if (_vec.len[ident](pth.node.idents) == 1u &&\n-                _vec.len[@ast.ty](pth.node.types) == 0u) {\n+            if (Vec.len[ident](pth.node.idents) == 1u &&\n+                Vec.len[@ast.ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n             cx.sess.span_err(x.span, \"evaluating structured path-name\");\n@@ -224,7 +224,7 @@ fn val_eq(session.session sess, span sp, val av, val bv) -> bool {\n         ret val_as_int(av) == val_as_int(bv);\n     }\n     if (val_is_str(av) && val_is_str(bv)) {\n-        ret _str.eq(val_as_str(av),\n+        ret Str.eq(val_as_str(av),\n                     val_as_str(bv));\n     }\n     sess.span_err(sp, \"bad types in comparison\");\n@@ -388,7 +388,7 @@ fn eval_crate_directive(ctx cx,\n                 case (none[filename]) {}\n             }\n \n-            auto full_path = prefix + std.fs.path_sep() + file_path;\n+            auto full_path = prefix + std.FS.path_sep() + file_path;\n \n             if (cx.mode == mode_depend) {\n                 cx.deps += vec(full_path);\n@@ -405,7 +405,7 @@ fn eval_crate_directive(ctx cx,\n             auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n             ast.index_item(index, i);\n-            _vec.push[@ast.item](items, i);\n+            Vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n@@ -418,16 +418,16 @@ fn eval_crate_directive(ctx cx,\n                 case (none[filename]) {}\n             }\n \n-            auto full_path = prefix + std.fs.path_sep() + path;\n+            auto full_path = prefix + std.FS.path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n             auto im = ast.item_mod(id, m0, cx.p.next_def_id());\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n             ast.index_item(index, i);\n-            _vec.push[@ast.item](items, i);\n+            Vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_view_item(?vi)) {\n-            _vec.push[@ast.view_item](view_items, vi);\n+            Vec.push[@ast.view_item](view_items, vi);\n             ast.index_view_item(index, vi);\n         }\n "}, {"sha": "a3fdde955d5224fdf4dac6a53bd826e23f7eba58", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -6,9 +6,9 @@\n \n import util.common;\n \n-import std._str;\n-import std._vec;\n-import std.option;\n+import std.Str;\n+import std.Vec;\n+import std.Option;\n import std.GenericOS;\n \n export expand_syntax_ext;\n@@ -17,9 +17,9 @@ export expand_syntax_ext;\n fn expand_syntax_ext(parser.parser p,\n                      common.span sp,\n                      vec[@ast.expr] args,\n-                     option.t[str] body) -> @ast.expr {\n+                     Option.t[str] body) -> @ast.expr {\n \n-    if (_vec.len[@ast.expr](args) != 1u) {\n+    if (Vec.len[@ast.expr](args) != 1u) {\n         p.err(\"malformed #env call\");\n     }\n "}, {"sha": "8aedf587236a2d8cc415de106308e07c4cfab56a", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -6,11 +6,11 @@\n \n import util.common;\n \n-import std._str;\n-import std._vec;\n-import std.option;\n-import std.option.none;\n-import std.option.some;\n+import std.Str;\n+import std.Vec;\n+import std.Option;\n+import std.Option.none;\n+import std.Option.some;\n \n import std.ExtFmt.CT.signedness;\n import std.ExtFmt.CT.signed;\n@@ -47,9 +47,9 @@ export expand_syntax_ext;\n \n // FIXME: Need to thread parser through here to handle errors correctly\n fn expand_syntax_ext(vec[@ast.expr] args,\n-                     option.t[str] body) -> @ast.expr {\n+                     Option.t[str] body) -> @ast.expr {\n \n-    if (_vec.len[@ast.expr](args) == 0u) {\n+    if (Vec.len[@ast.expr](args) == 0u) {\n         log_err \"malformed #fmt call\";\n         fail;\n     }\n@@ -60,8 +60,8 @@ fn expand_syntax_ext(vec[@ast.expr] args,\n     // log fmt;\n \n     auto pieces = parse_fmt_string(fmt);\n-    auto args_len = _vec.len[@ast.expr](args);\n-    auto fmt_args = _vec.slice[@ast.expr](args, 1u, args_len - 1u);\n+    auto args_len = Vec.len[@ast.expr](args);\n+    auto fmt_args = Vec.slice[@ast.expr](args, 1u, args_len - 1u);\n     ret pieces_to_expr(pieces, args);\n }\n \n@@ -148,7 +148,7 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         }\n \n         auto recexpr = ast.expr_rec(astfields,\n-                                    option.none[@ast.expr],\n+                                    Option.none[@ast.expr],\n                                     ast.ann_none);\n         auto sp_recexpr = @rec(node=recexpr, span=sp);\n         ret sp_recexpr;\n@@ -196,7 +196,7 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n-            if (_vec.len[@ast.expr](flagexprs) == 0u) {\n+            if (Vec.len[@ast.expr](flagexprs) == 0u) {\n                 flagexprs += vec(make_rt_path_expr(sp, \"flag_none\"));\n             }\n \n@@ -303,7 +303,7 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         auto unsupported = \"conversion not supported in #fmt string\";\n \n         alt (cnv.param) {\n-            case (option.none[int]) {\n+            case (Option.none[int]) {\n             }\n             case (_) {\n                 log_err unsupported;\n@@ -398,7 +398,7 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n     fn log_conv(conv c) {\n         alt (c.param) {\n             case (some[int](?p)) {\n-                log \"param: \" + std._int.to_str(p, 10u);\n+                log \"param: \" + std.Int.to_str(p, 10u);\n             }\n             case (_) {\n                 log \"param: none\";\n@@ -425,10 +425,10 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         }\n         alt (c.width) {\n             case (count_is(?i)) {\n-                log \"width: count is \" + std._int.to_str(i, 10u);\n+                log \"width: count is \" + std.Int.to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"width: count is param \" + std._int.to_str(i, 10u);\n+                log \"width: count is param \" + std.Int.to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"width: count is next param\";\n@@ -439,10 +439,10 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         }\n         alt (c.precision) {\n             case (count_is(?i)) {\n-                log \"prec: count is \" + std._int.to_str(i, 10u);\n+                log \"prec: count is \" + std.Int.to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"prec: count is param \" + std._int.to_str(i, 10u);\n+                log \"prec: count is param \" + std.Int.to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"prec: count is next param\";\n@@ -498,7 +498,7 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n                 tmp_expr = make_add_expr(sp, tmp_expr, s_expr);\n             }\n             case (piece_conv(?conv)) {\n-                if (n >= _vec.len[@ast.expr](args)) {\n+                if (n >= Vec.len[@ast.expr](args)) {\n                     log_err \"too many conversions in #fmt string\";\n                     fail;\n                 }"}, {"sha": "a17dd514951f09db3c6a430ff6cbd99624f43edb", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,12 +1,12 @@\n-import std.io;\n-import std._str;\n-import std._vec;\n-import std._int;\n-import std.map;\n-import std.map.hashmap;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.IO;\n+import std.Str;\n+import std.Vec;\n+import std.Int;\n+import std.Map;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n import util.common;\n import util.common.new_str_hash;\n \n@@ -24,7 +24,7 @@ state type reader = state obj {\n     fn get_filemap() -> codemap.filemap;\n };\n \n-fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n+fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n     -> reader {\n     state obj reader(str file,\n                      uint len,\n@@ -49,13 +49,13 @@ fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n         }\n \n         fn next() -> char {\n-            if (pos < len) {ret _str.char_at(file, pos);}\n+            if (pos < len) {ret Str.char_at(file, pos);}\n             else {ret -1 as char;}\n         }\n \n         fn init() {\n             if (pos < len) {\n-                auto next = _str.char_range_at(file, pos);\n+                auto next = Str.char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             }\n@@ -67,7 +67,7 @@ fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n                 if (ch == '\\n') {\n                     codemap.next_line(fm, chpos);\n                 }\n-                auto next = _str.char_range_at(file, pos);\n+                auto next = Str.char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             } else {\n@@ -87,8 +87,8 @@ fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n             ret fm;\n         }\n     }\n-    auto file = _str.unsafe_from_bytes(rdr.read_whole_stream());\n-    auto rd = reader(file, _str.byte_len(file), 0u, -1 as char,\n+    auto file = Str.unsafe_from_bytes(rdr.read_whole_stream());\n+    auto rd = reader(file, Str.byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      keyword_table(),\n                      reserved_word_table(),\n@@ -97,7 +97,7 @@ fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n     ret rd;\n }\n \n-fn keyword_table() -> std.map.hashmap[str, token.token] {\n+fn keyword_table() -> std.Map.hashmap[str, token.token] {\n     auto keywords = new_str_hash[token.token]();\n \n     keywords.insert(\"mod\", token.MOD);\n@@ -205,7 +205,7 @@ fn keyword_table() -> std.map.hashmap[str, token.token] {\n     ret keywords;\n }\n \n-fn reserved_word_table() -> std.map.hashmap[str, ()] {\n+fn reserved_word_table() -> std.Map.hashmap[str, ()] {\n     auto reserved = new_str_hash[()]();\n     reserved.insert(\"f16\", ());  // IEEE 754-2008 'binary16' interchange fmt\n     reserved.insert(\"f80\", ());  // IEEE 754-1985 'extended'\n@@ -341,20 +341,20 @@ fn digits_to_string(str s) -> int {\n     ret accum_int;\n }\n \n-fn scan_exponent(reader rdr) -> option.t[str] {\n+fn scan_exponent(reader rdr) -> Option.t[str] {\n     auto c = rdr.curr();\n     auto res = \"\";\n \n     if (c == 'e' || c == 'E') {\n-        res += _str.from_bytes(vec(c as u8));\n+        res += Str.from_bytes(vec(c as u8));\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '-' || c == '+') {\n-            res += _str.from_bytes(vec(c as u8));\n+            res += Str.from_bytes(vec(c as u8));\n             rdr.bump();\n         }\n         auto exponent = scan_dec_digits(rdr);\n-        if (_str.byte_len(exponent) > 0u) {\n+        if (Str.byte_len(exponent) > 0u) {\n             ret(some(res + exponent));\n         }\n         else {\n@@ -374,7 +374,7 @@ fn scan_dec_digits(reader rdr) -> str {\n \n     while (is_dec_digit (c) || c == '_') {\n         if (c != '_') {\n-            res += _str.from_bytes(vec(c as u8));\n+            res += Str.from_bytes(vec(c as u8));\n         }\n         rdr.bump();\n         c = rdr.curr();\n@@ -574,12 +574,12 @@ fn next_token(reader rdr) -> token.token {\n \n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n-            _str.push_char(accum_str, c);\n+            Str.push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n \n-        if (_str.eq(accum_str, \"_\")) {\n+        if (Str.eq(accum_str, \"_\")) {\n             ret token.UNDERSCORE;\n         }\n \n@@ -738,37 +738,37 @@ fn next_token(reader rdr) -> token.token {\n                         alt (rdr.next()) {\n                             case ('n') {\n                                 rdr.bump();\n-                                _str.push_byte(accum_str, '\\n' as u8);\n+                                Str.push_byte(accum_str, '\\n' as u8);\n                             }\n                             case ('r') {\n                                 rdr.bump();\n-                                _str.push_byte(accum_str, '\\r' as u8);\n+                                Str.push_byte(accum_str, '\\r' as u8);\n                             }\n                             case ('t') {\n                                 rdr.bump();\n-                                _str.push_byte(accum_str, '\\t' as u8);\n+                                Str.push_byte(accum_str, '\\t' as u8);\n                             }\n                             case ('\\\\') {\n                                 rdr.bump();\n-                                _str.push_byte(accum_str, '\\\\' as u8);\n+                                Str.push_byte(accum_str, '\\\\' as u8);\n                             }\n                             case ('\"') {\n                                 rdr.bump();\n-                                _str.push_byte(accum_str, '\"' as u8);\n+                                Str.push_byte(accum_str, '\"' as u8);\n                             }\n \n                             case ('x') {\n-                                _str.push_char(accum_str,\n+                                Str.push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('u') {\n-                                _str.push_char(accum_str,\n+                                Str.push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('U') {\n-                                _str.push_char(accum_str,\n+                                Str.push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n@@ -780,7 +780,7 @@ fn next_token(reader rdr) -> token.token {\n                         }\n                     }\n                     case (_) {\n-                        _str.push_char(accum_str, rdr.curr());\n+                        Str.push_char(accum_str, rdr.curr());\n                     }\n                 }\n                 rdr.bump();\n@@ -870,7 +870,7 @@ fn read_line_comment(reader rdr) -> cmnt {\n     while (rdr.curr() == ' ') {rdr.bump();}\n     auto val = \"\";\n     while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n-        _str.push_char(val, rdr.curr());\n+        Str.push_char(val, rdr.curr());\n         rdr.bump();\n     }\n     ret rec(val=cmnt_line(val),\n@@ -887,21 +887,21 @@ fn read_block_comment(reader rdr) -> cmnt {\n     auto level = 1;\n     while (true) {\n         if (rdr.curr() == '\\n') {\n-            _vec.push[str](lines, val);\n+            Vec.push[str](lines, val);\n             val = \"\";\n             consume_whitespace(rdr);\n         } else {\n             if (rdr.curr() == '*' && rdr.next() == '/') {\n                 level -= 1;\n                 if (level == 0) {\n                     rdr.bump(); rdr.bump();\n-                    _vec.push[str](lines, val);\n+                    Vec.push[str](lines, val);\n                     break;\n                 }\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n                 level += 1;\n             }\n-            _str.push_char(val, rdr.curr());\n+            Str.push_char(val, rdr.curr());\n             rdr.bump();\n         }\n         if (rdr.is_eof()) {fail;}\n@@ -912,16 +912,16 @@ fn read_block_comment(reader rdr) -> cmnt {\n }\n \n fn gather_comments(str path) -> vec[cmnt] {\n-    auto srdr = io.file_reader(path);\n+    auto srdr = IO.file_reader(path);\n     auto rdr = new_reader(srdr, path, codemap.new_filemap(path, 0u));\n     let vec[cmnt] comments = vec();\n     while (!rdr.is_eof()) {\n         while (true) {\n             consume_whitespace(rdr);\n             if (rdr.curr() == '/' && rdr.next() == '/') {\n-                _vec.push[cmnt](comments, read_line_comment(rdr));\n+                Vec.push[cmnt](comments, read_line_comment(rdr));\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-                _vec.push[cmnt](comments, read_block_comment(rdr));\n+                Vec.push[cmnt](comments, read_block_comment(rdr));\n             } else { break; }\n         }\n         next_token(rdr);"}, {"sha": "bcde167157e5c15c78e70c5b988c218a30c92d61", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,10 +1,10 @@\n-import std.io;\n-import std._vec;\n-import std._str;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n-import std.map.hashmap;\n+import std.IO;\n+import std.Vec;\n+import std.Str;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Map.hashmap;\n \n import driver.session;\n import util.common;\n@@ -118,12 +118,12 @@ fn new_parser(session.session sess,\n             fn get_chpos() -> uint {ret rdr.get_chpos();}\n         }\n     auto ftype = SOURCE_FILE;\n-    if (_str.ends_with(path, \".rc\")) {\n+    if (Str.ends_with(path, \".rc\")) {\n         ftype = CRATE_FILE;\n     }\n-    auto srdr = io.file_reader(path);\n+    auto srdr = IO.file_reader(path);\n     auto filemap = codemap.new_filemap(path, pos);\n-    _vec.push[codemap.filemap](sess.get_codemap().files, filemap);\n+    Vec.push[codemap.filemap](sess.get_codemap().files, filemap);\n     auto rdr = lexer.new_reader(srdr, path, filemap);\n     // Make sure npos points at first actual token.\n     lexer.consume_any_whitespace(rdr);\n@@ -320,7 +320,7 @@ fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n                 case (token.IDENT(_)) {\n                     auto constr = parse_ty_constr(p);\n                     hi = constr.span.hi;\n-                    _vec.push[@ast.constr](constrs, constr);\n+                    Vec.push[@ast.constr](constrs, constr);\n                     if (p.peek() == token.COMMA) {\n                         p.bump();\n                         more = false;\n@@ -496,7 +496,7 @@ fn parse_arg(parser p) -> ast.arg {\n }\n \n fn parse_seq_to_end[T](token.token ket,\n-                              option.t[token.token] sep,\n+                              Option.t[token.token] sep,\n                               (fn(parser) -> T) f,\n                               uint hi,\n                               parser p) -> vec[T] {\n@@ -525,7 +525,7 @@ fn parse_seq_to_end[T](token.token ket,\n \n fn parse_seq[T](token.token bra,\n                        token.token ket,\n-                       option.t[token.token] sep,\n+                       Option.t[token.token] sep,\n                        (fn(parser) -> T) f,\n                        parser p) -> util.common.spanned[vec[T]] {\n     auto lo = p.get_lo_pos();\n@@ -764,7 +764,7 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.BIND) {\n             p.bump();\n             auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-            fn parse_expr_opt(parser p) -> option.t[@ast.expr] {\n+            fn parse_expr_opt(parser p) -> Option.t[@ast.expr] {\n                 alt (p.peek()) {\n                     case (token.UNDERSCORE) {\n                         p.bump();\n@@ -777,7 +777,7 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n             }\n \n             auto pf = parse_expr_opt;\n-            auto es = parse_seq[option.t[@ast.expr]](token.LPAREN,\n+            auto es = parse_seq[Option.t[@ast.expr]](token.LPAREN,\n                                                      token.RPAREN,\n                                                      some(token.COMMA),\n                                                      pf, p);\n@@ -939,18 +939,18 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n \n fn expand_syntax_ext(parser p, ast.span sp,\n                      &ast.path path, vec[@ast.expr] args,\n-                     option.t[str] body) -> ast.expr_ {\n+                     Option.t[str] body) -> ast.expr_ {\n \n-    assert (_vec.len[ast.ident](path.node.idents) > 0u);\n+    assert (Vec.len[ast.ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n-    if (_str.eq(extname, \"fmt\")) {\n+    if (Str.eq(extname, \"fmt\")) {\n         auto expanded = extfmt.expand_syntax_ext(args, body);\n         auto newexpr = ast.expr_ext(path, args, body,\n                                     expanded,\n                                     ast.ann_none);\n \n         ret newexpr;\n-    } else if (_str.eq(extname, \"env\")) {\n+    } else if (Str.eq(extname, \"env\")) {\n         auto expanded = extenv.expand_syntax_ext(p, sp, args, body);\n         auto newexpr = ast.expr_ext(path, args, body,\n                                     expanded,\n@@ -968,7 +968,7 @@ fn extend_expr_by_ident(parser p, uint lo, uint hi,\n     auto e_ = e.node;\n     alt (e.node) {\n         case (ast.expr_path(?pth, ?def, ?ann)) {\n-            if (_vec.len[@ast.ty](pth.node.types) == 0u) {\n+            if (Vec.len[@ast.ty](pth.node.types) == 0u) {\n                 auto idents_ = pth.node.idents;\n                 idents_ += vec(i);\n                 auto tys = parse_ty_args(p, hi);\n@@ -1238,7 +1238,7 @@ fn parse_if_expr(parser p) -> @ast.expr {\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     auto thn = parse_block(p);\n-    let option.t[@ast.expr] els = none[@ast.expr];\n+    let Option.t[@ast.expr] els = none[@ast.expr];\n     auto hi = thn.span.hi;\n     alt (p.peek()) {\n         case (token.ELSE) {\n@@ -1398,7 +1398,7 @@ fn parse_spawn_expr(parser p) -> @ast.expr {\n                                    pf, p);\n     auto hi = es.span.hi;\n     auto spawn_expr = ast.expr_spawn(ast.dom_implicit,\n-                                     option.none[str],\n+                                     Option.none[str],\n                                      fn_expr,\n                                      es.node,\n                                      ast.ann_none);\n@@ -1449,7 +1449,7 @@ fn parse_expr_inner(parser p) -> @ast.expr {\n     }\n }\n \n-fn parse_initializer(parser p) -> option.t[ast.initializer] {\n+fn parse_initializer(parser p) -> Option.t[ast.initializer] {\n     alt (p.peek()) {\n         case (token.EQ) {\n             p.bump();\n@@ -1521,7 +1521,7 @@ fn parse_pat(parser p) -> @ast.pat {\n     ret @spanned(lo, hi, pat);\n }\n \n-fn parse_local_full(&option.t[@ast.ty] tyopt,\n+fn parse_local_full(&Option.t[@ast.ty] tyopt,\n                            parser p) -> @ast.local {\n     auto ident = parse_ident(p);\n     auto init = parse_initializer(p);\n@@ -1607,7 +1607,7 @@ fn parse_source_stmt(parser p) -> @ast.stmt {\n     fail;\n }\n \n-fn index_block(vec[@ast.stmt] stmts, option.t[@ast.expr] expr) -> ast.block_ {\n+fn index_block(vec[@ast.stmt] stmts, Option.t[@ast.expr] expr) -> ast.block_ {\n     auto index = new_str_hash[ast.block_index_entry]();\n     for (@ast.stmt s in stmts) {\n         ast.index_stmt(index, s);\n@@ -1634,7 +1634,7 @@ fn index_arm(@ast.pat pat) -> hashmap[ast.ident,ast.def_id] {\n     ret index;\n }\n \n-fn stmt_to_expr(@ast.stmt stmt) -> option.t[@ast.expr] {\n+fn stmt_to_expr(@ast.stmt stmt) -> Option.t[@ast.expr] {\n     alt (stmt.node) {\n         case (ast.stmt_expr(?e,_)) { ret some[@ast.expr](e); }\n         case (_) { /* fall through */ }\n@@ -1697,7 +1697,7 @@ fn parse_block(parser p) -> ast.block {\n     auto lo = p.get_lo_pos();\n \n     let vec[@ast.stmt] stmts = vec();\n-    let option.t[@ast.expr] expr = none[@ast.expr];\n+    let Option.t[@ast.expr] expr = none[@ast.expr];\n \n     expect(p, token.LBRACE);\n     while (p.peek() != token.RBRACE) {\n@@ -1871,7 +1871,7 @@ fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n          pf, p);\n \n     let vec[@ast.method] meths = vec();\n-    let option.t[@ast.method] dtor = none[@ast.method];\n+    let Option.t[@ast.method] dtor = none[@ast.method];\n \n     expect(p, token.LBRACE);\n     while (p.peek() != token.RBRACE) {\n@@ -1880,7 +1880,7 @@ fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n                 dtor = some[@ast.method](parse_dtor(p));\n             }\n             case (_) {\n-                _vec.push[@ast.method](meths,\n+                Vec.push[@ast.method](meths,\n                                        parse_method(p));\n             }\n         }\n@@ -2020,12 +2020,12 @@ fn parse_item_native_mod(parser p) -> @ast.item {\n     auto abi = ast.native_abi_cdecl;\n     if (p.peek() != token.MOD) {\n         auto t = parse_str_lit_or_env_ident(p);\n-        if (_str.eq(t, \"cdecl\")) {\n-        } else if (_str.eq(t, \"rust\")) {\n+        if (Str.eq(t, \"cdecl\")) {\n+        } else if (Str.eq(t, \"rust\")) {\n             abi = ast.native_abi_rust;\n-        } else if (_str.eq(t, \"llvm\")) {\n+        } else if (Str.eq(t, \"llvm\")) {\n             abi = ast.native_abi_llvm;\n-        } else if (_str.eq(t, \"rust-intrinsic\")) {\n+        } else if (Str.eq(t, \"rust-intrinsic\")) {\n             abi = ast.native_abi_rust_intrinsic;\n         } else {\n             p.err(\"unsupported abi: \" + t);\n@@ -2264,7 +2264,7 @@ fn parse_use(parser p) -> @ast.view_item {\n }\n \n fn parse_rest_import_name(parser p, ast.ident first,\n-                                 option.t[ast.ident] def_ident)\n+                                 Option.t[ast.ident] def_ident)\n         -> @ast.view_item {\n     auto lo = p.get_lo_pos();\n     let vec[ast.ident] identifiers = vec(first);\n@@ -2281,7 +2281,7 @@ fn parse_rest_import_name(parser p, ast.ident first,\n             defined_id = i;\n         }\n         case (_) {\n-            auto len = _vec.len[ast.ident](identifiers);\n+            auto len = Vec.len[ast.ident](identifiers);\n             defined_id = identifiers.(len - 1u);\n         }\n     }\n@@ -2506,15 +2506,15 @@ fn parse_crate_directives(parser p, token.token term)\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n-        _vec.push[@ast.crate_directive](cdirs, cdir);\n+        Vec.push[@ast.crate_directive](cdirs, cdir);\n     }\n \n     ret cdirs;\n }\n \n fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n     auto lo = p.get_lo_pos();\n-    auto prefix = std.fs.dirname(p.get_filemap().name);\n+    auto prefix = std.FS.dirname(p.get_filemap().name);\n     auto cdirs = parse_crate_directives(p, token.EOF);\n     let vec[str] deps = vec();\n     auto cx = @rec(p=p,"}, {"sha": "f0b6c4be352ac95cc50d64fd779b98577b68e551", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,9 +1,9 @@\n import util.common.ty_mach;\n import util.common.ty_mach_to_str;\n import util.common.new_str_hash;\n-import std._int;\n-import std._uint;\n-import std._str;\n+import std.Int;\n+import std.UInt;\n+import std.Str;\n \n tag binop {\n     PLUS;\n@@ -295,10 +295,10 @@ fn to_str(token t) -> str {\n         case (JOIN) { ret \"join\"; }\n \n         /* Literals */\n-        case (LIT_INT(?i)) { ret _int.to_str(i, 10u); }\n-        case (LIT_UINT(?u)) { ret _uint.to_str(u, 10u); }\n+        case (LIT_INT(?i)) { ret Int.to_str(i, 10u); }\n+        case (LIT_UINT(?u)) { ret UInt.to_str(u, 10u); }\n         case (LIT_MACH_INT(?tm, ?i)) {\n-            ret  _int.to_str(i, 10u)\n+            ret  Int.to_str(i, 10u)\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n         case (LIT_FLOAT(?s)) { ret s; }\n@@ -309,8 +309,8 @@ fn to_str(token t) -> str {\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n             auto tmp = \"'\";\n-            _str.push_char(tmp, c);\n-            _str.push_byte(tmp, '\\'' as u8);\n+            Str.push_char(tmp, c);\n+            Str.push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n \n@@ -320,7 +320,7 @@ fn to_str(token t) -> str {\n \n         /* Name components */\n         case (IDENT(?s)) { auto si = \"ident:\"; si += s; ret si; }\n-        case (IDX(?i)) { ret \"_\" + _int.to_str(i, 10u); }\n+        case (IDX(?i)) { ret \"_\" + Int.to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n \n         /* Reserved type names */"}, {"sha": "2c0ac2fcbe4d4b820ad472b7d682df9af98d9fa7", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,7 +1,7 @@\n-import std._vec;\n-import std._str;\n-import std._str.rustrt.sbuf;\n-import std._vec.rustrt.vbuf;\n+import std.Vec;\n+import std.Str;\n+import std.Str.rustrt.sbuf;\n+import std.Vec.rustrt.vbuf;\n \n import llvm.ModuleRef;\n import llvm.ContextRef;\n@@ -831,7 +831,7 @@ native mod llvm = llvm_lib {\n     /** Destroys a section iterator. */\n     fn LLVMDisposeSectionIterator(SectionIteratorRef SI);\n     /** Returns true if the section iterator is at the end of the section\n-        list. */\n+        List. */\n     fn LLVMIsSectionIteratorAtEnd(ObjectFileRef ObjectFile,\n                                   SectionIteratorRef SI) -> Bool;\n     /** Moves the section iterator to point to the next section. */\n@@ -894,8 +894,8 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildAggregateRet(B,\n-                                       _vec.buf[ValueRef](RetVals),\n-                                       _vec.len[ValueRef](RetVals));\n+                                       Vec.buf[ValueRef](RetVals),\n+                                       Vec.len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n@@ -930,10 +930,10 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildInvoke(B, Fn,\n-                                 _vec.buf[ValueRef](Args),\n-                                 _vec.len[ValueRef](Args),\n+                                 Vec.buf[ValueRef](Args),\n+                                 Vec.len[ValueRef](Args),\n                                  Then, Catch,\n-                                 _str.buf(\"\"));\n+                                 Str.buf(\"\"));\n     }\n \n     fn Unwind() -> ValueRef {\n@@ -951,176 +951,176 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAdd(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildAdd(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFAdd(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFAdd(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSub(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSub(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFSub(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFSub(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildMul(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildMul(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFMul(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFMul(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildUDiv(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildUDiv(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSDiv(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSDiv(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFDiv(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFDiv(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildURem(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildURem(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSRem(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSRem(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFRem(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFRem(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildShl(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildShl(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildLShr(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildLShr(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAShr(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildAShr(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAnd(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildAnd(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildOr(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildOr(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildXor(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildXor(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNeg(B, V, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNeg(B, V, Str.buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNSWNeg(B, V, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNSWNeg(B, V, Str.buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNUWNeg(B, V, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNUWNeg(B, V, Str.buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFNeg(B, V, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFNeg(B, V, Str.buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildNot(B, V, _str.buf(\"\"));\n+        ret llvm.LLVMBuildNot(B, V, Str.buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildMalloc(B, Ty, _str.buf(\"\"));\n+        ret llvm.LLVMBuildMalloc(B, Ty, Str.buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, _str.buf(\"\"));\n+        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, Str.buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildAlloca(B, Ty, _str.buf(\"\"));\n+        ret llvm.LLVMBuildAlloca(B, Ty, Str.buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, _str.buf(\"\"));\n+        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, Str.buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n@@ -1130,7 +1130,7 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildLoad(B, PointerVal, _str.buf(\"\"));\n+        ret llvm.LLVMBuildLoad(B, PointerVal, Str.buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n@@ -1141,249 +1141,249 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n         ret llvm.LLVMBuildGEP(B, Pointer,\n-                              _vec.buf[ValueRef](Indices),\n-                              _vec.len[ValueRef](Indices),\n-                              _str.buf(\"\"));\n+                              Vec.buf[ValueRef](Indices),\n+                              Vec.len[ValueRef](Indices),\n+                              Str.buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n         ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n-                                      _vec.buf[ValueRef](Indices),\n-                                      _vec.len[ValueRef](Indices),\n-                                      _str.buf(\"\"));\n+                                      Vec.buf[ValueRef](Indices),\n+                                      Vec.len[ValueRef](Indices),\n+                                      Str.buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, _str.buf(\"\"));\n+        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, Str.buf(\"\"));\n     }\n \n-    fn GlobalString(sbuf Str) -> ValueRef {\n+    fn GlobalString(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildGlobalString(B, Str, _str.buf(\"\"));\n+        ret llvm.LLVMBuildGlobalString(B, _Str, Str.buf(\"\"));\n     }\n \n-    fn GlobalStringPtr(sbuf Str) -> ValueRef {\n+    fn GlobalStringPtr(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildGlobalStringPtr(B, Str, _str.buf(\"\"));\n+        ret llvm.LLVMBuildGlobalStringPtr(B, _Str, Str.buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildTrunc(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildTrunc(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildZExt(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildZExt(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSExt(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSExt(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPToUI(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFPToUI(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPToSI(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFPToSI(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildUIToFP(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildUIToFP(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSIToFP(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSIToFP(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPExt(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFPExt(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildBitCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildBitCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildCast(B, Op, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildCast(B, Op, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPointerCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildPointerCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIntCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildIntCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFPCast(B, Val, DestTy, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFPCast(B, Val, DestTy, Str.buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, Str.buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n         assert (!*terminated);\n-        auto phi = llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n-        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        auto phi = llvm.LLVMBuildPhi(B, Ty, Str.buf(\"\"));\n+        assert (Vec.len[ValueRef](vals) == Vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n-                             _vec.buf[ValueRef](vals),\n-                             _vec.buf[BasicBlockRef](bbs),\n-                             _vec.len[ValueRef](vals));\n+                             Vec.buf[ValueRef](vals),\n+                             Vec.buf[BasicBlockRef](bbs),\n+                             Vec.len[ValueRef](vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(ValueRef phi,\n                         vec[ValueRef] vals,\n                         vec[BasicBlockRef] bbs) {\n-        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        assert (Vec.len[ValueRef](vals) == Vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n-                             _vec.buf[ValueRef](vals),\n-                             _vec.buf[BasicBlockRef](bbs),\n-                             _vec.len[ValueRef](vals));\n+                             Vec.buf[ValueRef](vals),\n+                             Vec.buf[BasicBlockRef](bbs),\n+                             Vec.len[ValueRef](vals));\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n         ret llvm.LLVMBuildCall(B, Fn,\n-                               _vec.buf[ValueRef](Args),\n-                               _vec.len[ValueRef](Args),\n-                               _str.buf(\"\"));\n+                               Vec.buf[ValueRef](Args),\n+                               Vec.len[ValueRef](Args),\n+                               Str.buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n         auto v = llvm.LLVMBuildCall(B, Fn,\n-                                    _vec.buf[ValueRef](Args),\n-                                    _vec.len[ValueRef](Args),\n-                                    _str.buf(\"\"));\n+                                    Vec.buf[ValueRef](Args),\n+                                    Vec.len[ValueRef](Args),\n+                                    Str.buf(\"\"));\n         llvm.LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n         ret v;\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildSelect(B, If, Then, Else, _str.buf(\"\"));\n+        ret llvm.LLVMBuildSelect(B, If, Then, Else, Str.buf(\"\"));\n     }\n \n     fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildVAArg(B, List, Ty, _str.buf(\"\"));\n+        ret llvm.LLVMBuildVAArg(B, List, Ty, Str.buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExtractElement(B, VecVal, Index, _str.buf(\"\"));\n+        ret llvm.LLVMBuildExtractElement(B, VecVal, Index, Str.buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n         ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n-                                        _str.buf(\"\"));\n+                                        Str.buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, _str.buf(\"\"));\n+        ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, Str.buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildExtractValue(B, AggVal, Index, _str.buf(\"\"));\n+        ret llvm.LLVMBuildExtractValue(B, AggVal, Index, Str.buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, _str.buf(\"\"));\n+        ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, Str.buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIsNull(B, Val, _str.buf(\"\"));\n+        ret llvm.LLVMBuildIsNull(B, Val, Str.buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildIsNotNull(B, Val, _str.buf(\"\"));\n+        ret llvm.LLVMBuildIsNotNull(B, Val, Str.buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, _str.buf(\"\"));\n+        ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, Str.buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n         assert (!*terminated);\n         let BasicBlockRef BB = llvm.LLVMGetInsertBlock(B);\n         let ValueRef FN = llvm.LLVMGetBasicBlockParent(BB);\n         let ModuleRef M = llvm.LLVMGetGlobalParent(FN);\n-        let ValueRef T = llvm.LLVMGetNamedFunction(M, _str.buf(\"llvm.trap\"));\n+        let ValueRef T = llvm.LLVMGetNamedFunction(M, Str.buf(\"llvm.trap\"));\n         assert (T as int != 0);\n         let vec[ValueRef] Args = vec();\n         ret llvm.LLVMBuildCall(B, T,\n-                               _vec.buf[ValueRef](Args),\n-                               _vec.len[ValueRef](Args),\n-                               _str.buf(\"\"));\n+                               Vec.buf[ValueRef](Args),\n+                               Vec.len[ValueRef](Args),\n+                               Str.buf(\"\"));\n     }\n \n     drop {\n@@ -1405,8 +1405,8 @@ fn mk_type_handle() -> type_handle {\n }\n \n \n-state obj type_names(std.map.hashmap[TypeRef, str] type_names,\n-                    std.map.hashmap[str, TypeRef] named_types) {\n+state obj type_names(std.Map.hashmap[TypeRef, str] type_names,\n+                    std.Map.hashmap[str, TypeRef] named_types) {\n \n     fn associate(str s, TypeRef t) {\n         assert (!named_types.contains_key(s));\n@@ -1443,9 +1443,9 @@ fn mk_type_names() -> type_names {\n         ret (a as uint) == (b as uint);\n     }\n \n-    let std.map.hashfn[TypeRef] hasher = hash;\n-    let std.map.eqfn[TypeRef] eqer = eq;\n-    auto tn = std.map.mk_hashmap[TypeRef,str](hasher, eqer);\n+    let std.Map.hashfn[TypeRef] hasher = hash;\n+    let std.Map.eqfn[TypeRef] eqer = eq;\n+    auto tn = std.Map.mk_hashmap[TypeRef,str](hasher, eqer);\n \n     ret type_names(tn, nt);\n }\n@@ -1503,8 +1503,8 @@ fn type_to_str_inner(type_names names,\n             let TypeRef out_ty = llvm.LLVMGetReturnType(ty);\n             let uint n_args = llvm.LLVMCountParamTypes(ty);\n             let vec[TypeRef] args =\n-                _vec.init_elt[TypeRef](0 as TypeRef, n_args);\n-            llvm.LLVMGetParamTypes(ty, _vec.buf[TypeRef](args));\n+                Vec.init_elt[TypeRef](0 as TypeRef, n_args);\n+            llvm.LLVMGetParamTypes(ty, Vec.buf[TypeRef](args));\n             s += tys_str(names, outer, args);\n             s += \") -> \";\n             s += type_to_str_inner(names, outer, out_ty);\n@@ -1515,8 +1515,8 @@ fn type_to_str_inner(type_names names,\n             let str s = \"{\";\n             let uint n_elts = llvm.LLVMCountStructElementTypes(ty);\n             let vec[TypeRef] elts =\n-                _vec.init_elt[TypeRef](0 as TypeRef, n_elts);\n-            llvm.LLVMGetStructElementTypes(ty, _vec.buf[TypeRef](elts));\n+                Vec.init_elt[TypeRef](0 as TypeRef, n_elts);\n+            llvm.LLVMGetStructElementTypes(ty, Vec.buf[TypeRef](elts));\n             s += tys_str(names, outer, elts);\n             s += \"}\";\n             ret s;\n@@ -1529,7 +1529,7 @@ fn type_to_str_inner(type_names names,\n             for (TypeRef tout in outer0) {\n                 i += 1u;\n                 if (tout as int == ty as int) {\n-                    let uint n = _vec.len[TypeRef](outer0) - i;\n+                    let uint n = Vec.len[TypeRef](outer0) - i;\n                     ret \"*\\\\\" + util.common.istr(n as int);\n                 }\n             }\n@@ -1556,7 +1556,7 @@ obj target_data_dtor(TargetDataRef TD) {\n type target_data = rec(TargetDataRef lltd, target_data_dtor dtor);\n \n fn mk_target_data(str string_rep) -> target_data {\n-    auto lltd = llvm.LLVMCreateTargetData(_str.buf(string_rep));\n+    auto lltd = llvm.LLVMCreateTargetData(Str.buf(string_rep));\n     ret rec(lltd=lltd, dtor=target_data_dtor(lltd));\n }\n "}, {"sha": "003c38972f8b3fdfcbfc6d68de7e8fa84382f355", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,29 +1,29 @@\n import driver.session;\n import front.ast;\n-import std.map.hashmap;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n-import std._int;\n-import std._vec;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Int;\n+import std.Vec;\n import util.common;\n \n-type fn_id_of_local = std.map.hashmap[ast.def_id, ast.def_id];\n+type fn_id_of_local = std.Map.hashmap[ast.def_id, ast.def_id];\n type env = rec(mutable vec[ast.def_id] current_context, // fn or obj\n                fn_id_of_local idmap,\n                session.session sess);\n \n fn current_context(&env e) -> ast.def_id {\n-    ret e.current_context.(_vec.len(e.current_context) - 1u);\n+    ret e.current_context.(Vec.len(e.current_context) - 1u);\n }\n \n fn enter_item(@env e, @ast.item i) {\n     alt (i.node) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n-            _vec.push(e.current_context, id);\n+            Vec.push(e.current_context, id);\n         }\n         case (ast.item_obj(_, _, _, ?ids, _)) {\n-            _vec.push(e.current_context, ids.ty);\n+            Vec.push(e.current_context, ids.ty);\n         }\n         case (_) {}\n     }\n@@ -32,10 +32,10 @@ fn enter_item(@env e, @ast.item i) {\n fn leave_item(@env e, @ast.item i) {\n     alt (i.node) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n-            _vec.pop(e.current_context);\n+            Vec.pop(e.current_context);\n         }\n         case (ast.item_obj(_, _, _, ?ids, _)) {\n-            _vec.pop(e.current_context);\n+            Vec.pop(e.current_context);\n         }\n         case (_) {}\n     }\n@@ -61,13 +61,13 @@ fn walk_expr(@env e, @ast.expr x) {\n         }\n         case (ast.expr_path(_, ?def, _)) {\n             auto local_id;\n-            alt (option.get(def)) {\n+            alt (Option.get(def)) {\n                 case (ast.def_local(?id)) { local_id = id; }\n                 case (_) { ret; }\n             }\n \n-            auto df = ast.def_id_of_def(option.get(def));\n-            auto def_context = option.get(e.idmap.find(df));\n+            auto df = ast.def_id_of_def(Option.get(def));\n+            auto def_context = Option.get(e.idmap.find(df));\n \n             if (current_context(*e) != def_context) {\n                 e.sess.span_err(x.span,"}, {"sha": "ace45c2f9a51273aef20ca9f9fa3bc0ba277465d", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,7 +1,7 @@\n-import std.map.hashmap;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n \n import util.common.new_str_hash;\n import util.common.spanned;\n@@ -32,8 +32,8 @@ import front.ast.ann;\n import front.ast.mt;\n import front.ast.purity;\n \n-import std._uint;\n-import std._vec;\n+import std.UInt;\n+import std.Vec;\n \n type ast_fold[ENV] =\n     @rec\n@@ -67,7 +67,7 @@ type ast_fold[ENV] =\n          @ty output) -> @ty)                      fold_ty_fn,\n \n      (fn(&ENV e, &span sp, ast.path p,\n-         &option.t[def] d) -> @ty)                fold_ty_path,\n+         &Option.t[def] d) -> @ty)                fold_ty_path,\n \n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_chan,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_port,\n@@ -82,7 +82,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          vec[ast.field] fields,\n-         option.t[@expr] base, ann a) -> @expr)   fold_expr_rec,\n+         Option.t[@expr] base, ann a) -> @expr)   fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n          @expr f, vec[@expr] args,\n@@ -92,11 +92,11 @@ type ast_fold[ENV] =\n          ident id, ann a) -> @expr)               fold_expr_self_method,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[option.t[@expr]] args,\n+         @expr f, vec[Option.t[@expr]] args,\n          ann a) -> @expr)                         fold_expr_bind,\n \n      (fn(&ENV e, &span sp,\n-         ast.spawn_dom dom, option.t[str] name,\n+         ast.spawn_dom dom, Option.t[str] name,\n          @expr f, vec[@expr] args,\n          ann a) -> @expr)                         fold_expr_spawn,\n \n@@ -118,7 +118,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n-         &option.t[@expr] els,\n+         &Option.t[@expr] els,\n          ann a) -> @expr)                         fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n@@ -169,12 +169,12 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &path p,\n-         &option.t[def] d,\n+         &Option.t[def] d,\n          ann a) -> @expr)                         fold_expr_path,\n \n      (fn(&ENV e, &span sp,\n          &path p, vec[@expr] args,\n-         option.t[str] body,\n+         Option.t[str] body,\n          @expr expanded,\n          ann a) -> @expr)                         fold_expr_ext,\n \n@@ -185,10 +185,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_cont,\n \n      (fn(&ENV e, &span sp,\n-         &option.t[@expr] rv, ann a) -> @expr)    fold_expr_ret,\n+         &Option.t[@expr] rv, ann a) -> @expr)    fold_expr_ret,\n \n      (fn(&ENV e, &span sp,\n-         &option.t[@expr] rv, ann a) -> @expr)    fold_expr_put,\n+         &Option.t[@expr] rv, ann a) -> @expr)    fold_expr_put,\n \n      (fn(&ENV e, &span sp,\n          @expr e, ann a) -> @expr)                fold_expr_be,\n@@ -229,7 +229,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          path p, vec[@pat] args,\n-         option.t[ast.variant_def] d,\n+         Option.t[ast.variant_def] d,\n          ann a) -> @pat)                          fold_pat_tag,\n \n \n@@ -253,7 +253,7 @@ type ast_fold[ENV] =\n          def_id id, ann a) -> @item)              fold_item_fn,\n \n      (fn(&ENV e, &span sp, ident ident,\n-         option.t[str] link_name,\n+         Option.t[str] link_name,\n          &ast.fn_decl decl,\n          vec[ast.ty_param] ty_params,\n          def_id id, ann a) -> @native_item)       fold_native_item_fn,\n@@ -284,10 +284,10 @@ type ast_fold[ENV] =\n      // View Item folds.\n      (fn(&ENV e, &span sp, ident ident,\n          vec[@meta_item] meta_items,\n-         def_id id, option.t[int]) -> @view_item) fold_view_item_use,\n+         def_id id, Option.t[int]) -> @view_item) fold_view_item_use,\n \n      (fn(&ENV e, &span sp, ident i, vec[ident] idents,\n-         def_id id, option.t[def]) -> @view_item) fold_view_item_import,\n+         def_id id, Option.t[def]) -> @view_item) fold_view_item_import,\n \n      (fn(&ENV e, &span sp, ident i) -> @view_item) fold_view_item_export,\n \n@@ -316,7 +316,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e,\n          vec[ast.obj_field] fields,\n          vec[@ast.method] methods,\n-         option.t[@ast.method] dtor) -> ast._obj) fold_obj,\n+         Option.t[@ast.method] dtor) -> ast._obj) fold_obj,\n \n      // Env updates.\n      (fn(&ENV e, @ast.crate c) -> ENV) update_env_for_crate,\n@@ -341,7 +341,7 @@ type ast_fold[ENV] =\n fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast.ty] tys_ = vec();\n     for (@ast.ty t in p.node.types) {\n-        _vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n+        Vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n     }\n     let ast.path_ p_ = rec(idents=p.node.idents, types=tys_);\n     ret fld.fold_path(env, p.span, p_);\n@@ -382,7 +382,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             let vec[mt] elts_ = vec();\n             for (mt elt in elts) {\n                 auto ty_ = fold_ty(env, fld, elt.ty);\n-                _vec.push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n+                Vec.push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n@@ -391,7 +391,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             let vec[ast.ty_field] flds_ = vec();\n             for (ast.ty_field f in flds) {\n                 auto ty_ = fold_ty(env, fld, f.mt.ty);\n-                _vec.push[ast.ty_field]\n+                Vec.push[ast.ty_field]\n                     (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n@@ -404,7 +404,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n                     case (ast.ty_fn(?p, ?ins, ?out)) {\n-                        _vec.push[ast.ty_method]\n+                        Vec.push[ast.ty_method]\n                             (meths_, rec(proto=p, inputs=ins,\n                                          output=out with m));\n                     }\n@@ -518,7 +518,7 @@ fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n-        _vec.push[@expr](exprs, fold_expr(env, fld, e));\n+        Vec.push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n@@ -558,7 +558,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n \n         case (ast.expr_rec(?fs, ?base, ?t)) {\n             let vec[ast.field] fields = vec();\n-            let option.t[@expr] b = none[@expr];\n+            let Option.t[@expr] b = none[@expr];\n             for (ast.field f in fs) {\n                 fields += vec(fold_rec_field(env, fld, f));\n             }\n@@ -586,8 +586,8 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n \n         case (ast.expr_bind(?f, ?args_opt, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n-            let vec[option.t[@ast.expr]] aargs_opt = vec();\n-            for (option.t[@ast.expr] t_opt in args_opt) {\n+            let vec[Option.t[@ast.expr]] aargs_opt = vec();\n+            for (Option.t[@ast.expr] t_opt in args_opt) {\n                 alt (t_opt) {\n                     case (none[@ast.expr]) {\n                         aargs_opt += vec(none[@ast.expr]);\n@@ -865,7 +865,7 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        _vec.push[@ast.stmt](stmts, new_stmt);\n+        Vec.push[@ast.stmt](stmts, new_stmt);\n         ast.index_stmt(index, new_stmt);\n     }\n \n@@ -935,7 +935,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n     for (ast.obj_field f in ob.fields) {\n         fields += vec(fold_obj_field(env, fld, f));\n     }\n-    let option.t[@ast.method] dtor = none[@ast.method];\n+    let Option.t[@ast.method] dtor = none[@ast.method];\n     alt (ob.dtor) {\n         case (none[@ast.method]) { }\n         case (some[@ast.method](?m)) {\n@@ -954,7 +954,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        _vec.push[@ast.method](meths, fold_method(_env, fld, m));\n+        Vec.push[@ast.method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n@@ -1057,13 +1057,13 @@ fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        _vec.push[@view_item](view_items, new_vi);\n+        Vec.push[@view_item](view_items, new_vi);\n         ast.index_view_item(index, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n-        _vec.push[@item](items, new_item);\n+        Vec.push[@item](items, new_item);\n         ast.index_item(index, new_item);\n     }\n \n@@ -1098,12 +1098,12 @@ fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        _vec.push[@view_item](view_items, new_vi);\n+        Vec.push[@view_item](view_items, new_vi);\n     }\n \n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n-        _vec.push[@native_item](items, new_item);\n+        Vec.push[@native_item](items, new_item);\n         ast.index_native_item(index, new_item);\n     }\n \n@@ -1202,7 +1202,7 @@ fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n-                        &option.t[def] d) -> @ty {\n+                        &Option.t[def] d) -> @ty {\n     ret @respan(sp, ast.ty_path(p, d));\n }\n \n@@ -1228,7 +1228,7 @@ fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n                                vec[ast.field] fields,\n-                               option.t[@expr] base, ann a) -> @expr {\n+                               Option.t[@expr] base, ann a) -> @expr {\n     ret @respan(sp, ast.expr_rec(fields, base, a));\n }\n \n@@ -1243,13 +1243,13 @@ fn identity_fold_expr_self_method[ENV](&ENV env, &span sp, ident id,\n }\n \n fn identity_fold_expr_bind[ENV](&ENV env, &span sp, @expr f,\n-                                vec[option.t[@expr]] args_opt, ann a)\n+                                vec[Option.t[@expr]] args_opt, ann a)\n         -> @expr {\n     ret @respan(sp, ast.expr_bind(f, args_opt, a));\n }\n \n fn identity_fold_expr_spawn[ENV](&ENV env, &span sp,\n-                                 ast.spawn_dom dom, option.t[str] name,\n+                                 ast.spawn_dom dom, Option.t[str] name,\n                                  @expr f, vec[@expr] args, ann a) -> @expr {\n     ret @respan(sp, ast.expr_spawn(dom, name, f, args, a));\n }\n@@ -1278,7 +1278,7 @@ fn identity_fold_expr_cast[ENV](&ENV env, &span sp, @ast.expr e,\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &option.t[@expr] els, ann a) -> @expr {\n+                              &Option.t[@expr] els, ann a) -> @expr {\n     ret @respan(sp, ast.expr_if(cond, thn, els, a));\n }\n \n@@ -1347,14 +1347,14 @@ fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n-                                &path p, &option.t[def] d,\n+                                &path p, &Option.t[def] d,\n                                 ann a) -> @expr {\n     ret @respan(sp, ast.expr_path(p, d, a));\n }\n \n fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n                                &path p, vec[@expr] args,\n-                               option.t[str] body,\n+                               Option.t[str] body,\n                                @expr expanded,\n                                ann a) -> @expr {\n     ret @respan(sp, ast.expr_ext(p, args, body, expanded, a));\n@@ -1373,12 +1373,12 @@ fn identity_fold_expr_cont[ENV](&ENV env, &span sp, ann a) -> @expr {\n }\n \n fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n-                               &option.t[@expr] rv, ann a) -> @expr {\n+                               &Option.t[@expr] rv, ann a) -> @expr {\n     ret @respan(sp, ast.expr_ret(rv, a));\n }\n \n fn identity_fold_expr_put[ENV](&ENV env, &span sp,\n-                               &option.t[@expr] rv, ann a) -> @expr {\n+                               &Option.t[@expr] rv, ann a) -> @expr {\n     ret @respan(sp, ast.expr_put(rv, a));\n }\n \n@@ -1437,7 +1437,7 @@ fn identity_fold_pat_bind[ENV](&ENV e, &span sp, ident i, def_id did, ann a)\n }\n \n fn identity_fold_pat_tag[ENV](&ENV e, &span sp, path p, vec[@pat] args,\n-                              option.t[ast.variant_def] d, ann a) -> @pat {\n+                              Option.t[ast.variant_def] d, ann a) -> @pat {\n     ret @respan(sp, ast.pat_tag(p, args, d, a));\n }\n \n@@ -1468,7 +1468,7 @@ fn identity_fold_item_fn[ENV](&ENV e, &span sp, ident i,\n }\n \n fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, ident i,\n-                                     option.t[str] link_name,\n+                                     Option.t[str] link_name,\n                                      &ast.fn_decl decl,\n                                      vec[ast.ty_param] ty_params,\n                                      def_id id, ann a) -> @native_item {\n@@ -1513,14 +1513,14 @@ fn identity_fold_item_obj[ENV](&ENV e, &span sp, ident i,\n \n fn identity_fold_view_item_use[ENV](&ENV e, &span sp, ident i,\n                                     vec[@meta_item] meta_items,\n-                                    def_id id, option.t[int] cnum)\n+                                    def_id id, Option.t[int] cnum)\n     -> @view_item {\n     ret @respan(sp, ast.view_item_use(i, meta_items, id, cnum));\n }\n \n fn identity_fold_view_item_import[ENV](&ENV e, &span sp, ident i,\n                                        vec[ident] is, def_id id,\n-                                       option.t[def] target_def)\n+                                       Option.t[def] target_def)\n     -> @view_item {\n     ret @respan(sp, ast.view_item_import(i, is, id, target_def));\n }\n@@ -1574,7 +1574,7 @@ fn identity_fold_crate[ENV](&ENV e, &span sp,\n fn identity_fold_obj[ENV](&ENV e,\n                           vec[ast.obj_field] fields,\n                           vec[@ast.method] methods,\n-                          option.t[@ast.method] dtor) -> ast._obj {\n+                          Option.t[@ast.method] dtor) -> ast._obj {\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n "}, {"sha": "f8e7a96e7b06a1ad72cfad1b42e2c45427f59908", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,12 +1,12 @@\n-import std._str;\n-import std._uint;\n-import std._vec;\n-import std.map.hashmap;\n-import std.ebml;\n-import std.io;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.Str;\n+import std.UInt;\n+import std.Vec;\n+import std.Map.hashmap;\n+import std.EBML;\n+import std.IO;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n \n import front.ast;\n import middle.fold;\n@@ -75,12 +75,12 @@ mod Encode {\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n         assert (!cx_uses_abbrevs(cx));\n-        auto sw = io.string_writer();\n+        auto sw = IO.string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();\n     }\n \n-    fn enc_ty(io.writer w, @ctxt cx, ty.t t) {\n+    fn enc_ty(IO.writer w, @ctxt cx, ty.t t) {\n         alt (cx.abbrevs) {\n             case (ac_no_abbrevs) { enc_sty(w, cx, ty.struct(cx.tcx, t)); }\n             case (ac_use_abbrevs(?abbrevs)) {\n@@ -109,8 +109,8 @@ mod Encode {\n                         if (abbrev_len < len) {\n                             // I.e. it's actually an abbreviation.\n                             auto s = (\"#\"\n-                                      + _uint.to_str(pos, 16u) + \":\"\n-                                      + _uint.to_str(len, 16u) + \"#\");\n+                                      + UInt.to_str(pos, 16u) + \":\"\n+                                      + UInt.to_str(len, 16u) + \"#\");\n                             auto a = rec(pos=pos, len=len, s=s);\n                             abbrevs.insert(t, a);\n                         }\n@@ -121,7 +121,7 @@ mod Encode {\n         }\n     }\n \n-    fn enc_mt(io.writer w, @ctxt cx, &ty.mt mt) {\n+    fn enc_mt(IO.writer w, @ctxt cx, &ty.mt mt) {\n         alt (mt.mut) {\n             case (ast.imm)       { }\n             case (ast.mut)       { w.write_char('m'); }\n@@ -130,7 +130,7 @@ mod Encode {\n         enc_ty(w, cx, mt.ty);\n     }\n \n-    fn enc_sty(io.writer w, @ctxt cx, ty.sty st) {\n+    fn enc_sty(IO.writer w, @ctxt cx, ty.sty st) {\n         alt (st) {\n             case (ty.ty_nil) { w.write_char('n'); }\n             case (ty.ty_bool) { w.write_char('b'); }\n@@ -231,14 +231,14 @@ mod Encode {\n         }\n     }\n \n-    fn enc_proto(io.writer w, ast.proto proto) {\n+    fn enc_proto(IO.writer w, ast.proto proto) {\n         alt (proto) {\n             case (ast.proto_iter) { w.write_char('W'); }\n             case (ast.proto_fn) { w.write_char('F'); }\n         }\n     }\n \n-    fn enc_ty_fn(io.writer w, @ctxt cx, vec[ty.arg] args, ty.t out) {\n+    fn enc_ty_fn(IO.writer w, @ctxt cx, vec[ty.arg] args, ty.t out) {\n         w.write_char('[');\n         for (ty.arg arg in args) {\n             if (arg.mode == ast.alias) { w.write_char('&'); }\n@@ -253,70 +253,70 @@ mod Encode {\n \n // Returns a Plain Old LLVM String.\n fn C_postr(str s) -> ValueRef {\n-    ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+    ret llvm.LLVMConstString(Str.buf(s), Str.byte_len(s), False);\n }\n \n \n // Path table encoding\n \n-fn encode_name(&ebml.writer ebml_w, str name) {\n-    ebml.start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(_str.bytes(name));\n-    ebml.end_tag(ebml_w);\n+fn encode_name(&EBML.writer ebml_w, str name) {\n+    EBML.start_tag(ebml_w, tag_paths_data_name);\n+    ebml_w.writer.write(Str.bytes(name));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n-    ebml.end_tag(ebml_w);\n+fn encode_def_id(&EBML.writer ebml_w, &ast.def_id id) {\n+    EBML.start_tag(ebml_w, tag_def_id);\n+    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml.writer ebml_w,\n+fn encode_tag_variant_paths(&EBML.writer ebml_w,\n                             vec[ast.variant] variants,\n                             vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (ast.variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        ebml.start_tag(ebml_w, tag_paths_data_item);\n+        EBML.start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, variant.node.id);\n-        ebml.end_tag(ebml_w);\n+        EBML.end_tag(ebml_w);\n     }\n }\n \n-fn add_to_index(&ebml.writer ebml_w,\n+fn add_to_index(&EBML.writer ebml_w,\n                 vec[str] path,\n                 &mutable vec[tup(str, uint)] index,\n                 str name) {\n     auto full_path = path + vec(name);\n-    index += vec(tup(_str.connect(full_path, \".\"), ebml_w.writer.tell()));\n+    index += vec(tup(Str.connect(full_path, \".\"), ebml_w.writer.tell()));\n }\n \n-fn encode_native_module_item_paths(&ebml.writer ebml_w,\n+fn encode_native_module_item_paths(&EBML.writer ebml_w,\n                                    &ast.native_mod nmod,\n                                    vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n     for (@ast.native_item nitem in nmod.items) {\n         alt (nitem.node) {\n             case (ast.native_item_ty(?id, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.native_item_fn(?id, _, _, _, ?did, _)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_module_item_paths(&ebml.writer ebml_w,\n+fn encode_module_item_paths(&EBML.writer ebml_w,\n                             &ast._mod module,\n                             vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n@@ -325,231 +325,231 @@ fn encode_module_item_paths(&ebml.writer ebml_w,\n         alt (it.node) {\n             case (ast.item_const(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.item_fn(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.item_mod(?id, ?_mod, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_mod);\n+                EBML.start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 encode_module_item_paths(ebml_w, _mod, path + vec(id), index);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.item_native_mod(?id, ?nmod, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_mod);\n+                EBML.start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 encode_native_module_item_paths(ebml_w, nmod, path + vec(id),\n                                                 index);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n             case (ast.item_tag(?id, ?variants, ?tps, ?did, _)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n \n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n             case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n-                ebml.start_tag(ebml_w, tag_paths_data_item);\n+                EBML.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, odid.ctor);\n                 encode_obj_type_id(ebml_w, odid.ty);\n-                ebml.end_tag(ebml_w);\n+                EBML.end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_item_paths(&ebml.writer ebml_w, @ast.crate crate)\n+fn encode_item_paths(&EBML.writer ebml_w, @ast.crate crate)\n         -> vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = vec();\n     let vec[str] path = vec();\n-    ebml.start_tag(ebml_w, tag_paths);\n+    EBML.start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n     ret index;\n }\n \n \n // Item info table encoding\n \n-fn encode_kind(&ebml.writer ebml_w, u8 c) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_kind);\n+fn encode_kind(&EBML.writer ebml_w, u8 c) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_kind);\n     ebml_w.writer.write(vec(c));\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n }\n \n fn def_to_str(ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n-fn encode_type_param_count(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml.write_vint(ebml_w.writer, _vec.len[ast.ty_param](tps));\n-    ebml.end_tag(ebml_w);\n+fn encode_type_param_count(&EBML.writer ebml_w, vec[ast.ty_param] tps) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+    EBML.write_vint(ebml_w.writer, Vec.len[ast.ty_param](tps));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&ebml.writer ebml_w, ast.def_id vid) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(_str.bytes(def_to_str(vid)));\n-    ebml.end_tag(ebml_w);\n+fn encode_variant_id(&EBML.writer ebml_w, ast.def_id vid) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.writer.write(Str.bytes(def_to_str(vid)));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_type(@trans.crate_ctxt cx, &ebml.writer ebml_w, ty.t typ) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_type);\n+fn encode_type(@trans.crate_ctxt cx, &EBML.writer ebml_w, ty.t typ) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n     auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx,\n                             abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n-    Encode.enc_ty(io.new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n-    ebml.end_tag(ebml_w);\n+    Encode.enc_ty(IO.new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_symbol(@trans.crate_ctxt cx, &ebml.writer ebml_w, ast.def_id did) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(_str.bytes(cx.item_symbols.get(did)));\n-    ebml.end_tag(ebml_w);\n+fn encode_symbol(@trans.crate_ctxt cx, &EBML.writer ebml_w, ast.def_id did) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(Str.bytes(cx.item_symbols.get(did)));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_discriminant(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+fn encode_discriminant(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n                        ast.def_id did) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(_str.bytes(cx.discrim_symbols.get(did)));\n-    ebml.end_tag(ebml_w);\n+    EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(Str.bytes(cx.discrim_symbols.get(did)));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_tag_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n-    ebml.end_tag(ebml_w);\n+fn encode_tag_id(&EBML.writer ebml_w, &ast.def_id id) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_tag_id);\n+    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_obj_type_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_items_data_item_obj_type_id);\n-    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n-    ebml.end_tag(ebml_w);\n+fn encode_obj_type_id(&EBML.writer ebml_w, &ast.def_id id) {\n+    EBML.start_tag(ebml_w, tag_items_data_item_obj_type_id);\n+    ebml_w.writer.write(Str.bytes(def_to_str(id)));\n+    EBML.end_tag(ebml_w);\n }\n \n \n-fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+fn encode_tag_variant_info(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n                            ast.def_id did, vec[ast.variant] variants,\n                            &mutable vec[tup(int, uint)] index,\n                            vec[ast.ty_param] ty_params) {\n     for (ast.variant variant in variants) {\n         index += vec(tup(variant.node.id._1, ebml_w.writer.tell()));\n \n-        ebml.start_tag(ebml_w, tag_items_data_item);\n+        EBML.start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n         encode_type(cx, ebml_w, trans.node_ann_type(cx, variant.node.ann));\n-        if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+        if (Vec.len[ast.variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);\n         encode_type_param_count(ebml_w, ty_params);\n-        ebml.end_tag(ebml_w);\n+        EBML.end_tag(ebml_w);\n     }\n }\n \n-fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+fn encode_info_for_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n                         @ast.item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n         case (ast.item_const(_, _, _, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'c' as u8);\n             encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n         case (ast.item_fn(_, _, ?tps, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n         case (ast.item_mod(_, _, ?did)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'm' as u8);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n         case (ast.item_native_mod(_, _, ?did)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'n' as u8);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n         case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n         case (ast.item_tag(?id, ?variants, ?tps, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             for (ast.variant v in variants) {\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n \n             encode_tag_variant_info(cx, ebml_w, did, variants, index, tps);\n         }\n         case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ctor);\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_param_count(ebml_w, tps);\n             auto fn_ty = trans.node_ann_type(cx, ann);\n             encode_type(cx, ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, odid.ctor);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n \n-            ebml.start_tag(ebml_w, tag_items_data_item);\n+            EBML.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, ty.ty_fn_ret(cx.tcx, fn_ty));\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n     }\n }\n \n-fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+fn encode_info_for_native_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n                                @ast.native_item nitem) {\n-    ebml.start_tag(ebml_w, tag_items_data_item);\n+    EBML.start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n@@ -564,14 +564,14 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_symbol(cx, ebml_w, did);\n         }\n     }\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n+fn encode_info_for_items(@trans.crate_ctxt cx, &EBML.writer ebml_w)\n         -> vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = vec();\n \n-    ebml.start_tag(ebml_w, tag_items_data);\n+    EBML.start_tag(ebml_w, tag_items_data);\n     for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n         index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_item(cx, ebml_w, kvp._1, index);\n@@ -581,7 +581,7 @@ fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n         index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n \n     ret index;\n }\n@@ -597,7 +597,7 @@ fn hash_def_num(&int def_num) -> uint {\n \n fn hash_path(&str s) -> uint {\n     auto h = 5381u;\n-    for (u8 ch in _str.bytes(s)) {\n+    for (u8 ch in Str.bytes(s)) {\n         h = ((h << 5u) + h) ^ (ch as uint);\n     }\n     ret h;\n@@ -606,7 +606,7 @@ fn hash_path(&str s) -> uint {\n fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n     let vec[vec[tup(T, uint)]] buckets = vec();\n-    for each (uint i in _uint.range(0u, 256u)) {\n+    for each (uint i in UInt.range(0u, 256u)) {\n         let vec[tup(T, uint)] bucket = vec();\n         buckets += vec(bucket);\n     }\n@@ -619,69 +619,69 @@ fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n     ret buckets;\n }\n \n-fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n-                          fn(io.writer, &T) write_fn) {\n-    auto writer = io.new_writer_(ebml_w.writer);\n+fn encode_index[T](&EBML.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n+                          fn(IO.writer, &T) write_fn) {\n+    auto writer = IO.new_writer_(ebml_w.writer);\n \n-    ebml.start_tag(ebml_w, tag_index);\n+    EBML.start_tag(ebml_w, tag_index);\n \n     let vec[uint] bucket_locs = vec();\n-    ebml.start_tag(ebml_w, tag_index_buckets);\n+    EBML.start_tag(ebml_w, tag_index_buckets);\n     for (vec[tup(T, uint)] bucket in buckets) {\n         bucket_locs += vec(ebml_w.writer.tell());\n \n-        ebml.start_tag(ebml_w, tag_index_buckets_bucket);\n+        EBML.start_tag(ebml_w, tag_index_buckets_bucket);\n         for (tup(T, uint) elt in bucket) {\n-            ebml.start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            EBML.start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n             write_fn(writer, elt._0);\n-            ebml.end_tag(ebml_w);\n+            EBML.end_tag(ebml_w);\n         }\n-        ebml.end_tag(ebml_w);\n+        EBML.end_tag(ebml_w);\n     }\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n \n-    ebml.start_tag(ebml_w, tag_index_table);\n+    EBML.start_tag(ebml_w, tag_index_table);\n     for (uint pos in bucket_locs) {\n         writer.write_be_uint(pos, 4u);\n     }\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n \n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n }\n \n-fn write_str(io.writer writer, &str s) {\n+fn write_str(IO.writer writer, &str s) {\n     writer.write_str(s);\n }\n \n-fn write_int(io.writer writer, &int n) {\n+fn write_int(IO.writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n \n fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n         -> ValueRef {\n-    auto string_w = io.string_writer();\n+    auto string_w = IO.string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n-    auto ebml_w = ebml.create_writer(buf_w);\n+    auto ebml_w = EBML.create_writer(buf_w);\n \n     // Encode and index the paths.\n-    ebml.start_tag(ebml_w, tag_paths);\n+    EBML.start_tag(ebml_w, tag_paths);\n     auto paths_index = encode_item_paths(ebml_w, crate);\n     auto str_writer = write_str;\n     auto path_hasher = hash_path;\n     auto paths_buckets = create_index[str](paths_index, path_hasher);\n     encode_index[str](ebml_w, paths_buckets, str_writer);\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n \n     // Encode and index the items.\n-    ebml.start_tag(ebml_w, tag_items);\n+    EBML.start_tag(ebml_w, tag_items);\n     auto items_index = encode_info_for_items(cx, ebml_w);\n     auto int_writer = write_int;\n     auto item_hasher = hash_def_num;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n     encode_index[int](ebml_w, items_buckets, int_writer);\n-    ebml.end_tag(ebml_w);\n+    EBML.end_tag(ebml_w);\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n@@ -698,9 +698,9 @@ fn write_metadata(@trans.crate_ctxt cx, @ast.crate crate) {\n \n     auto llconst = trans.C_struct(vec(llmeta));\n     auto llglobal = llvm.LLVMAddGlobal(cx.llmod, trans.val_ty(llconst),\n-                                       _str.buf(\"rust_metadata\"));\n+                                       Str.buf(\"rust_metadata\"));\n     llvm.LLVMSetInitializer(llglobal, llconst);\n-    llvm.LLVMSetSection(llglobal, _str.buf(x86.get_meta_sect_name()));\n+    llvm.LLVMSetSection(llglobal, Str.buf(x86.get_meta_sect_name()));\n }\n \n //"}, {"sha": "433b47340524594206ac7936645c07acc3daa165", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -7,15 +7,15 @@ import driver.session;\n import util.common.new_def_hash;\n import util.common.span;\n import util.typestate_ann.ts_ann;\n-import std.map.hashmap;\n-import std.list.list;\n-import std.list.nil;\n-import std.list.cons;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n-import std._str;\n-import std._vec;\n+import std.Map.hashmap;\n+import std.List.list;\n+import std.List.nil;\n+import std.List.cons;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Str;\n+import std.Vec;\n \n tag scope {\n     scope_crate(@ast.crate);\n@@ -43,7 +43,7 @@ tag direction {\n     down;\n }\n \n-type import_map = std.map.hashmap[ast.def_id,def_wrap];\n+type import_map = std.Map.hashmap[ast.def_id,def_wrap];\n \n // A simple wrapper over defs that stores a bit more information about modules\n // and uses so that we can use the regular lookup_name when resolving imports.\n@@ -112,7 +112,7 @@ fn unwrap_def(def_wrap d) -> def {\n }\n \n fn lookup_external_def(session.session sess, int cnum, vec[ident] idents)\n-        -> option.t[def_wrap] {\n+        -> Option.t[def_wrap] {\n     alt (creader.lookup_def(sess, cnum, idents)) {\n         case (none[ast.def]) {\n             ret none[def_wrap];\n@@ -141,7 +141,7 @@ fn lookup_external_def(session.session sess, int cnum, vec[ident] idents)\n \n fn find_final_def(&env e, import_map index,\n                   &span sp, vec[ident] idents, namespace ns,\n-                  option.t[ast.def_id] import_id) -> def_wrap {\n+                  Option.t[ast.def_id] import_id) -> def_wrap {\n \n     // We are given a series of identifiers (p.q.r) and we know that\n     // in the environment 'e' the identifier 'p' was resolved to 'd'. We\n@@ -153,8 +153,8 @@ fn find_final_def(&env e, import_map index,\n         fn found_mod(&env e, &import_map index, &span sp,\n                      vec[ident] idents, namespace ns,\n                      @ast.item i) -> def_wrap {\n-            auto len = _vec.len[ident](idents);\n-            auto rest_idents = _vec.slice[ident](idents, 1u, len);\n+            auto len = Vec.len[ident](idents);\n+            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope],\n                                sess = e.sess);\n             auto tmp_e = update_env_for_item(empty_e, i);\n@@ -178,8 +178,8 @@ fn find_final_def(&env e, import_map index,\n                               vec[ident] idents, namespace ns,\n                               ast.def_id mod_id)\n                 -> def_wrap {\n-            auto len = _vec.len[ident](idents);\n-            auto rest_idents = _vec.slice[ident](idents, 1u, len);\n+            auto len = Vec.len[ident](idents);\n+            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope],\n                                sess = e.sess);\n             auto tmp_e = update_env_for_external_mod(empty_e, mod_id, idents);\n@@ -202,12 +202,12 @@ fn find_final_def(&env e, import_map index,\n \n         fn found_crate(&env e, &import_map index, &span sp,\n                        vec[ident] idents, int cnum) -> def_wrap {\n-            auto len = _vec.len[ident](idents);\n-            auto rest_idents = _vec.slice[ident](idents, 1u, len);\n+            auto len = Vec.len[ident](idents);\n+            auto rest_idents = Vec.slice[ident](idents, 1u, len);\n             alt (lookup_external_def(e.sess, cnum, rest_idents)) {\n                 case (none[def_wrap]) {\n                     e.sess.span_err(sp, #fmt(\"unbound name '%s'\",\n-                                             _str.connect(idents, \".\")));\n+                                             Str.connect(idents, \".\")));\n                     fail;\n                 }\n                 case (some[def_wrap](?dw)) { ret dw; }\n@@ -227,7 +227,7 @@ fn find_final_def(&env e, import_map index,\n             case (_) {\n             }\n         }\n-        auto len = _vec.len[ident](idents);\n+        auto len = Vec.len[ident](idents);\n         if (len == 1u) {\n             ret d;\n         }\n@@ -247,21 +247,21 @@ fn find_final_def(&env e, import_map index,\n             case (def_wrap_use(?vi)) {\n                 alt (vi.node) {\n                     case (ast.view_item_use(_, _, _, ?cnum_opt)) {\n-                        auto cnum = option.get[int](cnum_opt);\n+                        auto cnum = Option.get[int](cnum_opt);\n                         ret found_crate(e, index, sp, idents, cnum);\n                     }\n                 }\n             }\n             case (def_wrap_other(?d)) {\n-                let uint l = _vec.len[ident](idents);\n+                let uint l = Vec.len[ident](idents);\n                 ret def_wrap_expr_field(l, d);\n             }\n         }\n         fail;\n     }\n \n     if (import_id != none[ast.def_id]) {\n-        alt (index.find(option.get[ast.def_id](import_id))) {\n+        alt (index.find(Option.get[ast.def_id](import_id))) {\n             case (some[def_wrap](?x)) {\n                 alt (x) {\n                     case (def_wrap_resolving) {\n@@ -276,7 +276,7 @@ fn find_final_def(&env e, import_map index,\n             case (none[def_wrap]) {\n             }\n         }\n-        index.insert(option.get[ast.def_id](import_id), def_wrap_resolving);\n+        index.insert(Option.get[ast.def_id](import_id), def_wrap_resolving);\n     }\n     auto first = idents.(0);\n     auto d_ = lookup_name_wrapped(e, first, ns, up);\n@@ -288,15 +288,15 @@ fn find_final_def(&env e, import_map index,\n         case (some[tup(@env, def_wrap)](?d)) {\n             auto x = found_something(*d._0, index, sp, idents, ns, d._1);\n             if (import_id != none[ast.def_id]) {\n-                index.insert(option.get[ast.def_id](import_id), x);\n+                index.insert(Option.get[ast.def_id](import_id), x);\n             }\n             ret x;\n         }\n     }\n }\n \n fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n-    -> option.t[tup(@env, def_wrap)] {\n+    -> Option.t[tup(@env, def_wrap)] {\n \n     // log \"resolving name \" + i;\n \n@@ -357,7 +357,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n     }\n \n     fn check_mod(ast.ident i, ast._mod m, namespace ns,\n-                 direction dir) -> option.t[def_wrap] {\n+                 direction dir) -> Option.t[def_wrap] {\n \n         fn visible(ast.ident i, ast._mod m, direction dir) -> bool {\n \n@@ -411,7 +411,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n         }\n     }\n \n-    fn check_native_mod(ast.ident i, ast.native_mod m) -> option.t[def_wrap] {\n+    fn check_native_mod(ast.ident i, ast.native_mod m) -> Option.t[def_wrap] {\n \n         alt (m.index.find(i)) {\n             case (some[ast.native_mod_index_entry](?ent)) {\n@@ -431,17 +431,17 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n     }\n \n     fn handle_fn_decl(ast.ident identifier, &ast.fn_decl decl,\n-                      &vec[ast.ty_param] ty_params) -> option.t[def_wrap] {\n+                      &vec[ast.ty_param] ty_params) -> Option.t[def_wrap] {\n         for (ast.arg a in decl.inputs) {\n-            if (_str.eq(a.ident, identifier)) {\n+            if (Str.eq(a.ident, identifier)) {\n                 auto t = ast.def_arg(a.id);\n                 ret some(def_wrap_other(t));\n             }\n         }\n \n         auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            if (_str.eq(tp, identifier)) {\n+            if (Str.eq(tp, identifier)) {\n                 auto t = ast.def_ty_arg(i);\n                 ret some(def_wrap_other(t));\n             }\n@@ -465,7 +465,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n     }\n \n     fn check_block(ast.ident i, &ast.block_ b, namespace ns)\n-            -> option.t[def_wrap] {\n+            -> Option.t[def_wrap] {\n         alt (b.index.find(i)) {\n             case (some[ast.block_index_entry](?ix)) {\n                 alt(ix) {\n@@ -486,7 +486,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n     }\n \n     fn in_scope(&session.session sess, ast.ident identifier, &scope s,\n-                namespace ns, direction dir) -> option.t[def_wrap] {\n+                namespace ns, direction dir) -> Option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n@@ -500,15 +500,15 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n                     }\n                     case (ast.item_obj(_, ?ob, ?ty_params, _, _)) {\n                         for (ast.obj_field f in ob.fields) {\n-                            if (_str.eq(f.ident, identifier)) {\n+                            if (Str.eq(f.ident, identifier)) {\n                                 auto t = ast.def_obj_field(f.id);\n                                 ret some(def_wrap_other(t));\n                             }\n                         }\n \n                         auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp, identifier)) {\n+                            if (Str.eq(tp, identifier)) {\n                                 auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n@@ -518,7 +518,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n                     case (ast.item_tag(_,?variants,?ty_params,?tag_id,_)) {\n                         auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp, identifier)) {\n+                            if (Str.eq(tp, identifier)) {\n                                 auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n@@ -534,7 +534,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n                     case (ast.item_ty(_, _, ?ty_params, _, _)) {\n                         auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp, identifier)) {\n+                            if (Str.eq(tp, identifier)) {\n                                 auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n@@ -560,7 +560,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n             case (scope_loop(?d)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?local)) {\n-                        if (_str.eq(local.ident, identifier)) {\n+                        if (Str.eq(local.ident, identifier)) {\n                             auto lc = ast.def_local(local.id);\n                             ret some(def_wrap_other(lc));\n                         }\n@@ -605,9 +605,9 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n }\n \n fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n-                option.t[ast.variant_def] old_def,\n+                Option.t[ast.variant_def] old_def,\n                 ann a) -> @ast.pat {\n-    auto len = _vec.len[ast.ident](p.node.idents);\n+    auto len = Vec.len[ast.ident](p.node.idents);\n     auto last_id = p.node.idents.(len - 1u);\n     auto new_def;\n     auto index = new_def_hash[def_wrap]();\n@@ -646,9 +646,9 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n // and split that off as the 'primary' expr_path, with secondary expr_field\n // expressions tacked on the end.\n \n-fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n+fn fold_expr_path(&env e, &span sp, &ast.path p, &Option.t[def] d,\n                   ann a) -> @ast.expr {\n-    auto n_idents = _vec.len[ast.ident](p.node.idents);\n+    auto n_idents = Vec.len[ast.ident](p.node.idents);\n     assert (n_idents != 0u);\n \n     auto index = new_def_hash[def_wrap]();\n@@ -669,7 +669,7 @@ fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n         }\n     }\n     auto path_elems =\n-        _vec.slice[ident](p.node.idents, 0u, path_len);\n+        Vec.slice[ident](p.node.idents, 0u, path_len);\n     auto p_ = rec(node=rec(idents = path_elems with p.node) with p);\n     auto d_ = some(unwrap_def(d));\n     auto ex = @fold.respan[ast.expr_](sp, ast.expr_path(p_, d_, a));\n@@ -685,9 +685,9 @@ fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n fn fold_view_item_import(&env e, &span sp,\n                          import_map index, ident i,\n                          vec[ident] is, ast.def_id id,\n-                         option.t[def] target_id) -> @ast.view_item {\n+                         Option.t[def] target_id) -> @ast.view_item {\n     // Produce errors for invalid imports\n-    auto len = _vec.len[ast.ident](is);\n+    auto len = Vec.len[ast.ident](is);\n     auto last_id = is.(len - 1u);\n     auto d = find_final_def(e, index, sp, is, ns_value, some(id));\n     alt (d) {\n@@ -698,12 +698,12 @@ fn fold_view_item_import(&env e, &span sp,\n         case (_) {\n         }\n     }\n-    let option.t[def] target_def = some(unwrap_def(d));\n+    let Option.t[def] target_def = some(unwrap_def(d));\n     ret @fold.respan[ast.view_item_](sp, ast.view_item_import(i, is, id,\n                                                               target_def));\n }\n \n-fn fold_ty_path(&env e, &span sp, ast.path p, &option.t[def] d) -> @ast.ty {\n+fn fold_ty_path(&env e, &span sp, ast.path p, &Option.t[def] d) -> @ast.ty {\n     auto index = new_def_hash[def_wrap]();\n     auto d = find_final_def(e, index, sp, p.node.idents, ns_type,\n                             none[ast.def_id]);"}, {"sha": "9f10097de3bfbf7b78d7612282620a4793271d1b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 201, "deletions": 201, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,14 +1,14 @@\n-import std._int;\n-import std._str;\n-import std._uint;\n-import std._vec;\n-import std._str.rustrt.sbuf;\n-import std._vec.rustrt.vbuf;\n-import std.map;\n-import std.map.hashmap;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.Int;\n+import std.Str;\n+import std.UInt;\n+import std.Vec;\n+import std.Str.rustrt.sbuf;\n+import std.Vec.rustrt.vbuf;\n+import std.Map;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n \n import front.ast;\n import front.creader;\n@@ -110,7 +110,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ty.t, TypeRef] lltypes,\n                             @glue_fns glues,\n                             namegen names,\n-                            std.sha1.sha1 sha,\n+                            std.SHA1.sha1 sha,\n                             hashmap[ty.t, str] type_sha1s,\n                             hashmap[ty.t, metadata.ty_abbrev] type_abbrevs,\n                             ty.ctxt tcx);\n@@ -129,8 +129,8 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n                          mutable BasicBlockRef llallocas,\n-                         mutable option.t[self_vt] llself,\n-                         mutable option.t[ValueRef] lliterbody,\n+                         mutable Option.t[self_vt] llself,\n+                         mutable Option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n@@ -145,7 +145,7 @@ tag cleanup {\n \n tag block_kind {\n     SCOPE_BLOCK;\n-    LOOP_SCOPE_BLOCK(option.t[@block_ctxt], @block_ctxt);\n+    LOOP_SCOPE_BLOCK(Option.t[@block_ctxt], @block_ctxt);\n     NON_SCOPE_BLOCK;\n }\n \n@@ -156,7 +156,7 @@ state type block_ctxt = rec(BasicBlockRef llbb,\n                             mutable vec[cleanup] cleanups,\n                             @fn_ctxt fcx);\n \n-// FIXME: we should be able to use option.t[@block_parent] here but\n+// FIXME: we should be able to use Option.t[@block_parent] here but\n // the infinite-tag check in rustboot gets upset.\n \n tag block_parent {\n@@ -177,7 +177,7 @@ fn extend_path(@local_ctxt cx, str name) -> @local_ctxt {\n }\n \n fn path_name(vec[str] path) -> str {\n-    ret _str.connect(path, sep());\n+    ret Str.connect(path, sep());\n }\n \n \n@@ -192,7 +192,7 @@ fn get_type_sha1(@crate_ctxt ccx, ty.t t) -> str {\n             // to be independent of one another in the crate.\n             auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata.ac_no_abbrevs);\n             ccx.sha.input_str(metadata.Encode.ty_str(cx, t));\n-            hash = _str.substr(ccx.sha.result_str(), 0u, 16u);\n+            hash = Str.substr(ccx.sha.result_str(), 0u, 16u);\n             ccx.type_sha1s.insert(t, hash);\n         }\n     }\n@@ -306,8 +306,8 @@ fn T_char() -> TypeRef {\n \n fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n     ret llvm.LLVMFunctionType(output,\n-                              _vec.buf[TypeRef](inputs),\n-                              _vec.len[TypeRef](inputs),\n+                              Vec.buf[TypeRef](inputs),\n+                              Vec.len[TypeRef](inputs),\n                               False);\n }\n \n@@ -321,8 +321,8 @@ fn T_ptr(TypeRef t) -> TypeRef {\n }\n \n fn T_struct(vec[TypeRef] elts) -> TypeRef {\n-    ret llvm.LLVMStructType(_vec.buf[TypeRef](elts),\n-                            _vec.len[TypeRef](elts),\n+    ret llvm.LLVMStructType(Vec.buf[TypeRef](elts),\n+                            Vec.len[TypeRef](elts),\n                             False);\n }\n \n@@ -352,9 +352,9 @@ fn T_task(type_names tn) -> TypeRef {\n fn T_tydesc_field(type_names tn, int field) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n     let vec[TypeRef] tydesc_elts =\n-        _vec.init_elt[TypeRef](T_nil(), abi.n_tydesc_fields as uint);\n+        Vec.init_elt[TypeRef](T_nil(), abi.n_tydesc_fields as uint);\n     llvm.LLVMGetStructElementTypes(T_tydesc(tn),\n-                                   _vec.buf[TypeRef](tydesc_elts));\n+                                   Vec.buf[TypeRef](tydesc_elts));\n     auto t = llvm.LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n@@ -372,7 +372,7 @@ fn T_glue_fn(type_names tn) -> TypeRef {\n \n fn T_dtor(@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n     ret type_of_fn_full(ccx, ast.proto_fn, some[TypeRef](llself_ty),\n-                        _vec.empty[ty.arg](), ty.mk_nil(ccx.tcx), 0u);\n+                        Vec.empty[ty.arg](), ty.mk_nil(ccx.tcx), 0u);\n }\n \n fn T_cmp_glue_fn(type_names tn) -> TypeRef {\n@@ -535,7 +535,7 @@ fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n }\n \n fn T_tag(type_names tn, uint size) -> TypeRef {\n-    auto s = \"tag_\" + _uint.to_str(size, 10u);\n+    auto s = \"tag_\" + UInt.to_str(size, 10u);\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n     }\n@@ -559,7 +559,7 @@ fn T_opaque_tag_ptr(type_names tn) -> TypeRef {\n }\n \n fn T_captured_tydescs(type_names tn, uint n) -> TypeRef {\n-    ret T_struct(_vec.init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n+    ret T_struct(Vec.init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n }\n \n fn T_obj_ptr(type_names tn, uint n_captured_tydescs) -> TypeRef {\n@@ -623,7 +623,7 @@ fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n \n fn type_of_fn_full(@crate_ctxt cx,\n                    ast.proto proto,\n-                   option.t[TypeRef] obj_self,\n+                   Option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n                    ty.t output,\n                    uint ty_param_count) -> TypeRef {\n@@ -811,7 +811,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     }\n \n     assert (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_short_str(cx.tcx, t)),\n+    llvm.LLVMAddTypeName(cx.llmod, Str.buf(ty.ty_to_short_str(cx.tcx, t)),\n                          llty);\n     cx.lltypes.insert(t, llty);\n     ret llty;\n@@ -872,7 +872,7 @@ fn sanitize(str s) -> str {\n                         c != (' ' as u8) && c != ('\\t' as u8) &&\n                         c != (';' as u8)) {\n                         auto v = vec(c);\n-                        result += _str.from_bytes(v);\n+                        result += Str.from_bytes(v);\n                     }\n                 }\n             }\n@@ -894,15 +894,15 @@ fn C_integral(int i, TypeRef t) -> ValueRef {\n     //\n     // ret llvm.LLVMConstInt(T_int(), t as LLVM.ULongLong, False);\n     //\n-    ret llvm.LLVMConstIntOfString(t, _str.buf(istr(i)), 10);\n+    ret llvm.LLVMConstIntOfString(t, Str.buf(istr(i)), 10);\n }\n \n fn C_float(str s) -> ValueRef {\n-    ret llvm.LLVMConstRealOfString(T_float(), _str.buf(s));\n+    ret llvm.LLVMConstRealOfString(T_float(), Str.buf(s));\n }\n \n fn C_floating(str s, TypeRef t) -> ValueRef {\n-    ret llvm.LLVMConstRealOfString(t, _str.buf(s));\n+    ret llvm.LLVMConstRealOfString(t, Str.buf(s));\n }\n \n fn C_nil() -> ValueRef {\n@@ -929,9 +929,9 @@ fn C_i8(uint i) -> ValueRef {\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n-    auto sc = llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+    auto sc = llvm.LLVMConstString(Str.buf(s), Str.byte_len(s), False);\n     auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(sc),\n-                                _str.buf(cx.names.next(\"str\")));\n+                                Str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, sc);\n     llvm.LLVMSetGlobalConstant(g, True);\n     llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n@@ -941,15 +941,15 @@ fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n \n // A rust boxed-and-length-annotated string.\n fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n-    auto len = _str.byte_len(s);\n+    auto len = Str.byte_len(s);\n     auto box = C_struct(vec(C_int(abi.const_refcount as int),\n                             C_int(len + 1u as int), // 'alloc'\n                             C_int(len + 1u as int), // 'fill'\n                             C_int(0),               // 'pad'\n-                            llvm.LLVMConstString(_str.buf(s),\n+                            llvm.LLVMConstString(Str.buf(s),\n                                                  len, False)));\n     auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(box),\n-                                _str.buf(cx.names.next(\"str\")));\n+                                Str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, box);\n     llvm.LLVMSetGlobalConstant(g, True);\n     llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n@@ -964,24 +964,24 @@ fn C_zero_byte_arr(uint size) -> ValueRef {\n         elts += vec(C_integral(0, T_i8()));\n         i += 1u;\n     }\n-    ret llvm.LLVMConstArray(T_i8(), _vec.buf[ValueRef](elts),\n-                            _vec.len[ValueRef](elts));\n+    ret llvm.LLVMConstArray(T_i8(), Vec.buf[ValueRef](elts),\n+                            Vec.len[ValueRef](elts));\n }\n \n fn C_struct(vec[ValueRef] elts) -> ValueRef {\n-    ret llvm.LLVMConstStruct(_vec.buf[ValueRef](elts),\n-                             _vec.len[ValueRef](elts),\n+    ret llvm.LLVMConstStruct(Vec.buf[ValueRef](elts),\n+                             Vec.len[ValueRef](elts),\n                              False);\n }\n \n fn C_array(TypeRef ty, vec[ValueRef] elts) -> ValueRef {\n-    ret llvm.LLVMConstArray(ty, _vec.buf[ValueRef](elts),\n-                            _vec.len[ValueRef](elts));\n+    ret llvm.LLVMConstArray(ty, Vec.buf[ValueRef](elts),\n+                            Vec.len[ValueRef](elts));\n }\n \n fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n-        llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n+        llvm.LLVMAddFunction(llmod, Str.buf(name), llty);\n     llvm.LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n@@ -1026,7 +1026,7 @@ fn decl_native_glue(ModuleRef llmod, type_names tn,\n         args += vec(T_int()); // taskptr, will not be passed\n     }\n \n-    args += _vec.init_elt[TypeRef](T_int(), n as uint);\n+    args += Vec.init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n@@ -1047,14 +1047,14 @@ fn get_extern_const(&hashmap[str, ValueRef] externs,\n     if (externs.contains_key(name)) {\n         ret externs.get(name);\n     }\n-    auto c = llvm.LLVMAddGlobal(llmod, ty, _str.buf(name));\n+    auto c = llvm.LLVMAddGlobal(llmod, ty, Str.buf(name));\n     externs.insert(name, c);\n     ret c;\n }\n \n fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n                      ModuleRef llmod, str name, int n_args) -> ValueRef {\n-    auto inputs = _vec.init_elt[TypeRef](T_int(), n_args as uint);\n+    auto inputs = Vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib.llvm.LLVMCCallConv, t);\n@@ -1075,7 +1075,7 @@ fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n                      &hashmap[str, ValueRef] externs,\n                      type_names tn, ModuleRef llmod, str name,\n                      bool pass_task, vec[ValueRef] args) -> ValueRef {\n-    let int n = (_vec.len[ValueRef](args) as int);\n+    let int n = (Vec.len[ValueRef](args) as int);\n     let ValueRef llnative = get_simple_extern_fn(externs, llmod, name, n);\n     llnative = llvm.LLVMConstPointerCast(llnative, T_int());\n \n@@ -1395,7 +1395,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n     fn split_type(@crate_ctxt ccx, ty.t t, vec[int] ixs, uint n)\n         -> rec(vec[ty.t] prefix, ty.t target) {\n \n-        let uint len = _vec.len[int](ixs);\n+        let uint len = Vec.len[int](ixs);\n \n         // We don't support 0-index or 1-index GEPs. The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n@@ -1417,7 +1417,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n         let vec[ty.t] prefix = vec();\n         let int i = 0;\n         while (i < ix) {\n-            _vec.push[ty.t](prefix,\n+            Vec.push[ty.t](prefix,\n                             ty.get_element_type(ccx.tcx, t, i as uint));\n             i += 1 ;\n         }\n@@ -1617,8 +1617,8 @@ fn mk_derived_tydesc(@block_ctxt cx, ty.t t, bool escapes) -> result {\n     let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n     auto tys = linearize_ty_params(cx, t);\n \n-    assert (n_params == _vec.len[uint](tys._0));\n-    assert (n_params == _vec.len[ValueRef](tys._1));\n+    assert (n_params == Vec.len[uint](tys._0));\n+    assert (n_params == Vec.len[ValueRef](tys._1));\n \n     auto root = get_static_tydesc(cx, t, tys._0).tydesc;\n \n@@ -1746,7 +1746,7 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) -> @tydesc_info {\n \n     auto name = mangle_name_by_type_only(ccx, t, \"tydesc\");\n     auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n-                                   _str.buf(name));\n+                                   Str.buf(name));\n     auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n                                llsize,\n                                llalign,\n@@ -1827,20 +1827,20 @@ fn make_generic_glue(@local_ctxt cx,\n         llty = T_ptr(type_of(cx.ccx, t));\n     }\n \n-    auto ty_param_count = _vec.len[uint](ty_params);\n+    auto ty_param_count = Vec.len[uint](ty_params);\n \n     auto lltyparams = llvm.LLVMGetParam(llfn, 3u);\n \n-    auto lltydescs = _vec.empty_mut[ValueRef]();\n+    auto lltydescs = Vec.empty_mut[ValueRef]();\n     auto p = 0u;\n     while (p < ty_param_count) {\n         auto llparam = bcx.build.GEP(lltyparams, vec(C_int(p as int)));\n         llparam = bcx.build.Load(llparam);\n-        _vec.grow_set[ValueRef](lltydescs, ty_params.(p), 0 as ValueRef,\n+        Vec.grow_set[ValueRef](lltydescs, ty_params.(p), 0 as ValueRef,\n                                 llparam);\n         p += 1u;\n     }\n-    bcx.fcx.lltydescs = _vec.freeze[ValueRef](lltydescs);\n+    bcx.fcx.lltydescs = Vec.freeze[ValueRef](lltydescs);\n \n     auto llrawptr0 = llvm.LLVMGetParam(llfn, 4u);\n     auto llval0 = bcx.build.BitCast(llrawptr0, llty);\n@@ -2157,7 +2157,7 @@ fn make_cmp_glue(@block_ctxt cx,\n          */\n \n         auto flag = alloca(scx, T_i1());\n-        llvm.LLVMSetValueName(flag, _str.buf(\"flag\"));\n+        llvm.LLVMSetValueName(flag, Str.buf(\"flag\"));\n \n         auto r;\n         if (ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -2378,7 +2378,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n             for (ast.variant variant in variants) {\n                 auto ctor_ty = node_ann_type(cx, variant.node.ann);\n                 let vec[ty.t] arg_tys = vec();\n-                if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+                if (Vec.len[ast.variant_arg](variant.node.args) > 0u) {\n                     for (ty.arg a in ty.ty_fn_args(cx.tcx, ctor_ty)) {\n                         arg_tys += vec(a.ty);\n                     }\n@@ -2399,7 +2399,7 @@ fn tag_variant_with_id(@crate_ctxt cx,\n     auto variants = tag_variants(cx, tag_id);\n \n     auto i = 0u;\n-    while (i < _vec.len[variant_info](variants)) {\n+    while (i < Vec.len[variant_info](variants)) {\n         auto variant = variants.(i);\n         if (common.def_eq(variant.id, variant_id)) {\n             ret variant;\n@@ -2495,7 +2495,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         }\n         case (ty.ty_tag(?tid, ?tps)) {\n             auto variants = tag_variants(cx.fcx.lcx.ccx, tid);\n-            auto n_variants = _vec.len[variant_info](variants);\n+            auto n_variants = Vec.len[variant_info](variants);\n \n             // Cast the tags to types we can GEP into.\n             auto lltagty = T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn);\n@@ -2532,10 +2532,10 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             for (variant_info variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n                                                      \"tag-iter-variant-\" +\n-                                                     _uint.to_str(i, 10u));\n+                                                     UInt.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n-                if (_vec.len[ty.t](variant.args) > 0u) {\n+                if (Vec.len[ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n                     alt (ty.struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n@@ -3386,12 +3386,12 @@ fn join_results(@block_ctxt parent_cx,\n         }\n     }\n \n-    alt (_vec.len[result](live)) {\n+    alt (Vec.len[result](live)) {\n         case (0u) {\n             // No incoming edges are live, so we're in dead-code-land.\n             // Arbitrarily pick the first dead edge, since the caller\n             // is just going to propagate it outward.\n-            assert (_vec.len[result](ins) >= 1u);\n+            assert (Vec.len[result](ins) >= 1u);\n             ret ins.(0);\n         }\n \n@@ -3408,7 +3408,7 @@ fn join_results(@block_ctxt parent_cx,\n }\n \n fn trans_if(@block_ctxt cx, @ast.expr cond,\n-            &ast.block thn, &option.t[@ast.expr] els) -> result {\n+            &ast.block thn, &Option.t[@ast.expr] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -3472,7 +3472,7 @@ fn trans_for(@block_ctxt cx,\n \n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n         auto scope_cx =\n-            new_loop_scope_block_ctxt(cx, option.some[@block_ctxt](next_cx),\n+            new_loop_scope_block_ctxt(cx, Option.some[@block_ctxt](next_cx),\n                                       outer_next_cx, \"for loop scope\");\n \n         cx.build.Br(scope_cx.llbb);\n@@ -3517,15 +3517,15 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n     fn walk_expr(env e, @ast.expr expr) {\n         alt (expr.node) {\n             case (ast.expr_path(?path, ?d, _)) {\n-                alt (option.get[ast.def](d)) {\n+                alt (Option.get[ast.def](d)) {\n                     case (ast.def_arg(?did)) {\n-                        _vec.push[ast.def_id](e.refs, did);\n+                        Vec.push[ast.def_id](e.refs, did);\n                     }\n                     case (ast.def_local(?did)) {\n-                        _vec.push[ast.def_id](e.refs, did);\n+                        Vec.push[ast.def_id](e.refs, did);\n                     }\n                     case (ast.def_upvar(?did)) {\n-                        _vec.push[ast.def_id](e.refs, did);\n+                        Vec.push[ast.def_id](e.refs, did);\n                     }\n                     case (_) {}\n                 }\n@@ -3606,7 +3606,7 @@ fn trans_for_each(@block_ctxt cx,\n     }\n \n     auto upvars = collect_upvars(cx, body, decl_id);\n-    auto upvar_count = _vec.len[ast.def_id](upvars);\n+    auto upvar_count = Vec.len[ast.def_id](upvars);\n \n     auto llbindingsptr;\n     if (upvar_count > 0u) {\n@@ -3645,7 +3645,7 @@ fn trans_for_each(@block_ctxt cx,\n     }\n \n     // Create an environment and populate it with the bindings.\n-    auto tydesc_count = _vec.len[ValueRef](cx.fcx.lltydescs);\n+    auto tydesc_count = Vec.len[ValueRef](cx.fcx.lltydescs);\n     auto llenvptrty = T_closure_ptr(lcx.ccx.tn, T_ptr(T_nil()),\n                                     val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm.LLVMGetElementType(llenvptrty));\n@@ -3776,7 +3776,7 @@ fn trans_while(@block_ctxt cx, @ast.expr cond,\n \n     auto cond_cx = new_scope_block_ctxt(cx, \"while cond\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto body_cx = new_loop_scope_block_ctxt(cx, option.none[@block_ctxt],\n+    auto body_cx = new_loop_scope_block_ctxt(cx, Option.none[@block_ctxt],\n                                              next_cx, \"while loop body\");\n \n     auto body_res = trans_block(body_cx, body);\n@@ -3795,7 +3795,7 @@ fn trans_do_while(@block_ctxt cx, &ast.block body,\n                   @ast.expr cond) -> result {\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto body_cx = new_loop_scope_block_ctxt(cx, option.none[@block_ctxt],\n+    auto body_cx = new_loop_scope_block_ctxt(cx, Option.none[@block_ctxt],\n                                              next_cx, \"do-while loop body\");\n \n     auto body_res = trans_block(body_cx, body);\n@@ -3834,7 +3834,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                                              vec(C_int(0), C_int(0)));\n             auto lldiscrim = cx.build.Load(lldiscrimptr);\n \n-            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto vdef = Option.get[ast.variant_def](vdef_opt);\n             auto variant_id = vdef._1;\n             auto variant_tag = 0;\n \n@@ -3857,7 +3857,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n             auto ty_params = node_ann_ty_params(ann);\n \n-            if (_vec.len[@ast.pat](subpats) > 0u) {\n+            if (Vec.len[@ast.pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n                     vec(C_int(0), C_int(1)));\n                 auto i = 0;\n@@ -3899,18 +3899,18 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat,\n                 auto rslt = alloc_ty(cx, t);\n                 auto dst = rslt.val;\n                 auto bcx = rslt.bcx;\n-                llvm.LLVMSetValueName(dst, _str.buf(id));\n+                llvm.LLVMSetValueName(dst, Str.buf(id));\n                 bcx.fcx.lllocals.insert(def_id, dst);\n                 bcx.cleanups +=\n                     vec(clean(bind drop_slot(_, dst, t)));\n                 ret copy_ty(bcx, INIT, dst, llval, t);\n             }\n         }\n         case (ast.pat_tag(_, ?subpats, ?vdef_opt, ?ann)) {\n-            if (_vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n+            if (Vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n \n             // Get the appropriate variant for this tag.\n-            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto vdef = Option.get[ast.variant_def](vdef_opt);\n \n             auto lltagptr = cx.build.PointerCast(llval,\n                 T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n@@ -3982,9 +3982,9 @@ type generic_info = rec(ty.t item_type,\n \n type lval_result = rec(result res,\n                        bool is_mem,\n-                       option.t[generic_info] generic,\n-                       option.t[ValueRef] llobj,\n-                       option.t[ty.t] method_ty);\n+                       Option.t[generic_info] generic,\n+                       Option.t[ValueRef] llobj,\n+                       Option.t[ty.t] method_ty);\n \n fn lval_mem(@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n@@ -4035,18 +4035,18 @@ fn lval_generic_fn(@block_ctxt cx,\n         }\n         case (ast.ann_type(?monoty_, ?tps, _)) {\n             monoty = monoty_;\n-            tys = option.get[vec[ty.t]](tps);\n+            tys = Option.get[vec[ty.t]](tps);\n         }\n     }\n \n-    if (_vec.len[ty.t](tys) != 0u) {\n+    if (Vec.len[ty.t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = vec();\n         for (ty.t t in tys) {\n             // TODO: Doesn't always escape.\n             auto td = get_tydesc(bcx, t, true);\n             bcx = td.bcx;\n-            _vec.push[ValueRef](tydescs, td.val);\n+            Vec.push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec( item_type = tpt._1,\n                         tydescs = tydescs );\n@@ -4065,7 +4065,7 @@ fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n             assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n             auto sym = creader.get_symbol(lcx.ccx.sess, vid);\n             auto gvar = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                           _str.buf(sym));\n+                                           Str.buf(sym));\n             llvm.LLVMSetLinkage(gvar,\n                                 lib.llvm.LLVMExternalLinkage as llvm.Linkage);\n             llvm.LLVMSetGlobalConstant(gvar, True);\n@@ -4076,7 +4076,7 @@ fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n     }\n }\n \n-fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n+fn trans_path(@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n               &ast.ann ann) -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n@@ -4246,10 +4246,10 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     auto unit_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    llvm.LLVMSetValueName(unit_sz.val, _str.buf(\"unit_sz\"));\n+    llvm.LLVMSetValueName(unit_sz.val, Str.buf(\"unit_sz\"));\n \n     auto scaled_ix = bcx.build.Mul(ix_val, unit_sz.val);\n-    llvm.LLVMSetValueName(scaled_ix, _str.buf(\"scaled_ix\"));\n+    llvm.LLVMSetValueName(scaled_ix, Str.buf(\"scaled_ix\"));\n \n     auto lim = bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n     lim = bcx.build.Load(lim);\n@@ -4369,7 +4369,7 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n fn trans_bind_thunk(@local_ctxt cx,\n                     ty.t incoming_fty,\n                     ty.t outgoing_fty,\n-                    vec[option.t[@ast.expr]] args,\n+                    vec[Option.t[@ast.expr]] args,\n                     ty.t closure_ty,\n                     vec[ty.t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n@@ -4433,7 +4433,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     let vec[TypeRef] llout_arg_tys =\n         type_of_explicit_args(cx.ccx, outgoing_args);\n \n-    for (option.t[@ast.expr] arg in args) {\n+    for (Option.t[@ast.expr] arg in args) {\n \n         auto out_arg = outgoing_args.(outgoing_arg_index);\n         auto llout_arg_ty = llout_arg_tys.(outgoing_arg_index);\n@@ -4516,20 +4516,20 @@ fn trans_bind_thunk(@local_ctxt cx,\n }\n \n fn trans_bind(@block_ctxt cx, @ast.expr f,\n-              vec[option.t[@ast.expr]] args,\n+              vec[Option.t[@ast.expr]] args,\n               &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n         cx.fcx.lcx.ccx.sess.unimpl(\"re-binding existing function\");\n     } else {\n         let vec[@ast.expr] bound = vec();\n \n-        for (option.t[@ast.expr] argopt in args) {\n+        for (Option.t[@ast.expr] argopt in args) {\n             alt (argopt) {\n                 case (none[@ast.expr]) {\n                 }\n                 case (some[@ast.expr](?e)) {\n-                    _vec.push[@ast.expr](bound, e);\n+                    Vec.push[@ast.expr](bound, e);\n                 }\n             }\n         }\n@@ -4547,9 +4547,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 lltydescs = ginfo.tydescs;\n             }\n         }\n-        auto ty_param_count = _vec.len[ValueRef](lltydescs);\n+        auto ty_param_count = Vec.len[ValueRef](lltydescs);\n \n-        if (_vec.len[@ast.expr](bound) == 0u && ty_param_count == 0u) {\n+        if (Vec.len[@ast.expr](bound) == 0u && ty_param_count == 0u) {\n             // Trivial 'binding': just return the static pair-ptr.\n             ret f_res.res;\n         } else {\n@@ -4565,8 +4565,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n \n-                _vec.push[ValueRef](bound_vals, arg.val);\n-                _vec.push[ty.t](bound_tys,\n+                Vec.push[ValueRef](bound_vals, arg.val);\n+                Vec.push[ty.t](bound_tys,\n                                  ty.expr_ty(cx.fcx.lcx.ccx.tcx, e));\n \n                 i += 1u;\n@@ -4582,7 +4582,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             let ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tcx);\n \n             let vec[ty.t] captured_tys =\n-                _vec.init_elt[ty.t](tydesc_ty, ty_param_count);\n+                Vec.init_elt[ty.t](tydesc_ty, ty_param_count);\n \n             let vec[ty.t] closure_tys =\n                 vec(tydesc_ty,\n@@ -4778,9 +4778,9 @@ fn trans_arg_expr(@block_ctxt cx,\n \n fn trans_args(@block_ctxt cx,\n               ValueRef llenv,\n-              option.t[ValueRef] llobj,\n-              option.t[generic_info] gen,\n-              option.t[ValueRef] lliterbody,\n+              Option.t[ValueRef] llobj,\n+              Option.t[generic_info] gen,\n+              Option.t[ValueRef] lliterbody,\n               &vec[@ast.expr] es,\n               ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n@@ -4869,7 +4869,7 @@ fn trans_args(@block_ctxt cx,\n }\n \n fn trans_call(@block_ctxt cx, @ast.expr f,\n-              option.t[ValueRef] lliterbody,\n+              Option.t[ValueRef] lliterbody,\n               vec[@ast.expr] args,\n               &ast.ann ann) -> result {\n \n@@ -4997,7 +4997,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    auto data_sz = bcx.build.Mul(C_int(_vec.len[@ast.expr](args) as int),\n+    auto data_sz = bcx.build.Mul(C_int(Vec.len[@ast.expr](args) as int),\n                                  unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n@@ -5015,8 +5015,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n     auto pseudo_tup_ty =\n         ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n-                      _vec.init_elt[ty.t](unit_ty,\n-                                           _vec.len[@ast.expr](args)));\n+                      Vec.init_elt[ty.t](unit_ty,\n+                                           Vec.len[@ast.expr](args)));\n     let int i = 0;\n \n     for (@ast.expr e in args) {\n@@ -5056,7 +5056,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n }\n \n fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n-             option.t[@ast.expr] base, &ast.ann ann) -> result {\n+             Option.t[@ast.expr] base, &ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5093,7 +5093,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n         auto src_res = res(bcx, C_nil());\n \n         for (ast.field f in fields) {\n-            if (_str.eq(f.ident, tf.ident)) {\n+            if (Str.eq(f.ident, tf.ident)) {\n                 expr_provided = true;\n                 src_res = trans_expr(bcx, f.expr);\n             }\n@@ -5326,13 +5326,13 @@ fn load_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n \n fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n-    auto modname = _str.connect(lcx.module_path, \".\");\n+    auto modname = Str.connect(lcx.module_path, \".\");\n     auto global;\n     if (lcx.ccx.module_data.contains_key(modname)) {\n         global = lcx.ccx.module_data.get(modname);\n     } else {\n         global = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                    _str.buf(\"_rust_mod_log_\" + modname));\n+                                    Str.buf(\"_rust_mod_log_\" + modname));\n         llvm.LLVMSetGlobalConstant(global, False);\n         llvm.LLVMSetInitializer(global, C_null(T_int()));\n         llvm.LLVMSetLinkage(global, lib.llvm.LLVMInternalLinkage\n@@ -5418,7 +5418,7 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_fail(@block_ctxt cx, option.t[common.span] sp_opt, str fail_str)\n+fn trans_fail(@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n         -> result {\n     auto V_fail_str = p2i(C_cstr(cx.fcx.lcx.ccx, fail_str));\n \n@@ -5442,7 +5442,7 @@ fn trans_fail(@block_ctxt cx, option.t[common.span] sp_opt, str fail_str)\n     ret res(sub.bcx, C_nil());\n }\n \n-fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n+fn trans_put(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     auto llcallee = C_nil();\n     auto llenv = C_nil();\n \n@@ -5490,7 +5490,7 @@ fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n                     bcx.build.Br(_break.llbb);\n                 } else {\n                     alt (_cont) {\n-                        case (option.some[@block_ctxt](?_cont)) {\n+                        case (Option.some[@block_ctxt](?_cont)) {\n                             bcx.build.Br(_cont.llbb);\n                         }\n                         case (_) {\n@@ -5519,7 +5519,7 @@ fn trans_cont(@block_ctxt cx) -> result {\n }\n \n \n-fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n+fn trans_ret(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     auto bcx = cx;\n     auto val = C_nil();\n \n@@ -5765,7 +5765,7 @@ fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n     let vec[cleanup] cleanups = vec();\n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(cx.llfn,\n-                                  _str.buf(cx.lcx.ccx.names.next(name)));\n+                                  Str.buf(cx.lcx.ccx.names.next(name)));\n \n     ret @rec(llbb=llbb,\n              build=new_builder(llbb),\n@@ -5786,7 +5786,7 @@ fn new_scope_block_ctxt(@block_ctxt bcx, str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n);\n }\n \n-fn new_loop_scope_block_ctxt(@block_ctxt bcx, option.t[@block_ctxt] _cont,\n+fn new_loop_scope_block_ctxt(@block_ctxt bcx, Option.t[@block_ctxt] _cont,\n                              @block_ctxt _break, str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n                        LOOP_SCOPE_BLOCK(_cont, _break), n);\n@@ -5803,10 +5803,10 @@ fn trans_block_cleanups(@block_ctxt cx,\n     auto bcx = cx;\n \n     if (cleanup_cx.kind == NON_SCOPE_BLOCK) {\n-        assert (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n+        assert (Vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n \n-    auto i = _vec.len[cleanup](cleanup_cx.cleanups);\n+    auto i = Vec.len[cleanup](cleanup_cx.cleanups);\n     while (i > 0u) {\n         i -= 1u;\n         auto c = cleanup_cx.cleanups.(i);\n@@ -5983,7 +5983,7 @@ fn new_fn_ctxt(@local_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n \n     let BasicBlockRef llallocas =\n-        llvm.LLVMAppendBasicBlock(llfndecl, _str.buf(\"allocas\"));\n+        llvm.LLVMAppendBasicBlock(llfndecl, Str.buf(\"allocas\"));\n \n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n@@ -5996,7 +5996,7 @@ fn new_fn_ctxt(@local_ctxt cx,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n              llupvars=llupvars,\n-             mutable lltydescs=_vec.empty[ValueRef](),\n+             mutable lltydescs=Vec.empty[ValueRef](),\n              lcx=cx);\n }\n \n@@ -6009,7 +6009,7 @@ fn new_fn_ctxt(@local_ctxt cx,\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              ast.proto proto,\n-                             option.t[tup(TypeRef, ty.t)] ty_self,\n+                             Option.t[tup(TypeRef, ty.t)] ty_self,\n                              ty.t ret_ty,\n                              &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n@@ -6052,7 +6052,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_any_self_to_alloca(@fn_ctxt fcx,\n-                           option.t[tup(TypeRef, ty.t)] ty_self) {\n+                           Option.t[tup(TypeRef, ty.t)] ty_self) {\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n@@ -6152,7 +6152,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // its magic.\n     auto fields_tup_ty = ty.mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n \n-    auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n+    auto n_typarams = Vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n \n     auto box_cell =\n@@ -6209,7 +6209,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n }\n \n fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n-            option.t[tup(TypeRef, ty.t)] ty_self,\n+            Option.t[tup(TypeRef, ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n     auto llfndecl = cx.ccx.item_ids.get(fid);\n \n@@ -6264,10 +6264,10 @@ fn trans_vtbl(@local_ctxt cx,\n     let vec[ValueRef] methods = vec(dtor);\n \n     fn meth_lteq(&@ast.method a, &@ast.method b) -> bool {\n-        ret _str.lteq(a.node.ident, b.node.ident);\n+        ret Str.lteq(a.node.ident, b.node.ident);\n     }\n \n-    auto meths = std.sort.merge_sort[@ast.method](bind meth_lteq(_,_),\n+    auto meths = std.Sort.merge_sort[@ast.method](bind meth_lteq(_,_),\n                                                   ob.methods);\n \n     for (@ast.method m in meths) {\n@@ -6278,7 +6278,7 @@ fn trans_vtbl(@local_ctxt cx,\n                 llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n-                                         _vec.len[ast.ty_param](ty_params));\n+                                         Vec.len[ast.ty_param](ty_params));\n             }\n         }\n \n@@ -6297,7 +6297,7 @@ fn trans_vtbl(@local_ctxt cx,\n     auto vtbl = C_struct(methods);\n     auto vtbl_name = mangle_name_by_seq(cx.ccx, cx.path, \"vtbl\");\n     auto gvar = llvm.LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n-                                   _str.buf(vtbl_name));\n+                                   Str.buf(vtbl_name));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n     llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMInternalLinkage\n@@ -6368,22 +6368,22 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     // FIXME we should probably also allocate a box for empty objs that have a\n     // dtor, since otherwise they are never dropped, and the dtor never runs\n-    if (_vec.len[ast.ty_param](ty_params) == 0u &&\n-        _vec.len[ty.arg](arg_tys) == 0u) {\n+    if (Vec.len[ast.ty_param](ty_params) == 0u &&\n+        Vec.len[ty.arg](arg_tys) == 0u) {\n         // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Malloc a box for the body and copy args in.\n         let vec[ty.t] obj_fields = vec();\n         for (ty.arg a in arg_tys) {\n-            _vec.push[ty.t](obj_fields, a.ty);\n+            Vec.push[ty.t](obj_fields, a.ty);\n         }\n \n         // Synthesize an obj body type.\n         auto tydesc_ty = ty.mk_type(ccx.tcx);\n         let vec[ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n-            _vec.push[ty.t](tps, tydesc_ty);\n+            Vec.push[ty.t](tps, tydesc_ty);\n         }\n \n         let ty.t typarams_ty = ty.mk_imm_tup(ccx.tcx, tps);\n@@ -6467,7 +6467,7 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n                      &ast.variant variant, int index,\n                      &vec[ast.ty_param] ty_params) {\n-    if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n+    if (Vec.len[ast.variant_arg](variant.node.args) == 0u) {\n         ret;    // nullary constructors are just constants\n     }\n \n@@ -6477,7 +6477,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     for (ast.variant_arg varg in variant.node.args) {\n         fn_args += vec(rec(mode=ast.alias,\n                            ty=varg.ty,\n-                           ident=\"arg\" + _uint.to_str(i, 10u),\n+                           ident=\"arg\" + UInt.to_str(i, 10u),\n                            id=varg.id));\n     }\n \n@@ -6617,7 +6617,7 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n     let vec[TypeRef] pair_tys = vec(T_nil(), T_nil());\n     llvm.LLVMGetStructElementTypes(llpairty,\n-                                   _vec.buf[TypeRef](pair_tys));\n+                                   Vec.buf[TypeRef](pair_tys));\n     ret llvm.LLVMGetElementType(pair_tys.(0));\n }\n \n@@ -6633,7 +6633,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n     alt (ty.struct(ccx.tcx, node_ann_type(ccx, ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n-                               _vec.len[ast.ty_param](ty_params));\n+                               Vec.len[ast.ty_param](ty_params));\n             llpairty = T_fn_pair(ccx.tn, llfty);\n         }\n         case (_) {\n@@ -6655,7 +6655,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n                     ast.def_id id) {\n     let ValueRef gvar = llvm.LLVMAddGlobal(cx.llmod, llpairty,\n-                                           _str.buf(ps));\n+                                           Str.buf(ps));\n     auto pair = C_struct(vec(llfn,\n                              C_null(T_opaque_closure_ptr(cx.tn))));\n \n@@ -6681,7 +6681,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n             fail;\n         }\n         case (ast.native_item_fn(_, _, _, ?tps, _, _)) {\n-            count = _vec.len[ast.ty_param](tps);\n+            count = Vec.len[ast.ty_param](tps);\n         }\n     }\n     ret count;\n@@ -6768,7 +6768,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     if (pass_task) { call_args += vec(lltaskptr); }\n \n     auto arg_n = 3u;\n-    for each (uint i in _uint.range(0u, num_ty_param)) {\n+    for each (uint i in UInt.range(0u, num_ty_param)) {\n         auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n         fcx.lltydescs += vec(llarg);\n         assert (llarg as int != 0);\n@@ -6900,13 +6900,13 @@ fn new_walk_ctxt() -> @walk_ctxt {\n fn enter_item(@walk_ctxt cx, @ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, _, _, _, _)) {\n-            _vec.push[str](cx.path, name);\n+            Vec.push[str](cx.path, name);\n         }\n         case (ast.item_obj(?name, _, _, _, _)) {\n-            _vec.push[str](cx.path, name);\n+            Vec.push[str](cx.path, name);\n         }\n         case (ast.item_mod(?name, _, _)) {\n-            _vec.push[str](cx.path, name);\n+            Vec.push[str](cx.path, name);\n         }\n         case (_) { }\n     }\n@@ -6915,13 +6915,13 @@ fn enter_item(@walk_ctxt cx, @ast.item item) {\n fn leave_item(@walk_ctxt cx, @ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(_, _, _, _, _)) {\n-            _vec.pop[str](cx.path);\n+            Vec.pop[str](cx.path);\n         }\n         case (ast.item_obj(_, _, _, _, _)) {\n-            _vec.pop[str](cx.path);\n+            Vec.pop[str](cx.path);\n         }\n         case (ast.item_mod(_, _, _)) {\n-            _vec.pop[str](cx.path);\n+            Vec.pop[str](cx.path);\n         }\n         case (_) { }\n     }\n@@ -6948,7 +6948,7 @@ fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n         case (ast.item_const(?name, _, _, ?cid, ?ann)) {\n             auto typ = node_ann_type(ccx, ann);\n             auto g = llvm.LLVMAddGlobal(ccx.llmod, type_of(ccx, typ),\n-                                        _str.buf(ccx.names.next(name)));\n+                                        Str.buf(ccx.names.next(name)));\n             llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n                                 as llvm.Linkage);\n             ccx.items.insert(cid, i);\n@@ -7009,7 +7009,7 @@ fn collect_tag_ctor(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n     alt (i.node) {\n         case (ast.item_tag(_, ?variants, ?tps, _, _)) {\n             for (ast.variant variant in variants) {\n-                if (_vec.len[ast.variant_arg](variant.node.args) != 0u) {\n+                if (Vec.len[ast.variant_arg](variant.node.args) != 0u) {\n                     decl_fn_and_pair(ccx, wcx.path + vec(variant.node.name),\n                                      \"tag\", tps, variant.node.ann,\n                                      variant.node.id);\n@@ -7037,7 +7037,7 @@ fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item it) {\n     alt (it.node) {\n         case (ast.item_tag(?ident, ?variants, _, ?tag_id, _)) {\n             auto i = 0u;\n-            auto n_variants = _vec.len[ast.variant](variants);\n+            auto n_variants = Vec.len[ast.variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n \n@@ -7047,7 +7047,7 @@ fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item it) {\n                                             #fmt(\"_rust_tag_discrim_%s_%u\",\n                                                  ident, i));\n                 auto discrim_gvar = llvm.LLVMAddGlobal(ccx.llmod, T_int(),\n-                                                       _str.buf(s));\n+                                                       Str.buf(s));\n \n                 llvm.LLVMSetInitializer(discrim_gvar, discrim_val);\n                 llvm.LLVMSetGlobalConstant(discrim_gvar, True);\n@@ -7107,7 +7107,7 @@ fn trans_exit_task_glue(@glue_fns glues,\n \n     auto llfn = glues.exit_task_glue;\n \n-    auto entrybb = llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"entry\"));\n+    auto entrybb = llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"entry\"));\n     auto build = new_builder(entrybb);\n \n     let ValueRef arg1 = llvm.LLVMGetParam(llfn, 0u);\n@@ -7129,9 +7129,9 @@ fn trans_exit_task_glue(@glue_fns glues,\n }\n \n fn create_typedefs(@crate_ctxt cx) {\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"crate\"), T_crate(cx.tn));\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"task\"), T_task(cx.tn));\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tydesc\"), T_tydesc(cx.tn));\n+    llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"crate\"), T_crate(cx.tn));\n+    llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"task\"), T_task(cx.tn));\n+    llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n@@ -7173,7 +7173,7 @@ fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n     let ValueRef v = C_nil();\n     let uint n = 0u;\n     for each (@tup(ast.def_id, str) i in cx.item_symbols.items()) {\n-        if (_str.ends_with(i._1, e)) {\n+        if (Str.ends_with(i._1, e)) {\n             n += 1u;\n             v = cx.item_ids.get(i._0);\n         }\n@@ -7197,7 +7197,7 @@ fn trans_main_fn(@local_ctxt cx, ValueRef llcrate, ValueRef crate_map) {\n     auto T_rust_start_args = vec(T_int(), T_int(), T_int(), T_int(), T_int());\n \n     auto main_name;\n-    if (_str.eq(std.os.target_os(), \"win32\")) {\n+    if (Str.eq(std.OS.target_os(), \"win32\")) {\n         main_name = \"WinMain@16\";\n     } else {\n         main_name = \"main\";\n@@ -7222,7 +7222,7 @@ fn trans_main_fn(@local_ctxt cx, ValueRef llcrate, ValueRef crate_map) {\n     //\n \n     let BasicBlockRef llbb =\n-        llvm.LLVMAppendBasicBlock(llmain, _str.buf(\"\"));\n+        llvm.LLVMAppendBasicBlock(llmain, Str.buf(\"\"));\n     auto b = new_builder(llbb);\n \n     auto start_args = vec(p2i(llrust_main), p2i(llcrate), llargc, llargv,\n@@ -7267,7 +7267,7 @@ fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n }\n \n fn make_no_op_type_glue(ValueRef fun) {\n-    auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n+    auto bb_name = Str.buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n     new_builder(llbb).RetVoid();\n }\n@@ -7283,10 +7283,10 @@ fn make_memcpy_glue(ValueRef fun) {\n     // We're not using the LLVM memcpy intrinsic. It appears to call through\n     // to the platform memcpy in some cases, which is not terribly safe to run\n     // on a rust stack.\n-    auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n-    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n-    auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n-    auto endbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"end\"));\n+    auto initbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"init\"));\n+    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"hdr\"));\n+    auto loopbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"loop\"));\n+    auto endbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"end\"));\n \n     auto dst = llvm.LLVMGetParam(fun, 0u);\n     auto src = llvm.LLVMGetParam(fun, 1u);\n@@ -7325,10 +7325,10 @@ fn decl_bzero_glue(ModuleRef llmod) -> ValueRef {\n \n fn make_bzero_glue(ValueRef fun) -> ValueRef {\n     // We're not using the LLVM memset intrinsic. Same as with memcpy.\n-    auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n-    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n-    auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n-    auto endbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"end\"));\n+    auto initbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"init\"));\n+    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"hdr\"));\n+    auto loopbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"loop\"));\n+    auto endbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"end\"));\n \n     auto dst = llvm.LLVMGetParam(fun, 0u);\n     auto count = llvm.LLVMGetParam(fun, 1u);\n@@ -7440,7 +7440,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     let ValueRef llskipnull = llvm.LLVMGetParam(llfn, 5u);\n \n     let BasicBlockRef llallocas =\n-        llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"allocas\"));\n+        llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"allocas\"));\n \n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n@@ -7453,7 +7453,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     llupvars=new_def_hash[ValueRef](),\n-                    mutable lltydescs=_vec.empty[ValueRef](),\n+                    mutable lltydescs=Vec.empty[ValueRef](),\n                     lcx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -7476,14 +7476,14 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     bcx = llnew_vec_res.bcx;\n     auto llnew_vec = vi2p(bcx, llnew_vec_res.val,\n                           T_opaque_vec_ptr());\n-    llvm.LLVMSetValueName(llnew_vec, _str.buf(\"llnew_vec\"));\n+    llvm.LLVMSetValueName(llnew_vec, Str.buf(\"llnew_vec\"));\n \n     auto copy_dst_cx = new_sub_block_ctxt(bcx, \"copy new <- dst\");\n     auto copy_src_cx = new_sub_block_ctxt(bcx, \"copy new <- src\");\n \n     auto pp0 = alloca(bcx, T_ptr(T_i8()));\n     bcx.build.Store(vec_p1_adjusted(bcx, llnew_vec, llskipnull), pp0);\n-    llvm.LLVMSetValueName(pp0, _str.buf(\"pp0\"));\n+    llvm.LLVMSetValueName(pp0, Str.buf(\"pp0\"));\n \n     bcx.build.CondBr(bcx.build.TruncOrBitCast\n                      (bcx.build.Load(llcopy_dst_ptr),\n@@ -7499,13 +7499,13 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                  ValueRef n_bytes) -> result {\n \n         auto src_lim = cx.build.GEP(src, vec(n_bytes));\n-        llvm.LLVMSetValueName(src_lim, _str.buf(\"src_lim\"));\n+        llvm.LLVMSetValueName(src_lim, Str.buf(\"src_lim\"));\n \n         auto elt_llsz =\n             cx.build.Load(cx.build.GEP(elt_tydesc,\n                                        vec(C_int(0),\n                                            C_int(abi.tydesc_field_size))));\n-        llvm.LLVMSetValueName(elt_llsz, _str.buf(\"elt_llsz\"));\n+        llvm.LLVMSetValueName(elt_llsz, Str.buf(\"elt_llsz\"));\n \n         fn take_one(ValueRef elt_tydesc,\n                     @block_ctxt cx,\n@@ -7526,7 +7526,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     // Copy any dst elements in, omitting null if doing str.\n \n     auto n_bytes = vec_fill_adjusted(copy_dst_cx, lldst_vec, llskipnull);\n-    llvm.LLVMSetValueName(n_bytes, _str.buf(\"n_bytes\"));\n+    llvm.LLVMSetValueName(n_bytes, Str.buf(\"n_bytes\"));\n \n     copy_dst_cx = copy_elts(copy_dst_cx,\n                             llelt_tydesc,\n@@ -7576,13 +7576,13 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n                                                  T_void())),\n \n              native_glues_rust =\n-                 _vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 Vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi.ngt_rust, _), abi.n_native_glues + 1 as uint),\n              native_glues_pure_rust =\n-                 _vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 Vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi.ngt_pure_rust, _), abi.n_native_glues + 1 as uint),\n              native_glues_cdecl =\n-                 _vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 Vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi.ngt_cdecl, _), abi.n_native_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              memcpy_glue = decl_memcpy_glue(llmod),\n@@ -7595,19 +7595,19 @@ fn make_common_glue(session.session sess, str output) {\n     // to autogen it, but things like the memcpy implementation are not\n     // and it might be better to just check in a .ll file.\n     auto llmod =\n-        llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n+        llvm.LLVMModuleCreateWithNameInContext(Str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());\n \n-    llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n-    llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n+    llvm.LLVMSetDataLayout(llmod, Str.buf(x86.get_data_layout()));\n+    llvm.LLVMSetTarget(llmod, Str.buf(x86.get_target_triple()));\n     auto td = mk_target_data(x86.get_data_layout());\n     auto tn = mk_type_names();\n     let ValueRef crate_ptr =\n-        llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n+        llvm.LLVMAddGlobal(llmod, T_crate(tn), Str.buf(\"rust_crate\"));\n \n     auto intrinsics = declare_intrinsics(llmod);\n \n-    llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n+    llvm.LLVMSetModuleInlineAsm(llmod, Str.buf(x86.get_module_asm()));\n \n     auto glues = make_glues(llmod, tn);\n     create_crate_constant(crate_ptr, glues);\n@@ -7624,22 +7624,22 @@ fn create_module_map(@crate_ctxt ccx) -> ValueRef {\n     auto elttype = T_struct(vec(T_int(), T_int()));\n     auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype,\n-                                  _str.buf(\"_rust_mod_map\"));\n+                                  Str.buf(\"_rust_mod_map\"));\n     llvm.LLVMSetLinkage(map, lib.llvm.LLVMInternalLinkage as llvm.Linkage);\n     let vec[ValueRef] elts = vec();\n     for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n         auto elt = C_struct(vec(p2i(C_cstr(ccx, item._0)), p2i(item._1)));\n-        _vec.push[ValueRef](elts, elt);\n+        Vec.push[ValueRef](elts, elt);\n     }\n     auto term = C_struct(vec(C_int(0), C_int(0)));\n-    _vec.push[ValueRef](elts, term);\n+    Vec.push[ValueRef](elts, term);\n     llvm.LLVMSetInitializer(map, C_array(elttype, elts));\n     ret map;\n }\n \n fn crate_name(@crate_ctxt ccx, str deflt) -> str {\n     for (@ast.meta_item item in ccx.sess.get_metadata()) {\n-        if (_str.eq(item.node.name, \"name\")) {\n+        if (Str.eq(item.node.name, \"name\")) {\n             ret item.node.value;\n         }\n     }\n@@ -7653,15 +7653,15 @@ fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n     while (ccx.sess.has_external_crate(i)) {\n         auto name = ccx.sess.get_external_crate(i).name;\n         auto cr = llvm.LLVMAddGlobal(ccx.llmod, T_int(),\n-                                     _str.buf(\"_rust_crate_map_\" + name));\n-        _vec.push[ValueRef](subcrates, p2i(cr));\n+                                     Str.buf(\"_rust_crate_map_\" + name));\n+        Vec.push[ValueRef](subcrates, p2i(cr));\n         i += 1;\n     }\n-    _vec.push[ValueRef](subcrates, C_int(0));\n+    Vec.push[ValueRef](subcrates, C_int(0));\n     auto sym_name = \"_rust_crate_map_\" + crate_name(ccx, \"__none__\");\n-    auto arrtype = T_array(T_int(), _vec.len[ValueRef](subcrates));\n+    auto arrtype = T_array(T_int(), Vec.len[ValueRef](subcrates));\n     auto maptype = T_struct(vec(T_int(), arrtype));\n-    auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype, _str.buf(sym_name));\n+    auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype, Str.buf(sym_name));\n     llvm.LLVMSetLinkage(map, lib.llvm.LLVMExternalLinkage as llvm.Linkage);\n     llvm.LLVMSetInitializer(map, C_struct(vec(p2i(create_module_map(ccx)),\n                                               C_array(T_int(), subcrates))));\n@@ -7672,26 +7672,26 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                ty.type_cache type_cache, str output)\n         -> ModuleRef {\n     auto llmod =\n-        llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n+        llvm.LLVMModuleCreateWithNameInContext(Str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());\n \n-    llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n-    llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n+    llvm.LLVMSetDataLayout(llmod, Str.buf(x86.get_data_layout()));\n+    llvm.LLVMSetTarget(llmod, Str.buf(x86.get_target_triple()));\n     auto td = mk_target_data(x86.get_data_layout());\n     auto tn = mk_type_names();\n     let ValueRef crate_ptr =\n-        llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n+        llvm.LLVMAddGlobal(llmod, T_crate(tn), Str.buf(\"rust_crate\"));\n \n     auto intrinsics = declare_intrinsics(llmod);\n \n     auto glues = make_glues(llmod, tn);\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n-    auto tag_sizes = map.mk_hashmap[ty.t,uint](hasher, eqer);\n-    auto tydescs = map.mk_hashmap[ty.t,@tydesc_info](hasher, eqer);\n-    auto lltypes = map.mk_hashmap[ty.t,TypeRef](hasher, eqer);\n-    auto sha1s = map.mk_hashmap[ty.t,str](hasher, eqer);\n-    auto abbrevs = map.mk_hashmap[ty.t,metadata.ty_abbrev](hasher, eqer);\n+    auto tag_sizes = Map.mk_hashmap[ty.t,uint](hasher, eqer);\n+    auto tydescs = Map.mk_hashmap[ty.t,@tydesc_info](hasher, eqer);\n+    auto lltypes = Map.mk_hashmap[ty.t,TypeRef](hasher, eqer);\n+    auto sha1s = Map.mk_hashmap[ty.t,str](hasher, eqer);\n+    auto abbrevs = Map.mk_hashmap[ty.t,metadata.ty_abbrev](hasher, eqer);\n \n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,\n@@ -7716,7 +7716,7 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                     lltypes = lltypes,\n                     glues = glues,\n                     names = namegen(0),\n-                    sha = std.sha1.mk_sha1(),\n+                    sha = std.SHA1.mk_sha1(),\n                     type_sha1s = sha1s,\n                     type_abbrevs = abbrevs,\n                     tcx = tcx);"}, {"sha": "44fc5486047ada8ad759df10daa4fe1dd048a99a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,13 +1,13 @@\n-import std._str;\n-import std._uint;\n-import std._vec;\n+import std.Str;\n+import std.UInt;\n+import std.Vec;\n import std.Box;\n import std.UFind;\n-import std.map;\n-import std.map.hashmap;\n-import std.option;\n-import std.option.none;\n-import std.option.some;\n+import std.Map;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.none;\n+import std.Option.some;\n \n import driver.session;\n import front.ast;\n@@ -65,7 +65,7 @@ fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariants.\n type raw_t = rec(sty struct,\n-                 option.t[str] cname,\n+                 Option.t[str] cname,\n                  uint magic,\n                  uint hash,\n                  bool has_params,\n@@ -108,7 +108,7 @@ tag sty {\n // Data structures used in type unification\n \n type unify_handler = obj {\n-    fn resolve_local(ast.def_id id) -> option.t[t];\n+    fn resolve_local(ast.def_id id) -> Option.t[t];\n     fn record_local(ast.def_id id, t ty);  // TODO: -> Unify.result\n     fn record_param(uint index, t binding) -> Unify.result;\n };\n@@ -168,8 +168,8 @@ fn mk_type_store() -> @type_store {\n     auto hasher = hash_ty;\n     auto eqer = eq_ty_full;\n \n-    ret @rec(empty_vec_ty = _vec.empty[ty.t](),\n-             empty_vec_mutable_ty = _vec.empty_mut[ty.t](),\n+    ret @rec(empty_vec_ty = Vec.empty[ty.t](),\n+             empty_vec_mutable_ty = Vec.empty_mut[ty.t](),\n              t_nil = mk_ty_full(ty_nil, none[str]),\n              t_bool = mk_ty_full(ty_bool, none[str]),\n              t_int = mk_ty_full(ty_int, none[str]),\n@@ -196,11 +196,11 @@ fn mk_type_store() -> @type_store {\n              t_native = mk_ty_full(ty_native, none[str]),\n              t_type = mk_ty_full(ty_type, none[str]),\n \n-             mutable t_params = _vec.empty[ty.t](),\n-             mutable t_bound_params = _vec.empty[ty.t](),\n-             mutable t_vars = _vec.empty[ty.t](),\n+             mutable t_params = Vec.empty[ty.t](),\n+             mutable t_bound_params = Vec.empty[ty.t](),\n+             mutable t_vars = Vec.empty[ty.t](),\n \n-             others=map.mk_hashmap[t,t](hasher, eqer));\n+             others=Map.mk_hashmap[t,t](hasher, eqer));\n }\n \n fn mk_rcache() -> creader_cache {\n@@ -215,7 +215,7 @@ fn mk_rcache() -> creader_cache {\n     }\n     auto h = hash_cache_entry;\n     auto e = eq_cache_entries;\n-    ret map.mk_hashmap[tup(int,uint,uint),t](h, e);\n+    ret Map.mk_hashmap[tup(int,uint,uint),t](h, e);\n }\n \n fn mk_ctxt(session.session s) -> ctxt {\n@@ -225,7 +225,7 @@ fn mk_ctxt(session.session s) -> ctxt {\n }\n // Type constructors\n \n-fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n+fn mk_ty_full(&sty st, Option.t[str] cname) -> t {\n     auto h = hash_type_info(st, cname);\n     auto magic = mk_magic(st);\n \n@@ -350,7 +350,7 @@ fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n              has_locals = has_locals);\n }\n \n-fn gen_ty_full(ctxt cx, &sty st, option.t[str] cname) -> t {\n+fn gen_ty_full(ctxt cx, &sty st, Option.t[str] cname) -> t {\n     auto new_type = mk_ty_full(st, cname);\n \n     // Do not intern anything with locals or vars; it'll be nearly\n@@ -457,7 +457,7 @@ fn mk_local(ctxt cx, ast.def_id did) -> t {\n }\n \n fn mk_param(ctxt cx, uint n) -> t {\n-    let uint i = _vec.len[t](cx.ts.t_params);\n+    let uint i = Vec.len[t](cx.ts.t_params);\n     while (i <= n) {\n         cx.ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n         i += 1u;\n@@ -466,7 +466,7 @@ fn mk_param(ctxt cx, uint n) -> t {\n }\n \n fn mk_bound_param(ctxt cx, uint n) -> t {\n-    let uint i = _vec.len[t](cx.ts.t_bound_params);\n+    let uint i = Vec.len[t](cx.ts.t_bound_params);\n     while (i <= n) {\n         cx.ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n         i += 1u;\n@@ -482,17 +482,17 @@ fn mk_native(ctxt cx) -> t  { ret cx.ts.t_native; }\n fn struct(ctxt cx, t typ) -> sty { ret typ.struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(ctxt cx, t typ) -> option.t[str] { ret typ.cname; }\n+fn cname(ctxt cx, t typ) -> Option.t[str] { ret typ.cname; }\n \n \n // Stringification\n \n fn path_to_str(&ast.path pth) -> str {\n-    auto result = _str.connect(pth.node.idents,  \".\");\n-    if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n+    auto result = Str.connect(pth.node.idents,  \".\");\n+    if (Vec.len[@ast.ty](pth.node.types) > 0u) {\n         auto f = pretty.pprust.ty_to_str;\n         result += \"[\";\n-        result += _str.connect(_vec.map[@ast.ty,str](f, pth.node.types), \",\");\n+        result += Str.connect(Vec.map[@ast.ty,str](f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n@@ -513,7 +513,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n     fn fn_to_str(ctxt cx,\n                  ast.proto proto,\n-                 option.t[ast.ident] ident,\n+                 Option.t[ast.ident] ident,\n                  vec[arg] inputs, t output) -> str {\n             auto f = bind fn_input_to_str(cx, _);\n \n@@ -536,7 +536,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n             }\n \n             s += \"(\";\n-            s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n+            s += Str.connect(Vec.map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n             if (struct(cx, output) != ty_nil) {\n@@ -592,24 +592,24 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n         case (ty_tup(?elems)) {\n             auto f = bind mt_to_str(cx, _);\n-            auto strs = _vec.map[mt,str](f, elems);\n-            s += \"tup(\" + _str.connect(strs, \",\") + \")\";\n+            auto strs = Vec.map[mt,str](f, elems);\n+            s += \"tup(\" + Str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n             auto f = bind field_to_str(cx, _);\n-            auto strs = _vec.map[field,str](f, elems);\n-            s += \"rec(\" + _str.connect(strs, \",\") + \")\";\n+            auto strs = Vec.map[field,str](f, elems);\n+            s += \"rec(\" + Str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n             s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n                 util.common.istr(id._1) + \">\";\n-            if (_vec.len[t](tps) > 0u) {\n+            if (Vec.len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n-                auto strs = _vec.map[t,str](f, tps);\n-                s += \"[\" + _str.connect(strs, \",\") + \"]\";\n+                auto strs = Vec.map[t,str](f, tps);\n+                s += \"[\" + Str.connect(strs, \",\") + \"]\";\n             }\n         }\n \n@@ -623,8 +623,8 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n-            auto m = _vec.map[method,str](f, meths);\n-            s += \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n+            auto m = Vec.map[method,str](f, meths);\n+            s += \"obj {\\n\\t\" + Str.connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n \n         case (ty_var(?v)) {\n@@ -637,11 +637,11 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         }\n \n         case (ty_param(?id)) {\n-            s += \"'\" + _str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+            s += \"'\" + Str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n         }\n \n         case (ty_bound_param(?id)) {\n-            s += \"''\" + _str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+            s += \"''\" + Str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n         }\n     }\n \n@@ -652,7 +652,7 @@ fn ty_to_short_str(ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n     auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata.ac_no_abbrevs);\n     auto s = metadata.Encode.ty_str(ecx, typ);\n-    if (_str.byte_len(s) >= 64u) { s = _str.substr(s, 0u, 64u); }\n+    if (Str.byte_len(s) >= 64u) { s = Str.substr(s, 0u, 64u); }\n     ret s;\n }\n \n@@ -956,14 +956,14 @@ fn type_has_dynamic_size(ctxt cx, t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < _vec.len[mt](mts)) {\n+            while (i < Vec.len[mt](mts)) {\n                 if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n-            while (i < _vec.len[field](fields)) {\n+            while (i < Vec.len[field](fields)) {\n                 if (type_has_dynamic_size(cx, fields.(i).mt.ty)) {\n                     ret true;\n                 }\n@@ -972,7 +972,7 @@ fn type_has_dynamic_size(ctxt cx, t ty) -> bool {\n         }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < _vec.len[t](subtys)) {\n+            while (i < Vec.len[t](subtys)) {\n                 if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -1041,7 +1041,7 @@ fn type_is_signed(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_param(ctxt cx, t ty) -> option.t[uint] {\n+fn type_param(ctxt cx, t ty) -> Option.t[uint] {\n     alt (struct(cx, ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n@@ -1174,7 +1174,7 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_obj(?methods)) {\n             auto h = 27u;\n             for (method m in methods) {\n-                h += h << 5u + _str.hash(m.ident);\n+                h += h << 5u + Str.hash(m.ident);\n             }\n             ret h;\n         }\n@@ -1187,11 +1187,11 @@ fn hash_type_structure(&sty st) -> uint {\n     }\n }\n \n-fn hash_type_info(&sty st, option.t[str] cname_opt) -> uint {\n+fn hash_type_info(&sty st, Option.t[str] cname_opt) -> uint {\n     auto h = hash_type_structure(st);\n     alt (cname_opt) {\n         case (none[str]) { /* no-op */ }\n-        case (some[str](?s)) { h += h << 5u + _str.hash(s); }\n+        case (some[str](?s)) { h += h << 5u + Str.hash(s); }\n     }\n     ret h;\n }\n@@ -1297,8 +1297,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 vec[arg] args_b, t rty_b) -> bool {\n         if (!eq_ty(rty_a, rty_b)) { ret false; }\n \n-        auto len = _vec.len[arg](args_a);\n-        if (len != _vec.len[arg](args_b)) { ret false; }\n+        auto len = Vec.len[arg](args_a);\n+        if (len != Vec.len[arg](args_b)) { ret false; }\n \n         auto i = 0u;\n         while (i < len) {\n@@ -1370,8 +1370,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n \n-                    auto len = _vec.len[t](tys_a);\n-                    if (len != _vec.len[t](tys_b)) { ret false; }\n+                    auto len = Vec.len[t](tys_a);\n+                    if (len != Vec.len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1415,8 +1415,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_tup(?mts_a)) {\n             alt (b) {\n                 case (ty_tup(?mts_b)) {\n-                    auto len = _vec.len[mt](mts_a);\n-                    if (len != _vec.len[mt](mts_b)) { ret false; }\n+                    auto len = Vec.len[mt](mts_a);\n+                    if (len != Vec.len[mt](mts_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n@@ -1430,12 +1430,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_rec(?flds_a)) {\n             alt (b) {\n                 case (ty_rec(?flds_b)) {\n-                    auto len = _vec.len[field](flds_a);\n-                    if (len != _vec.len[field](flds_b)) { ret false; }\n+                    auto len = Vec.len[field](flds_a);\n+                    if (len != Vec.len[field](flds_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto fld_a = flds_a.(i); auto fld_b = flds_b.(i);\n-                        if (!_str.eq(fld_a.ident, fld_b.ident) ||\n+                        if (!Str.eq(fld_a.ident, fld_b.ident) ||\n                                 !equal_mt(fld_a.mt, fld_b.mt)) {\n                             ret false;\n                         }\n@@ -1467,13 +1467,13 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = _vec.len[method](methods_a);\n-                    if (len != _vec.len[method](methods_b)) { ret false; }\n+                    auto len = Vec.len[method](methods_a);\n+                    if (len != Vec.len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i); auto m_b = methods_b.(i);\n                         if (!equal_proto(m_a.proto, m_b.proto) ||\n-                                !_str.eq(m_a.ident, m_b.ident) ||\n+                                !Str.eq(m_a.ident, m_b.ident) ||\n                                 !equal_fn(m_a.inputs, m_a.output,\n                                           m_b.inputs, m_b.output)) {\n                             ret false;\n@@ -1546,7 +1546,7 @@ fn eq_ty_full(&t a, &t b) -> bool {\n         case (some[str](?s_a)) {\n             alt (b.cname) {\n                 case (some[str](?s_b)) {\n-                    if (!_str.eq(s_a, s_b)) { ret false; }\n+                    if (!Str.eq(s_a, s_b)) { ret false; }\n                 }\n                 case (_) { ret false; }\n             }\n@@ -1651,7 +1651,7 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n     let @mutable vec[uint] param_indices = @mutable v;\n     auto f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret _vec.len[uint](*param_indices);\n+    ret Vec.len[uint](*param_indices);\n }\n \n fn type_contains_vars(ctxt cx, t typ) -> bool {\n@@ -1721,7 +1721,7 @@ fn native_item_ty(@ast.native_item it) -> ty_param_count_and_ty {\n     auto result_ty;\n     alt (it.node) {\n         case (ast.native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec.len[ast.ty_param](tps);\n+            ty_param_count = Vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n@@ -1737,22 +1737,22 @@ fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec.len[ast.ty_param](tps);\n+            ty_param_count = Vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_mod(_, _, _)) {\n             fail;   // modules are typeless\n         }\n         case (ast.item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec.len[ast.ty_param](tps);\n+            ty_param_count = Vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_param_count = _vec.len[ast.ty_param](tps);\n+            ty_param_count = Vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec.len[ast.ty_param](tps);\n+            ty_param_count = Vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n@@ -1924,7 +1924,7 @@ fn expr_has_ty_params(@ast.expr expr) -> bool {\n     alt (expr_ann(expr)) {\n         case (ast.ann_none) { fail; }\n         case (ast.ann_type(_, ?tps_opt, _)) {\n-            ret !option.is_none[vec[t]](tps_opt);\n+            ret !Option.is_none[vec[t]](tps_opt);\n         }\n     }\n }\n@@ -1987,7 +1987,7 @@ fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n                 accum += (c as uint) - ('0' as uint);\n             } else {\n                 auto s = \"\";\n-                s += _str.unsafe_from_byte(c);\n+                s += Str.unsafe_from_byte(c);\n                 sess.span_err(sp,\n                               \"bad numeric field on tuple: \"\n                               + \" non-digit character: \"\n@@ -2003,7 +2003,7 @@ fn field_idx(session.session sess, &span sp,\n              &ast.ident id, vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) {\n-        if (_str.eq(f.ident, id)) {\n+        if (Str.eq(f.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -2016,7 +2016,7 @@ fn method_idx(session.session sess, &span sp,\n               &ast.ident id, vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) {\n-        if (_str.eq(m.ident, id)) {\n+        if (Str.eq(m.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -2027,10 +2027,10 @@ fn method_idx(session.session sess, &span sp,\n \n fn sort_methods(vec[method] meths) -> vec[method] {\n     fn method_lteq(&method a, &method b) -> bool {\n-        ret _str.lteq(a.ident, b.ident);\n+        ret Str.lteq(a.ident, b.ident);\n     }\n \n-    ret std.sort.merge_sort[method](bind method_lteq(_,_), meths);\n+    ret std.Sort.merge_sort[method](bind method_lteq(_,_), meths);\n }\n \n fn is_lval(@ast.expr expr) -> bool {\n@@ -2078,7 +2078,7 @@ mod Unify {\n \n     // Unifies two mutability flags.\n     fn unify_mut(ast.mutability expected, ast.mutability actual)\n-            -> option.t[ast.mutability] {\n+            -> Option.t[ast.mutability] {\n         if (expected == actual) {\n             ret some[ast.mutability](expected);\n         }\n@@ -2102,8 +2102,8 @@ mod Unify {\n                        vec[arg] expected_inputs, t expected_output,\n                        vec[arg] actual_inputs, t actual_output)\n         -> fn_common_res {\n-        auto expected_len = _vec.len[arg](expected_inputs);\n-        auto actual_len = _vec.len[arg](actual_inputs);\n+        auto expected_len = Vec.len[arg](expected_inputs);\n+        auto actual_len = Vec.len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n             ret fn_common_res_err(ures_err(terr_arg_count,\n                                            expected, actual));\n@@ -2213,8 +2213,8 @@ mod Unify {\n                  vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n       let uint i = 0u;\n-      let uint expected_len = _vec.len[method](expected_meths);\n-      let uint actual_len = _vec.len[method](actual_meths);\n+      let uint expected_len = Vec.len[method](expected_meths);\n+      let uint actual_len = Vec.len[method](actual_meths);\n \n       if (expected_len != actual_len) {\n         ret ures_err(terr_meth_count, expected, actual);\n@@ -2223,7 +2223,7 @@ mod Unify {\n       while (i < expected_len) {\n         auto e_meth = expected_meths.(i);\n         auto a_meth = actual_meths.(i);\n-        if (! _str.eq(e_meth.ident, a_meth.ident)) {\n+        if (! Str.eq(e_meth.ident, a_meth.ident)) {\n           ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n                        expected, actual);\n         }\n@@ -2287,7 +2287,7 @@ mod Unify {\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = _vec.len[vec[t]](cx.types);\n+                        auto vlen = Vec.len[vec[t]](cx.types);\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += vec(expected);\n                         } else {\n@@ -2354,7 +2354,7 @@ mod Unify {\n                         // ty.ty_tup case\n                         let vec[t] result_tps = vec();\n                         auto i = 0u;\n-                        auto expected_len = _vec.len[t](expected_tps);\n+                        auto expected_len = Vec.len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n@@ -2365,7 +2365,7 @@ mod Unify {\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    _vec.push[t](result_tps, rty);\n+                                    Vec.push[t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -2494,8 +2494,8 @@ mod Unify {\n             case (ty.ty_tup(?expected_elems)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec.len[ty.mt](expected_elems);\n-                        auto actual_len = _vec.len[ty.mt](actual_elems);\n+                        auto expected_len = Vec.len[ty.mt](expected_elems);\n+                        auto actual_len = Vec.len[ty.mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -2548,8 +2548,8 @@ mod Unify {\n             case (ty.ty_rec(?expected_fields)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_rec(?actual_fields)) {\n-                        auto expected_len = _vec.len[field](expected_fields);\n-                        auto actual_len = _vec.len[field](actual_fields);\n+                        auto expected_len = Vec.len[field](expected_fields);\n+                        auto actual_len = Vec.len[field](actual_fields);\n                         if (expected_len != actual_len) {\n                             auto err = terr_record_size(expected_len,\n                                                         actual_len);\n@@ -2574,7 +2574,7 @@ mod Unify {\n                                 case (some[ast.mutability](?m)) { mut = m; }\n                             }\n \n-                            if (!_str.eq(expected_field.ident,\n+                            if (!Str.eq(expected_field.ident,\n                                          actual_field.ident)) {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n@@ -2588,7 +2588,7 @@ mod Unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    _vec.push[field]\n+                                    Vec.push[field]\n                                         (result_fields,\n                                          rec(mt=mt with expected_field));\n                                 }\n@@ -2655,7 +2655,7 @@ mod Unify {\n             case (ty.ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = _vec.len[vec[t]](cx.types);\n+                auto vlen = Vec.len[vec[t]](cx.types);\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += vec(actual);\n                 } else {\n@@ -2719,23 +2719,23 @@ mod Unify {\n     fn unify_sets(@ctxt cx) -> vec[t] {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] set_types = vec(mutable throwaway);\n-        _vec.pop[vec[t]](set_types);   // FIXME: botch\n+        Vec.pop[vec[t]](set_types);   // FIXME: botch\n \n         for (UFind.node node in cx.sets.nodes) {\n             let vec[t] v = vec();\n             set_types += vec(mutable v);\n         }\n \n         auto i = 0u;\n-        while (i < _vec.len[vec[t]](set_types)) {\n+        while (i < Vec.len[vec[t]](set_types)) {\n             auto root = UFind.find(cx.sets, i);\n             set_types.(root) += cx.types.(i);\n             i += 1u;\n         }\n \n         let vec[t] result = vec();\n         for (vec[t] types in set_types) {\n-            if (_vec.len[t](types) > 1u) {\n+            if (Vec.len[t](types) > 1u) {\n                 log_err \"unification of > 1 types in a type set is \" +\n                     \"unimplemented\";\n                 fail;\n@@ -2752,7 +2752,7 @@ mod Unify {\n              ty_ctxt tcx) -> result {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] types = vec(mutable throwaway);\n-        _vec.pop[vec[t]](types);   // FIXME: botch\n+        Vec.pop[vec[t]](types);   // FIXME: botch\n \n         auto cx = @rec(sets=UFind.make(),\n                        var_ids=common.new_int_hash[uint](),\n@@ -2765,7 +2765,7 @@ mod Unify {\n         case (ures_ok(?typ)) {\n             // Fast path: if there are no local variables, don't perform\n             // substitutions.\n-            if (_vec.len(cx.sets.nodes) == 0u) {\n+            if (Vec.len(cx.sets.nodes) == 0u) {\n                 ret ures_ok(typ);\n             }\n \n@@ -2791,16 +2791,16 @@ fn type_err_to_str(&ty.type_err err) -> str {\n             ret \"vectors differ in mutability\";\n         }\n         case (terr_tuple_size(?e_sz, ?a_sz)) {\n-            ret \"expected a tuple with \" + _uint.to_str(e_sz, 10u) +\n-                \" elements but found one with \" + _uint.to_str(a_sz, 10u) +\n+            ret \"expected a tuple with \" + UInt.to_str(e_sz, 10u) +\n+                \" elements but found one with \" + UInt.to_str(a_sz, 10u) +\n                 \" elements\";\n         }\n         case (terr_tuple_mutability) {\n             ret \"tuple elements differ in mutability\";\n         }\n         case (terr_record_size(?e_sz, ?a_sz)) {\n-            ret \"expected a record with \" + _uint.to_str(e_sz, 10u) +\n-                \" fields but found one with \" + _uint.to_str(a_sz, 10u) +\n+            ret \"expected a record with \" + UInt.to_str(e_sz, 10u) +\n+                \" fields but found one with \" + UInt.to_str(a_sz, 10u) +\n                 \" fields\";\n         }\n         case (terr_record_mutability) {"}, {"sha": "091616fcda700d829548c4f581744950515e5fd0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -32,15 +32,15 @@ import middle.ty.ty_nil;\n import middle.ty.Unify.ures_ok;\n import middle.ty.Unify.ures_err;\n \n-import std._str;\n-import std._uint;\n-import std._vec;\n-import std.map;\n-import std.map.hashmap;\n-import std.option;\n-import std.option.none;\n-import std.option.some;\n-import std.option.from_maybe;\n+import std.Str;\n+import std.UInt;\n+import std.Vec;\n+import std.Map;\n+import std.Map.hashmap;\n+import std.Option;\n+import std.Option.none;\n+import std.Option.some;\n+import std.Option.from_maybe;\n \n import util.typestate_ann.ts_ann;\n \n@@ -61,7 +61,7 @@ type crate_ctxt = rec(session.session sess,\n                       ty.type_cache type_cache,\n                       @ty_item_table item_items,\n                       vec[ast.obj_field] obj_fields,\n-                      option.t[ast.def_id] this_obj,\n+                      Option.t[ast.def_id] this_obj,\n                       @fn_purity_table fn_purity_table,\n                       mutable int next_var_id,\n                       unify_cache unify_cache,\n@@ -91,12 +91,12 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n         }\n     }\n \n-    auto supplied_len = _vec.len[ty.t](supplied);\n+    auto supplied_len = Vec.len[ty.t](supplied);\n     if (ty_param_count != supplied_len) {\n         ccx.sess.span_err(sp, \"expected \" +\n-                          _uint.to_str(ty_param_count, 10u) +\n+                          UInt.to_str(ty_param_count, 10u) +\n                           \" type parameter(s) but found \" +\n-                          _uint.to_str(supplied_len, 10u) + \" parameter(s)\");\n+                          UInt.to_str(supplied_len, 10u) + \" parameter(s)\");\n         fail;\n     }\n \n@@ -181,7 +181,7 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n     auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n \n     auto ty_substs_opt;\n-    auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n+    auto ty_substs_len = Vec.len[@ast.ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n         let vec[ty.t] ty_substs = vec();\n         auto i = 0u;\n@@ -281,29 +281,29 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n         case (ast.ty_tup(?fields)) {\n             let vec[ty.mt] flds = vec();\n             for (ast.mt field in fields) {\n-                _vec.push[ty.mt](flds, ast_mt_to_mt(tcx, getter, field));\n+                Vec.push[ty.mt](flds, ast_mt_to_mt(tcx, getter, field));\n             }\n             typ = ty.mk_tup(tcx, flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n                 auto tm = ast_mt_to_mt(tcx, getter, f.mt);\n-                _vec.push[field](flds, rec(ident=f.ident, mt=tm));\n+                Vec.push[field](flds, rec(ident=f.ident, mt=tm));\n             }\n             typ = ty.mk_rec(tcx, flds);\n         }\n \n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n-            auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n+            auto i = Vec.map[ast.ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n             typ = ty.mk_fn(tcx, proto, i, out_ty);\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n             assert (def != none[ast.def]);\n-            alt (option.get[ast.def](def)) {\n+            alt (Option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n@@ -325,9 +325,9 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n             let vec[ty.method] tmeths = vec();\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             for (ast.ty_method m in meths) {\n-                auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n+                auto ins = Vec.map[ast.ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(tcx, getter, m.output);\n-                _vec.push[ty.method](tmeths,\n+                Vec.push[ty.method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n@@ -383,10 +383,10 @@ mod Collect {\n                      ast.proto proto,\n                      vec[ast.ty_param] ty_params,\n                      ast.def_id def_id) -> ty.ty_param_count_and_ty {\n-        auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n+        auto input_tys = Vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty.mk_fn(cx.tcx, proto, input_tys, output_ty);\n-        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto ty_param_count = Vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n         ret tpt;\n@@ -399,10 +399,10 @@ mod Collect {\n                             ast.native_abi abi,\n                             vec[ast.ty_param] ty_params,\n                             ast.def_id def_id) -> ty.ty_param_count_and_ty {\n-        auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n+        auto input_tys = Vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty.mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n-        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto ty_param_count = Vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n         ret tpt;\n@@ -438,7 +438,7 @@ mod Collect {\n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         auto f = bind ty_of_arg(cx, _);\n-        auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n+        auto inputs = Vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                 inputs=inputs, output=output);\n@@ -449,11 +449,11 @@ mod Collect {\n                  &ast._obj obj_info,\n                  vec[ast.ty_param] ty_params) -> ty.ty_param_count_and_ty {\n         auto f = bind ty_of_method(cx, _);\n-        auto methods = _vec.map[@ast.method,method](f, obj_info.methods);\n+        auto methods = Vec.map[@ast.method,method](f, obj_info.methods);\n \n         auto t_obj = ty.mk_obj(cx.tcx, ty.sort_methods(methods));\n         t_obj = ty.rename(cx.tcx, t_obj, id);\n-        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto ty_param_count = Vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }\n \n@@ -468,7 +468,7 @@ mod Collect {\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n+            Vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n \n         cx.type_cache.insert(obj_ty_id, t_obj);\n@@ -515,7 +515,7 @@ mod Collect {\n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n                 auto typ = convert(t);\n-                auto ty_param_count = _vec.len[ast.ty_param](tps);\n+                auto ty_param_count = Vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -533,7 +533,7 @@ mod Collect {\n \n                 auto t = ty.mk_tag(cx.tcx, def_id, subtys);\n \n-                auto ty_param_count = _vec.len[ast.ty_param](tps);\n+                auto ty_param_count = Vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -585,13 +585,13 @@ mod Collect {\n             i += 1u;\n         }\n \n-        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto ty_param_count = Vec.len[ast.ty_param](ty_params);\n \n         for (ast.variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n             auto result_ty;\n-            if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n+            if (Vec.len[ast.variant_arg](variant.node.args) == 0u) {\n                 result_ty = ty.mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n@@ -691,7 +691,7 @@ mod Collect {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n+    fn fold_native_item_fn(&@env e, &span sp, ast.ident i, Option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n         // assert (e.cx.type_cache.contains_key(id));\n@@ -746,15 +746,15 @@ mod Collect {\n                 with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n-            _vec.push[@ast.method](methods, m);\n+            Vec.push[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n             let ty.t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n             let ast.obj_field f = rec(ann=triv_ann(fty)\n                 with fld\n             );\n-            _vec.push[ast.obj_field](fields, f);\n+            Vec.push[ast.obj_field](fields, f);\n         }\n \n         auto dtor = none[@ast.method];\n@@ -847,7 +847,7 @@ mod Unify {\n         // FIXME: horrid botch\n         let vec[mutable ty.t] param_substs =\n             vec(mutable ty.mk_nil(fcx.ccx.tcx));\n-        _vec.pop(param_substs);\n+        Vec.pop(param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n \n@@ -865,7 +865,7 @@ mod Unify {\n         }\n \n         obj unify_handler(@fn_ctxt fcx, vec[mutable ty.t] param_substs) {\n-            fn resolve_local(ast.def_id id) -> option.t[ty.t] {\n+            fn resolve_local(ast.def_id id) -> Option.t[ty.t] {\n                 alt (fcx.locals.find(id)) {\n                     case (none[ty.t]) { ret none[ty.t]; }\n                     case (some[ty.t](?existing_type)) {\n@@ -905,7 +905,7 @@ mod Unify {\n             }\n             fn record_param(uint index, ty.t binding) -> ty.Unify.result {\n                 // Unify with the appropriate type in the parameter\n-                // substitution list.\n+                // substitution List.\n                 auto old_subst = param_substs.(index);\n \n                 auto result = with_params(fcx, old_subst, binding,\n@@ -1004,7 +1004,7 @@ mod Demand {\n \n         let vec[mutable ty.t] ty_param_substs =\n             vec(mutable ty.mk_nil(fcx.ccx.tcx));\n-        _vec.pop(ty_param_substs);   // FIXME: horrid botch\n+        Vec.pop(ty_param_substs);   // FIXME: horrid botch\n         for (ty.t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += vec(mutable ty_param_subst);\n         }\n@@ -1047,7 +1047,7 @@ fn are_compatible(&@fn_ctxt fcx, ty.t expected, ty.t actual) -> bool {\n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n                      vec[ty.t] tag_ty_params) -> vec[ty.t] {\n-    auto ty_param_count = _vec.len[ty.t](tag_ty_params);\n+    auto ty_param_count = Vec.len[ty.t](tag_ty_params);\n \n     let vec[ty.t] result = vec();\n \n@@ -1130,7 +1130,7 @@ mod Pushdown {\n                 }\n \n                 // Get the types of the arguments of the variant.\n-                auto vdef = option.get[ast.variant_def](vdef_opt);\n+                auto vdef = Option.get[ast.variant_def](vdef_opt);\n                 auto arg_tys = variant_arg_types(fcx.ccx, pat.span, vdef._1,\n                                                  tag_tps);\n \n@@ -1218,7 +1218,7 @@ mod Pushdown {\n                             case (none[@ast.expr]) {\n                                 auto i = 0u;\n                                 for (ast.field field_0 in fields_0) {\n-                                    assert (_str.eq(field_0.ident,\n+                                    assert (Str.eq(field_0.ident,\n                                                    field_mts.(i).ident));\n                                     auto e_1 =\n                                         pushdown_expr(fcx,\n@@ -1240,7 +1240,7 @@ mod Pushdown {\n                                 for (ast.field field_0 in fields_0) {\n \n                                     for (ty.field ft in field_mts) {\n-                                        if (_str.eq(field_0.ident,\n+                                        if (Str.eq(field_0.ident,\n                                                     ft.ident)) {\n                                             auto e_1 =\n                                                 pushdown_expr(fcx, ft.mt.ty,\n@@ -1508,9 +1508,9 @@ mod Pushdown {\n // Local variable resolution: the phase that finds all the types in the AST\n // and replaces opaque \"ty_local\" types with the resolved local types.\n \n-fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n+fn writeback_local(&Option.t[@fn_ctxt] env, &span sp, @ast.local local)\n         -> @ast.decl {\n-    auto fcx = option.get[@fn_ctxt](env);\n+    auto fcx = Option.get[@fn_ctxt](env);\n \n     auto local_ty;\n     alt (fcx.locals.find(local.id)) {\n@@ -1530,7 +1530,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n-fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n+fn resolve_local_types_in_annotation(&Option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n     fn resolver(@fn_ctxt fcx, ty.t typ) -> ty.t {\n         alt (struct(fcx.ccx.tcx, typ)) {\n@@ -1539,7 +1539,7 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         }\n     }\n \n-    auto fcx = option.get[@fn_ctxt](env);\n+    auto fcx = Option.get[@fn_ctxt](env);\n     alt (ann) {\n         case (ast.ann_none) {\n             log \"warning: no type for expression\";\n@@ -1559,16 +1559,16 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n \n fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n         -> ast.block {\n-    fn update_env_for_item(&option.t[@fn_ctxt] env, @ast.item i)\n-            -> option.t[@fn_ctxt] {\n+    fn update_env_for_item(&Option.t[@fn_ctxt] env, @ast.item i)\n+            -> Option.t[@fn_ctxt] {\n         ret none[@fn_ctxt];\n     }\n-    fn keep_going(&option.t[@fn_ctxt] env) -> bool {\n-        ret !option.is_none[@fn_ctxt](env);\n+    fn keep_going(&Option.t[@fn_ctxt] env) -> bool {\n+        ret !Option.is_none[@fn_ctxt](env);\n     }\n \n     // FIXME: rustboot bug prevents us from using these functions directly\n-    auto fld = fold.new_identity_fold[option.t[@fn_ctxt]]();\n+    auto fld = fold.new_identity_fold[Option.t[@fn_ctxt]]();\n     auto wbl = writeback_local;\n     auto rltia = bind resolve_local_types_in_annotation(_,_);\n     auto uefi = update_env_for_item;\n@@ -1580,7 +1580,7 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n         keep_going = kg\n         with *fld\n     );\n-    ret fold.fold_block[option.t[@fn_ctxt]](some[@fn_ctxt](fcx), fld, block);\n+    ret fold.fold_block[Option.t[@fn_ctxt]](some[@fn_ctxt](fcx), fld, block);\n }\n \n // AST fragment checking\n@@ -1616,10 +1616,10 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n-            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto vdef = Option.get[ast.variant_def](vdef_opt);\n             auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                          fcx.ccx.type_cache, vdef._1)._1;\n-            auto len = _vec.len[ast.ident](p.node.idents);\n+            auto len = Vec.len[ast.ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n             auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n@@ -1629,14 +1629,14 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n             alt (struct(fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n-                    auto arg_len = _vec.len[arg](args);\n-                    auto subpats_len = _vec.len[@ast.pat](subpats);\n+                    auto arg_len = Vec.len[arg](args);\n+                    auto subpats_len = Vec.len[@ast.pat](subpats);\n                     if (arg_len != subpats_len) {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id + \" has \" +\n-                                       _uint.to_str(subpats_len, 10u) +\n+                                       UInt.to_str(subpats_len, 10u) +\n                                        \" field(s), but this pattern has \" +\n-                                       _uint.to_str(arg_len, 10u) +\n+                                       UInt.to_str(arg_len, 10u) +\n                                        \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n@@ -1653,13 +1653,13 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n \n                 // Nullary variants have tag types.\n                 case (ty.ty_tag(?tid, _)) {\n-                    auto subpats_len = _vec.len[@ast.pat](subpats);\n+                    auto subpats_len = Vec.len[@ast.pat](subpats);\n                     if (subpats_len > 0u) {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id +\n                                        \" has no field(s),\" +\n                                        \" but this pattern has \" +\n-                                       _uint.to_str(subpats_len, 10u) +\n+                                       UInt.to_str(subpats_len, 10u) +\n                                        \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n@@ -1689,7 +1689,7 @@ fn require_impure(&session.session sess,\n }\n \n fn get_function_purity(@crate_ctxt ccx, &ast.def_id d_id) -> ast.purity {\n-    let option.t[ast.purity] o = ccx.fn_purity_table.find(d_id);\n+    let Option.t[ast.purity] o = ccx.fn_purity_table.find(d_id);\n     ret from_maybe[ast.purity](ast.impure_fn, o);\n }\n \n@@ -1738,16 +1738,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(&@fn_ctxt fcx, &@ast.expr f,\n-                          &vec[option.t[@ast.expr]] args)\n-            -> tup(@ast.expr, vec[option.t[@ast.expr]]) {\n+                          &vec[Option.t[@ast.expr]] args)\n+            -> tup(@ast.expr, vec[Option.t[@ast.expr]]) {\n \n         // Check the function.\n         auto f_0 = check_expr(fcx, f);\n \n         // Check the arguments and generate the argument signature.\n-        let vec[option.t[@ast.expr]] args_0 = vec();\n+        let vec[Option.t[@ast.expr]] args_0 = vec();\n         let vec[arg] arg_tys_0 = vec();\n-        for (option.t[@ast.expr] a_opt in args) {\n+        for (Option.t[@ast.expr] a_opt in args) {\n             alt (a_opt) {\n                 case (some[@ast.expr](?a)) {\n                     auto a_0 = check_expr(fcx, a);\n@@ -1756,14 +1756,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n                     auto arg_ty = rec(mode=ast.val,\n                                       ty=expr_ty(fcx.ccx.tcx, a_0));\n-                    _vec.push[arg](arg_tys_0, arg_ty);\n+                    Vec.push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast.expr]) {\n                     args_0 += vec(none[@ast.expr]);\n \n                     // FIXME: breaks aliases too?\n                     auto typ = next_ty_var(fcx.ccx);\n-                    _vec.push[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n+                    Vec.push[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n                 }\n             }\n         }\n@@ -1812,7 +1812,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     fn check_call(&@fn_ctxt fcx, @ast.expr f, vec[@ast.expr] args)\n         -> tup(@ast.expr, vec[@ast.expr]) {\n \n-        let vec[option.t[@ast.expr]] args_opt_0 = vec();\n+        let vec[Option.t[@ast.expr]] args_opt_0 = vec();\n         for (@ast.expr arg in args) {\n             args_opt_0 += vec(some[@ast.expr](arg));\n         }\n@@ -1822,8 +1822,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         // Pull out the arguments.\n         let vec[@ast.expr] args_1 = vec();\n-        for (option.t[@ast.expr] arg in result._1) {\n-            args_1 += vec(option.get[@ast.expr](arg));\n+        for (Option.t[@ast.expr] arg in result._1) {\n+            args_1 += vec(Option.get[@ast.expr](arg));\n         }\n \n         ret tup(result._0, args_1);\n@@ -1901,7 +1901,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n             assert (defopt != none[ast.def]);\n-            auto defn = option.get[ast.def](defopt);\n+            auto defn = Option.get[ast.def](defopt);\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n \n@@ -1913,7 +1913,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n-            if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n+            if (Vec.len[@ast.ty](pth.node.types) > 0u) {\n                 fcx.ccx.sess.span_err(expr.span, \"this kind of value does \" +\n                                       \"not take type parameters\");\n                 fail;\n@@ -2295,7 +2295,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     // For each blank argument, add the type of that argument\n                     // to the resulting function type.\n                     auto i = 0u;\n-                    while (i < _vec.len[option.t[@ast.expr]](args)) {\n+                    while (i < Vec.len[Option.t[@ast.expr]](args)) {\n                         alt (args.(i)) {\n                             case (some[@ast.expr](_)) { /* no-op */ }\n                             case (none[@ast.expr]) {\n@@ -2434,7 +2434,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             let vec[@ast.expr] args_1 = vec();\n \n             let ty.t t;\n-            if (_vec.len[@ast.expr](args) == 0u) {\n+            if (Vec.len[@ast.expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n@@ -2445,7 +2445,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 auto expr_1 = check_expr(fcx, e);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n                 Demand.simple(fcx, expr.span, t, expr_t);\n-                _vec.push[@ast.expr](args_1,expr_1);\n+                Vec.push[@ast.expr](args_1,expr_1);\n             }\n \n             auto ann = triv_ann(ty.mk_vec(fcx.ccx.tcx,\n@@ -2461,7 +2461,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n-                _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n+                Vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n@@ -2486,10 +2486,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n-                _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n+                Vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n-                _vec.push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n+                Vec.push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n             }\n \n             auto ann = ast.ann_none;\n@@ -2521,7 +2521,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     for (ty.field f in fields_t) {\n                         auto found = false;\n                         for (ty.field bf in base_fields) {\n-                            if (_str.eq(f.ident, bf.ident)) {\n+                            if (Str.eq(f.ident, bf.ident)) {\n                                 Demand.simple(fcx, expr.span, f.mt.ty,\n                                               bf.mt.ty);\n                                 found = true;\n@@ -2549,7 +2549,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n-                    if (ix >= _vec.len[ty.mt](args)) {\n+                    if (ix >= Vec.len[ty.mt](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n@@ -2563,7 +2563,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_rec(?fields)) {\n                     let uint ix = ty.field_idx(fcx.ccx.sess,\n                                                expr.span, field, fields);\n-                    if (ix >= _vec.len[typeck.field](fields)) {\n+                    if (ix >= Vec.len[typeck.field](fields)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n@@ -2577,7 +2577,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_obj(?methods)) {\n                     let uint ix = ty.method_idx(fcx.ccx.sess,\n                                                 expr.span, field, methods);\n-                    if (ix >= _vec.len[typeck.method](methods)) {\n+                    if (ix >= Vec.len[typeck.method](methods)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on obj\");\n                     }\n@@ -2775,7 +2775,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in block.node.stmts) {\n-        _vec.push[@ast.stmt](stmts, check_stmt(fcx, s));\n+        Vec.push[@ast.stmt](stmts, check_stmt(fcx, s));\n     }\n \n     auto expr = none[@ast.expr];\n@@ -2900,7 +2900,7 @@ fn hash_unify_cache_entry(&unify_cache_entry uce) -> uint {\n     h += h << 5u + ty.hash_ty(uce._1);\n \n     auto i = 0u;\n-    auto tys_len = _vec.len(uce._2);\n+    auto tys_len = Vec.len(uce._2);\n     while (i < tys_len) {\n         h += h << 5u + ty.hash_ty(uce._2.(i));\n         i += 1u;\n@@ -2913,8 +2913,8 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n     if (!ty.eq_ty(a._0, b._0) || !ty.eq_ty(a._1, b._1)) { ret false; }\n \n     auto i = 0u;\n-    auto tys_len = _vec.len(a._2);\n-    if (_vec.len(b._2) != tys_len) { ret false; }\n+    auto tys_len = Vec.len(a._2);\n+    if (Vec.len(b._2) != tys_len) { ret false; }\n \n     while (i < tys_len) {\n         if (!ty.eq_ty(a._2.(i), b._2.(i))) { ret false; }\n@@ -2957,7 +2957,7 @@ fn check_crate(ty.ctxt tcx, @ast.crate crate)\n     auto hasher = hash_unify_cache_entry;\n     auto eqer = eq_unify_cache_entry;\n     auto unify_cache =\n-        map.mk_hashmap[unify_cache_entry,ty.Unify.result](hasher, eqer);\n+        Map.mk_hashmap[unify_cache_entry,ty.Unify.result](hasher, eqer);\n     auto fpt =\n         mk_fn_purity_table(crate); // use a variation on Collect\n "}, {"sha": "e571fa21ee56743307d348e3c6679286800ce348", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -155,37 +155,37 @@ import pretty.pprust.print_block;\n import pretty.pprust.print_expr;\n import pretty.pprust.print_decl;\n import pretty.pp.mkstate;\n-import std.io.stdout;\n-import std.io.str_writer;\n-import std.io.string_writer;\n-import std._vec.map;\n-import std._vec;\n-import std._vec.len;\n-import std._vec.pop;\n-import std._vec.push;\n-import std._vec.slice;\n-import std._vec.unzip;\n-import std._vec.plus_option;\n-import std._vec.cat_options;\n-import std.option;\n-import std.option.t;\n-import std.option.some;\n-import std.option.none;\n-import std.option.from_maybe;\n-import std.option.maybe;\n-import std.option.is_none;\n-import std.option.get;\n-import std.map.hashmap;\n-import std.list;\n-import std.list.list;\n-import std.list.cons;\n-import std.list.nil;\n-import std.list.foldl;\n-import std.list.find;\n-import std._uint;\n-import std.bitv;\n-import std.util.fst;\n-import std.util.snd;\n+import std.IO.stdout;\n+import std.IO.str_writer;\n+import std.IO.string_writer;\n+import std.Vec.map;\n+import std.Vec;\n+import std.Vec.len;\n+import std.Vec.pop;\n+import std.Vec.push;\n+import std.Vec.slice;\n+import std.Vec.unzip;\n+import std.Vec.plus_option;\n+import std.Vec.cat_options;\n+import std.Option;\n+import std.Option.t;\n+import std.Option.some;\n+import std.Option.none;\n+import std.Option.from_maybe;\n+import std.Option.maybe;\n+import std.Option.is_none;\n+import std.Option.get;\n+import std.Map.hashmap;\n+import std.List;\n+import std.List.list;\n+import std.List.cons;\n+import std.List.nil;\n+import std.List.foldl;\n+import std.List.find;\n+import std.UInt;\n+import std.BitV;\n+import std.Util.fst;\n+import std.Util.snd;\n \n import util.typestate_ann;\n import util.typestate_ann.difference;\n@@ -195,22 +195,22 @@ import util.typestate_ann.require_and_preserve;\n \n /**** debugging junk  ****/\n \n-fn bitv_to_str(fn_info enclosing, bitv.t v) -> str {\n+fn bitv_to_str(fn_info enclosing, BitV.t v) -> str {\n   auto s = \"\";\n \n   for each (@tup(def_id, tup(uint, ident)) p in enclosing.items()) {\n-    if (bitv.get(v, p._1._0)) {\n+    if (BitV.get(v, p._1._0)) {\n       s += \" \" + p._1._1 + \" \";\n     }\n   }\n   ret s;\n }\n \n-fn log_bitv(fn_info enclosing, bitv.t v) {\n+fn log_bitv(fn_info enclosing, BitV.t v) {\n     log(bitv_to_str(enclosing, v));\n }\n \n-fn log_bitv_err(fn_info enclosing, bitv.t v) {\n+fn log_bitv_err(fn_info enclosing, BitV.t v) {\n     log_err(bitv_to_str(enclosing, v));\n }\n \n@@ -235,35 +235,35 @@ fn log_cond_err(vec[uint] v) -> () {\n }\n \n fn log_pp(&pre_and_post pp) -> () {\n-  auto p1 = bitv.to_vec(pp.precondition);\n-  auto p2 = bitv.to_vec(pp.postcondition);\n+  auto p1 = BitV.to_vec(pp.precondition);\n+  auto p2 = BitV.to_vec(pp.postcondition);\n   log(\"pre:\");\n   log_cond(p1);\n   log(\"post:\");\n   log_cond(p2);\n }\n \n fn log_pp_err(&pre_and_post pp) -> () {\n-  auto p1 = bitv.to_vec(pp.precondition);\n-  auto p2 = bitv.to_vec(pp.postcondition);\n+  auto p1 = BitV.to_vec(pp.precondition);\n+  auto p2 = BitV.to_vec(pp.postcondition);\n   log_err(\"pre:\");\n   log_cond_err(p1);\n   log_err(\"post:\");\n   log_cond_err(p2);\n }\n \n fn log_states(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv.to_vec(pp.prestate);\n-  auto p2 = bitv.to_vec(pp.poststate);\n+  auto p1 = BitV.to_vec(pp.prestate);\n+  auto p2 = BitV.to_vec(pp.poststate);\n   log(\"prestate:\");\n   log_cond(p1);\n   log(\"poststate:\");\n   log_cond(p2);\n }\n \n fn log_states_err(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv.to_vec(pp.prestate);\n-  auto p2 = bitv.to_vec(pp.poststate);\n+  auto p1 = BitV.to_vec(pp.prestate);\n+  auto p2 = BitV.to_vec(pp.poststate);\n   log_err(\"prestate:\");\n   log_cond_err(p1);\n   log_err(\"poststate:\");\n@@ -288,9 +288,9 @@ fn print_idents(vec[ident] idents) -> () {\n    variable in a given function) to bit number \n    (also remembers the ident for error-logging purposes) */\n type var_info     = tup(uint, ident);\n-type fn_info      = std.map.hashmap[def_id, var_info];\n+type fn_info      = std.Map.hashmap[def_id, var_info];\n /* mapping from function name to fn_info map */\n-type fn_info_map = std.map.hashmap[def_id, fn_info];\n+type fn_info_map = std.Map.hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n   assert (m.contains_key(v));\n@@ -312,12 +312,12 @@ fn num_locals(fn_info m) -> uint {\n fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, @ast.local loc) \n     -> @decl {\n     log(\"collect_local: pushing \" + loc.ident);\n-    _vec.push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    Vec.push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n     ret @respan(sp, decl_local(loc));\n }\n \n fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n-  auto res = @_vec.alloc[tup(ident,def_id)](0u);\n+  auto res = @Vec.alloc[tup(ident,def_id)](0u);\n \n   auto fld = fold.new_identity_fold[@vec[tup(ident, def_id)]]();\n   fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n@@ -343,7 +343,7 @@ fn mk_fn_info(_fn f) -> fn_info {\n      just collect locally declared vars */\n \n   let @vec[tup(ident,def_id)] locals = find_locals(f);\n-  log(uistr(_vec.len[tup(ident, def_id)](*locals)) + \" locals\");\n+  log(uistr(Vec.len[tup(ident, def_id)](*locals)) + \" locals\");\n   for (tup(ident,def_id) p in *locals) {\n     next = add_var(p._1, p._0, next, res);\n   }\n@@ -364,7 +364,7 @@ fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, ident i, &ast._fn f,\n    function IDs to fn_info maps */\n fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, ident i, &ast._obj o,\n      vec[ast.ty_param] ty_params, ast.obj_def_ids odid, ann a) -> @item {\n-    auto all_methods = _vec.clone[@method](o.methods);\n+    auto all_methods = Vec.clone[@method](o.methods);\n     plus_option[@method](all_methods, o.dtor);\n     for (@method m in all_methods) {\n         fi.insert(m.node.id, mk_fn_info(m.node.meth));\n@@ -403,7 +403,7 @@ fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   }\n }\n \n-fn ann_to_ts_ann_fail(ann a) -> option.t[@ts_ann] {\n+fn ann_to_ts_ann_fail(ann a) -> Option.t[@ts_ann] {\n   alt (a) {\n       case (ann_none) { \n           log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n@@ -432,7 +432,7 @@ fn ann_to_poststate(ann a) -> poststate {\n     ret (ann_to_ts_ann_fail_more(a)).states.poststate;\n }\n \n-fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n+fn stmt_to_ann(&stmt s) -> Option.t[@ts_ann] {\n   alt (s.node) {\n     case (stmt_decl(_,?a)) {\n         ret ann_to_ts_ann_fail(a);\n@@ -652,7 +652,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n /* works on either postconds or preconds\n  should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec.len[postcond](rest);\n+  auto sz = Vec.len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -665,7 +665,7 @@ fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n \n fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n   if (len[postcond](pcs) > 0u) {\n-      ret union_postconds_go(bitv.clone(pcs.(0)), pcs);\n+      ret union_postconds_go(BitV.clone(pcs.(0)), pcs);\n   }\n   else {\n       ret empty_prestate(nv);\n@@ -674,7 +674,7 @@ fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n \n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec.len[postcond](rest);\n+  auto sz = Vec.len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -689,7 +689,7 @@ fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n   assert (len[postcond](pcs) > 0u);\n \n-  ret intersect_postconds_go(bitv.clone(pcs.(0)), pcs);\n+  ret intersect_postconds_go(BitV.clone(pcs.(0)), pcs);\n }\n \n /******* AST-traversing code ********/\n@@ -720,8 +720,8 @@ fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n         find_pre_post_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n-    _vec.map[@method, ()](f, o.methods);\n-    option.map[@method, ()](f, o.dtor);\n+    Vec.map[@method, ()](f, o.methods);\n+    Option.map[@method, ()](f, o.dtor);\n }\n \n fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n@@ -730,8 +730,8 @@ fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n         ret find_pre_post_state_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n-    auto flags = _vec.map[@method, bool](f, o.methods);\n-    auto changed = _vec.or(flags);\n+    auto flags = Vec.map[@method, bool](f, o.methods);\n+    auto changed = Vec.or(flags);\n     changed = changed || maybe[@method, bool](false, f, o.dtor);\n     ret changed;\n }\n@@ -777,19 +777,19 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n     }\n     auto f = bind do_one(fm, enclosing, _);\n \n-    _vec.map[@expr, ()](f, args);\n+    Vec.map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp;\n-    auto pps = _vec.map[@expr, pre_and_post](g, args);\n+    auto pps = Vec.map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n     set_pre_and_post(a,\n        rec(precondition=seq_preconds(enclosing, pps),\n            postcondition=union_postconds\n-           (nv, (_vec.map[pre_and_post, postcond](h, pps)))));\n+           (nv, (Vec.map[pre_and_post, postcond](h, pps)))));\n }\n \n fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n@@ -822,13 +822,13 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n-            auto args = _vec.clone[@expr](operands);\n-            _vec.push[@expr](args, operator);\n+            auto args = Vec.clone[@expr](operands);\n+            Vec.push[@expr](args, operator);\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-            auto args = _vec.clone[@expr](operands);\n-            _vec.push[@expr](args, operator);\n+            auto args = Vec.clone[@expr](operands);\n+            Vec.push[@expr](args, operator);\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n         case (expr_vec(?args, _, ?a)) {\n@@ -888,7 +888,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n-            _vec.plus_option[@expr](es, maybe_base);\n+            Vec.plus_option[@expr](es, maybe_base);\n             find_pre_post_exprs(fm, enclosing, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n@@ -1051,7 +1051,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                 ret block_pp(an_alt.block);\n             }\n             auto f = bind do_an_alt(fm, enclosing, _);\n-            auto alt_pps = _vec.map[arm, pre_and_post](f, alts);\n+            auto alt_pps = Vec.map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n@@ -1065,7 +1065,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, enclosing, _, _);\n \n-            auto alts_overall_pp = _vec.foldl[pre_and_post, pre_and_post]\n+            auto alts_overall_pp = Vec.foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n \n             set_pre_and_post(a, alts_overall_pp);\n@@ -1091,8 +1091,8 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n-            auto args = _vec.cat_options[@expr](maybe_args);\n-            _vec.push[@expr](args, operator); /* ??? order of eval? */\n+            auto args = Vec.cat_options[@expr](maybe_args);\n+            Vec.push[@expr](args, operator); /* ??? order of eval? */\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n         case (expr_break(?a)) {\n@@ -1210,33 +1210,33 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     }\n     auto do_one = bind do_one_(fm, enclosing, _);\n     \n-    _vec.map[@stmt, ()](do_one, b.node.stmts);\n+    Vec.map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(fn_info_map fm, fn_info i, &@expr e) -> () {\n         find_pre_post_expr(fm, i, e);\n     }\n     auto do_inner = bind do_inner_(fm, enclosing, _);\n-    option.map[@expr, ()](do_inner, b.node.expr);\n+    Option.map[@expr, ()](do_inner, b.node.expr);\n \n     let vec[pre_and_post] pps = vec();\n \n     fn get_pp_stmt(&@stmt s) -> pre_and_post {\n         ret stmt_pp(*s);\n     }\n     auto f = get_pp_stmt;\n-    pps += _vec.map[@stmt, pre_and_post](f, b.node.stmts);\n+    pps += Vec.map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n-       option.map[@expr, pre_and_post](g, b.node.expr));\n+       Option.map[@expr, pre_and_post](g, b.node.expr));\n \n     auto block_precond  = seq_preconds(enclosing, pps);\n     auto h = get_post;\n-    auto postconds =  _vec.map[pre_and_post, postcond](h, pps);\n+    auto postconds =  Vec.map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    _vec.push[postcond](postconds, block_precond);\n+    Vec.push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n     if (! has_nonlocal_exits(b)) {\n@@ -1696,7 +1696,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n         auto e_post = expr_poststate(e);\n         auto a_post;\n-        if (_vec.len[arm](alts) > 0u) {\n+        if (Vec.len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n                 changed = find_pre_post_state_block(fm, enclosing, e_post,\n@@ -1775,9 +1775,9 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n               log(\"*At beginning: stmt = \");\n               log_stmt(*s);\n               log(\"*prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n+              log(BitV.to_str(stmt_ann.states.prestate));\n               log(\"*poststate =\");\n-              log(bitv.to_str(stmt_ann.states.poststate));\n+              log(BitV.to_str(stmt_ann.states.poststate));\n               log(\"*changed =\");\n               log(changed);\n   \n@@ -1798,7 +1798,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n               log(\"Summary: stmt = \");\n               log_stmt(*s);\n               log(\"prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n+              log(BitV.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n               log(\"poststate =\");\n               log_bitv(enclosing, stmt_ann.states.poststate);\n@@ -1835,10 +1835,10 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                     log(\"Summary: stmt = \");\n               log_stmt(*s);\n               log(\"prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n+              log(BitV.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n               log(\"poststate =\");\n-              log(bitv.to_str(stmt_ann.states.poststate));\n+              log(BitV.to_str(stmt_ann.states.poststate));\n               log_bitv(enclosing, stmt_ann.states.poststate);\n               log(\"changed =\");\n               log(changed);\n@@ -1986,12 +1986,12 @@ fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n   }\n   auto do_one = bind do_one_(enclosing, _);\n  \n-  _vec.map[@stmt, ()](do_one, f.body.node.stmts);\n+  Vec.map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> () {\n     check_states_expr(i, e);\n   }\n   auto do_inner = bind do_inner_(enclosing, _);\n-  option.map[@expr, ()](do_inner, f.body.node.expr);\n+  Option.map[@expr, ()](do_inner, f.body.node.expr);\n   \n }\n \n@@ -2027,13 +2027,13 @@ fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n }\n \n fn check_obj_state(&fn_info_map f_info_map, vec[obj_field] fields,\n-                  vec[@method] methods, option.t[@method] dtor) -> ast._obj {\n+                  vec[@method] methods, Option.t[@method] dtor) -> ast._obj {\n     fn one(fn_info_map fm, &@method m) -> () {\n         ret check_method_states(fm, m);\n     }\n     auto f = bind one(f_info_map,_);\n-    _vec.map[@method, ()](f, methods);\n-    option.map[@method, ()](f, dtor);\n+    Vec.map[@method, ()](f, methods);\n+    Option.map[@method, ()](f, dtor);\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n@@ -2122,15 +2122,15 @@ fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec.map[@expr, @expr](f, es);\n+    ret Vec.map[@expr, @expr](f, es);\n }\n fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n     fn one(fn_info_map fm, &elt e) -> elt {\n         ret rec(mut=e.mut,\n                 expr=annotate_expr(fm, e.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec.map[elt, elt](f, es);\n+    ret Vec.map[elt, elt](f, es);\n }\n fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n     fn one(fn_info_map fm, &field f) -> field {\n@@ -2139,31 +2139,31 @@ fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n                  expr=annotate_expr(fm, f.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec.map[field, field](f, fs);\n+    ret Vec.map[field, field](f, fs);\n }\n-fn annotate_option_exp(&fn_info_map fm, &option.t[@expr] o)\n-  -> option.t[@expr] {\n+fn annotate_option_exp(&fn_info_map fm, &Option.t[@expr] o)\n+  -> Option.t[@expr] {\n     fn one(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret option.map[@expr, @expr](f, o);\n+    ret Option.map[@expr, @expr](f, o);\n }\n-fn annotate_option_exprs(&fn_info_map fm, &vec[option.t[@expr]] es)\n-  -> vec[option.t[@expr]] {\n-    fn one(fn_info_map fm, &option.t[@expr] o) -> option.t[@expr] {\n+fn annotate_option_exprs(&fn_info_map fm, &vec[Option.t[@expr]] es)\n+  -> vec[Option.t[@expr]] {\n+    fn one(fn_info_map fm, &Option.t[@expr] o) -> Option.t[@expr] {\n         ret annotate_option_exp(fm, o);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec.map[option.t[@expr], option.t[@expr]](f, es);\n+    ret Vec.map[Option.t[@expr], Option.t[@expr]](f, es);\n }\n fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n     auto d1 = d.node;\n     alt (d.node) {\n         case (decl_local(?l)) {\n             alt(l.init) {\n                 case (some[initializer](?init)) {\n-                    let option.t[initializer] an_i =\n+                    let Option.t[initializer] an_i =\n                         some[initializer]\n                           (rec(expr=annotate_expr(fm, init.expr)\n                                  with init));\n@@ -2186,7 +2186,7 @@ fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n                  index=a.index);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec.map[arm, arm](f, alts);\n+    ret Vec.map[arm, arm](f, alts);\n \n }\n fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n@@ -2338,15 +2338,15 @@ fn annotate_block(&fn_info_map fm, &block b) -> block {\n \n     for (@stmt s in b.node.stmts) {\n         auto new_s = annotate_stmt(fm, s);\n-        _vec.push[@stmt](new_stmts, new_s);\n+        Vec.push[@stmt](new_stmts, new_s);\n         ast.index_stmt(new_index, new_s);\n     }\n     fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind ann_e(fm,_);\n \n-    auto new_e = option.map[@expr, @expr](f, b.node.expr);\n+    auto new_e = Option.map[@expr, @expr](f, b.node.expr);\n \n     ret respan(b.span,\n           rec(stmts=new_stmts, expr=new_e, index=new_index with b.node));\n@@ -2362,7 +2362,7 @@ fn annotate_mod(&fn_info_map fm, &ast._mod m) -> ast._mod {\n \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n-        _vec.push[@item](new_items, new_i);\n+        Vec.push[@item](new_items, new_i);\n         ast.index_item(new_index, new_i);\n     }\n     ret rec(items=new_items, index=new_index with m);\n@@ -2383,8 +2383,8 @@ fn annotate_obj(&fn_info_map fm, &ast._obj o) -> ast._obj {\n         ret annotate_method(fm, m);\n     }\n     auto f = bind one(fm,_);\n-    auto new_methods = _vec.map[@method, @method](f, o.methods);\n-    auto new_dtor    = option.map[@method, @method](f, o.dtor);\n+    auto new_methods = Vec.map[@method, @method](f, o.methods);\n+    auto new_dtor    = Option.map[@method, @method](f, o.dtor);\n     ret rec(methods=new_methods, dtor=new_dtor with o);\n }\n \n@@ -2476,7 +2476,7 @@ fn annotate_module(&fn_info_map fm, &ast._mod module) -> ast._mod {\n \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);\n-        _vec.push[@item](new_items, new_item);\n+        Vec.push[@item](new_items, new_item);\n         ast.index_item(new_index, new_item);\n     }\n "}, {"sha": "2df69261f383ea1bc99cafc47cbba113c408592a", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n import front.ast;\n \n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n \n type ast_visitor =\n     rec(fn () -> bool                 keep_going,\n@@ -257,7 +257,7 @@ fn walk_decl(&ast_visitor v, @ast.decl d) {\n     v.visit_decl_post(d);\n }\n \n-fn walk_expr_opt(&ast_visitor v, option.t[@ast.expr] eo) {\n+fn walk_expr_opt(&ast_visitor v, Option.t[@ast.expr] eo) {\n     alt (eo) {\n         case (none[@ast.expr]) {}\n         case (some[@ast.expr](?e)) {\n@@ -297,7 +297,7 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n         case (ast.expr_self_method(_, _)) { }\n         case (ast.expr_bind(?callee, ?args, _)) {\n             walk_expr(v, callee);\n-            for (option.t[@ast.expr] eo in args) {\n+            for (Option.t[@ast.expr] eo in args) {\n                 walk_expr_opt(v, eo);\n             }\n         }"}, {"sha": "f966704253c8923ab688903d3e91a371d1b11db9", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,6 +1,6 @@\n-import std.io;\n-import std._vec;\n-import std._str;\n+import std.IO;\n+import std.Vec;\n+import std.Str;\n \n tag boxtype {box_h; box_v; box_hv; box_align;}\n tag contexttype {cx_h; cx_v;}\n@@ -19,7 +19,7 @@ type context = rec(contexttype tp, uint indent);\n \n type ps = @rec(mutable vec[context] context,\n                uint width,\n-               io.writer out,\n+               IO.writer out,\n                mutable uint col,\n                mutable uint spaces,\n                mutable vec[token] buffered,\n@@ -30,7 +30,7 @@ type ps = @rec(mutable vec[context] context,\n                mutable bool start_of_box,\n                mutable bool potential_brk);\n \n-fn mkstate(io.writer out, uint width) -> ps {\n+fn mkstate(IO.writer out, uint width) -> ps {\n   let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n   let vec[token] buff = vec();\n   let vec[boxtype] sd = vec();\n@@ -57,12 +57,12 @@ fn write_spaces(ps p, uint i) {\n \n fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  _vec.push[context](p.context, rec(tp=tp, indent=indent));\n+  Vec.push[context](p.context, rec(tp=tp, indent=indent));\n   p.start_of_box = true;\n }\n \n fn pop_context(ps p) {\n-  _vec.pop[context](p.context);\n+  Vec.pop[context](p.context);\n }\n \n fn add_token(ps p, token tok) {\n@@ -89,22 +89,22 @@ fn buffer_token(ps p, token tok) {\n   } else {\n     alt (tok) {\n       case (open(?tp,_)) {\n-        _vec.push[boxtype](p.scandepth, tp);\n+        Vec.push[boxtype](p.scandepth, tp);\n         if (p.scanning == scan_h) {\n           if (tp == box_h) {\n             check_potential_brk(p);\n           }\n         }\n       }\n       case (close) {\n-        _vec.pop[boxtype](p.scandepth);\n-        if (_vec.len[boxtype](p.scandepth) == 0u) {\n+        Vec.pop[boxtype](p.scandepth);\n+        if (Vec.len[boxtype](p.scandepth) == 0u) {\n           finish_scan(p, true);\n         }\n       }\n       case (brk(_)) {\n         if (p.scanning == scan_h) {\n-          if (p.scandepth.(_vec.len[boxtype](p.scandepth)-1u) == box_v) {\n+          if (p.scandepth.(Vec.len[boxtype](p.scandepth)-1u) == box_v) {\n             finish_scan(p, true);\n           }\n         }\n@@ -123,7 +123,7 @@ fn check_potential_brk(ps p) {\n \n fn finish_scan(ps p, bool fits) {\n   auto buf = p.buffered;\n-  auto front = _vec.shift[token](buf);\n+  auto front = Vec.shift[token](buf);\n   auto chosen_tp = cx_h;\n   if (!fits) {chosen_tp = cx_v;}\n   alt (front) {\n@@ -154,10 +154,10 @@ fn start_scan(ps p, token tok, scantype tp) {\n }\n \n fn cur_context(ps p) -> context {\n-  ret p.context.(_vec.len[context](p.context)-1u);\n+  ret p.context.(Vec.len[context](p.context)-1u);\n }\n fn base_indent(ps p) -> uint {\n-  auto i = _vec.len[context](p.context);\n+  auto i = Vec.len[context](p.context);\n   while (i > 0u) {\n     i -= 1u;\n     auto cx = p.context.(i);\n@@ -190,7 +190,7 @@ fn do_token(ps p, token tok) {\n       line_break(p);\n     }\n     case (word(?w)) {\n-      auto len = _str.char_len(w);\n+      auto len = Str.char_len(w);\n       if (len + p.col + p.spaces > p.width && !start_of_box &&\n           !p.start_of_line) {\n         line_break(p);\n@@ -202,7 +202,7 @@ fn do_token(ps p, token tok) {\n     case (cword(?w)) {\n       before_print(p, true);\n       p.out.write_str(w);\n-      p.col += _str.char_len(w);\n+      p.col += Str.char_len(w);\n     }\n     case (open(?tp, ?indent)) {\n       if (tp == box_v) {\n@@ -247,8 +247,8 @@ fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}\n     case (hardbrk) {ret 0xFFFFFFu;}\n-    case (word(?w)) {ret _str.char_len(w);}\n-    case (cword(?w)) {ret _str.char_len(w);}\n+    case (word(?w)) {ret Str.char_len(w);}\n+    case (cword(?w)) {ret Str.char_len(w);}\n     case (open(_, _)) {ret 0u;}\n     case (close) {ret 0u;}\n   }"}, {"sha": "17547bb65ac21da0212404d01b49079e1f864677", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,7 +1,7 @@\n-import std._vec;\n-import std._str;\n-import std.io;\n-import std.option;\n+import std.Vec;\n+import std.Str;\n+import std.IO;\n+import std.Option;\n import front.ast;\n import front.lexer;\n import util.common;\n@@ -12,39 +12,39 @@ const int as_prec = 5;\n const uint default_columns = 78u;\n \n type ps = @rec(pp.ps s,\n-               option.t[vec[lexer.cmnt]] comments,\n+               Option.t[vec[lexer.cmnt]] comments,\n                mutable uint cur_cmnt);\n \n-fn print_file(ast._mod _mod, str filename, io.writer out) {\n+fn print_file(ast._mod _mod, str filename, IO.writer out) {\n     auto cmnts = lexer.gather_comments(filename);\n     auto s = @rec(s=pp.mkstate(out, default_columns),\n-                  comments=option.some[vec[lexer.cmnt]](cmnts),\n+                  comments=Option.some[vec[lexer.cmnt]](cmnts),\n                   mutable cur_cmnt=0u);\n     print_mod(s, _mod);\n }\n \n fn ty_to_str(&@ast.ty ty) -> str {\n-    auto writer = io.string_writer();\n+    auto writer = IO.string_writer();\n     auto s = @rec(s=pp.mkstate(writer.get_writer(), 0u),\n-                  comments=option.none[vec[lexer.cmnt]],\n+                  comments=Option.none[vec[lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n     print_type(s, ty);\n     ret writer.get_str();\n }\n \n fn block_to_str(&ast.block blk) -> str {\n-    auto writer = io.string_writer();\n+    auto writer = IO.string_writer();\n     auto s = @rec(s=pp.mkstate(writer.get_writer(), 78u),\n-                  comments=option.none[vec[lexer.cmnt]],\n+                  comments=Option.none[vec[lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n     print_block(s, blk);\n     ret writer.get_str();\n }\n \n fn pat_to_str(&@ast.pat p) -> str {\n-    auto writer = io.string_writer();\n+    auto writer = IO.string_writer();\n     auto s = @rec(s=pp.mkstate(writer.get_writer(), 78u),\n-                  comments=option.none[vec[lexer.cmnt]],\n+                  comments=Option.none[vec[lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n     print_pat(s, p);\n     ret writer.get_str();\n@@ -92,7 +92,7 @@ fn commasep[IN](ps s, vec[IN] elts, fn(ps, &IN) op) {\n }\n fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n                             fn(&IN) -> common.span get_span) {\n-    auto len = _vec.len[IN](elts);\n+    auto len = Vec.len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n         op(s, elt);\n@@ -160,7 +160,7 @@ fn print_type(ps s, &@ast.ty ty) {\n             fn get_span(&ast.ty_field f) -> common.span {\n               // Try to reconstruct the span for this field\n               auto sp = f.mt.ty.span;\n-              auto hi = sp.hi + _str.char_len(f.ident) + 1u;\n+              auto hi = sp.hi + Str.char_len(f.ident) + 1u;\n               ret rec(hi=hi with sp);\n             }\n             auto f = print_field;\n@@ -173,7 +173,7 @@ fn print_type(ps s, &@ast.ty ty) {\n             bopen(s);\n             for (ast.ty_method m in methods) {\n                 hbox(s);\n-                print_ty_fn(s, m.proto, option.some[str](m.ident),\n+                print_ty_fn(s, m.proto, Option.some[str](m.ident),\n                             m.inputs, m.output);\n                 wrd(s.s, \";\");\n                 end(s.s);\n@@ -182,7 +182,7 @@ fn print_type(ps s, &@ast.ty ty) {\n             bclose_c(s, ty.span);\n         }\n         case (ast.ty_fn(?proto,?inputs,?output)) {\n-            print_ty_fn(s, proto, option.none[str], inputs, output);\n+            print_ty_fn(s, proto, Option.none[str], inputs, output);\n         }\n         case (ast.ty_path(?path,_)) {\n             print_path(s, path);\n@@ -240,8 +240,8 @@ fn print_item(ps s, @ast.item item) {\n                                              ?typarams,_,_)) {\n                         print_fn(s, decl, id, typarams);\n                         alt (lname) {\n-                            case (option.none[str]) {}\n-                            case (option.some[str](?ss)) {\n+                            case (Option.none[str]) {}\n+                            case (Option.some[str](?ss)) {\n                                 print_string(s, ss);\n                             }\n                         }\n@@ -270,7 +270,7 @@ fn print_item(ps s, @ast.item item) {\n             for (ast.variant v in variants) {\n                 maybe_print_comment(s, v.span.lo);\n                 wrd(s.s, v.node.name);\n-                if (_vec.len[ast.variant_arg](v.node.args) > 0u) {\n+                if (Vec.len[ast.variant_arg](v.node.args) > 0u) {\n                     popen(s);\n                     fn print_variant_arg(ps s, &ast.variant_arg arg) {\n                         print_type(s, arg.ty);\n@@ -314,7 +314,7 @@ fn print_item(ps s, @ast.item item) {\n                 line(s.s);\n             }\n             alt (_obj.dtor) {\n-                case (option.some[@ast.method](?dtor)) {\n+                case (Option.some[@ast.method](?dtor)) {\n                     hbox(s);\n                     wrd1(s, \"close\");\n                     print_block(s, dtor.node.meth.body);\n@@ -344,7 +344,7 @@ fn print_block(ps s, ast.block blk) {\n         if (!maybe_print_line_comment(s, st.span)) {line(s.s);}\n     }\n     alt (blk.node.expr) {\n-        case (option.some[@ast.expr](?expr)) {\n+        case (Option.some[@ast.expr](?expr)) {\n             print_expr(s, expr);\n             if (!maybe_print_line_comment(s, expr.span)) {line(s.s);}\n         }\n@@ -358,7 +358,7 @@ fn print_literal(ps s, @ast.lit lit) {\n     alt (lit.node) {\n         case (ast.lit_str(?st)) {print_string(s, st);}\n         case (ast.lit_char(?ch)) {\n-            wrd(s.s, \"'\" + escape_str(_str.from_bytes(vec(ch as u8)), '\\'')\n+            wrd(s.s, \"'\" + escape_str(Str.from_bytes(vec(ch as u8)), '\\'')\n                 + \"'\");\n         }\n         case (ast.lit_int(?val)) {\n@@ -432,8 +432,8 @@ fn print_expr(ps s, &@ast.expr expr) {\n             auto gs = get_span;\n             commasep_cmnt[ast.field](s, fields, f, gs);\n             alt (wth) {\n-                case (option.some[@ast.expr](?expr)) {\n-                    if (_vec.len[ast.field](fields) > 0u) {space(s.s);}\n+                case (Option.some[@ast.expr](?expr)) {\n+                    if (Vec.len[ast.field](fields) > 0u) {space(s.s);}\n                     hbox(s);\n                     wrd1(s, \"with\");\n                     print_expr(s, expr);\n@@ -454,9 +454,9 @@ fn print_expr(ps s, &@ast.expr expr) {\n             print_ident(s, ident);\n         }\n         case (ast.expr_bind(?func,?args,_)) {\n-            fn print_opt(ps s, &option.t[@ast.expr] expr) {\n+            fn print_opt(ps s, &Option.t[@ast.expr] expr) {\n                 alt (expr) {\n-                    case (option.some[@ast.expr](?expr)) {\n+                    case (Option.some[@ast.expr](?expr)) {\n                         print_expr(s, expr);\n                     }\n                     case (_) {wrd(s.s, \"_\");}\n@@ -466,7 +466,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n             print_expr(s, func);\n             popen(s);\n             auto f = print_opt;\n-            commasep[option.t[@ast.expr]](s, args, f);\n+            commasep[Option.t[@ast.expr]](s, args, f);\n             pclose(s);\n         }\n     case (ast.expr_spawn(_,_,?e,?es,_)) {\n@@ -504,7 +504,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n             space(s.s);\n             print_block(s, block);\n             alt (elseopt) {\n-                case (option.some[@ast.expr](?_else)) {\n+                case (Option.some[@ast.expr](?_else)) {\n                     space(s.s);\n                     wrd1(s, \"else\");\n                     print_expr(s, _else);\n@@ -627,7 +627,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n         case (ast.expr_ret(?result,_)) {\n             wrd(s.s, \"ret\");\n             alt (result) {\n-                case (option.some[@ast.expr](?expr)) {\n+                case (Option.some[@ast.expr](?expr)) {\n                     space(s.s);\n                     print_expr(s, expr);\n                 }\n@@ -637,7 +637,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n         case (ast.expr_put(?result,_)) {\n             wrd(s.s, \"put\");\n             alt (result) {\n-                case (option.some[@ast.expr](?expr)) {\n+                case (Option.some[@ast.expr](?expr)) {\n                     space(s.s);\n                     print_expr(s, expr);\n                 }\n@@ -670,7 +670,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n         case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n             wrd(s.s, \"#\");\n             print_path(s, path);\n-            if (_vec.len[@ast.expr](args) > 0u) {\n+            if (Vec.len[@ast.expr](args) > 0u) {\n                 popen(s);\n                 commasep_exprs(s, args);\n                 pclose(s);\n@@ -698,7 +698,7 @@ fn print_decl(ps s, @ast.decl decl) {\n     alt (decl.node) {\n         case (ast.decl_local(?loc)) {\n             alt (loc.ty) {\n-                case (option.some[@ast.ty](?ty)) {\n+                case (Option.some[@ast.ty](?ty)) {\n                     wrd1(s, \"let\");\n                     print_type(s, ty);\n                     space(s.s);\n@@ -709,7 +709,7 @@ fn print_decl(ps s, @ast.decl decl) {\n             }\n             wrd(s.s, loc.ident);\n             alt (loc.init) {\n-                case (option.some[ast.initializer](?init)) {\n+                case (Option.some[ast.initializer](?init)) {\n                     space(s.s);\n                     alt (init.op) {\n                         case (ast.init_assign) {\n@@ -738,7 +738,7 @@ fn print_ident(ps s, ast.ident ident) {\n fn print_for_decl(ps s, @ast.decl decl) {\n     alt (decl.node) {\n         case (ast.decl_local(?loc)) {\n-            print_type(s, option.get[@ast.ty](loc.ty));\n+            print_type(s, Option.get[@ast.ty](loc.ty));\n             space(s.s);\n             wrd(s.s, loc.ident);\n         }\n@@ -753,7 +753,7 @@ fn print_path(ps s, ast.path path) {\n         else {wrd(s.s, \".\");}\n         wrd(s.s, id);\n     }\n-    if (_vec.len[@ast.ty](path.node.types) > 0u) {\n+    if (Vec.len[@ast.ty](path.node.types) > 0u) {\n         wrd(s.s, \"[\");\n         auto f = print_type;\n         commasep[@ast.ty](s, path.node.types, f);\n@@ -769,7 +769,7 @@ fn print_pat(ps s, &@ast.pat pat) {\n         case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n         case (ast.pat_tag(?path,?args,_,_)) {\n             print_path(s, path);\n-            if (_vec.len[@ast.pat](args) > 0u) {\n+            if (Vec.len[@ast.pat](args) > 0u) {\n                 popen_h(s);\n                 auto f = print_pat;\n                 commasep[@ast.pat](s, args, f);\n@@ -814,7 +814,7 @@ fn print_fn(ps s, ast.fn_decl decl, str name,\n }\n \n fn print_type_params(ps s, vec[ast.ty_param] params) {\n-    if (_vec.len[ast.ty_param](params) > 0u) {\n+    if (Vec.len[ast.ty_param](params) > 0u) {\n         wrd(s.s, \"[\");\n         fn printParam(ps s, &ast.ty_param param) {\n             wrd(s.s, param);\n@@ -832,7 +832,7 @@ fn print_view_item(ps s, @ast.view_item item) {\n         case (ast.view_item_use(?id,?mta,_,_)) {\n             wrd1(s, \"use\");\n             wrd(s.s, id);\n-            if (_vec.len[@ast.meta_item](mta) > 0u) {\n+            if (Vec.len[@ast.meta_item](mta) > 0u) {\n                 popen(s);\n                 fn print_meta(ps s, &@ast.meta_item item) {\n                     hbox(s);\n@@ -848,7 +848,7 @@ fn print_view_item(ps s, @ast.view_item item) {\n         }\n         case (ast.view_item_import(?id,?ids,_,_)) {\n             wrd1(s, \"import\");\n-            if (!_str.eq(id, ids.(_vec.len[str](ids)-1u))) {\n+            if (!Str.eq(id, ids.(Vec.len[str](ids)-1u))) {\n                 wrd1(s, id);\n                 wrd1(s, \"=\");\n             }\n@@ -898,7 +898,7 @@ fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n \n fn escape_str(str st, char to_escape) -> str {\n     let str out = \"\";\n-    auto len = _str.byte_len(st);\n+    auto len = Str.byte_len(st);\n     auto i = 0u;\n     while (i < len) {\n         alt (st.(i) as char) {\n@@ -908,7 +908,7 @@ fn escape_str(str st, char to_escape) -> str {\n             case ('\\\\') {out += \"\\\\\\\\\";}\n             case (?cur) {\n                 if (cur == to_escape) {out += \"\\\\\";}\n-                _str.push_byte(out, cur as u8);\n+                Str.push_byte(out, cur as u8);\n             }\n         }\n         i += 1u;\n@@ -929,12 +929,12 @@ fn print_string(ps s, str st) {\n     wrd(s.s, \"\\\"\"); wrd(s.s, escape_str(st, '\"')); wrd(s.s, \"\\\"\");\n }\n \n-fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n+fn print_ty_fn(ps s, ast.proto proto, Option.t[str] id,\n                vec[ast.ty_arg] inputs, @ast.ty output) {\n     if (proto == ast.proto_fn) {wrd(s.s, \"fn\");}\n     else {wrd(s.s, \"iter\");}\n     alt (id) {\n-        case (option.some[str](?id)) {space(s.s); wrd(s.s, id);}\n+        case (Option.some[str](?id)) {space(s.s); wrd(s.s, id);}\n         case (_) {}\n     }\n     popen_h(s);\n@@ -955,21 +955,21 @@ fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n     }\n }\n \n-fn next_comment(ps s) -> option.t[lexer.cmnt] {\n+fn next_comment(ps s) -> Option.t[lexer.cmnt] {\n     alt (s.comments) {\n-        case (option.some[vec[lexer.cmnt]](?cmnts)) {\n-            if (s.cur_cmnt < _vec.len[lexer.cmnt](cmnts)) {\n-                ret option.some[lexer.cmnt](cmnts.(s.cur_cmnt));\n-            } else {ret option.none[lexer.cmnt];}\n+        case (Option.some[vec[lexer.cmnt]](?cmnts)) {\n+            if (s.cur_cmnt < Vec.len[lexer.cmnt](cmnts)) {\n+                ret Option.some[lexer.cmnt](cmnts.(s.cur_cmnt));\n+            } else {ret Option.none[lexer.cmnt];}\n         }\n-        case (_) {ret option.none[lexer.cmnt];}\n+        case (_) {ret Option.none[lexer.cmnt];}\n     }\n }\n \n fn maybe_print_comment(ps s, uint pos) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (option.some[lexer.cmnt](?cmnt)) {\n+            case (Option.some[lexer.cmnt](?cmnt)) {\n                 if (cmnt.pos < pos) {\n                     print_comment(s, cmnt.val);\n                     if (cmnt.space_after) {line(s.s);}\n@@ -983,7 +983,7 @@ fn maybe_print_comment(ps s, uint pos) {\n \n fn maybe_print_line_comment(ps s, common.span span) -> bool {\n     alt (next_comment(s)) {\n-        case (option.some[lexer.cmnt](?cmnt)) {\n+        case (Option.some[lexer.cmnt](?cmnt)) {\n             if (span.hi + 4u >= cmnt.pos) {\n                 wrd(s.s, \" \");\n                 print_comment(s, cmnt.val);\n@@ -999,7 +999,7 @@ fn maybe_print_line_comment(ps s, common.span span) -> bool {\n fn print_remaining_comments(ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (option.some[lexer.cmnt](?cmnt)) {\n+            case (Option.some[lexer.cmnt](?cmnt)) {\n                 print_comment(s, cmnt.val);\n                 if (cmnt.space_after) {line(s.s);}\n                 s.cur_cmnt += 1u;"}, {"sha": "b1a3989398688b03b208a3e8feda9b022ed379ef", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,18 +1,18 @@\n-import std.map;\n-import std.map.hashmap;\n-import std._uint;\n-import std._int;\n-import std._vec;\n-import std.option.none;\n+import std.Map;\n+import std.Map.hashmap;\n+import std.UInt;\n+import std.Int;\n+import std.Vec;\n+import std.Option.none;\n import front.ast;\n import util.typestate_ann.ts_ann;\n \n import middle.fold;\n import middle.fold.respan;\n \n-import std.io.stdout;\n-import std.io.str_writer;\n-import std.io.string_writer;\n+import std.IO.stdout;\n+import std.IO.str_writer;\n+import std.IO.string_writer;\n import pretty.pprust.print_block;\n import pretty.pprust.print_expr;\n import pretty.pprust.print_decl;\n@@ -56,10 +56,10 @@ fn ty_mach_to_str(ty_mach tm) -> str {\n     }\n }\n \n-fn new_str_hash[V]() -> std.map.hashmap[str,V] {\n-    let std.map.hashfn[str] hasher = std._str.hash;\n-    let std.map.eqfn[str] eqer = std._str.eq;\n-    ret std.map.mk_hashmap[str,V](hasher, eqer);\n+fn new_str_hash[V]() -> std.Map.hashmap[str,V] {\n+    let std.Map.hashfn[str] hasher = std.Str.hash;\n+    let std.Map.eqfn[str] eqer = std.Str.eq;\n+    ret std.Map.mk_hashmap[str,V](hasher, eqer);\n }\n \n fn def_eq(&ast.def_id a, &ast.def_id b) -> bool {\n@@ -73,48 +73,48 @@ fn hash_def(&ast.def_id d) -> uint {\n     ret h;\n }\n \n-fn new_def_hash[V]() -> std.map.hashmap[ast.def_id,V] {\n-    let std.map.hashfn[ast.def_id] hasher = hash_def;\n-    let std.map.eqfn[ast.def_id] eqer = def_eq;\n-    ret std.map.mk_hashmap[ast.def_id,V](hasher, eqer);\n+fn new_def_hash[V]() -> std.Map.hashmap[ast.def_id,V] {\n+    let std.Map.hashfn[ast.def_id] hasher = hash_def;\n+    let std.Map.eqfn[ast.def_id] eqer = def_eq;\n+    ret std.Map.mk_hashmap[ast.def_id,V](hasher, eqer);\n }\n \n-fn new_int_hash[V]() -> std.map.hashmap[int,V] {\n+fn new_int_hash[V]() -> std.Map.hashmap[int,V] {\n     fn hash_int(&int x) -> uint { ret x as uint; }\n     fn eq_int(&int a, &int b) -> bool { ret a == b; }\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n-    ret std.map.mk_hashmap[int,V](hasher, eqer);\n+    ret std.Map.mk_hashmap[int,V](hasher, eqer);\n }\n \n-fn new_uint_hash[V]() -> std.map.hashmap[uint,V] {\n+fn new_uint_hash[V]() -> std.Map.hashmap[uint,V] {\n     fn hash_uint(&uint x) -> uint { ret x; }\n     fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n     auto hasher = hash_uint;\n     auto eqer = eq_uint;\n-    ret std.map.mk_hashmap[uint,V](hasher, eqer);\n+    ret std.Map.mk_hashmap[uint,V](hasher, eqer);\n }\n \n fn istr(int i) -> str {\n-    ret _int.to_str(i, 10u);\n+    ret Int.to_str(i, 10u);\n }\n \n fn uistr(uint i) -> str {\n-    ret _uint.to_str(i, 10u);\n+    ret UInt.to_str(i, 10u);\n }\n \n fn elt_expr(&ast.elt e) -> @ast.expr { ret e.expr; }\n \n fn elt_exprs(&vec[ast.elt] elts) -> vec[@ast.expr] {\n     auto f = elt_expr;\n-    ret _vec.map[ast.elt, @ast.expr](f, elts);\n+    ret Vec.map[ast.elt, @ast.expr](f, elts);\n }\n \n fn field_expr(&ast.field f) -> @ast.expr { ret f.expr; }\n \n fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n     auto f = field_expr;\n-    ret _vec.map[ast.field, @ast.expr](f, fields);\n+    ret Vec.map[ast.field, @ast.expr](f, fields);\n }\n \n fn plain_ann(middle.ty.ctxt tcx) -> ast.ann {"}, {"sha": "949eaeb2f54b651618ed3bcd8a7855fc661da7be", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,21 +1,21 @@\n import front.ast.ident;\n-import std._vec;\n-import std.bitv;\n+import std.Vec;\n+import std.BitV;\n \n /* \n    This says: this expression requires the idents in <pre> to be initialized,\n    and given the precondition, it guarantees that the idents in <post> are\n    initialized.\n  */\n-type precond  = bitv.t; /* 1 means \"this variable must be initialized\"\n+type precond  = BitV.t; /* 1 means \"this variable must be initialized\"\n                            0 means \"don't care about this variable\" */\n-type postcond = bitv.t; /* 1 means \"this variable is initialized\"\n+type postcond = BitV.t; /* 1 means \"this variable is initialized\"\n                            0 means \"don't know about this variable */\n \n-type prestate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+type prestate = BitV.t; /* 1 means \"this variable is definitely initialized\"\n                            0 means \"don't know whether this variable is\n                            initialized\" */\n-type poststate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+type poststate = BitV.t; /* 1 means \"this variable is definitely initialized\"\n                             0 means \"don't know whether this variable is\n                             initialized\" */\n \n@@ -29,7 +29,7 @@ type pre_and_post_state = rec(prestate prestate, poststate poststate);\n type ts_ann = rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n-  be bitv.create(num_vars, false);\n+  be BitV.create(num_vars, false);\n }\n \n fn true_postcond(uint num_vars) -> postcond {\n@@ -45,7 +45,7 @@ fn empty_poststate(uint num_vars) -> poststate {\n }\n \n fn false_postcond(uint num_vars) -> postcond {\n-    be bitv.create(num_vars, true);\n+    be BitV.create(num_vars, true);\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {\n@@ -72,15 +72,15 @@ fn get_post(&pre_and_post p) -> postcond {\n }\n \n fn difference(&precond p1, &precond p2) -> bool {\n-  be bitv.difference(p1, p2);\n+  be BitV.difference(p1, p2);\n }\n \n fn union(&precond p1, &precond p2) -> bool {\n-  be bitv.union(p1, p2);\n+  be BitV.union(p1, p2);\n }\n \n fn intersect(&precond p1, &precond p2) -> bool {\n-  be bitv.intersect(p1, p2);\n+  be BitV.intersect(p1, p2);\n }\n \n fn pps_len(&pre_and_post p) -> uint {\n@@ -91,62 +91,62 @@ fn pps_len(&pre_and_post p) -> uint {\n \n fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n-  bitv.set(p.precondition, i, true);\n-  bitv.set(p.postcondition, i, true);\n+  BitV.set(p.precondition, i, true);\n+  BitV.set(p.postcondition, i, true);\n }\n \n fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n   // sets the ith bit in p's post\n-  auto was_set = bitv.get(p.postcondition, i);\n-  bitv.set(p.postcondition, i, true);\n+  auto was_set = BitV.get(p.postcondition, i);\n+  BitV.set(p.postcondition, i, true);\n   ret !was_set;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n   // sets the ith bit in p's post\n-  auto was_set = bitv.get(s.poststate, i);\n-  bitv.set(s.poststate, i, true);\n+  auto was_set = BitV.get(s.poststate, i);\n+  BitV.set(s.poststate, i, true);\n   ret !was_set;\n }\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n fn set_precondition(&ts_ann a, &precond p) -> () {\n-  bitv.copy(a.conditions.precondition, p);\n+  BitV.copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_postcondition(&ts_ann a, &postcond p) -> () {\n-  bitv.copy(a.conditions.postcondition, p);\n+  BitV.copy(a.conditions.postcondition, p);\n }\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n fn set_prestate(@ts_ann a, &prestate p) -> bool {\n-  ret bitv.copy(a.states.prestate, p);\n+  ret BitV.copy(a.states.prestate, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n fn set_poststate(@ts_ann a, &poststate p) -> bool {\n-  ret bitv.copy(a.states.poststate, p);\n+  ret BitV.copy(a.states.poststate, p);\n }\n \n // Set all the bits in p that are set in new\n fn extend_prestate(&prestate p, &poststate new) -> bool {\n-  ret bitv.union(p, new);\n+  ret BitV.union(p, new);\n }\n \n // Set all the bits in p that are set in new\n fn extend_poststate(&poststate p, &poststate new) -> bool {\n-  ret bitv.union(p, new);\n+  ret BitV.union(p, new);\n }\n \n // Clears the given bit in p\n fn relax_prestate(uint i, &prestate p) -> bool {\n-    auto was_set = bitv.get(p, i);\n-    bitv.set(p, i, false);\n+    auto was_set = BitV.get(p, i);\n+    BitV.set(p, i, false);\n     ret was_set;\n }\n \n@@ -164,16 +164,16 @@ fn pp_clone(&pre_and_post p) -> pre_and_post {\n }\n \n fn clone(prestate p) -> prestate {\n-    ret bitv.clone(p);\n+    ret BitV.clone(p);\n }\n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = 0\n-fn implies(bitv.t a, bitv.t b) -> bool {\n-  auto tmp = bitv.clone(b);\n-  bitv.difference(tmp, a);\n-  ret bitv.is_false(tmp);\n+fn implies(BitV.t a, BitV.t b) -> bool {\n+  auto tmp = BitV.clone(b);\n+  BitV.difference(tmp, a);\n+  ret BitV.is_false(tmp);\n }\n \n //"}, {"sha": "b0a4c9ea7f7bed3b83defa2b05d687b927164966", "filename": "src/lib/BitV.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FBitV.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FBitV.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FBitV.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -21,19 +21,19 @@ fn create(uint nbits, bool init) -> t {\n         elt = 0u;\n     }\n \n-    auto storage = _vec.init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    auto storage = Vec.init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n     ret rec(storage = storage, nbits = nbits);\n }\n \n fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n-    auto len = _vec.len(v1.storage);\n+    auto len = Vec.len(v1.storage);\n \n-    assert (_vec.len(v0.storage) == len);\n+    assert (Vec.len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n \n     auto changed = false;\n \n-    for each (uint i in _uint.range(0u, len)) {\n+    for each (uint i in UInt.range(0u, len)) {\n         auto w0 = v0.storage.(i);\n         auto w1 = v1.storage.(i);\n \n@@ -75,9 +75,9 @@ fn copy(&t v0, t v1) -> bool {\n }\n \n fn clone(t v) -> t {\n-    auto storage = _vec.init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n-    auto len = _vec.len(v.storage);\n-    for each (uint i in _uint.range(0u, len)) {\n+    auto storage = Vec.init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    auto len = Vec.len(v.storage);\n+    for each (uint i in UInt.range(0u, len)) {\n         storage.(i) = v.storage.(i);\n     }\n     ret rec(storage = storage, nbits = v.nbits);\n@@ -97,7 +97,7 @@ fn get(&t v, uint i) -> bool {\n fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n-    auto len = _vec.len(v1.storage);\n+    auto len = Vec.len(v1.storage);\n     auto i = 0u;\n     while (i < len) {\n         if (v0.storage.(i) != v1.storage.(i)) {\n@@ -109,13 +109,13 @@ fn equal(&t v0, &t v1) -> bool {\n }\n \n fn clear(&t v) {\n-    for each (uint i in _uint.range(0u, _vec.len(v.storage))) {\n+    for each (uint i in UInt.range(0u, Vec.len(v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n fn invert(&t v) {\n-    for each (uint i in _uint.range(0u, _vec.len(v.storage))) {\n+    for each (uint i in UInt.range(0u, Vec.len(v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n@@ -176,13 +176,13 @@ fn init_to_vec(t v, uint i) -> uint {\n \n fn to_vec(&t v) -> vec[uint] {\n     auto sub = bind init_to_vec(v, _);\n-    ret _vec.init_fn[uint](sub, v.nbits);\n+    ret Vec.init_fn[uint](sub, v.nbits);\n }\n \n fn to_str(&t v) -> str {\n     auto res = \"\";\n \n-    for (uint i in bitv.to_vec(v)) {\n+    for (uint i in BitV.to_vec(v)) {\n         if (i == 1u) {\n             res += \"1\";\n         }\n@@ -196,7 +196,7 @@ fn to_str(&t v) -> str {\n \n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n-    assert (v0.nbits == _vec.len[uint](v1));\n+    assert (v0.nbits == Vec.len[uint](v1));\n     auto len = v0.nbits;\n     auto i = 0u;\n     while (i < len) {", "previous_filename": "src/lib/bitv.rs"}, {"sha": "f155d1198f8a7ebff0f468f913754ecf21e9216d", "filename": "src/lib/Dbg.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FDbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FDbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FDbg.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -20,7 +20,7 @@ native \"rust\" mod rustrt {\n }\n \n fn debug_vec[T](vec[T] v) {\n-    _vec.print_debug_info[T](v);\n+    Vec.print_debug_info[T](v);\n }\n \n fn debug_tydesc[T]() {", "previous_filename": "src/lib/dbg.rs"}, {"sha": "a38e4fec446980a753e487b1b3d8c12d64bc80d0", "filename": "src/lib/Deque.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FDeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FDeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FDeque.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -19,7 +19,7 @@ type t[T] = obj {\n \n fn create[T]() -> t[T] {\n \n-    type cell[T] = option.t[T];\n+    type cell[T] = Option.t[T];\n \n     let uint initial_capacity = 32u; // 2^5\n \n@@ -28,25 +28,25 @@ fn create[T]() -> t[T] {\n      * elsewhere.\n      */\n     fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        assert (nelts == _vec.len[cell[T]](elts));\n+        assert (nelts == Vec.len[cell[T]](elts));\n \n         fn fill[T](uint i, uint nelts, uint lo,\n                    vec[cell[T]] old) -> cell[T] {\n             if (i < nelts) {\n                 ret old.((lo + i) % nelts);\n             } else {\n-                ret option.none[T];\n+                ret Option.none[T];\n             }\n         }\n \n-        let uint nalloc = _uint.next_power_of_two(nelts + 1u);\n-        let _vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-        ret _vec.init_fn[cell[T]](copy_op, nalloc);\n+        let uint nalloc = UInt.next_power_of_two(nelts + 1u);\n+        let Vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n+        ret Vec.init_fn[cell[T]](copy_op, nalloc);\n     }\n \n     fn get[T](vec[cell[T]] elts, uint i) -> T {\n         alt (elts.(i)) {\n-            case (option.some[T](?t)) { ret t; }\n+            case (Option.some[T](?t)) { ret t; }\n             case (_) { fail; }\n         }\n         fail;   // FIXME: remove me when exhaustiveness checking works\n@@ -63,18 +63,18 @@ fn create[T]() -> t[T] {\n                 let uint oldlo = lo;\n \n                 if (lo == 0u) {\n-                    lo = _vec.len[cell[T]](elts) - 1u;\n+                    lo = Vec.len[cell[T]](elts) - 1u;\n                 } else {\n                     lo -= 1u;\n                 }\n \n                 if (lo == hi) {\n                     elts = grow[T](nelts, oldlo, elts);\n-                    lo = _vec.len[cell[T]](elts) - 1u;\n+                    lo = Vec.len[cell[T]](elts) - 1u;\n                     hi = nelts;\n                 }\n \n-                elts.(lo) = option.some[T](t);\n+                elts.(lo) = Option.some[T](t);\n                 nelts += 1u;\n             }\n \n@@ -85,8 +85,8 @@ fn create[T]() -> t[T] {\n                     hi = nelts;\n                 }\n \n-                elts.(hi) = option.some[T](t);\n-                hi = (hi + 1u) % _vec.len[cell[T]](elts);\n+                elts.(hi) = Option.some[T](t);\n+                hi = (hi + 1u) % Vec.len[cell[T]](elts);\n                 nelts += 1u;\n             }\n \n@@ -96,21 +96,21 @@ fn create[T]() -> t[T] {\n              */\n             fn pop_front() -> T {\n                 let T t = get[T](elts, lo);\n-                elts.(lo) = option.none[T];\n-                lo = (lo + 1u) % _vec.len[cell[T]](elts);\n+                elts.(lo) = Option.none[T];\n+                lo = (lo + 1u) % Vec.len[cell[T]](elts);\n                 nelts -= 1u;\n                 ret t;\n             }\n \n             fn pop_back() -> T {\n                 if (hi == 0u) {\n-                    hi = _vec.len[cell[T]](elts) - 1u;\n+                    hi = Vec.len[cell[T]](elts) - 1u;\n                 } else {\n                     hi -= 1u;\n                 }\n \n                 let T t = get[T](elts, hi);\n-                elts.(hi) = option.none[T];\n+                elts.(hi) = Option.none[T];\n                 nelts -= 1u;\n                 ret t;\n             }\n@@ -124,12 +124,12 @@ fn create[T]() -> t[T] {\n             }\n \n             fn get(int i) -> T {\n-                let uint idx = (lo + (i as uint)) % _vec.len[cell[T]](elts);\n+                let uint idx = (lo + (i as uint)) % Vec.len[cell[T]](elts);\n                 ret get[T](elts, idx);\n             }\n \n         }\n-    let vec[cell[T]] v = _vec.init_elt[cell[T]](option.none[T],\n+    let vec[cell[T]] v = Vec.init_elt[cell[T]](Option.none[T],\n                                                 initial_capacity);\n \n     ret deque[T](0u, 0u, 0u, v);", "previous_filename": "src/lib/deque.rs"}, {"sha": "9b17bf06a682867f51b5fa6acdd77f1002966a12", "filename": "src/lib/EBML.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FEBML.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FEBML.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FEBML.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,8 +2,8 @@\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n \n-import option.none;\n-import option.some;\n+import Option.none;\n+import Option.some;\n \n type ebml_tag = rec(uint id, uint size);\n type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n@@ -38,7 +38,7 @@ fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n }\n \n fn new_doc(vec[u8] data) -> doc {\n-    ret rec(data=data, start=0u, end=_vec.len[u8](data));\n+    ret rec(data=data, start=0u, end=Vec.len[u8](data));\n }\n \n fn doc_at(vec[u8] data, uint start) -> doc {\n@@ -48,7 +48,7 @@ fn doc_at(vec[u8] data, uint start) -> doc {\n     ret rec(data=data, start=elt_size._1, end=end);\n }\n \n-fn maybe_get_doc(doc d, uint tg) -> option.t[doc] {\n+fn maybe_get_doc(doc d, uint tg) -> Option.t[doc] {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(d.data, pos);\n@@ -65,7 +65,7 @@ fn get_doc(doc d, uint tg) -> doc {\n     alt (maybe_get_doc(d, tg)) {\n         case (some[doc](?d)) {ret d;}\n         case (none[doc]) {\n-            log_err \"failed to find block with tag \" + _uint.to_str(tg, 10u);\n+            log_err \"failed to find block with tag \" + UInt.to_str(tg, 10u);\n             fail;\n         }\n     }\n@@ -94,7 +94,7 @@ iter tagged_docs(doc d, uint tg) -> doc {\n }\n \n fn doc_data(doc d) -> vec[u8] {\n-    ret _vec.slice[u8](d.data, d.start, d.end);\n+    ret Vec.slice[u8](d.data, d.start, d.end);\n }\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n@@ -116,9 +116,9 @@ fn doc_as_uint(doc d) -> uint {\n \n // EBML writing\n \n-type writer = rec(io.buf_writer writer, mutable vec[uint] size_positions);\n+type writer = rec(IO.buf_writer writer, mutable vec[uint] size_positions);\n \n-fn write_sized_vint(&io.buf_writer w, uint n, uint size) {\n+fn write_sized_vint(&IO.buf_writer w, uint n, uint size) {\n     let vec[u8] buf;\n     alt (size) {\n         case (1u) {\n@@ -148,7 +148,7 @@ fn write_sized_vint(&io.buf_writer w, uint n, uint size) {\n     w.write(buf);\n }\n \n-fn write_vint(&io.buf_writer w, uint n) {\n+fn write_vint(&IO.buf_writer w, uint n) {\n     if (n < 0x7fu)          { write_sized_vint(w, n, 1u); ret; }\n     if (n < 0x4000u)        { write_sized_vint(w, n, 2u); ret; }\n     if (n < 0x200000u)      { write_sized_vint(w, n, 3u); ret; }\n@@ -157,7 +157,7 @@ fn write_vint(&io.buf_writer w, uint n) {\n     fail;\n }\n \n-fn create_writer(&io.buf_writer w) -> writer {\n+fn create_writer(&IO.buf_writer w) -> writer {\n     let vec[uint] size_positions = vec();\n     ret rec(writer=w, mutable size_positions=size_positions);\n }\n@@ -175,11 +175,11 @@ fn start_tag(&writer w, uint tag_id) {\n }\n \n fn end_tag(&writer w) {\n-    auto last_size_pos = _vec.pop[uint](w.size_positions);\n+    auto last_size_pos = Vec.pop[uint](w.size_positions);\n     auto cur_pos = w.writer.tell();\n-    w.writer.seek(last_size_pos as int, io.seek_set);\n+    w.writer.seek(last_size_pos as int, IO.seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n-    w.writer.seek(cur_pos as int, io.seek_set);\n+    w.writer.seek(cur_pos as int, IO.seek_set);\n }\n \n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently", "previous_filename": "src/lib/ebml.rs"}, {"sha": "0510a2a87ec3d8b96ab640f8e9262f17ef46875b", "filename": "src/lib/ExtFmt.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FExtFmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FExtFmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FExtFmt.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -13,8 +13,8 @@\n  * combinations at the moment.\n  */\n \n-import option.none;\n-import option.some;\n+import Option.none;\n+import Option.some;\n \n /*\n  * We have a CT (compile-time) module that parses format strings into a\n@@ -66,7 +66,7 @@ mod CT {\n     }\n \n     // A formatted conversion from an expression to a string\n-    type conv = rec(option.t[int] param,\n+    type conv = rec(Option.t[int] param,\n                     vec[flag] flags,\n                     count width,\n                     count precision,\n@@ -80,11 +80,11 @@ mod CT {\n \n     fn parse_fmt_string(str s) -> vec[piece] {\n         let vec[piece] pieces = vec();\n-        auto lim = _str.byte_len(s);\n+        auto lim = Str.byte_len(s);\n         auto buf = \"\";\n \n         fn flush_buf(str buf, &vec[piece] pieces) -> str {\n-            if (_str.byte_len(buf) > 0u) {\n+            if (Str.byte_len(buf) > 0u) {\n                 auto piece = piece_string(buf);\n                 pieces += vec(piece);\n             }\n@@ -93,15 +93,15 @@ mod CT {\n \n         auto i = 0u;\n         while (i < lim) {\n-            auto curr = _str.substr(s, i, 1u);\n-            if (_str.eq(curr, \"%\")) {\n+            auto curr = Str.substr(s, i, 1u);\n+            if (Str.eq(curr, \"%\")) {\n                 i += 1u;\n                 if (i >= lim) {\n                     log_err \"unterminated conversion at end of string\";\n                     fail;\n                 }\n-                auto curr2 = _str.substr(s, i, 1u);\n-                if (_str.eq(curr2, \"%\")) {\n+                auto curr2 = Str.substr(s, i, 1u);\n+                if (Str.eq(curr2, \"%\")) {\n                     i += 1u;\n                 } else {\n                     buf = flush_buf(buf, pieces);\n@@ -118,14 +118,14 @@ mod CT {\n         ret pieces;\n     }\n \n-    fn peek_num(str s, uint i, uint lim) -> option.t[tup(uint, uint)] {\n+    fn peek_num(str s, uint i, uint lim) -> Option.t[tup(uint, uint)] {\n         if (i >= lim) {\n             ret none[tup(uint, uint)];\n         }\n \n         auto c = s.(i);\n         if (!('0' as u8 <= c && c <= '9' as u8)) {\n-            ret option.none[tup(uint, uint)];\n+            ret Option.none[tup(uint, uint)];\n         }\n \n         auto n = (c - ('0' as u8)) as uint;\n@@ -156,7 +156,7 @@ mod CT {\n                 ty._1);\n     }\n \n-    fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n+    fn parse_parameter(str s, uint i, uint lim) -> tup(Option.t[int], uint) {\n         if (i >= lim) {\n             ret tup(none[int], i);\n         }\n@@ -270,27 +270,27 @@ mod CT {\n         }\n \n         auto t;\n-        auto tstr = _str.substr(s, i, 1u);\n-        if (_str.eq(tstr, \"b\")) {\n+        auto tstr = Str.substr(s, i, 1u);\n+        if (Str.eq(tstr, \"b\")) {\n             t = ty_bool;\n-        } else if (_str.eq(tstr, \"s\")) {\n+        } else if (Str.eq(tstr, \"s\")) {\n             t = ty_str;\n-        } else if (_str.eq(tstr, \"c\")) {\n+        } else if (Str.eq(tstr, \"c\")) {\n             t = ty_char;\n-        } else if (_str.eq(tstr, \"d\")\n-                   || _str.eq(tstr, \"i\")) {\n+        } else if (Str.eq(tstr, \"d\")\n+                   || Str.eq(tstr, \"i\")) {\n             // TODO: Do we really want two signed types here?\n             // How important is it to be printf compatible?\n             t = ty_int(signed);\n-        } else if (_str.eq(tstr, \"u\")) {\n+        } else if (Str.eq(tstr, \"u\")) {\n             t = ty_int(unsigned);\n-        } else if (_str.eq(tstr, \"x\")) {\n+        } else if (Str.eq(tstr, \"x\")) {\n             t = ty_hex(case_lower);\n-        } else if (_str.eq(tstr, \"X\")) {\n+        } else if (Str.eq(tstr, \"X\")) {\n             t = ty_hex(case_upper);\n-        } else if (_str.eq(tstr, \"t\")) {\n+        } else if (Str.eq(tstr, \"t\")) {\n             t = ty_bits;\n-        } else if (_str.eq(tstr, \"o\")) {\n+        } else if (Str.eq(tstr, \"o\")) {\n             t = ty_octal;\n         } else {\n             log_err \"unknown type in conversion\";\n@@ -364,7 +364,7 @@ mod RT {\n                 res = uint_to_str_prec(u, 16u, prec);\n             }\n             case (ty_hex_upper) {\n-                res = _str.to_upper(uint_to_str_prec(u, 16u, prec));\n+                res = Str.to_upper(uint_to_str_prec(u, 16u, prec));\n             }\n             case (ty_bits) {\n                 res = uint_to_str_prec(u, 2u, prec);\n@@ -389,7 +389,7 @@ mod RT {\n     }\n \n     fn conv_char(&conv cv, char c) -> str {\n-        ret pad(cv, _str.from_char(c), pad_nozero);\n+        ret pad(cv, Str.from_char(c), pad_nozero);\n     }\n \n     fn conv_str(&conv cv, str s) -> str {\n@@ -399,9 +399,9 @@ mod RT {\n             }\n             case (count_is(?max)) {\n                 // For strings, precision is the maximum characters displayed\n-                if (max as uint < _str.char_len(s)) {\n+                if (max as uint < Str.char_len(s)) {\n                     // FIXME: substr works on bytes, not chars!\n-                    unpadded = _str.substr(s, 0u, max as uint);\n+                    unpadded = Str.substr(s, 0u, max as uint);\n                 }\n             }\n         }\n@@ -420,15 +420,15 @@ mod RT {\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to _uint, but it doesn't seem all that useful.\n+    // to UInt. but it doesn't seem all that useful.\n     fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n         auto s;\n \n         if (prec == 0u && num == 0u) {\n             s = \"\";\n         } else {\n-            s = _uint.to_str(num, radix);\n-            auto len = _str.char_len(s);\n+            s = UInt.to_str(num, radix);\n+            auto len = Str.char_len(s);\n             if (len < prec) {\n                 auto diff = prec - len;\n                 auto pad = str_init_elt('0', diff);\n@@ -450,12 +450,12 @@ mod RT {\n         }\n     }\n \n-    // FIXME: This might be useful in _str, but needs to be utf8 safe first\n+    // FIXME: This might be useful in Str. but needs to be utf8 safe first\n     fn str_init_elt(char c, uint n_elts) -> str {\n-        auto svec = _vec.init_elt[u8](c as u8, n_elts);\n+        auto svec = Vec.init_elt[u8](c as u8, n_elts);\n         // FIXME: Using unsafe_from_bytes because rustboot\n         // can't figure out the is_utf8 predicate on from_bytes?\n-        ret _str.unsafe_from_bytes(svec);\n+        ret Str.unsafe_from_bytes(svec);\n     }\n \n     tag pad_mode {\n@@ -476,7 +476,7 @@ mod RT {\n             }\n         }\n \n-        auto strlen = _str.char_len(s);\n+        auto strlen = Str.char_len(s);\n         if (uwidth <= strlen) {\n             ret s;\n         }\n@@ -532,16 +532,16 @@ mod RT {\n         // instead.\n         if (signed\n             && zero_padding\n-            && _str.byte_len(s) > 0u) {\n+            && Str.byte_len(s) > 0u) {\n \n             auto head = s.(0);\n             if (head == '+' as u8\n                 || head == '-' as u8\n                 || head == ' ' as u8) {\n \n-                auto headstr = _str.unsafe_from_bytes(vec(head));\n-                auto bytelen = _str.byte_len(s);\n-                auto numpart = _str.substr(s, 1u, bytelen - 1u);\n+                auto headstr = Str.unsafe_from_bytes(vec(head));\n+                auto bytelen = Str.byte_len(s);\n+                auto numpart = Str.substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;\n             }\n         }"}, {"sha": "69edf247a3ec066b20f28330a4c2f1743d0f62ee", "filename": "src/lib/FS.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FFS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FFS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FFS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,25 +3,25 @@ native \"rust\" mod rustrt {\n }\n \n fn path_sep() -> str {\n-    ret _str.from_char(os_fs.path_sep);\n+    ret Str.from_char(OS_FS.path_sep);\n }\n \n type path = str;\n \n fn dirname(path p) -> path {\n-    let int i = _str.rindex(p, os_fs.path_sep as u8);\n+    let int i = Str.rindex(p, OS_FS.path_sep as u8);\n     if (i == -1) {\n-        i = _str.rindex(p, os_fs.alt_path_sep as u8);\n+        i = Str.rindex(p, OS_FS.alt_path_sep as u8);\n         if (i == -1) {\n             ret p;\n         }\n     }\n-    ret _str.substr(p, 0u, i as uint);\n+    ret Str.substr(p, 0u, i as uint);\n }\n \n fn connect(path pre, path post) -> path {\n-    auto len = _str.byte_len(pre);\n-    if (pre.(len - 1u) == (os_fs.path_sep as u8)) { // Trailing '/'?\n+    auto len = Str.byte_len(pre);\n+    if (pre.(len - 1u) == (OS_FS.path_sep as u8)) { // Trailing '/'?\n         ret pre + post;\n     }\n     ret pre + path_sep() + post;\n@@ -32,14 +32,14 @@ fn file_is_dir(path p) -> bool {\n }\n \n fn list_dir(path p) -> vec[str] {\n-  auto pl = _str.byte_len(p);\n-  if (pl == 0u || p.(pl - 1u) as char != os_fs.path_sep) {\n+  auto pl = Str.byte_len(p);\n+  if (pl == 0u || p.(pl - 1u) as char != OS_FS.path_sep) {\n     p += path_sep();\n   }\n   let vec[str] full_paths = vec();\n-  for (str filename in os_fs.list_dir(p)) {\n-    if (!_str.eq(filename, \".\")) {if (!_str.eq(filename, \"..\")) {\n-      _vec.push[str](full_paths, p + filename);\n+  for (str filename in OS_FS.list_dir(p)) {\n+    if (!Str.eq(filename, \".\")) {if (!Str.eq(filename, \"..\")) {\n+      Vec.push[str](full_paths, p + filename);\n     }}\n   }\n   ret full_paths;", "previous_filename": "src/lib/fs.rs"}, {"sha": "c60fa2b8ed17665aaf726d25e4228900a8c614dd", "filename": "src/lib/GenericOS.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FGenericOS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FGenericOS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FGenericOS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,4 +1,4 @@\n fn getenv(str n) -> str {\n-    ret _str.str_from_cstr(os.libc.getenv(_str.buf(n)));\n+    ret Str.str_from_cstr(OS.libc.getenv(Str.buf(n)));\n }\n "}, {"sha": "0cacf3ffc6533661fb96e6ef71744029d7e80a13", "filename": "src/lib/GetOpts.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FGetOpts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FGetOpts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FGetOpts.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -7,8 +7,8 @@\n  * argument values out of the match object.\n  */ \n \n-import option.some;\n-import option.none;\n+import Option.some;\n+import Option.none;\n \n tag name { long(str); short(char); }\n tag hasarg { yes; no; maybe; }\n@@ -17,7 +17,7 @@ tag occur { req; optional; multi; }\n type opt = rec(name name, hasarg hasarg, occur occur);\n \n fn mkname(str nm) -> name {\n-    if (_str.char_len(nm) == 1u) { ret short(_str.char_at(nm, 0u)); }\n+    if (Str.char_len(nm) == 1u) { ret short(Str.char_at(nm, 0u)); }\n     else { ret long(nm); }\n }\n fn reqopt(str name) -> opt {\n@@ -41,11 +41,11 @@ tag optval {\n type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n \n fn is_arg(str arg) -> bool {\n-    ret _str.byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+    ret Str.byte_len(arg) > 1u && arg.(0) == '-' as u8;\n }\n fn name_str(name nm) -> str {\n     alt (nm) {\n-        case (short(?ch)) {ret _str.from_char(ch);}\n+        case (short(?ch)) {ret Str.from_char(ch);}\n         case (long(?s)) {ret s;}\n     }\n }\n@@ -55,16 +55,16 @@ fn name_eq(name a, name b) -> bool {\n     alt (a) {\n         case (long(?a)) {\n             alt (b) {\n-                case (long(?b)) { ret _str.eq(a, b); }\n+                case (long(?b)) { ret Str.eq(a, b); }\n                 case (_) { ret false; }\n             }\n         }\n         case (_) { if (a == b) { ret true; } else {ret false; } }\n     }\n }\n-fn find_opt(vec[opt] opts, name nm) -> option.t[uint] {\n+fn find_opt(vec[opt] opts, name nm) -> Option.t[uint] {\n     auto i = 0u;\n-    auto l = _vec.len[opt](opts);\n+    auto l = Vec.len[opt](opts);\n     while (i < l) {\n         if (name_eq(opts.(i).name, nm)) { ret some[uint](i); }\n         i += 1u;\n@@ -102,41 +102,41 @@ tag result {\n }\n \n fn getopts(vec[str] args, vec[opt] opts) -> result {\n-    auto n_opts = _vec.len[opt](opts);\n-    fn empty_(uint x) -> vec[optval]{ret _vec.empty[optval]();}\n+    auto n_opts = Vec.len[opt](opts);\n+    fn empty_(uint x) -> vec[optval]{ret Vec.empty[optval]();}\n     auto f = empty_;\n-    auto vals = _vec.init_fn_mut[vec[optval]](f, n_opts);\n+    auto vals = Vec.init_fn_mut[vec[optval]](f, n_opts);\n     let vec[str] free = vec();\n \n-    auto l = _vec.len[str](args);\n+    auto l = Vec.len[str](args);\n     auto i = 0u;\n     while (i < l) {\n         auto cur = args.(i);\n-        auto curlen = _str.byte_len(cur);\n+        auto curlen = Str.byte_len(cur);\n         if (!is_arg(cur)) {\n-            _vec.push[str](free, cur);\n-        } else if (_str.eq(cur, \"--\")) {\n-            free += _vec.slice[str](args, i + 1u, l);\n+            Vec.push[str](free, cur);\n+        } else if (Str.eq(cur, \"--\")) {\n+            free += Vec.slice[str](args, i + 1u, l);\n             break;\n         } else {\n             auto names;\n-            auto i_arg = option.none[str];\n+            auto i_arg = Option.none[str];\n             if (cur.(1) == '-' as u8) {\n-                auto tail = _str.slice(cur, 2u, curlen);\n-                auto eq = _str.index(tail, '=' as u8);\n+                auto tail = Str.slice(cur, 2u, curlen);\n+                auto eq = Str.index(tail, '=' as u8);\n                 if (eq == -1) {\n                     names = vec(long(tail));\n                 } else {\n-                    names = vec(long(_str.slice(tail, 0u, eq as uint)));\n-                    i_arg = option.some[str]\n-                        (_str.slice(tail, (eq as uint) + 1u, curlen - 2u));\n+                    names = vec(long(Str.slice(tail, 0u, eq as uint)));\n+                    i_arg = Option.some[str]\n+                        (Str.slice(tail, (eq as uint) + 1u, curlen - 2u));\n                 }\n             } else {\n                 auto j = 1u;\n                 names = vec();\n                 while (j < curlen) {\n-                    auto range = _str.char_range_at(cur, j);\n-                    _vec.push[name](names, short(range._0));\n+                    auto range = Str.char_range_at(cur, j);\n+                    Vec.push[name](names, short(range._0));\n                     j = range._1;\n                 }\n             }\n@@ -152,29 +152,29 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 }\n                 alt (opts.(optid).hasarg) {\n                     case (no) {\n-                        _vec.push[optval](vals.(optid), given);\n+                        Vec.push[optval](vals.(optid), given);\n                     }\n                     case (maybe) {\n-                        if (!option.is_none[str](i_arg)) {\n-                            _vec.push[optval](vals.(optid),\n-                                              val(option.get[str](i_arg)));\n-                        } else if (name_pos < _vec.len[name](names) ||\n+                        if (!Option.is_none[str](i_arg)) {\n+                            Vec.push[optval](vals.(optid),\n+                                              val(Option.get[str](i_arg)));\n+                        } else if (name_pos < Vec.len[name](names) ||\n                                    i + 1u == l || is_arg(args.(i + 1u))) {\n-                            _vec.push[optval](vals.(optid), given);\n+                            Vec.push[optval](vals.(optid), given);\n                         } else {\n                             i += 1u;\n-                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                            Vec.push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                     case (yes) {\n-                        if (!option.is_none[str](i_arg)) {\n-                            _vec.push[optval](vals.(optid),\n-                                              val(option.get[str](i_arg)));\n+                        if (!Option.is_none[str](i_arg)) {\n+                            Vec.push[optval](vals.(optid),\n+                                              val(Option.get[str](i_arg)));\n                         } else if (i + 1u == l) {\n                             ret failure(argument_missing(name_str(nm)));\n                         } else {\n                             i += 1u;\n-                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                            Vec.push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                 }\n@@ -185,7 +185,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n \n     i = 0u;\n     while (i < n_opts) {\n-        auto n = _vec.len[optval](vals.(i));\n+        auto n = Vec.len[optval](vals.(i));\n         auto occ = opts.(i).occur;\n         if (occ == req) {if (n == 0u) {\n             ret failure(option_missing(name_str(opts.(i).name)));\n@@ -212,7 +212,7 @@ fn opt_val(match m, str nm) -> optval {\n     ret opt_vals(m, nm).(0);\n }\n fn opt_present(match m, str nm) -> bool {\n-    ret _vec.len[optval](opt_vals(m, nm)) > 0u;\n+    ret Vec.len[optval](opt_vals(m, nm)) > 0u;\n }\n fn opt_str(match m, str nm) -> str {\n     alt (opt_val(m, nm)) {\n@@ -224,15 +224,15 @@ fn opt_strs(match m, str nm) -> vec[str] {\n     let vec[str] acc = vec();\n     for (optval v in opt_vals(m, nm)) {\n         alt (v) {\n-            case (val(?s)) { _vec.push[str](acc, s); }\n+            case (val(?s)) { Vec.push[str](acc, s); }\n             case (_) {}\n         }\n     }\n     ret acc;\n }\n-fn opt_maybe_str(match m, str nm) -> option.t[str] {\n+fn opt_maybe_str(match m, str nm) -> Option.t[str] {\n     auto vals = opt_vals(m, nm);\n-    if (_vec.len[optval](vals) == 0u) { ret none[str]; }\n+    if (Vec.len[optval](vals) == 0u) { ret none[str]; }\n     alt (vals.(0)) {\n         case (val(?s)) { ret some[str](s); }\n         case (_) { ret none[str]; }"}, {"sha": "60416ab1e77bff73ce74a02e6266725f3575b2bb", "filename": "src/lib/IO.rs", "status": "renamed", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FIO.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FIO.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FIO.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n-import os.libc;\n+import OS.libc;\n \n native \"rust\" mod rustrt {\n-  fn rust_get_stdin() -> os.libc.FILE;\n-  fn rust_get_stdout() -> os.libc.FILE;\n+  fn rust_get_stdin() -> OS.libc.FILE;\n+  fn rust_get_stdout() -> OS.libc.FILE;\n }\n \n // Reading\n@@ -55,30 +55,30 @@ fn convert_whence(seek_style whence) -> int {\n     }\n }\n \n-state obj FILE_buf_reader(os.libc.FILE f, bool must_close) {\n+state obj FILE_buf_reader(OS.libc.FILE f, bool must_close) {\n     fn read(uint len) -> vec[u8] {\n-        auto buf = _vec.alloc[u8](len);\n-        auto read = os.libc.fread(_vec.buf[u8](buf), 1u, len, f);\n-        _vec.len_set[u8](buf, read);\n+        auto buf = Vec.alloc[u8](len);\n+        auto read = OS.libc.fread(Vec.buf[u8](buf), 1u, len, f);\n+        Vec.len_set[u8](buf, read);\n         ret buf;\n     }\n     fn read_byte() -> int {\n-        ret os.libc.fgetc(f);\n+        ret OS.libc.fgetc(f);\n     }\n     fn unread_byte(int byte) {\n-        os.libc.ungetc(byte, f);\n+        OS.libc.ungetc(byte, f);\n     }\n     fn eof() -> bool {\n-        ret os.libc.feof(f) != 0;\n+        ret OS.libc.feof(f) != 0;\n     }\n     fn seek(int offset, seek_style whence) {\n-        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (OS.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n     fn tell() -> uint {\n-        ret os.libc.ftell(f) as uint;\n+        ret OS.libc.ftell(f) as uint;\n     }\n     drop {\n-        if (must_close) { os.libc.fclose(f); }\n+        if (must_close) { OS.libc.fclose(f); }\n     }\n }\n \n@@ -100,7 +100,7 @@ state obj new_reader(buf_reader rdr) {\n         auto c0 = rdr.read_byte();\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n-        auto w = _str.utf8_char_width(b0);\n+        auto w = Str.utf8_char_width(b0);\n         assert (w > 0u);\n         if (w == 1u) {ret b0 as char;}\n         auto val = 0u;\n@@ -112,7 +112,7 @@ state obj new_reader(buf_reader rdr) {\n             val <<= 6u;\n             val += (next & 0x3f) as uint;\n         }\n-        // See _str.char_at\n+        // See Str.char_at\n         val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n         ret val as char;\n     }\n@@ -126,19 +126,19 @@ state obj new_reader(buf_reader rdr) {\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch == -1 || ch == 10) {go_on = false;}\n-            else {_vec.push[u8](buf, ch as u8);}\n+            else {Vec.push[u8](buf, ch as u8);}\n         }\n-        ret _str.unsafe_from_bytes(buf);\n+        ret Str.unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> str {\n         let vec[u8] buf = vec();\n         auto go_on = true;\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch < 1) {go_on = false;}\n-            else {_vec.push[u8](buf, ch as u8);}\n+            else {Vec.push[u8](buf, ch as u8);}\n         }\n-        ret _str.unsafe_from_bytes(buf);\n+        ret Str.unsafe_from_bytes(buf);\n     }\n     // FIXME deal with eof?\n     fn read_le_uint(uint size) -> uint {\n@@ -191,7 +191,7 @@ fn stdin() -> reader {\n }\n \n fn file_reader(str path) -> reader {\n-    auto f = os.libc.fopen(_str.buf(path), _str.buf(\"r\"));\n+    auto f = OS.libc.fopen(Str.buf(path), Str.buf(\"r\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -212,17 +212,17 @@ type byte_buf = @rec(vec[u8] buf, mutable uint pos);\n \n state obj byte_buf_reader(byte_buf bbuf) {\n     fn read(uint len) -> vec[u8] {\n-        auto rest = _vec.len[u8](bbuf.buf) - bbuf.pos;\n+        auto rest = Vec.len[u8](bbuf.buf) - bbuf.pos;\n         auto to_read = len;\n         if (rest < to_read) {\n             to_read = rest;\n         }\n-        auto range = _vec.slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        auto range = Vec.slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n         bbuf.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if (bbuf.pos == _vec.len[u8](bbuf.buf)) {ret -1;}\n+        if (bbuf.pos == Vec.len[u8](bbuf.buf)) {ret -1;}\n         auto b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n@@ -234,12 +234,12 @@ state obj byte_buf_reader(byte_buf bbuf) {\n     }\n \n     fn eof() -> bool {\n-        ret bbuf.pos == _vec.len[u8](bbuf.buf);\n+        ret bbuf.pos == Vec.len[u8](bbuf.buf);\n     }\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = bbuf.pos;\n-        auto len = _vec.len[u8](bbuf.buf);\n+        auto len = Vec.len[u8](bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -268,40 +268,40 @@ type buf_writer = state obj {\n   fn tell() -> uint; // FIXME: eventually u64\n };\n \n-state obj FILE_writer(os.libc.FILE f, bool must_close) {\n+state obj FILE_writer(OS.libc.FILE f, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = _vec.len[u8](v);\n-        auto vbuf = _vec.buf[u8](v);\n-        auto nout = os.libc.fwrite(vbuf, len, 1u, f);\n+        auto len = Vec.len[u8](v);\n+        auto vbuf = Vec.buf[u8](v);\n+        auto nout = OS.libc.fwrite(vbuf, len, 1u, f);\n         if (nout < 1u) {\n             log_err \"error dumping buffer\";\n         }\n     }\n \n     fn seek(int offset, seek_style whence) {\n-        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (OS.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n \n     fn tell() -> uint {\n-        ret os.libc.ftell(f) as uint;\n+        ret OS.libc.ftell(f) as uint;\n     }\n \n     drop {\n-        if (must_close) {os.libc.fclose(f);}\n+        if (must_close) {OS.libc.fclose(f);}\n     }\n }\n \n state obj fd_buf_writer(int fd, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = _vec.len[u8](v);\n+        auto len = Vec.len[u8](v);\n         auto count = 0u;\n         auto vbuf;\n         while (count < len) {\n-            vbuf = _vec.buf_off[u8](v, count);\n-            auto nout = os.libc.write(fd, vbuf, len);\n+            vbuf = Vec.buf_off[u8](v, count);\n+            auto nout = OS.libc.write(fd, vbuf, len);\n             if (nout < 0) {\n                 log_err \"error dumping buffer\";\n-                log_err sys.rustrt.last_os_error();\n+                log_err Sys.rustrt.last_os_error();\n                 fail;\n             }\n             count += nout as uint;\n@@ -319,32 +319,32 @@ state obj fd_buf_writer(int fd, bool must_close) {\n     }\n \n     drop {\n-        if (must_close) {os.libc.close(fd);}\n+        if (must_close) {OS.libc.close(fd);}\n     }\n }\n \n fn file_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n     let int fflags =\n-        os.libc_constants.O_WRONLY() |\n-        os.libc_constants.O_BINARY();\n+        OS.libc_constants.O_WRONLY() |\n+        OS.libc_constants.O_BINARY();\n \n     for (fileflag f in flags) {\n         alt (f) {\n-            case (append)   { fflags |= os.libc_constants.O_APPEND(); }\n-            case (create)   { fflags |= os.libc_constants.O_CREAT(); }\n-            case (truncate) { fflags |= os.libc_constants.O_TRUNC(); }\n+            case (append)   { fflags |= OS.libc_constants.O_APPEND(); }\n+            case (create)   { fflags |= OS.libc_constants.O_CREAT(); }\n+            case (truncate) { fflags |= OS.libc_constants.O_TRUNC(); }\n             case (none) {}\n         }\n     }\n \n-    auto fd = os.libc.open(_str.buf(path),\n+    auto fd = OS.libc.open(Str.buf(path),\n                            fflags,\n-                           os.libc_constants.S_IRUSR() |\n-                           os.libc_constants.S_IWUSR());\n+                           OS.libc_constants.S_IRUSR() |\n+                           OS.libc_constants.S_IWUSR());\n \n     if (fd < 0) {\n         log_err \"error opening file for writing\";\n-        log_err sys.rustrt.last_os_error();\n+        log_err Sys.rustrt.last_os_error();\n         fail;\n     }\n     ret fd_buf_writer(fd, true);\n@@ -390,17 +390,17 @@ state obj new_writer(buf_writer out) {\n         ret out;\n     }\n     fn write_str(str s) {\n-        out.write(_str.bytes(s));\n+        out.write(Str.bytes(s));\n     }\n     fn write_char(char ch) {\n         // FIXME needlessly consy\n-        out.write(_str.bytes(_str.from_char(ch)));\n+        out.write(Str.bytes(Str.from_char(ch)));\n     }\n     fn write_int(int n) {\n-        out.write(_str.bytes(_int.to_str(n, 10u)));\n+        out.write(Str.bytes(Int.to_str(n, 10u)));\n     }\n     fn write_uint(uint n) {\n-        out.write(_str.bytes(_uint.to_str(n, 10u)));\n+        out.write(Str.bytes(UInt.to_str(n, 10u)));\n     }\n     fn write_bytes(vec[u8] bytes) {\n         out.write(bytes);\n@@ -427,7 +427,7 @@ fn file_writer(str path, vec[fileflag] flags) -> writer {\n \n // FIXME: fileflags\n fn buffered_file_buf_writer(str path) -> buf_writer {\n-    auto f = os.libc.fopen(_str.buf(path), _str.buf(\"w\"));\n+    auto f = OS.libc.fopen(Str.buf(path), Str.buf(\"w\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -451,21 +451,21 @@ type mutable_byte_buf = @rec(mutable vec[mutable u8] buf, mutable uint pos);\n state obj byte_buf_writer(mutable_byte_buf buf) {\n     fn write(vec[u8] v) {\n         // Fast path.\n-        if (buf.pos == _vec.len(buf.buf)) {\n+        if (buf.pos == Vec.len(buf.buf)) {\n             // FIXME: Fix our type system. There's no reason you shouldn't be\n             // able to add a mutable vector to an immutable one.\n-            auto mv = _vec.rustrt.unsafe_vec_to_mut[u8](v);\n+            auto mv = Vec.rustrt.unsafe_vec_to_mut[u8](v);\n             buf.buf += mv;\n-            buf.pos += _vec.len[u8](v);\n+            buf.pos += Vec.len[u8](v);\n             ret;\n         }\n \n         // FIXME: Optimize. These should be unique pointers.\n-        auto vlen = _vec.len[u8](v);\n+        auto vlen = Vec.len[u8](v);\n         auto vpos = 0u;\n         while (vpos < vlen) {\n             auto b = v.(vpos);\n-            if (buf.pos == _vec.len(buf.buf)) {\n+            if (buf.pos == Vec.len(buf.buf)) {\n                 buf.buf += vec(mutable b);\n             } else {\n                 buf.buf.(buf.pos) = b;\n@@ -477,7 +477,7 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = buf.pos;\n-        auto len = _vec.len(buf.buf);\n+        auto len = Vec.len(buf.buf);\n         buf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -487,12 +487,12 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n     let vec[mutable u8] b = vec(mutable 0u8);\n-    _vec.pop(b);\n+    Vec.pop(b);\n \n     let mutable_byte_buf buf = @rec(mutable buf = b, mutable pos = 0u);\n     state obj str_writer_wrap(writer wr, mutable_byte_buf buf) {\n         fn get_writer() -> writer {ret wr;}\n-        fn get_str() -> str {ret _str.unsafe_from_mutable_bytes(buf.buf);}\n+        fn get_str() -> str {ret Str.unsafe_from_mutable_bytes(buf.buf);}\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }", "previous_filename": "src/lib/io.rs"}, {"sha": "59fb507f7fb1cfb1e423c66be12e337a02b72f61", "filename": "src/lib/Int.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FInt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FInt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FInt.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -29,9 +29,9 @@ fn to_str(int n, uint radix) -> str\n {\n     assert (0u < radix && radix <= 16u);\n     if (n < 0) {\n-        ret \"-\" + _uint.to_str((-n) as uint, radix);\n+        ret \"-\" + UInt.to_str((-n) as uint, radix);\n     } else {\n-        ret _uint.to_str(n as uint, radix);\n+        ret UInt.to_str(n as uint, radix);\n     }\n }\n ", "previous_filename": "src/lib/_int.rs"}, {"sha": "58ea29f2964b04f8ad677b972fefdeac49714d94", "filename": "src/lib/List.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FList.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FList.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FList.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n-import option.some;\n-import option.none;\n+import Option.some;\n+import Option.none;\n \n // FIXME: It would probably be more appealing to define this as\n // type list[T] = rec(T hd, option[@list[T]] tl), but at the moment\n@@ -27,7 +27,7 @@ fn foldl[T,U](&list[T] ls, &U u, fn(&T t, &U u) -> U f) -> U {\n }\n \n fn find[T,U](&list[T] ls,\n-             (fn(&T) -> option.t[U]) f) -> option.t[U] {\n+             (fn(&T) -> Option.t[U]) f) -> Option.t[U] {\n   alt(ls) {\n     case (cons[T](?hd, ?tl)) {\n         alt (f(hd)) {", "previous_filename": "src/lib/list.rs"}, {"sha": "6f1ad6d70299dcc14dc2451da615f36ccf5a4e35", "filename": "src/lib/Map.rs", "status": "renamed", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FMap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FMap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FMap.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -11,16 +11,16 @@ state type hashmap[K, V] = state obj {\n                                  fn insert(&K key, &V val) -> bool;\n                                  fn contains_key(&K key) -> bool;\n                                  fn get(&K key) -> V;\n-                                 fn find(&K key) -> option.t[V];\n-                                 fn remove(&K key) -> option.t[V];\n+                                 fn find(&K key) -> Option.t[V];\n+                                 fn remove(&K key) -> Option.t[V];\n                                  fn rehash();\n                                  iter items() -> @tup(K,V);\n };\n \n fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n     let uint initial_capacity = 32u; // 2^5\n-    let util.rational load_factor = rec(num=3, den=4);\n+    let Util.rational load_factor = rec(num=3, den=4);\n \n     tag bucket[K, V] {\n         nil;\n@@ -29,7 +29,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     }\n \n     fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n-        ret _vec.init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n+        ret Vec.init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n \n     // Derive two hash functions from the one given by taking the upper\n@@ -96,7 +96,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                          vec[mutable bucket[K, V]] bkts,\n                          uint nbkts,\n                          &K key)\n-        -> option.t[V]\n+        -> Option.t[V]\n         {\n             let uint i = 0u;\n             let uint h = hasher(key);\n@@ -105,17 +105,17 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 alt (bkts.(j)) {\n                     case (some[K, V](?k, ?v)) {\n                         if (eqer(key, k)) {\n-                            ret option.some[V](v);\n+                            ret Option.some[V](v);\n                         }\n                     }\n                     case (nil[K, V]) {\n-                        ret option.none[V];\n+                        ret Option.none[V];\n                     }\n                     case (deleted[K, V]) { }\n                 }\n                 i += 1u;\n             }\n-            ret option.none[V];\n+            ret Option.none[V];\n         }\n \n \n@@ -140,15 +140,15 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                             mutable vec[mutable bucket[K, V]] bkts,\n                             mutable uint nbkts,\n                             mutable uint nelts,\n-                            util.rational lf)\n+                            Util.rational lf)\n         {\n             fn size() -> uint { ret nelts; }\n \n             fn insert(&K key, &V val) -> bool {\n-                let util.rational load = rec(num=(nelts + 1u) as int,\n+                let Util.rational load = rec(num=(nelts + 1u) as int,\n                                              den=nbkts as int);\n-                if (!util.rational_leq(load, lf)) {\n-                    let uint nnewbkts = _uint.next_power_of_two(nbkts + 1u);\n+                if (!Util.rational_leq(load, lf)) {\n+                    let uint nnewbkts = UInt.next_power_of_two(nbkts + 1u);\n                     let vec[mutable bucket[K, V]] newbkts =\n                         make_buckets[K, V](nnewbkts);\n                     rehash[K, V](hasher, eqer, bkts, nbkts,\n@@ -167,27 +167,27 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n             fn contains_key(&K key) -> bool {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (option.some[V](_)) { ret true; }\n+                    case (Option.some[V](_)) { ret true; }\n                     case (_) { ret false; }\n                 }\n                 fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n             fn get(&K key) -> V {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (option.some[V](?val)) { ret val; }\n+                    case (Option.some[V](?val)) { ret val; }\n                     case (_) { fail; }\n                 }\n                 fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n-            fn find(&K key) -> option.t[V] {\n+            fn find(&K key) -> Option.t[V] {\n                 // FIXME: should be 'be' but parametric tail-calls don't\n                 // work at the moment.\n                 ret find_common[K, V](hasher, eqer, bkts, nbkts, key);\n             }\n \n-            fn remove(&K key) -> option.t[V] {\n+            fn remove(&K key) -> Option.t[V] {\n                 let uint i = 0u;\n                 let uint h = hasher(key);\n                 while (i < nbkts) {\n@@ -197,17 +197,17 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                             if (eqer(key, k)) {\n                                 bkts.(j) = deleted[K, V];\n                                 nelts -= 1u;\n-                                ret option.some[V](v);\n+                                ret Option.some[V](v);\n                             }\n                         }\n                         case (deleted[K, V]) { }\n                         case (nil[K, V]) {\n-                            ret option.none[V];\n+                            ret Option.none[V];\n                         }\n                     }\n                     i += 1u;\n                 }\n-                ret option.none[V];\n+                ret Option.none[V];\n             }\n \n             fn rehash() {", "previous_filename": "src/lib/map.rs"}, {"sha": "3fb9aa3b613577c05f7f15e86ba28e505eca3840", "filename": "src/lib/Option.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FOption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FOption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FOption.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,4 +1,4 @@\n-// lib/option.rs\n+// lib/Option.rs\n \n tag t[T] {\n     none;\n@@ -39,7 +39,7 @@ fn is_none[T](&t[T] opt) -> bool {\n }\n \n fn from_maybe[T](&T def, &t[T] opt) -> T {\n-    auto f = bind util.id[T](_);\n+    auto f = bind Util.id[T](_);\n     ret maybe[T, T](def, f, opt);\n }\n ", "previous_filename": "src/lib/option.rs"}, {"sha": "06eb2f06fd7cb79bb7994d002a2edb38ca9f1384", "filename": "src/lib/Rand.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FRand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FRand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FRand.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "previous_filename": "src/lib/rand.rs"}, {"sha": "30c0ee9c9a2fca084394d068fbc5b8afa5caaa02", "filename": "src/lib/Run_Program.rs", "status": "renamed", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FRun_Program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FRun_Program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FRun_Program.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,74 +1,74 @@\n-import _str.sbuf;\n-import _vec.vbuf;\n+import Str.sbuf;\n+import Vec.vbuf;\n \n native \"rust\" mod rustrt {\n     fn rust_run_program(vbuf argv, int in_fd, int out_fd, int err_fd) -> int;\n }\n \n fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n-    auto argptrs = vec(_str.buf(prog));\n+    auto argptrs = vec(Str.buf(prog));\n     for (str arg in args) {\n-        _vec.push[sbuf](argptrs, _str.buf(arg));\n+        Vec.push[sbuf](argptrs, Str.buf(arg));\n     }\n-    _vec.push[sbuf](argptrs, 0 as sbuf);\n+    Vec.push[sbuf](argptrs, 0 as sbuf);\n     ret argptrs;\n }\n \n fn run_program(str prog, vec[str] args) -> int {\n-    auto pid = rustrt.rust_run_program(_vec.buf[sbuf](argvec(prog, args)),\n+    auto pid = rustrt.rust_run_program(Vec.buf[sbuf](argvec(prog, args)),\n                                        0, 0, 0);\n-    ret os.waitpid(pid);\n+    ret OS.waitpid(pid);\n }\n \n type program =\n     state obj {\n         fn get_id() -> int;\n-        fn input() -> io.writer;\n-        fn output() -> io.reader;\n+        fn input() -> IO.writer;\n+        fn output() -> IO.reader;\n         fn close_input();\n         fn finish() -> int;\n     };\n \n fn start_program(str prog, vec[str] args) -> @program {\n-    auto pipe_input = os.pipe();\n-    auto pipe_output = os.pipe();\n+    auto pipe_input = OS.pipe();\n+    auto pipe_output = OS.pipe();\n     auto pid = rustrt.rust_run_program\n-        (_vec.buf[sbuf](argvec(prog, args)),\n+        (Vec.buf[sbuf](argvec(prog, args)),\n          pipe_input._0, pipe_output._1, 0);\n     if (pid == -1) {fail;}\n-    os.libc.close(pipe_input._0);\n-    os.libc.close(pipe_output._1);\n+    OS.libc.close(pipe_input._0);\n+    OS.libc.close(pipe_output._1);\n \n     state obj new_program(int pid,\n                           int in_fd,\n-                          os.libc.FILE out_file,\n+                          OS.libc.FILE out_file,\n                           mutable bool finished) {\n         fn get_id() -> int {ret pid;}\n-        fn input() -> io.writer {\n-            ret io.new_writer(io.fd_buf_writer(in_fd, false));\n+        fn input() -> IO.writer {\n+            ret IO.new_writer(IO.fd_buf_writer(in_fd, false));\n         }\n-        fn output() -> io.reader {\n-            ret io.new_reader(io.FILE_buf_reader(out_file, false));\n+        fn output() -> IO.reader {\n+            ret IO.new_reader(IO.FILE_buf_reader(out_file, false));\n         }\n         fn close_input() {\n-            os.libc.close(in_fd);\n+            OS.libc.close(in_fd);\n         }\n         fn finish() -> int {\n             if (finished) {ret 0;}\n             finished = true;\n-            os.libc.close(in_fd);\n-            ret os.waitpid(pid);\n+            OS.libc.close(in_fd);\n+            ret OS.waitpid(pid);\n         }\n         drop {\n             if (!finished) {\n-                os.libc.close(in_fd);\n-                os.waitpid(pid);\n+                OS.libc.close(in_fd);\n+                OS.waitpid(pid);\n             }\n-            os.libc.fclose(out_file);\n+            OS.libc.fclose(out_file);\n         }\n     }\n     ret @new_program(pid, pipe_input._1,\n-                     os.fd_FILE(pipe_output._0),\n+                     OS.fd_FILE(pipe_output._0),\n                      false);\n }\n \n@@ -80,7 +80,7 @@ fn program_output(str prog, vec[str] args)\n     auto buf = \"\";\n     while (!out.eof()) {\n         auto bytes = out.read_bytes(4096u);\n-        buf += _str.unsafe_from_bytes(bytes);\n+        buf += Str.unsafe_from_bytes(bytes);\n     }\n     ret rec(status=pr.finish(), out=buf);\n }", "previous_filename": "src/lib/run_program.rs"}, {"sha": "b6ac0521f14c04f5beea130414e39382d5fbd886", "filename": "src/lib/SHA1.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSHA1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSHA1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FSHA1.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -67,7 +67,7 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n-        assert (_vec.len(st.h) == digest_buf_len);\n+        assert (Vec.len(st.h) == digest_buf_len);\n \n         // Constants\n         auto k = vec(0x5A827999u32,\n@@ -76,7 +76,7 @@ fn mk_sha1() -> sha1 {\n                      0xCA62C1D6u32);\n \n         let int t; // Loop counter\n-        let vec[mutable u32] w = _vec.init_elt_mut[u32](0u32, 80u);\n+        let vec[mutable u32] w = Vec.init_elt_mut[u32](0u32, 80u);\n \n         // Initialize the first 16 words of the vector w\n         t = 0;\n@@ -192,7 +192,7 @@ fn mk_sha1() -> sha1 {\n      */\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n-        assert (_vec.len(st.msg_block) == msg_block_len);\n+        assert (Vec.len(st.msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -236,7 +236,7 @@ fn mk_sha1() -> sha1 {\n \n         fn reset() {\n             // FIXME: Should be typestate precondition\n-            assert (_vec.len(st.h) == digest_buf_len);\n+            assert (Vec.len(st.h) == digest_buf_len);\n \n             st.len_low = 0u32;\n             st.len_high = 0u32;\n@@ -256,7 +256,7 @@ fn mk_sha1() -> sha1 {\n         }\n \n         fn input_str(&str msg) {\n-            add_input(st, _str.bytes(msg));\n+            add_input(st, Str.bytes(msg));\n         }\n \n         fn result() -> vec[u8] {\n@@ -267,16 +267,16 @@ fn mk_sha1() -> sha1 {\n             auto r = mk_result(st);\n             auto s = \"\";\n             for (u8 b in r) {\n-                s += _uint.to_str(b as uint, 16u);\n+                s += UInt.to_str(b as uint, 16u);\n             }\n             ret s;\n         }\n     }\n \n-    auto st = rec(h = _vec.init_elt_mut[u32](0u32, digest_buf_len),\n+    auto st = rec(h = Vec.init_elt_mut[u32](0u32, digest_buf_len),\n                   mutable len_low = 0u32,\n                   mutable len_high = 0u32,\n-                  msg_block = _vec.init_elt_mut[u8](0u8, msg_block_len),\n+                  msg_block = Vec.init_elt_mut[u8](0u8, msg_block_len),\n                   mutable msg_block_idx = 0u,\n                   mutable computed = false);\n     auto sh = sha1(st);", "previous_filename": "src/lib/sha1.rs"}, {"sha": "7ecaaaba0cf63315964784b5ec25c1ee467c5ff5", "filename": "src/lib/Sort.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FSort.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n-import _vec.len;\n-import _vec.slice;\n+import Vec.len;\n+import Vec.slice;\n \n type lteq[T] = fn(&T a, &T b) -> bool;\n ", "previous_filename": "src/lib/sort.rs"}, {"sha": "3886ee19164d3eb7266e50fd2f1055006fe87e0b", "filename": "src/lib/Str.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FStr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FStr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FStr.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,6 +1,6 @@\n import rustrt.sbuf;\n \n-import _vec.rustrt.vbuf;\n+import Vec.rustrt.vbuf;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -83,7 +83,7 @@ const uint tag_six_b = 0xfc_u;\n \n fn is_utf8(vec[u8] v) -> bool {\n     auto i = 0u;\n-    auto total = _vec.len[u8](v);\n+    auto total = Vec.len[u8](v);\n     while (i < total) {\n         auto chsize = utf8_char_width(v.(i));\n         if (chsize == 0u) {ret false;}\n@@ -261,7 +261,7 @@ fn to_chars(str s) -> vec[char] {\n     auto len = byte_len(s);\n     while (i < len) {\n         auto cur = char_range_at(s, i);\n-        _vec.push[char](buf, cur._0);\n+        Vec.push[char](buf, cur._0);\n         i = cur._1;\n     }\n     ret buf;\n@@ -296,7 +296,7 @@ fn unshift_char(&mutable str s, char ch) {\n \n fn refcount(str s) -> uint {\n     auto r = rustrt.refcount[u8](s);\n-    if (r == dbg.const_refcount) {\n+    if (r == Dbg.const_refcount) {\n         ret r;\n     } else {\n         // -1 because calling this function incremented the refcount.\n@@ -319,7 +319,7 @@ fn index(str s, u8 c) -> int {\n }\n \n fn rindex(str s, u8 c) -> int {\n-    let int n = _str.byte_len(s) as int;\n+    let int n = Str.byte_len(s) as int;\n     while (n >= 0) {\n         if (s.(n) == c) {\n             ret n;\n@@ -443,7 +443,7 @@ fn split(str s, u8 sep) -> vec[str] {\n             ends_with_sep = false;\n         }\n     }\n-    if (_str.byte_len(accum) != 0u ||\n+    if (Str.byte_len(accum) != 0u ||\n         ends_with_sep) {\n         v += vec(accum);\n     }", "previous_filename": "src/lib/_str.rs"}, {"sha": "77eab003573a683a547e463e5f9af125b2f4e915", "filename": "src/lib/Sys.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FSys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FSys.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "previous_filename": "src/lib/sys.rs"}, {"sha": "8eece16b508277b268185b0f1931ba76df8e91ec", "filename": "src/lib/Task.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FTask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FTask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FTask.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "previous_filename": "src/lib/_task.rs"}, {"sha": "fca04bffb5660ada07f175df49fc6435a3853715", "filename": "src/lib/Term.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FTerm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FTerm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FTerm.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -21,20 +21,20 @@ const u8 color_bright_magenta = 13u8;\n const u8 color_bright_cyan = 14u8;\n const u8 color_bright_white = 15u8;\n \n-fn esc(io.buf_writer writer) {\n+fn esc(IO.buf_writer writer) {\n     writer.write(vec(0x1bu8, '[' as u8));\n }\n \n-fn reset(io.buf_writer writer) {\n+fn reset(IO.buf_writer writer) {\n     esc(writer);\n     writer.write(vec('0' as u8, 'm' as u8));\n }\n \n fn color_supported() -> bool {\n-    ret _str.eq(GenericOS.getenv(\"TERM\"), \"xterm-color\");\n+    ret Str.eq(GenericOS.getenv(\"TERM\"), \"xterm-color\");\n }\n \n-fn set_color(io.buf_writer writer, u8 first_char, u8 color) {\n+fn set_color(IO.buf_writer writer, u8 first_char, u8 color) {\n     assert (color < 16u8);\n \n     esc(writer);\n@@ -45,11 +45,11 @@ fn set_color(io.buf_writer writer, u8 first_char, u8 color) {\n     writer.write(vec(first_char, ('0' as u8) + color, 'm' as u8));\n }\n \n-fn fg(io.buf_writer writer, u8 color) {\n+fn fg(IO.buf_writer writer, u8 color) {\n     ret set_color(writer, '3' as u8, color);\n }\n \n-fn bg(io.buf_writer writer, u8 color) {\n+fn bg(IO.buf_writer writer, u8 color) {\n     ret set_color(writer, '4' as u8, color);\n }\n "}, {"sha": "e094e5812bddb5b86663266f37fa84aec9ce65b1", "filename": "src/lib/U8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FU8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FU8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FU8.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "previous_filename": "src/lib/_u8.rs"}, {"sha": "0bb06d7cfb89c7eb0d0e95e540446daf01e58e2d", "filename": "src/lib/UFind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUFind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUFind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FUFind.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,19 +1,19 @@\n-import option.none;\n-import option.some;\n+import Option.none;\n+import Option.some;\n \n // A very naive implementation of union-find with unsigned integer nodes.\n \n-type node = option.t[uint];\n+type node = Option.t[uint];\n type ufind = rec(mutable vec[mutable node] nodes);\n \n fn make() -> ufind {\n     let vec[mutable node] v = vec(mutable none[uint]);\n-    _vec.pop(v);  // FIXME: botch\n+    Vec.pop(v);  // FIXME: botch\n     ret rec(mutable nodes=v);\n }\n \n fn make_set(&ufind ufnd) -> uint {\n-    auto idx = _vec.len(ufnd.nodes);\n+    auto idx = Vec.len(ufnd.nodes);\n     ufnd.nodes += vec(mutable none[uint]);\n     ret idx;\n }"}, {"sha": "eea52325694056a0a4174fd3d7d9e945731ea399", "filename": "src/lib/UInt.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUInt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUInt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FUInt.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -23,7 +23,7 @@ iter range(uint lo, uint hi) -> uint {\n fn next_power_of_two(uint n) -> uint {\n     // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n     // world explode.\n-    let uint halfbits = sys.rustrt.size_of[uint]() * 4u;\n+    let uint halfbits = Sys.rustrt.size_of[uint]() * 4u;\n     let uint tmp = n - 1u;\n     let uint shift = 1u;\n     while (shift <= halfbits) {\n@@ -34,12 +34,12 @@ fn next_power_of_two(uint n) -> uint {\n }\n \n fn parse_buf(vec[u8] buf, uint radix) -> uint {\n-    if (_vec.len[u8](buf) == 0u) {\n+    if (Vec.len[u8](buf) == 0u) {\n         log_err \"parse_buf(): buf is empty\";\n         fail;\n     }\n \n-    auto i = _vec.len[u8](buf) - 1u;\n+    auto i = Vec.len[u8](buf) - 1u;\n     auto power = 1u;\n     auto n = 0u;\n     while (true) {\n@@ -83,15 +83,15 @@ fn to_str(uint num, uint radix) -> str\n \n     let str s = \"\";\n     while (n != 0u) {\n-        s += _str.unsafe_from_byte(digit(n % radix) as u8);\n+        s += Str.unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n \n     let str s1 = \"\";\n-    let uint len = _str.byte_len(s);\n+    let uint len = Str.byte_len(s);\n     while (len != 0u) {\n         len -= 1u;\n-        s1 += _str.unsafe_from_byte(s.(len));\n+        s1 += Str.unsafe_from_byte(s.(len));\n     }\n     ret s1;\n ", "previous_filename": "src/lib/_uint.rs"}, {"sha": "a385aafda6473f8d7080ba9dc6a63aa3e95e433a", "filename": "src/lib/Util.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUtil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FUtil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FUtil.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -4,7 +4,7 @@ fn id[T](&T x) -> T {\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n-type rational = rec(int num, int den); // : _int.positive(*.den);\n+type rational = rec(int num, int den); // : Int.positive(*.den);\n \n fn rational_leq(&rational x, &rational y) -> bool {\n     // NB: Uses the fact that rationals have positive denominators WLOG.", "previous_filename": "src/lib/util.rs"}, {"sha": "28b5d018d54c3ca933236f4865965fc83000477c", "filename": "src/lib/Vec.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FVec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2FVec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FVec.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,6 +1,6 @@\n-import option.none;\n-import option.some;\n-import util.orb;\n+import Option.none;\n+import Option.some;\n+import Util.orb;\n \n type vbuf = rustrt.vbuf;\n \n@@ -47,7 +47,7 @@ fn alloc_mut[T](uint n_elts) -> vec[mutable T] {\n \n fn refcount[T](array[T] v) -> uint {\n     auto r = rustrt.refcount[T](v);\n-    if (r == dbg.const_refcount) {\n+    if (r == Dbg.const_refcount) {\n         ret r;\n     } else {\n         // -1 because calling this function incremented the refcount.\n@@ -140,7 +140,7 @@ fn print_debug_info[T](array[T] v) {\n }\n \n // Returns the last element of v.\n-fn last[T](array[T] v) -> option.t[T] {\n+fn last[T](array[T] v) -> Option.t[T] {\n     auto l = len[T](v);\n     if (l == 0u) {\n         ret none[T];\n@@ -199,14 +199,14 @@ fn grow[T](&array[T] v, uint n, &T initval) {\n }\n \n fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n-    auto length = _vec.len(v);\n+    auto length = Vec.len(v);\n     if (index >= length) {\n         grow(v, index - length + 1u, initval);\n     }\n     v.(index) = val;\n }\n \n-fn map[T, U](&option.operator[T,U] f, &array[T] v) -> vec[U] {\n+fn map[T, U](&Option.operator[T,U] f, &array[T] v) -> vec[U] {\n     let vec[U] u = alloc[U](len[T](v));\n     for (T ve in v) {\n         u += vec(f(ve));\n@@ -230,7 +230,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n     ret u;\n }\n \n-fn find[T](fn (&T) -> bool f, &array[T] v) -> option.t[T] {\n+fn find[T](fn (&T) -> bool f, &array[T] v) -> Option.t[T] {\n     for (T elt in v) {\n         if (f(elt)) {\n             ret some[T](elt);\n@@ -270,24 +270,24 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n \n fn or(&vec[bool] v) -> bool {\n     auto f = orb;\n-    ret _vec.foldl[bool, bool](f, false, v);\n+    ret Vec.foldl[bool, bool](f, false, v);\n }\n \n fn clone[T](&vec[T] v) -> vec[T] {\n     ret slice[T](v, 0u, len[T](v));\n }\n \n-fn plus_option[T](&vec[T] v, &option.t[T] o) -> () {\n+fn plus_option[T](&vec[T] v, &Option.t[T] o) -> () {\n     alt (o) {\n         case (none[T]) {}\n         case (some[T](?x)) { v += vec(x); }\n     }\n }\n \n-fn cat_options[T](&vec[option.t[T]] v) -> vec[T] {\n+fn cat_options[T](&vec[Option.t[T]] v) -> vec[T] {\n     let vec[T] res = vec();\n \n-    for (option.t[T] o in v) {\n+    for (Option.t[T] o in v) {\n         alt (o) {\n             case (none[T]) { }\n             case (some[T](?t)) {", "previous_filename": "src/lib/_vec.rs"}, {"sha": "02c9183bded9c8cde30ebe0d7cf4ee8c32bf3390", "filename": "src/lib/linux_OS.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Flinux_OS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Flinux_OS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_OS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n-import _str.sbuf;\n-import _vec.vbuf;\n+import Str.sbuf;\n+import Vec.vbuf;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n@@ -66,17 +66,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc.pipe(_vec.buf(fds)) == 0);\n+    assert (OS.libc.pipe(Vec.buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc.fdopen(fd, _str.buf(\"r\"));\n+    ret libc.fdopen(fd, Str.buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (os.libc.waitpid(pid, _vec.buf(status), 0) != -1);\n+    assert (OS.libc.waitpid(pid, Vec.buf(status), 0) != -1);\n     ret status.(0);\n }\n ", "previous_filename": "src/lib/linux_os.rs"}, {"sha": "700ac17c7b66f034cf1895273018325d6abe35fa", "filename": "src/lib/macos_OS.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fmacos_OS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fmacos_OS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_OS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n-import _str.sbuf;\n-import _vec.vbuf;\n+import Str.sbuf;\n+import Vec.vbuf;\n \n native mod libc = \"libc.dylib\" {\n \n@@ -63,17 +63,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n+    assert (OS.libc.pipe(Vec.buf[mutable int](fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc.fdopen(fd, _str.buf(\"r\"));\n+    ret libc.fdopen(fd, Str.buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    assert (os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n+    assert (OS.libc.waitpid(pid, Vec.buf[mutable int](status), 0) != -1);\n     ret status.(0);\n }\n ", "previous_filename": "src/lib/macos_os.rs"}, {"sha": "b1f01a66414c45f07089f0726fc6cbd83978c5c9", "filename": "src/lib/posix_FS.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fposix_FS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fposix_FS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_FS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,21 +1,21 @@\n native \"rust\" mod rustrt {\n-  fn rust_dirent_filename(os.libc.dirent ent) -> str;\n+  fn rust_dirent_filename(OS.libc.dirent ent) -> str;\n }\n \n fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n-  auto dir = os.libc.opendir(_str.buf(path));\n+  auto dir = OS.libc.opendir(Str.buf(path));\n   assert (dir as uint != 0u);\n   let vec[str] result = vec();\n   while (true) {\n-    auto ent = os.libc.readdir(dir);\n+    auto ent = OS.libc.readdir(dir);\n     if (ent as int == 0) {\n-        os.libc.closedir(dir);\n+        OS.libc.closedir(dir);\n         ret result;\n     }\n-    _vec.push[str](result, rustrt.rust_dirent_filename(ent));\n+    Vec.push[str](result, rustrt.rust_dirent_filename(ent));\n   }\n-  os.libc.closedir(dir);\n+  OS.libc.closedir(dir);\n   ret result;\n }\n ", "previous_filename": "src/lib/posix_fs.rs"}, {"sha": "a317b1148f74178f5b227c5c4c8c36052568b939", "filename": "src/lib/std.rc", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -6,39 +6,38 @@ meta (name = \"std\",\n \n // Built-in types support modules.\n \n-mod _int;\n-mod _uint;\n-mod _u8;\n-mod _vec;\n-mod _str;\n+mod Int;\n+mod UInt;\n+mod U8;\n+mod Vec;\n+mod Str;\n \n // General IO and system-services modules.\n \n-mod io;\n-mod sys;\n-mod _task;\n+mod IO;\n+mod Sys;\n+mod Task;\n \n // Utility modules.\n \n-mod option;\n-mod util;\n+mod Option;\n+mod Util;\n \n // Authorize various rule-bendings.\n \n-auth io = unsafe;\n-auth fs = unsafe;\n-auth os = unsafe;\n-auth os_fs = unsafe;\n-auth run = unsafe;\n-auth _str = unsafe;\n-auth _vec = unsafe;\n-auth _task = unsafe;\n+auth IO = unsafe;\n+auth FS = unsafe;\n+auth OS_FS = unsafe;\n+auth Run = unsafe;\n+auth Str = unsafe;\n+auth Vec = unsafe;\n+auth Task = unsafe;\n \n-auth dbg = unsafe;\n+auth Dbg = unsafe;\n \n-auth _uint.next_power_of_two = unsafe;\n-auth map.mk_hashmap = unsafe;\n-auth rand.mk_rng = unsafe;\n+auth UInt.next_power_of_two = unsafe;\n+auth Map.mk_hashmap = unsafe;\n+auth Rand.mk_rng = unsafe;\n \n // Target-OS module.\n \n@@ -47,30 +46,30 @@ mod GenericOS;\n \n alt (target_os) {\n     case (\"win32\") {\n-        mod os = \"win32_os.rs\";\n-        mod os_fs = \"win32_fs.rs\";\n+        mod OS = \"win32_OS.rs\";\n+        mod OS_FS = \"win32_FS.rs\";\n     } case (\"macos\") {\n-        mod os = \"macos_os.rs\";\n-        mod os_fs = \"posix_fs.rs\";\n+        mod OS = \"macos_OS.rs\";\n+        mod OS_FS = \"posix_FS.rs\";\n     } else {\n-        mod os = \"linux_os.rs\";\n-        mod os_fs = \"posix_fs.rs\";\n+        mod OS = \"linux_OS.rs\";\n+        mod OS_FS = \"posix_FS.rs\";\n     }\n }\n \n-mod run = \"run_program.rs\";\n-mod fs;\n+mod Run = \"Run_Program.rs\";\n+mod FS;\n \n // FIXME: parametric\n-mod map;\n-mod deque;\n-mod list;\n-mod rand;\n-mod dbg;\n-mod bitv;\n-mod sort;\n-mod sha1;\n-mod ebml;\n+mod Map;\n+mod Deque;\n+mod List;\n+mod Rand;\n+mod Dbg;\n+mod BitV;\n+mod Sort;\n+mod SHA1;\n+mod EBML;\n mod UFind;\n mod ExtFmt;\n mod Box;"}, {"sha": "94599e3c3dfa6109bd7c3a09b4cfd4106575150b", "filename": "src/lib/win32_FS.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fwin32_FS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fwin32_FS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_FS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "previous_filename": "src/lib/win32_fs.rs"}, {"sha": "b799287c950635dc31f6ebab50317da63baeb04c", "filename": "src/lib/win32_OS.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fwin32_OS.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Flib%2Fwin32_OS.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_OS.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n-import _str.sbuf;\n-import _vec.vbuf;\n+import Str.sbuf;\n+import Vec.vbuf;\n \n native mod libc = \"msvcrt.dll\" {\n     fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n@@ -53,13 +53,13 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    assert (os.libc._pipe(_vec.buf[mutable int](fds), 1024u,\n+    assert (OS.libc._pipe(Vec.buf[mutable int](fds), 1024u,\n                         libc_constants.O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc.FILE {\n-    ret libc._fdopen(fd, _str.buf(\"r\"));\n+    ret libc._fdopen(fd, Str.buf(\"r\"));\n }\n \n native \"rust\" mod rustrt {", "previous_filename": "src/lib/win32_os.rs"}, {"sha": "e8cc4b4bb911b649719bb2d8e2f6a1955af77a99", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std._int;\n-import std._str;\n+import std.Int;\n+import std.Str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -32,15 +32,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = _int.to_str(n, 10u) + \" bottles\";\n+    ns = Int.to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < _str.byte_len(t)) {\n+  while (i < Str.byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      _str.push_byte(b, t.(i));\n+      Str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "fc9ddddb35df498a3390535b8269c93924022cc8", "filename": "src/test/bench/99-bottles/99bob-pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std._int;\n-import std._str;\n+import std.Int;\n+import std.Str;\n \n tag bottle { none; dual; single; multiple(int);}\n \n@@ -25,8 +25,8 @@ fn show(bottle b) {\n       log \"Take one down and pass it around, 1 bottle of beer on the wall.\";\n     }\n     case (multiple(?n)) {\n-      let str nb =  _int.to_str(n, 10u);\n-      let str mb = _int.to_str(n - 1, 10u);\n+      let str nb =  Int.to_str(n, 10u);\n+      let str mb = Int.to_str(n - 1, 10u);\n       log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n       log \"Take one down and pass it around, \" \n         + mb + \" bottles of beer on the wall.\";"}, {"sha": "5c0f08240590490b2c6b89fc31de1042bf8c3f29", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std._int;\n-import std._str;\n+import std.Int;\n+import std.Str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -31,15 +31,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = _int.to_str(n, 10u) + \" bottles\";\n+    ns = Int.to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < _str.byte_len(t)) {\n+  while (i < Str.byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      _str.push_byte(b, t.(i));\n+      Str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "985d9b4b7093365536863304ca5df12cd895d7b0", "filename": "src/test/bench/99-bottles/99bob-tail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,13 +3,13 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std._int;\n-import std._str;\n+import std.Int;\n+import std.Str;\n \n fn main() {\n   fn multiple(int n) {\n-    let str nb =  _int.to_str(n, 10u);\n-    let str mb =  _int.to_str(n - 1, 10u);\n+    let str nb =  Int.to_str(n, 10u);\n+    let str mb =  Int.to_str(n - 1, 10u);\n     log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n     log \"Take one down and pass it around, \" \n       + mb + \" bottles of beer on the wall.\";"}, {"sha": "aa81aaac31df92e75545e4eb25888f3b450035c9", "filename": "src/test/bench/shootout/binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std._int;\n+import std.Int;\n \n tag tree {\n   nil;\n@@ -49,7 +49,7 @@ fn main() {\n \n   auto depth = min_depth;\n   while (depth <= max_depth) {\n-    auto iterations = _int.pow(2, (max_depth - depth + min_depth) as uint);\n+    auto iterations = Int.pow(2, (max_depth - depth + min_depth) as uint);\n     auto chk = 0;\n \n     auto i = 1;"}, {"sha": "ad3d7dd253d3c57febea6ee6f0dae89df3134ac7", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,8 +2,8 @@\n \n use std;\n \n-import std._int;\n-import std._vec;\n+import std.Int;\n+import std.Vec;\n \n fn fannkuch(int n) -> int {\n \n@@ -12,9 +12,9 @@ fn fannkuch(int n) -> int {\n   }\n   auto perm1init_ = perm1init; // Rustboot workaround\n \n-  auto perm = _vec.init_elt[mutable int](0, n as uint);\n-  auto perm1 = _vec.init_fn[mutable int](perm1init_, n as uint);\n-  auto count = _vec.init_elt[mutable int](0, n as uint);\n+  auto perm = Vec.init_elt[mutable int](0, n as uint);\n+  auto perm1 = Vec.init_fn[mutable int](perm1init_, n as uint);\n+  auto count = Vec.init_elt[mutable int](0, n as uint);\n \n   auto f = 0;\n   auto i = 0;"}, {"sha": "3543c29875430ff155c1de39cea758f4a1abf45c", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -7,10 +7,10 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std._vec;\n-import std._str;\n-import std._uint;\n-import std._int;\n+import std.Vec;\n+import std.Str;\n+import std.UInt;\n+import std.Int;\n \n fn LINE_LENGTH() -> uint {\n   ret 60u;\n@@ -54,38 +54,38 @@ fn select_random(u32 r, vec[aminoacids] genelist) -> char {\n       ret v.(hi)._0;\n     }\n   }\n-  ret bisect(genelist, 0u, _vec.len[aminoacids](genelist) - 1u, r);\n+  ret bisect(genelist, 0u, Vec.len[aminoacids](genelist) - 1u, r);\n }\n \n fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n   log(\">\" + id + \" \" + desc);\n-  auto rng = myrandom(std.rand.mk_rng().next());\n+  auto rng = myrandom(std.Rand.mk_rng().next());\n   let str op = \"\";\n-  for each (uint i in _uint.range(0u, n as uint)) {\n-    _str.push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-    if (_str.byte_len(op) >= LINE_LENGTH()) {\n+  for each (uint i in UInt.range(0u, n as uint)) {\n+    Str.push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n+    if (Str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (_str.byte_len(op) > 0u) {\n+  if (Str.byte_len(op) > 0u) {\n     log(op);\n   }\n }\n \n fn make_repeat_fasta(str id, str desc, str s, int n) {\n   log(\">\" + id + \" \" + desc);\n   let str op = \"\";\n-  let uint sl = _str.byte_len(s);\n-  for each (uint i in _uint.range(0u, n as uint)) {\n+  let uint sl = Str.byte_len(s);\n+  for each (uint i in UInt.range(0u, n as uint)) {\n \n-    _str.push_byte(op, s.(i % sl));\n-    if (_str.byte_len(op) >= LINE_LENGTH()) {\n+    Str.push_byte(op, s.(i % sl));\n+    if (Str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (_str.byte_len(op) > 0u) {\n+  if (Str.byte_len(op) > 0u) {\n     log(op);\n   }\n }"}, {"sha": "8f45e6ff5ac09ba98868a44ae353d588b40b91b0", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std.option;\n-import std.option.t;\n-import std.option.none;\n-import std.option.some;\n+import std.Option;\n+import std.Option.t;\n+import std.Option.none;\n+import std.Option.some;\n \n-fn foo[T](&option.t[T] y) {\n+fn foo[T](&Option.t[T] y) {\n   let int x;\n   \n   let vec[int] res = vec();"}, {"sha": "76e7c3aa18d79c5cf819f56f9d10ca24c5d2f72d", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,9 +1,9 @@\n // -*- rust -*-\n \n use std;\n-import std._str;\n+import std.Str;\n \n-// FIXME: import std.dbg.const_refcount. Currently\n+// FIXME: import std.Dbg.const_refcount. Currently\n // cross-crate const references don't work.\n const uint const_refcount = 0x7bad_face_u;\n \n@@ -20,13 +20,13 @@ fn foo(str s) {\n     case (_) { log \"?\"; fail; }\n   }\n \n-  log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  log Str.refcount(s);\n+  assert (Str.refcount(s) == const_refcount);\n }\n \n fn main() {\n   let str s = \"hi\";     // ref up\n   foo(s);               // ref up then down\n-  log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  log Str.refcount(s);\n+  assert (Str.refcount(s) == const_refcount);\n }"}, {"sha": "b047f47a5cb3d1d9ae62e6a16d0900a911688d60", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,132 +1,132 @@\n use std;\n-import std._vec;\n-import std.bitv;\n+import std.Vec;\n+import std.BitV;\n \n fn test_0_elements() {\n   auto act;\n   auto exp;\n \n-  act = bitv.create(0u, false);\n-  exp = _vec.init_elt[uint](0u, 0u);\n+  act = BitV.create(0u, false);\n+  exp = Vec.init_elt[uint](0u, 0u);\n   // FIXME: why can't I write vec[uint]()?\n-  assert (bitv.eq_vec(act, exp));\n+  assert (BitV.eq_vec(act, exp));\n }\n \n fn test_1_element() {\n   auto act;\n \n-  act = bitv.create(1u, false);\n-  assert (bitv.eq_vec(act, vec(0u)));\n+  act = BitV.create(1u, false);\n+  assert (BitV.eq_vec(act, vec(0u)));\n \n-  act = bitv.create(1u, true);\n-  assert (bitv.eq_vec(act, vec(1u)));\n+  act = BitV.create(1u, true);\n+  assert (BitV.eq_vec(act, vec(1u)));\n }\n \n fn test_10_elements() {\n   auto act;\n \n   // all 0\n-  act = bitv.create(10u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+  act = BitV.create(10u, false);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = bitv.create(10u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+  act = BitV.create(10u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(10u, false);\n-  bitv.set(act, 0u, true);\n-  bitv.set(act, 1u, true);\n-  bitv.set(act, 2u, true);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 4u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+  act = BitV.create(10u, false);\n+  BitV.set(act, 0u, true);\n+  BitV.set(act, 1u, true);\n+  BitV.set(act, 2u, true);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 4u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = bitv.create(10u, false);\n-  bitv.set(act, 5u, true);\n-  bitv.set(act, 6u, true);\n-  bitv.set(act, 7u, true);\n-  bitv.set(act, 8u, true);\n-  bitv.set(act, 9u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+  act = BitV.create(10u, false);\n+  BitV.set(act, 5u, true);\n+  BitV.set(act, 6u, true);\n+  BitV.set(act, 7u, true);\n+  BitV.set(act, 8u, true);\n+  BitV.set(act, 9u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(10u, false);\n-  bitv.set(act, 0u, true);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 6u, true);\n-  bitv.set(act, 9u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+  act = BitV.create(10u, false);\n+  BitV.set(act, 0u, true);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 6u, true);\n+  BitV.set(act, 9u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n fn test_31_elements() {\n   auto act;\n \n   // all 0\n-  act = bitv.create(31u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(31u, false);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = bitv.create(31u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(31u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(31u, false);\n-  bitv.set(act, 0u, true);\n-  bitv.set(act, 1u, true);\n-  bitv.set(act, 2u, true);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 4u, true);\n-  bitv.set(act, 5u, true);\n-  bitv.set(act, 6u, true);\n-  bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(31u, false);\n+  BitV.set(act, 0u, true);\n+  BitV.set(act, 1u, true);\n+  BitV.set(act, 2u, true);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 4u, true);\n+  BitV.set(act, 5u, true);\n+  BitV.set(act, 6u, true);\n+  BitV.set(act, 7u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = bitv.create(31u, false);\n-  bitv.set(act, 16u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 18u, true);\n-  bitv.set(act, 19u, true);\n-  bitv.set(act, 20u, true);\n-  bitv.set(act, 21u, true);\n-  bitv.set(act, 22u, true);\n-  bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(31u, false);\n+  BitV.set(act, 16u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 18u, true);\n+  BitV.set(act, 19u, true);\n+  BitV.set(act, 20u, true);\n+  BitV.set(act, 21u, true);\n+  BitV.set(act, 22u, true);\n+  BitV.set(act, 23u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = bitv.create(31u, false);\n-  bitv.set(act, 24u, true);\n-  bitv.set(act, 25u, true);\n-  bitv.set(act, 26u, true);\n-  bitv.set(act, 27u, true);\n-  bitv.set(act, 28u, true);\n-  bitv.set(act, 29u, true);\n-  bitv.set(act, 30u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(31u, false);\n+  BitV.set(act, 24u, true);\n+  BitV.set(act, 25u, true);\n+  BitV.set(act, 26u, true);\n+  BitV.set(act, 27u, true);\n+  BitV.set(act, 28u, true);\n+  BitV.set(act, 29u, true);\n+  BitV.set(act, 30u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(31u, false);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 30u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(31u, false);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 30u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n@@ -136,71 +136,71 @@ fn test_32_elements() {\n   auto act;\n \n   // all 0\n-  act = bitv.create(32u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(32u, false);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n-  act = bitv.create(32u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(32u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(32u, false);\n-  bitv.set(act, 0u, true);\n-  bitv.set(act, 1u, true);\n-  bitv.set(act, 2u, true);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 4u, true);\n-  bitv.set(act, 5u, true);\n-  bitv.set(act, 6u, true);\n-  bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(32u, false);\n+  BitV.set(act, 0u, true);\n+  BitV.set(act, 1u, true);\n+  BitV.set(act, 2u, true);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 4u, true);\n+  BitV.set(act, 5u, true);\n+  BitV.set(act, 6u, true);\n+  BitV.set(act, 7u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = bitv.create(32u, false);\n-  bitv.set(act, 16u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 18u, true);\n-  bitv.set(act, 19u, true);\n-  bitv.set(act, 20u, true);\n-  bitv.set(act, 21u, true);\n-  bitv.set(act, 22u, true);\n-  bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(32u, false);\n+  BitV.set(act, 16u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 18u, true);\n+  BitV.set(act, 19u, true);\n+  BitV.set(act, 20u, true);\n+  BitV.set(act, 21u, true);\n+  BitV.set(act, 22u, true);\n+  BitV.set(act, 23u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n-  act = bitv.create(32u, false);\n-  bitv.set(act, 24u, true);\n-  bitv.set(act, 25u, true);\n-  bitv.set(act, 26u, true);\n-  bitv.set(act, 27u, true);\n-  bitv.set(act, 28u, true);\n-  bitv.set(act, 29u, true);\n-  bitv.set(act, 30u, true);\n-  bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(32u, false);\n+  BitV.set(act, 24u, true);\n+  BitV.set(act, 25u, true);\n+  BitV.set(act, 26u, true);\n+  BitV.set(act, 27u, true);\n+  BitV.set(act, 28u, true);\n+  BitV.set(act, 29u, true);\n+  BitV.set(act, 30u, true);\n+  BitV.set(act, 31u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n-  act = bitv.create(32u, false);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 30u, true);\n-  bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(32u, false);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 30u, true);\n+  BitV.set(act, 31u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n@@ -210,77 +210,77 @@ fn test_33_elements() {\n   auto act;\n \n   // all 0\n-  act = bitv.create(33u, false);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(33u, false);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // all 1\n-  act = bitv.create(33u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(33u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u)));\n \n   // mixed\n-  act = bitv.create(33u, false);\n-  bitv.set(act, 0u, true);\n-  bitv.set(act, 1u, true);\n-  bitv.set(act, 2u, true);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 4u, true);\n-  bitv.set(act, 5u, true);\n-  bitv.set(act, 6u, true);\n-  bitv.set(act, 7u, true);\n-  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  act = BitV.create(33u, false);\n+  BitV.set(act, 0u, true);\n+  BitV.set(act, 1u, true);\n+  BitV.set(act, 2u, true);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 4u, true);\n+  BitV.set(act, 5u, true);\n+  BitV.set(act, 6u, true);\n+  BitV.set(act, 7u, true);\n+  assert (BitV.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // mixed\n-  act = bitv.create(33u, false);\n-  bitv.set(act, 16u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 18u, true);\n-  bitv.set(act, 19u, true);\n-  bitv.set(act, 20u, true);\n-  bitv.set(act, 21u, true);\n-  bitv.set(act, 22u, true);\n-  bitv.set(act, 23u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(33u, false);\n+  BitV.set(act, 16u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 18u, true);\n+  BitV.set(act, 19u, true);\n+  BitV.set(act, 20u, true);\n+  BitV.set(act, 21u, true);\n+  BitV.set(act, 22u, true);\n+  BitV.set(act, 23u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // mixed\n-  act = bitv.create(33u, false);\n-  bitv.set(act, 24u, true);\n-  bitv.set(act, 25u, true);\n-  bitv.set(act, 26u, true);\n-  bitv.set(act, 27u, true);\n-  bitv.set(act, 28u, true);\n-  bitv.set(act, 29u, true);\n-  bitv.set(act, 30u, true);\n-  bitv.set(act, 31u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(33u, false);\n+  BitV.set(act, 24u, true);\n+  BitV.set(act, 25u, true);\n+  BitV.set(act, 26u, true);\n+  BitV.set(act, 27u, true);\n+  BitV.set(act, 28u, true);\n+  BitV.set(act, 29u, true);\n+  BitV.set(act, 30u, true);\n+  BitV.set(act, 31u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u)));\n \n   // mixed\n-  act = bitv.create(33u, false);\n-  bitv.set(act, 3u, true);\n-  bitv.set(act, 17u, true);\n-  bitv.set(act, 30u, true);\n-  bitv.set(act, 31u, true);\n-  bitv.set(act, 32u, true);\n-  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  act = BitV.create(33u, false);\n+  BitV.set(act, 3u, true);\n+  BitV.set(act, 17u, true);\n+  BitV.set(act, 30u, true);\n+  BitV.set(act, 31u, true);\n+  BitV.set(act, 32u, true);\n+  assert (BitV.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,"}, {"sha": "9de238dc8f7524f0588cb087516aa27076d52fc5", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,10 +1,10 @@\n // -*- rust -*-\n \n use std;\n-import std.deque;\n+import std.Deque;\n \n fn test_simple() {\n-  let deque.t[int] d = deque.create[int]();\n+  let Deque.t[int] d = Deque.create[int]();\n   assert (d.size() == 0u);\n   d.add_front(17);\n   d.add_front(42);\n@@ -57,7 +57,7 @@ fn test_simple() {\n }\n \n fn test_boxes(@int a, @int b, @int c, @int d) {\n-  let deque.t[@int] deq = deque.create[@int]();\n+  let Deque.t[@int] deq = Deque.create[@int]();\n   assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n@@ -93,7 +93,7 @@ fn test_boxes(@int a, @int b, @int c, @int d) {\n type eqfn[T] = fn(&T a, &T b) -> bool;\n \n fn test_parameterized[T](eqfn[T] e, &T a, &T b, &T c, &T d) {\n-  let deque.t[T] deq = deque.create[T]();\n+  let Deque.t[T] deq = Deque.create[T]();\n   assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);"}, {"sha": "a5a9a2a10ce03150243558bc8fc508ee336ae2ee", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,25 +1,25 @@\n use std;\n \n-import std._int;\n-import std._str.eq;\n+import std.Int;\n+import std.Str.eq;\n \n fn test_to_str() {\n-  assert (eq(_int.to_str(0, 10u), \"0\"));\n-  assert (eq(_int.to_str(1, 10u), \"1\"));\n-  assert (eq(_int.to_str(-1, 10u), \"-1\"));\n-  assert (eq(_int.to_str(255, 16u), \"ff\"));\n-  assert (eq(_int.to_str(100, 10u), \"100\"));\n+  assert (eq(Int.to_str(0, 10u), \"0\"));\n+  assert (eq(Int.to_str(1, 10u), \"1\"));\n+  assert (eq(Int.to_str(-1, 10u), \"-1\"));\n+  assert (eq(Int.to_str(255, 16u), \"ff\"));\n+  assert (eq(Int.to_str(100, 10u), \"100\"));\n }\n \n fn test_pow() {\n-  assert (_int.pow(0, 0u) == 1);\n-  assert (_int.pow(0, 1u) == 0);\n-  assert (_int.pow(0, 2u) == 0);\n-  assert (_int.pow(-1, 0u) == -1);\n-  assert (_int.pow(1, 0u) == 1);\n-  assert (_int.pow(-3, 2u) == 9);\n-  assert (_int.pow(-3, 3u) == -27);\n-  assert (_int.pow(4, 9u) == 262144);\n+  assert (Int.pow(0, 0u) == 1);\n+  assert (Int.pow(0, 1u) == 0);\n+  assert (Int.pow(0, 2u) == 0);\n+  assert (Int.pow(-1, 0u) == -1);\n+  assert (Int.pow(1, 0u) == 1);\n+  assert (Int.pow(-3, 2u) == 9);\n+  assert (Int.pow(-3, 3u) == -27);\n+  assert (Int.pow(4, 9u) == 262144);\n }\n \n fn main() {"}, {"sha": "e124cde3b22f9e83021cfa87baccbfe2ccc61894", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -5,8 +5,8 @@\n // -*- rust -*-\n \n use std;\n-import std.io;\n-import std._str;\n+import std.IO;\n+import std.Str;\n \n fn test_simple(str tmpfilebase) {\n   let str tmpfile = tmpfilebase + \".tmp\";\n@@ -15,14 +15,14 @@ fn test_simple(str tmpfilebase) {\n   log frood;\n \n   {\n-    let io.writer out = io.file_writer(tmpfile, vec(io.create));\n+    let IO.writer out = IO.file_writer(tmpfile, vec(IO.create));\n     out.write_str(frood);\n   }\n \n-  let io.reader inp = io.file_reader(tmpfile);\n+  let IO.reader inp = IO.file_reader(tmpfile);\n   let str frood2 = inp.read_c_str();\n   log frood2;\n-  assert (_str.eq(frood, frood2));\n+  assert (Str.eq(frood, frood2));\n }\n \n fn main(vec[str] argv) {"}, {"sha": "1f9560558d965a44ce82a8e99075bd977f0aa7b3", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,31 +1,31 @@\n // -*- rust -*-\n \n use std;\n-import std.map;\n-import std._str;\n-import std._uint;\n-import std.util;\n+import std.Map;\n+import std.Str;\n+import std.UInt;\n+import std.Util;\n \n fn test_simple() {\n   log \"*** starting test_simple\";\n \n   fn eq_uint(&uint x, &uint y) -> bool { ret x == y; }\n   fn hash_uint(&uint u) -> uint {\n-    // FIXME: can't use std.util.id since we'd be capturing a type param,\n+    // FIXME: can't use std.Util.id since we'd be capturing a type param,\n     // and presently we can't close items over type params.\n     ret u;\n   }\n \n-  let map.hashfn[uint] hasher_uint = hash_uint;\n-  let map.eqfn[uint] eqer_uint = eq_uint;\n+  let Map.hashfn[uint] hasher_uint = hash_uint;\n+  let Map.eqfn[uint] eqer_uint = eq_uint;\n \n-  let map.hashfn[str] hasher_str = _str.hash;\n-  let map.eqfn[str] eqer_str = _str.eq;\n+  let Map.hashfn[str] hasher_str = Str.hash;\n+  let Map.eqfn[str] eqer_str = Str.eq;\n \n \n   log \"uint -> uint\";\n \n-  let map.hashmap[uint, uint] hm_uu = map.mk_hashmap[uint, uint](hasher_uint,\n+  let Map.hashmap[uint, uint] hm_uu = Map.mk_hashmap[uint, uint](hasher_uint,\n                                                                  eqer_uint);\n \n   assert (hm_uu.insert(10u, 12u));\n@@ -49,7 +49,7 @@ fn test_simple() {\n \n   log \"str -> uint\";\n \n-  let map.hashmap[str, uint] hm_su = map.mk_hashmap[str, uint](hasher_str,\n+  let Map.hashmap[str, uint] hm_su = Map.mk_hashmap[str, uint](hasher_str,\n                                                                eqer_str);\n   assert (hm_su.insert(\"ten\", 12u));\n   assert (hm_su.insert(eleven, 13u));\n@@ -70,42 +70,42 @@ fn test_simple() {\n \n   log \"uint -> str\";\n \n-  let map.hashmap[uint, str] hm_us = map.mk_hashmap[uint, str](hasher_uint,\n+  let Map.hashmap[uint, str] hm_us = Map.mk_hashmap[uint, str](hasher_uint,\n                                                                eqer_uint);\n \n   assert (hm_us.insert(10u, \"twelve\"));\n   assert (hm_us.insert(11u, \"thirteen\"));\n   assert (hm_us.insert(12u, \"fourteen\"));\n \n-  assert (_str.eq(hm_us.get(11u), \"thirteen\"));\n-  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n-  assert (_str.eq(hm_us.get(10u), \"twelve\"));\n+  assert (Str.eq(hm_us.get(11u), \"thirteen\"));\n+  assert (Str.eq(hm_us.get(12u), \"fourteen\"));\n+  assert (Str.eq(hm_us.get(10u), \"twelve\"));\n \n   assert (!hm_us.insert(12u, \"fourteen\"));\n-  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n+  assert (Str.eq(hm_us.get(12u), \"fourteen\"));\n \n   assert (!hm_us.insert(12u, \"twelve\"));\n-  assert (_str.eq(hm_us.get(12u), \"twelve\"));\n+  assert (Str.eq(hm_us.get(12u), \"twelve\"));\n \n \n   log \"str -> str\";\n \n-  let map.hashmap[str, str] hm_ss = map.mk_hashmap[str, str](hasher_str,\n+  let Map.hashmap[str, str] hm_ss = Map.mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n   assert (hm_ss.insert(ten, \"twelve\"));\n   assert (hm_ss.insert(eleven, \"thirteen\"));\n   assert (hm_ss.insert(twelve, \"fourteen\"));\n \n-  assert (_str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-  assert (_str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n+  assert (Str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+  assert (Str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (Str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (Str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-  assert (_str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+  assert (Str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n \n   log \"*** finished test_simple\";\n }\n@@ -120,33 +120,33 @@ fn test_growth() {\n \n   fn eq_uint(&uint x, &uint y) -> bool { ret x == y; }\n   fn hash_uint(&uint u) -> uint {\n-    // FIXME: can't use std.util.id since we'd be capturing a type param,\n+    // FIXME: can't use std.Util.id since we'd be capturing a type param,\n     // and presently we can't close items over type params.\n     ret u;\n   }\n \n \n   log \"uint -> uint\";\n \n-  let map.hashfn[uint] hasher_uint = hash_uint;\n-  let map.eqfn[uint] eqer_uint = eq_uint;\n-  let map.hashmap[uint, uint] hm_uu = map.mk_hashmap[uint, uint](hasher_uint,\n+  let Map.hashfn[uint] hasher_uint = hash_uint;\n+  let Map.eqfn[uint] eqer_uint = eq_uint;\n+  let Map.hashmap[uint, uint] hm_uu = Map.mk_hashmap[uint, uint](hasher_uint,\n                                                                  eqer_uint);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm_uu.insert(i, i * i));\n-    log \"inserting \" + _uint.to_str(i, 10u)\n-      + \" -> \" + _uint.to_str(i * i, 10u);\n+    log \"inserting \" + UInt.to_str(i, 10u)\n+      + \" -> \" + UInt.to_str(i * i, 10u);\n     i += 1u;\n   }\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n@@ -160,25 +160,25 @@ fn test_growth() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n \n   log \"str -> str\";\n \n-  let map.hashfn[str] hasher_str = _str.hash;\n-  let map.eqfn[str] eqer_str = _str.eq;\n-  let map.hashmap[str, str] hm_ss = map.mk_hashmap[str, str](hasher_str,\n+  let Map.hashfn[str] hasher_str = Str.hash;\n+  let Map.eqfn[str] eqer_str = Str.eq;\n+  let Map.hashmap[str, str] hm_ss = Map.mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm_ss.insert(_uint.to_str(i, 2u), _uint.to_str(i * i, 2u)));\n-    log \"inserting \\\"\" + _uint.to_str(i, 2u)\n-      + \"\\\" -> \\\"\" + _uint.to_str(i * i, 2u) + \"\\\"\";\n+    assert (hm_ss.insert(UInt.to_str(i, 2u), UInt.to_str(i * i, 2u)));\n+    log \"inserting \\\"\" + UInt.to_str(i, 2u)\n+      + \"\\\" -> \\\"\" + UInt.to_str(i * i, 2u) + \"\\\"\";\n     i += 1u;\n   }\n \n@@ -187,31 +187,31 @@ fn test_growth() {\n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\\\"\"\n-      + _uint.to_str(i, 2u)\n+      + UInt.to_str(i, 2u)\n       + \"\\\") = \\\"\"\n-      + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n+      + hm_ss.get(UInt.to_str(i, 2u)) + \"\\\"\";\n \n-    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n-                   _uint.to_str(i * i, 2u)));\n+    assert (Str.eq(hm_ss.get(UInt.to_str(i, 2u)),\n+                   UInt.to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n-  assert (hm_ss.insert(_uint.to_str(num_to_insert, 2u),\n-                      _uint.to_str(17u, 2u)));\n+  assert (hm_ss.insert(UInt.to_str(num_to_insert, 2u),\n+                      UInt.to_str(17u, 2u)));\n \n-  assert (_str.eq(hm_ss.get(_uint.to_str(num_to_insert, 2u)),\n-                 _uint.to_str(17u, 2u)));\n+  assert (Str.eq(hm_ss.get(UInt.to_str(num_to_insert, 2u)),\n+                 UInt.to_str(17u, 2u)));\n \n   log \"-----\";\n \n   hm_ss.rehash();\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\\\"\" + _uint.to_str(i, 2u) + \"\\\") = \\\"\"\n-      + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n-    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n-                   _uint.to_str(i * i, 2u)));\n+    log \"get(\\\"\" + UInt.to_str(i, 2u) + \"\\\") = \\\"\"\n+      + hm_ss.get(UInt.to_str(i, 2u)) + \"\\\"\";\n+    assert (Str.eq(hm_ss.get(UInt.to_str(i, 2u)),\n+                   UInt.to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n@@ -234,15 +234,15 @@ fn test_removal() {\n   assert (hash(2u) == hash(3u));\n   assert (hash(0u) != hash(2u));\n \n-  let map.hashfn[uint] hasher = hash;\n-  let map.eqfn[uint] eqer = eq;\n-  let map.hashmap[uint, uint] hm = map.mk_hashmap[uint, uint](hasher, eqer);\n+  let Map.hashfn[uint] hasher = hash;\n+  let Map.eqfn[uint] eqer = eq;\n+  let Map.hashmap[uint, uint] hm = Map.mk_hashmap[uint, uint](hasher, eqer);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + _uint.to_str(i, 10u)\n-      + \" -> \" + _uint.to_str(i * i, 10u);\n+    log \"inserting \" + UInt.to_str(i, 10u)\n+      + \" -> \" + UInt.to_str(i * i, 10u);\n     i += 1u;\n   }\n \n@@ -279,8 +279,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -294,8 +294,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -305,8 +305,8 @@ fn test_removal() {\n   i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + _uint.to_str(i, 10u)\n-      + \" -> \" + _uint.to_str(i * i, 10u);\n+    log \"inserting \" + UInt.to_str(i, 10u)\n+      + \" -> \" + UInt.to_str(i * i, 10u);\n     i += 2u;\n   }\n \n@@ -316,8 +316,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }\n@@ -333,8 +333,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n-      + _uint.to_str(hm.get(i), 10u);\n+    log \"get(\" + UInt.to_str(i, 10u) + \") = \"\n+      + UInt.to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }"}, {"sha": "417ab482764fc7c90f4bf27bde9d0269c3c31df2", "filename": "src/test/run-pass/lib-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,5 +1,5 @@\n use std;\n \n fn main() {\n-  auto x = std.option.some[int](10);\n+  auto x = std.Option.some[int](10);\n }"}, {"sha": "aed5009dd24ada53f6a6aea9ec823f360d2121d9", "filename": "src/test/run-pass/lib-qsort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,13 +1,13 @@\n use std;\n \n fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n-  auto len = std._vec.len[int](v1);\n+  auto len = std.Vec.len[int](v1);\n \n   fn ltequal(&int a, &int b) -> bool {\n     ret a <= b;\n   }\n   auto f = ltequal;\n-  std.sort.quick_sort[int](f, v1);\n+  std.Sort.quick_sort[int](f, v1);\n   auto i = 0u;\n   while (i < len) {\n     log v2.(i);"}, {"sha": "e423bcba53f4844cf49c1459f7cca1a036317cca", "filename": "src/test/run-pass/lib-rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-rand.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -4,14 +4,14 @@\n // -*- rust -*-\n \n use std;\n-import std.rand;\n+import std.Rand;\n \n fn main() {\n-  let rand.rng r1 = rand.mk_rng();\n+  let Rand.rng r1 = Rand.mk_rng();\n   log r1.next();\n   log r1.next();\n   {\n-    auto r2 = rand.mk_rng();\n+    auto r2 = Rand.mk_rng();\n     log r1.next();\n     log r2.next();\n     log r1.next();"}, {"sha": "2a7e8646a6313f3047bb6793d1534d957d9c1fb9", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,9 +2,9 @@\n \n use std;\n \n-import std.sha1;\n-import std._vec;\n-import std._str;\n+import std.SHA1;\n+import std.Vec;\n+import std.Str;\n \n fn main() {\n \n@@ -69,8 +69,8 @@ fn main() {\n     auto tests = fips_180_1_tests + wikipedia_tests;\n \n     fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        assert (_vec.len[u8](v0) == _vec.len[u8](v1));\n-        auto len = _vec.len[u8](v0);\n+        assert (Vec.len[u8](v0) == Vec.len[u8](v1));\n+        auto len = Vec.len[u8](v0);\n         auto i = 0u;\n         while (i < len) {\n             auto a = v0.(i);\n@@ -81,7 +81,7 @@ fn main() {\n     }\n \n     // Test that it works when accepting the message all at once\n-    auto sh = sha1.mk_sha1();\n+    auto sh = SHA1.mk_sha1();\n     for (test t in tests) {\n         sh.input_str(t.input);\n         auto out = sh.result();\n@@ -91,11 +91,11 @@ fn main() {\n \n     // Test that it works when accepting the message in pieces\n     for (test t in tests) {\n-        auto len = _str.byte_len(t.input);\n+        auto len = Str.byte_len(t.input);\n         auto left = len;\n         while (left > 0u) {\n             auto take = (left + 1u) / 2u;\n-            sh.input_str(_str.substr(t.input, len - left, take));\n+            sh.input_str(Str.substr(t.input, len - left, take));\n             left = left - take;\n         }\n         auto out = sh.result();"}, {"sha": "145d0175ddb95ebd39a17ae4ce9213016644425a", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,12 +1,12 @@\n use std;\n \n fn check_sort(vec[int] v1, vec[int] v2) {\n-  auto len = std._vec.len[int](v1);\n+  auto len = std.Vec.len[int](v1);\n   fn lteq(&int a, &int b) -> bool {\n     ret a <= b;\n   }\n   auto f = lteq;\n-  auto v3 = std.sort.merge_sort[int](f, v1);\n+  auto v3 = std.Sort.merge_sort[int](f, v1);\n   auto i = 0u;\n   while (i < len) {\n     log v3.(i);"}, {"sha": "cd8ba9e9fd0127dcda62a6c8099762436d6d6687", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -4,14 +4,14 @@\n // -*- rust -*-\n \n use std;\n-import std._str;\n+import std.Str;\n \n fn main() {\n     auto s = \"hello\";\n-    auto sb = _str.rustrt.str_buf(s);\n-    auto s_cstr = _str.rustrt.str_from_cstr(sb);\n-    assert (_str.eq(s_cstr, s));\n-    auto s_buf = _str.rustrt.str_from_buf(sb, 5u);\n-    assert (_str.eq(s_buf, s));\n+    auto sb = Str.rustrt.str_buf(s);\n+    auto s_cstr = Str.rustrt.str_from_cstr(sb);\n+    assert (Str.eq(s_cstr, s));\n+    auto s_buf = Str.rustrt.str_from_buf(sb, 5u);\n+    assert (Str.eq(s_buf, s));\n }\n "}, {"sha": "58779f674e3fa0af134a84dd8f5701a34c0d6e8d", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,36 +1,36 @@\n use std;\n-import std._str;\n+import std.Str;\n \n fn test_bytes_len() {\n-  assert (_str.byte_len(\"\") == 0u);\n-  assert (_str.byte_len(\"hello world\") == 11u);\n-  assert (_str.byte_len(\"\\x63\") == 1u);\n-  assert (_str.byte_len(\"\\xa2\") == 2u);\n-  assert (_str.byte_len(\"\\u03c0\") == 2u);\n-  assert (_str.byte_len(\"\\u2620\") == 3u);\n-  assert (_str.byte_len(\"\\U0001d11e\") == 4u);\n+  assert (Str.byte_len(\"\") == 0u);\n+  assert (Str.byte_len(\"hello world\") == 11u);\n+  assert (Str.byte_len(\"\\x63\") == 1u);\n+  assert (Str.byte_len(\"\\xa2\") == 2u);\n+  assert (Str.byte_len(\"\\u03c0\") == 2u);\n+  assert (Str.byte_len(\"\\u2620\") == 3u);\n+  assert (Str.byte_len(\"\\U0001d11e\") == 4u);\n }\n \n fn test_index_and_rindex() {\n-  assert (_str.index(\"hello\", 'e' as u8) == 1);\n-  assert (_str.index(\"hello\", 'o' as u8) == 4);\n-  assert (_str.index(\"hello\", 'z' as u8) == -1);\n-  assert (_str.rindex(\"hello\", 'l' as u8) == 3);\n-  assert (_str.rindex(\"hello\", 'h' as u8) == 0);\n-  assert (_str.rindex(\"hello\", 'z' as u8) == -1);\n+  assert (Str.index(\"hello\", 'e' as u8) == 1);\n+  assert (Str.index(\"hello\", 'o' as u8) == 4);\n+  assert (Str.index(\"hello\", 'z' as u8) == -1);\n+  assert (Str.rindex(\"hello\", 'l' as u8) == 3);\n+  assert (Str.rindex(\"hello\", 'h' as u8) == 0);\n+  assert (Str.rindex(\"hello\", 'z' as u8) == -1);\n }\n \n fn test_split() {\n   fn t(&str s, char c, int i, &str k) {\n     log \"splitting: \" + s;\n     log i;\n-    auto v = _str.split(s, c as u8);\n+    auto v = Str.split(s, c as u8);\n     log \"split to: \";\n     for (str z in v) {\n       log z;\n     }\n     log \"comparing: \" + v.(i) + \" vs. \" + k;\n-    assert (_str.eq(v.(i), k));\n+    assert (Str.eq(v.(i), k));\n   }\n   t(\"abc.hello.there\", '.', 0, \"abc\");\n   t(\"abc.hello.there\", '.', 1, \"hello\");\n@@ -43,7 +43,7 @@ fn test_split() {\n \n fn test_find() {\n   fn t(&str haystack, &str needle, int i) {\n-    let int j = _str.find(haystack,needle);\n+    let int j = Str.find(haystack,needle);\n     log \"searched for \" + needle;\n     log j;\n     assert (i == j);\n@@ -57,8 +57,8 @@ fn test_find() {\n \n fn test_substr() {\n   fn t(&str a, &str b, int start) {\n-    assert (_str.eq(_str.substr(a, start as uint,\n-                              _str.byte_len(b)), b));\n+    assert (Str.eq(Str.substr(a, start as uint,\n+                              Str.byte_len(b)), b));\n   }\n \n   t(\"hello\", \"llo\", 2);\n@@ -68,7 +68,7 @@ fn test_substr() {\n \n fn test_concat() {\n   fn t(&vec[str] v, &str s) {\n-    assert (_str.eq(_str.concat(v), s));\n+    assert (Str.eq(Str.concat(v), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \"youknowI'mnogood\");\n@@ -79,7 +79,7 @@ fn test_concat() {\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n-    assert (_str.eq(_str.connect(v, sep), s));\n+    assert (Str.eq(Str.connect(v, sep), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \" \", \"you know I'm no good\");\n@@ -94,8 +94,8 @@ fn test_to_upper() {\n   auto unicode = \"\\u65e5\\u672c\";\n   auto input = \"abcDEF\" + unicode + \"xyz:.;\";\n   auto expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n-  auto actual = _str.to_upper(input);\n-  assert (_str.eq(expected, actual));\n+  auto actual = Str.to_upper(input);\n+  assert (Str.eq(expected, actual));\n }\n \n "}, {"sha": "8e07962ce9e481df6bb7f8bff143d84880b02493", "filename": "src/test/run-pass/lib-task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-task.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,6 +1,6 @@\n use std;\n-import std._task;\n+import std.Task;\n \n fn main() {\n-  _task.sleep(1000000u);\n+  Task.sleep(1000000u);\n }\n\\ No newline at end of file"}, {"sha": "4f7877450811d1d4879201d0fa8c90daa8b4a923", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,47 +1,47 @@\n // -*- rust -*-\n \n use std;\n-import std._uint;\n+import std.UInt;\n \n fn main() {\n-  assert (_uint.next_power_of_two(0u) == 0u);\n-  assert (_uint.next_power_of_two(1u) == 1u);\n-  assert (_uint.next_power_of_two(2u) == 2u);\n-  assert (_uint.next_power_of_two(3u) == 4u);\n-  assert (_uint.next_power_of_two(4u) == 4u);\n-  assert (_uint.next_power_of_two(5u) == 8u);\n-  assert (_uint.next_power_of_two(6u) == 8u);\n-  assert (_uint.next_power_of_two(7u) == 8u);\n-  assert (_uint.next_power_of_two(8u) == 8u);\n-  assert (_uint.next_power_of_two(9u) == 16u);\n-  assert (_uint.next_power_of_two(10u) == 16u);\n-  assert (_uint.next_power_of_two(11u) == 16u);\n-  assert (_uint.next_power_of_two(12u) == 16u);\n-  assert (_uint.next_power_of_two(13u) == 16u);\n-  assert (_uint.next_power_of_two(14u) == 16u);\n-  assert (_uint.next_power_of_two(15u) == 16u);\n-  assert (_uint.next_power_of_two(16u) == 16u);\n-  assert (_uint.next_power_of_two(17u) == 32u);\n-  assert (_uint.next_power_of_two(18u) == 32u);\n-  assert (_uint.next_power_of_two(19u) == 32u);\n-  assert (_uint.next_power_of_two(20u) == 32u);\n-  assert (_uint.next_power_of_two(21u) == 32u);\n-  assert (_uint.next_power_of_two(22u) == 32u);\n-  assert (_uint.next_power_of_two(23u) == 32u);\n-  assert (_uint.next_power_of_two(24u) == 32u);\n-  assert (_uint.next_power_of_two(25u) == 32u);\n-  assert (_uint.next_power_of_two(26u) == 32u);\n-  assert (_uint.next_power_of_two(27u) == 32u);\n-  assert (_uint.next_power_of_two(28u) == 32u);\n-  assert (_uint.next_power_of_two(29u) == 32u);\n-  assert (_uint.next_power_of_two(30u) == 32u);\n-  assert (_uint.next_power_of_two(31u) == 32u);\n-  assert (_uint.next_power_of_two(32u) == 32u);\n-  assert (_uint.next_power_of_two(33u) == 64u);\n-  assert (_uint.next_power_of_two(34u) == 64u);\n-  assert (_uint.next_power_of_two(35u) == 64u);\n-  assert (_uint.next_power_of_two(36u) == 64u);\n-  assert (_uint.next_power_of_two(37u) == 64u);\n-  assert (_uint.next_power_of_two(38u) == 64u);\n-  assert (_uint.next_power_of_two(39u) == 64u);\n+  assert (UInt.next_power_of_two(0u) == 0u);\n+  assert (UInt.next_power_of_two(1u) == 1u);\n+  assert (UInt.next_power_of_two(2u) == 2u);\n+  assert (UInt.next_power_of_two(3u) == 4u);\n+  assert (UInt.next_power_of_two(4u) == 4u);\n+  assert (UInt.next_power_of_two(5u) == 8u);\n+  assert (UInt.next_power_of_two(6u) == 8u);\n+  assert (UInt.next_power_of_two(7u) == 8u);\n+  assert (UInt.next_power_of_two(8u) == 8u);\n+  assert (UInt.next_power_of_two(9u) == 16u);\n+  assert (UInt.next_power_of_two(10u) == 16u);\n+  assert (UInt.next_power_of_two(11u) == 16u);\n+  assert (UInt.next_power_of_two(12u) == 16u);\n+  assert (UInt.next_power_of_two(13u) == 16u);\n+  assert (UInt.next_power_of_two(14u) == 16u);\n+  assert (UInt.next_power_of_two(15u) == 16u);\n+  assert (UInt.next_power_of_two(16u) == 16u);\n+  assert (UInt.next_power_of_two(17u) == 32u);\n+  assert (UInt.next_power_of_two(18u) == 32u);\n+  assert (UInt.next_power_of_two(19u) == 32u);\n+  assert (UInt.next_power_of_two(20u) == 32u);\n+  assert (UInt.next_power_of_two(21u) == 32u);\n+  assert (UInt.next_power_of_two(22u) == 32u);\n+  assert (UInt.next_power_of_two(23u) == 32u);\n+  assert (UInt.next_power_of_two(24u) == 32u);\n+  assert (UInt.next_power_of_two(25u) == 32u);\n+  assert (UInt.next_power_of_two(26u) == 32u);\n+  assert (UInt.next_power_of_two(27u) == 32u);\n+  assert (UInt.next_power_of_two(28u) == 32u);\n+  assert (UInt.next_power_of_two(29u) == 32u);\n+  assert (UInt.next_power_of_two(30u) == 32u);\n+  assert (UInt.next_power_of_two(31u) == 32u);\n+  assert (UInt.next_power_of_two(32u) == 32u);\n+  assert (UInt.next_power_of_two(33u) == 64u);\n+  assert (UInt.next_power_of_two(34u) == 64u);\n+  assert (UInt.next_power_of_two(35u) == 64u);\n+  assert (UInt.next_power_of_two(36u) == 64u);\n+  assert (UInt.next_power_of_two(37u) == 64u);\n+  assert (UInt.next_power_of_two(38u) == 64u);\n+  assert (UInt.next_power_of_two(39u) == 64u);\n }"}, {"sha": "cd8b64a889e24b970f903ce95067ac399ac8deea", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std._str;\n-import std._vec;\n+import std.Str;\n+import std.Vec;\n \n fn test_simple() {\n   let str s1 = \"All mimsy were the borogoves\";\n@@ -14,12 +14,12 @@ fn test_simple() {\n    * working, but we should implement is_utf8 before that happens.\n    */\n \n-  let vec[u8] v = _str.bytes(s1);\n-  let str s2 = _str.from_bytes(v);\n+  let vec[u8] v = Str.bytes(s1);\n+  let str s2 = Str.from_bytes(v);\n \n   let uint i = 0u;\n-  let uint n1 = _str.byte_len(s1);\n-  let uint n2 = _vec.len[u8](v);\n+  let uint n1 = Str.byte_len(s1);\n+  let uint n2 = Vec.len[u8](v);\n \n   assert (n1 == n2);\n \n@@ -33,7 +33,7 @@ fn test_simple() {\n   }\n \n   log \"refcnt is\";\n-  log _str.refcount(s1);\n+  log Str.refcount(s1);\n }\n \n fn main() {"}, {"sha": "0905652a5d00923c4108b0d6818f685c36e1bbdc", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,8 +1,8 @@\n use std;\n \n fn test_init_elt() {\n-  let vec[uint] v = std._vec.init_elt[uint](5u, 3u);\n-  assert (std._vec.len[uint](v) == 3u);\n+  let vec[uint] v = std.Vec.init_elt[uint](5u, 3u);\n+  assert (std.Vec.len[uint](v) == 3u);\n   assert (v.(0) == 5u);\n   assert (v.(1) == 5u);\n   assert (v.(2) == 5u);\n@@ -13,8 +13,8 @@ fn id(uint x) -> uint {\n }\n fn test_init_fn() {\n   let fn(uint)->uint op = id;\n-  let vec[uint] v = std._vec.init_fn[uint](op, 5u);\n-  assert (std._vec.len[uint](v) == 5u);\n+  let vec[uint] v = std.Vec.init_fn[uint](op, 5u);\n+  assert (std.Vec.len[uint](v) == 5u);\n   assert (v.(0) == 0u);\n   assert (v.(1) == 1u);\n   assert (v.(2) == 2u);\n@@ -24,17 +24,17 @@ fn test_init_fn() {\n \n fn test_slice() {\n   let vec[int] v = vec(1,2,3,4,5);\n-  auto v2 = std._vec.slice[int](v, 2u, 4u);\n-  assert (std._vec.len[int](v2) == 2u);\n+  auto v2 = std.Vec.slice[int](v, 2u, 4u);\n+  assert (std.Vec.len[int](v2) == 2u);\n   assert (v2.(0) == 3);\n   assert (v2.(1) == 4);\n }\n \n fn test_map() {\n   fn square(&int x) -> int { ret x * x; }\n-  let std.option.operator[int, int] op = square;\n+  let std.Option.operator[int, int] op = square;\n   let vec[int] v = vec(1, 2, 3, 4, 5);\n-  let vec[int] s = std._vec.map[int, int](op, v);\n+  let vec[int] s = std.Vec.map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n     assert (v.(i) * v.(i) == s.(i));\n@@ -47,7 +47,7 @@ fn test_map2() {\n   auto f = times;\n   auto v0 = vec(1, 2, 3, 4, 5);\n   auto v1 = vec(5, 4, 3, 2, 1);\n-  auto u = std._vec.map2[int,int,int](f, v0, v1);\n+  auto u = std.Vec.map2[int,int,int](f, v0, v1);\n \n   auto i = 0;\n   while (i < 5) {"}, {"sha": "b5eff76f4dc28f6d5e6049a40c8ce53476aa1689", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -16,6 +16,6 @@ fn main() {\n   let @cell first = @tup(mutable @nil());\n   let @cell second = @tup(mutable @link(first));\n   first._0 = @link(second);\n-  std.sys.rustrt.gc();\n+  std.Sys.rustrt.gc();\n   let @cell third = @tup(mutable @nil());\n }"}, {"sha": "5919abdc5d4b2ae869a673a60a9e9116c895c33b", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   grow(v);\n   grow(v);\n   grow(v);\n-  auto len = std._vec.len[int](v);\n+  auto len = std.Vec.len[int](v);\n   log len;\n   assert (len == (3 as uint));\n }"}, {"sha": "cb244cc8b100fc43f11fd1c9c17a3dcc8a88a593", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,13 +1,13 @@\n // a bug was causing this to complain about leaked memory on exit\n \n use std;\n-import std.option;\n-import std.option.some;\n-import std.option.none;\n+import std.Option;\n+import std.Option.some;\n+import std.Option.none;\n \n tag t {\n   foo(int, uint);\n-  bar(int, option.t[int]);\n+  bar(int, Option.t[int]);\n }\n \n fn nested(t o) {"}, {"sha": "b6c545b2782bd050e178fec6baeae704e9c60e6b", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -5,9 +5,9 @@\n \n use std;\n \n-import std.option;\n-import std._uint;\n-import std._vec;\n+import std.Option;\n+import std.UInt;\n+import std.Vec;\n \n // A 12-byte unit to send over the channel\n type record = rec(u32 val1, u32 val2, u32 val3);\n@@ -33,7 +33,7 @@ fn test_grow() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in _uint.range(0u, 100u)) {\n+    for each (uint i in UInt.range(0u, 100u)) {\n         mychan <| val;\n     }\n }\n@@ -53,11 +53,11 @@ fn test_shrink2() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in _uint.range(0u, 100u)) {\n+    for each (uint i in UInt.range(0u, 100u)) {\n         mychan <| val;\n     }\n \n-    for each (uint i in _uint.range(0u, 100u)) {\n+    for each (uint i in UInt.range(0u, 100u)) {\n         auto x <- myport;\n     }\n }\n@@ -67,7 +67,7 @@ fn test_rotate() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint i in _uint.range(0u, 100u)) {\n+    for each (uint i in UInt.range(0u, 100u)) {\n         auto val = rec(val1=i as u32,\n                        val2=i as u32,\n                        val3=i as u32);\n@@ -86,15 +86,15 @@ fn test_rotate_grow() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint j in _uint.range(0u, 10u)) {\n-        for each (uint i in _uint.range(0u, 10u)) {\n+    for each (uint j in UInt.range(0u, 10u)) {\n+        for each (uint i in UInt.range(0u, 10u)) {\n             let record val = rec(val1=i as u32,\n                                  val2=i as u32,\n                                  val3=i as u32);\n             mychan <| val;\n         }\n \n-        for each (uint i in _uint.range(0u, 10u)) {\n+        for each (uint i in UInt.range(0u, 10u)) {\n             auto x <- myport;\n             assert (x.val1 == i as u32);\n             assert (x.val2 == i as u32);"}, {"sha": "afca72a8d1dad536f9479f89d8f8118857a6a54b", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std._str;\n+import std.Str;\n \n fn test1() {\n   let str s = \"hello\";\n@@ -20,8 +20,8 @@ fn test2() {\n   log a;\n   log b;\n \n-  assert (_str.eq(a, \"abcABCabc\"));\n-  assert (_str.eq(b, \"ABCabcABC\"));\n+  assert (Str.eq(a, \"abcABCabc\"));\n+  assert (Str.eq(b, \"ABCabcABC\"));\n }\n \n fn main() {"}, {"sha": "08a8c499668495e902583a14343081ecbb06be1e", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,12 +3,12 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std._str;\n+import std.Str;\n \n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  assert (_str.eq(actual, expected));\n+  assert (Str.eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "d4a135c2a39e477c253bdc2c3b98dd212dd7f58b", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -3,7 +3,7 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std._task;\n+import std.Task;\n \n fn main() -> () {\n     test00();\n@@ -18,7 +18,7 @@ fn test00() {\n     let task t = spawn thread \"child\" start(i);\n     \n     // Sleep long enough for the task to finish.\n-    _task.sleep(10000u);\n+    Task.sleep(10000u);\n     \n     // Try joining tasks that have already finished.\n     join t;"}, {"sha": "fedc516bd59a8845894889b9019a4ab7aca339dd", "filename": "src/test/run-pass/task-comm-13-thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std._task;\n+import std.Task;\n \n fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;"}, {"sha": "1bf5d1f56f6366dd4b6ab8ffed673482d7014f20", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std._task;\n+import std.Task;\n \n fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;"}, {"sha": "d39a2064828ae9c9bd9e927d450484161997b9c3", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n \n-import size_of = std.sys.rustrt.size_of;\n+import size_of = std.Sys.rustrt.size_of;\n \n use std;\n "}, {"sha": "3d1a6947f7cb7ab2183fd12e55ce0e4d2c7b35b0", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -7,17 +7,17 @@ use zed(name = \"std\");\n use bar(name = \"std\", ver = \"0.0.1\");\n \n // FIXME: commented out since resolve doesn't know how to handle crates yet.\n-// import std._str;\n-// import x = std._str;\n+// import std.Str;\n+// import x = std.Str;\n \n mod baz {\n   use std;\n   use libc();\n   use zed(name = \"std\");\n   use bar(name = \"std\", ver = \"0.0.1\");\n \n-  // import std._str;\n-  // import x = std._str;\n+  // import std.Str;\n+  // import x = std.Str;\n }\n \n fn main() {"}, {"sha": "877c416bbb3537c6a81470fc44fc32106cc945bb", "filename": "src/test/run-pass/user.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fuser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fuser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuser.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -8,10 +8,10 @@ use std (name = \"std\",\n          uuid = _, ver = _);\n \n fn main() {\n-  auto s = std._str.alloc(10 as uint);\n+  auto s = std.Str.alloc(10 as uint);\n   s += \"hello \";\n   log s;\n   s += \"there\";\n   log s;\n-  auto z = std._vec.alloc[int](10 as uint);\n+  auto z = std.Vec.alloc[int](10 as uint);\n }"}, {"sha": "95cbc64e0ab68ea6b5abb2fbcc1752d07094894f", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -2,34 +2,34 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std._str;\n-import std._vec;\n-import std.io;\n+import std.Str;\n+import std.Vec;\n+import std.IO;\n \n fn main() {\n   // Chars of 1, 2, 3, and 4 bytes\n   let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n-  let str s = _str.from_chars(chs);\n+  let str s = Str.from_chars(chs);\n \n-  assert (_str.byte_len(s) == 10u);\n-  assert (_str.char_len(s) == 4u);\n-  assert (_vec.len[char](_str.to_chars(s)) == 4u);\n-  assert (_str.eq(_str.from_chars(_str.to_chars(s)), s));\n-  assert (_str.char_at(s, 0u) == 'e');\n-  assert (_str.char_at(s, 1u) == '\u00e9');\n+  assert (Str.byte_len(s) == 10u);\n+  assert (Str.char_len(s) == 4u);\n+  assert (Vec.len[char](Str.to_chars(s)) == 4u);\n+  assert (Str.eq(Str.from_chars(Str.to_chars(s)), s));\n+  assert (Str.char_at(s, 0u) == 'e');\n+  assert (Str.char_at(s, 1u) == '\u00e9');\n \n-  assert (_str.is_utf8(_str.bytes(s)));\n-  assert (!_str.is_utf8(vec(0x80_u8)));\n-  assert (!_str.is_utf8(vec(0xc0_u8)));\n-  assert (!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n+  assert (Str.is_utf8(Str.bytes(s)));\n+  assert (!Str.is_utf8(vec(0x80_u8)));\n+  assert (!Str.is_utf8(vec(0xc0_u8)));\n+  assert (!Str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n \n   auto stack = \"a\u00d7c\u20ac\";\n-  assert (_str.pop_char(stack) == '\u20ac');\n-  assert (_str.pop_char(stack) == 'c');\n-  _str.push_char(stack, 'u');\n-  assert (_str.eq(stack, \"a\u00d7u\"));\n-  assert (_str.shift_char(stack) == 'a');\n-  assert (_str.shift_char(stack) == '\u00d7');\n-  _str.unshift_char(stack, '\u00df');\n-  assert (_str.eq(stack, \"\u00dfu\"));\n+  assert (Str.pop_char(stack) == '\u20ac');\n+  assert (Str.pop_char(stack) == 'c');\n+  Str.push_char(stack, 'u');\n+  assert (Str.eq(stack, \"a\u00d7u\"));\n+  assert (Str.shift_char(stack) == 'a');\n+  assert (Str.shift_char(stack) == '\u00d7');\n+  Str.unshift_char(stack, '\u00df');\n+  assert (Str.eq(stack, \"\u00dfu\"));\n }"}, {"sha": "4327e789cd5724a850ac40cf0167b64b66e46d2b", "filename": "src/test/run-pass/vec-alloc-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -6,7 +6,7 @@\n use std;\n \n fn slice[T](vec[T] e) {\n-  let vec[T] result = std._vec.alloc[T](1 as uint);\n+  let vec[T] result = std.Vec.alloc[T](1 as uint);\n   log \"alloced\";\n   result += e;\n   log \"appended\";"}, {"sha": "cd87ec230ceca4dec4b84ad20551982e61b31e65", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -4,11 +4,11 @@\n // -*- rust -*-\n \n use std;\n-import std._str;\n-import std._vec;\n+import std.Str;\n+import std.Vec;\n \n \n-// FIXME: import std.dbg.const_refcount. Currently\n+// FIXME: import std.Dbg.const_refcount. Currently\n // cross-crate const references don't work.\n const uint const_refcount = 0x7bad_face_u;\n \n@@ -53,30 +53,30 @@ fn slow_growth2_helper(str s) {   // ref up: s\n     let vec[str] v = vec(mumble); // ref up: v, mumble\n     let acc a = acc(v);           // ref up: a, v\n \n-    log _vec.refcount[str](v);\n-    assert (_vec.refcount[str](v) == 2u);\n+    log Vec.refcount[str](v);\n+    assert (Vec.refcount[str](v) == 2u);\n \n     a.add(s);                     // ref up: mumble, s.  ref down: v\n \n-    log _vec.refcount[str](v);\n-    log _str.refcount(s);\n-    log _str.refcount(mumble);\n+    log Vec.refcount[str](v);\n+    log Str.refcount(s);\n+    log Str.refcount(mumble);\n \n-    assert (_vec.refcount[str](v) == 1u);\n-    assert (_str.refcount(s) == const_refcount);\n-    assert (_str.refcount(mumble) == const_refcount);\n+    assert (Vec.refcount[str](v) == 1u);\n+    assert (Str.refcount(s) == const_refcount);\n+    assert (Str.refcount(mumble) == const_refcount);\n \n     log v.(0);\n-    log _vec.len[str](v);\n-    assert (_str.eq(v.(0), mumble));\n-    assert (_vec.len[str](v) == 1u);\n+    log Vec.len[str](v);\n+    assert (Str.eq(v.(0), mumble));\n+    assert (Vec.len[str](v) == 1u);\n   }                               // ref down: a, mumble, s, v\n \n-  log _str.refcount(s);\n-  log _str.refcount(mumble);\n+  log Str.refcount(s);\n+  log Str.refcount(mumble);\n \n-  assert (_str.refcount(s) == const_refcount);\n-  assert (_str.refcount(mumble) == const_refcount);\n+  assert (Str.refcount(s) == const_refcount);\n+  assert (Str.refcount(mumble) == const_refcount);\n \n   log mumble;\n   log ss;\n@@ -85,8 +85,8 @@ fn slow_growth2_helper(str s) {   // ref up: s\n fn slow_growth2() {\n   let str s = \"hi\";               // ref up: s\n   slow_growth2_helper(s);\n-  log _str.refcount(s);\n-  assert (_str.refcount(s) == const_refcount);\n+  log Str.refcount(s);\n+  assert (Str.refcount(s) == const_refcount);\n }\n \n fn main() {"}, {"sha": "4534a86195a2a8b1a82b7c58f535a716818550a1", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ec0b1f643d00b9418e4884bd7caa07bf052201/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=a3ec0b1f643d00b9418e4884bd7caa07bf052201", "patch": "@@ -1,12 +1,12 @@\n use std;\n-import std._vec;\n+import std.Vec;\n \n fn main() {\n     auto v = vec(1, 2, 3);\n-    log_err _vec.refcount[int](v);\n-    log_err _vec.refcount[int](v);\n-    log_err _vec.refcount[int](v);\n-    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n-    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n+    log_err Vec.refcount[int](v);\n+    log_err Vec.refcount[int](v);\n+    log_err Vec.refcount[int](v);\n+    assert (Vec.refcount[int](v) == 1u || Vec.refcount[int](v) == 2u);\n+    assert (Vec.refcount[int](v) == 1u || Vec.refcount[int](v) == 2u);\n }\n "}]}