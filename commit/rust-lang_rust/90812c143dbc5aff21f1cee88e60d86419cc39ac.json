{"sha": "90812c143dbc5aff21f1cee88e60d86419cc39ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwODEyYzE0M2RiYzVhZmYyMWYxY2VlODhlNjBkODY0MTljYzM5YWM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-25T00:56:45Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-25T00:57:41Z"}, "message": "Rework method lookup to properly handle self types for non impl matches. Closes #3268. Closes #3274.", "tree": {"sha": "2c868638aa154451a0411f600f644150b6f51765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c868638aa154451a0411f600f644150b6f51765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90812c143dbc5aff21f1cee88e60d86419cc39ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90812c143dbc5aff21f1cee88e60d86419cc39ac", "html_url": "https://github.com/rust-lang/rust/commit/90812c143dbc5aff21f1cee88e60d86419cc39ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90812c143dbc5aff21f1cee88e60d86419cc39ac/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a562126497d3160c6131a125d0842bc4e3d61ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a562126497d3160c6131a125d0842bc4e3d61ce", "html_url": "https://github.com/rust-lang/rust/commit/6a562126497d3160c6131a125d0842bc4e3d61ce"}], "stats": {"total": 87, "additions": 72, "deletions": 15}, "files": [{"sha": "b8139b181cd2c65aa668faee22e0cd62e24e8f33", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/90812c143dbc5aff21f1cee88e60d86419cc39ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90812c143dbc5aff21f1cee88e60d86419cc39ac/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=90812c143dbc5aff21f1cee88e60d86419cc39ac", "patch": "@@ -140,7 +140,24 @@ struct lookup {\n              immutable_reference_mode, mutable_reference_mode];\n \n         loop {\n-            self.add_candidates_from_type();\n+            // Try to find a method that is keyed directly off of the\n+            // type. This only happens for boxed traits, type params,\n+            // classes, and self. If we see some sort of pointer, then\n+            // we look at candidates for the pointed to type to match\n+            // them against methods that take explicit self parameters.\n+            // N.B.: this looking through boxes to match against\n+            // explicit self parameters is *not* the same as\n+            // autoderef.\n+            // Try each of the possible matching semantics in turn.\n+            for matching_modes.each |mode| {\n+                match ty::get(self.self_ty).struct {\n+                  ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) => {\n+                    self.add_candidates_from_type(mt.ty, mode);\n+                  }\n+                  _ => { self.add_candidates_from_type(self.self_ty, mode); }\n+                }\n+                if self.candidates.len() > 0u { break; }\n+            }\n \n             // if we found anything, stop now.  otherwise continue to\n             // loop for impls in scope.  Note: I don't love these\n@@ -235,18 +252,17 @@ struct lookup {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn add_candidates_from_type() {\n-        match ty::get(self.self_ty).struct {\n+    fn add_candidates_from_type(inner_ty: ty::t, mode: method_lookup_mode) {\n+        match ty::get(inner_ty).struct {\n           // First, see whether this is a bounded parameter.\n           ty::ty_param(p) => {\n-            self.add_candidates_from_param(p.idx, p.def_id);\n+            self.add_candidates_from_param(inner_ty, mode, p.idx, p.def_id);\n           }\n-\n           ty::ty_trait(did, substs, _) => {\n-            self.add_candidates_from_trait(did, substs);\n+            self.add_candidates_from_trait(inner_ty, mode, did, substs);\n           }\n           ty::ty_class(did, substs) => {\n-            self.add_candidates_from_class(did, substs);\n+            self.add_candidates_from_class(inner_ty, mode, did, substs);\n           }\n           ty::ty_self => {\n             // Call is of the form \"self.foo()\" and appears in one\n@@ -260,13 +276,15 @@ struct lookup {\n                 tps: ~[],\n             };\n \n-            self.add_candidates_from_trait(self_def_id, substs);\n+            self.add_candidates_from_trait(inner_ty, mode,\n+                                           self_def_id, substs);\n           }\n           _ => ()\n         }\n     }\n \n-    fn add_candidates_from_param(n: uint, did: ast::def_id) {\n+    fn add_candidates_from_param(inner_ty: ty::t, mode: method_lookup_mode,\n+                                 n: uint, did: ast::def_id) {\n         debug!(\"add_candidates_from_param\");\n \n         let tcx = self.tcx();\n@@ -304,6 +322,8 @@ struct lookup {\n                               with bound_substs};\n \n                 self.add_candidates_from_m(\n+                    inner_ty,\n+                    mode,\n                     substs, trt_methods[pos],\n                     method_param({trait_id:trait_id,\n                                   method_num:pos,\n@@ -315,7 +335,10 @@ struct lookup {\n \n     }\n \n-    fn add_candidates_from_trait(did: ast::def_id, trait_substs: ty::substs) {\n+    fn add_candidates_from_trait(inner_ty: ty::t,\n+                                 mode: method_lookup_mode,\n+                                 did: ast::def_id,\n+                                 trait_substs: ty::substs) {\n \n         debug!(\"add_candidates_from_trait\");\n \n@@ -346,11 +369,14 @@ struct lookup {\n                           with trait_substs};\n \n             self.add_candidates_from_m(\n-                substs, m, method_trait(did, i));\n+                inner_ty, mode, substs, m, method_trait(did, i));\n         }\n     }\n \n-    fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n+    fn add_candidates_from_class(inner_ty: ty::t,\n+                                 mode: method_lookup_mode,\n+                                 did: ast::def_id,\n+                                 class_substs: ty::substs) {\n \n         debug!(\"add_candidates_from_class\");\n \n@@ -371,7 +397,7 @@ struct lookup {\n                 self.tcx(), did, self.m_name, self.expr.span);\n \n             self.add_candidates_from_m(\n-                class_substs, m, method_static(m_declared));\n+                inner_ty, mode, class_substs, m, method_static(m_declared));\n         }\n     }\n \n@@ -488,11 +514,42 @@ struct lookup {\n         return added_any;\n     }\n \n-    fn add_candidates_from_m(self_substs: ty::substs,\n+    fn add_candidates_from_m(inner_ty: ty::t,\n+                             mode: method_lookup_mode,\n+                             self_substs: ty::substs,\n                              m: ty::method,\n                              origin: method_origin) {\n         let tcx = self.fcx.ccx.tcx;\n \n+        // If we don't have a self region but have an region pointer\n+        // explicit self, we need to make up a new region.\n+        let self_r = match self_substs.self_r {\n+          none => {\n+            match m.self_ty {\n+              ast::sty_region(_) =>\n+                  some(self.fcx.infcx.next_region_var(\n+                      self.self_expr.span,\n+                      self.self_expr.id)),\n+              _ => none\n+            }\n+          }\n+          some(_) => self_substs.self_r\n+        };\n+        let self_substs = {self_r: self_r with self_substs};\n+\n+        // Before we can be sure we succeeded we need to match the\n+        // self type against the impl type that we get when we apply\n+        // the explicit self parameter to whatever inner type we are\n+        // looking at (which may be something that the self_type\n+        // points to).\n+        let impl_ty = transform_self_type_for_method(\n+            self.tcx(), self_substs.self_r,\n+            inner_ty, m.self_ty);\n+\n+        let matches = self.check_type_match(impl_ty, mode);\n+        debug!(\"matches = %?\", matches);\n+        if matches.is_err() { return; }\n+\n         // a bit hokey, but the method unbound has a bare protocol, whereas\n         // a.b has a protocol like fn@() (perhaps eventually fn&()):\n         let fty = ty::mk_fn(tcx, {proto: ty::proto_vstore(ty::vstore_box)\n@@ -507,7 +564,7 @@ struct lookup {\n              entry: {derefs: self.derefs,\n                      self_mode: get_mode_from_self_type(m.self_ty),\n                      origin: origin},\n-             mode: subtyping_mode});\n+             mode: mode});\n     }\n \n     fn add_inherent_and_extension_candidates(optional_inherent_methods:"}]}