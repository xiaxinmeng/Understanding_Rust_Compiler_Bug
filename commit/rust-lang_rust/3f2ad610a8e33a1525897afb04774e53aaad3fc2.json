{"sha": "3f2ad610a8e33a1525897afb04774e53aaad3fc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMmFkNjEwYThlMzNhMTUyNTg5N2FmYjA0Nzc0ZTUzYWFhZDNmYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-18T11:09:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-18T11:09:03Z"}, "message": "Auto merge of #28845 - oli-obk:rfc1229, r=pnkfelix\n\nThis PR turns statically known erroneous code (e.g. numeric overflow) into a warning and continues normal code-generation to emit the same code that would have been generated without `check_const` detecting that the result can be computed at compile-time.\r\n\r\n<del>It's not done yet, as I don't know how to properly emit a lint from trans. I can't seem to extract the real lint level of the item the erroneous expression is in.</del> It's an unconditional warning now.\r\n\r\nr? @pnkfelix \r\n\r\ncc @nikomatsakis \r\n\r\n* [RFC 1229 text](https://github.com/rust-lang/rfcs/blob/master/text/1229-compile-time-asserts.md)\r\n* RFC PR: rust-lang/rfcs#1229\r\n* tracking issue: https://github.com/rust-lang/rust/issues/28238", "tree": {"sha": "5b74580947c826daa4c246d740ff208522c9ae44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b74580947c826daa4c246d740ff208522c9ae44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2ad610a8e33a1525897afb04774e53aaad3fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2ad610a8e33a1525897afb04774e53aaad3fc2", "html_url": "https://github.com/rust-lang/rust/commit/3f2ad610a8e33a1525897afb04774e53aaad3fc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2ad610a8e33a1525897afb04774e53aaad3fc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7c5e5d3d355a3980e3c598456b616942bfb6d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7c5e5d3d355a3980e3c598456b616942bfb6d9", "html_url": "https://github.com/rust-lang/rust/commit/9d7c5e5d3d355a3980e3c598456b616942bfb6d9"}, {"sha": "09d3adf52eaf6e411b49d26af7d347406f563557", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d3adf52eaf6e411b49d26af7d347406f563557", "html_url": "https://github.com/rust-lang/rust/commit/09d3adf52eaf6e411b49d26af7d347406f563557"}], "stats": {"total": 570, "additions": 376, "deletions": 194}, "files": [{"sha": "26f663b1c9d79de988cc608688f4cec78914e3a6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -16,6 +16,12 @@\n \n use lint::{LintPass, LateLintPass, LintArray};\n \n+declare_lint! {\n+    pub CONST_ERR,\n+    Warn,\n+    \"constant evaluation detected erroneous expression\"\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,\n@@ -134,7 +140,8 @@ impl LintPass for HardwiredLints {\n             VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES,\n             TRIVIAL_CASTS,\n-            TRIVIAL_NUMERIC_CASTS\n+            TRIVIAL_NUMERIC_CASTS,\n+            CONST_ERR\n         )\n     }\n }"}, {"sha": "433d2468a0973e37225ff0febfdde60bd7d33d29", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -176,8 +176,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         if mode == Mode::ConstFn {\n             for arg in &fd.inputs {\n                 match arg.pat.node {\n-                    hir::PatIdent(hir::BindByValue(hir::MutImmutable), _, None) => {}\n                     hir::PatWild(_) => {}\n+                    hir::PatIdent(hir::BindByValue(hir::MutImmutable), _, None) => {}\n                     _ => {\n                         span_err!(self.tcx.sess, arg.pat.span, E0022,\n                                   \"arguments of constant functions can only \\\n@@ -476,9 +476,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                                     self.tcx, ex, ExprTypeChecked) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n-                                    span_err!(self.tcx.sess, msg.span, E0020,\n-                                              \"{} in a constant expression\",\n-                                              msg.description())\n+                                    self.tcx.sess.add_lint(::lint::builtin::CONST_ERR, ex.id,\n+                                                           msg.span,\n+                                                           msg.description().into_owned())\n                                 }\n                             }\n                         }"}, {"sha": "f0e4c20be05050b230e4deb04856c5c5b8f07eaf", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -275,19 +275,30 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n     }\n \n     fn trans<'blk>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n+        use trans::consts::TrueConst::Yes;\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n-                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None);\n+                let expr = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None, Yes);\n+                let llval = match expr {\n+                    Ok((llval, _)) => llval,\n+                    Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n+                };\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None);\n-                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None);\n+                let l1 = match consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None, Yes) {\n+                    Ok((l1, _)) => l1,\n+                    Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n+                };\n+                let l2 = match consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None, Yes) {\n+                    Ok((l2, _)) => l2,\n+                    Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n+                };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {"}, {"sha": "af4f8aff113132cc5ff08c0336ab8d74d2712022", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -2125,7 +2125,10 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          let g = consts::trans_static(ccx, m, expr, item.id, &item.attrs);\n+          let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n+              Ok(g) => g,\n+              Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+          };\n           set_global_section(ccx, g, item);\n           update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n       },"}, {"sha": "5986236c27f0e65230231ec5bb473e7ada608ee6", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 184, "deletions": 75, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -15,7 +15,7 @@ use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use metadata::cstore::LOCAL_CRATE;\n use middle::{check_const, def};\n-use middle::const_eval::{self, ConstVal};\n+use middle::const_eval::{self, ConstVal, ConstEvalErr};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n@@ -29,7 +29,10 @@ use middle::const_eval::eval_const_expr_partial;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n-use trans::common::*;\n+use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n+use trans::common::{type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n+use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n+use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null, ExprId, MethodCallKey};\n use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -44,6 +47,7 @@ use util::nodemap::NodeMap;\n use rustc_front::hir;\n \n use std::ffi::{CStr, CString};\n+use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast;\n use syntax::attr;\n@@ -191,7 +195,8 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            node: ExprOrMethodCall,\n                            def_id: DefId,\n                            arg_vals: &[ValueRef],\n-                           param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n+                           param_substs: &'tcx Substs<'tcx>,\n+                           trueconst: TrueConst) -> Result<ValueRef, ConstEvalFailure> {\n     let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n     let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n \n@@ -204,9 +209,9 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n     match fn_like.body().expr {\n         Some(ref expr) => {\n-            const_expr(ccx, &**expr, substs, Some(&fn_args)).0\n-        }\n-        None => C_nil(ccx)\n+            const_expr(ccx, &**expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n+        },\n+        None => Ok(C_nil(ccx)),\n     }\n }\n \n@@ -229,19 +234,57 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n+pub enum ConstEvalFailure {\n+    /// in case the const evaluator failed on something that panic at runtime\n+    /// as defined in RFC 1229\n+    Runtime(ConstEvalErr),\n+    // in case we found a true constant\n+    Compiletime(ConstEvalErr),\n+}\n+\n+impl ConstEvalFailure {\n+    fn into_inner(self) -> ConstEvalErr {\n+        match self {\n+            Runtime(e) => e,\n+            Compiletime(e) => e,\n+        }\n+    }\n+    pub fn description(&self) -> Cow<str> {\n+        match self {\n+            &Runtime(ref e) => e.description(),\n+            &Compiletime(ref e) => e.description(),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum TrueConst {\n+    Yes, No\n+}\n+\n+use self::ConstEvalFailure::*;\n+\n fn get_const_val(ccx: &CrateContext,\n                  def_id: DefId,\n-                 ref_expr: &hir::Expr) -> ValueRef {\n+                 ref_expr: &hir::Expr) -> Result<ValueRef, ConstEvalFailure> {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::empty(), empty_substs)\n+    match get_const_expr_as_global(ccx, expr, check_const::ConstQualif::empty(),\n+                                   empty_substs, TrueConst::Yes) {\n+        Err(Runtime(err)) => {\n+            ccx.tcx().sess.span_err(expr.span, &err.description());\n+            Err(Compiletime(err))\n+        },\n+        other => other,\n+    }\n }\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           expr: &hir::Expr,\n                                           qualif: check_const::ConstQualif,\n-                                          param_substs: &'tcx Substs<'tcx>)\n-                                          -> ValueRef {\n+                                          param_substs: &'tcx Substs<'tcx>,\n+                                          trueconst: TrueConst)\n+                                          -> Result<ValueRef, ConstEvalFailure> {\n     debug!(\"get_const_expr_as_global: {:?}\", expr.id);\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n@@ -263,17 +306,20 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let key = (expr.id, param_substs);\n     match ccx.const_values().borrow().get(&key) {\n-        Some(&val) => return val,\n+        Some(&val) => return Ok(val),\n         None => {}\n     }\n     let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n                                               &ccx.tcx().expr_ty(expr));\n     let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n-        const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n+        try!(const_expr_unadjusted(ccx, expr, ty, param_substs, None, trueconst))\n     } else {\n-        const_expr(ccx, expr, param_substs, None).0\n+        match const_expr(ccx, expr, param_substs, None, trueconst) {\n+            Err(err) => return Err(err),\n+            Ok((ok, _)) => ok,\n+        }\n     };\n \n     // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -288,17 +334,18 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let lvalue = addr_of(ccx, val, type_of::align_of(ccx, ty), \"const\");\n     ccx.const_values().borrow_mut().insert(key, lvalue);\n-    lvalue\n+    Ok(lvalue)\n }\n \n pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             e: &hir::Expr,\n                             param_substs: &'tcx Substs<'tcx>,\n-                            fn_args: FnArgMap)\n-                            -> (ValueRef, Ty<'tcx>) {\n+                            fn_args: FnArgMap,\n+                            trueconst: TrueConst)\n+                            -> Result<(ValueRef, Ty<'tcx>), ConstEvalFailure> {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                &cx.tcx().expr_ty(e));\n-    let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args);\n+    let llconst = try!(const_expr_unadjusted(cx, e, ety, param_substs, fn_args, trueconst));\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n@@ -393,11 +440,11 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                          e, ety_adjusted,\n                          csize, tsize));\n     }\n-    (llconst, ety_adjusted)\n+    Ok((llconst, ety_adjusted))\n }\n \n fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n-                             te: ValueRef) {\n+                             te: ValueRef, trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n     // The only kind of unary expression that we check for validity\n     // here is `-expr`, to check if it \"overflows\" (e.g. `-i32::MIN`).\n     if let hir::ExprUnary(hir::UnNeg, ref inner_e) = e.node {\n@@ -410,45 +457,65 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n         //\n         // Catch this up front by looking for ExprLit directly,\n         // and just accepting it.\n-        if let hir::ExprLit(_) = inner_e.node { return; }\n+        if let hir::ExprLit(_) = inner_e.node { return Ok(()); }\n \n         let result = match t.sty {\n             ty::TyInt(int_type) => {\n                 let input = match const_to_opt_int(te) {\n                     Some(v) => v,\n-                    None => return,\n+                    None => return Ok(()),\n                 };\n                 const_int_checked_neg(\n                     input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n             }\n             ty::TyUint(uint_type) => {\n                 let input = match const_to_opt_uint(te) {\n                     Some(v) => v,\n-                    None => return,\n+                    None => return Ok(()),\n                 };\n                 const_uint_checked_neg(\n                     input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n             }\n-            _ => return,\n+            _ => return Ok(()),\n         };\n+        const_err(cx, e, result, trueconst)\n+    } else {\n+        Ok(())\n+    }\n+}\n \n-        // We do not actually care about a successful result.\n-        if let Err(err) = result {\n+fn const_err(cx: &CrateContext,\n+             e: &hir::Expr,\n+             result: Result<ConstVal, ConstEvalErr>,\n+             trueconst: TrueConst)\n+             -> Result<(), ConstEvalFailure> {\n+    match (result, trueconst) {\n+        (Ok(_), _) => {\n+            // We do not actually care about a successful result.\n+            Ok(())\n+        },\n+        (Err(err), TrueConst::Yes) => {\n             cx.tcx().sess.span_err(e.span, &err.description());\n-        }\n+            Err(Compiletime(err))\n+        },\n+        (Err(err), TrueConst::No) => {\n+            cx.tcx().sess.span_warn(e.span, &err.description());\n+            Err(Runtime(err))\n+        },\n     }\n }\n \n fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n-                              te1: ValueRef, te2: ValueRef) {\n-    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { return };\n+                              te1: ValueRef, te2: ValueRef,\n+                              trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n+    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { unreachable!() };\n \n     let result = match t.sty {\n         ty::TyInt(int_type) => {\n             let (lhs, rhs) = match (const_to_opt_int(te1),\n                                     const_to_opt_int(te2)) {\n                 (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return,\n+                _ => return Ok(()),\n             };\n \n             let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n@@ -460,14 +527,14 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                 hir::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n                 hir::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n                 hir::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return,\n+                _ => return Ok(()),\n             }\n         }\n         ty::TyUint(uint_type) => {\n             let (lhs, rhs) = match (const_to_opt_uint(te1),\n                                     const_to_opt_uint(te2)) {\n                 (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return,\n+                _ => return Ok(()),\n             };\n \n             let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n@@ -479,53 +546,54 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                 hir::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n                 hir::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n                 hir::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return,\n+                _ => return Ok(()),\n             }\n         }\n-        _ => return,\n+        _ => return Ok(()),\n     };\n-    // We do not actually care about a successful result.\n-    if let Err(err) = result {\n-        cx.tcx().sess.span_err(e.span, &err.description());\n-    }\n+    const_err(cx, e, result, trueconst)\n }\n \n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &hir::Expr,\n                                    ety: Ty<'tcx>,\n                                    param_substs: &'tcx Substs<'tcx>,\n-                                   fn_args: FnArgMap)\n-                                   -> ValueRef\n+                                   fn_args: FnArgMap,\n+                                   trueconst: TrueConst)\n+                                   -> Result<ValueRef, ConstEvalFailure>\n {\n     debug!(\"const_expr_unadjusted(e={:?}, ety={:?}, param_substs={:?})\",\n            e,\n            ety,\n            param_substs);\n \n-    let map_list = |exprs: &[P<hir::Expr>]| -> Vec<ValueRef> {\n+    let map_list = |exprs: &[P<hir::Expr>]| -> Result<Vec<ValueRef>, ConstEvalFailure> {\n         exprs.iter()\n-             .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n+             .map(|e| const_expr(cx, &**e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n+             .collect::<Vec<Result<ValueRef, ConstEvalFailure>>>()\n+             .into_iter()\n              .collect()\n+         // this dance is necessary to eagerly run const_expr so all errors are reported\n     };\n     let _icx = push_ctxt(\"const_expr\");\n-    match e.node {\n+    Ok(match e.node {\n         hir::ExprLit(ref lit) => {\n             const_lit(cx, e, &**lit)\n         },\n         hir::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n+            let (te1, ty) = try!(const_expr(cx, &**e1, param_substs, fn_args, trueconst));\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n-            let (te2, _) = const_expr(cx, &**e2, param_substs, fn_args);\n+            let (te2, _) = try!(const_expr(cx, &**e2, param_substs, fn_args, trueconst));\n \n-            check_binary_expr_validity(cx, e, ty, te1, te2);\n+            try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n \n             unsafe { match b.node {\n                 hir::BiAdd if is_float => llvm::LLVMConstFAdd(te1, te2),\n@@ -571,9 +639,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } } // unsafe { match b.node {\n         },\n         hir::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = const_expr(cx, &**inner_e, param_substs, fn_args);\n+            let (te, ty) = try!(const_expr(cx, &**inner_e, param_substs, fn_args, trueconst));\n \n-            check_unary_expr_validity(cx, e, ty, te);\n+            try!(check_unary_expr_validity(cx, e, ty, te, trueconst));\n \n             let is_float = ty.is_fp();\n             unsafe { match u {\n@@ -584,21 +652,21 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } }\n         },\n         hir::ExprField(ref base, field) => {\n-            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n             adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n-            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n         },\n \n         hir::ExprIndex(ref base, ref index) => {\n-            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n             let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked) {\n                 Ok(ConstVal::Int(i)) => i as u64,\n                 Ok(ConstVal::Uint(u)) => u,\n@@ -650,10 +718,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n+            let (v, t_expr) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n             debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n-                return v;\n+                return Ok(v);\n             }\n             if type_is_fat_ptr(cx.tcx(), t_expr) {\n                 // Fat pointer casts.\n@@ -664,9 +732,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    ptr_ty);\n                 if type_is_fat_ptr(cx.tcx(), t_cast) {\n                     let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n-                    return C_struct(cx, &[addr, info], false)\n+                    return Ok(C_struct(cx, &[addr, info], false))\n                 } else {\n-                    return addr;\n+                    return Ok(addr);\n                 }\n             }\n             unsafe { match (\n@@ -732,35 +800,47 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n-                let (v, ty) = const_expr(cx, &**sub, param_substs, fn_args);\n+                let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n                 addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n             }\n         },\n         hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, ty) = const_expr(cx, &**sub, param_substs, fn_args);\n+            let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n             addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n         },\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n-            let vals = map_list(&es[..]);\n+            let vals = try!(map_list(&es[..]));\n             adt::trans_const(cx, &*repr, 0, &vals[..])\n         },\n         hir::ExprStruct(_, ref fs, ref base_opt) => {\n             let repr = adt::represent_type(cx, ety);\n \n             let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base, param_substs, fn_args)),\n+                Some(ref base) => Some(try!(const_expr(\n+                    cx,\n+                    &**base,\n+                    param_substs,\n+                    fn_args,\n+                    trueconst,\n+                ))),\n                 None => None\n             };\n \n             let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n             let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n                 match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n-                    (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n-                    (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n+                    (Some(ref f), _) => {\n+                        const_expr(cx, &*f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n+                    },\n+                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &*repr, bv, discr, ix)),\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n-            }).collect::<Vec<_>>();\n+            })\n+            .collect::<Vec<Result<_, ConstEvalFailure>>>()\n+            .into_iter()\n+            .collect::<Result<Vec<_>,ConstEvalFailure>>();\n+            let cs = try!(cs);\n             if ety.is_simd() {\n                 C_vector(&cs[..])\n             } else {\n@@ -771,8 +851,17 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let vs = es.iter()\n-                       .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n-                       .collect::<Vec<_>>();\n+                       .map(|e| const_expr(\n+                           cx,\n+                           &**e,\n+                           param_substs,\n+                           fn_args,\n+                           trueconst,\n+                       ).map(|(l, _)| l))\n+                       .collect::<Vec<Result<_, ConstEvalFailure>>>()\n+                       .into_iter()\n+                       .collect::<Result<Vec<_>, ConstEvalFailure>>();\n+            let vs = try!(vs);\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, &vs[..], false)\n@@ -784,7 +873,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = cx.tcx().eval_repeat_count(count);\n-            let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n+            let unit_val = try!(const_expr(cx, &**elem, param_substs, fn_args, trueconst)).0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -806,7 +895,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n                 def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n-                    const_deref_ptr(cx, get_const_val(cx, def_id, e))\n+                    const_deref_ptr(cx, try!(get_const_val(cx, def_id, e)))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n@@ -850,10 +939,17 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 };\n             }\n             let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n-            let arg_vals = map_list(args);\n+            let arg_vals = try!(map_list(args));\n             match def {\n                 def::DefFn(did, _) | def::DefMethod(did) => {\n-                    const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n+                    try!(const_fn_call(\n+                        cx,\n+                        ExprId(callee.id),\n+                        did,\n+                        &arg_vals,\n+                        param_substs,\n+                        trueconst,\n+                    ))\n                 }\n                 def::DefStruct(_) => {\n                     if ety.is_simd() {\n@@ -875,15 +971,21 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         hir::ExprMethodCall(_, _, ref args) => {\n-            let arg_vals = map_list(args);\n+            let arg_vals = try!(map_list(args));\n             let method_call = ty::MethodCall::expr(e.id);\n             let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n-            const_fn_call(cx, MethodCallKey(method_call),\n-                          method_did, &arg_vals, param_substs)\n+            try!(const_fn_call(cx, MethodCallKey(method_call),\n+                               method_did, &arg_vals, param_substs, trueconst))\n         },\n         hir::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr, param_substs, fn_args).0,\n+                Some(ref expr) => try!(const_expr(\n+                    cx,\n+                    &**expr,\n+                    param_substs,\n+                    fn_args,\n+                    trueconst,\n+                )).0,\n                 None => C_nil(cx),\n             }\n         },\n@@ -902,20 +1004,27 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         _ => cx.sess().span_bug(e.span,\n                                 \"bad constant expression type in consts::const_expr\"),\n-    }\n+    })\n }\n+\n pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n                     id: ast::NodeId,\n                     attrs: &Vec<ast::Attribute>)\n-                    -> ValueRef {\n+                    -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n \n         let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-        let (v, _) = const_expr(ccx, expr, empty_substs, None);\n+        let (v, _) = try!(const_expr(\n+            ccx,\n+            expr,\n+            empty_substs,\n+            None,\n+            TrueConst::Yes,\n+        ).map_err(|e| e.into_inner()));\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n@@ -964,7 +1073,7 @@ pub fn trans_static(ccx: &CrateContext,\n                                \"thread_local\") {\n             llvm::set_thread_local(g, true);\n         }\n-        g\n+        Ok(g)\n     }\n }\n "}, {"sha": "6144de7109fba4f7f7a0aa1b15a6324ad0225233", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 74, "deletions": 46, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -133,13 +133,25 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     ) {\n         if !qualif.intersects(check_const::ConstQualif::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n-                let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n-                                                            bcx.fcx.param_substs);\n-                // Cast pointer to destination, because constants\n-                // have different types.\n-                let lldest = PointerCast(bcx, lldest, val_ty(global));\n-                memcpy_ty(bcx, lldest, global, expr_ty_adjusted(bcx, expr));\n-                return bcx;\n+                match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                       bcx.fcx.param_substs,\n+                                                       consts::TrueConst::No) {\n+                    Ok(global) => {\n+                        // Cast pointer to destination, because constants\n+                        // have different types.\n+                        let lldest = PointerCast(bcx, lldest, val_ty(global));\n+                        memcpy_ty(bcx, lldest, global, expr_ty_adjusted(bcx, expr));\n+                        return bcx;\n+                    },\n+                    Err(consts::ConstEvalFailure::Runtime(_)) => {\n+                        // in case const evaluation errors, translate normally\n+                        // debug assertions catch the same errors\n+                        // see RFC 1229\n+                    },\n+                    Err(consts::ConstEvalFailure::Compiletime(_)) => {\n+                        return bcx;\n+                    },\n+                }\n             }\n             // Even if we don't have a value to emit, and the expression\n             // doesn't have any side-effects, we still have to translate the\n@@ -221,48 +233,64 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         check_const::ConstQualif::NOT_CONST |\n         check_const::ConstQualif::NEEDS_DROP\n     ) {\n-        let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n-                                                      bcx.fcx.param_substs);\n+        match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                            bcx.fcx.param_substs,\n+                                                            consts::TrueConst::No) {\n+            Ok(global) => {\n+                if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n+                    // Is borrowed as 'static, must return lvalue.\n+\n+                    // Cast pointer to global, because constants have different types.\n+                    let const_ty = expr_ty_adjusted(bcx, expr);\n+                    let llty = type_of::type_of(bcx.ccx(), const_ty);\n+                    let global = PointerCast(bcx, global, llty.ptr_to());\n+                    let datum = Datum::new(global, const_ty, Lvalue::new(\"expr::trans\"));\n+                    return DatumBlock::new(bcx, datum.to_expr_datum());\n+                }\n \n-        if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n-            // Is borrowed as 'static, must return lvalue.\n+                // Otherwise, keep around and perform adjustments, if needed.\n+                let const_ty = if adjusted_global {\n+                    expr_ty_adjusted(bcx, expr)\n+                } else {\n+                    expr_ty(bcx, expr)\n+                };\n \n-            // Cast pointer to global, because constants have different types.\n-            let const_ty = expr_ty_adjusted(bcx, expr);\n-            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-            let global = PointerCast(bcx, global, llty.ptr_to());\n-            let datum = Datum::new(global, const_ty, Lvalue::new(\"expr::trans\"));\n-            return DatumBlock::new(bcx, datum.to_expr_datum());\n+                // This could use a better heuristic.\n+                Some(if type_is_immediate(bcx.ccx(), const_ty) {\n+                    // Cast pointer to global, because constants have different types.\n+                    let llty = type_of::type_of(bcx.ccx(), const_ty);\n+                    let global = PointerCast(bcx, global, llty.ptr_to());\n+                    // Maybe just get the value directly, instead of loading it?\n+                    immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n+                } else {\n+                    let scratch = alloc_ty(bcx, const_ty, \"const\");\n+                    call_lifetime_start(bcx, scratch);\n+                    let lldest = if !const_ty.is_structural() {\n+                        // Cast pointer to slot, because constants have different types.\n+                        PointerCast(bcx, scratch, val_ty(global))\n+                    } else {\n+                        // In this case, memcpy_ty calls llvm.memcpy after casting both\n+                        // source and destination to i8*, so we don't need any casts.\n+                        scratch\n+                    };\n+                    memcpy_ty(bcx, lldest, global, const_ty);\n+                    Datum::new(scratch, const_ty, Rvalue::new(ByRef))\n+                })\n+            },\n+            Err(consts::ConstEvalFailure::Runtime(_)) => {\n+                // in case const evaluation errors, translate normally\n+                // debug assertions catch the same errors\n+                // see RFC 1229\n+                None\n+            },\n+            Err(consts::ConstEvalFailure::Compiletime(_)) => {\n+                // generate a dummy llvm value\n+                let const_ty = expr_ty(bcx, expr);\n+                let llty = type_of::type_of(bcx.ccx(), const_ty);\n+                let dummy = C_undef(llty.ptr_to());\n+                Some(Datum::new(dummy, const_ty, Rvalue::new(ByRef)))\n+            },\n         }\n-\n-        // Otherwise, keep around and perform adjustments, if needed.\n-        let const_ty = if adjusted_global {\n-            expr_ty_adjusted(bcx, expr)\n-        } else {\n-            expr_ty(bcx, expr)\n-        };\n-\n-        // This could use a better heuristic.\n-        Some(if type_is_immediate(bcx.ccx(), const_ty) {\n-            // Cast pointer to global, because constants have different types.\n-            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-            let global = PointerCast(bcx, global, llty.ptr_to());\n-            // Maybe just get the value directly, instead of loading it?\n-            immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n-        } else {\n-            let scratch = alloc_ty(bcx, const_ty, \"const\");\n-            call_lifetime_start(bcx, scratch);\n-            let lldest = if !const_ty.is_structural() {\n-                // Cast pointer to slot, because constants have different types.\n-                PointerCast(bcx, scratch, val_ty(global))\n-            } else {\n-                // In this case, memcpy_ty calls llvm.memcpy after casting both\n-                // source and destination to i8*, so we don't need any casts.\n-                scratch\n-            };\n-            memcpy_ty(bcx, lldest, global, const_ty);\n-            Datum::new(scratch, const_ty, Rvalue::new(ByRef))\n-        })\n     } else {\n         None\n     };"}, {"sha": "a8d85ae17e2bb36bb926d35dffa319784f6219eb", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -1563,7 +1563,16 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n             None => bcx.sess().span_bug(call_info.span,\n                                         \"intrinsic call with unexpected argument shape\"),\n         };\n-        let vector = consts::const_expr(bcx.ccx(), vector, tcx.mk_substs(substs), None).0;\n+        let vector = match consts::const_expr(\n+            bcx.ccx(),\n+            vector,\n+            tcx.mk_substs(substs),\n+            None,\n+            consts::TrueConst::Yes, // this should probably help simd error reporting\n+        ) {\n+            Ok((vector, _)) => vector,\n+            Err(err) => bcx.sess().span_fatal(call_info.span, &err.description()),\n+        };\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {"}, {"sha": "be67e06d99fee0f0cc8fc3a22b02857cf4f23b14", "filename": "src/test/compile-fail/const-err.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(exceeding_bitshifts)]\n+#[deny(const_err)]\n+\n+fn black_box<T>(_: T) {\n+    unimplemented!()\n+}\n+\n+const BLA: u8 = 200u8 + 200u8;\n+//~^ ERROR attempted to add with overflow\n+\n+fn main() {\n+    let a = -std::i8::MIN;\n+    //~^ WARN attempted to negate with overflow\n+    let b = 200u8 + 200u8 + 200u8;\n+    //~^ WARN attempted to add with overflow\n+    //~^^ WARN attempted to add with overflow\n+    let c = 200u8 * 4;\n+    //~^ WARN attempted to mul with overflow\n+    let d = 42u8 - (42u8 + 1);\n+    //~^ WARN attempted to sub with overflow\n+    let _e = BLA;\n+    black_box(a);\n+    black_box(b);\n+    black_box(c);\n+    black_box(d);\n+}"}, {"sha": "daa60955ad88decd4d037bc1fe3299d4d24ec018", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n-\n #![allow(unused_imports)]\n #![feature(negate_unsigned)]\n "}, {"sha": "95921556c7db1de120f85c73887fc83e8fe23c87", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -8,48 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(const_err)]\n+\n use std::{isize, i8, i16, i32, i64};\n use std::thread;\n \n fn main() {\n     assert!(thread::spawn(move|| { isize::MIN / -1; }).join().is_err());\n-    //~^ ERROR attempted to divide with overflow in a constant expression\n+    //~^ ERROR attempted to divide with overflow\n     assert!(thread::spawn(move|| { i8::MIN / -1; }).join().is_err());\n-    //~^ ERROR attempted to divide with overflow in a constant expression\n+    //~^ ERROR attempted to divide with overflow\n     assert!(thread::spawn(move|| { i16::MIN / -1; }).join().is_err());\n-    //~^ ERROR attempted to divide with overflow in a constant expression\n+    //~^ ERROR attempted to divide with overflow\n     assert!(thread::spawn(move|| { i32::MIN / -1; }).join().is_err());\n-    //~^ ERROR attempted to divide with overflow in a constant expression\n+    //~^ ERROR attempted to divide with overflow\n     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n-    //~^ ERROR attempted to divide with overflow in a constant expression\n+    //~^ ERROR attempted to divide with overflow\n     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n-    //~^ ERROR attempted to divide by zero in a constant expression\n+    //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n-    //~^ ERROR attempted to divide by zero in a constant expression\n+    //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n-    //~^ ERROR attempted to divide by zero in a constant expression\n+    //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n-    //~^ ERROR attempted to divide by zero in a constant expression\n+    //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n-    //~^ ERROR attempted to divide by zero in a constant expression\n+    //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow in a constant expression\n+    //~^ ERROR attempted remainder with overflow\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow in a constant expression\n+    //~^ ERROR attempted remainder with overflow\n     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow in a constant expression\n+    //~^ ERROR attempted remainder with overflow\n     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow in a constant expression\n+    //~^ ERROR attempted remainder with overflow\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow in a constant expression\n+    //~^ ERROR attempted remainder with overflow\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    //~^ ERROR attempted remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    //~^ ERROR attempted remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    //~^ ERROR attempted remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    //~^ ERROR attempted remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    //~^ ERROR attempted remainder with a divisor of zero\n }"}, {"sha": "6c6a41fa6f2e3e6deaa21b8e62bcb2faa94b8959", "filename": "src/test/run-fail/overflowing-add.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-add.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,7 @@\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn value() -> u8 { 200 }\n \n fn main() {\n-    let _x = value() + value() + value();\n+    let _x = 200u8 + 200u8 + 200u8;\n }"}, {"sha": "62935bacce8711f90b198d14fc5b7b387f1f53bc", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = 1_i32 << id(32);\n+    let _x = 1_i32 << 32;\n }"}, {"sha": "f6e6cb105c51bd797fa12c0ae5cef393e8fe726d", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = 1 << id(-1);\n+    let _x = 1 << -1;\n }"}, {"sha": "a70f31954c6edaf65d7331f6eff2199679f1d4d5", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = 1_u64 << id(64);\n+    let _x = 1_u64 << 64;\n }"}, {"sha": "571feaeb94345f70b2de1103fa3db812f922a65b", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -14,12 +14,11 @@\n // This function is checking that our automatic truncation does not\n // sidestep the overflow checking.\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n     // this signals overflow when checking is on\n-    let x = 1_i8 << id(17);\n+    let x = 1_i8 << 17;\n \n     // ... but when checking is off, the fallback will truncate the\n     // input to its lower three bits (= 1). Note that this is *not*"}, {"sha": "a413a6f0abfa29d489fdac600e5f05a6cace1c2d", "filename": "src/test/run-fail/overflowing-mul.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,6 @@\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn value() -> u8 { 200 }\n-\n fn main() {\n-    let x = value() * 4;\n+    let x = 200u8 * 4;\n }"}, {"sha": "7891d1ce9bed4931d2bd8fb7cd6e2256b5a61115", "filename": "src/test/run-fail/overflowing-neg.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,6 @@\n // error-pattern:thread '<main>' panicked at 'attempted to negate with overflow'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn value() -> i8 { std::i8::MIN }\n-\n fn main() {\n-    let _x = -value();\n+    let _x = -std::i8::MIN;\n }"}, {"sha": "b58eaf7f836c2c2e1d38ad48d16159ef9c7f8059", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = -1_i32 >> id(32);\n+    let _x = -1_i32 >> 32;\n }"}, {"sha": "40b468a6ad41974d4b50b5c943b48e7d21eeefa2", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = -1_i32 >> id(-1);\n+    let _x = -1_i32 >> -1;\n }"}, {"sha": "afe6a908cb5f13587dee7d6d6dd564e1081009fd", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,8 @@\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n-    let _x = -1_i64 >> id(64);\n+    let _x = -1_i64 >> 64;\n }"}, {"sha": "585186575f6eda614bd4631861624bd1205e5387", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -14,12 +14,11 @@\n // This function is checking that our (type-based) automatic\n // truncation does not sidestep the overflow checking.\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n+#![warn(exceeding_bitshifts)]\n \n fn main() {\n     // this signals overflow when checking is on\n-    let x = 2_i8 >> id(17);\n+    let x = 2_i8 >> 17;\n \n     // ... but when checking is off, the fallback will truncate the\n     // input to its lower three bits (= 1). Note that this is *not*"}, {"sha": "ece4d37c36eb31171ca1fa40009cb51f6893e0e5", "filename": "src/test/run-fail/overflowing-sub.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -11,9 +11,6 @@\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n-// (Work around constant-evaluation)\n-fn value() -> u8 { 42 }\n-\n fn main() {\n-    let _x = value() - (value() + 1);\n+    let _x = 42u8 - (42u8 + 1);\n }"}, {"sha": "5470ad93e142644c217a0404422d1466f78c5308", "filename": "src/test/run-pass/wrapping-int-api.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ad610a8e33a1525897afb04774e53aaad3fc2/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs?ref=3f2ad610a8e33a1525897afb04774e53aaad3fc2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(num_wrapping)]\n-\n // Test inherent wrapping_* methods for {i,u}{size,8,16,32,64}.\n \n use std::{i8, i16, i32, i64, isize};"}]}