{"sha": "fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYjcwZDkxNmYwOGU4ODBjN2YwY2E1NzZmN2Y1NmVhN2E0MGRkYzE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T04:14:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:29Z"}, "message": "librustc: De-`@mut` the `reachable` map", "tree": {"sha": "e9e2ed903d8eeee2dbd36a9b00cf706df2bc4f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9e2ed903d8eeee2dbd36a9b00cf706df2bc4f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "html_url": "https://github.com/rust-lang/rust/commit/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "417378554c076d2c3b42156fc046fd390587af41", "url": "https://api.github.com/repos/rust-lang/rust/commits/417378554c076d2c3b42156fc046fd390587af41", "html_url": "https://github.com/rust-lang/rust/commit/417378554c076d2c3b42156fc046fd390587af41"}], "stats": {"total": 116, "additions": 80, "deletions": 36}, "files": [{"sha": "a3f5dc4257b9615682d381adac9e85156da46f3b", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -212,7 +212,7 @@ pub struct CrateAnalysis {\n     exported_items: middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @mut HashSet<ast::NodeId>\n+    reachable: @RefCell<HashSet<ast::NodeId>>\n }\n \n /// Run the resolution, typechecking, region checking and other\n@@ -309,9 +309,16 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"reachability checking\", (), |_|\n              reachable::find_reachable(ty_cx, method_map, &exported_items));\n \n-    time(time_passes, \"death checking\", (), |_|\n-         middle::dead::check_crate(ty_cx, method_map,\n-                                   &exported_items, reachable_map, crate));\n+    {\n+        let reachable_map = reachable_map.borrow();\n+        time(time_passes, \"death checking\", (), |_| {\n+             middle::dead::check_crate(ty_cx,\n+                                       method_map,\n+                                       &exported_items,\n+                                       reachable_map.get(),\n+                                       crate)\n+        });\n+    }\n \n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(ty_cx, method_map, &exported_items, crate));"}, {"sha": "140a53880db74fbd75fcfa81cbbe6dae58d9eb4f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -65,7 +65,7 @@ pub struct EncodeParams<'a> {\n     link_meta: &'a LinkMeta,\n     cstore: @cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'a>,\n-    reachable: @mut HashSet<ast::NodeId>,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n }\n \n struct Stats {\n@@ -95,11 +95,12 @@ pub struct EncodeContext<'a> {\n     cstore: &'a cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'a>,\n     type_abbrevs: abbrev_map,\n-    reachable: @mut HashSet<ast::NodeId>,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n }\n \n pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n-    ecx.reachable.contains(&id)\n+    let reachable = ecx.reachable.borrow();\n+    reachable.get().contains(&id)\n }\n \n fn encode_name(ecx: &EncodeContext,"}, {"sha": "50407ecb09130731be227c7c863181eab5175058", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -19,6 +19,7 @@ use middle::ty;\n use middle::typeck;\n use middle::privacy;\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n@@ -84,7 +85,7 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::method_map,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @mut HashSet<ast::NodeId>,\n+    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n     worklist: @mut ~[ast::NodeId],\n@@ -94,7 +95,7 @@ struct MarkSymbolVisitor {\n     worklist: @mut ~[ast::NodeId],\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n-    reachable_symbols: @mut HashSet<ast::NodeId>,\n+    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n }\n \n impl Visitor<()> for MarkSymbolVisitor {\n@@ -129,7 +130,9 @@ impl Visitor<()> for MarkSymbolVisitor {\n                             // If this wasn't a static, then this destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(def_id.node);\n+                                let mut reachable_symbols =\n+                                    self.reachable_symbols.borrow_mut();\n+                                reachable_symbols.get().insert(def_id.node);\n                             }\n                         }\n                     }\n@@ -146,9 +149,13 @@ impl Visitor<()> for MarkSymbolVisitor {\n                                 def_id_represents_local_inlined_item(\n                                     self.tcx,\n                                     def_id) {\n-                                    self.worklist.push(def_id.node)\n-                                }\n-                            self.reachable_symbols.insert(def_id.node);\n+                                self.worklist.push(def_id.node)\n+                            }\n+                            {\n+                                let mut reachable_symbols =\n+                                    self.reachable_symbols.borrow_mut();\n+                                reachable_symbols.get().insert(def_id.node);\n+                            }\n                         }\n                     }\n                     Some(_) => {}\n@@ -177,7 +184,7 @@ impl ReachableContext {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n-            reachable_symbols: @mut HashSet::new(),\n+            reachable_symbols: @RefCell::new(HashSet::new()),\n             worklist: @mut ~[],\n         }\n     }\n@@ -289,7 +296,9 @@ impl ReachableContext {\n                 ast_map::node_item(item, _) => {\n                     match item.node {\n                         ast::item_fn(_, ast::extern_fn, _, _, _) => {\n-                            self.reachable_symbols.insert(search_item);\n+                            let mut reachable_symbols =\n+                                self.reachable_symbols.borrow_mut();\n+                            reachable_symbols.get().insert(search_item);\n                         }\n                         _ => {}\n                     }\n@@ -301,7 +310,8 @@ impl ReachableContext {\n             // continue to participate in linkage after this product is\n             // produced. In this case, we traverse the ast node, recursing on\n             // all reachable nodes from this one.\n-            self.reachable_symbols.insert(search_item);\n+            let mut reachable_symbols = self.reachable_symbols.borrow_mut();\n+            reachable_symbols.get().insert(search_item);\n         }\n \n         match *node {\n@@ -318,7 +328,9 @@ impl ReachableContext {\n                     ast::item_static(..) => {\n                         if attr::contains_name(item.attrs,\n                                                \"address_insignificant\") {\n-                            self.reachable_symbols.remove(&search_item);\n+                            let mut reachable_symbols =\n+                                self.reachable_symbols.borrow_mut();\n+                            reachable_symbols.get().remove(&search_item);\n                         }\n                     }\n \n@@ -377,7 +389,9 @@ impl ReachableContext {\n         let destructor_for_type = self.tcx.destructor_for_type.borrow();\n         for (_, destructor_def_id) in destructor_for_type.get().iter() {\n             if destructor_def_id.crate == ast::LOCAL_CRATE {\n-                self.reachable_symbols.insert(destructor_def_id.node);\n+                let mut reachable_symbols = self.reachable_symbols\n+                                                .borrow_mut();\n+                reachable_symbols.get().insert(destructor_def_id.node);\n             }\n         }\n     }\n@@ -386,7 +400,7 @@ impl ReachableContext {\n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @mut HashSet<ast::NodeId> {\n+                      -> @RefCell<HashSet<ast::NodeId>> {\n     let reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as"}, {"sha": "e4dc991938b7d89af6adc86ee848e33e738089f6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -2318,8 +2318,11 @@ fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::Nod\n         item_symbols.get().insert(node_id, sym);\n     }\n \n-    if !ccx.reachable.contains(&node_id) {\n-        lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    {\n+        let reachable = ccx.reachable.borrow();\n+        if !reachable.get().contains(&node_id) {\n+            lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+        }\n     }\n \n     if is_entry_fn(&ccx.sess, node_id) && !*ccx.sess.building_library {\n@@ -2531,18 +2534,27 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 });\n \n-                                if !ccx.reachable.contains(&id) {\n-                                    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+                                {\n+                                    let reachable = ccx.reachable.borrow();\n+                                    if !reachable.get().contains(&id) {\n+                                        lib::llvm::SetLinkage(\n+                                            g,\n+                                            lib::llvm::InternalLinkage);\n+                                    }\n                                 }\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n                                 if attr::contains_name(i.attrs,\n                                                        \"address_insignificant\"){\n-                                    if ccx.reachable.contains(&id) {\n-                                        ccx.sess.span_bug(i.span,\n-                                            \"insignificant static is \\\n-                                             reachable\");\n+                                    {\n+                                        let reachable =\n+                                            ccx.reachable.borrow();\n+                                        if reachable.get().contains(&id) {\n+                                            ccx.sess.span_bug(i.span,\n+                                                \"insignificant static is \\\n+                                                 reachable\");\n+                                        }\n                                     }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n \n@@ -2731,8 +2743,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n             // foreign items (extern fns and extern statics) don't have internal\n             // linkage b/c that doesn't quite make sense. Otherwise items can\n             // have internal linkage if they're not reachable.\n-            if !foreign && !ccx.reachable.contains(&id) {\n-                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+            {\n+                let reachable = ccx.reachable.borrow();\n+                if !foreign && !reachable.get().contains(&id) {\n+                    lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+                }\n             }\n \n             let mut item_vals = ccx.item_vals.borrow_mut();\n@@ -3245,10 +3260,14 @@ pub fn trans_crate(sess: session::Session,\n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n-    let mut reachable = ccx.reachable.iter().filter_map(|id| {\n-        let item_symbols = ccx.item_symbols.borrow();\n-        item_symbols.get().find(id).map(|s| s.to_owned())\n-    }).to_owned_vec();\n+\n+    let mut reachable = {\n+        let reachable_map = ccx.reachable.borrow();\n+        reachable_map.get().iter().filter_map(|id| {\n+            let item_symbols = ccx.item_symbols.borrow();\n+            item_symbols.get().find(id).map(|s| s.to_owned())\n+        }).to_owned_vec()\n+    };\n \n     // Make sure that some other crucial symbols are not eliminated from the\n     // module. This includes the main function, the crate map (used for debug"}, {"sha": "a9d18cfa034a82faf129bff9dcdd29d9f053c3f0", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -49,7 +49,7 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n      exp_map2: resolve::ExportMap2,\n-     reachable: @mut HashSet<ast::NodeId>,\n+     reachable: @RefCell<HashSet<ast::NodeId>>,\n      item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n      link_meta: LinkMeta,\n      tydescs: RefCell<HashMap<ty::t, @mut tydesc_info>>,\n@@ -123,7 +123,7 @@ impl CrateContext {\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: @mut HashSet<ast::NodeId>)\n+               reachable: @RefCell<HashSet<ast::NodeId>>)\n                -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();"}, {"sha": "68ba597f01d16c2143aa70f0366271386a0f6387", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fbb70d916f08e880c7f0ca576f7f56ea7a40ddc1", "patch": "@@ -732,7 +732,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // (by being externally visible or by being inlined into something externally visible). It might\n     // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n     // this set is not available in the translation pass.\n-    let is_local_to_unit = !cx.reachable.contains(&fn_ast_id);\n+    let is_local_to_unit = {\n+        let reachable = cx.reachable.borrow();\n+        !reachable.get().contains(&fn_ast_id)\n+    };\n \n     let fn_metadata = function_name.with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {"}]}