{"sha": "6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOGQ4MzE0MDYxODcyMWU3YjcyYTc4ZjJlNTNhMDhlNzFlMWQ0Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-28T11:02:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-28T11:02:32Z"}, "message": "Auto merge of #22851 - FlaPer87:oibit-send-and-friends, r=nikomatsakis\n\nFixes #22828\r\nFixes #22629\r\n\r\nr? @nikomatsakis", "tree": {"sha": "0f72a5ef90e0db644c8d5d3c12b48aa267ac6ffc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f72a5ef90e0db644c8d5d3c12b48aa267ac6ffc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "html_url": "https://github.com/rust-lang/rust/commit/6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8519e7833daa1dd14ff8f88e09929193bd13b6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8519e7833daa1dd14ff8f88e09929193bd13b6b1", "html_url": "https://github.com/rust-lang/rust/commit/8519e7833daa1dd14ff8f88e09929193bd13b6b1"}, {"sha": "b7f9d07f4c4f0fdb5e33736814a2f4f7fd1db7bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f9d07f4c4f0fdb5e33736814a2f4f7fd1db7bf", "html_url": "https://github.com/rust-lang/rust/commit/b7f9d07f4c4f0fdb5e33736814a2f4f7fd1db7bf"}], "stats": {"total": 177, "additions": 114, "deletions": 63}, "files": [{"sha": "d8c62780a781fa124bbb02ca0ea3b0dc35a673a5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "patch": "@@ -1716,6 +1716,60 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn collect_predicates_for_types(&mut self,\n+                                    obligation: &TraitObligation<'tcx>,\n+                                    trait_def_id: ast::DefId,\n+                                    types: Vec<Ty<'tcx>>) -> Vec<PredicateObligation<'tcx>> {\n+\n+        let derived_cause = match self.tcx().lang_items.to_builtin_kind(trait_def_id) {\n+            Some(_) => {\n+                self.derived_cause(obligation, BuiltinDerivedObligation)\n+            },\n+            None => {\n+                self.derived_cause(obligation, ImplDerivedObligation)\n+            }\n+        };\n+\n+        let normalized = project::normalize_with_depth(self, obligation.cause.clone(),\n+                                                       obligation.recursion_depth + 1,\n+                                                       &types);\n+\n+        let obligations = normalized.value.iter().map(|&nested_ty| {\n+            // the obligation might be higher-ranked, e.g. for<'a> &'a\n+            // int : Copy. In that case, we will wind up with\n+            // late-bound regions in the `nested` vector. So for each\n+            // one we instantiate to a skolemized region, do our work\n+            // to produce something like `&'0 int : Copy`, and then\n+            // re-bind it. This is a bit of busy-work but preserves\n+            // the invariant that we only manipulate free regions, not\n+            // bound ones.\n+            self.infcx.try(|snapshot| {\n+                let (skol_ty, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n+                let skol_predicate =\n+                    util::predicate_for_trait_def(\n+                        self.tcx(),\n+                        derived_cause.clone(),\n+                        trait_def_id,\n+                        obligation.recursion_depth + 1,\n+                        skol_ty);\n+                match skol_predicate {\n+                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n+                                                                     &skol_predicate)),\n+                    Err(ErrorReported) => Err(ErrorReported)\n+                }\n+            })\n+        }).collect::<Result<Vec<PredicateObligation<'tcx>>, _>>();\n+\n+        match obligations {\n+            Ok(mut obls) => {\n+                obls.push_all(normalized.obligations.as_slice());\n+                obls\n+            },\n+            Err(ErrorReported) => Vec::new()\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // CONFIRMATION\n     //\n@@ -1854,38 +1908,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<Ty<'tcx>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n-        let derived_cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n-        let obligations = nested.iter().map(|&bound_ty| {\n-            // the obligation might be higher-ranked, e.g. for<'a> &'a\n-            // int : Copy. In that case, we will wind up with\n-            // late-bound regions in the `nested` vector. So for each\n-            // one we instantiate to a skolemized region, do our work\n-            // to produce something like `&'0 int : Copy`, and then\n-            // re-bind it. This is a bit of busy-work but preserves\n-            // the invariant that we only manipulate free regions, not\n-            // bound ones.\n-            self.infcx.try(|snapshot| {\n-                let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty::Binder(bound_ty), snapshot);\n-                let skol_predicate =\n-                    util::predicate_for_builtin_bound(\n-                        self.tcx(),\n-                        derived_cause.clone(),\n-                        bound,\n-                        obligation.recursion_depth + 1,\n-                        skol_ty);\n-                match skol_predicate {\n-                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n-                                                                     &skol_predicate)),\n-                    Err(ErrorReported) => Err(ErrorReported)\n-                }\n-            })\n-        }).collect::<Result<_, _>>();\n-        let obligations = match obligations {\n-            Ok(o) => o,\n-            Err(ErrorReported) => Vec::new(),\n+        let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n+            Ok(def_id) => def_id,\n+            Err(_) => {\n+                self.tcx().sess.bug(\"builtin trait definition not found\");\n+            }\n         };\n \n+        let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n+\n         let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n \n         debug!(\"vtable_builtin_data: obligations={}\",\n@@ -1928,39 +1959,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<Ty<'tcx>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        let derived_cause = self.derived_cause(obligation, ImplDerivedObligation);\n \n-        let obligations = nested.iter().map(|&nested_ty| {\n-            // the obligation might be higher-ranked, e.g. for<'a> &'a\n-            // int : Copy. In that case, we will wind up with\n-            // late-bound regions in the `nested` vector. So for each\n-            // one we instantiate to a skolemized region, do our work\n-            // to produce something like `&'0 int : Copy`, and then\n-            // re-bind it. This is a bit of busy-work but preserves\n-            // the invariant that we only manipulate free regions, not\n-            // bound ones.\n-            self.infcx.try(|snapshot| {\n-                let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n-                let skol_predicate =\n-                    util::predicate_for_default_trait_impl(\n-                        self.tcx(),\n-                        derived_cause.clone(),\n-                        trait_def_id,\n-                        obligation.recursion_depth + 1,\n-                        skol_ty);\n-                match skol_predicate {\n-                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n-                                                                     &skol_predicate)),\n-                    Err(ErrorReported) => Err(ErrorReported)\n-                }\n-            })\n-        }).collect::<Result<_, _>>();\n-\n-        let mut obligations = match obligations {\n-            Ok(o) => o,\n-            Err(ErrorReported) => Vec::new()\n-        };\n+        let mut obligations = self.collect_predicates_for_types(obligation,\n+                                                                trait_def_id,\n+                                                                nested);\n \n         let _: Result<(),()> = self.infcx.try(|snapshot| {\n             let (_, skol_map) ="}, {"sha": "7bef5f32475d39153033ebfef81c471b7aebcb5e", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "patch": "@@ -337,7 +337,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     })\n }\n \n-pub fn predicate_for_default_trait_impl<'tcx>(\n+pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: ast::DefId,"}, {"sha": "7bbd85d817fb96a5893cac592f019234155998e6", "filename": "src/test/run-pass/issue-22629.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Ftest%2Frun-pass%2Fissue-22629.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Ftest%2Frun-pass%2Fissue-22629.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22629.rs?ref=6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test transitive analysis for associated types. Collected types\n+// should be normalized and new obligations generated.\n+\n+use std::borrow::{ToOwned, Cow};\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+fn main() {\n+    assert_send(Cow::Borrowed(\"foo\"));\n+}"}, {"sha": "8ad960b3f1b45ccb441196d4f576fe8e8954f285", "filename": "src/test/run-pass/issue-22828.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Ftest%2Frun-pass%2Fissue-22828.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d83140618721e7b72a78f2e53a08e71e1d4cb/src%2Ftest%2Frun-pass%2Fissue-22828.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22828.rs?ref=6f8d83140618721e7b72a78f2e53a08e71e1d4cb", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test transitive analysis for associated types. Collected types\n+// should be normalized and new obligations generated.\n+\n+trait Foo {\n+    type A;\n+    fn foo(&self) {}\n+}\n+\n+impl Foo for usize {\n+    type A = usize;\n+}\n+\n+struct Bar<T: Foo> { inner: T::A }\n+\n+fn is_send<T: Send>() {}\n+\n+fn main() {\n+    is_send::<Bar<usize>>();\n+}"}]}