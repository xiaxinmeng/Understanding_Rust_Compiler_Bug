{"sha": "0e846998e66539147481882484f05c973a46bc8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlODQ2OTk4ZTY2NTM5MTQ3NDgxODgyNDg0ZjA1Yzk3M2E0NmJjOGY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-01T01:42:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-01T01:42:10Z"}, "message": "Merge pull request #1842 from emilio/rustfmt-format-diff\n\nbin: Add a very simple rustfmt-format-diff.", "tree": {"sha": "958de1f4ffe33f21bc2db33628b97bc00337ae9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/958de1f4ffe33f21bc2db33628b97bc00337ae9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e846998e66539147481882484f05c973a46bc8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e846998e66539147481882484f05c973a46bc8f", "html_url": "https://github.com/rust-lang/rust/commit/0e846998e66539147481882484f05c973a46bc8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e846998e66539147481882484f05c973a46bc8f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9e5afd62e1036c23a2f78d38fd9b9bdd7e52100", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9e5afd62e1036c23a2f78d38fd9b9bdd7e52100", "html_url": "https://github.com/rust-lang/rust/commit/b9e5afd62e1036c23a2f78d38fd9b9bdd7e52100"}, {"sha": "068bcad880b1e14d44ae7aef8709b8f60bea526e", "url": "https://api.github.com/repos/rust-lang/rust/commits/068bcad880b1e14d44ae7aef8709b8f60bea526e", "html_url": "https://github.com/rust-lang/rust/commit/068bcad880b1e14d44ae7aef8709b8f60bea526e"}], "stats": {"total": 341, "additions": 340, "deletions": 1}, "files": [{"sha": "0e0920f875591e883a36536d94ad5fe2296196f9", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e846998e66539147481882484f05c973a46bc8f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e846998e66539147481882484f05c973a46bc8f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0e846998e66539147481882484f05c973a46bc8f", "patch": "@@ -20,9 +20,13 @@ name = \"rustfmt\"\n [[bin]]\n name = \"cargo-fmt\"\n \n+[[bin]]\n+name = \"rustfmt-format-diff\"\n+\n [features]\n-default = [\"cargo-fmt\"]\n+default = [\"cargo-fmt\", \"rustfmt-format-diff\"]\n cargo-fmt = []\n+rustfmt-format-diff = []\n \n [dependencies]\n toml = \"0.4\""}, {"sha": "f7f3c1d8f7ca46fab1accec7a67f08c95445cb65", "filename": "src/bin/rustfmt-format-diff.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/0e846998e66539147481882484f05c973a46bc8f/src%2Fbin%2Frustfmt-format-diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e846998e66539147481882484f05c973a46bc8f/src%2Fbin%2Frustfmt-format-diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt-format-diff.rs?ref=0e846998e66539147481882484f05c973a46bc8f", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Inspired by Clang's clang-format-diff:\n+//\n+// https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/clang-format-diff.py\n+\n+#![deny(warnings)]\n+\n+extern crate env_logger;\n+extern crate getopts;\n+#[macro_use]\n+extern crate log;\n+extern crate regex;\n+extern crate serde;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde_json as json;\n+\n+use std::{env, fmt, process};\n+use std::collections::HashSet;\n+use std::error::Error;\n+use std::io::{self, BufRead};\n+\n+use regex::Regex;\n+\n+/// The default pattern of files to format.\n+///\n+/// We only want to format rust files by default.\n+const DEFAULT_PATTERN: &'static str = r\".*\\.rs\";\n+\n+#[derive(Debug)]\n+enum FormatDiffError {\n+    IncorrectOptions(getopts::Fail),\n+    IncorrectFilter(regex::Error),\n+    IoError(io::Error),\n+}\n+\n+impl fmt::Display for FormatDiffError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Display::fmt(self.cause().unwrap(), f)\n+    }\n+}\n+\n+impl Error for FormatDiffError {\n+    fn description(&self) -> &str {\n+        self.cause().unwrap().description()\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        Some(match *self {\n+            FormatDiffError::IoError(ref e) => e,\n+            FormatDiffError::IncorrectFilter(ref e) => e,\n+            FormatDiffError::IncorrectOptions(ref e) => e,\n+        })\n+    }\n+}\n+\n+impl From<getopts::Fail> for FormatDiffError {\n+    fn from(fail: getopts::Fail) -> Self {\n+        FormatDiffError::IncorrectOptions(fail)\n+    }\n+}\n+\n+impl From<regex::Error> for FormatDiffError {\n+    fn from(err: regex::Error) -> Self {\n+        FormatDiffError::IncorrectFilter(err)\n+    }\n+}\n+\n+impl From<io::Error> for FormatDiffError {\n+    fn from(fail: io::Error) -> Self {\n+        FormatDiffError::IoError(fail)\n+    }\n+}\n+\n+fn main() {\n+    let _ = env_logger::init();\n+\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optopt(\n+        \"p\",\n+        \"skip-prefix\",\n+        \"skip the smallest prefix containing NUMBER slashes\",\n+        \"NUMBER\",\n+    );\n+    opts.optopt(\n+        \"f\",\n+        \"filter\",\n+        \"custom pattern selecting file paths to reformat\",\n+        \"PATTERN\",\n+    );\n+\n+    if let Err(e) = run(&opts) {\n+        println!(\"{}\", opts.usage(e.description()));\n+        process::exit(1);\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]\n+struct Range {\n+    file: String,\n+    range: [u32; 2],\n+}\n+\n+fn run(opts: &getopts::Options) -> Result<(), FormatDiffError> {\n+    let matches = opts.parse(env::args().skip(1))?;\n+\n+    if matches.opt_present(\"h\") {\n+        println!(\"{}\", opts.usage(\"usage: \"));\n+        return Ok(());\n+    }\n+\n+    let filter = matches\n+        .opt_str(\"f\")\n+        .unwrap_or_else(|| DEFAULT_PATTERN.into());\n+\n+    let skip_prefix = matches\n+        .opt_str(\"p\")\n+        .and_then(|p| p.parse::<u32>().ok())\n+        .unwrap_or(0);\n+\n+    let (files, ranges) = scan_diff(io::stdin(), skip_prefix, &filter)?;\n+\n+    run_rustfmt(&files, &ranges)\n+}\n+\n+fn run_rustfmt(files: &HashSet<String>, ranges: &[Range]) -> Result<(), FormatDiffError> {\n+    if files.is_empty() || ranges.is_empty() {\n+        debug!(\"No files to format found\");\n+        return Ok(());\n+    }\n+\n+    let ranges_as_json = json::to_string(ranges).unwrap();\n+\n+    debug!(\"Files: {:?}\", files);\n+    debug!(\"Ranges: {:?}\", ranges);\n+\n+    let exit_status = process::Command::new(\"rustfmt\")\n+        .args(files)\n+        .arg(\"--file-lines\")\n+        .arg(ranges_as_json)\n+        .status()?;\n+\n+    if !exit_status.success() {\n+        return Err(FormatDiffError::IoError(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"rustfmt failed with {}\", exit_status),\n+        )));\n+    }\n+    Ok(())\n+}\n+\n+/// Scans a diff from `from`, and returns the set of files found, and the ranges\n+/// in those files.\n+fn scan_diff<R>(\n+    from: R,\n+    skip_prefix: u32,\n+    file_filter: &str,\n+) -> Result<(HashSet<String>, Vec<Range>), FormatDiffError>\n+where\n+    R: io::Read,\n+{\n+    let diff_pattern = format!(r\"^\\+\\+\\+\\s(?:.*?/){{{}}}(\\S*)\", skip_prefix);\n+    let diff_pattern = Regex::new(&diff_pattern).unwrap();\n+\n+    let lines_pattern = Regex::new(r\"^@@.*\\+(\\d+)(,(\\d+))?\").unwrap();\n+\n+    let file_filter = Regex::new(&format!(\"^{}$\", file_filter))?;\n+\n+    let mut current_file = None;\n+\n+    let mut files = HashSet::new();\n+    let mut ranges = vec![];\n+    for line in io::BufReader::new(from).lines() {\n+        let line = line.unwrap();\n+\n+        if let Some(captures) = diff_pattern.captures(&line) {\n+            current_file = Some(captures.get(1).unwrap().as_str().to_owned());\n+        }\n+\n+        let file = match current_file {\n+            Some(ref f) => &**f,\n+            None => continue,\n+        };\n+\n+        // TODO(emilio): We could avoid this most of the time if needed, but\n+        // it's not clear it's worth it.\n+        if !file_filter.is_match(file) {\n+            continue;\n+        }\n+\n+        let lines_captures = match lines_pattern.captures(&line) {\n+            Some(captures) => captures,\n+            None => continue,\n+        };\n+\n+        let start_line = lines_captures\n+            .get(1)\n+            .unwrap()\n+            .as_str()\n+            .parse::<u32>()\n+            .unwrap();\n+        let line_count = match lines_captures.get(3) {\n+            Some(line_count) => line_count.as_str().parse::<u32>().unwrap(),\n+            None => 1,\n+        };\n+\n+        if line_count == 0 {\n+            continue;\n+        }\n+\n+        let end_line = start_line + line_count - 1;\n+        files.insert(file.to_owned());\n+        ranges.push(Range {\n+            file: file.to_owned(),\n+            range: [start_line, end_line],\n+        });\n+    }\n+\n+    Ok((files, ranges))\n+}\n+\n+#[test]\n+fn scan_simple_git_diff() {\n+    const DIFF: &'static str = include_str!(\"test/bindgen.diff\");\n+    let (files, ranges) = scan_diff(DIFF.as_bytes(), 1, r\".*\\.rs\").expect(\"scan_diff failed?\");\n+\n+    assert!(\n+        files.contains(\"src/ir/traversal.rs\"),\n+        \"Should've matched the filter\"\n+    );\n+\n+    assert!(\n+        !files.contains(\"tests/headers/anon_enum.hpp\"),\n+        \"Shouldn't have matched the filter\"\n+    );\n+\n+    assert_eq!(\n+        &ranges,\n+        &[\n+            Range {\n+                file: \"src/ir/item.rs\".into(),\n+                range: [148, 158],\n+            },\n+            Range {\n+                file: \"src/ir/item.rs\".into(),\n+                range: [160, 170],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".into(),\n+                range: [9, 16],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".into(),\n+                range: [35, 43],\n+            }\n+        ]\n+    );\n+}"}, {"sha": "d2fd379f471654699ec84c3f7ce628243023f1b9", "filename": "src/bin/test/bindgen.diff", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0e846998e66539147481882484f05c973a46bc8f/src%2Fbin%2Ftest%2Fbindgen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e846998e66539147481882484f05c973a46bc8f/src%2Fbin%2Ftest%2Fbindgen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Ftest%2Fbindgen.diff?ref=0e846998e66539147481882484f05c973a46bc8f", "patch": "@@ -0,0 +1,67 @@\n+diff --git a/src/ir/item.rs b/src/ir/item.rs\n+index 7f3afefb..90d15e96 100644\n+--- a/src/ir/item.rs\n++++ b/src/ir/item.rs\n+@@ -148,7 +148,11 @@ impl<'a, 'b> Iterator for ItemAncestorsIter<'a, 'b>\n+ impl AsTemplateParam for ItemId {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         ctx.resolve_item(*self).as_template_param(ctx, &())\n+     }\n+ }\n+@@ -156,7 +160,11 @@ impl AsTemplateParam for ItemId {\n+ impl AsTemplateParam for Item {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         self.kind.as_template_param(ctx, self)\n+     }\n+ }\n+diff --git a/src/ir/traversal.rs b/src/ir/traversal.rs\n+index 762a3e2d..b9c9dd4e 100644\n+--- a/src/ir/traversal.rs\n++++ b/src/ir/traversal.rs\n+@@ -9,6 +9,8 @@ use std::collections::{BTreeMap, VecDeque};\n+ ///\n+ ///   from --> to\n+ ///\n++/// Random content to generate a diff.\n++///\n+ /// The `from` is left implicit: it is the concrete `Trace` implementer which\n+ /// yielded this outgoing edge.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+@@ -33,7 +35,9 @@ impl Into<ItemId> for Edge {\n+     }\n+ }\n+ \n+-/// The kind of edge reference. This is useful when we wish to only consider\n++/// The kind of edge reference.\n++///\n++/// This is useful when we wish to only consider\n+ /// certain kinds of edges for a particular traversal or analysis.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+ pub enum EdgeKind {\n+diff --git a/tests/headers/anon_enum.hpp b/tests/headers/anon_enum.hpp\n+index 1961fe6c..34759df3 100644\n+--- a/tests/headers/anon_enum.hpp\n++++ b/tests/headers/anon_enum.hpp\n+@@ -1,7 +1,7 @@\n+ struct Test {\n+   int foo;\n+   float bar;\n+-  enum { T_NONE };\n++  enum { T_NONE, T_SOME };\n+ };\n+ \n+ typedef enum {"}]}