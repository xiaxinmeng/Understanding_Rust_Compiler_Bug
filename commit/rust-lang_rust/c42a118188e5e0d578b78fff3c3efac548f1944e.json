{"sha": "c42a118188e5e0d578b78fff3c3efac548f1944e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MmExMTgxODhlNWUwZDU3OGI3OGZmZjNjM2VmYWM1NDhmMTk0NGU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-17T15:19:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-28T02:18:32Z"}, "message": "MIR: split Operand::Consume into Copy and Move.", "tree": {"sha": "da1bfb72411c6548c2422f25aa3bdced0aa0bb99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da1bfb72411c6548c2422f25aa3bdced0aa0bb99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c42a118188e5e0d578b78fff3c3efac548f1944e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c42a118188e5e0d578b78fff3c3efac548f1944e", "html_url": "https://github.com/rust-lang/rust/commit/c42a118188e5e0d578b78fff3c3efac548f1944e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c42a118188e5e0d578b78fff3c3efac548f1944e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f5bab33fa890d265dec99d7c465ad9871ffe7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f5bab33fa890d265dec99d7c465ad9871ffe7d", "html_url": "https://github.com/rust-lang/rust/commit/73f5bab33fa890d265dec99d7c465ad9871ffe7d"}], "stats": {"total": 489, "additions": 251, "deletions": 238}, "files": [{"sha": "e40d07d936bbcba40bd84b5a98b6e5927baae3c0", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -420,7 +420,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            mir::Operand::Consume(ref lvalue) => {\n+            mir::Operand::Copy(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Operand::Move(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n             mir::Operand::Constant(ref constant) => {"}, {"sha": "d5df90a5ea02c5849c37ccaf098e679906b9092e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -1283,7 +1283,17 @@ pub struct VisibilityScopeData {\n /// being nested in one another.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n-    Consume(Lvalue<'tcx>),\n+    /// Copy: The value must be available for use afterwards.\n+    ///\n+    /// This implies that the type of the lvalue must be `Copy`; this is true\n+    /// by construction during build, but also checked by the MIR type checker.\n+    Copy(Lvalue<'tcx>),\n+    /// Move: The value (including old borrows of it) will not be used again.\n+    ///\n+    /// Safe for values of all types (modulo future developments towards `?Move`).\n+    /// Correct usage patterns are enforced by the borrow checker for safe code.\n+    /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n+    Move(Lvalue<'tcx>),\n     Constant(Box<Constant<'tcx>>),\n }\n \n@@ -1292,7 +1302,8 @@ impl<'tcx> Debug for Operand<'tcx> {\n         use self::Operand::*;\n         match *self {\n             Constant(ref a) => write!(fmt, \"{:?}\", a),\n-            Consume(ref lv) => write!(fmt, \"{:?}\", lv),\n+            Copy(ref lv) => write!(fmt, \"{:?}\", lv),\n+            Move(ref lv) => write!(fmt, \"move {:?}\", lv),\n         }\n     }\n }\n@@ -2089,14 +2100,16 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            Operand::Consume(ref lval) => Operand::Consume(lval.fold_with(folder)),\n+            Operand::Copy(ref lval) => Operand::Copy(lval.fold_with(folder)),\n+            Operand::Move(ref lval) => Operand::Move(lval.fold_with(folder)),\n             Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            Operand::Consume(ref lval) => lval.visit_with(visitor),\n+            Operand::Copy(ref lval) |\n+            Operand::Move(ref lval) => lval.visit_with(visitor),\n             Operand::Constant(ref c) => c.visit_with(visitor)\n         }\n     }"}, {"sha": "073f4cafc9dc6883bd5969237e0c1b0303e2d37a", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -230,7 +230,8 @@ impl<'tcx> Operand<'tcx> {\n         where D: HasLocalDecls<'tcx>\n     {\n         match self {\n-            &Operand::Consume(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n+            &Operand::Copy(ref l) |\n+            &Operand::Move(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n             &Operand::Constant(ref c) => c.ty,\n         }\n     }"}, {"sha": "b9db7d236c0d21c8e0d510002839dbd67362d261", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -611,8 +611,11 @@ macro_rules! make_mir_visitor {\n                              operand: & $($mutability)* Operand<'tcx>,\n                              location: Location) {\n                 match *operand {\n-                    Operand::Consume(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Consume, location);\n+                    Operand::Copy(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::Copy, location);\n+                    }\n+                    Operand::Move(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::Move, location);\n                     }\n                     Operand::Constant(ref $($mutability)* constant) => {\n                         self.visit_constant(constant, location);\n@@ -679,7 +682,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n                     ProjectionElem::Index(ref $($mutability)* local) => {\n-                        self.visit_local(local, LvalueContext::Consume, location);\n+                        self.visit_local(local, LvalueContext::Copy, location);\n                     }\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n@@ -860,7 +863,8 @@ pub enum LvalueContext<'tcx> {\n     Projection(Mutability),\n \n     // Consumed as part of an operand\n-    Consume,\n+    Copy,\n+    Move,\n \n     // Starting and ending a storage live range\n     StorageLive,\n@@ -913,7 +917,8 @@ impl<'tcx> LvalueContext<'tcx> {\n             LvalueContext::Inspect |\n             LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n             LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n+            LvalueContext::Projection(Mutability::Not) |\n+            LvalueContext::Copy | LvalueContext::Move |\n             LvalueContext::StorageLive | LvalueContext::StorageDead |\n             LvalueContext::Validate => false,\n         }\n@@ -924,7 +929,8 @@ impl<'tcx> LvalueContext<'tcx> {\n         match *self {\n             LvalueContext::Inspect | LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n             LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n+            LvalueContext::Projection(Mutability::Not) |\n+            LvalueContext::Copy | LvalueContext::Move => true,\n             LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n             LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n             LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead |"}, {"sha": "19d121843cbfae2145a54f849ed9cf1beb1e2cc8", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 56, "deletions": 92, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n use rustc_data_structures::indexed_vec::{Idx};\n \n use syntax::ast::{self};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n@@ -38,7 +38,6 @@ use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult, M\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n use self::MutateMode::{JustWrite, WriteAndRead};\n-use self::ConsumeKind::{Consume};\n \n \n pub fn provide(providers: &mut Providers) {\n@@ -77,7 +76,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let id = tcx.hir.as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n-    let move_data: MoveData<'tcx> = match MoveData::gather_moves(input_mir, tcx, param_env) {\n+    let move_data: MoveData<'tcx> = match MoveData::gather_moves(input_mir, tcx) {\n         Ok(move_data) => move_data,\n         Err((move_data, move_errors)) => {\n             for move_error in move_errors {\n@@ -264,24 +263,27 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                    flow_state);\n             }\n             StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                let context = ContextKind::InlineAsm.new(location);\n                 for (o, output) in asm.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n-                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n-                                            Consume,\n-                                            (output, span),\n-                                            flow_state);\n+                        // FIXME(eddyb) indirect inline asm outputs should\n+                        // be encoeded through MIR lvalue derefs instead.\n+                        self.access_lvalue(context,\n+                                           (output, span),\n+                                           (Deep, Read(ReadKind::Copy)),\n+                                           flow_state);\n+                        self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                                    (output, span), flow_state);\n                     } else {\n-                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n+                        self.mutate_lvalue(context,\n                                            (output, span),\n                                            Deep,\n                                            if o.is_rw { WriteAndRead } else { JustWrite },\n                                            flow_state);\n                     }\n                 }\n                 for input in inputs {\n-                    self.consume_operand(ContextKind::InlineAsm.new(location),\n-                                         Consume,\n-                                         (input, span), flow_state);\n+                    self.consume_operand(context, (input, span), flow_state);\n                 }\n             }\n             StatementKind::EndRegion(ref _rgn) => {\n@@ -314,13 +316,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         match term.kind {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(ContextKind::SwitchInt.new(loc),\n-                                     Consume,\n                                      (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n-                self.consume_lvalue(ContextKind::Drop.new(loc),\n-                                    ConsumeKind::Drop,\n-                                    (drop_lvalue, span), flow_state);\n+                self.access_lvalue(ContextKind::Drop.new(loc),\n+                                   (drop_lvalue, span),\n+                                   (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                                   flow_state);\n             }\n             TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n                                              value: ref new_value,\n@@ -332,16 +334,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                    JustWrite,\n                                    flow_state);\n                 self.consume_operand(ContextKind::DropAndReplace.new(loc),\n-                                     ConsumeKind::Drop,\n                                      (new_value, span), flow_state);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 self.consume_operand(ContextKind::CallOperator.new(loc),\n-                                     Consume,\n                                      (func, span), flow_state);\n                 for arg in args {\n                     self.consume_operand(ContextKind::CallOperand.new(loc),\n-                                         Consume,\n                                          (arg, span), flow_state);\n                 }\n                 if let Some((ref dest, _/*bb*/)) = *destination {\n@@ -354,15 +353,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n                 self.consume_operand(ContextKind::Assert.new(loc),\n-                                     Consume,\n                                      (cond, span), flow_state);\n                 match *msg {\n                     AssertMessage::BoundsCheck { ref len, ref index } => {\n                         self.consume_operand(ContextKind::Assert.new(loc),\n-                                             Consume,\n                                              (len, span), flow_state);\n                         self.consume_operand(ContextKind::Assert.new(loc),\n-                                             Consume,\n                                              (index, span), flow_state);\n                     }\n                     AssertMessage::Math(_/*const_math_err*/) => {}\n@@ -373,7 +369,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n             TerminatorKind::Yield { ref value, resume: _, drop: _} => {\n                 self.consume_operand(ContextKind::Yield.new(loc),\n-                                     Consume, (value, span), flow_state);\n+                                     (value, span), flow_state);\n             }\n \n             TerminatorKind::Resume |\n@@ -422,9 +418,6 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum MutateMode { JustWrite, WriteAndRead }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ConsumeKind { Drop, Consume }\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum Control { Continue, Break }\n \n@@ -648,7 +641,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Rvalue::Repeat(ref operand, _) |\n             Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n             Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n-                self.consume_operand(context, Consume, (operand, span), flow_state)\n+                self.consume_operand(context, (operand, span), flow_state)\n             }\n \n             Rvalue::Len(ref lvalue) |\n@@ -666,8 +659,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n             Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, Consume, (operand1, span), flow_state);\n-                self.consume_operand(context, Consume, (operand2, span), flow_state);\n+                self.consume_operand(context, (operand1, span), flow_state);\n+                self.consume_operand(context, (operand2, span), flow_state);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n@@ -680,70 +673,41 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n                 for operand in operands {\n-                    self.consume_operand(context, Consume, (operand, span), flow_state);\n+                    self.consume_operand(context, (operand, span), flow_state);\n                 }\n             }\n         }\n     }\n \n     fn consume_operand(&mut self,\n                        context: Context,\n-                       consume_via_drop: ConsumeKind,\n                        (operand, span): (&Operand<'tcx>, Span),\n                        flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         match *operand {\n-            Operand::Consume(ref lvalue) => {\n-                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n-            }\n-            Operand::Constant(_) => {}\n-        }\n-    }\n-\n-    fn consume_lvalue(&mut self,\n-                      context: Context,\n-                      consume_via_drop: ConsumeKind,\n-                      lvalue_span: (&Lvalue<'tcx>, Span),\n-                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n-        let lvalue = lvalue_span.0;\n-\n-        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-        // Erase the regions in type before checking whether it moves by\n-        // default. There are a few reasons to do this:\n-        //\n-        // - They should not affect the result.\n-        // - It avoids adding new region constraints into the surrounding context,\n-        //   which would trigger an ICE, since the infcx will have been \"frozen\" by\n-        //   the NLL region context.\n-        let gcx = self.tcx.global_tcx();\n-        let erased_ty = gcx.lift(&self.tcx.erase_regions(&ty)).unwrap();\n-        let moves_by_default = erased_ty.moves_by_default(gcx, self.param_env, DUMMY_SP);\n-\n-        if moves_by_default {\n-            let kind = match consume_via_drop {\n-                ConsumeKind::Drop => WriteKind::StorageDeadOrDrop,\n-                _ => WriteKind::Move,\n-            };\n-\n-            // move of lvalue: check if this is move of already borrowed path\n-            self.access_lvalue(context, lvalue_span, (Deep, Write(kind)), flow_state);\n-        } else {\n-            // copy of lvalue: check if this is \"copy of frozen path\"\n-            // (FIXME: see check_loans.rs)\n-            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n-        }\n+            Operand::Copy(ref lvalue) => {\n+                // copy of lvalue: check if this is \"copy of frozen path\"\n+                // (FIXME: see check_loans.rs)\n+                self.access_lvalue(context,\n+                                   (lvalue, span),\n+                                   (Deep, Read(ReadKind::Copy)),\n+                                   flow_state);\n \n-        // Finally, check if path was already moved.\n-        match consume_via_drop {\n-            ConsumeKind::Drop => {\n-                // If path is merely being dropped, then we'll already\n-                // check the drop flag to see if it is moved (thus we\n-                // skip this check in that case).\n+                // Finally, check if path was already moved.\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                            (lvalue, span), flow_state);\n             }\n-            ConsumeKind::Consume => {\n+            Operand::Move(ref lvalue) => {\n+                // move of lvalue: check if this is move of already borrowed path\n+                self.access_lvalue(context,\n+                                   (lvalue, span),\n+                                   (Deep, Write(WriteKind::Move)),\n+                                   flow_state);\n+\n+                // Finally, check if path was already moved.\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n-                                            lvalue_span, flow_state);\n+                                            (lvalue, span), flow_state);\n             }\n+            Operand::Constant(_) => {}\n         }\n     }\n }\n@@ -1479,22 +1443,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return None;\n                         };\n \n-                        self.tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, lv) in freevars.iter().zip(lvs) {\n-                                    if let Operand::Consume(Lvalue::Local(l)) = *lv {\n-                                        if local == l {\n-                                            debug!(\n-                                                \"find_closure_span: found captured local {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n+                        self.tcx.with_freevars(node_id, |freevars| {\n+                            for (v, lv) in freevars.iter().zip(lvs) {\n+                                match *lv {\n+                                    Operand::Copy(Lvalue::Local(l)) |\n+                                    Operand::Move(Lvalue::Local(l)) if local == l => {\n+                                        debug!(\n+                                            \"find_closure_span: found captured local {:?}\",\n+                                            l\n+                                        );\n+                                        return Some(v.span);\n                                     }\n+                                    _ => {}\n                                 }\n-                                None\n-                            })\n-                            .map(|var_span| (args_span, var_span))\n+                            }\n+                            None\n+                        }).map(|var_span| (args_span, var_span))\n                     } else {\n                         None\n                     };"}, {"sha": "46c15ede4d923b1df09afeb54506dac90819537b", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -70,14 +70,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      &len, Rvalue::Len(slice.clone()));\n                 this.cfg.push_assign(block, source_info, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n-                                                           Operand::Consume(Lvalue::Local(idx)),\n-                                                           Operand::Consume(len.clone())));\n+                                                           Operand::Copy(Lvalue::Local(idx)),\n+                                                           Operand::Copy(len.clone())));\n \n                 let msg = AssertMessage::BoundsCheck {\n-                    len: Operand::Consume(len),\n-                    index: Operand::Consume(Lvalue::Local(idx))\n+                    len: Operand::Move(len),\n+                    index: Operand::Copy(Lvalue::Local(idx))\n                 };\n-                let success = this.assert(block, Operand::Consume(lt), true,\n+                let success = this.assert(block, Operand::Move(lt), true,\n                                           msg, expr_span);\n                 success.and(slice.index(idx))\n             }"}, {"sha": "b9d03cb2d4544c290a760ed293fb68c78a30396c", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Rvalue(..) => {\n                 let operand =\n                     unpack!(block = this.as_temp(block, scope, expr));\n-                block.and(Operand::Consume(Lvalue::Local(operand)))\n+                block.and(Operand::Move(Lvalue::Local(operand)))\n             }\n         }\n     }"}, {"sha": "b6f2477a930122a0ab7ac334f53804cdb2b77a21", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n                     let err = ConstMathErr::Overflow(Op::Neg);\n-                    block = this.assert(block, Operand::Consume(is_min), false,\n+                    block = this.assert(block, Operand::Move(is_min), false,\n                                         AssertMessage::Math(err), expr_span);\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n@@ -117,7 +117,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // initialize the box contents:\n                 unpack!(block = this.into(&Lvalue::Local(result).deref(), block, value));\n-                block.and(Rvalue::Use(Operand::Consume(Lvalue::Local(result))))\n+                block.and(Rvalue::Use(Operand::Move(Lvalue::Local(result))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .zip(field_types.into_iter())\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n-                            None => Operand::Consume(base.clone().field(n, ty))\n+                            None => this.consume_by_copy_or_move(base.clone().field(n, ty))\n                         })\n                         .collect()\n                 } else {\n@@ -325,10 +325,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            block = self.assert(block, Operand::Consume(of), false,\n+            block = self.assert(block, Operand::Move(of), false,\n                                 AssertMessage::Math(err), span);\n \n-            block.and(Rvalue::Use(Operand::Consume(val)))\n+            block.and(Rvalue::Use(Operand::Move(val)))\n         } else {\n             if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n                 // Checking division and remainder is more complex, since we 1. always check\n@@ -348,7 +348,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.push_assign(block, source_info, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n-                block = self.assert(block, Operand::Consume(is_zero), false,\n+                block = self.assert(block, Operand::Move(is_zero), false,\n                                     AssertMessage::Math(zero_err), span);\n \n                 // We only need to check for the overflow in one case:\n@@ -368,12 +368,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, lhs.clone(), min));\n \n-                    let is_neg_1 = Operand::Consume(is_neg_1);\n-                    let is_min = Operand::Consume(is_min);\n+                    let is_neg_1 = Operand::Move(is_neg_1);\n+                    let is_min = Operand::Move(is_min);\n                     self.cfg.push_assign(block, source_info, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n-                    block = self.assert(block, Operand::Consume(of), false,\n+                    block = self.assert(block, Operand::Move(of), false,\n                                         AssertMessage::Math(overflow_err), span);\n                 }\n             }"}, {"sha": "a292d8e54980b4c18d9e6e1d851f06ac5b7f8f98", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match Category::of(&expr.kind).unwrap() {\n             Category::Lvalue => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n-                let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(lvalue));\n                 this.cfg.push_assign(block, source_info, &Lvalue::Local(temp), rvalue);\n             }\n             _ => {"}, {"sha": "1878258f90846ff52a81728ae0bdd4cf4ee3c230", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n                 let result = unpack!(block = this.build_binary_op(block, op, expr_span, lhs_ty,\n-                                                  Operand::Consume(lhs.clone()), rhs));\n+                                                  Operand::Copy(lhs.clone()), rhs));\n                 this.cfg.push_assign(block, source_info, &lhs, result);\n \n                 block.unit()"}, {"sha": "fb6458aa115da7df150404373f15f6735f5e3d68", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -773,7 +773,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.schedule_drop_for_binding(binding.var_id, binding.span);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue =>\n-                    Rvalue::Use(Operand::Consume(binding.source)),\n+                    Rvalue::Use(self.consume_by_copy_or_move(binding.source)),\n                 BindingMode::ByRef(region, borrow_kind) =>\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };"}, {"sha": "b3a46508cf0b232bc641c20806085c4f534ab651", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      Rvalue::Discriminant(lvalue.clone()));\n                 assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n-                    discr: Operand::Consume(discr),\n+                    discr: Operand::Move(discr),\n                     switch_ty: discr_ty,\n                     values: From::from(values),\n                     targets,\n@@ -233,7 +233,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n-                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n+                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(lvalue.clone()),\n                                               true_bb, false_bb))\n                 } else {\n                     // The switch may be inexhaustive so we\n@@ -248,7 +248,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         v.val.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n-                        discr: Operand::Consume(lvalue.clone()),\n+                        discr: Operand::Copy(lvalue.clone()),\n                         switch_ty,\n                         values: From::from(values),\n                         targets,\n@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::Eq { value, mut ty } => {\n-                let mut val = Operand::Consume(lvalue.clone());\n+                let mut val = Operand::Copy(lvalue.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n@@ -273,7 +273,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             let val_slice = self.temp(ty, test.span);\n                             self.cfg.push_assign(block, source_info, &val_slice,\n                                                  Rvalue::Cast(CastKind::Unsize, val, ty));\n-                            val = Operand::Consume(val_slice);\n+                            val = Operand::Move(val_slice);\n                         }\n                     }\n \n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let slice = self.temp(ty, test.span);\n                     self.cfg.push_assign(block, source_info, &slice,\n                                          Rvalue::Cast(CastKind::Unsize, array, ty));\n-                    Operand::Consume(slice)\n+                    Operand::Move(slice)\n                 } else {\n                     self.literal_operand(test.span, ty, Literal::Value {\n                         value\n@@ -322,7 +322,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let block = self.cfg.start_new_block();\n                     self.cfg.terminate(eq_block, source_info,\n                                        TerminatorKind::if_(self.hir.tcx(),\n-                                                           Operand::Consume(eq_result),\n+                                                           Operand::Move(eq_result),\n                                                            block, fail));\n                     vec![block, fail]\n                 } else {\n@@ -335,7 +335,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, ty.clone(), lo.clone());\n                 let hi = self.literal_operand(test.span, ty.clone(), hi.clone());\n-                let val = Operand::Consume(lvalue.clone());\n+                let val = Operand::Copy(lvalue.clone());\n \n                 let fail = self.cfg.start_new_block();\n                 let block = self.compare(block, fail, test.span, BinOp::Le, lo, val.clone());\n@@ -362,14 +362,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // result = actual == expected OR result = actual < expected\n                 self.cfg.push_assign(block, source_info, &result,\n                                      Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(actual),\n-                                                      Operand::Consume(expected)));\n+                                                      Operand::Move(actual),\n+                                                      Operand::Move(expected)));\n \n                 // branch based on result\n                 let (false_bb, true_bb) = (self.cfg.start_new_block(),\n                                            self.cfg.start_new_block());\n                 self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::if_(self.hir.tcx(), Operand::Consume(result),\n+                                   TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n                                                        true_bb, false_bb));\n                 vec![true_bb, false_bb]\n             }\n@@ -394,7 +394,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n         self.cfg.terminate(block, source_info,\n-                           TerminatorKind::if_(self.hir.tcx(), Operand::Consume(result),\n+                           TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n                                                target_block, fail_block));\n         target_block\n     }"}, {"sha": "1b689aa2132b4ec9f5a4c17b0b600d43b324bfb6", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{self, Ty};\n \n use rustc::mir::*;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of\n@@ -133,4 +133,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             });\n         temp\n     }\n+\n+    pub fn consume_by_copy_or_move(&self, lvalue: Lvalue<'tcx>) -> Operand<'tcx> {\n+        let tcx = self.hir.tcx();\n+        let ty = lvalue.ty(&self.local_decls, tcx).to_ty(tcx);\n+        if self.hir.type_moves_by_default(ty, DUMMY_SP) {\n+            Operand::Move(lvalue)\n+        } else {\n+            Operand::Copy(lvalue)\n+        }\n+    }\n }"}, {"sha": "b8a9103c8167caf975f80f62cac741c75c9f8ce1", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -14,8 +14,6 @@ use rustc::mir::tcx::RvalueInitializationState;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n-use syntax::codemap::DUMMY_SP;\n-\n use std::collections::hash_map::Entry;\n use std::mem;\n \n@@ -28,24 +26,19 @@ use super::IllegalMoveOriginKind::*;\n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'gcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<MoveError<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>,\n-           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-           param_env: ty::ParamEnv<'gcx>)\n-           -> Self {\n+    fn new(mir: &'a Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n \n         MoveDataBuilder {\n             mir,\n             tcx,\n-            param_env,\n             errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n@@ -213,12 +206,10 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>,\n-                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                           param_env: ty::ParamEnv<'gcx>)\n+pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                                            -> Result<MoveData<'tcx>,\n                                                      (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n-    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n+    let mut builder = MoveDataBuilder::new(mir, tcx);\n \n     builder.gather_args();\n \n@@ -289,7 +280,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Lvalue::Local(local), true);\n+                self.gather_move(&Lvalue::Local(local));\n             }\n             StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span,\n@@ -348,7 +339,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Lvalue::Local(RETURN_POINTER), false);\n+                self.gather_move(&Lvalue::Local(RETURN_POINTER));\n             }\n \n             TerminatorKind::Assert { .. } |\n@@ -361,7 +352,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                self.gather_move(location, false);\n+                self.gather_move(location);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 self.create_move_path(location);\n@@ -383,25 +374,17 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n \n     fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n-            Operand::Constant(..) => {} // not-a-move\n-            Operand::Consume(ref lval) => { // a move\n-                self.gather_move(lval, false);\n+            Operand::Constant(..) |\n+            Operand::Copy(..) => {} // not-a-move\n+            Operand::Move(ref lval) => { // a move\n+                self.gather_move(lval);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, lval: &Lvalue<'tcx>, force: bool) {\n+    fn gather_move(&mut self, lval: &Lvalue<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n \n-        let tcx = self.builder.tcx;\n-        let gcx = tcx.global_tcx();\n-        let lv_ty = lval.ty(self.builder.mir, tcx).to_ty(tcx);\n-        let erased_ty = gcx.lift(&tcx.erase_regions(&lv_ty)).unwrap();\n-        if !force && !erased_ty.moves_by_default(gcx, self.builder.param_env, DUMMY_SP) {\n-            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", self.loc, lval, lv_ty);\n-            return\n-        }\n-\n         let path = match self.move_path_for(lval) {\n             Ok(path) | Err(MoveError::UnionMove { path }) => path,\n             Err(error @ MoveError::IllegalMove { .. }) => {"}, {"sha": "69877367c7688755ad6961c67e82ca27daebcfb0", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -293,10 +293,8 @@ impl<'tcx> MoveError<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'gcx>)\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                         -> Result<Self, (Self, Vec<MoveError<'tcx>>)> {\n-        builder::gather_moves(mir, tcx, param_env)\n+        builder::gather_moves(mir, tcx)\n     }\n }"}, {"sha": "306b41714a553a1b5ae8eb04d26c22c6435f418b", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -252,6 +252,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn check_overflow(&self) -> bool {\n         self.check_overflow\n     }\n+\n+    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        self.infcx.type_moves_by_default(self.param_env, ty, span)\n+    }\n }\n \n fn lint_level_for_hir_id(tcx: TyCtxt, mut id: ast::NodeId) -> ast::NodeId {"}, {"sha": "119cd35910fd590272c312a8d666b9c703b6e7e9", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -385,7 +385,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 Lvalue::Local(RETURN_POINTER),\n-                Rvalue::Use(Operand::Consume(rcvr))\n+                Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `let loc = Clone::clone(ref_loc);`\n         self.block(vec![statement], TerminatorKind::Call {\n             func,\n-            args: vec![Operand::Consume(ref_loc)],\n+            args: vec![Operand::Move(ref_loc)],\n             destination: Some((loc.clone(), next)),\n             cleanup: Some(cleanup),\n         }, false);\n@@ -470,14 +470,14 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let compute_cond = self.make_statement(\n             StatementKind::Assign(\n                 cond.clone(),\n-                Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n+                Rvalue::BinaryOp(BinOp::Ne, Operand::Copy(end), Operand::Copy(beg))\n             )\n         );\n \n         // `if end != beg { goto loop_body; } else { goto loop_end; }`\n         self.block(\n             vec![compute_cond],\n-            TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n+            TerminatorKind::if_(tcx, Operand::Move(cond), loop_body, loop_end),\n             is_cleanup\n         );\n     }\n@@ -547,15 +547,15 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             self.make_statement(\n                 StatementKind::Assign(\n                     ret_field,\n-                    Rvalue::Use(Operand::Consume(cloned))\n+                    Rvalue::Use(Operand::Move(cloned))\n                 )\n             ),\n             self.make_statement(\n                 StatementKind::Assign(\n                     Lvalue::Local(beg),\n                     Rvalue::BinaryOp(\n                         BinOp::Add,\n-                        Operand::Consume(Lvalue::Local(beg)),\n+                        Operand::Copy(Lvalue::Local(beg)),\n                         Operand::Constant(self.make_usize(1))\n                     )\n                 )\n@@ -568,7 +568,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 Lvalue::Local(RETURN_POINTER),\n-                Rvalue::Use(Operand::Consume(ret.clone())),\n+                Rvalue::Use(Operand::Move(ret.clone())),\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n@@ -611,7 +611,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n                 Lvalue::Local(beg),\n                 Rvalue::BinaryOp(\n                     BinOp::Add,\n-                    Operand::Consume(Lvalue::Local(beg)),\n+                    Operand::Copy(Lvalue::Local(beg)),\n                     Operand::Constant(self.make_usize(1))\n                 )\n             )\n@@ -666,7 +666,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n                 Lvalue::Local(RETURN_POINTER),\n                 Rvalue::Aggregate(\n                     box kind,\n-                    returns.into_iter().map(Operand::Consume).collect()\n+                    returns.into_iter().map(Operand::Move).collect()\n                 )\n             )\n         );\n@@ -705,8 +705,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut statements = vec![];\n \n     let rcvr = match rcvr_adjustment {\n-        Adjustment::Identity => Operand::Consume(rcvr_l),\n-        Adjustment::Deref => Operand::Consume(rcvr_l.deref()),\n+        Adjustment::Identity => Operand::Move(rcvr_l),\n+        Adjustment::Deref => Operand::Copy(rcvr_l.deref()),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n             let ref_rcvr = local_decls.push(temp_decl(\n@@ -724,7 +724,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, rcvr_l)\n                 )\n             });\n-            Operand::Consume(Lvalue::Local(ref_rcvr))\n+            Operand::Move(Lvalue::Local(ref_rcvr))\n         }\n     };\n \n@@ -750,11 +750,11 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n             let arg_lv = Lvalue::Local(Local::new(1+1));\n-            Operand::Consume(arg_lv.field(Field::new(i), *ity))\n+            Operand::Move(arg_lv.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n-            Operand::Consume(Lvalue::Local(Local::new(1+i)))\n+            Operand::Move(Lvalue::Local(Local::new(1+i)))\n         }));\n     }\n \n@@ -868,7 +868,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                 Rvalue::Aggregate(\n                     box AggregateKind::Adt(adt_def, variant_no, substs, None),\n                     (1..sig.inputs().len()+1).map(|i| {\n-                        Operand::Consume(Lvalue::Local(Local::new(i)))\n+                        Operand::Move(Lvalue::Local(Local::new(i)))\n                     }).collect()\n                 )\n             )"}, {"sha": "2cb8cb60e07d716ed5bbc17026f1da3bd7396535", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -132,7 +132,7 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n     patch.add_statement(\n         loc, StatementKind::StorageLive(temp));\n     patch.add_assign(loc, Lvalue::Local(temp),\n-                     Rvalue::Use(Operand::Consume(location.clone())));\n+                     Rvalue::Use(Operand::Move(location.clone())));\n     patch.patch_terminator(loc.block, TerminatorKind::Drop {\n         location: Lvalue::Local(temp),\n         target: storage_dead_block,"}, {"sha": "6021955004e6407cf72b50bed822c94af1c95de4", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -260,7 +260,8 @@ impl MirPass for AddValidation {\n                                 .chain(\n                                     args.iter().filter_map(|op| {\n                                         match op {\n-                                            &Operand::Consume(ref lval) =>\n+                                            &Operand::Copy(ref lval) |\n+                                            &Operand::Move(ref lval) =>\n                                                 Some(lval_to_operand(lval.clone())),\n                                             &Operand::Constant(..) => { None },\n                                         }\n@@ -353,14 +354,17 @@ impl MirPass for AddValidation {\n                         block_data.statements.insert(i, release_stmt);\n                     }\n                     // Casts can change what validation does (e.g. unsizing)\n-                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Consume(_), _))\n+                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Copy(_), _)) |\n+                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Move(_), _))\n                         if kind != CastKind::Misc =>\n                     {\n                         // Due to a lack of NLL; we can't capture anything directly here.\n                         // Instead, we have to re-match and clone there.\n                         let (dest_lval, src_lval) = match block_data.statements[i].kind {\n                             StatementKind::Assign(ref dest_lval,\n-                                    Rvalue::Cast(_, Operand::Consume(ref src_lval), _)) =>\n+                                    Rvalue::Cast(_, Operand::Copy(ref src_lval), _)) |\n+                            StatementKind::Assign(ref dest_lval,\n+                                    Rvalue::Cast(_, Operand::Move(ref src_lval), _)) =>\n                             {\n                                 (dest_lval.clone(), src_lval.clone())\n                             },"}, {"sha": "30048639589ffaa11c6814e6827de838a5e84066", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -126,7 +126,8 @@ impl MirPass for CopyPropagation {\n                         StatementKind::Assign(Lvalue::Local(local), Rvalue::Use(ref operand)) if\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n-                                Operand::Consume(ref src_lvalue) => {\n+                                Operand::Copy(ref src_lvalue) |\n+                                Operand::Move(ref src_lvalue) => {\n                                     Action::local_copy(&mir, &def_use_analysis, src_lvalue)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n@@ -173,7 +174,11 @@ fn eliminate_self_assignments<'tcx>(\n                 match stmt.kind {\n                     StatementKind::Assign(\n                         Lvalue::Local(local),\n-                        Rvalue::Use(Operand::Consume(Lvalue::Local(src_local))),\n+                        Rvalue::Use(Operand::Copy(Lvalue::Local(src_local))),\n+                    ) |\n+                    StatementKind::Assign(\n+                        Lvalue::Local(local),\n+                        Rvalue::Use(Operand::Move(Lvalue::Local(src_local))),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;\n@@ -351,7 +356,8 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Consume(Lvalue::Local(local)) if local == self.dest_local => {}\n+            Operand::Copy(Lvalue::Local(local)) |\n+            Operand::Move(Lvalue::Local(local)) if local == self.dest_local => {}\n             _ => return,\n         }\n "}, {"sha": "6f94bd1f88f14fb2dbad9c72b2b4ad8b1bcd1949", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -50,7 +50,7 @@ impl MirPass for ElaborateDrops {\n             _ => return\n         }\n         let param_env = tcx.param_env(src.def_id);\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n+        let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {\n@@ -278,7 +278,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>> {\n-        self.ctxt.drop_flag(path).map(Operand::Consume)\n+        self.ctxt.drop_flag(path).map(Operand::Copy)\n     }\n }\n "}, {"sha": "fe7ff326f497cc7a0cc1ea6d4f2eaae247b78c88", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         let ret_val = match data.terminator().kind {\n             TerminatorKind::Return => Some((1,\n                 None,\n-                Operand::Consume(Lvalue::Local(self.new_ret_local)),\n+                Operand::Move(Lvalue::Local(self.new_ret_local)),\n                 None)),\n             TerminatorKind::Yield { ref value, resume, drop } => Some((0,\n                 Some(resume),\n@@ -452,7 +452,7 @@ fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let default_block = insert_term_block(mir, default);\n \n     let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        discr: Operand::Copy(transform.make_field(transform.state_field, tcx.types.u32)),\n         switch_ty: tcx.types.u32,\n         values: Cow::from(cases.iter().map(|&(i, _)| ConstInt::U32(i)).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),"}, {"sha": "844459930b8d76198371264cdcb3b71112a4413a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     // needs to generate the cast.\n                     // FIXME: we should probably just generate correct MIR in the first place...\n \n-                    let arg = if let Operand::Consume(ref lval) = args[0] {\n+                    let arg = if let Operand::Move(ref lval) = args[0] {\n                         lval.clone()\n                     } else {\n                         bug!(\"Constant arg to \\\"box_free\\\"\");\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         };\n         let ptr_ty = self.tcx.mk_mut_ptr(pointee_ty);\n \n-        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Consume(ref_tmp), ptr_ty);\n+        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Move(ref_tmp), ptr_ty);\n \n         let cast_tmp = LocalDecl::new_temp(ptr_ty, callsite.location.span);\n         let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n                     // This is e.g. `tuple_tmp.0` in our example above.\n-                    let tuple_field = Operand::Consume(tuple.clone().field(Field::new(i), ty));\n+                    let tuple_field = Operand::Move(tuple.clone().field(Field::new(i), ty));\n \n                     // Spill to a local to make e.g. `tmp0`.\n                     self.create_temp_if_necessary(tuple_field, callsite, caller_mir)\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Consume(Lvalue::Local(local)) = arg {\n+        if let Operand::Move(Lvalue::Local(local)) = arg {\n             if caller_mir.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n                 return local;"}, {"sha": "b45db18eff5f08f3d09ac67ba5195512a0c47c94", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n                 }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n-            *rvalue = Rvalue::Use(Operand::Consume(new_lvalue))\n+            *rvalue = Rvalue::Use(Operand::Copy(new_lvalue))\n         }\n \n         if let Some(constant) = self.optimizations.arrays_lengths.remove(&location) {"}, {"sha": "26621afaba41f29d14b78efcff42fa884c9a91c6", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -105,7 +105,7 @@ impl Lower128Bit {\n                                 rhs,\n                                 rhs_override_ty.unwrap())),\n                     });\n-                    rhs = Operand::Consume(Lvalue::Local(local));\n+                    rhs = Operand::Move(Lvalue::Local(local));\n                 }\n \n                 let call_did = check_lang_item_type(\n@@ -237,4 +237,4 @@ fn item_for_checked_op(bin_op: BinOp, is_signed: bool) -> Option<(LangItem, RhsK\n         _ => bug!(\"That should be all the checked ones?\"),\n     };\n     Some(i)\n-}\n\\ No newline at end of file\n+}"}, {"sha": "555f0a327980e101e2af07af4075a943a5bdf87d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -519,7 +519,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         match *operand {\n-            Operand::Consume(ref lvalue) => {\n+            Operand::Copy(ref lvalue) |\n+            Operand::Move(ref lvalue) => {\n                 self.nest(|this| {\n                     this.super_operand(operand, location);\n                     this.try_consume();\n@@ -872,10 +873,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                self.const_fn_arg_vars.insert(index.index()) {\n \n                 // Direct use of an argument is permitted.\n-                if let Rvalue::Use(Operand::Consume(Lvalue::Local(local))) = *rvalue {\n-                    if self.mir.local_kind(local) == LocalKind::Arg {\n-                        return;\n+                match *rvalue {\n+                    Rvalue::Use(Operand::Copy(Lvalue::Local(local))) |\n+                    Rvalue::Use(Operand::Move(Lvalue::Local(local))) => {\n+                        if self.mir.local_kind(local) == LocalKind::Arg {\n+                            return;\n+                        }\n                     }\n+                    _ => {}\n                 }\n \n                 // Avoid a generic error for other uses of arguments."}, {"sha": "cc8a6e66da1824fe1ecd403de75e2b2df3c1d00e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -45,7 +45,7 @@ impl MirPass for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n+        let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n@@ -124,7 +124,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     assert!(args.len() == 1);\n     let peek_arg_lval = match args[0] {\n-        mir::Operand::Consume(ref lval @ mir::Lvalue::Local(_)) => Some(lval),\n+        mir::Operand::Copy(ref lval @ mir::Lvalue::Local(_)) |\n+        mir::Operand::Move(ref lval @ mir::Lvalue::Local(_)) => Some(lval),\n         _ => None,\n     };\n "}, {"sha": "bb8dbd64c367ef9e121623ed18430c8102c6afc0", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -498,7 +498,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n-                    discr: Operand::Consume(discr),\n+                    discr: Operand::Move(discr),\n                     switch_ty: discr_ty,\n                     values: From::from(values.to_owned()),\n                     targets: blocks,\n@@ -536,7 +536,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n-                    args: vec![Operand::Consume(Lvalue::Local(ref_lvalue))],\n+                    args: vec![Operand::Move(Lvalue::Local(ref_lvalue))],\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                 },\n@@ -572,7 +572,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                  ptr_based: bool)\n                  -> BasicBlock\n     {\n-        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let copy = |lv: &Lvalue<'tcx>| Operand::Copy(lv.clone());\n+        let move_ = |lv: &Lvalue<'tcx>| Operand::Move(lv.clone());\n         let tcx = self.tcx();\n \n         let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n@@ -584,14 +585,14 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n-            (Rvalue::Use(use_(&Lvalue::Local(cur))),\n-             Rvalue::BinaryOp(BinOp::Offset, use_(&Lvalue::Local(cur)), one))\n+            (Rvalue::Use(copy(&Lvalue::Local(cur))),\n+             Rvalue::BinaryOp(BinOp::Offset, copy(&Lvalue::Local(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n                  BorrowKind::Mut,\n                  self.lvalue.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, use_(&Lvalue::Local(cur)), one))\n+             Rvalue::BinaryOp(BinOp::Add, copy(&Lvalue::Local(cur)), one))\n         };\n \n         let drop_block = BasicBlockData {\n@@ -611,13 +612,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let loop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     use_(&Lvalue::Local(cur)),\n-                                                     use_(length_or_end)))\n+                                                     copy(&Lvalue::Local(cur)),\n+                                                     copy(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n-                kind: TerminatorKind::if_(tcx, use_(can_go), succ, drop_block)\n+                kind: TerminatorKind::if_(tcx, move_(can_go), succ, drop_block)\n             })\n         };\n         let loop_block = self.elaborator.patch().new_block(loop_block);\n@@ -642,22 +643,22 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let tcx = self.tcx();\n \n-        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let move_ = |lv: &Lvalue<'tcx>| Operand::Move(lv.clone());\n         let size = &Lvalue::Local(self.new_temp(tcx.types.usize));\n         let size_is_zero = &Lvalue::Local(self.new_temp(tcx.types.bool));\n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n                 self.assign(size_is_zero, Rvalue::BinaryOp(BinOp::Eq,\n-                                                           use_(size),\n+                                                           move_(size),\n                                                            self.constant_usize(0)))\n             ],\n             is_cleanup: self.unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::if_(\n                     tcx,\n-                    use_(size_is_zero),\n+                    move_(size_is_zero),\n                     self.drop_loop_pair(ety, false),\n                     self.drop_loop_pair(ety, true)\n                 )\n@@ -718,11 +719,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone()\n             )));\n             drop_block_stmts.push(self.assign(&cur, Rvalue::Cast(\n-                CastKind::Misc, Operand::Consume(tmp.clone()), iter_ty\n+                CastKind::Misc, Operand::Move(tmp.clone()), iter_ty\n             )));\n             drop_block_stmts.push(self.assign(&length_or_end,\n                 Rvalue::BinaryOp(BinOp::Offset,\n-                     Operand::Consume(cur.clone()), Operand::Consume(length.clone())\n+                     Operand::Copy(cur.clone()), Operand::Move(length.clone())\n             )));\n         } else {\n             // index = 0 (length already pushed)\n@@ -854,7 +855,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let call = TerminatorKind::Call {\n             func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: vec![Operand::Consume(self.lvalue.clone())],\n+            args: vec![Operand::Move(self.lvalue.clone())],\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#6393)"}, {"sha": "9afd5a1483fbffe9055a92ec4b450c443d3bcb5e", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -273,7 +273,8 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n             LvalueContext::Borrow { .. } |\n \n             LvalueContext::Inspect |\n-            LvalueContext::Consume |\n+            LvalueContext::Copy |\n+            LvalueContext::Move |\n             LvalueContext::Validate => {\n                 if self.mode.include_regular_use {\n                     self.defs_uses.add_use(local);"}, {"sha": "6054d6c24101ac6216f0967ba35787d9c11ce095", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -181,7 +181,8 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                      location: Location) {\n         self.record(\"Operand\", operand);\n         self.record(match *operand {\n-            Operand::Consume(..) => \"Operand::Consume\",\n+            Operand::Copy(..) => \"Operand::Copy\",\n+            Operand::Move(..) => \"Operand::Move\",\n             Operand::Constant(..) => \"Operand::Constant\",\n         }, operand);\n         self.super_operand(operand, location);"}, {"sha": "77f607e55143541b938bdc5634a9b666e15feca8", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n-                if let mir::Operand::Consume(ref lvalue) = args[0] {\n+                if let mir::Operand::Move(ref lvalue) = args[0] {\n                     self.visit_lvalue(lvalue, LvalueContext::Drop, location);\n                 }\n             }\n@@ -140,7 +140,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n-            if let LvalueContext::Consume = context {\n+            let is_consume = match context {\n+                LvalueContext::Copy | LvalueContext::Move => true,\n+                _ => false\n+            };\n+            if is_consume {\n                 let base_ty = proj.base.ty(self.cx.mir, ccx.tcx());\n                 let base_ty = self.cx.monomorphize(&base_ty);\n \n@@ -154,18 +158,18 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n                     let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx()));\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n-                        // Recurse as a `Consume` instead of `Projection`,\n+                        // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n                         // which would trigger `mark_as_lvalue` on locals.\n-                        self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+                        self.visit_lvalue(&proj.base, context, location);\n                         return;\n                     }\n                 }\n             }\n \n             // A deref projection only reads the pointer, never needs the lvalue.\n             if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+                return self.visit_lvalue(&proj.base, LvalueContext::Copy, location);\n             }\n         }\n \n@@ -184,7 +188,8 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             LvalueContext::StorageLive |\n             LvalueContext::StorageDead |\n             LvalueContext::Validate |\n-            LvalueContext::Consume => {}\n+            LvalueContext::Copy |\n+            LvalueContext::Move => {}\n \n             LvalueContext::Inspect |\n             LvalueContext::Store |"}, {"sha": "61811a62c6630b58e6436493ac3fabb83b6eef9a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -517,7 +517,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // promotes any complex rvalues to constants.\n                         if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n                             match *arg {\n-                                mir::Operand::Consume(_) => {\n+                                mir::Operand::Copy(_) |\n+                                mir::Operand::Move(_) => {\n                                     span_bug!(span, \"shuffle indices must be constant\");\n                                 }\n                                 mir::Operand::Constant(ref constant) => {\n@@ -573,10 +574,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                     // The callee needs to own the argument memory if we pass it\n                     // by-ref, so make a local copy of non-immediate constants.\n-                    if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n-                        let tmp = LvalueRef::alloca(&bcx, op.layout, \"const\");\n-                        op.val.store(&bcx, tmp);\n-                        op.val = Ref(tmp.llval, tmp.alignment);\n+                    match (arg, op.val) {\n+                        (&mir::Operand::Copy(_), Ref(..)) |\n+                        (&mir::Operand::Constant(_), Ref(..)) => {\n+                            let tmp = LvalueRef::alloca(&bcx, op.layout, \"const\");\n+                            op.val.store(&bcx, tmp);\n+                            op.val = Ref(tmp.llval, tmp.alignment);\n+                        }\n+                        _ => {}\n                     }\n \n                     self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[i]);"}, {"sha": "e38af774a51ff782105bc74c63a430ababfae4a6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -505,7 +505,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         (Base::Value(llprojected), llextra)\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n+                        let index = &mir::Operand::Copy(mir::Lvalue::Local(index));\n                         let llindex = self.const_operand(index, span)?.llval;\n \n                         let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n@@ -540,7 +540,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                      -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         debug!(\"const_operand({:?} @ {:?})\", operand, span);\n         let result = match *operand {\n-            mir::Operand::Consume(ref lvalue) => {\n+            mir::Operand::Copy(ref lvalue) |\n+            mir::Operand::Move(ref lvalue) => {\n                 Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n             }\n "}, {"sha": "b7470e470bc14242475c8deac7f647f2b394ab19", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -487,7 +487,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         tr_base.project_field(bcx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n+                        let index = &mir::Operand::Copy(mir::Lvalue::Local(index));\n                         let index = self.trans_operand(bcx, index);\n                         let llindex = index.immediate();\n                         tr_base.project_index(bcx, llindex)"}, {"sha": "21770c1d792574717c8582f697f375ea664d51c0", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42a118188e5e0d578b78fff3c3efac548f1944e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=c42a118188e5e0d578b78fff3c3efac548f1944e", "patch": "@@ -308,7 +308,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_operand(operand={:?})\", operand);\n \n         match *operand {\n-            mir::Operand::Consume(ref lvalue) => {\n+            mir::Operand::Copy(ref lvalue) |\n+            mir::Operand::Move(ref lvalue) => {\n                 self.trans_consume(bcx, lvalue)\n             }\n "}]}