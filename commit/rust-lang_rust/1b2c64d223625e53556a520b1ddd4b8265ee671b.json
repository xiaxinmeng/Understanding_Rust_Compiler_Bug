{"sha": "1b2c64d223625e53556a520b1ddd4b8265ee671b", "node_id": "C_kwDOAAsO6NoAKDFiMmM2NGQyMjM2MjVlNTM1NTZhNTIwYjFkZGQ0YjgyNjVlZTY3MWI", "commit": {"author": {"name": "Lamb", "email": "lamb@ltow.me", "date": "2022-01-11T20:09:31Z"}, "committer": {"name": "Lamb", "email": "lamb@ltow.me", "date": "2022-01-14T02:59:16Z"}, "message": "fix: set struct/union/enum fields/variants as reachable when item is", "tree": {"sha": "6eb739d98e2305d9b9e529c1f67bd2a81b534149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb739d98e2305d9b9e529c1f67bd2a81b534149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b2c64d223625e53556a520b1ddd4b8265ee671b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2c64d223625e53556a520b1ddd4b8265ee671b", "html_url": "https://github.com/rust-lang/rust/commit/1b2c64d223625e53556a520b1ddd4b8265ee671b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b2c64d223625e53556a520b1ddd4b8265ee671b/comments", "author": null, "committer": null, "parents": [{"sha": "22e491ac7ed454d34669151a8b6464cb643c9b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e491ac7ed454d34669151a8b6464cb643c9b41", "html_url": "https://github.com/rust-lang/rust/commit/22e491ac7ed454d34669151a8b6464cb643c9b41"}], "stats": {"total": 111, "additions": 91, "deletions": 20}, "files": [{"sha": "e7741ccc4e42419e82bf2d6626c45a9088c7744b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 64, "deletions": 20, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1b2c64d223625e53556a520b1ddd4b8265ee671b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2c64d223625e53556a520b1ddd4b8265ee671b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=1b2c64d223625e53556a520b1ddd4b8265ee671b", "patch": "@@ -652,12 +652,73 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             _ => self.get(item.def_id),\n         };\n \n+        // Update levels of nested things.\n+        match item.kind {\n+            hir::ItemKind::Enum(ref def, _) => {\n+                for variant in def.variants {\n+                    let variant_level = self.update_with_hir_id(variant.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        self.update_with_hir_id(ctor_hir_id, item_level);\n+                    }\n+                    for field in variant.data.fields() {\n+                        self.update_with_hir_id(field.hir_id, variant_level);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Impl(ref impl_) => {\n+                for impl_item_ref in impl_.items {\n+                    if impl_.of_trait.is_some()\n+                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n+                    {\n+                        self.update(impl_item_ref.id.def_id, item_level);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n+                for trait_item_ref in trait_item_refs {\n+                    self.update(trait_item_ref.id.def_id, item_level);\n+                }\n+            }\n+            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n+                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n+                    self.update_with_hir_id(ctor_hir_id, item_level);\n+                }\n+                for field in def.fields() {\n+                    if field.vis.node.is_pub() {\n+                        self.update_with_hir_id(field.hir_id, item_level);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                self.update_reachability_from_macro(item.def_id, macro_def);\n+            }\n+            hir::ItemKind::ForeignMod { items, .. } => {\n+                for foreign_item in items {\n+                    if self.tcx.visibility(foreign_item.id.def_id) == ty::Visibility::Public {\n+                        self.update(foreign_item.id.def_id, item_level);\n+                    }\n+                }\n+            }\n+\n+            hir::ItemKind::OpaqueTy(..)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::GlobalAsm(..)\n+            | hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::TraitAlias(..)\n+            | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::ExternCrate(..) => {}\n+        }\n+\n         // Mark all items in interfaces of reachable items as reachable.\n         match item.kind {\n             // The interface is empty.\n-            hir::ItemKind::ExternCrate(..) => {}\n+            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n+            // Handled in the access level of in rustc_resolve\n             hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n@@ -709,14 +770,6 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                for impl_item_ref in impl_.items {\n-                    if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n-                    {\n-                        self.update(impl_item_ref.id.def_id, item_level);\n-                    }\n-                }\n-\n                 if item_level.is_some() {\n                     self.reach(item.def_id, item_level).generics().predicates().ty().trait_ref();\n \n@@ -731,21 +784,15 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n+\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.def_id, item_level).generics().predicates();\n                 }\n-\n-                let enum_level = self.get(item.def_id);\n                 for variant in def.variants {\n-                    let variant_level = self.update_with_hir_id(variant.id, enum_level);\n-\n+                    let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n                     if variant_level.is_some() {\n-                        if let Some(ctor_id) = variant.data.ctor_hir_id() {\n-                            self.update_with_hir_id(ctor_id, variant_level);\n-                        }\n-\n                         for field in variant.data.fields() {\n                             self.reach(self.tcx.hir().local_def_id(field.hir_id), variant_level)\n                                 .ty();\n@@ -756,9 +803,6 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Macro(ref macro_def) => {\n-                self.update_reachability_from_macro(item.def_id, macro_def);\n-            }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {"}, {"sha": "6f85273461af5417f12c15dbc5b36a49ccbe3723", "filename": "src/test/ui/privacy/auxiliary/issue-92755.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1b2c64d223625e53556a520b1ddd4b8265ee671b/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-92755.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2c64d223625e53556a520b1ddd4b8265ee671b/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-92755.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-92755.rs?ref=1b2c64d223625e53556a520b1ddd4b8265ee671b", "patch": "@@ -0,0 +1,17 @@\n+mod machine {\n+    pub struct A {\n+        pub b: B,\n+    }\n+    pub struct B {}\n+    impl B {\n+        pub fn f(&self) {}\n+    }\n+}\n+\n+pub struct Context {\n+    pub a: machine::A,\n+}\n+\n+pub fn ctx() -> Context {\n+    todo!();\n+}"}, {"sha": "49559152b6fd09b4777bbe561adfca0d55d8ff0f", "filename": "src/test/ui/privacy/issue-92755.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b2c64d223625e53556a520b1ddd4b8265ee671b/src%2Ftest%2Fui%2Fprivacy%2Fissue-92755.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2c64d223625e53556a520b1ddd4b8265ee671b/src%2Ftest%2Fui%2Fprivacy%2Fissue-92755.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-92755.rs?ref=1b2c64d223625e53556a520b1ddd4b8265ee671b", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:issue-92755.rs\n+// build-pass\n+\n+// Thank you @tmiasko for providing the content of this test!\n+\n+extern crate issue_92755;\n+\n+fn main() {\n+    issue_92755::ctx().a.b.f();\n+}"}]}