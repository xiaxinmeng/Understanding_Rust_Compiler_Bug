{"sha": "082ef52bcb15d779c6aff78d9860d328bf7df9b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmVmNTJiY2IxNWQ3NzljNmFmZjc4ZDk4NjBkMzI4YmY3ZGY5YjI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-07T12:44:54Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-12T14:01:19Z"}, "message": "Implement basic inherent method resolution", "tree": {"sha": "a4a123ad491e15c8d17bdc815675d43bb33811b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4a123ad491e15c8d17bdc815675d43bb33811b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082ef52bcb15d779c6aff78d9860d328bf7df9b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082ef52bcb15d779c6aff78d9860d328bf7df9b2", "html_url": "https://github.com/rust-lang/rust/commit/082ef52bcb15d779c6aff78d9860d328bf7df9b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082ef52bcb15d779c6aff78d9860d328bf7df9b2/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e397e705ad0bec9775067b10109e35ebefc493", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e397e705ad0bec9775067b10109e35ebefc493", "html_url": "https://github.com/rust-lang/rust/commit/e9e397e705ad0bec9775067b10109e35ebefc493"}], "stats": {"total": 326, "additions": 309, "deletions": 17}, "files": [{"sha": "9c28b62af3cef96bb705ccbd87a9cf9c160c0cdf", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -113,6 +113,11 @@ impl Module {\n         self.child_impl(db, name)\n     }\n \n+    /// Iterates over all child modules.\n+    pub fn children(&self, db: &impl HirDatabase) -> Cancelable<impl Iterator<Item = Module>> {\n+        self.children_impl(db)\n+    }\n+\n     /// Finds a parent module.\n     pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         self.parent_impl(db)\n@@ -270,6 +275,9 @@ pub struct FnSignature {\n     pub(crate) name: Name,\n     pub(crate) args: Vec<TypeRef>,\n     pub(crate) ret_type: TypeRef,\n+    /// True if the first arg is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub(crate) has_self_arg: bool,\n }\n \n impl FnSignature {\n@@ -284,6 +292,12 @@ impl FnSignature {\n     pub fn ret_type(&self) -> &TypeRef {\n         &self.ret_type\n     }\n+\n+    /// True if the first arg is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub fn has_self_arg(&self) -> bool {\n+        self.has_self_arg\n+    }\n }\n \n impl Function {"}, {"sha": "77dddff7986d66a92b9e4605333a8257d42060ed", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -43,6 +43,7 @@ impl FnSignature {\n             .map(|n| n.as_name())\n             .unwrap_or_else(Name::missing);\n         let mut args = Vec::new();\n+        let mut has_self_arg = false;\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.type_ref() {\n@@ -60,6 +61,7 @@ impl FnSignature {\n                     }\n                 };\n                 args.push(self_type);\n+                has_self_arg = true;\n             }\n             for param in param_list.params() {\n                 let type_ref = TypeRef::from_ast_opt(param.type_ref());\n@@ -75,6 +77,7 @@ impl FnSignature {\n             name,\n             args,\n             ret_type,\n+            has_self_arg,\n         };\n         Arc::new(sig)\n     }"}, {"sha": "775dd6709f9184774270cb3e381e369215ff460c", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -95,6 +95,21 @@ impl Module {\n         Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n     }\n \n+    /// Iterates over all child modules.\n+    pub fn children_impl(&self, db: &impl HirDatabase) -> Cancelable<impl Iterator<Item = Module>> {\n+        // FIXME this should be implementable without collecting into a vec, but\n+        // it's kind of hard since the iterator needs to keep a reference to the\n+        // module tree.\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let children = loc\n+            .module_id\n+            .children(&module_tree)\n+            .map(|(_, module_id)| Module::from_module_id(db, loc.source_root_id, module_id))\n+            .collect::<Cancelable<Vec<_>>>()?;\n+        Ok(children.into_iter())\n+    }\n+\n     pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;"}, {"sha": "842f54f110a74a3d03f1fb7973c33fc260fa5568", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -5,13 +5,13 @@ use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n     DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n-    SourceFileItems, SourceItemId,\n+    SourceFileItems, SourceItemId, Crate,\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::{ModuleId, ModuleTree},\n     nameres::{ItemMap, InputModuleItems},\n-    ty::{InferenceResult, Ty},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n };\n@@ -102,6 +102,11 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::impl_block::impls_in_module;\n     }\n \n+    fn impls_in_crate(krate: Crate) -> Cancelable<Arc<CrateImplBlocks>> {\n+        type ImplsInCrateQuery;\n+        use fn crate::ty::method_resolution::impls_in_crate;\n+    }\n+\n     fn body_hir(def_id: DefId) -> Cancelable<Arc<crate::expr::Body>> {\n         type BodyHirQuery;\n         use fn crate::expr::body_hir;"}, {"sha": "23c1d98d5c91921cbfea951386a4192029a3cbb6", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -33,20 +33,27 @@ impl ImplBlock {\n         })\n     }\n \n+    pub(crate) fn from_id(module_impl_blocks: Arc<ModuleImplBlocks>, impl_id: ImplId) -> ImplBlock {\n+        ImplBlock {\n+            module_impl_blocks,\n+            impl_id,\n+        }\n+    }\n+\n     fn impl_data(&self) -> &ImplData {\n         &self.module_impl_blocks.impls[self.impl_id]\n     }\n \n     pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.impl_data().target_trait.as_ref()\n+        self.impl_data().target_trait()\n     }\n \n     pub fn target_type(&self) -> &TypeRef {\n-        &self.impl_data().target_type\n+        self.impl_data().target_type()\n     }\n \n     pub fn items(&self) -> &[ImplItem] {\n-        &self.impl_data().items\n+        self.impl_data().items()\n     }\n }\n \n@@ -64,7 +71,7 @@ impl ImplData {\n         module: &Module,\n         node: &ast::ImplBlock,\n     ) -> Self {\n-        let target_trait = node.target_type().map(TypeRef::from_ast);\n+        let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n         let module_loc = module.def_id.loc(db);\n         let items = if let Some(item_list) = node.item_list() {\n@@ -103,6 +110,18 @@ impl ImplData {\n             items,\n         }\n     }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.target_type\n+    }\n+\n+    pub fn items(&self) -> &[ImplItem] {\n+        &self.items\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -133,11 +152,9 @@ impl_arena_id!(ImplId);\n /// This way, we avoid having to do this process for the whole crate whenever\n /// a file is changed; as long as the impl blocks in the file don't change,\n /// we don't need to do the second step again.\n-///\n-/// (The second step does not yet exist.)\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n-    impls: Arena<ImplId, ImplData>,\n+    pub(crate) impls: Arena<ImplId, ImplData>,\n     impls_by_def: FxHashMap<DefId, ImplId>,\n }\n \n@@ -153,7 +170,10 @@ impl ModuleImplBlocks {\n         let (file_id, module_source) = module.definition_source(db)?;\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n-            ModuleSource::Module(node) => node.syntax(),\n+            ModuleSource::Module(node) => match node.item_list() {\n+                Some(item_list) => item_list.syntax(),\n+                None => return Ok(()),\n+            },\n         };\n \n         let source_file_items = db.file_items(file_id.into());"}, {"sha": "9371c5a0dec3aedc02f501e6bb37d37238ea913a", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -235,6 +235,7 @@ salsa::database_storage! {\n             fn enum_data() for db::EnumDataQuery;\n             fn enum_variant_data() for db::EnumVariantDataQuery;\n             fn impls_in_module() for db::ImplsInModuleQuery;\n+            fn impls_in_crate() for db::ImplsInCrateQuery;\n             fn body_hir() for db::BodyHirQuery;\n             fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n             fn fn_signature() for db::FnSignatureQuery;"}, {"sha": "2dcba52831c05273a33615ed3bc6954d6e04fc39", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -17,6 +17,7 @@ mod autoderef;\n mod primitive;\n #[cfg(test)]\n mod tests;\n+pub(crate) mod method_resolution;\n \n use std::borrow::Cow;\n use std::ops::Index;\n@@ -891,14 +892,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                let _receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n-                // TODO resolve method...\n-                for (_i, arg) in args.iter().enumerate() {\n-                    // TODO unify / expect argument type\n-                    self.infer_expr(*arg, &Expectation::none())?;\n+            Expr::MethodCall {\n+                receiver,\n+                args,\n+                method_name,\n+            } => {\n+                let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n+                let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n+                let method_ty = match resolved {\n+                    Some(def_id) => self.db.type_for_def(def_id)?,\n+                    None => Ty::Unknown,\n+                };\n+                let method_ty = self.insert_type_vars(method_ty);\n+                let (expected_receiver_ty, arg_tys, ret_ty) = match &method_ty {\n+                    Ty::FnPtr(sig) => {\n+                        if sig.input.len() > 0 {\n+                            (&sig.input[0], &sig.input[1..], sig.output.clone())\n+                        } else {\n+                            (&Ty::Unknown, &[][..], sig.output.clone())\n+                        }\n+                    }\n+                    _ => (&Ty::Unknown, &[][..], Ty::Unknown),\n+                };\n+                // TODO we would have to apply the autoderef/autoref steps here\n+                // to get the correct receiver type to unify...\n+                self.unify(expected_receiver_ty, &receiver_ty);\n+                for (i, arg) in args.iter().enumerate() {\n+                    self.infer_expr(\n+                        *arg,\n+                        &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                    )?;\n                 }\n-                Ty::Unknown\n+                ret_ty\n             }\n             Expr::Match { expr, arms } => {\n                 let _ty = self.infer_expr(*expr, &Expectation::none())?;"}, {"sha": "ad80aa8b6ad6b69bba60287bf17a37006d067dba", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -0,0 +1,164 @@\n+//! This module is concerned with finding methods that a given type provides.\n+//! For details about how this works in rustc, see the method lookup page in the\n+//! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n+//! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_db::{Cancelable, SourceRootId};\n+\n+use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n+use super::Ty;\n+\n+/// This is used as a key for indexing impls.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum TyFingerprint {\n+    Adt(DefId),\n+    // we'll also want to index impls for primitive types etc.\n+}\n+\n+impl TyFingerprint {\n+    /// Creates a TyFingerprint for looking up an impl. Only certain types can\n+    /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n+    /// `impl &S`. Hence, this will return `None` for reference types and such.\n+    fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n+        match ty {\n+            Ty::Adt { def_id, .. } => Some(TyFingerprint::Adt(*def_id)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateImplBlocks {\n+    /// To make sense of the ModuleIds, we need the source root.\n+    source_root_id: SourceRootId,\n+    impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n+}\n+\n+impl CrateImplBlocks {\n+    pub fn lookup_impl_blocks<'a>(\n+        &'a self,\n+        db: &'a impl HirDatabase,\n+        ty: &Ty,\n+    ) -> impl Iterator<Item = Cancelable<ImplBlock>> + 'a {\n+        let fingerprint = TyFingerprint::for_impl(ty);\n+        fingerprint\n+            .and_then(|f| self.impls.get(&f))\n+            .into_iter()\n+            .flat_map(|i| i.iter())\n+            .map(move |(module_id, impl_id)| {\n+                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id)?;\n+                Ok(ImplBlock::from_id(module_impl_blocks, *impl_id))\n+            })\n+    }\n+\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+        let module_id = module.def_id.loc(db).module_id;\n+        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id)?;\n+\n+        for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n+            let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n+\n+            if let Some(_target_trait) = impl_data.target_trait() {\n+                // ignore for now\n+            } else {\n+                let target_ty =\n+                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type())?;\n+                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                    self.impls\n+                        .entry(target_ty_fp)\n+                        .or_insert_with(Vec::new)\n+                        .push((module_id, impl_id));\n+                }\n+            }\n+        }\n+\n+        for child in module.children(db)? {\n+            self.collect_recursive(db, child)?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub(crate) fn impls_in_crate(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+) -> Cancelable<Arc<CrateImplBlocks>> {\n+    let crate_graph = db.crate_graph();\n+    let file_id = crate_graph.crate_root(krate.crate_id);\n+    let source_root_id = db.file_source_root(file_id);\n+    let mut crate_impl_blocks = CrateImplBlocks {\n+        source_root_id,\n+        impls: FxHashMap::default(),\n+    };\n+    if let Some(module) = krate.root_module(db)? {\n+        crate_impl_blocks.collect_recursive(db, module)?;\n+    }\n+    Ok(Arc::new(crate_impl_blocks))\n+}\n+\n+fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Cancelable<Option<Crate>> {\n+    match ty {\n+        Ty::Adt { def_id, .. } => def_id.krate(db),\n+        _ => Ok(None),\n+    }\n+}\n+\n+impl Ty {\n+    // TODO: cache this as a query?\n+    // - if so, what signature? (TyFingerprint, Name)?\n+    // - or maybe cache all names and def_ids of methods per fingerprint?\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<DefId>> {\n+        self.iterate_methods(db, |f| {\n+            let sig = f.signature(db);\n+            if sig.name() == name && sig.has_self_arg() {\n+                Ok(Some(f.def_id()))\n+            } else {\n+                Ok(None)\n+            }\n+        })\n+    }\n+\n+    // This would be nicer if it just returned an iterator, but that's really\n+    // complicated with all the cancelable operations\n+    pub fn iterate_methods<T>(\n+        self,\n+        db: &impl HirDatabase,\n+        mut callback: impl FnMut(Function) -> Cancelable<Option<T>>,\n+    ) -> Cancelable<Option<T>> {\n+        // For method calls, rust first does any number of autoderef, and then one\n+        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+        // the autoref currently -- when we find a method matching the given name,\n+        // we assume it fits.\n+\n+        // Also note that when we've got a receiver like &S, even if the method we\n+        // find in the end takes &self, we still do the autoderef step (just as\n+        // rustc does an autoderef and then autoref again).\n+\n+        for derefed_ty in self.autoderef(db) {\n+            let krate = match def_crate(db, &derefed_ty)? {\n+                Some(krate) => krate,\n+                None => continue,\n+            };\n+            let impls = db.impls_in_crate(krate)?;\n+\n+            for impl_block in impls.lookup_impl_blocks(db, &derefed_ty) {\n+                let impl_block = impl_block?;\n+                for item in impl_block.items() {\n+                    match item {\n+                        ImplItem::Method(f) => {\n+                            if let Some(result) = callback(f.clone())? {\n+                                return Ok(Some(result));\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+        Ok(None)\n+    }\n+}"}, {"sha": "1c31294410dc9c73776ffaf3961059e949ca7ee8", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -242,6 +242,32 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_inherent_method() {\n+    check_inference(\n+        r#\"\n+struct A;\n+\n+impl A {\n+    fn foo(self, x: u32) -> i32 {}\n+}\n+\n+mod b {\n+    impl super::A {\n+        fn bar(&self, x: u64) -> i64 {}\n+    }\n+}\n+\n+fn test(a: A) {\n+    a.foo(1);\n+    (&a).bar(1);\n+    a.bar(1);\n+}\n+\"#,\n+        \"inherent_method.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "6e6f70357a7e49cbb832d8d9e70072cbd26007bf", "filename": "crates/ra_hir/src/ty/tests/data/inherent_method.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -0,0 +1,18 @@\n+[32; 36) 'self': A\n+[38; 39) 'x': u32\n+[53; 55) '{}': ()\n+[103; 107) 'self': &A\n+[109; 110) 'x': u64\n+[124; 126) '{}': ()\n+[144; 145) 'a': A\n+[150; 198) '{     ...(1); }': ()\n+[156; 157) 'a': A\n+[156; 164) 'a.foo(1)': i32\n+[162; 163) '1': u32\n+[170; 181) '(&a).bar(1)': i64\n+[171; 173) '&a': &A\n+[172; 173) 'a': A\n+[179; 180) '1': u64\n+[187; 188) 'a': A\n+[187; 195) 'a.bar(1)': i64\n+[193; 194) '1': u64"}, {"sha": "60f84675d4bc1c66bea4855c6508ac152d2113f5", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082ef52bcb15d779c6aff78d9860d328bf7df9b2/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=082ef52bcb15d779c6aff78d9860d328bf7df9b2", "patch": "@@ -124,6 +124,7 @@ salsa::database_storage! {\n             fn enum_data() for hir::db::EnumDataQuery;\n             fn enum_variant_data() for hir::db::EnumVariantDataQuery;\n             fn impls_in_module() for hir::db::ImplsInModuleQuery;\n+            fn impls_in_crate() for hir::db::ImplsInCrateQuery;\n             fn body_hir() for hir::db::BodyHirQuery;\n             fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n             fn fn_signature() for hir::db::FnSignatureQuery;"}]}