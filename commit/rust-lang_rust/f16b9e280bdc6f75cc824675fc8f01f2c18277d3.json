{"sha": "f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNmI5ZTI4MGJkYzZmNzVjYzgyNDY3NWZjOGYwMWYyYzE4Mjc3ZDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-28T11:08:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Move all intrinsics out of `interpret` and fail CTFE on intrinsic calls", "tree": {"sha": "c2b7893354788eb24122c2b5d579ddf97dbe882d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b7893354788eb24122c2b5d579ddf97dbe882d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19mEkg//d/UExI2MnbrkVdGnpDHjsu1z3uZYvToCuLuy7gQ17kulo8OKx5jGaKJd\nqzA+pvGT56yCyoyBRISdPfz6IX6HH/mZd2kQY9v7Vw2aXyld5oyvTMVE8gKaZ9Ek\nHF1kXB1k5nkeKNZbTjvZ34tjEx5vN+fXkf+QfSzTD8JtFQqFbtIIqieK4BbGXpuK\nyhhC+o+Frm/4vtrdRb1qYX46AUzX3TDUXwm2pOLVLCHMYGUNnpXIGFBAKDFxV+73\n2ng1Pau2FZS5e4Vt/AEj8bxRlsf0rFATxBmFp4Lg+Cj7sHwpuo5dfOj3bG2Hazwu\n9OV0mrs8Hs3hlq/cvjS4ymV+eJBFtgb8HGEb3QT+c548kpsA0htMLA8a8d+RNKyN\nuR2fqyguVvDlW2YZygI8/7Q7dYYNANL88q5wV2gkDBjbf5cMjXwQ+yBuEBuq20p7\nwrPoYqRxybYNTeBhW59kVlGN/pix8S+SqXBsMT38DX6kOMyed2mmqolZCW3aID+I\nJErdRwFEww26Bxgyf/aYIJ/jaXBoakHWflE5L09lHGUNZosKKw+FHjEbYHQaX+GI\ncpPnB77vYR7eH5TgUWllJEiRJAlqDh6zfOvdOyZ8DRYV+O9fZRYH2nTo8qnW4qIk\nQi313RHyeEpP4Cx0+kjMihwpT/PJSY3/oZJY7EDYg+QLzGlsr+0=\n=PQf0\n-----END PGP SIGNATURE-----", "payload": "tree c2b7893354788eb24122c2b5d579ddf97dbe882d\nparent 45b7cfdb6de4b5a4e4a48b782b1bbb5849f58e70\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501240107 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nMove all intrinsics out of `interpret` and fail CTFE on intrinsic calls\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "html_url": "https://github.com/rust-lang/rust/commit/f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b7cfdb6de4b5a4e4a48b782b1bbb5849f58e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b7cfdb6de4b5a4e4a48b782b1bbb5849f58e70", "html_url": "https://github.com/rust-lang/rust/commit/45b7cfdb6de4b5a4e4a48b782b1bbb5849f58e70"}], "stats": {"total": 207, "additions": 148, "deletions": 59}, "files": [{"sha": "add6558bcc4440180e72b3e96c9db34dcee99c29", "filename": "miri/helpers.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -0,0 +1,69 @@\n+use rustc_miri::interpret::{\n+    Pointer,\n+    EvalResult, EvalError,\n+    PrimVal,\n+    EvalContext,\n+};\n+\n+use rustc::ty::Ty;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer>;\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let offset = offset.overflowing_mul(pointee_size).0;\n+        ptr.wrapping_signed_offset(offset, self)\n+    }\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n+        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n+        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n+        // allocation.\n+\n+        if ptr.is_null()? { // NULL pointers must only be offset by 0\n+            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n+        }\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+            let ptr = ptr.signed_offset(offset, self)?;\n+            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n+            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n+                self.memory.check_bounds(ptr, false)?;\n+            } else if ptr.is_null()? {\n+                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n+                return Err(EvalError::InvalidNullPointerUsage);\n+            }\n+            Ok(ptr)\n+        } else {\n+            Err(EvalError::OverflowingMath)\n+        }\n+    }\n+}"}, {"sha": "73caf64dbde888cb1bd73e938ed00eca790b2898", "filename": "miri/intrinsic.rs", "status": "renamed", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -3,17 +3,30 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n-use interpret::{\n+use rustc_miri::interpret::{\n     EvalError, EvalResult,\n-    EvalContext,\n     Lvalue, LvalueExtra,\n     PrimVal, PrimValKind, Value, Pointer,\n     HasMemory,\n-    Machine,\n+    EvalContext,\n };\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(super) fn call_intrinsic(\n+use helpers::EvalContextExt as HelperEvalContextExt;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn call_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_layout: &'tcx Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -495,7 +508,7 @@ fn numeric_intrinsic<'tcx>(\n ) -> EvalResult<'tcx, PrimVal> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            use interpret::PrimValKind::*;\n+            use rustc_miri::interpret::PrimValKind::*;\n             let result_bytes = match kind {\n                 I8 => (bytes as i8).$method() as u128,\n                 U8 => (bytes as u8).$method() as u128,", "previous_filename": "src/librustc_mir/interpret/terminator/intrinsic.rs"}, {"sha": "c32c8105e333e2b2394a06cffc80f4d1b6533b0f", "filename": "miri/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -14,6 +14,7 @@ extern crate rustc_data_structures;\n extern crate syntax;\n \n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::Layout;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n@@ -29,9 +30,12 @@ pub use rustc_miri::interpret::*;\n \n mod fn_call;\n mod operator;\n+mod intrinsic;\n+mod helpers;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n+use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -287,6 +291,18 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx.eval_fn_call(instance, destination, arg_operands, span, sig)\n     }\n \n+    fn call_intrinsic<'a>(\n+        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: ty::Ty<'tcx>,\n+        dest_layout: &'tcx Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest, dest_ty, dest_layout, target)\n+    }\n+\n     fn ptr_op<'a>(\n         ecx: &rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n         bin_op: mir::BinOp,"}, {"sha": "a01ba25cd75ea89e6fef24f7a5a42d8689e8b352", "filename": "miri/operator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -3,6 +3,8 @@ use rustc::mir;\n \n use rustc_miri::interpret::*;\n \n+use helpers::EvalContextExt as HelperEvalContextExt;\n+\n pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,"}, {"sha": "604ef15e9045ac5dc4babb358a1318295db97b5e", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -1,5 +1,5 @@\n use rustc::traits::Reveal;\n-use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use rustc::ty::{self, TyCtxt, Ty, Instance, layout};\n use rustc::mir;\n \n use syntax::ast::Mutability;\n@@ -163,6 +163,18 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         Ok(false)\n     }\n \n+    fn call_intrinsic<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _dest: Lvalue<'tcx>,\n+        _dest_ty: Ty<'tcx>,\n+        _dest_layout: &'tcx layout::Layout,\n+        _target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        Err(ConstEvalError::NeedsRfc(\"calling intrinsics\".to_string()).into())\n+    }\n+\n     fn ptr_op<'a>(\n         _ecx: &EvalContext<'a, 'tcx, Self>,\n         _bin_op: mir::BinOp,"}, {"sha": "f5082a4d2d85d901ba5e70fb437b841dd95cfeba", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         false\n     }\n \n-    pub(crate) fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_cached(s.as_bytes())?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n@@ -369,11 +369,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n     }\n \n-    pub(super) fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n+    pub fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    pub(super) fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n+    pub fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n@@ -1022,39 +1022,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self)\n-    }\n-\n-    pub fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n-        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n-        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n-        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n-        // allocation.\n-\n-        if ptr.is_null()? { // NULL pointers must only be offset by 0\n-            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n-        }\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n-                self.memory.check_bounds(ptr, false)?;\n-            } else if ptr.is_null()? {\n-                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return Err(EvalError::InvalidNullPointerUsage);\n-            }\n-            Ok(ptr)\n-        } else {\n-            Err(EvalError::OverflowingMath)\n-        }\n-    }\n-\n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n@@ -1103,7 +1070,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub(super) fn force_allocation(\n+    pub fn force_allocation(\n         &mut self,\n         lvalue: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n@@ -1297,7 +1264,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub(super) fn write_value_to_ptr(\n+    pub fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n         dest: Pointer,\n@@ -1315,7 +1282,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn write_pair_to_ptr(\n+    pub fn write_pair_to_ptr(\n         &mut self,\n         a: PrimVal,\n         b: PrimVal,\n@@ -1445,7 +1412,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {"}, {"sha": "5c10d2c19528293edcd0715fd2c43635d0bb7081", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> Lvalue<'tcx> {\n         Self::from_primval_ptr(PrimVal::Undef.into())\n     }\n \n-    pub(crate) fn from_primval_ptr(ptr: Pointer) -> Self {\n+    pub fn from_primval_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n     }\n \n@@ -89,7 +89,7 @@ impl<'tcx> Lvalue<'tcx> {\n         }\n     }\n \n-    pub(super) fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         let (ptr, extra, _aligned) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the lvalue has been turned into a reference,\n         // and no matter where it came from, it now must be aligned."}, {"sha": "adb1054af1dbee598799283395d2732ab876b41b", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -36,6 +36,17 @@ pub trait Machine<'tcx>: Sized {\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n \n+    /// directly process an intrinsic without pushing a stack frame.\n+    fn call_intrinsic<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: ty::Ty<'tcx>,\n+        dest_layout: &'tcx ty::layout::Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+\n     /// Called when operating on the value of pointers.\n     ///\n     /// Returns `None` if the operation should be handled by the integer"}, {"sha": "e8701d1e64c85c4896471e18957ecae70c23a4ae", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -434,7 +434,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub(crate) fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n@@ -1311,7 +1311,7 @@ fn bit_index(bits: u64) -> (usize, usize) {\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub(crate) trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n+pub trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n     fn memory(&self) -> &Memory<'a, 'tcx, M>;\n "}, {"sha": "236e708d96fb8729b41ae604ed9dafb130c5a001", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -40,10 +40,10 @@ pub use self::memory::{\n     Memory,\n     MemoryPointer,\n     Kind,\n+    HasMemory,\n };\n \n use self::memory::{\n-    HasMemory,\n     PointerArithmetic,\n     LockInfo,\n     AccessKind,"}, {"sha": "010531d96cca006de9a5e6944b153b59b1394f95", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    pub(super) fn intrinsic_with_overflow(\n+    pub fn intrinsic_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n@@ -49,7 +49,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n     /// destination. Returns `true` if the operation overflowed.\n-    pub(super) fn intrinsic_overflowing(\n+    pub fn intrinsic_overflowing(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,"}, {"sha": "3ccc2ee0fb4a32a43310e89fd61f66be7c32729b", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -18,7 +18,6 @@ use super::eval_context::IntegerExt;\n use rustc_data_structures::indexed_vec::Idx;\n \n mod drop;\n-mod intrinsic;\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn goto_block(&mut self, target: mir::BasicBlock) {\n@@ -222,7 +221,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     return Err(EvalError::Unreachable);\n                 }\n                 let layout = self.type_layout(ty)?;\n-                self.call_intrinsic(instance, arg_operands, ret, ty, layout, target)?;\n+                M::call_intrinsic(self, instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n             },"}, {"sha": "c88d1c22dc9f365e6f7a1e20baf249542296f74d", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16b9e280bdc6f75cc824675fc8f01f2c18277d3/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=f16b9e280bdc6f75cc824675fc8f01f2c18277d3", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> Pointer {\n         self.primval\n     }\n \n-    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -88,7 +88,7 @@ impl<'tcx> Pointer {\n         }\n     }\n \n-    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -165,7 +165,7 @@ pub enum PrimValKind {\n \n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n-    pub(super) fn by_ref(ptr: Pointer) -> Self {\n+    pub fn by_ref(ptr: Pointer) -> Self {\n         Value::ByRef { ptr, aligned: true }\n     }\n "}]}