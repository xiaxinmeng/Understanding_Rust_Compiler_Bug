{"sha": "e033a231abf1b8933a51e4c93dc8aeb39b30020d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMzNhMjMxYWJmMWI4OTMzYTUxZTRjOTNkYzhhZWIzOWIzMDAyMGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-16T20:48:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-24T21:27:22Z"}, "message": "Change collect to implement `AstConv` on a `ItemCtxt` rather than a\nglobal context. Have this `ItemCtxt` carry a (currently unused) pointer\nto the in-scope generics.", "tree": {"sha": "50002d3af86909f3fd5d80abdcf140785c5b1fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50002d3af86909f3fd5d80abdcf140785c5b1fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e033a231abf1b8933a51e4c93dc8aeb39b30020d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e033a231abf1b8933a51e4c93dc8aeb39b30020d", "html_url": "https://github.com/rust-lang/rust/commit/e033a231abf1b8933a51e4c93dc8aeb39b30020d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e033a231abf1b8933a51e4c93dc8aeb39b30020d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bd15657d93c932611f3aee351b6521cdfa77731", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd15657d93c932611f3aee351b6521cdfa77731", "html_url": "https://github.com/rust-lang/rust/commit/0bd15657d93c932611f3aee351b6521cdfa77731"}], "stats": {"total": 305, "additions": 180, "deletions": 125}, "files": [{"sha": "3ca12959246d00d68a85fd842d964e7b2bfced58", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 180, "deletions": 125, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/e033a231abf1b8933a51e4c93dc8aeb39b30020d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e033a231abf1b8933a51e4c93dc8aeb39b30020d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e033a231abf1b8933a51e4c93dc8aeb39b30020d", "patch": "@@ -121,7 +121,7 @@ use syntax::visit;\n // Main entry point\n \n pub fn collect_item_types(tcx: &ty::ctxt) {\n-    let ccx = &CollectCtxt { tcx: tcx };\n+    let ccx = &CrateCtxt { tcx: tcx };\n \n     match ccx.tcx.lang_items.ty_desc() {\n         Some(id) => { collect_intrinsic_type(ccx, id); }\n@@ -141,17 +141,22 @@ pub fn collect_item_types(tcx: &ty::ctxt) {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-struct CollectCtxt<'a,'tcx:'a> {\n+struct CrateCtxt<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n+#[allow(dead_code)] // just temporary, for generics\n+struct ItemCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    generics: &'a ty::Generics<'tcx>,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Zeroth phase: collect types of intrinsics\n \n-fn collect_intrinsic_type(ccx: &CollectCtxt,\n+fn collect_intrinsic_type(ccx: &CrateCtxt,\n                           lang_item: ast::DefId) {\n-    let ty::TypeScheme { ty, .. } =\n-        ccx.get_item_type_scheme(lang_item);\n+    let ty::TypeScheme { ty, .. } = type_scheme_of_def_id(ccx, lang_item);\n     ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n }\n \n@@ -161,7 +166,7 @@ fn collect_intrinsic_type(ccx: &CollectCtxt,\n // know later when parsing field defs.\n \n struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CollectCtxt<'a, 'tcx>\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n@@ -182,7 +187,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n // Second phase: collection proper.\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CollectCtxt<'a, 'tcx>\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n@@ -199,42 +204,41 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n+impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n+    fn icx(&'a self, generics: &'a ty::Generics<'tcx>) -> ItemCtxt<'a,'tcx> {\n+        ItemCtxt { ccx: self, generics: generics }\n+    }\n+\n+    fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n+        let def_id = local_def(method_id);\n+        match self.tcx.impl_or_trait_items.borrow()[def_id] {\n+            ty::MethodTraitItem(ref mty) => mty.clone(),\n+            ty::TypeTraitItem(..) => {\n+                self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n+            }\n+        }\n+    }\n+}\n+\n pub trait ToTy<'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy<'tcx> for CollectCtxt<'a,'tcx> {\n+impl<'a,'tcx> ToTy<'tcx> for ItemCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n-        if id.krate != ast::LOCAL_CRATE {\n-            return ty::lookup_item_type(self.tcx, id);\n-        }\n-\n-        match self.tcx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                type_scheme_of_item(self, &*item)\n-            }\n-            Some(ast_map::NodeForeignItem(foreign_item)) => {\n-                let abi = self.tcx.map.get_foreign_abi(id.node);\n-                type_scheme_of_foreign_item(self, &*foreign_item, abi)\n-            }\n-            x => {\n-                self.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                            in get_item_type_scheme(): {:?}\",\n-                                           x));\n-            }\n-        }\n+        type_scheme_of_def_id(self.ccx, id)\n     }\n \n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        get_trait_def(self, id)\n+        get_trait_def(self.ccx, id)\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n@@ -253,11 +257,12 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     }\n }\n \n-fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     enum_scheme: ty::TypeScheme<'tcx>,\n                                     enum_predicates: ty::GenericPredicates<'tcx>,\n                                     variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n+    let icx = ccx.icx(&enum_scheme.generics);\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants {\n@@ -268,8 +273,8 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[..], enum_scheme.ty)\n+                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -294,7 +299,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    trait_def: &ty::TraitDef<'tcx>,\n                                    trait_predicates: &ty::GenericPredicates<'tcx>) {\n@@ -393,7 +398,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             TypeScheme {\n@@ -405,7 +410,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             m.predicates.clone());\n     }\n \n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            trait_bounds: &ty::GenericPredicates<'tcx>,\n@@ -417,7 +422,8 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            m_generics: &ast::Generics,\n                                            m_unsafety: &ast::Unsafety,\n                                            m_decl: &ast::FnDecl)\n-                                           -> ty::Method<'tcx> {\n+                                           -> ty::Method<'tcx>\n+    {\n         let ty_generics =\n             ty_generics_for_fn_or_method(ccx,\n                                          m_generics,\n@@ -431,7 +437,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n         let (fty, explicit_self_category) = {\n             let trait_self_ty = ty::mk_self_type(ccx.tcx);\n-            astconv::ty_of_method(ccx,\n+            astconv::ty_of_method(&ccx.icx(&ty_generics),\n                                   *m_unsafety,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -454,12 +460,14 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                struct_generics: &ty::Generics<'tcx>,\n-                                struct_predicates: &ty::GenericPredicates<'tcx>,\n-                                v: &ast::StructField,\n-                                origin: ast::DefId) -> ty::field_ty {\n-    let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n+fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           struct_generics: &ty::Generics<'tcx>,\n+                           struct_predicates: &ty::GenericPredicates<'tcx>,\n+                           v: &ast::StructField,\n+                           origin: ast::DefId)\n+                           -> ty::field_ty\n+{\n+    let tt = ccx.icx(struct_generics).to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n@@ -491,7 +499,7 @@ fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n {\n@@ -504,11 +512,10 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     ccx.tcx\n        .impl_or_trait_items\n        .borrow_mut()\n-       .insert(associated_type.def_id,\n-               ty::TypeTraitItem(associated_type));\n+       .insert(associated_type.def_id, ty::TypeTraitItem(associated_type));\n }\n \n-fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n                                  ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n@@ -559,7 +566,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n@@ -578,7 +585,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                &m_ty_generics,\n                                                rcvr_ty_predicates.clone());\n \n-        let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n+        let (fty, explicit_self_category) = astconv::ty_of_method(&ccx.icx(&m_ty_generics),\n                                                                   m.pe_unsafety(),\n                                                                   untransformed_rcvr_ty,\n                                                                   m.pe_explicit_self(),\n@@ -603,7 +610,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n+fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n@@ -632,7 +639,7 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n     }\n }\n \n-fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n+fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n@@ -671,7 +678,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n+            let selfty = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -695,12 +702,6 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n             for impl_item in impl_items {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n-                        let body_id = method.pe_body().id;\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               selfty,\n-                                               method.pe_explicit_self(),\n-                                               body_id);\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n@@ -709,7 +710,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n+                        let typ = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n                                                        TypeScheme {\n                                                            generics: ty::Generics::empty(),\n@@ -741,8 +742,23 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                             &ty_predicates,\n                             parent_visibility);\n \n+            for impl_item in impl_items {\n+                match *impl_item {\n+                    ast::MethodImplItem(ref method) => {\n+                        let body_id = method.pe_body().id;\n+                        check_method_self_type(ccx,\n+                                               &BindingRscope::new(),\n+                                               ccx.method_ty(method.id),\n+                                               selfty,\n+                                               method.pe_explicit_self(),\n+                                               body_id);\n+                    }\n+                    ast::TypeImplItem(..) => { }\n+                }\n+            }\n+\n             if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(ccx,\n+                astconv::instantiate_trait_ref(&ccx.icx(&ty_generics),\n                                                &ExplicitRscope,\n                                                trait_ref,\n                                                Some(it.id),\n@@ -754,27 +770,50 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                                    generics,\n                                                    local_def(it.id));\n         },\n-        ast::ItemTrait(_, _, _, ref trait_methods) => {\n+        ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n             convert_trait_predicates(ccx, it);\n             let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n-            for trait_method in trait_methods {\n+            // Run convert_methods on the provided methods.\n+            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n+            convert_methods(ccx,\n+                            TraitContainer(local_def(it.id)),\n+                            trait_items.iter().filter_map(|m| match *m {\n+                                ast::RequiredMethod(_) => None,\n+                                ast::ProvidedMethod(ref m) => Some(&**m),\n+                                ast::TypeTraitItem(_) => None,\n+                            }),\n+                            untransformed_rcvr_ty,\n+                            &trait_def.generics,\n+                            &trait_predicates,\n+                            it.vis);\n+\n+            // We need to do this *after* converting methods, since\n+            // convert_methods produces a tcache entry that is wrong for\n+            // static trait methods. This is somewhat unfortunate.\n+            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n+\n+            // This must be done after `collect_trait_methods` so that\n+            // we have a method type stored for every method.\n+            for trait_item in trait_items {\n                 let self_type = ty::mk_self_type(tcx);\n-                match *trait_method {\n+                match *trait_item {\n                     ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n                                                &rscope,\n+                                               ccx.method_ty(type_method.id),\n                                                self_type,\n                                                &type_method.explicit_self,\n                                                it.id)\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n+                                               ccx.method_ty(method.id),\n                                                self_type,\n                                                method.pe_explicit_self(),\n                                                it.id)\n@@ -786,25 +825,6 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                 }\n             }\n-\n-            // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n-            convert_methods(ccx,\n-                            TraitContainer(local_def(it.id)),\n-                            trait_methods.iter().filter_map(|m| match *m {\n-                                ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(&**m),\n-                                ast::TypeTraitItem(_) => None,\n-                            }),\n-                            untransformed_rcvr_ty,\n-                            &trait_def.generics,\n-                            &trait_predicates,\n-                            it.vis);\n-\n-            // We need to do this *after* converting methods, since\n-            // convert_methods produces a tcache entry that is wrong for\n-            // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n@@ -827,7 +847,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n     }\n }\n \n-fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             struct_def: &ast::StructDef,\n                             scheme: ty::TypeScheme<'tcx>,\n                             predicates: ty::GenericPredicates<'tcx>,\n@@ -897,7 +917,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n     let tcx = ccx.tcx;\n@@ -915,7 +935,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &ast::Item)\n                                -> Rc<ty::TraitDef<'tcx>>\n {\n@@ -959,6 +979,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     // supertraits:\n     let bounds = compute_bounds(ccx,\n+                                &ty_generics,\n                                 self_param_ty,\n                                 bounds,\n                                 SizedByDefault::No,\n@@ -992,7 +1013,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     return trait_def;\n \n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n@@ -1025,7 +1046,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item) {\n+fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n \n@@ -1044,7 +1065,8 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n \n     let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n \n-    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.trait_ref, items);\n+    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.generics,\n+                                                           &trait_def.trait_ref, items);\n \n     // `ty_generic_bounds` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n@@ -1075,7 +1097,8 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n \n     return;\n \n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 generics: &ty::Generics<'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n                                                  trait_items: &[ast::TraitItem])\n                                                  -> Vec<ty::Predicate<'tcx>>\n@@ -1095,6 +1118,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n                                                  assoc_type_def.ident.name);\n \n                 let bounds = compute_bounds(ccx,\n+                                            generics,\n                                             assoc_ty,\n                                             &*assoc_type_def.bounds,\n                                             SizedByDefault::Yes,\n@@ -1106,7 +1130,31 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n     }\n }\n \n-fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                  def_id: ast::DefId)\n+                                  -> ty::TypeScheme<'tcx>\n+{\n+    if def_id.krate != ast::LOCAL_CRATE {\n+        return ty::lookup_item_type(ccx.tcx, def_id);\n+    }\n+\n+    match ccx.tcx.map.find(def_id.node) {\n+        Some(ast_map::NodeItem(item)) => {\n+            type_scheme_of_item(ccx, &*item)\n+        }\n+        Some(ast_map::NodeForeignItem(foreign_item)) => {\n+            let abi = ccx.tcx.map.get_foreign_abi(def_id.node);\n+            type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+        }\n+        x => {\n+            ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n+                                            in get_item_type_scheme(): {:?}\",\n+                                       x));\n+        }\n+    }\n+}\n+\n+fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 it: &ast::Item)\n                                 -> ty::TypeScheme<'tcx>\n {\n@@ -1116,27 +1164,27 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n }\n \n \n-fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                              it: &ast::Item)\n-                                              -> ty::TypeScheme<'tcx>\n+fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                        it: &ast::Item)\n+                                        -> ty::TypeScheme<'tcx>\n {\n     let tcx = ccx.tcx;\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n-            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(&ty::Generics::empty()).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx,\n                                                            generics,\n                                                            ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n+            let tofd = astconv::ty_of_bare_fn(&ccx.icx(&ty_generics), unsafety, abi, &**decl);\n             let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            let ty = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemEnum(_, ref generics) => {\n@@ -1168,7 +1216,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &ast::Item)\n                                 -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n {\n@@ -1234,18 +1282,18 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n }\n \n fn type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     it: &ast::ForeignItem,\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n {\n-    memoized(&ccx.tcx().tcache,\n+    memoized(&ccx.tcx.tcache,\n              local_def(it.id),\n              |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n }\n \n fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     it: &ast::ForeignItem,\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n@@ -1257,13 +1305,13 @@ fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n         ast::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n+                ty: ast_ty_to_ty(&ccx.icx(&ty::Generics::empty()), &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n-fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   it: &ast::ForeignItem)\n {\n     // For reasons I cannot fully articulate, I do so hate the AST\n@@ -1292,7 +1340,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n }\n \n-fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n@@ -1303,7 +1351,7 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                 ty::Generics::empty())\n }\n \n-fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                ty_generics: &ty::Generics<'tcx>,\n                                                generics: &ast::Generics)\n                                                -> ty::GenericPredicates<'tcx>\n@@ -1315,7 +1363,7 @@ fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                       &generics.where_clause)\n }\n \n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics)\n@@ -1364,7 +1412,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     return generics;\n }\n \n-fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                          generics: &ast::Generics,\n                                          base_generics: ty::Generics<'tcx>)\n                                          -> ty::Generics<'tcx>\n@@ -1378,7 +1426,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 base_generics)\n }\n \n-fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                generics: &ast::Generics,\n                                                ty_generics: &ty::Generics<'tcx>,\n                                                base: ty::GenericPredicates<'tcx>)\n@@ -1392,7 +1440,7 @@ fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                               bounds: &mut ty::BuiltinBounds,\n                               ast_bounds: &[ast::TyParamBound],\n                               span: Span)\n@@ -1438,7 +1486,7 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn ty_generic_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                               space: subst::ParamSpace,\n                               generics: &ty::Generics<'tcx>,\n                               base: ty::GenericPredicates<'tcx>,\n@@ -1465,15 +1513,17 @@ fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     for predicate in &where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n+                let ty = ast_ty_to_ty(&ccx.icx(generics),\n+                                      &ExplicitRscope,\n+                                      &*bound_pred.bounded_ty);\n \n                 for bound in &*bound_pred.bounds {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n-                                ccx,\n+                                &ccx.icx(generics),\n                                 &ExplicitRscope,\n                                 poly_trait_ref,\n                                 Some(ty),\n@@ -1517,7 +1567,7 @@ fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     return result;\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n@@ -1554,7 +1604,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     result\n }\n \n-fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n                                              index: u32,\n@@ -1569,14 +1619,15 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n+                                &ty::Generics::empty(),\n                                 param_ty.to_ty(ccx.tcx),\n                                 &param.bounds,\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n-            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n+            let ty = ast_ty_to_ty(&ccx.icx(&ty::Generics::empty()), &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n@@ -1705,14 +1756,16 @@ enum SizedByDefault { Yes, No }\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn compute_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                           generics: &ty::Generics<'tcx>,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            sized_by_default: SizedByDefault,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n {\n     let mut param_bounds = conv_param_bounds(ccx,\n+                                             generics,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n@@ -1734,7 +1787,7 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     param_bounds\n }\n \n-fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn check_bounds_compatible<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty: Ty<'tcx>,\n                                     param_bounds: &ty::ParamBounds<'tcx>,\n                                     span: Span) {\n@@ -1743,7 +1796,7 @@ fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             ccx.tcx,\n             &param_bounds.trait_bounds,\n             |trait_ref| {\n-                let trait_def = ccx.get_trait_def(trait_ref.def_id());\n+                let trait_def = get_trait_def(ccx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(ccx.tcx.sess, span, E0129,\n                               \"incompatible bounds on `{}`, \\\n@@ -1756,7 +1809,8 @@ fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                              generics: &ty::Generics<'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n@@ -1774,7 +1828,7 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let trait_bounds: Vec<ty::PolyTraitRef> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(ccx,\n+            astconv::instantiate_poly_trait_ref(&ccx.icx(generics),\n                                                 &ExplicitRscope,\n                                                 bound,\n                                                 Some(param_ty),\n@@ -1796,7 +1850,7 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n }\n \n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     decl: &ast::FnDecl,\n     ast_generics: &ast::Generics,\n     abi: abi::Abi)\n@@ -1818,12 +1872,12 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n-                        .map(|a| ty_of_arg(ccx, &rb, a, None))\n+                        .map(|a| ty_of_arg(&ccx.icx(&ty_generics), &rb, a, None))\n                         .collect();\n \n     let output = match decl.output {\n         ast::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(ccx, &rb, &**ty)),\n+            ty::FnConverging(ast_ty_to_ty(&ccx.icx(&ty_generics), &rb, &**ty)),\n         ast::DefaultReturn(..) =>\n             ty::FnConverging(ty::mk_nil(ccx.tcx)),\n         ast::NoReturn(..) =>\n@@ -1847,7 +1901,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     }\n }\n \n-fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             ty_generics: &ty::Generics<'tcx>)\n                             -> subst::Substs<'tcx>\n {\n@@ -1869,15 +1923,16 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n /// comes back to check after the fact that explicit type the user\n /// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n+    method_type: Rc<ty::Method<'tcx>>,\n     required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = ccx.to_ty(rs, &**ast_type);\n+        let typ = ccx.icx(&method_type.generics).to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n             ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n             ty::ty_uniq(typ) => typ,"}]}