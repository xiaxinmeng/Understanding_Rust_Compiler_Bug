{"sha": "30f26ddbc99e34c42f110625f66fc9399d6f38d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjI2ZGRiYzk5ZTM0YzQyZjExMDYyNWY2NmZjOTM5OWQ2ZjM4ZDE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-18T03:36:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: adding uv::ll::ip4_name and refactored net::ip to use it\n\nreplaces net::ip's previously, hand-rolled impl for ipv4 addr parsing..\nwe're relying on libuv, now", "tree": {"sha": "af5f27465b1bd3d5c3913e17fd78e16ac6252a5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af5f27465b1bd3d5c3913e17fd78e16ac6252a5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f26ddbc99e34c42f110625f66fc9399d6f38d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f26ddbc99e34c42f110625f66fc9399d6f38d1", "html_url": "https://github.com/rust-lang/rust/commit/30f26ddbc99e34c42f110625f66fc9399d6f38d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f26ddbc99e34c42f110625f66fc9399d6f38d1/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0272928464c9f3ec8aa2e4a7ed17de6157ad59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0272928464c9f3ec8aa2e4a7ed17de6157ad59b", "html_url": "https://github.com/rust-lang/rust/commit/c0272928464c9f3ec8aa2e4a7ed17de6157ad59b"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "106f1baa8c5b72ac5956934231121a0eccdeb53e", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=30f26ddbc99e34c42f110625f66fc9399d6f38d1", "patch": "@@ -5,14 +5,19 @@ Types/fns concerning Internet Protocol (IP), versions 4 & 6\n import vec;\n import uint;\n \n+import sockaddr_in = uv::ll::sockaddr_in;\n+import sockaddr_in6 = uv::ll::sockaddr_in6;\n+import uv_ip4_addr = uv::ll::ip4_addr;\n+import uv_ip4_name = uv::ll::ip4_name;\n+\n export ip_addr, parse_addr_err;\n export format_addr;\n export v4;\n \n #[doc = \"An IP address\"]\n enum ip_addr {\n     #[doc=\"An IPv4 address\"]\n-    ipv4(u8, u8, u8, u8),\n+    ipv4(sockaddr_in),\n     ipv6(u16,u16,u16,u16,u16,u16,u16,u16)\n }\n \n@@ -32,8 +37,14 @@ Convert a `ip_addr` to a str\n \"]\n fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n-      ipv4(a, b, c, d) {\n-        #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n+      ipv4(addr) {\n+        unsafe {\n+            let result = uv_ip4_name(&addr);\n+            if result == \"\" {\n+                fail \"failed to convert inner sockaddr_in address to str\"\n+            }\n+            result\n+        }\n       }\n       ipv6(_, _, _, _, _, _, _, _) {\n         fail \"FIXME (#2651) impl parsing of ipv6 addr\";\n@@ -59,45 +70,28 @@ j    Fails if the string is not a valid IPv4 address\n     \"]\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          result::ok(addr) { addr }\n+          // FIXME: more copies brought to light to due the implicit\n+          // copy compiler warning.. what can be done? out pointers,\n+          // ala c#?\n+          result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n             fail err_data.err_msg\n           }\n         }\n     }\n     fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n-        let parts = vec::map(str::split_char(ip, '.'), {|s|\n-            alt uint::from_str(s) {\n-              some(n) if n <= 255u { n }\n-              _ { 256u }\n-            }\n-        });\n-        if vec::len(parts) != 4u {\n-            result::err({err_msg: #fmt(\"'%s' doesn't have 4 parts\",\n-                        ip)})\n-        }\n-        else if vec::contains(parts, 256u) {\n-            result::err({err_msg: #fmt(\"invalid octal in provided addr '%s'\",\n-                        ip)})\n-        }\n-        else {\n-            result::ok(ipv4(parts[0] as u8, parts[1] as u8,\n-                 parts[2] as u8, parts[3] as u8))\n+        unsafe {\n+            // need to figure out how to establish a parse failure..\n+            result::ok(ipv4(uv_ip4_addr(ip, 22)))\n         }\n     }\n }\n \n #[cfg(test)]\n mod test {\n     #[test]\n-    fn test_format_ip() {\n-        assert (format_addr(ipv4(127u8, 0u8, 0u8, 1u8))\n+    fn test_ipv4_parse_and_format_ip() {\n+        assert (format_addr(v4::parse_addr(\"127.0.0.1\"))\n                 == \"127.0.0.1\")\n     }\n-\n-    #[test]\n-    fn test_parse_ip() {\n-        assert (v4::parse_addr(\"127.0.0.1\") ==\n-                ipv4(127u8, 0u8, 0u8, 1u8));\n-    }\n }\n\\ No newline at end of file"}, {"sha": "7c3349efae4bfd2ce6bac78a87be0fec57192023", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=30f26ddbc99e34c42f110625f66fc9399d6f38d1", "patch": "@@ -126,7 +126,7 @@ that can be used to send and receive data to/from the remote host. In the\n event of failure, a `net::tcp::tcp_connect_err_data` instance will be\n returned\n \"]\n-fn connect(input_ip: ip::ip_addr, port: uint,\n+fn connect(-input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n     -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n@@ -551,7 +551,7 @@ a `result` instance containing empty data of type `()` on a\n successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n of listen exiting because of an error\n \"]\n-fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n@@ -568,7 +568,7 @@ fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n-fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n@@ -589,8 +589,15 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     let server_data_ptr = ptr::addr_of(server_data);\n \n     let setup_result = comm::listen {|setup_ch|\n+        // FIXME this is to address a compiler warning about\n+        // an implicit copy.. it seems that double nested\n+        // will defeat a move sigil, as is done to the host_ip\n+        // arg above.. this same pattern works w/o complaint in\n+        // tcp::connect (because the iotask::interact cb isn't\n+        // nested within a comm::listen block)\n+        let loc_ip = copy(host_ip);\n         iotask::interact(iotask) {|loop_ptr|\n-            let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n+            let tcp_addr = ipv4_ip_addr_to_sockaddr_in(loc_ip,\n                                                        port);\n             alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n               0i32 {\n@@ -1201,9 +1208,10 @@ type tcp_buffered_socket_data = {\n fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n                                port: uint) -> uv::ll::sockaddr_in unsafe {\n     // FIXME (#2656): ipv6\n+    let addr_str = ip::format_addr(input_ip);\n     alt input_ip {\n-      ip::ipv4(_,_,_,_) {\n-        uv::ll::ip4_addr(ip::format_addr(input_ip), port as int)\n+      ip::ipv4(addr) {\n+        uv::ll::ip4_addr(addr_str, port as int)\n       }\n       ip::ipv6(_,_,_,_,_,_,_,_) {\n         fail \"FIXME (#2656) ipv6 not yet supported\";"}, {"sha": "fb8ba36acd34fb97a5772b85f3879e284f792916", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f26ddbc99e34c42f110625f66fc9399d6f38d1/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=30f26ddbc99e34c42f110625f66fc9399d6f38d1", "patch": "@@ -704,6 +704,24 @@ unsafe fn ip6_addr(ip: str, port: int)\n     ret rustrt::rust_uv_ip6_addr(addr_vec_ptr,\n                                  port as libc::c_int);\n }\n+unsafe fn ip4_name(src: &sockaddr_in) -> str {\n+    // ipv4 addr max size: 15 + 1 trailing null byte\n+    let dst: [u8] = [0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n+    let size = 16 as libc::size_t;\n+    vec::as_buf(dst) {|dst_buf|\n+        let result = rustrt::rust_uv_ip4_name(src as *sockaddr_in,\n+                                              dst_buf, size);\n+        alt result {\n+          0i32 {\n+            str::unsafe::from_buf(dst_buf)\n+          }\n+          _ {\n+            \"\"\n+          }\n+        }\n+    }\n+}\n \n unsafe fn timer_init(loop_ptr: *libc::c_void,\n                      timer_ptr: *uv_timer_t) -> libc::c_int {"}]}