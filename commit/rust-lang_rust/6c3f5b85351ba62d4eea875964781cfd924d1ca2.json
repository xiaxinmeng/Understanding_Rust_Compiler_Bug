{"sha": "6c3f5b85351ba62d4eea875964781cfd924d1ca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjM2Y1Yjg1MzUxYmE2MmQ0ZWVhODc1OTY0NzgxY2ZkOTI0ZDFjYTI=", "commit": {"author": {"name": "hi-rustin", "email": "rustin.liu@gmail.com", "date": "2021-04-05T14:54:50Z"}, "committer": {"name": "hi-rustin", "email": "rustin.liu@gmail.com", "date": "2021-04-05T14:58:11Z"}, "message": "resolve conflicts\n\nresolve conflicts", "tree": {"sha": "55f0b033b6b12a7bd24e9149db10de28d16324d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55f0b033b6b12a7bd24e9149db10de28d16324d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c3f5b85351ba62d4eea875964781cfd924d1ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3f5b85351ba62d4eea875964781cfd924d1ca2", "html_url": "https://github.com/rust-lang/rust/commit/6c3f5b85351ba62d4eea875964781cfd924d1ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c3f5b85351ba62d4eea875964781cfd924d1ca2/comments", "author": {"login": "hi-rustin", "id": 29879298, "node_id": "MDQ6VXNlcjI5ODc5Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/29879298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hi-rustin", "html_url": "https://github.com/hi-rustin", "followers_url": "https://api.github.com/users/hi-rustin/followers", "following_url": "https://api.github.com/users/hi-rustin/following{/other_user}", "gists_url": "https://api.github.com/users/hi-rustin/gists{/gist_id}", "starred_url": "https://api.github.com/users/hi-rustin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hi-rustin/subscriptions", "organizations_url": "https://api.github.com/users/hi-rustin/orgs", "repos_url": "https://api.github.com/users/hi-rustin/repos", "events_url": "https://api.github.com/users/hi-rustin/events{/privacy}", "received_events_url": "https://api.github.com/users/hi-rustin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hi-rustin", "id": 29879298, "node_id": "MDQ6VXNlcjI5ODc5Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/29879298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hi-rustin", "html_url": "https://github.com/hi-rustin", "followers_url": "https://api.github.com/users/hi-rustin/followers", "following_url": "https://api.github.com/users/hi-rustin/following{/other_user}", "gists_url": "https://api.github.com/users/hi-rustin/gists{/gist_id}", "starred_url": "https://api.github.com/users/hi-rustin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hi-rustin/subscriptions", "organizations_url": "https://api.github.com/users/hi-rustin/orgs", "repos_url": "https://api.github.com/users/hi-rustin/repos", "events_url": "https://api.github.com/users/hi-rustin/events{/privacy}", "received_events_url": "https://api.github.com/users/hi-rustin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "115e216067aff0b7b2fa55d9a66394f14a3a8397", "url": "https://api.github.com/repos/rust-lang/rust/commits/115e216067aff0b7b2fa55d9a66394f14a3a8397", "html_url": "https://github.com/rust-lang/rust/commit/115e216067aff0b7b2fa55d9a66394f14a3a8397"}], "stats": {"total": 141, "additions": 8, "deletions": 133}, "files": [{"sha": "1aca93fc5c56a990a69f21e611fc6ed12c7c12b2", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6c3f5b85351ba62d4eea875964781cfd924d1ca2", "patch": "@@ -564,7 +564,7 @@ rustc_queries! {\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n-    query associated_items(key: DefId) -> ty::AssociatedItems<'tcx> {\n+    query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n         storage(ArenaCacheSelector<'tcx>)\n         desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n     }"}, {"sha": "d005f63ed4383b4365d9790cd715a8746000547c", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=6c3f5b85351ba62d4eea875964781cfd924d1ca2", "patch": "@@ -96,15 +96,15 @@ impl AssocKind {\n /// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssociatedItems<'tcx> {\n+pub struct AssocItems<'tcx> {\n     pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n }\n \n-impl<'tcx> AssociatedItems<'tcx> {\n+impl<'tcx> AssocItems<'tcx> {\n     /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n     pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n         let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n-        AssociatedItems { items }\n+        AssocItems { items }\n     }\n \n     /// Returns a slice of associated items in the order they were defined."}, {"sha": "38e5ce6fd831c686c56856e10a35b6e02b66d863", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=6c3f5b85351ba62d4eea875964781cfd924d1ca2", "patch": "@@ -210,9 +210,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssociatedItems<'_> {\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n     let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    ty::AssociatedItems::new(items)\n+    ty::AssocItems::new(items)\n }\n \n fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {"}, {"sha": "c69389e7b432b1578de4879b47add8b147c64bb1", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3f5b85351ba62d4eea875964781cfd924d1ca2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=6c3f5b85351ba62d4eea875964781cfd924d1ca2", "patch": "@@ -24,8 +24,8 @@ impl InherentOverlapChecker<'tcx> {\n     /// namespace.\n     fn impls_have_common_items(\n         &self,\n-        impl_items1: &ty::AssociatedItems<'_>,\n-        impl_items2: &ty::AssociatedItems<'_>,\n+        impl_items1: &ty::AssocItems<'_>,\n+        impl_items2: &ty::AssocItems<'_>,\n     ) -> bool {\n         let mut impl_items1 = &impl_items1;\n         let mut impl_items2 = &impl_items2;"}, {"sha": "bc7f5af826efad79dc780638b2bf2f4e2ab01724", "filename": "test.rs", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/115e216067aff0b7b2fa55d9a66394f14a3a8397/test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/115e216067aff0b7b2fa55d9a66394f14a3a8397/test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.rs?ref=115e216067aff0b7b2fa55d9a66394f14a3a8397", "patch": "@@ -1,125 +0,0 @@\n-#![allow(missing_docs)]\n-\n-use embedded_hal::digital::v2::{InputPin, OutputPin};\n-use generic_array::{ArrayLength, GenericArray};\n-use heapless::Vec;\n-\n-pub trait HeterogenousArray {\n-    type Len;\n-}\n-\n-/// Macro to implement a iterator on trait objects from a tuple struct.\n-#[macro_export]\n-macro_rules! impl_heterogenous_array {\n-    ($s:ident, $t:ty, $len:tt, [$($idx:tt),+]) => {\n-        impl<'a> IntoIterator for &'a $s {\n-            type Item = &'a $t;\n-            type IntoIter = generic_array::GenericArrayIter<&'a $t, $len>;\n-            fn into_iter(self) -> Self::IntoIter {\n-                self.as_array().into_iter()\n-            }\n-        }\n-        impl<'a> IntoIterator for &'a mut $s {\n-            type Item = &'a mut $t;\n-            type IntoIter = generic_array::GenericArrayIter<&'a mut $t, $len>;\n-            fn into_iter(self) -> Self::IntoIter {\n-                self.as_mut_array().into_iter()\n-            }\n-        }\n-        impl $crate::matrix::HeterogenousArray for $s {\n-            type Len = $len;\n-        }\n-        impl $s {\n-            pub fn as_array(&self) -> generic_array::GenericArray<&$t, $len> {\n-                generic_array::arr![&$t; $( &self.$idx as &$t, )+]\n-            }\n-            pub fn as_mut_array(&mut self) -> generic_array::GenericArray<&mut $t, $len> {\n-                generic_array::arr![&mut $t; $( &mut self.$idx as &mut $t, )+]\n-            }\n-        }\n-    }\n-}\n-\n-pub struct Matrix<C, R> {\n-    cols: C,\n-    rows: R,\n-}\n-\n-impl<C, R> Matrix<C, R> {\n-    pub fn new<E>(cols: C, rows: R) -> Result<Self, E>\n-        where\n-                for<'a> &'a mut R: IntoIterator<Item = &'a mut dyn OutputPin<Error = E>>,\n-    {\n-        let mut res = Self { cols, rows };\n-        res.clear()?;\n-        Ok(res)\n-    }\n-    pub fn clear<'a, E: 'a>(&'a mut self) -> Result<(), E>\n-        where\n-            &'a mut R: IntoIterator<Item = &'a mut dyn OutputPin<Error = E>>,\n-    {\n-        for r in self.rows.into_iter() {\n-            r.set_high()?;\n-        }\n-        Ok(())\n-    }\n-    pub fn get<'a, E: 'a>(&'a mut self) -> Result<PressedKeys<R::Len, C::Len>, E>\n-        where\n-            &'a mut R: IntoIterator<Item = &'a mut dyn OutputPin<Error = E>>,\n-            R: HeterogenousArray,\n-            R::Len: ArrayLength<GenericArray<bool, C::Len>>,\n-            &'a C: IntoIterator<Item = &'a dyn InputPin<Error = E>>,\n-            C: HeterogenousArray,\n-            C::Len: ArrayLength<bool>,\n-    {\n-        let cols = &self.cols;\n-        self.rows\n-            .into_iter()\n-            .map(|r| {\n-                r.set_low()?;\n-                let col = cols\n-                    .into_iter()\n-                    .map(|c| c.is_low())\n-                    .collect::<Result<Vec<_, C::Len>, E>>()?\n-                    .into_iter()\n-                    .collect();\n-                r.set_high()?;\n-                Ok(col)\n-            })\n-            .collect::<Result<Vec<_, R::Len>, E>>()\n-            .map(|res| PressedKeys(res.into_iter().collect()))\n-    }\n-}\n-\n-#[derive(Default, PartialEq, Eq)]\n-pub struct PressedKeys<U, V>(pub GenericArray<GenericArray<bool, V>, U>)\n-    where\n-        V: ArrayLength<bool>,\n-        U: ArrayLength<GenericArray<bool, V>>;\n-\n-impl<U, V> PressedKeys<U, V>\n-    where\n-        V: ArrayLength<bool>,\n-        U: ArrayLength<GenericArray<bool, V>>,\n-{\n-    pub fn iter_pressed<'a>(&'a self) -> impl Iterator<Item = (usize, usize)> + Clone + 'a {\n-        self.0.iter().enumerate().flat_map(|(i, r)| {\n-            r.iter()\n-                .enumerate()\n-                .filter_map(move |(j, &b)| if b { Some((i, j)) } else { None })\n-        })\n-    }\n-}\n-\n-impl<'a, U, V> IntoIterator for &'a PressedKeys<U, V>\n-    where\n-        V: ArrayLength<bool>,\n-        U: ArrayLength<GenericArray<bool, V>>,\n-        U: ArrayLength<&'a GenericArray<bool, V>>,\n-{\n-    type IntoIter = core::slice::Iter<'a, GenericArray<bool, V>>;\n-    type Item = &'a GenericArray<bool, V>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.iter()\n-    }\n-}\n\\ No newline at end of file"}]}