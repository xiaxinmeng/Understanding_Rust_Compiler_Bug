{"sha": "acdf83f2288e1b80259dafeca4a0cee9a42973c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZGY4M2YyMjg4ZTFiODAyNTlkYWZlY2E0YTBjZWU5YTQyOTczYzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T08:25:29Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T08:25:29Z"}, "message": "Update miri to rustc changes", "tree": {"sha": "ef7ffe46fee2f0b9f331a206af4a71d23fabe0a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef7ffe46fee2f0b9f331a206af4a71d23fabe0a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acdf83f2288e1b80259dafeca4a0cee9a42973c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlonqXkACgkQpp+NIls6\n19kKTg/+JC8MlH7Z95bUwe6JzjV/3YR40yGCSdbQN7SixJstJad+pAsc3SHbl2tE\ncJPXAjDDdNC63ps5dZM/SUowgxNO6WdqiuE84l9lYzhw7Lri+9UIOaPV0YZpxAL3\nWU5zrHj66TozDZzqFqmxfb4yIalQpNdITHbnp6iD5Ep/7SGMx7j+r7uKAhcnkdJZ\nDhfkI9pk27seU66fMtcCQflKgfObUUmQpRYiMQFfd42h+1RWYWfSfVAwL4VW3wDd\nCgRSvjCvj0gR7I3deA0JfpqmQCNbVBjC2xT77ztEUKpzqGEe4lprLTtpCAWW5w2Y\n65qmM2UOdaMIE0NfS56YIG/i14cL6Zd39a1+nzWblypR0q4cx4D34L/wsscYq7TU\nfPGdflykeAjLPWpKsrZNbSE8dAt+qqbPwTQv0Qo3Hd33F5HBNyFUq5OcYAzB/SUG\neLrdVeDCay2aCicpSu/HnpOajUXkCiptBtIctImzUVfngYle+QyhT7aCeSJWsc3K\neBPShxawQfRIsWwd4Xo8MTxhjOK5A6E4n1an3eqLtphMdOIDr7X9VBOgbc9pIqu0\nRAapJEhaEu5oxNXzxC2xhPc9vHHFC9qL//dJ7rTOnYxiPwwR72B5kRQtYnwIpuKT\n7n3usomUetH5bjCEg4/kY9uciPqmn+JjYCNLs+FqipWtR4oHSX8=\n=i+zJ\n-----END PGP SIGNATURE-----", "payload": "tree ef7ffe46fee2f0b9f331a206af4a71d23fabe0a1\nparent d4c442d65c150b99d18202a5cce4a2cbdbd4dc83\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1512548729 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1512548729 +0100\n\nUpdate miri to rustc changes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acdf83f2288e1b80259dafeca4a0cee9a42973c3", "html_url": "https://github.com/rust-lang/rust/commit/acdf83f2288e1b80259dafeca4a0cee9a42973c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acdf83f2288e1b80259dafeca4a0cee9a42973c3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "html_url": "https://github.com/rust-lang/rust/commit/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}], "stats": {"total": 131301, "additions": 84986, "deletions": 46315}, "files": [{"sha": "3c1f41bdcca6c6fd7ef721d7821433059962ee4b", "filename": ".editorconfig", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.editorconfig?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,25 +0,0 @@\n-# EditorConfig helps developers define and maintain consistent\n-# coding styles between different editors and IDEs\n-# editorconfig.org\n-\n-root = true\n-\n-\n-[*]\n-end_of_line = lf\n-charset = utf-8\n-trim_trailing_whitespace = true\n-insert_final_newline = true\n-indent_style = space\n-indent_size = 4\n-\n-[*.rs]\n-indent_style = space\n-indent_size = 4\n-\n-[*.toml]\n-indent_style = space\n-indent_size = 4\n-\n-[*.md]\n-trim_trailing_whitespace = false"}, {"sha": "57407a2399a2f249f85ecf5ad69d05b3888ef481", "filename": ".gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -95,7 +95,6 @@ config.stamp\n keywords.md\n lexer.ml\n src/etc/dl\n-src/librustc_llvm/llvmdeps.rs\n tmp.*.rs\n version.md\n version.ml"}, {"sha": "0a1188e83eae673234ed1e27df9e3fd61d7ea986", "filename": ".gitmodules", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -42,3 +42,9 @@\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/solson/miri.git\n+[submodule \"src/dlmalloc\"]\n+\tpath = src/dlmalloc\n+\turl = https://github.com/alexcrichton/dlmalloc-rs.git\n+[submodule \"src/binaryen\"]\n+\tpath = src/binaryen\n+\turl = https://github.com/alexcrichton/binaryen.git"}, {"sha": "b2840ac3121f84d3a48151d62828399986cf734e", "filename": ".travis.yml", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12,18 +12,17 @@ matrix:\n   fast_finish: true\n   include:\n     # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-3.7 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-gnu-llvm-3.9 RUST_BACKTRACE=1\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1\n       if: branch = try OR branch = auto\n \n-    # \"alternate\" deployments, these are \"nightlies\" but don't have assertions\n-    # turned on, they're deployed to a different location primarily for projects\n-    # which are stuck on nightly and don't want llvm assertions in the artifacts\n-    # that they use.\n+    # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n+    # turned on, they're deployed to a different location primarily for\n+    # additional testing.\n     - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n-      if: branch = auto\n+      if: branch = try OR branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n@@ -36,7 +35,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     # macOS builders. These are placed near the beginning because they are very\n@@ -57,7 +56,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.2\n+      osx_image: xcode8.3\n       if: branch = auto\n \n     - env: >\n@@ -71,7 +70,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.2\n+      osx_image: xcode8.3\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and\n@@ -91,7 +90,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     - env: >\n@@ -105,15 +104,17 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     # Linux builders, remaining docker images\n     - env: IMAGE=arm-android\n       if: branch = auto\n     - env: IMAGE=armhf-gnu\n       if: branch = auto\n-    - env: IMAGE=cross DEPLOY=1\n+    - env: IMAGE=dist-various-1 DEPLOY=1\n+      if: branch = auto\n+    - env: IMAGE=dist-various-2 DEPLOY=1\n       if: branch = auto\n     - env: IMAGE=dist-aarch64-linux DEPLOY=1\n       if: branch = auto\n@@ -125,8 +126,6 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=dist-armv7-linux DEPLOY=1\n       if: branch = auto\n-    - env: IMAGE=dist-fuchsia DEPLOY=1\n-      if: branch = auto\n     - env: IMAGE=dist-i586-gnu-i686-musl DEPLOY=1\n       if: branch = auto\n     - env: IMAGE=dist-i686-freebsd DEPLOY=1\n@@ -161,14 +160,16 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=i686-gnu-nopt\n       if: branch = auto\n-    # - env: IMAGE=wasm32 issue 42646\n-    #   if: branch = auto\n+    - env: IMAGE=wasm32-unknown\n+      if: branch = auto\n     - env: IMAGE=x86_64-gnu\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-full-bootstrap\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-aux\n       if: branch = auto\n+    - env: IMAGE=x86_64-gnu-tools\n+      if: branch = auto\n     - env: IMAGE=x86_64-gnu-debug\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-nopt\n@@ -251,7 +252,14 @@ after_failure:\n \n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n-  - ls $HOME/Library/Logs/DiagnosticReports/\n+  - ls -lat $HOME/Library/Logs/DiagnosticReports/\n+  - find $HOME/Library/Logs/DiagnosticReports\n+      -type f\n+      -not -name '*.stage2-*.crash'\n+      -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n+      -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n+      -exec head -750 {} \\;\n+      -exec echo travis_fold\":\"end:crashlog \\;\n \n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened\n@@ -284,6 +292,7 @@ before_deploy:\n           rm -rf obj/build/dist/doc &&\n           cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n+  - travis_retry gem update --system\n \n deploy:\n   - provider: s3\n@@ -300,11 +309,30 @@ deploy:\n       branch: auto\n       condition: $DEPLOY = 1\n \n+  # this is the same as the above deployment provider except that it uploads to\n+  # a slightly different directory and has a different trigger\n   - provider: s3\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy\n-    upload_dir: rustc-builds-try\n+    upload_dir: rustc-builds-alt\n+    acl: public_read\n+    region: us-west-1\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n+    secret_access_key:\n+      secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n+    on:\n+      branch: auto\n+      condition: $DEPLOY_ALT = 1\n+\n+  # These two providers are the same as the two above, except deploy on the\n+  # try branch. Travis does not appear to provide a way to use \"or\" in these\n+  # conditions.\n+  - provider: s3\n+    bucket: rust-lang-ci2\n+    skip_cleanup: true\n+    local_dir: deploy\n+    upload_dir: rustc-builds\n     acl: public_read\n     region: us-west-1\n     access_key_id: AKIAJVBODR3IA4O72THQ\n@@ -314,8 +342,6 @@ deploy:\n       branch: try\n       condition: $DEPLOY = 1\n \n-  # this is the same as the above deployment provider except that it uploads to\n-  # a slightly different directory and has a different trigger\n   - provider: s3\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n@@ -327,5 +353,5 @@ deploy:\n     secret_access_key:\n       secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n-      branch: auto\n+      branch: try\n       condition: $DEPLOY_ALT = 1"}, {"sha": "d42476bc4130dd8e1b14d23ce936de657955debe", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -6,7 +6,7 @@ A version of this document [can be found online](https://www.rust-lang.org/condu\n \n **Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n \n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n * On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n * Please be kind and courteous. There's no need to be mean or rude.\n * Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer."}, {"sha": "e3767df2808fa765501388991b2780ff5cc8ad84", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 145, "deletions": 5, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,5 @@\n # Contributing to Rust\n+[contributing-to-rust]: #contributing-to-rust\n \n Thank you for your interest in contributing to Rust! There are many ways to\n contribute, and we appreciate all of them. This document is a bit long, so here's\n@@ -18,18 +19,20 @@ hop on [#rust-internals][pound-rust-internals].\n \n As a reminder, all contributors are expected to follow our [Code of Conduct][coc].\n \n-[pound-rust-internals]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n+[pound-rust-internals]: https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n [internals]: https://internals.rust-lang.org\n [coc]: https://www.rust-lang.org/conduct.html\n \n ## Feature Requests\n+[feature-requests]: #feature-requests\n \n To request a change to the way that the Rust language works, please open an\n issue in the [RFCs repository](https://github.com/rust-lang/rfcs/issues/new)\n rather than this one. New features and other significant language changes\n must go through the RFC process.\n \n ## Bug Reports\n+[bug-reports]: #bug-reports\n \n While bugs are unfortunate, they're a reality in software. We can't fix what we\n don't know about, so please report liberally. If you're not sure if something\n@@ -80,6 +83,7 @@ $ RUST_BACKTRACE=1 rustc ...\n ```\n \n ## The Build System\n+[the-build-system]: #the-build-system\n \n Rust's build system allows you to bootstrap the compiler, run tests &\n benchmarks, generate documentation, install a fresh build of Rust, and more.\n@@ -94,6 +98,7 @@ system internals, try asking in [`#rust-internals`][pound-rust-internals].\n [bootstrap]: https://github.com/rust-lang/rust/tree/master/src/bootstrap/\n \n ### Configuration\n+[configuration]: #configuration\n \n Before you can start building the compiler you need to configure the build for\n your system. In most cases, that will just mean using the defaults provided\n@@ -125,6 +130,11 @@ file. If you still have a `config.mk` file in your directory - from\n `./configure` - you may need to delete it for `config.toml` to work.\n \n ### Building\n+[building]: #building\n+\n+Dependencies\n+- [build dependencies](README.md#building-from-source)\n+- `gdb` 6.2.0 minimum, 7.1 or later recommended for test builds\n \n The build system uses the `x.py` script to control the build process. This script\n is used to build, test, and document various parts of the compiler. You can\n@@ -194,6 +204,7 @@ Note: Previously `./configure` and `make` were used to build this project.\n They are still available, but `x.py` is the recommended build system.\n \n ### Useful commands\n+[useful-commands]: #useful-commands\n \n Some common invocations of `x.py` are:\n \n@@ -234,6 +245,7 @@ Some common invocations of `x.py` are:\n   code.\n \n ### Using your local build\n+[using-local-build]: #using-local-build\n \n If you use Rustup to manage your rust install, it has a feature called [\"custom\n toolchains\"][toolchain-link] that you can use to access your newly-built compiler\n@@ -262,6 +274,7 @@ stage 1. `python x.py build --stage 1 src/libstd src/tools/rustdoc` will build\n rustdoc and libstd, which will allow rustdoc to be run with that toolchain.)\n \n ## Pull Requests\n+[pull-requests]: #pull-requests\n \n Pull requests are the primary mechanism we use to change Rust. GitHub itself\n has some [great documentation][pull-requests] on using the Pull Request feature.\n@@ -326,20 +339,144 @@ it can be found\n [here](https://github.com/rust-lang/rust-wiki-backup/blob/master/Note-testsuite.md).\n \n ### External Dependencies\n+[external-dependencies]: #external-dependencies\n \n Currently building Rust will also build the following external projects:\n \n * [clippy](https://github.com/rust-lang-nursery/rust-clippy)\n * [miri](https://github.com/solson/miri)\n \n If your changes break one of these projects, you need to fix them by opening\n-a pull request against the broken project. When you have opened a pull request,\n-you can disable the tool via `src/tools/toolstate.toml`.\n+a pull request against the broken project asking to put the fix on a branch.\n+Then you can disable the tool building via `src/tools/toolstate.toml`.\n+Once the branch containing your fix is likely to be merged, you can point\n+the affected submodule at this branch.\n+\n+Don't forget to also add your changes with\n+\n+```\n+git add path/to/submodule\n+```\n+\n+outside the submodule.\n+\n+In order to prepare your PR, you can run the build locally by doing\n+`./x.py build src/tools/TOOL`. If you will be editing the sources\n+there, you may wish to set `submodules = false` in the `config.toml`\n+to prevent `x.py` from resetting to the original branch.\n+\n+#### Breaking Tools Built With The Compiler\n+[breaking-tools-built-with-the-compiler]: #breaking-tools-built-with-the-compiler\n+\n+Rust's build system builds a number of tools that make use of the\n+internals of the compiler. This includes clippy,\n+[RLS](https://github.com/rust-lang-nursery/rls) and\n+[rustfmt](https://github.com/rust-lang-nursery/rustfmt). If these tools\n+break because of your changes, you may run into a sort of \"chicken and egg\"\n+problem. These tools rely on the latest compiler to be built so you can't update\n+them to reflect your changes to the compiler until those changes are merged into\n+the compiler. At the same time, you can't get your changes merged into the compiler\n+because the rust-lang/rust build won't pass until those tools build and pass their\n+tests.\n+\n+That means that, in the default state, you can't update the compiler without first\n+fixing rustfmt, rls and the other tools that the compiler builds.\n+\n+Luckily, a feature was [added to Rust's build](https://github.com/rust-lang/rust/pull/45243)\n+to make all of this easy to handle. The idea is that you mark the tools as \"broken\",\n+so that the rust-lang/rust build passes without trying to build them, then land the change\n+in the compiler, wait for a nightly, and go update the tools that you broke. Once you're done\n+and the tools are working again, you go back in the compiler and change the tools back\n+from \"broken\".\n+\n+This should avoid a bunch of synchronization dances and is also much easier on contributors as\n+there's no need to block on rls/rustfmt/other tools changes going upstream.\n+\n+Here are those same steps in detail:\n+\n+1. (optional) First, if it doesn't exist already, create a `config.toml` by copying\n+   `config.toml.example` in the root directory of the Rust repository.\n+   Set `submodules = false` in the `[build]` section. This will prevent `x.py`\n+   from resetting to the original branch after you make your changes. If you\n+   need to [update any submodules to their latest versions][updating-submodules],\n+   see the section of this file about that for more information.\n+2. (optional) Run `./x.py test src/tools/rustfmt` (substituting the submodule\n+   that broke for `rustfmt`). Fix any errors in the submodule (and possibly others).\n+3. (optional) Make commits for your changes and send them to upstream repositories as a PR.\n+4. (optional) Maintainers of these submodules will **not** merge the PR. The PR can't be\n+   merged because CI will be broken. You'll want to write a message on the PR referencing\n+   your change, and how the PR should be merged once your change makes it into a nightly.\n+5. Update `src/tools/toolstate.toml` to indicate that the tool in question is \"broken\",\n+   that will disable building it on CI. See the documentation in that file for the exact\n+   configuration values you can use.\n+6. Commit the changes to `src/tools/toolstate.toml`, **do not update submodules in your commit**,\n+   and then update the PR you have for rust-lang/rust.\n+7. Wait for your PR to merge.\n+8. Wait for a nightly\n+9. (optional) Help land your PR on the upstream repository now that your changes are in nightly.\n+10. (optional) Send a PR to rust-lang/rust updating the submodule, reverting `src/tools/toolstate.toml` back to a \"building\" or \"testing\" state.\n+\n+#### Updating submodules\n+[updating-submodules]: #updating-submodules\n+\n+These instructions are specific to updating `rustfmt`, however they may apply\n+to the other submodules as well. Please help by improving these instructions\n+if you find any discrepancies or special cases that need to be addressed.\n+\n+To update the `rustfmt` submodule, start by running the appropriate\n+[`git submodule` command](https://git-scm.com/book/en/v2/Git-Tools-Submodules).\n+For example, to update to the latest commit on the remote master branch,\n+you may want to run:\n+```\n+git submodule update --remote src/tools/rustfmt\n+```\n+If you run `./x.py build` now, and you are lucky, it may just work. If you see\n+an error message about patches that did not resolve to any crates, you will need\n+to complete a few more steps which are outlined with their rationale below.\n+\n+*(This error may change in the future to include more information.)*\n+```\n+error: failed to resolve patches for `https://github.com/rust-lang-nursery/rustfmt`\n+\n+Caused by:\n+  patch for `rustfmt-nightly` in `https://github.com/rust-lang-nursery/rustfmt` did not resolve to any crates\n+failed to run: ~/rust/build/x86_64-unknown-linux-gnu/stage0/bin/cargo build --manifest-path ~/rust/src/bootstrap/Cargo.toml\n+```\n+\n+If you haven't used the `[patch]`\n+section of `Cargo.toml` before, there is [some relevant documentation about it\n+in the cargo docs](http://doc.crates.io/manifest.html#the-patch-section). In\n+addition to that, you should read the \n+[Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#overriding-dependencies)\n+section of the documentation as well.\n+\n+Specifically, the following [section in Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#testing-a-bugfix) reveals what the problem is:\n+\n+> Next up we need to ensure that our lock file is updated to use this new version of uuid so our project uses the locally checked out copy instead of one from crates.io. The way [patch] works is that it'll load the dependency at ../path/to/uuid and then whenever crates.io is queried for versions of uuid it'll also return the local version.\n+> \n+> This means that the version number of the local checkout is significant and will affect whether the patch is used. Our manifest declared uuid = \"1.0\" which means we'll only resolve to >= 1.0.0, < 2.0.0, and Cargo's greedy resolution algorithm also means that we'll resolve to the maximum version within that range. Typically this doesn't matter as the version of the git repository will already be greater or match the maximum version published on crates.io, but it's important to keep this in mind!\n+\n+This says that when we updated the submodule, the version number in our\n+`src/tools/rustfmt/Cargo.toml` changed. The new version is different from\n+the version in `Cargo.lock`, so the build can no longer continue.\n+\n+To resolve this, we need to update `Cargo.lock`. Luckily, cargo provides a\n+command to do this easily.\n+\n+First, go into the `src/` directory since that is where `Cargo.toml` is in\n+the rust repository. Then run, `cargo update -p rustfmt-nightly` to solve\n+the problem.\n+\n+```\n+$ cd src\n+$ cargo update -p rustfmt-nightly\n+```\n \n-It can also be more convenient during development to set `submodules = false`\n-in the `config.toml` to prevent `x.py` from resetting to the original branch.\n+This should change the version listed in `src/Cargo.lock` to the new version you updated\n+the submodule to. Running `./x.py build` should work now.\n \n ## Writing Documentation\n+[writing-documentation]: #writing-documentation\n \n Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n is located in `src/doc` in the tree, and standard API documentation is generated\n@@ -370,6 +507,7 @@ reference to `doc/reference.html`. The CSS might be messed up, but you can\n verify that the HTML is right.\n \n ## Issue Triage\n+[issue-triage]: #issue-triage\n \n Sometimes, an issue will stay open, even though the bug has been fixed. And\n sometimes, the original bug may go stale because something has changed in the\n@@ -437,6 +575,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n \n ## Out-of-tree Contributions\n+[out-of-tree-contributions]: #out-of-tree-contributions\n \n There are a number of other ways to contribute to Rust that don't deal with\n this repository.\n@@ -456,6 +595,7 @@ valuable!\n [community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library\n \n ## Helpful Links and Information\n+[helpful-info]: #helpful-info\n \n For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information"}, {"sha": "589aa1afe35ec7389bcafc875ffb130826af80ba", "filename": "README.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -6,14 +6,17 @@ standard library, and documentation.\n [Rust]: https://www.rust-lang.org\n \n ## Quick Start\n+[quick-start]: #quick-start\n \n Read [\"Installation\"] from [The Book].\n \n [\"Installation\"]: https://doc.rust-lang.org/book/second-edition/ch01-01-installation.html\n [The Book]: https://doc.rust-lang.org/book/index.html\n \n ## Building from Source\n+[building-from-source]: #building-from-source\n \n+### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 4.7 or later or `clang++` 3.x or later\n@@ -52,6 +55,7 @@ Read [\"Installation\"] from [The Book].\n [Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n+[building-on-windows]: #building-on-windows\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n@@ -61,6 +65,7 @@ for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n build.\n \n #### MinGW\n+[windows-mingw]: #windows-mingw\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n@@ -101,6 +106,7 @@ build.\n    ```\n \n #### MSVC\n+[windows-msvc]: #windows-msvc\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2013\n (or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n@@ -123,7 +129,11 @@ CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.\n python x.py build\n ```\n \n+If you are seeing build failure when compiling `rustc_binaryen`, make sure the path\n+length of the rust folder is not longer than 22 characters.\n+\n #### Specifying an ABI\n+[specifying-an-abi]: #specifying-an-abi\n \n Each specific ABI can also be used from either environment (for example, using\n the GNU ABI in powershell) by using an explicit build triple. The available\n@@ -141,6 +151,7 @@ in Building From Source), and modifying the `build` option under the `[build]`\n section.\n \n ### Configure and Make\n+[configure-and-make]: #configure-and-make\n \n While it's not the recommended build system, this project also provides a\n configure script and makefile (the latter of which just invokes `x.py`).\n@@ -155,6 +166,7 @@ When using the configure script, the generated `config.mk` file may override the\n `config.mk` file.\n \n ## Building Documentation\n+[building-documentation]: #building-documentation\n \n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n@@ -167,6 +179,7 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n `build\\x86_64-pc-windows-msvc\\doc`.\n \n ## Notes\n+[notes]: #notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n precompiled \"snapshot\" version of itself (made in an earlier state of\n@@ -184,14 +197,15 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-Rust currently needs between 600MiB and 1.5GiB to build, depending on platform.\n+Rust currently needs between 600MiB and 1.5GiB of RAM to build, depending on platform.\n If it hits swap, it will take a very long time to build.\n \n There is more advice about hacking on Rust in [CONTRIBUTING.md].\n \n [CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n \n ## Getting Help\n+[getting-help]: #getting-help\n \n The Rust community congregates in a few places:\n \n@@ -204,6 +218,7 @@ The Rust community congregates in a few places:\n [users.rust-lang.org]: https://users.rust-lang.org/\n \n ## Contributing\n+[contributing]: #contributing\n \n To contribute to Rust, please see [CONTRIBUTING](CONTRIBUTING.md).\n \n@@ -217,6 +232,7 @@ Rust. And a good place to ask for help would be [#rust-beginners].\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n \n ## License\n+[license]: #license\n \n Rust is primarily distributed under the terms of both the MIT license\n and the Apache License (Version 2.0), with portions covered by various"}, {"sha": "57434ebc1f60077a2a866bd4af261724d21f0578", "filename": "RELEASES.md", "status": "modified", "additions": 201, "deletions": 11, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,3 +1,193 @@\n+Version 1.22.1 (2017-11-22)\n+==========================\n+\n+- [Update Cargo to fix an issue with macOS 10.13 \"High Sierra\"][46183]\n+\n+[46183]: https://github.com/rust-lang/rust/pull/46183\n+\n+Version 1.22.0 (2017-11-22)\n+==========================\n+\n+Language\n+--------\n+- [`non_snake_case` lint now allows extern no-mangle functions][44966]\n+- [Now accepts underscores in unicode escapes][43716]\n+- [`T op= &T` now works for numeric types.][44287] eg. `let mut x = 2; x += &8;`\n+- [types that impl `Drop` are now allowed in `const` and `static` types][44456]\n+\n+Compiler\n+--------\n+- [rustc now defaults to having 16 codegen units at debug on supported platforms.][45064]\n+- [rustc will no longer inline in codegen units when compiling for debug][45075]\n+  This should decrease compile times for debug builds.\n+- [strict memory alignment now enabled on ARMv6][45094]\n+- [Remove support for the PNaCl target `le32-unknown-nacl`][45041]\n+\n+Libraries\n+---------\n+- [Allow atomic operations up to 32 bits\n+  on `armv5te_unknown_linux_gnueabi`][44978]\n+- [`Box<Error>` now impls `From<Cow<str>>`][44466]\n+- [`std::mem::Discriminant` is now guaranteed to be `Send + Sync`][45095]\n+- [`fs::copy` now returns the length of the main stream on NTFS.][44895]\n+- [Properly detect overflow in `Instant += Duration`.][44220]\n+- [impl `Hasher` for `{&mut Hasher, Box<Hasher>}`][44015]\n+- [impl `fmt::Debug` for `SplitWhitespace`.][44303]\n+- [`Option<T>` now impls `Try`][42526] This allows for using `?` with `Option` types.\n+\n+Stabilized APIs\n+---------------\n+\n+Cargo\n+-----\n+- [Cargo will now build multi file examples in subdirectories of the `examples`\n+  folder that have a `main.rs` file.][cargo/4496]\n+- [Changed `[root]` to `[package]` in `Cargo.lock`][cargo/4571] Packages with\n+  the old format will continue to work and can be updated with `cargo update`.\n+- [Now supports vendoring git repositories][cargo/3992]\n+\n+Misc\n+----\n+- [`libbacktrace` is now available on Apple platforms.][44251]\n+- [Stabilised the `compile_fail` attribute for code fences in doc-comments.][43949]\n+  This now lets you specify that a given code example will fail to compile.\n+\n+Compatibility Notes\n+-------------------\n+- [The minimum Android version that rustc can build for has been bumped\n+  to `4.0` from `2.3`][45656]\n+- [Allowing `T op= &T` for numeric types has broken some type\n+  inference cases][45480]\n+\n+\n+[42526]: https://github.com/rust-lang/rust/pull/42526\n+[43017]: https://github.com/rust-lang/rust/pull/43017\n+[43716]: https://github.com/rust-lang/rust/pull/43716\n+[43949]: https://github.com/rust-lang/rust/pull/43949\n+[44015]: https://github.com/rust-lang/rust/pull/44015\n+[44220]: https://github.com/rust-lang/rust/pull/44220\n+[44251]: https://github.com/rust-lang/rust/pull/44251\n+[44287]: https://github.com/rust-lang/rust/pull/44287\n+[44303]: https://github.com/rust-lang/rust/pull/44303\n+[44456]: https://github.com/rust-lang/rust/pull/44456\n+[44466]: https://github.com/rust-lang/rust/pull/44466\n+[44895]: https://github.com/rust-lang/rust/pull/44895\n+[44966]: https://github.com/rust-lang/rust/pull/44966\n+[44978]: https://github.com/rust-lang/rust/pull/44978\n+[45041]: https://github.com/rust-lang/rust/pull/45041\n+[45064]: https://github.com/rust-lang/rust/pull/45064\n+[45075]: https://github.com/rust-lang/rust/pull/45075\n+[45094]: https://github.com/rust-lang/rust/pull/45094\n+[45095]: https://github.com/rust-lang/rust/pull/45095\n+[45480]: https://github.com/rust-lang/rust/issues/45480\n+[45656]: https://github.com/rust-lang/rust/pull/45656\n+[cargo/3992]: https://github.com/rust-lang/cargo/pull/3992\n+[cargo/4496]: https://github.com/rust-lang/cargo/pull/4496\n+[cargo/4571]: https://github.com/rust-lang/cargo/pull/4571\n+\n+\n+\n+\n+\n+\n+Version 1.21.0 (2017-10-12)\n+==========================\n+\n+Language\n+--------\n+- [You can now use static references for literals.][43838]\n+  Example:\n+  ```rust\n+  fn main() {\n+      let x: &'static u32 = &0;\n+  }\n+  ```\n+- [Relaxed path syntax. Optional `::` before `<` is now allowed in all contexts.][43540]\n+  Example:\n+  ```rust\n+  my_macro!(Vec<i32>::new); // Always worked\n+  my_macro!(Vec::<i32>::new); // Now works\n+  ```\n+\n+Compiler\n+--------\n+- [Upgraded jemalloc to 4.5.0][43911]\n+- [Enabled unwinding panics on Redox][43917]\n+- [Now runs LLVM in parallel during translation phase.][43506]\n+  This should reduce peak memory usage.\n+\n+Libraries\n+---------\n+- [Generate builtin impls for `Clone` for all arrays and tuples that\n+  are `T: Clone`][43690]\n+- [`Stdin`, `Stdout`, and `Stderr` now implement `AsRawFd`.][43459]\n+- [`Rc` and `Arc` now implement `From<&[T]> where T: Clone`, `From<str>`,\n+  `From<String>`, `From<Box<T>> where T: ?Sized`, and `From<Vec<T>>`.][42565]\n+\n+Stabilized APIs\n+---------------\n+\n+[`std::mem::discriminant`]\n+\n+Cargo\n+-----\n+- [You can now call `cargo install` with multiple package names][cargo/4216]\n+- [Cargo commands inside a virtual workspace will now implicitly\n+  pass `--all`][cargo/4335]\n+- [Added a `[patch]` section to `Cargo.toml` to handle\n+  prepublication dependencies][cargo/4123] [RFC 1969]\n+- [`include` & `exclude` fields in `Cargo.toml` now accept gitignore\n+  like patterns][cargo/4270]\n+- [Added the `--all-targets` option][cargo/4400]\n+- [Using required dependencies as a feature is now deprecated and emits\n+  a warning][cargo/4364]\n+\n+\n+Misc\n+----\n+- [Cargo docs are moving][43916]\n+  to [doc.rust-lang.org/cargo](https://doc.rust-lang.org/cargo)\n+- [The rustdoc book is now available][43863]\n+  at [doc.rust-lang.org/rustdoc](https://doc.rust-lang.org/rustdoc)\n+- [Added a preview of RLS has been made available through rustup][44204]\n+  Install with `rustup component add rls-preview`\n+- [`std::os` documentation for Unix, Linux, and Windows now appears on doc.rust-lang.org][43348]\n+  Previously only showed `std::os::unix`.\n+\n+Compatibility Notes\n+-------------------\n+- [Changes in method matching against higher-ranked types][43880] This may cause\n+  breakage in subtyping corner cases. [A more in-depth explanation is available.][info/43880]\n+- [rustc's JSON error output's byte position start at top of file.][42973]\n+  Was previously relative to the rustc's internal `CodeMap` struct which\n+  required the unstable library `libsyntax` to correctly use.\n+- [`unused_results` lint no longer ignores booleans][43728]\n+\n+[42565]: https://github.com/rust-lang/rust/pull/42565\n+[42973]: https://github.com/rust-lang/rust/pull/42973\n+[43348]: https://github.com/rust-lang/rust/pull/43348\n+[43459]: https://github.com/rust-lang/rust/pull/43459\n+[43506]: https://github.com/rust-lang/rust/pull/43506\n+[43540]: https://github.com/rust-lang/rust/pull/43540\n+[43690]: https://github.com/rust-lang/rust/pull/43690\n+[43728]: https://github.com/rust-lang/rust/pull/43728\n+[43838]: https://github.com/rust-lang/rust/pull/43838\n+[43863]: https://github.com/rust-lang/rust/pull/43863\n+[43880]: https://github.com/rust-lang/rust/pull/43880\n+[43911]: https://github.com/rust-lang/rust/pull/43911\n+[43916]: https://github.com/rust-lang/rust/pull/43916\n+[43917]: https://github.com/rust-lang/rust/pull/43917\n+[44204]: https://github.com/rust-lang/rust/pull/44204\n+[cargo/4123]: https://github.com/rust-lang/cargo/pull/4123\n+[cargo/4216]: https://github.com/rust-lang/cargo/pull/4216\n+[cargo/4270]: https://github.com/rust-lang/cargo/pull/4270\n+[cargo/4335]: https://github.com/rust-lang/cargo/pull/4335\n+[cargo/4364]: https://github.com/rust-lang/cargo/pull/4364\n+[cargo/4400]: https://github.com/rust-lang/cargo/pull/4400\n+[RFC 1969]: https://github.com/rust-lang/rfcs/pull/1969\n+[info/43880]: https://github.com/rust-lang/rust/issues/44224#issuecomment-330058902\n+[`std::mem::discriminant`]: https://doc.rust-lang.org/std/mem/fn.discriminant.html\n+\n Version 1.20.0 (2017-08-31)\n ===========================\n \n@@ -110,7 +300,7 @@ Compatibility Notes\n - [Functions with `'static` in their return types will now not be as usable as\n   if they were using lifetime parameters instead.][42417]\n - [The reimplementation of `{f32, f64}::is_sign_{negative, positive}` now\n-  takes the sign of NaN into account where previously didn't.][42430] \n+  takes the sign of NaN into account where previously didn't.][42430]\n \n [42033]: https://github.com/rust-lang/rust/pull/42033\n [42155]: https://github.com/rust-lang/rust/pull/42155\n@@ -438,7 +628,7 @@ Misc\n ----\n \n - [rustdoc can now use pulldown-cmark with the `--enable-commonmark` flag][40338]\n-- [Added rust-winbg script for better debugging on Windows][39983]\n+- [Added rust-windbg script for better debugging on Windows][39983]\n - [Rust now uses the official cross compiler for NetBSD][40612]\n - [rustdoc now accepts `#` at the start of files][40828]\n - [Fixed jemalloc support for musl][41168]\n@@ -1472,7 +1662,7 @@ Diagnostics\n -----------\n \n * [Replace macro backtraces with labeled local uses][35702]\n-* [Improve error message for missplaced doc comments][33922]\n+* [Improve error message for misplaced doc comments][33922]\n * [Buffer unix and lock windows to prevent message interleaving][35975]\n * [Update lifetime errors to specifically note temporaries][36171]\n * [Special case a few colors for Windows][36178]\n@@ -1780,7 +1970,7 @@ Language\n   useful](https://github.com/rust-lang/rust/pull/34908)\n * [`macro_rules!` `stmt` matchers correctly consume the entire contents when\n   inside non-braces invocations](https://github.com/rust-lang/rust/pull/34886)\n-* [Semicolons are properly required as statement delimeters inside\n+* [Semicolons are properly required as statement delimiters inside\n   `macro_rules!` invocations](https://github.com/rust-lang/rust/pull/34660)\n * [`cfg_attr` works on `path` attributes](https://github.com/rust-lang/rust/pull/34546)\n \n@@ -2005,7 +2195,7 @@ Compatibility Notes\n * [`const`s and `static`s may not have unsized types](https://github.com/rust-lang/rust/pull/34443)\n * [The new follow-set rules that place restrictions on `macro_rules!`\n   in order to ensure syntax forward-compatibility have been enabled](https://github.com/rust-lang/rust/pull/33982)\n-  This was an [ammendment to RFC 550](https://github.com/rust-lang/rfcs/pull/1384),\n+  This was an [amendment to RFC 550](https://github.com/rust-lang/rfcs/pull/1384),\n   and has been a warning since 1.10.\n * [`cfg` attribute process has been refactored to fix various bugs](https://github.com/rust-lang/rust/pull/33706).\n   This causes breakage in some corner cases.\n@@ -3162,7 +3352,7 @@ Libraries\n * `FromStr` is [implemented for `SockAddrV4` and `SockAddrV6`][1.5s].\n * There are now `From` conversions [between floating point\n   types][1.5f] where the conversions are lossless.\n-* Thera are now `From` conversions [between integer types][1.5i] where\n+* There are now `From` conversions [between integer types][1.5i] where\n   the conversions are lossless.\n * [`fs::Metadata` implements `Clone`][1.5fs].\n * The `parse` method [accepts a leading \"+\" when parsing\n@@ -3362,7 +3552,7 @@ Libraries\n * [`IntoIterator` is implemented for references to `Option` and\n   `Result`][into2].\n * [`HashMap` and `HashSet` implement `Extend<&T>` where `T:\n-  Copy`][ext] as part of [RFC 839]. This will cause type inferance\n+  Copy`][ext] as part of [RFC 839]. This will cause type inference\n   breakage in rare situations.\n * [`BinaryHeap` implements `Debug`][bh2].\n * [`Borrow` and `BorrowMut` are implemented for fixed-size\n@@ -3373,7 +3563,7 @@ Libraries\n * `&mut T` where `T: std::fmt::Write` [also implements\n   `std::fmt::Write`][mutw].\n * [A stable regression in `VecDeque::push_back` and other\n-  capicity-altering methods that caused panics for zero-sized types\n+  capacity-altering methods that caused panics for zero-sized types\n   was fixed][vd].\n * [Function pointers implement traits for up to 12 parameters][fp2].\n \n@@ -3560,7 +3750,7 @@ Libraries\n   [better for long data][sh].\n * [`AtomicPtr`] implements [`Send`].\n * The [`read_to_end`] implementations for [`Stdin`] and [`File`]\n-  are now [specialized to use uninitalized buffers for increased\n+  are now [specialized to use uninitialized buffers for increased\n   performance][rte].\n * Lifetime parameters of foreign functions [are now resolved\n   properly][f].\n@@ -3689,7 +3879,7 @@ Highlights\n * This is the first release with [experimental support for linking\n   with the MSVC linker and lib C on Windows (instead of using the GNU\n   variants via MinGW)][win]. It is yet recommended only for the most\n-  intrepid Rusticians.\n+  intrepid Rustaceans.\n * Benchmark compilations are showing a 30% improvement in\n   bootstrapping over 1.1.\n \n@@ -4555,7 +4745,7 @@ Version 0.11.0 (2014-07-02)\n   * Libraries\n     * The standard library is now a \"facade\" over a number of underlying\n       libraries. This means that development on the standard library should\n-      be speeder due to smaller crates, as well as a clearer line between\n+      be speedier due to smaller crates, as well as a clearer line between\n       all dependencies.\n     * A new library, libcore, lives under the standard library's facade\n       which is Rust's \"0-assumption\" library, suitable for embedded and"}, {"sha": "b8fd479d0f149b4415e3453b9a0e7cace775113b", "filename": "appveyor.yml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -25,6 +25,11 @@ environment:\n     RUST_CHECK_TARGET: check-aux\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n+  # MSVC tools tests\n+  - MSYS_BITS: 64\n+    SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py toolstates.json\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=toolstates.json\n+\n   # 32/64-bit MinGW builds.\n   #\n   # We are using MinGW with posix threads since LLVM does not compile with"}, {"sha": "18c1f160c03d28eb1cc1cbea804e89551fef51cd", "filename": "config.toml.example", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -35,7 +35,7 @@\n # If an external LLVM root is specified, we automatically check the version by\n # default to make sure it's within the range that we're expecting, but setting\n # this flag will indicate that this version check should not be done.\n-#version-check = false\n+#version-check = true\n \n # Link libstdc++ statically into the librustc_llvm instead of relying on a\n # dynamic version to be available.\n@@ -60,10 +60,9 @@\n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n-# on them will not work unless the user opts in to building them. Possible\n-# experimental LLVM targets include WebAssembly for the\n-# wasm32-experimental-emscripten Rust target.\n-#experimental-targets = \"\"\n+# on them will not work unless the user opts in to building them. By default the\n+# `WebAssembly` target is enabled when compiling LLVM from scratch.\n+#experimental-targets = \"WebAssembly\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -203,6 +202,16 @@\n # Where to install man pages in `prefix` above\n #mandir = \"share/man\"\n \n+# Where to install data in `prefix` above (currently unused)\n+#datadir = \"share\"\n+\n+# Where to install additional info in `prefix` above (currently unused)\n+#infodir = \"share/info\"\n+\n+# Where to install local state (currently unused)\n+# If this is a relative path, it will get installed in `prefix` above\n+#localstatedir = \"/var/lib\"\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # =============================================================================\n@@ -250,14 +259,11 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n-# The default linker that will be used by the generated compiler. Note that this\n-# is not the linker used to link said compiler.\n+# The default linker that will be hard-coded into the generated compiler for\n+# targets that don't specify linker explicitly in their target specifications.\n+# Note that this is not the linker used to link said compiler.\n #default-linker = \"cc\"\n \n-# The default ar utility that will be used by the generated compiler if LLVM\n-# cannot be used. Note that this is not used to assemble said compiler.\n-#default-ar = \"ar\"\n-\n # The \"channel\" for the Rust build to produce. The stable/beta channels only\n # allow using stable features, whereas the nightly and dev channels allow using\n # nightly features\n@@ -295,6 +301,10 @@\n # As a side-effect also generates MIR for all libraries.\n #test-miri = false\n \n+# After building or testing extended tools (e.g. clippy and rustfmt), append the\n+# result (broken, compiling, testing) into this JSON file.\n+#save-toolstates = \"/path/to/toolstates.json\"\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -303,7 +313,7 @@\n # =============================================================================\n [target.x86_64-unknown-linux-gnu]\n \n-# C compiler to be used to compiler C code and link Rust code. Note that the\n+# C compiler to be used to compiler C code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n #cc = \"cc\"\n@@ -312,6 +322,15 @@\n # This is only used for host targets.\n #cxx = \"c++\"\n \n+# Archiver to be used to assemble static libraries compiled from C/C++ code.\n+# Note: an absolute path should be used, otherwise LLVM build will break.\n+#ar = \"ar\"\n+\n+# Linker to be used to link Rust code. Note that the\n+# default value is platform specific, and if not specified it may also depend on\n+# what platform is crossing to what platform.\n+#linker = \"cc\"\n+\n # Path to the `llvm-config` binary of the installation of a custom LLVM to link\n # against. Note that if this is specifed we don't compile LLVM at all for this\n # target."}, {"sha": "bfb442ce3db95958c959f02739b42ae3956a79ea", "filename": "src/Cargo.lock", "status": "modified", "additions": 674, "deletions": 464, "changes": 1138, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "abe1fe5a6de01da8d1d28bcc11ec9a6517e174df", "filename": "src/Cargo.toml", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,6 +5,7 @@ members = [\n   \"libstd\",\n   \"libtest\",\n   \"tools/cargotest\",\n+  \"tools/clippy\",\n   \"tools/compiletest\",\n   \"tools/error_index_generator\",\n   \"tools/linkchecker\",\n@@ -20,25 +21,19 @@ members = [\n   \"tools/rls\",\n   \"tools/rustfmt\",\n   # FIXME(https://github.com/rust-lang/cargo/issues/4089): move these to exclude\n+  \"tools/rls/test_data/bin_lib\",\n   \"tools/rls/test_data/borrow_error\",\n-  \"tools/rls/test_data/completion\",\n-  \"tools/rls/test_data/find_all_refs\",\n+  \"tools/rls/test_data/common\",\n+  \"tools/rls/test_data/deglob\",\n+  \"tools/rls/test_data/features\",\n   \"tools/rls/test_data/find_all_refs_no_cfg_test\",\n-  \"tools/rls/test_data/goto_def\",\n-  \"tools/rls/test_data/highlight\",\n-  \"tools/rls/test_data/hover\",\n-  \"tools/rls/test_data/rename\",\n-  \"tools/rls/test_data/reformat\",\n-  \"tools/rls/test_data/bin_lib_no_cfg_test\",\n-  \"tools/rls/test_data/multiple_bins\",\n-  \"tools/rls/test_data/bin_lib\",\n-  \"tools/rls/test_data/reformat_with_range\",\n   \"tools/rls/test_data/find_impls\",\n   \"tools/rls/test_data/infer_bin\",\n   \"tools/rls/test_data/infer_custom_bin\",\n   \"tools/rls/test_data/infer_lib\",\n-  \"tools/rls/test_data/omit_init_build\",\n-  \"tools/rls/test_data/unic\u00f8d\u00eb\",\n+  \"tools/rls/test_data/multiple_bins\",\n+  \"tools/rls/test_data/reformat\",\n+  \"tools/rls/test_data/reformat_with_range\",\n   \"tools/rls/test_data/workspace_symbol\",\n ]\n "}, {"sha": "1c9bf65aa0e371b84755a8ddd6e79497fac57171", "filename": "src/binaryen", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1 @@\n+Subproject commit 1c9bf65aa0e371b84755a8ddd6e79497fac57171"}, {"sha": "bbbbf0e1915555c419039a827eb1703a8c267c4e", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -34,7 +34,7 @@ cmake = \"0.1.23\"\n filetime = \"0.1\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n libc = \"0.2\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\""}, {"sha": "9ff681ac680874b09b35122160f7807025d4b1cc", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -39,7 +39,7 @@ The script accepts commands, flags, and arguments to determine what to do:\n   ```\n \n   If files are dirty that would normally be rebuilt from stage 0, that can be\n-  overidden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n+  overridden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n   that belong to stage n or earlier:\n \n   ```\n@@ -126,17 +126,17 @@ install a nightly, presumably using `rustup`. You will then want to\n configure your directory to use this build, like so:\n \n ```\n-# configure to use local rust instead of downloding a beta.\n+# configure to use local rust instead of downloading a beta.\n # `--local-rust-root` is optional here. If elided, we will\n # use whatever rustc we find on your PATH.\n-> configure --enable-rustbuild --local-rust-root=~/.cargo/ --enable-local-rebuild\n+> ./configure --local-rust-root=~/.cargo/ --enable-local-rebuild\n ```\n \n After that, you can use the `--incremental` flag to actually do\n incremental builds:\n \n ```\n-> ../x.py build --incremental\n+> ./x.py build --incremental\n ```\n \n The `--incremental` flag will store incremental compilation artifacts"}, {"sha": "631c9f72f3500b47860a8baaf89e6133bc00842c", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -31,8 +31,6 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::io;\n-use std::io::prelude::*;\n use std::str::FromStr;\n use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n@@ -122,19 +120,14 @@ fn main() {\n             cmd.arg(\"-L\").arg(&root);\n         }\n \n-        // Pass down extra flags, commonly used to configure `-Clinker` when\n-        // cross compiling.\n-        if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n-            cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+        // Override linker if necessary.\n+        if let Ok(target_linker) = env::var(\"RUSTC_TARGET_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n         // Pass down incremental directory, if any.\n         if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n             cmd.arg(format!(\"-Zincremental={}\", dir));\n-\n-            if verbose > 0 {\n-                cmd.arg(\"-Zincremental-info\");\n-            }\n         }\n \n         let crate_name = args.windows(2)\n@@ -182,12 +175,16 @@ fn main() {\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n+        if env::var(\"RUSTC_THINLTO\").is_ok() {\n+            cmd.arg(\"-Ccodegen-units=16\").arg(\"-Zthinlto\");\n+        }\n \n         // Emit save-analysis info.\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n             cmd.arg(\"-Zsave-analysis\");\n             cmd.env(\"RUST_SAVE_ANALYSIS_CONFIG\",\n-                    \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\"pub_only\\\": true,\\\n+                    \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n+                     \\\"pub_only\\\": true,\\\"reachable_only\\\": false,\\\n                      \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\");\n         }\n \n@@ -258,6 +255,11 @@ fn main() {\n         if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n             cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n         }\n+    } else {\n+        // Override linker if necessary.\n+        if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", host_linker));\n+        }\n     }\n \n     let color = match env::var(\"RUSTC_COLOR\") {\n@@ -270,7 +272,7 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        writeln!(&mut io::stderr(), \"rustc command: {:?}\", cmd).unwrap();\n+        eprintln!(\"rustc command: {:?}\", cmd);\n     }\n \n     // Actually run the compiler!"}, {"sha": "4e975adc9721cdef87aac309521056c7816ba39c", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -47,6 +47,17 @@ fn main() {\n     if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n+    if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n+        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+    }\n+\n+    // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick\n+    // it up so we can make rustdoc print this into the docs\n+    if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n+        // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n+        cmd.arg(\"-Z\").arg(\"unstable-options\")\n+           .arg(\"--crate-version\").arg(version);\n+    }\n \n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),"}, {"sha": "707aceebb1eda99ed8eeacf5cfe345903a7b0d4f", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,7 +8,7 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-from __future__ import print_function\n+from __future__ import absolute_import, division, print_function\n import argparse\n import contextlib\n import datetime\n@@ -294,14 +294,15 @@ def default_build_triple():\n             raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n         # only the n64 ABI is supported, indicate it\n         ostype += 'abi64'\n-    elif cputype == 'sparcv9':\n+    elif cputype == 'sparcv9' or cputype == 'sparc64':\n         pass\n     else:\n         err = \"unknown cpu type: {}\".format(cputype)\n         sys.exit(err)\n \n     return \"{}-{}\".format(cputype, ostype)\n \n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -498,7 +499,7 @@ def get_toml(self, key):\n \n         If the key does not exists, the result is None:\n \n-        >>> rb.get_toml(\"key3\") == None\n+        >>> rb.get_toml(\"key3\") is None\n         True\n         \"\"\"\n         for line in self.config_toml.splitlines():\n@@ -531,7 +532,7 @@ def program_config(self, program):\n         \"\"\"\n         config = self.get_toml(program)\n         if config:\n-            return config\n+            return os.path.expanduser(config)\n         return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n@@ -647,7 +648,8 @@ def update_submodules(self):\n                       if not ((module.endswith(\"llvm\") and\n                                self.get_toml('llvm-config')) or\n                               (module.endswith(\"jemalloc\") and\n-                               self.get_toml('jemalloc')))]\n+                               (self.get_toml('use-jemalloc') == \"false\" or\n+                                self.get_toml('jemalloc'))))]\n         run([\"git\", \"submodule\", \"update\",\n              \"--init\", \"--recursive\"] + submodules,\n             cwd=self.rust_root, verbose=self.verbose)"}, {"sha": "4db7e2ec016f0c5ef145ba850a3f0bc86cd9c8e9", "filename": "src/bootstrap/bootstrap_test.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -10,6 +10,7 @@\n \n \"\"\"Bootstrap tests\"\"\"\n \n+from __future__ import absolute_import, division, print_function\n import os\n import doctest\n import unittest"}, {"sha": "dcffc83c4b6f6a28e695ce69abe4822c8dec5113", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -261,9 +261,10 @@ impl<'a> Builder<'a> {\n                 doc::Reference, doc::Rustdoc, doc::CargoBook),\n             Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n                 dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Extended, dist::HashSign, dist::DontDistWithMiriEnabled),\n+                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign,\n+                dist::DontDistWithMiriEnabled),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n-                install::Analysis, install::Src, install::Rustc),\n+                install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }\n     }\n \n@@ -306,7 +307,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n-            Subcommand::Clean => panic!(),\n+            Subcommand::Clean { .. } => panic!(),\n         };\n \n         let builder = Builder {\n@@ -413,12 +414,15 @@ impl<'a> Builder<'a> {\n     pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n-        cmd\n-            .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n-            .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(host));\n+        cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n+           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+           .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n+           .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n+           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+           .env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+        if let Some(linker) = self.build.linker(host) {\n+            cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n+        }\n         cmd\n     }\n \n@@ -468,8 +472,6 @@ impl<'a> Builder<'a> {\n              .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.rustc(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_CODEGEN_UNITS\",\n-                  self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n                   self.config.rust_debug_assertions.to_string())\n              .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n@@ -481,15 +483,23 @@ impl<'a> Builder<'a> {\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n              })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+             .env(\"TEST_MIRI\", self.config.test_miri.to_string());\n+\n+        if let Some(n) = self.config.rust_codegen_units {\n+            cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n+        }\n+\n+        if let Some(host_linker) = self.build.linker(compiler.host) {\n+            cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n+        }\n+        if let Some(target_linker) = self.build.linker(target) {\n+            cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n+        }\n+        cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+            .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n \n         if mode != Mode::Tool {\n-            // Tools don't get debuginfo right now, e.g. cargo and rls don't\n-            // get compiled with debuginfo.\n-            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n-                 .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n-                 .env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n+            cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n             // then other crates can depend on the compiler (e.g. proc-macro\n@@ -556,24 +566,45 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n-        // Specify some various options for build scripts used throughout\n-        // the build.\n+        // Throughout the build Cargo can execute a number of build scripts\n+        // compiling C/C++ code and we need to pass compilers, archivers, flags, etc\n+        // obtained previously to those build scripts.\n+        // Build scripts use either the `cc` crate or `configure/make` so we pass\n+        // the options through environment variables that are fetched and understood by both.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n+            let cc = self.cc(target);\n+            cargo.env(format!(\"CC_{}\", target), cc)\n+                 .env(\"CC\", cc);\n+\n+            let cflags = self.cflags(target).join(\" \");\n+            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                 .env(\"CFLAGS\", cflags.clone());\n+\n+            if let Some(ar) = self.ar(target) {\n+                let ranlib = format!(\"{} s\", ar.display());\n+                cargo.env(format!(\"AR_{}\", target), ar)\n+                     .env(\"AR\", ar)\n+                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                     .env(\"RANLIB\", ranlib);\n+            }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                 cargo.env(format!(\"CXX_{}\", target), cxx);\n+                cargo.env(format!(\"CXX_{}\", target), cxx)\n+                     .env(\"CXX\", cxx)\n+                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                     .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n         if mode == Mode::Libstd && self.config.extended && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n+        // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n+        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+\n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n@@ -582,12 +613,20 @@ impl<'a> Builder<'a> {\n         // Set this for all builds to make sure doc builds also get it.\n         cargo.env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel);\n \n-        if self.is_verbose() {\n+        if self.is_very_verbose() {\n             cargo.arg(\"-v\");\n         }\n-        // FIXME: cargo bench does not accept `--release`\n-        if self.config.rust_optimize && cmd != \"bench\" {\n-            cargo.arg(\"--release\");\n+        if self.config.rust_optimize {\n+            // FIXME: cargo bench does not accept `--release`\n+            if cmd != \"bench\" {\n+                cargo.arg(\"--release\");\n+            }\n+\n+            if self.config.rust_codegen_units.is_none() &&\n+               self.build.is_rust_llvm(compiler.host)\n+            {\n+                cargo.env(\"RUSTC_THINLTO\", \"1\");\n+            }\n         }\n         if self.config.locked_deps {\n             cargo.arg(\"--locked\");"}, {"sha": "e531fdaf2923bd4048e2ae35f99dae2eb83e7f20", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 76, "deletions": 11, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -31,20 +31,51 @@\n //! ever be probed for. Instead the compilers found here will be used for\n //! everything.\n \n+use std::collections::HashSet;\n+use std::{env, iter};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::iter;\n \n-use build_helper::{cc2ar, output};\n+use build_helper::output;\n use cc;\n \n use Build;\n use config::Target;\n use cache::Interned;\n \n+// The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n+// so use some simplified logic here. First we respect the environment variable `AR`, then\n+// try to infer the archiver path from the C compiler path.\n+// In the future this logic should be replaced by calling into the `cc` crate.\n+fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n+    if let Some(ar) = env::var_os(\"AR\") {\n+        Some(PathBuf::from(ar))\n+    } else if target.contains(\"msvc\") {\n+        None\n+    } else if target.contains(\"musl\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"openbsd\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else {\n+        let parent = cc.parent().unwrap();\n+        let file = cc.file_name().unwrap().to_str().unwrap();\n+        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n+            if let Some(idx) = file.rfind(suffix) {\n+                let mut file = file[..idx].to_owned();\n+                file.push_str(\"ar\");\n+                return Some(parent.join(&file));\n+            }\n+        }\n+        Some(parent.join(file))\n+    }\n+}\n+\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n+    let targets = build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build))\n+                               .collect::<HashSet<_>>();\n+    for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n@@ -53,28 +84,35 @@ pub fn find(build: &mut Build) {\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", target, config, build);\n+            set_compiler(&mut cfg, Language::C, target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n-        let ar = cc2ar(compiler.path(), &target);\n+        let ar = if let ar @ Some(..) = config.and_then(|c| c.ar.clone()) {\n+            ar\n+        } else {\n+            cc2ar(compiler.path(), &target)\n+        };\n+\n         build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n-        if let Some(ref ar) = ar {\n+        build.cc.insert(target, compiler);\n+        if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.ar.insert(target, ar);\n         }\n-        build.cc.insert(target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n+    let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n+    for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", host, config, build);\n+            set_compiler(&mut cfg, Language::CPlusPlus, host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n@@ -83,7 +121,7 @@ pub fn find(build: &mut Build) {\n }\n \n fn set_compiler(cfg: &mut cc::Build,\n-                gnu_compiler: &str,\n+                compiler: Language,\n                 target: Interned<String>,\n                 config: Option<&Target>,\n                 build: &Build) {\n@@ -94,7 +132,7 @@ fn set_compiler(cfg: &mut cc::Build,\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n                 let target = target.replace(\"armv7\", \"arm\");\n-                let compiler = format!(\"{}-{}\", target, gnu_compiler);\n+                let compiler = format!(\"{}-{}\", target, compiler.clang());\n                 cfg.compiler(ndk.join(\"bin\").join(compiler));\n             }\n         }\n@@ -103,6 +141,7 @@ fn set_compiler(cfg: &mut cc::Build,\n         // which is a gcc version from ports, if this is the case.\n         t if t.contains(\"openbsd\") => {\n             let c = cfg.get_compiler();\n+            let gnu_compiler = compiler.gcc();\n             if !c.path().ends_with(gnu_compiler) {\n                 return\n             }\n@@ -145,3 +184,29 @@ fn set_compiler(cfg: &mut cc::Build,\n         _ => {}\n     }\n }\n+\n+/// The target programming language for a native compiler.\n+enum Language {\n+    /// The compiler is targeting C.\n+    C,\n+    /// The compiler is targeting C++.\n+    CPlusPlus,\n+}\n+\n+impl Language {\n+    /// Obtains the name of a compiler in the GCC collection.\n+    fn gcc(self) -> &'static str {\n+        match self {\n+            Language::C => \"gcc\",\n+            Language::CPlusPlus => \"g++\",\n+        }\n+    }\n+\n+    /// Obtains the name of a compiler in the clang suite.\n+    fn clang(self) -> &'static str {\n+        match self {\n+            Language::C => \"clang\",\n+            Language::CPlusPlus => \"clang++\",\n+        }\n+    }\n+}"}, {"sha": "0485ebe17fb000011eed4eb1c4c78989486dae76", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.22.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.24.0\";\n \n // An optional number to put after the label, e.g. '.2' -> '-beta.2'\n // Be sure to make this starts with a dot to conform to semver pre-release"}, {"sha": "ee780d1245ed8e6613098112c4ee01f385fb630c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 104, "deletions": 53, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -65,19 +65,21 @@ impl fmt::Display for TestKind {\n     }\n }\n \n-fn try_run_expecting(build: &Build, cmd: &mut Command, expect: BuildExpectation) {\n+fn try_run_expecting(build: &Build, cmd: &mut Command, expect: BuildExpectation) -> bool {\n     if !build.fail_fast {\n         if !build.try_run(cmd, expect) {\n             let mut failures = build.delayed_failures.borrow_mut();\n             failures.push(format!(\"{:?}\", cmd));\n+            return false;\n         }\n     } else {\n         build.run_expecting(cmd, expect);\n     }\n+    true\n }\n \n fn try_run(build: &Build, cmd: &mut Command) {\n-    try_run_expecting(build, cmd, BuildExpectation::None)\n+    try_run_expecting(build, cmd, BuildExpectation::None);\n }\n \n fn try_run_quiet(build: &Build, cmd: &mut Command) {\n@@ -246,19 +248,24 @@ impl Step for Rls {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run_expecting(\n+        if try_run_expecting(\n             build,\n             &mut cargo,\n             builder.build.config.toolstate.rls.passes(ToolState::Testing),\n-        );\n+        ) {\n+            build.save_toolstate(\"rls\", ToolState::Testing);\n+        }\n     }\n }\n \n@@ -291,24 +298,30 @@ impl Step for Rustfmt {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rustfmt/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run_expecting(\n+        if try_run_expecting(\n             build,\n             &mut cargo,\n             builder.build.config.toolstate.rustfmt.passes(ToolState::Testing),\n-        );\n+        ) {\n+            build.save_toolstate(\"rustfmt\", ToolState::Testing);\n+        }\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Miri {\n+    stage: u32,\n     host: Interned<String>,\n }\n \n@@ -324,40 +337,48 @@ impl Step for Miri {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Miri {\n+            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for miri.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n+        let stage = self.stage;\n         let host = self.host;\n-        let compiler = builder.compiler(1, host);\n-\n-        let miri = builder.ensure(tool::Miri { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // miri tests need to know about the stage sysroot\n-        cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-        cargo.env(\"MIRI_PATH\", miri);\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        let compiler = builder.compiler(stage, host);\n \n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.miri.passes(ToolState::Testing),\n-        );\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.miri.passes(ToolState::Testing),\n+            ) {\n+                build.save_toolstate(\"miri\", ToolState::Testing);\n+            }\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n+    stage: u32,\n     host: Interned<String>,\n }\n \n@@ -372,32 +393,45 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for clippy.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n+        let stage = self.stage;\n         let host = self.host;\n-        let compiler = builder.compiler(1, host);\n-\n-        let _clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // clippy tests need to know about the stage sysroot\n-        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        let compiler = builder.compiler(stage, host);\n \n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n-        );\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n+            cargo.env(\"HOST_LIBS\", host_libs);\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n+            ) {\n+                build.save_toolstate(\"clippy-driver\", ToolState::Testing);\n+            }\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n     }\n }\n \n@@ -736,12 +770,14 @@ impl Step for Compiletest {\n             flags.push(\"-g\".to_string());\n         }\n \n-        let mut hostflags = build.rustc_flags(compiler.host);\n-        hostflags.extend(flags.clone());\n+        if let Some(linker) = build.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-        let mut targetflags = build.rustc_flags(target);\n-        targetflags.extend(flags);\n+        let mut targetflags = flags.clone();\n         targetflags.push(format!(\"-Lnative={}\",\n                                  build.test_helpers_out(target).display()));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n@@ -795,6 +831,9 @@ impl Step for Compiletest {\n                 .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n                 .arg(\"--llvm-components\").arg(llvm_components.trim())\n                 .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                if let Some(ar) = build.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n@@ -820,7 +859,7 @@ impl Step for Compiletest {\n         // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n         // rather than stomp over it.\n         if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].0.env() {\n+            for &(ref k, ref v) in build.cc[&target].env() {\n                 if k != \"PATH\" {\n                     cmd.env(k, v);\n                 }\n@@ -1185,7 +1224,8 @@ impl Step for Crate {\n                     // ends up messing with various mtime calculations and such.\n                     if !name.contains(\"jemalloc\") &&\n                        *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) {\n+                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n+                       name != \"dlmalloc\" {\n                         cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n                     }\n                     for dep in build.crates[&name].deps.iter() {\n@@ -1218,6 +1258,17 @@ impl Step for Crate {\n         if target.contains(\"emscripten\") {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+        } else if target.starts_with(\"wasm32\") {\n+            // On the wasm32-unknown-unknown target we're using LTO which is\n+            // incompatible with `-C prefer-dynamic`, so disable that here\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+            let node = build.config.nodejs.as_ref()\n+                .expect(\"nodejs not configured\");\n+            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n+                                 node.display(),\n+                                 build.src.display());\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n         } else if build.remote_tested(target) {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       format!(\"{} run\","}, {"sha": "87f194fb7d2f85d4ae3eed1e32efd0390331975b", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -13,32 +13,37 @@\n //! Responsible for cleaning out a build directory of all old and stale\n //! artifacts to prepare for a fresh build. Currently doesn't remove the\n //! `build/cache` directory (download cache) or the `build/$target/llvm`\n-//! directory as we want that cached between builds.\n+//! directory unless the --all flag is present.\n \n use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n use Build;\n \n-pub fn clean(build: &Build) {\n+pub fn clean(build: &Build, all: bool) {\n     rm_rf(\"tmp\".as_ref());\n-    rm_rf(&build.out.join(\"tmp\"));\n-    rm_rf(&build.out.join(\"dist\"));\n \n-    for host in &build.hosts {\n-        let entries = match build.out.join(host).read_dir() {\n-            Ok(iter) => iter,\n-            Err(_) => continue,\n-        };\n+    if all {\n+        rm_rf(&build.out);\n+    } else {\n+        rm_rf(&build.out.join(\"tmp\"));\n+        rm_rf(&build.out.join(\"dist\"));\n \n-        for entry in entries {\n-            let entry = t!(entry);\n-            if entry.file_name().to_str() == Some(\"llvm\") {\n-                continue\n+        for host in &build.hosts {\n+            let entries = match build.out.join(host).read_dir() {\n+                Ok(iter) => iter,\n+                Err(_) => continue,\n+            };\n+\n+            for entry in entries {\n+                let entry = t!(entry);\n+                if entry.file_name().to_str() == Some(\"llvm\") {\n+                    continue\n+                }\n+                let path = t!(entry.path().canonicalize());\n+                rm_rf(&path);\n             }\n-            let path = t!(entry.path().canonicalize());\n-            rm_rf(&path);\n         }\n     }\n }"}, {"sha": "db013691bb1b8ca1aec7db48feb30e5a4a9951d4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -29,7 +29,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy};\n+use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n@@ -102,13 +102,13 @@ impl Step for Std {\n             copy_musl_third_party_objects(build, target, &libdir);\n         }\n \n-        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n-                &mut cargo,\n-                &libstd_stamp(build, compiler, target));\n+                  &mut cargo,\n+                  &libstd_stamp(build, compiler, target));\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -354,13 +354,13 @@ impl Step for Test {\n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target);\n-        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n-                &mut cargo,\n-                &libtest_stamp(build, compiler, target));\n+                  &mut cargo,\n+                  &libtest_stamp(build, compiler, target));\n \n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -480,8 +480,9 @@ impl Step for Rustc {\n         println!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target);\n \n-        let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n-        build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &compiler, target, &mut cargo);\n@@ -560,9 +561,6 @@ pub fn rustc_cargo(build: &Build,\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if let Some(ref s) = build.config.rustc_default_ar {\n-        cargo.env(\"CFG_DEFAULT_AR\", s);\n-    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -760,15 +758,7 @@ impl Step for Assemble {\n /// `sysroot_dst` provided.\n fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in this file).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = Path::new(t!(str::from_utf8(part)));\n+    for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n@@ -802,7 +792,7 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n-    if stderr_isatty() {\n+    if stderr_isatty() && build.ci_env == CiEnv::None {\n         // since we pass message-format=json to cargo, we need to tell the rustc\n         // wrapper to give us colored output if necessary. This is because we\n         // only want Cargo's JSON output, not rustcs.\n@@ -870,10 +860,19 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // have a hash in the name, but there's a version of this file in\n             // the `deps` folder which *does* have a hash in the name. That's\n             // the one we'll want to we'll probe for it later.\n-            toplevel.push((filename.file_stem().unwrap()\n-                                    .to_str().unwrap().to_string(),\n-                            filename.extension().unwrap().to_owned()\n-                                    .to_str().unwrap().to_string()));\n+            //\n+            // We do not use `Path::file_stem` or `Path::extension` here,\n+            // because some generated files may have multiple extensions e.g.\n+            // `std-<hash>.dll.lib` on Windows. The aforementioned methods only\n+            // split the file name by the last extension (`.lib`) while we need\n+            // to split by all extensions (`.dll.lib`).\n+            let expected_len = t!(filename.metadata()).len();\n+            let filename = filename.file_name().unwrap().to_str().unwrap();\n+            let mut parts = filename.splitn(2, '.');\n+            let file_stem = parts.next().unwrap().to_owned();\n+            let extension = parts.next().unwrap().to_owned();\n+\n+            toplevel.push((file_stem, extension, expected_len));\n         }\n     }\n \n@@ -893,11 +892,12 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n         .map(|e| t!(e))\n         .map(|e| (e.path(), e.file_name().into_string().unwrap(), t!(e.metadata())))\n         .collect::<Vec<_>>();\n-    for (prefix, extension) in toplevel {\n-        let candidates = contents.iter().filter(|&&(_, ref filename, _)| {\n+    for (prefix, extension, expected_len) in toplevel {\n+        let candidates = contents.iter().filter(|&&(_, ref filename, ref meta)| {\n             filename.starts_with(&prefix[..]) &&\n                 filename[prefix.len()..].starts_with(\"-\") &&\n-                filename.ends_with(&extension[..])\n+                filename.ends_with(&extension[..]) &&\n+                meta.len() == expected_len\n         });\n         let max = candidates.max_by_key(|&&(_, _, ref metadata)| {\n             FileTime::from_last_modification_time(metadata)\n@@ -941,6 +941,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n+        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+                stamp, max, stamp_mtime));\n         return\n     }\n     if max > stamp_mtime {"}, {"sha": "9dd37d8e4560cd8681576d5a62c84e280f697a70", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -76,19 +76,18 @@ pub struct Config {\n     pub llvm_static_stdcpp: bool,\n     pub llvm_link_shared: bool,\n     pub llvm_targets: Option<String>,\n-    pub llvm_experimental_targets: Option<String>,\n+    pub llvm_experimental_targets: String,\n     pub llvm_link_jobs: Option<u32>,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n-    pub rust_codegen_units: u32,\n+    pub rust_codegen_units: Option<u32>,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n     pub rust_debuginfo_only_std: bool,\n     pub rust_rpath: bool,\n     pub rustc_default_linker: Option<String>,\n-    pub rustc_default_ar: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n@@ -113,6 +112,8 @@ pub struct Config {\n     pub channel: String,\n     pub quiet_tests: bool,\n     pub test_miri: bool,\n+    pub save_toolstates: Option<PathBuf>,\n+\n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<PathBuf>,\n@@ -144,6 +145,8 @@ pub struct Target {\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n+    pub ar: Option<PathBuf>,\n+    pub linker: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n@@ -206,6 +209,11 @@ struct Install {\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n+\n+    // standard paths, currently unused\n+    datadir: Option<String>,\n+    infodir: Option<String>,\n+    localstatedir: Option<String>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -262,7 +270,6 @@ struct Rust {\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n-    default_ar: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n@@ -274,6 +281,7 @@ struct Rust {\n     dist_src: Option<bool>,\n     quiet_tests: Option<bool>,\n     test_miri: Option<bool>,\n+    save_toolstates: Option<String>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -284,6 +292,8 @@ struct TomlTarget {\n     jemalloc: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n+    ar: Option<String>,\n+    linker: Option<String>,\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n@@ -297,14 +307,14 @@ impl Config {\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n+        config.llvm_version_check = true;\n         config.use_jemalloc = true;\n         config.backtrace = true;\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n         config.docs = true;\n         config.rust_rpath = true;\n-        config.rust_codegen_units = 1;\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n         config.ignore_git = false;\n@@ -440,7 +450,8 @@ impl Config {\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n             set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n-            config.llvm_experimental_targets = llvm.experimental_targets.clone();\n+            config.llvm_experimental_targets = llvm.experimental_targets.clone()\n+                .unwrap_or(\"WebAssembly\".to_string());\n             config.llvm_link_jobs = llvm.link_jobs;\n         }\n \n@@ -464,12 +475,12 @@ impl Config {\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n             config.rustc_default_linker = rust.default_linker.clone();\n-            config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n+            config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n \n             match rust.codegen_units {\n-                Some(0) => config.rust_codegen_units = num_cpus::get() as u32,\n-                Some(n) => config.rust_codegen_units = n,\n+                Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n+                Some(n) => config.rust_codegen_units = Some(n),\n                 None => {}\n             }\n         }\n@@ -487,8 +498,10 @@ impl Config {\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(env::current_dir().unwrap().join(s));\n                 }\n-                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n+                target.ar = cfg.ar.clone().map(PathBuf::from);\n+                target.linker = cfg.linker.clone().map(PathBuf::from);\n                 target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n@@ -520,7 +533,7 @@ impl Config {\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n-        let default = config.channel == \"nightly\";\n+        let default = false;\n         config.llvm_assertions = llvm_assertions.unwrap_or(default);\n \n         let default = match &config.channel[..] {"}, {"sha": "48ca2838e4febd9001244ef7231174420043bb9b", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -11,6 +11,7 @@\n \n # ignore-tidy-linelength\n \n+from __future__ import absolute_import, division, print_function\n import sys\n import os\n rust_dir = os.path.dirname(os.path.abspath(__file__))\n@@ -19,21 +20,26 @@\n sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n import bootstrap\n \n-class Option:\n+\n+class Option(object):\n     def __init__(self, name, rustbuild, desc, value):\n         self.name = name\n         self.rustbuild = rustbuild\n         self.desc = desc\n         self.value = value\n \n+\n options = []\n \n+\n def o(*args):\n     options.append(Option(*args, value=False))\n \n+\n def v(*args):\n     options.append(Option(*args, value=True))\n \n+\n o(\"debug\", \"rust.debug\", \"debug mode; disables optimization unless `--enable-optimize` given\")\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n@@ -71,6 +77,7 @@ def v(*args):\n o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n o(\"debug-jemalloc\", \"rust.debug-jemalloc\", \"build jemalloc with --enable-debug --enable-fill\")\n+v(\"save-toolstates\", \"rust.save-toolstates\", \"save build and test status of external tools into this file\")\n \n v(\"prefix\", \"install.prefix\", \"set installation prefix\")\n v(\"localstatedir\", \"install.localstatedir\", \"local state directory\")\n@@ -119,9 +126,8 @@ def v(*args):\n   \"experimental LLVM targets to build\")\n v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")\n \n-# Used on systems where \"cc\" and \"ar\" are unavailable\n+# Used on systems where \"cc\" is unavailable\n v(\"default-linker\", \"rust.default-linker\", \"the default linker\")\n-v(\"default-ar\", \"rust.default-ar\", \"the default ar\")\n \n # Many of these are saved below during the \"writing configuration\" step\n # (others are conditionally saved).\n@@ -136,13 +142,16 @@ def v(*args):\n \n v(\"set\", None, \"set arbitrary key/value pairs in TOML configuration\")\n \n+\n def p(msg):\n     print(\"configure: \" + msg)\n \n+\n def err(msg):\n     print(\"configure: error: \" + msg)\n     sys.exit(1)\n \n+\n if '--help' in sys.argv or '-h' in sys.argv:\n     print('Usage: ./configure [options]')\n     print('')\n@@ -208,7 +217,7 @@ def err(msg):\n                 continue\n \n         found = True\n-        if not option.name in known_args:\n+        if option.name not in known_args:\n             known_args[option.name] = []\n         known_args[option.name].append((option, value))\n         break\n@@ -217,7 +226,12 @@ def err(msg):\n         unknown_args.append(arg)\n p(\"\")\n \n-if 'option-checking' not in known_args or known_args['option-checking'][1]:\n+# Note: here and a few other places, we use [-1] to apply the *last* value\n+# passed.  But if option-checking is enabled, then the known_args loop will\n+# also assert that options are only passed once.\n+option_checking = ('option-checking' not in known_args\n+                   or known_args['option-checking'][-1][1])\n+if option_checking:\n     if len(unknown_args) > 0:\n         err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n     if len(need_value_args) > 0:\n@@ -227,27 +241,30 @@ def err(msg):\n # TOML we're going to write out\n config = {}\n \n+\n def build():\n     if 'build' in known_args:\n-        return known_args['build'][0][1]\n+        return known_args['build'][-1][1]\n     return bootstrap.default_build_triple()\n \n+\n def set(key, value):\n-      s = \"{:20} := {}\".format(key, value)\n-      if len(s) < 70:\n-          p(s)\n-      else:\n-          p(s[:70] + \" ...\")\n-\n-      arr = config\n-      parts = key.split('.')\n-      for i, part in enumerate(parts):\n-          if i == len(parts) - 1:\n-              arr[part] = value\n-          else:\n-              if not part in arr:\n-                  arr[part] = {}\n-              arr = arr[part]\n+    s = \"{:20} := {}\".format(key, value)\n+    if len(s) < 70:\n+        p(s)\n+    else:\n+        p(s[:70] + \" ...\")\n+\n+    arr = config\n+    parts = key.split('.')\n+    for i, part in enumerate(parts):\n+        if i == len(parts) - 1:\n+            arr[part] = value\n+        else:\n+            if part not in arr:\n+                arr[part] = {}\n+            arr = arr[part]\n+\n \n for key in known_args:\n     # The `set` option is special and can be passed a bunch of times\n@@ -265,9 +282,9 @@ def set(key, value):\n \n     # Ensure each option is only passed once\n     arr = known_args[key]\n-    if len(arr) > 1:\n+    if option_checking and len(arr) > 1:\n         err(\"Option '{}' provided more than once\".format(key))\n-    option, value = arr[0]\n+    option, value = arr[-1]\n \n     # If we have a clear avenue to set our value in rustbuild, do so\n     if option.rustbuild is not None:\n@@ -345,8 +362,9 @@ def set(key, value):\n     targets[target] = sections['target'][:]\n     targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", target)\n \n+\n # Here we walk through the constructed configuration we have from the parsed\n-# command line arguemnts. We then apply each piece of configuration by\n+# command line arguments. We then apply each piece of configuration by\n # basically just doing a `sed` to change the various configuration line to what\n # we've got configure.\n def to_toml(value):\n@@ -360,7 +378,8 @@ def to_toml(value):\n     elif isinstance(value, str):\n         return \"'\" + value + \"'\"\n     else:\n-        raise 'no toml'\n+        raise RuntimeError('no toml')\n+\n \n def configure_section(lines, config):\n     for key in config:\n@@ -375,10 +394,11 @@ def configure_section(lines, config):\n         if not found:\n             raise RuntimeError(\"failed to find config line for {}\".format(key))\n \n+\n for section_key in config:\n     section_config = config[section_key]\n-    if not section_key in sections:\n-        raise RuntimeError(\"config key {} not in sections\".format(key))\n+    if section_key not in sections:\n+        raise RuntimeError(\"config key {} not in sections\".format(section_key))\n \n     if section_key == 'target':\n         for target in section_config:\n@@ -407,11 +427,6 @@ def configure_section(lines, config):\n     contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n     f.write(contents)\n \n-# Finally, clean up with a bit of a help message\n-relpath = os.path.dirname(__file__)\n-if relpath == '':\n-    relpath = '.'\n-\n p(\"\")\n-p(\"run `python {}/x.py --help`\".format(relpath))\n+p(\"run `python {}/x.py --help`\".format(rust_dir))\n p(\"\")"}, {"sha": "bfe2a64f5ba489ad27436936261e6236ac88b8fe", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 217, "deletions": 93, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -39,6 +39,8 @@ pub fn pkgname(build: &Build, component: &str) -> String {\n         format!(\"{}-{}\", component, build.cargo_package_vers())\n     } else if component == \"rls\" {\n         format!(\"{}-{}\", component, build.rls_package_vers())\n+    } else if component == \"rustfmt\" {\n+        format!(\"{}-{}\", component, build.rustfmt_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, build.rust_package_vers())\n@@ -176,7 +178,7 @@ fn make_win_dist(\n         }\n     }\n \n-    let target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let target_tools = [\"gcc.exe\", \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libstdc++-6.dll\", \"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n@@ -630,7 +632,7 @@ impl Step for Analysis {\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n \n         let src = build.stage_out(compiler, Mode::Libstd)\n-            .join(target).join(\"release\").join(\"deps\");\n+            .join(target).join(build.cargo_dir()).join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n@@ -670,6 +672,9 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n              spath.ends_with(\".s\")) {\n             return false\n         }\n+        if spath.contains(\"test/emscripten\") || spath.contains(\"test\\\\emscripten\") {\n+            return false\n+        }\n \n         let full_path = Path::new(dir).join(path);\n         if exclude_dirs.iter().any(|excl| full_path == Path::new(excl)) {\n@@ -734,17 +739,16 @@ impl Step for Src {\n         // (essentially libstd and all of its path dependencies)\n         let std_src_dirs = [\n             \"src/build_helper\",\n+            \"src/dlmalloc\",\n             \"src/liballoc\",\n             \"src/liballoc_jemalloc\",\n             \"src/liballoc_system\",\n             \"src/libbacktrace\",\n-            \"src/libcollections\",\n             \"src/libcompiler_builtins\",\n             \"src/libcore\",\n             \"src/liblibc\",\n             \"src/libpanic_abort\",\n             \"src/libpanic_unwind\",\n-            \"src/librand\",\n             \"src/librustc_asan\",\n             \"src/librustc_lsan\",\n             \"src/librustc_msan\",\n@@ -754,6 +758,7 @@ impl Step for Src {\n             \"src/libunwind\",\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\",\n+            \"src/rustc/dlmalloc_shim\",\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/jemalloc\",\n@@ -1035,7 +1040,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1050,12 +1055,17 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n         assert!(build.config.extended);\n \n+        if !builder.config.toolstate.rls.testing() {\n+            println!(\"skipping Dist RLS stage{} ({})\", stage, target);\n+            return None\n+        }\n+\n         println!(\"Dist RLS stage{} ({})\", stage, target);\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n@@ -1068,10 +1078,13 @@ impl Step for Rls {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n+        // We expect RLS to build, because we've exited this step above if tool\n+        // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n             target\n-        });\n+        }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n+\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);\n@@ -1102,7 +1115,97 @@ impl Step for Rls {\n            .arg(\"--component-name=rls-preview\");\n \n         build.run(&mut cmd);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}\n+\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustfmt {\n+    pub stage: u32,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Rustfmt {\n+    type Output = Option<PathBuf>;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"rustfmt\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustfmt {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(build.config.extended);\n+\n+        if !builder.config.toolstate.rustfmt.testing() {\n+            println!(\"skipping Dist Rustfmt stage{} ({})\", stage, target);\n+            return None\n+        }\n+\n+        println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n+        let src = build.src.join(\"src/tools/rustfmt\");\n+        let release_num = build.release_num(\"rustfmt\");\n+        let name = pkgname(build, \"rustfmt\");\n+        let version = build.rustfmt_info.version(build, &release_num);\n+\n+        let tmp = tmpdir(build);\n+        let image = tmp.join(\"rustfmt-image\");\n+        drop(fs::remove_dir_all(&image));\n+        t!(fs::create_dir_all(&image));\n+\n+        // Prepare the image directory\n+        let rustfmt = builder.ensure(tool::Rustfmt {\n+            compiler: builder.compiler(stage, build.build),\n+            target\n+        }).or_else(|| { println!(\"Unable to build Rustfmt, skipping dist\"); None })?;\n+        let cargofmt = builder.ensure(tool::Cargofmt {\n+            compiler: builder.compiler(stage, build.build),\n+            target\n+        }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n+\n+        install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        let doc = image.join(\"share/doc/rustfmt\");\n+        install(&src.join(\"README.md\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"rustfmt-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        install(&src.join(\"README.md\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--component-name=rustfmt-preview\");\n+\n+        build.run(&mut cmd);\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -1169,6 +1272,7 @@ impl Step for Extended {\n             compiler: builder.compiler(stage, target),\n         });\n         let cargo_installer = builder.ensure(Cargo { stage, target });\n+        let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n         let rls_installer = builder.ensure(Rls { stage, target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis {\n@@ -1202,8 +1306,13 @@ impl Step for Extended {\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n         // the std files during uninstall. To do this ensure that rustc comes\n         // before rust-std in the list below.\n-        let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n-                                analysis_installer, std_installer];\n+        let mut tarballs = Vec::new();\n+        tarballs.push(rustc_installer);\n+        tarballs.push(cargo_installer);\n+        tarballs.extend(rls_installer.clone());\n+        tarballs.extend(rustfmt_installer.clone());\n+        tarballs.push(analysis_installer);\n+        tarballs.push(std_installer);\n         if build.config.docs {\n             tarballs.push(docs_installer);\n         }\n@@ -1245,35 +1354,41 @@ impl Step for Extended {\n         }\n         rtf.push_str(\"}\");\n \n+        fn filter(contents: &str, marker: &str) -> String {\n+            let start = format!(\"tool-{}-start\", marker);\n+            let end = format!(\"tool-{}-end\", marker);\n+            let mut lines = Vec::new();\n+            let mut omitted = false;\n+            for line in contents.lines() {\n+                if line.contains(&start) {\n+                    omitted = true;\n+                } else if line.contains(&end) {\n+                    omitted = false;\n+                } else if !omitted {\n+                    lines.push(line);\n+                }\n+            }\n+\n+            lines.join(\"\\n\")\n+        }\n+\n+        let xform = |p: &Path| {\n+            let mut contents = String::new();\n+            t!(t!(File::open(p)).read_to_string(&mut contents));\n+            if rls_installer.is_none() {\n+                contents = filter(&contents, \"rls\");\n+            }\n+            if rustfmt_installer.is_none() {\n+                contents = filter(&contents, \"rustfmt\");\n+            }\n+            let ret = tmp.join(p.file_name().unwrap());\n+            t!(t!(File::create(&ret)).write_all(contents.as_bytes()));\n+            return ret\n+        };\n+\n         if target.contains(\"apple-darwin\") {\n             let pkg = tmp.join(\"pkg\");\n             let _ = fs::remove_dir_all(&pkg);\n-            t!(fs::create_dir_all(pkg.join(\"rustc\")));\n-            t!(fs::create_dir_all(pkg.join(\"cargo\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-std\")));\n-            t!(fs::create_dir_all(pkg.join(\"rls\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-analysis\")));\n-\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target)),\n-                    &pkg.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target)),\n-                    &pkg.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target)),\n-                    &pkg.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target)),\n-                    &pkg.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)),\n-                    &pkg.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target)),\n-                    &pkg.join(\"rust-analysis\"));\n-\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rustc\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"cargo\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-docs\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-std\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rls\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-analysis\"), 0o755);\n \n             let pkgbuild = |component: &str| {\n                 let mut cmd = Command::new(\"pkgbuild\");\n@@ -1283,12 +1398,23 @@ impl Step for Extended {\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n                 build.run(&mut cmd);\n             };\n-            pkgbuild(\"rustc\");\n-            pkgbuild(\"cargo\");\n-            pkgbuild(\"rust-docs\");\n-            pkgbuild(\"rust-std\");\n-            pkgbuild(\"rls\");\n-            pkgbuild(\"rust-analysis\");\n+\n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(pkg.join(name)));\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                        &pkg.join(name));\n+                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                pkgbuild(name);\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            prepare(\"rust-analysis\");\n+\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n \n             // create an 'uninstall' package\n             install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n@@ -1298,7 +1424,7 @@ impl Step for Extended {\n             t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n             install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n-            cmd.arg(\"--distribution\").arg(etc.join(\"pkg/Distribution.xml\"))\n+            cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n                 .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n                                                     pkgname(build, \"rust\"),\n@@ -1310,46 +1436,34 @@ impl Step for Extended {\n         if target.contains(\"windows\") {\n             let exe = tmp.join(\"exe\");\n             let _ = fs::remove_dir_all(&exe);\n-            t!(fs::create_dir_all(exe.join(\"rustc\")));\n-            t!(fs::create_dir_all(exe.join(\"cargo\")));\n-            t!(fs::create_dir_all(exe.join(\"rls\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-analysis\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-std\")));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target))\n-                        .join(\"rustc\"),\n-                    &exe.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target))\n-                        .join(\"cargo\"),\n-                    &exe.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target))\n-                        .join(\"rust-docs\"),\n-                    &exe.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n-                        .join(format!(\"rust-std-{}\", target)),\n-                    &exe.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls-preview\"),\n-                 &exe.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n-                        .join(format!(\"rust-analysis-{}\", target)),\n-                    &exe.join(\"rust-analysis\"));\n-\n-            t!(fs::remove_file(exe.join(\"rustc/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"cargo/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-docs/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-std/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rls/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-analysis/manifest.in\")));\n \n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(exe.join(name)));\n+                let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n+                    format!(\"{}-{}\", name, target)\n+                } else if name == \"rls\" {\n+                    \"rls-preview\".to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                            .join(dir),\n+                        &exe.join(name));\n+                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-analysis\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n             if target.contains(\"windows-gnu\") {\n-                t!(fs::create_dir_all(exe.join(\"rust-mingw\")));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-mingw\"), target))\n-                            .join(\"rust-mingw\"),\n-                        &exe.join(\"rust-mingw\"));\n-                t!(fs::remove_file(exe.join(\"rust-mingw/manifest.in\")));\n+                prepare(\"rust-mingw\");\n             }\n \n-            install(&etc.join(\"exe/rust.iss\"), &exe, 0o644);\n+            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n             install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n             install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n             install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n@@ -1413,16 +1527,18 @@ impl Step for Extended {\n                             .arg(\"-dr\").arg(\"Std\")\n                             .arg(\"-var\").arg(\"var.StdDir\")\n                             .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n-            build.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rls\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"RlsGroup\")\n-                            .arg(\"-dr\").arg(\"Rls\")\n-                            .arg(\"-var\").arg(\"var.RlsDir\")\n-                            .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            if rls_installer.is_some() {\n+                build.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"rls\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"RlsGroup\")\n+                                .arg(\"-dr\").arg(\"Rls\")\n+                                .arg(\"-var\").arg(\"var.RlsDir\")\n+                                .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n+                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            }\n             build.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n@@ -1456,26 +1572,30 @@ impl Step for Extended {\n                     .arg(\"-dDocsDir=rust-docs\")\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n-                    .arg(\"-dRlsDir=rls\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n                     .arg(\"-arch\").arg(&arch)\n                     .arg(\"-out\").arg(&output)\n                     .arg(&input);\n                 add_env(build, &mut cmd, target);\n \n+                if rls_installer.is_some() {\n+                    cmd.arg(\"-dRlsDir=rls\");\n+                }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n                 build.run(&mut cmd);\n             };\n-            candle(&etc.join(\"msi/rust.wxs\"));\n+            candle(&xform(&etc.join(\"msi/rust.wxs\")));\n             candle(&etc.join(\"msi/ui.wxs\"));\n             candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n             candle(\"RustcGroup.wxs\".as_ref());\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n-            candle(\"RlsGroup.wxs\".as_ref());\n+            if rls_installer.is_some() {\n+                candle(\"RlsGroup.wxs\".as_ref());\n+            }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n@@ -1499,10 +1619,13 @@ impl Step for Extended {\n                 .arg(\"DocsGroup.wixobj\")\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n-                .arg(\"RlsGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n                 .current_dir(&exe);\n \n+            if rls_installer.is_some() {\n+                cmd.arg(\"RlsGroup.wixobj\");\n+            }\n+\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");\n             }\n@@ -1586,6 +1709,7 @@ impl Step for HashSign {\n         cmd.arg(build.rust_package_vers());\n         cmd.arg(build.package_vers(&build.release_num(\"cargo\")));\n         cmd.arg(build.package_vers(&build.release_num(\"rls\")));\n+        cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n         t!(fs::create_dir_all(distdir(build)));"}, {"sha": "3c12cfc4c7ffd4ba83ac910b8d3ad8a4e4b99899", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -66,7 +66,7 @@ macro_rules! book {\n }\n \n book!(\n-    Nomicon, \"src/doc/book\", \"nomicon\";\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n     Rustdoc, \"src/doc/rustdoc\", \"rustdoc\";\n );\n@@ -132,6 +132,52 @@ impl Step for UnstableBook {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CargoBook {\n+    target: Interned<String>,\n+    name: Interned<String>,\n+}\n+\n+impl Step for CargoBook {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(CargoBook {\n+            target: run.target,\n+            name: INTERNER.intern_str(\"cargo\"),\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+\n+        let target = self.target;\n+        let name = self.name;\n+        let src = build.src.join(\"src/tools/cargo/src/doc/book\");\n+\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        let out = out.join(name);\n+\n+        println!(\"Cargo Book ({}) - {}\", target, name);\n+\n+        let _ = fs::remove_dir_all(&out);\n+\n+        build.run(builder.tool_cmd(Tool::Rustbook)\n+                       .arg(\"build\")\n+                       .arg(&src)\n+                       .arg(\"-d\")\n+                       .arg(out));\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n struct RustbookSrc {\n     target: Interned<String>,\n@@ -205,10 +251,12 @@ impl Step for TheBook {\n     ///\n     /// * Book (first edition)\n     /// * Book (second edition)\n+    /// * Version info and CSS\n     /// * Index page\n     /// * Redirect pages\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n+        let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n         // build book first edition\n@@ -223,10 +271,16 @@ impl Step for TheBook {\n             name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n         });\n \n+        // build the version info page and CSS\n+        builder.ensure(Standalone {\n+            compiler,\n+            target,\n+        });\n+\n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n         println!(\"Documenting book index ({})\", target);\n-        invoke_rustdoc(builder, self.compiler, target, &index);\n+        invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n         println!(\"Documenting book redirect pages ({})\", target);\n@@ -235,56 +289,11 @@ impl Step for TheBook {\n             let path = file.path();\n             let path = path.to_str().unwrap();\n \n-            invoke_rustdoc(builder, self.compiler, target, path);\n+            invoke_rustdoc(builder, compiler, target, path);\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct CargoBook {\n-    target: Interned<String>,\n-}\n-\n-impl Step for CargoBook {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/doc/cargo\").default_condition(builder.build.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(CargoBook {\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Create a placeholder for the cargo documentation so that doc.rust-lang.org/cargo will\n-    /// redirect to doc.crates.io. We want to publish doc.rust-lang.org/cargo in the paper\n-    /// version of the book, but we don't want to rush the process of switching cargo's docs\n-    /// over to mdbook and deploying them. When the cargo book is ready, this implementation\n-    /// should build the mdbook instead of this redirect page.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let out = build.doc_out(self.target);\n-\n-        let cargo_dir = out.join(\"cargo\");\n-        t!(fs::create_dir_all(&cargo_dir));\n-\n-        let index = cargo_dir.join(\"index.html\");\n-        let redirect_html = r#\"\n-            <html>\n-                <head>\n-                    <meta http-equiv=\"refresh\" content=\"0; URL='http://doc.crates.io'\" />\n-                </head>\n-            </html>\"#;\n-\n-        println!(\"Creating cargo book redirect page\");\n-        t!(t!(File::create(&index)).write_all(redirect_html.as_bytes()));\n-    }\n-}\n-\n fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n     let build = builder.build;\n     let out = build.doc_out(target);\n@@ -293,25 +302,12 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n \n     let favicon = build.src.join(\"src/doc/favicon.inc\");\n     let footer = build.src.join(\"src/doc/footer.inc\");\n-\n-    let version_input = build.src.join(\"src/doc/version_info.html.template\");\n     let version_info = out.join(\"version_info.html\");\n \n-    if !up_to_date(&version_input, &version_info) {\n-        let mut info = String::new();\n-        t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-        let info = info.replace(\"VERSION\", &build.rust_release())\n-                       .replace(\"SHORT_HASH\", build.rust_info.sha_short().unwrap_or(\"\"))\n-                       .replace(\"STAMP\", build.rust_info.sha().unwrap_or(\"\"));\n-        t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n-    }\n-\n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n \n     let out = out.join(\"book\");\n \n-    t!(fs::copy(build.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n-\n     cmd.arg(\"--html-after-content\").arg(&footer)\n         .arg(\"--html-before-content\").arg(&version_info)\n         .arg(\"--html-in-header\").arg(&favicon)\n@@ -320,7 +316,7 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n         .arg(\"-o\").arg(&out)\n         .arg(&path)\n         .arg(\"--markdown-css\")\n-        .arg(\"rust.css\");\n+        .arg(\"../rust.css\");\n \n     build.run(&mut cmd);\n }\n@@ -490,7 +486,7 @@ impl Step for Std {\n         // for which docs must be built.\n         if !build.config.compiler_docs {\n             cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n+            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n                 cargo.arg(\"-p\").arg(krate);\n                 // Create all crate output directories first to make sure rustdoc uses\n                 // relative links.\n@@ -623,11 +619,9 @@ impl Step for Rustc {\n         compile::rustc_cargo(build, &compiler, target, &mut cargo);\n \n         if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains bin crates called rustc and rustdoc\n-            // which would otherwise overwrite the docs for the real rustc and\n-            // rustdoc lib crates.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\")\n-                 .arg(\"-p\").arg(\"rustdoc\");\n+            // src/rustc/Cargo.toml contains a bin crate called rustc which\n+            // would otherwise overwrite the docs for the real rustc lib crate.\n+            cargo.arg(\"-p\").arg(\"rustc_driver\");\n         } else {\n             // Like with libstd above if compiler docs aren't enabled then we're not\n             // documenting internal dependencies, so we have a whitelist."}, {"sha": "b5d51598fab882009004091425de1e8fe7c5472e", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -60,7 +60,9 @@ pub enum Subcommand {\n         paths: Vec<PathBuf>,\n         test_args: Vec<String>,\n     },\n-    Clean,\n+    Clean {\n+        all: bool,\n+    },\n     Dist {\n         paths: Vec<PathBuf>,\n     },\n@@ -134,9 +136,12 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n-                // No subcommand -- show the general usage and subcommand help\n+                // No or an invalid subcommand -- show the general usage and subcommand help\n+                // An exit code will be 0 when no subcommand is given, and 1 in case of an invalid\n+                // subcommand.\n                 println!(\"{}\\n\", subcommand_help);\n-                process::exit(1);\n+                let exit_code = if args.is_empty() { 0 } else { 1 };\n+                process::exit(exit_code);\n             }\n         };\n \n@@ -147,6 +152,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             },\n             \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n             _ => { },\n         };\n \n@@ -250,17 +256,18 @@ Arguments:\n             }\n         });\n \n-        // All subcommands can have an optional \"Available paths\" section\n+        // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n             let mut build = Build::new(config);\n             metadata::build(&mut build);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-        } else {\n-            extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                     subcommand).as_str());\n+        } else if subcommand.as_str() != \"clean\" {\n+            extra_help.push_str(format!(\n+                \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                subcommand).as_str());\n         }\n \n         // User passed in -h/--help?\n@@ -290,10 +297,13 @@ Arguments:\n             }\n             \"clean\" => {\n                 if paths.len() > 0 {\n-                    println!(\"\\nclean takes no arguments\\n\");\n+                    println!(\"\\nclean does not take a path argument\\n\");\n                     usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n-                Subcommand::Clean\n+\n+                Subcommand::Clean {\n+                    all: matches.opt_present(\"all\"),\n+                }\n             }\n             \"dist\" => {\n                 Subcommand::Dist {"}, {"sha": "743f32ece99c6284111b96f4f14c8a155c1044af", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -27,10 +27,8 @@ pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n-pub fn install_std(builder: &Builder, stage: u32) {\n-    for target in &builder.build.targets {\n-        install_sh(builder, \"std\", \"rust-std\", stage, Some(*target));\n-    }\n+pub fn install_std(builder: &Builder, stage: u32, target: Interned<String>) {\n+    install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n }\n \n pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n@@ -41,6 +39,10 @@ pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n \n+pub fn install_rustfmt(builder: &Builder, stage: u32, host: Interned<String>) {\n+    install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n+}\n+\n pub fn install_analysis(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n@@ -175,19 +177,31 @@ install!((self, builder, _config),\n         install_docs(builder, self.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n-        builder.ensure(dist::Std {\n-            compiler: builder.compiler(self.stage, self.host),\n-            target: self.target\n-        });\n-        install_std(builder, self.stage);\n+        for target in &builder.build.targets {\n+            builder.ensure(dist::Std {\n+                compiler: builder.compiler(self.stage, self.host),\n+                target: *target\n+            });\n+            install_std(builder, self.stage, *target);\n+        }\n     };\n     Cargo, \"cargo\", _config.extended, only_hosts: true, {\n         builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n         install_cargo(builder, self.stage, self.target);\n     };\n     Rls, \"rls\", _config.extended, only_hosts: true, {\n-        builder.ensure(dist::Rls { stage: self.stage, target: self.target });\n-        install_rls(builder, self.stage, self.target);\n+        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() {\n+            install_rls(builder, self.stage, self.target);\n+        } else {\n+            println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n+        }\n+    };\n+    Rustfmt, \"rustfmt\", _config.extended, only_hosts: true, {\n+        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() {\n+            install_rustfmt(builder, self.stage, self.target);\n+        } else {\n+            println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n+        }\n     };\n     Analysis, \"analysis\", _config.extended, only_hosts: false, {\n         builder.ensure(dist::Analysis {"}, {"sha": "fa3ba02482f569b81903c27ff85f716ae8a3ede3", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -185,7 +185,7 @@ pub unsafe fn setup(build: &mut Build) {\n                             0, FALSE, DUPLICATE_SAME_ACCESS);\n \n     // If this failed, well at least we tried! An example of DuplicateHandle\n-    // failing in the past has been when the wrong python2 package spawed this\n+    // failing in the past has been when the wrong python2 package spawned this\n     // build system (e.g. the `python2` package in MSYS instead of\n     // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n     // mode\" here is that we only clean everything up when the build system"}, {"sha": "2f00c313a0c30268067b50fff2fc66cc572bb3a9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -190,6 +190,7 @@ mod job {\n pub use config::Config;\n use flags::Subcommand;\n use cache::{Interned, INTERNER};\n+use toolstate::ToolState;\n \n /// A structure representing a Rust compiler.\n ///\n@@ -222,6 +223,7 @@ pub struct Build {\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n+    rustfmt_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     verbosity: usize,\n@@ -240,10 +242,11 @@ pub struct Build {\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n-    // target -> (cc, ar)\n-    cc: HashMap<Interned<String>, (cc::Tool, Option<PathBuf>)>,\n-    // host -> (cc, ar)\n+    // C/C++ compilers and archiver for all targets\n+    cc: HashMap<Interned<String>, cc::Tool>,\n     cxx: HashMap<Interned<String>, cc::Tool>,\n+    ar: HashMap<Interned<String>, PathBuf>,\n+    // Misc\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -303,6 +306,7 @@ impl Build {\n         let rust_info = channel::GitInfo::new(&config, &src);\n         let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n+        let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n         Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -322,8 +326,10 @@ impl Build {\n             rust_info,\n             cargo_info,\n             rls_info,\n+            rustfmt_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n+            ar: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n@@ -345,8 +351,8 @@ impl Build {\n             job::setup(self);\n         }\n \n-        if let Subcommand::Clean = self.config.cmd {\n-            return clean::clean(self);\n+        if let Subcommand::Clean { all } = self.config.cmd {\n+            return clean::clean(self, all);\n         }\n \n         self.verbose(\"finding compilers\");\n@@ -383,16 +389,19 @@ impl Build {\n     /// Clear out `dir` if `input` is newer.\n     ///\n     /// After this executes, it will also ensure that `dir` exists.\n-    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) -> bool {\n         let stamp = dir.join(\".stamp\");\n+        let mut cleared = false;\n         if mtime(&stamp) < mtime(input) {\n             self.verbose(&format!(\"Dirty - {}\", dir.display()));\n             let _ = fs::remove_dir_all(dir);\n+            cleared = true;\n         } else if stamp.exists() {\n-            return\n+            return cleared;\n         }\n         t!(fs::create_dir_all(dir));\n         t!(File::create(stamp));\n+        cleared\n     }\n \n     /// Get the space-separated set of activated features for the standard\n@@ -433,6 +442,12 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n+    fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n+        let out = self.out.join(&*compiler.host).join(format!(\"stage{}-tools-bin\", compiler.stage));\n+        t!(fs::create_dir_all(&out));\n+        out\n+    }\n+\n     /// Get the directory for incremental by-products when using the\n     /// given compiler.\n     fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n@@ -612,15 +627,15 @@ impl Build {\n \n     /// Returns the path to the C compiler for the target specified.\n     fn cc(&self, target: Interned<String>) -> &Path {\n-        self.cc[&target].0.path()\n+        self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n     fn cflags(&self, target: Interned<String>) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[&target].0.args().iter()\n+        let mut base = self.cc[&target].args().iter()\n                            .map(|s| s.to_string_lossy().into_owned())\n                            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n                            .collect::<Vec<_>>();\n@@ -644,7 +659,7 @@ impl Build {\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n     fn ar(&self, target: Interned<String>) -> Option<&Path> {\n-        self.cc[&target].1.as_ref().map(|p| &**p)\n+        self.ar.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n@@ -657,21 +672,17 @@ impl Build {\n         }\n     }\n \n-    /// Returns flags to pass to the compiler to generate code for `target`.\n-    fn rustc_flags(&self, target: Interned<String>) -> Vec<String> {\n-        // New flags should be added here with great caution!\n-        //\n-        // It's quite unfortunate to **require** flags to generate code for a\n-        // target, so it should only be passed here if absolutely necessary!\n-        // Most default configuration should be done through target specs rather\n-        // than an entry here.\n-\n-        let mut base = Vec::new();\n-        if target != self.config.build && !target.contains(\"msvc\") &&\n-            !target.contains(\"emscripten\") {\n-            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+    /// Returns the path to the linker for the given target if it needs to be overriden.\n+    fn linker(&self, target: Interned<String>) -> Option<&Path> {\n+        if let Some(linker) = self.config.target_config.get(&target)\n+                                                       .and_then(|c| c.linker.as_ref()) {\n+            Some(linker)\n+        } else if target != self.config.build &&\n+                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+            Some(self.cc(target))\n+        } else {\n+            None\n         }\n-        base\n     }\n \n     /// Returns if this target should statically link the C runtime, if specified\n@@ -807,6 +818,11 @@ impl Build {\n         self.package_vers(&self.release_num(\"rls\"))\n     }\n \n+    /// Returns the value of `package_vers` above for rustfmt\n+    fn rustfmt_package_vers(&self) -> String {\n+        self.package_vers(&self.release_num(\"rustfmt\"))\n+    }\n+\n     /// Returns the `version` string associated with this compiler for Rust\n     /// itself.\n     ///\n@@ -859,6 +875,30 @@ impl Build {\n         }\n     }\n \n+    /// Updates the actual toolstate of a tool.\n+    ///\n+    /// The toolstates are saved to the file specified by the key\n+    /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n+    /// done. The file is updated immediately after this function completes.\n+    pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n+        use std::io::{Seek, SeekFrom};\n+\n+        if let Some(ref path) = self.config.save_toolstates {\n+            let mut file = t!(fs::OpenOptions::new()\n+                .create(true)\n+                .read(true)\n+                .write(true)\n+                .open(path));\n+\n+            let mut current_toolstates: HashMap<Box<str>, ToolState> =\n+                serde_json::from_reader(&mut file).unwrap_or_default();\n+            current_toolstates.insert(tool.into(), state);\n+            t!(file.seek(SeekFrom::Start(0)));\n+            t!(file.set_len(0));\n+            t!(serde_json::to_writer(file, &current_toolstates));\n+        }\n+    }\n+\n     /// Get a list of crates from a root crate.\n     ///\n     /// Returns Vec<(crate, path to crate, is_root_crate)>"}, {"sha": "925a361f0b22e010eb0e4fc034330c44806ac83c", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -52,11 +52,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/tools/cargotest \\\n \t\tsrc/tools/cargo \\\n-\t\tsrc/tools/rls \\\n-\t\tsrc/tools/rustfmt \\\n-\t\tsrc/tools/miri \\\n+\t\tsrc/tools/cargotest \\\n \t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\"}, {"sha": "a5408ee381bbbb23c2338ce0cdd5eb04316856c5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -110,10 +110,7 @@ impl Step for Llvm {\n             None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX;Hexagon\",\n         };\n \n-        let llvm_exp_targets = match build.config.llvm_experimental_targets {\n-            Some(ref s) => s,\n-            None => \"\",\n-        };\n+        let llvm_exp_targets = &build.config.llvm_experimental_targets;\n \n         let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n@@ -227,6 +224,13 @@ impl Step for Llvm {\n             cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n             cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n             cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n+            if let Some(ar) = build.ar(target) {\n+                if ar.is_absolute() {\n+                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+                    // tries to resolve this path in the LLVM build directory.\n+                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+                }\n+            }\n         };\n \n         configure_compilers(&mut cfg);\n@@ -252,11 +256,14 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n \n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n-    if version.starts_with(\"3.5\") || version.starts_with(\"3.6\") ||\n-       version.starts_with(\"3.7\") {\n-        return\n+    let mut parts = version.split('.').take(2)\n+        .filter_map(|s| s.parse::<u32>().ok());\n+    if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n+        if major > 3 || (major == 3 && minor >= 9) {\n+            return\n+        }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -309,13 +316,13 @@ impl Step for TestHelpers {\n            .warnings(false)\n            .debug(false)\n            .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n-           .compile(\"librust_test_helpers.a\");\n+           .compile(\"rust_test_helpers\");\n     }\n }\n \n-const OPENSSL_VERS: &'static str = \"1.0.2k\";\n+const OPENSSL_VERS: &'static str = \"1.0.2m\";\n const OPENSSL_SHA256: &'static str =\n-    \"6b3977c61f2aedf0f96367dcfb5c6e578cf37e7b8d913b4ecb6643c3cb88d8c0\";\n+    \"8c6ff15ec6b319b50788f42c7abc2890c08ba5a1cdcd3810eb9092deada37b0f\";\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Openssl {\n@@ -352,42 +359,59 @@ impl Step for Openssl {\n             // originally from https://www.openssl.org/source/...\n             let url = format!(\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/{}\",\n                               name);\n-            let mut ok = false;\n+            let mut last_error = None;\n             for _ in 0..3 {\n                 let status = Command::new(\"curl\")\n                                 .arg(\"-o\").arg(&tmp)\n+                                .arg(\"-f\")  // make curl fail if the URL does not return HTTP 200\n                                 .arg(&url)\n                                 .status()\n                                 .expect(\"failed to spawn curl\");\n-                if status.success() {\n-                    ok = true;\n-                    break\n+\n+                // Retry if download failed.\n+                if !status.success() {\n+                    last_error = Some(status.to_string());\n+                    continue;\n                 }\n+\n+                // Ensure the hash is correct.\n+                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                    let mut cmd = Command::new(\"shasum\");\n+                    cmd.arg(\"-a\").arg(\"256\");\n+                    cmd\n+                } else {\n+                    Command::new(\"sha256sum\")\n+                };\n+                let output = output(&mut shasum.arg(&tmp));\n+                let found = output.split_whitespace().next().unwrap();\n+\n+                // If the hash is wrong, probably the download is incomplete or S3 served an error\n+                // page. In any case, retry.\n+                if found != OPENSSL_SHA256 {\n+                    last_error = Some(format!(\n+                        \"downloaded openssl sha256 different\\n\\\n+                         expected: {}\\n\\\n+                         found:    {}\\n\",\n+                        OPENSSL_SHA256,\n+                        found\n+                    ));\n+                    continue;\n+                }\n+\n+                // Everything is fine, so exit the retry loop.\n+                last_error = None;\n+                break;\n             }\n-            if !ok {\n-                panic!(\"failed to download openssl source\")\n-            }\n-            let mut shasum = if target.contains(\"apple\") {\n-                let mut cmd = Command::new(\"shasum\");\n-                cmd.arg(\"-a\").arg(\"256\");\n-                cmd\n-            } else {\n-                Command::new(\"sha256sum\")\n-            };\n-            let output = output(&mut shasum.arg(&tmp));\n-            let found = output.split_whitespace().next().unwrap();\n-            if found != OPENSSL_SHA256 {\n-                panic!(\"downloaded openssl sha256 different\\n\\\n-                        expected: {}\\n\\\n-                        found:    {}\\n\", OPENSSL_SHA256, found);\n+            if let Some(error) = last_error {\n+                panic!(\"failed to download openssl source: {}\", error);\n             }\n             t!(fs::rename(&tmp, &tarball));\n         }\n         let obj = out.join(format!(\"openssl-{}\", OPENSSL_VERS));\n         let dst = build.openssl_install_dir(target).unwrap();\n         drop(fs::remove_dir_all(&obj));\n         drop(fs::remove_dir_all(&dst));\n-        build.run(Command::new(\"tar\").arg(\"xf\").arg(&tarball).current_dir(&out));\n+        build.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n \n         let mut configure = Command::new(\"perl\");\n         configure.arg(obj.join(\"Configure\"));\n@@ -419,10 +443,12 @@ impl Step for Openssl {\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"sparc64-unknown-linux-gnu\" => \"linux64-sparcv9\",\n             \"sparc64-unknown-netbsd\" => \"BSD-sparc64\",\n             \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n             \"x86_64-linux-android\" => \"linux-x86_64\",\n             \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n+            \"x86_64-unknown-dragonfly\" => \"BSD-x86_64\",\n             \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n             \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n             \"x86_64-unknown-netbsd\" => \"BSD-x86_64\","}, {"sha": "bc275b7fc745c2b903aca80eec1cc71b5d757345", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -78,7 +78,7 @@ pub fn check(build: &mut Build) {\n     }\n \n     let mut cmd_finder = Finder::new();\n-    // If we've got a git directory we're gona need git to update\n+    // If we've got a git directory we're gonna need git to update\n     // submodules and learn about various other aspects.\n     if build.rust_info.is_git() {\n         cmd_finder.must_have(\"git\");"}, {"sha": "fa9bdc43c378cb69c3346a3c4df278c421f8b5c8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 120, "deletions": 159, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -11,7 +11,7 @@\n use std::fs;\n use std::env;\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{Command, exit};\n \n use Mode;\n use Compiler;\n@@ -38,24 +38,40 @@ impl Step for CleanTools {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n-    ///\n-    /// This will build the specified tool with the specified `host` compiler in\n-    /// `stage` into the normal cargo output directory.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n \n-        let stamp = match mode {\n-            Mode::Libstd => libstd_stamp(build, compiler, target),\n-            Mode::Libtest => libtest_stamp(build, compiler, target),\n-            Mode::Librustc => librustc_stamp(build, compiler, target),\n-            _ => panic!(),\n+        // This is for the original compiler, but if we're forced to use stage 1, then\n+        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n+        // we copy the libs forward.\n+        let tools_dir = build.stage_out(compiler, Mode::Tool);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n         };\n-        let out_dir = build.cargo_out(compiler, Mode::Tool, target);\n-        build.clear_if_dirty(&out_dir, &stamp);\n+\n+        for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n+            let stamp = match cur_mode {\n+                Mode::Libstd => libstd_stamp(build, compiler, target),\n+                Mode::Libtest => libtest_stamp(build, compiler, target),\n+                Mode::Librustc => librustc_stamp(build, compiler, target),\n+                _ => panic!(),\n+            };\n+\n+            if build.clear_if_dirty(&tools_dir, &stamp) {\n+                break;\n+            }\n+\n+            // If we are a rustc tool, and std changed, we also need to clear ourselves out -- our\n+            // dependencies depend on std. Therefore, we iterate up until our own mode.\n+            if mode == cur_mode {\n+                break;\n+            }\n+        }\n     }\n }\n \n@@ -70,7 +86,7 @@ struct ToolBuild {\n }\n \n impl Step for ToolBuild {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -80,7 +96,7 @@ impl Step for ToolBuild {\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -99,8 +115,35 @@ impl Step for ToolBuild {\n         println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n \n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n-        build.run_expecting(&mut cargo, expectation);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+        let is_expected = build.try_run(&mut cargo, expectation);\n+        // If the expectation is \"Failing\", `try_run` returning true actually\n+        // means a build-failure is successfully observed, i.e. the tool is\n+        // broken. Thus the XOR here.\n+        // Sorry for the complicated logic, but we can remove this expectation\n+        // logic after #45861 is fully fixed.\n+        build.save_toolstate(tool, if is_expected ^ (expectation == BuildExpectation::Failing) {\n+            ToolState::Compiling\n+        } else {\n+            ToolState::Broken\n+        });\n+\n+        if !is_expected {\n+            if expectation == BuildExpectation::None {\n+                exit(1);\n+            } else {\n+                return None;\n+            }\n+        }\n+\n+        if expectation == BuildExpectation::Succeeding || expectation == BuildExpectation::None {\n+            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+                .join(exe(tool, &compiler.host));\n+            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            copy(&cargo_out, &bin);\n+            Some(bin)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -169,12 +212,12 @@ macro_rules! tool {\n             }\n \n             pub fn tool_default_stage(&self, tool: Tool) -> u32 {\n-                // Compile the error-index in the top stage as it depends on\n-                // rustdoc, so we want to avoid recompiling rustdoc twice if we\n-                // can. Otherwise compile everything else in stage0 as there's\n-                // no need to rebootstrap everything\n+                // Compile the error-index in the same stage as rustdoc to avoid\n+                // recompiling rustdoc twice if we can. Otherwise compile\n+                // everything else in stage0 as there's no need to rebootstrap\n+                // everything.\n                 match tool {\n-                    Tool::ErrorIndex => self.top_stage,\n+                    Tool::ErrorIndex if self.top_stage >= 2 => self.top_stage,\n                     _ => 0,\n                 }\n             }\n@@ -209,7 +252,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     expectation: BuildExpectation::None,\n-                })\n+                }).expect(\"expected to build -- BuildExpectation::None\")\n             }\n         }\n         )+\n@@ -257,7 +300,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"expected to build -- BuildExpectation::None\")\n     }\n }\n \n@@ -375,74 +418,70 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"BuildExpectation::None - expected to build\")\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Clippy {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n+macro_rules! tool_extended {\n+    (($sel:ident, $builder:ident),\n+       $($name:ident,\n+       $toolstate:ident,\n+       $path:expr,\n+       $tool_name:expr,\n+       $extra_deps:block;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n+        }\n \n-impl Step for Clippy {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = false;\n-    const ONLY_HOSTS: bool = true;\n+        impl Step for $name {\n+            type Output = Option<PathBuf>;\n+            const DEFAULT: bool = true;\n+            const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/clippy\")\n-    }\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                let builder = run.builder;\n+                run.path($path).default_condition(builder.build.config.extended)\n+            }\n \n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n+            fn make_run(run: RunConfig) {\n+                run.builder.ensure($name {\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    target: run.target,\n+                });\n+            }\n+\n+            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+                $extra_deps\n+                let toolstate = $builder.build.config.toolstate.$toolstate;\n+                $builder.ensure(ToolBuild {\n+                    compiler: $sel.compiler,\n+                    target: $sel.target,\n+                    tool: $tool_name,\n+                    mode: Mode::Librustc,\n+                    path: $path,\n+                    expectation: toolstate.passes(ToolState::Compiling),\n+                })\n+            }\n+        }\n+        )+\n     }\n+}\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+tool_extended!((self, builder),\n+    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"clippy\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/clippy\",\n-            expectation: builder.build.config.toolstate.clippy.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rls {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rls\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    };\n+    Miri, miri, \"src/tools/miri\", \"miri\", {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -452,87 +491,9 @@ impl Step for Rls {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rls\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rls\",\n-            expectation: builder.build.config.toolstate.rls.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustfmt {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rustfmt\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> PathBuf {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rustfmt\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rustfmt\",\n-            expectation: builder.build.config.toolstate.rustfmt.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Miri {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> PathBuf {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"miri\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/miri\",\n-            expectation: builder.build.config.toolstate.miri.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n+    };\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+);\n \n impl<'a> Builder<'a> {\n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n@@ -561,7 +522,7 @@ impl<'a> Builder<'a> {\n         if compiler.host.contains(\"msvc\") {\n             let curpaths = env::var_os(\"PATH\").unwrap_or_default();\n             let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n-            for &(ref k, ref v) in self.cc[&compiler.host].0.env() {\n+            for &(ref k, ref v) in self.cc[&compiler.host].env() {\n                 if k != \"PATH\" {\n                     continue\n                 }"}, {"sha": "00dbcc86af4d18c3b1ee3bfedcf2a2cecf929aa2", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -10,7 +10,7 @@\n \n use build_helper::BuildExpectation;\n \n-#[derive(Copy, Clone, Debug, Deserialize, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]\n /// Whether a tool can be compiled, tested or neither\n pub enum ToolState {\n     /// The tool compiles successfully, but the test suite fails\n@@ -31,6 +31,13 @@ impl ToolState {\n             BuildExpectation::Failing\n         }\n     }\n+\n+    pub fn testing(&self) -> bool {\n+        match *self {\n+            ToolState::Testing => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl Default for ToolState {"}, {"sha": "2506048858f2b67dadf83f970214815c062cc2a8", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -14,8 +14,9 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::fs;\n-use std::io::{self, Write};\n+use std::str;\n+use std::fs::{self, File};\n+use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n@@ -50,6 +51,22 @@ pub fn copy(src: &Path, dst: &Path) {\n     t!(filetime::set_file_times(dst, atime, mtime));\n }\n \n+pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n+    let mut paths = Vec::new();\n+    let mut contents = Vec::new();\n+    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+    // This is the method we use for extracting paths from the stamp file passed to us. See\n+    // run_cargo for more information (in compile.rs).\n+    for part in contents.split(|b| *b == 0) {\n+        if part.is_empty() {\n+            continue\n+        }\n+        let path = PathBuf::from(t!(str::from_utf8(part)));\n+        paths.push(path);\n+    }\n+    paths\n+}\n+\n /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n /// when this function is called.\n pub fn cp_r(src: &Path, dst: &Path) {"}, {"sha": "2b6e2828cfb4bf644771d4bd76b65010d77aadfd", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -138,27 +138,6 @@ pub fn gnu_target(target: &str) -> String {\n     }\n }\n \n-pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if target.contains(\"msvc\") {\n-        None\n-    } else if target.contains(\"musl\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else if target.contains(\"openbsd\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else {\n-        let parent = cc.parent().unwrap();\n-        let file = cc.file_name().unwrap().to_str().unwrap();\n-        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n-            if let Some(idx) = file.rfind(suffix) {\n-                let mut file = file[..idx].to_owned();\n-                file.push_str(\"ar\");\n-                return Some(parent.join(&file));\n-            }\n-        }\n-        Some(parent.join(file))\n-    }\n-}\n-\n pub fn make(host: &str) -> PathBuf {\n     if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n         host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n@@ -211,6 +190,9 @@ pub fn mtime(path: &Path) -> FileTime {\n ///\n /// Uses last-modified time checks to verify this.\n pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n+    if !dst.exists() {\n+        return false;\n+    }\n     let threshold = mtime(dst);\n     let meta = match fs::metadata(src) {\n         Ok(meta) => meta,"}, {"sha": "8d4dbc399986fa1865208170018d51c450ef3f0b", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -22,6 +22,48 @@ Images will output artifacts in an `obj` dir at the root of a repository.\n - `scripts` contains files shared by docker images\n - `disabled` contains images that are not built on travis\n \n+## Docker Toolbox on Windows\n+\n+For Windows before Windows 10, the docker images can be run on Windows via\n+[Docker Toolbox]. There are several preparation needs to be made before running\n+a Docker image.\n+\n+1. Stop the virtual machine from the terminal with `docker-machine stop`\n+\n+2. If your Rust source is placed outside of `C:\\Users\\**`, e.g. if you place the\n+    repository in the `E:\\rust` folder, please add a shared folder from\n+    VirtualBox by:\n+\n+    1. Select the \"default\" virtual machine inside VirtualBox, then click\n+        \"Settings\"\n+    2. Go to \"Shared Folders\", click \"Add shared folder\" (the folder icon with\n+        a plus sign), fill in the following information, then click \"OK\":\n+\n+        * Folder path: `E:\\rust`\n+        * Folder name: `e/rust`\n+        * Read-only: \u2610 *unchecked*\n+        * Auto-mount: \u2611 *checked*\n+        * Make Permanent: \u2611 *checked*\n+\n+3. VirtualBox might not support creating symbolic links inside a shared folder\n+    by default. You can enable it manually by running these from `cmd.exe`:\n+\n+    ```bat\n+    cd \"C:\\Program Files\\Oracle\\VirtualBox\"\n+    VBoxManage setextradata default VBoxInternal2/SharedFoldersEnableSymlinksCreate/e/rust 1\n+    ::                                                                              ^~~~~~\n+    ::                                                                              folder name\n+    ```\n+\n+4. Restart the virtual machine from terminal with `docker-machine start`.\n+\n+To run the image,\n+\n+1. Launch the \"Docker Quickstart Terminal\".\n+2. Execute `./src/ci/docker/run.sh $image_name` as explained at the beginning.\n+\n+[Docker Toolbox]: https://www.docker.com/products/docker-toolbox\n+\n ## Cross toolchains\n \n A number of these images take quite a long time to compile as they're building\n@@ -137,7 +179,7 @@ For targets: `armv7-unknown-linux-gnueabihf`\n     libraries like jemalloc. See the mk/cfg/arm(v7)-uknown-linux-gnueabi{,hf}.mk\n     file in Rust's source code.\n \n-## `aarch64-linux-gnu.config`\n+### `aarch64-linux-gnu.config`\n \n For targets: `aarch64-unknown-linux-gnu`\n \n@@ -150,7 +192,7 @@ For targets: `aarch64-unknown-linux-gnu`\n - C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n-## `powerpc-linux-gnu.config`\n+### `powerpc-linux-gnu.config`\n \n For targets: `powerpc-unknown-linux-gnu`\n \n@@ -165,7 +207,7 @@ For targets: `powerpc-unknown-linux-gnu`\n - C compiler > gcc version = 4.9.3\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n-## `powerpc64-linux-gnu.config`\n+### `powerpc64-linux-gnu.config`\n \n For targets: `powerpc64-unknown-linux-gnu`\n \n@@ -184,7 +226,7 @@ For targets: `powerpc64-unknown-linux-gnu`\n \n (+) These CPU options match the configuration of the toolchains in RHEL6.\n \n-## `s390x-linux-gnu.config`\n+### `s390x-linux-gnu.config`\n \n For targets: `s390x-unknown-linux-gnu`\n "}, {"sha": "f2773a720cfbcf3ae063950c6d22efc5ab96ab78", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,29 +5,35 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm 9\n+    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n \n+# Note:\n+# Do not upgrade to `openjdk-9-jre-headless`, as it will cause certificate error\n+# when installing the Android SDK (see PR #45193). This is unfortunate, but\n+# every search result suggested either disabling HTTPS or replacing JDK 9 by\n+# JDK 8 as the solution (e.g. https://stackoverflow.com/q/41421340). :|\n RUN dpkg --add-architecture i386 && \\\n     apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n   libgl1-mesa-glx \\\n   libpulse0 \\\n   libstdc++6:i386 \\\n-  openjdk-9-jre-headless \\\n+  openjdk-8-jre-headless \\\n   tzdata\n \n COPY scripts/android-sdk.sh /scripts/\n RUN . /scripts/android-sdk.sh && \\\n-    download_and_create_avd tools_r25.2.5-linux.zip armeabi-v7a 18\n+    download_and_create_avd 4333796 armeabi-v7a 18\n \n+ENV PATH=$PATH:/android/sdk/emulator\n ENV PATH=$PATH:/android/sdk/tools\n ENV PATH=$PATH:/android/sdk/platform-tools\n \n ENV TARGETS=arm-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n-      --arm-linux-androideabi-ndk=/android/ndk/arm-9\n+      --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n "}, {"sha": "07849a20d00458d446b1d936d22ddfcd5059a0a3", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -16,6 +16,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/emscripten.sh /scripts/\n RUN bash /scripts/emscripten.sh\n \n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/clang/e1.37.13_64bit/\n ENV PATH=$PATH:/emsdk-portable/emscripten/1.37.13/\n@@ -29,6 +32,3 @@ ENV TARGETS=asmjs-unknown-emscripten\n ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh"}, {"sha": "fedb4094c8aaafd25732e8b163517fd057def3d2", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -31,7 +31,7 @@ WORKDIR /build\n # The `config` config file was a previously generated config file for\n # the kernel. This file was generated by running `make defconfig`\n # followed by `make menuconfig` and then enabling the IPv6 protocol page.\n-COPY disabled/aarch64-gnu/config /build/.config\n+COPY aarch64-gnu/config /build/.config\n RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n       tar xJf - && \\\n       cd /build/linux-4.4.42 && \\"}, {"sha": "ce5e8cfaf09582b86bf32643b210cb55542c32be", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,7 +5,7 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm64 21\n+    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm64 21\n \n ENV PATH=$PATH:/android/ndk/arm64-21/bin\n "}, {"sha": "3177fa2147fa16b63eea51e7b9e26d71ca6bfe55", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,17 +5,17 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain arm 9 && \\\n+    download_ndk android-ndk-r15c-linux-x86_64.zip && \\\n+    make_standalone_toolchain arm 14 && \\\n     make_standalone_toolchain arm 21 && \\\n     remove_ndk\n \n RUN chmod 777 /android/ndk && \\\n     ln -s /android/ndk/arm-21 /android/ndk/arm\n \n-ENV PATH=$PATH:/android/ndk/arm-9/bin\n+ENV PATH=$PATH:/android/ndk/arm-14/bin\n \n-ENV DEP_Z_ROOT=/android/ndk/arm-9/sysroot/usr/\n+ENV DEP_Z_ROOT=/android/ndk/arm-14/sysroot/usr/\n \n ENV HOSTS=armv7-linux-androideabi\n \n@@ -27,18 +27,18 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-# We support api level 9, but api level 21 is required to build llvm. To\n+# We support api level 14, but api level 21 is required to build llvm. To\n # overcome this problem we use a ndk with api level 21 to build llvm and then\n-# switch to a ndk with api level 9 to complete the build. When the linker is\n+# switch to a ndk with api level 14 to complete the build. When the linker is\n # invoked there are missing symbols (like sigsetempty, not available with api\n-# level 9), the default linker behavior is to generate an error, to allow the\n+# level 14), the default linker behavior is to generate an error, to allow the\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n   python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/arm && \\\n-    ln -s /android/ndk/arm-9 /android/ndk/arm && \\\n+    ln -s /android/ndk/arm-14 /android/ndk/arm && \\\n     python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "ace9c4feb4f3be307a18613afcd733e559cae28a", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,17 +5,17 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain x86 9 && \\\n+    download_ndk android-ndk-r15c-linux-x86_64.zip && \\\n+    make_standalone_toolchain x86 14 && \\\n     make_standalone_toolchain x86 21 && \\\n     remove_ndk\n \n RUN chmod 777 /android/ndk && \\\n     ln -s /android/ndk/x86-21 /android/ndk/x86\n \n-ENV PATH=$PATH:/android/ndk/x86-9/bin\n+ENV PATH=$PATH:/android/ndk/x86-14/bin\n \n-ENV DEP_Z_ROOT=/android/ndk/x86-9/sysroot/usr/\n+ENV DEP_Z_ROOT=/android/ndk/x86-14/sysroot/usr/\n \n ENV HOSTS=i686-linux-android\n \n@@ -27,18 +27,18 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-# We support api level 9, but api level 21 is required to build llvm. To\n+# We support api level 14, but api level 21 is required to build llvm. To\n # overcome this problem we use a ndk with api level 21 to build llvm and then\n-# switch to a ndk with api level 9 to complete the build. When the linker is\n+# switch to a ndk with api level 14 to complete the build. When the linker is\n # invoked there are missing symbols (like sigsetempty, not available with api\n-# level 9), the default linker behavior is to generate an error, to allow the\n+# level 14), the default linker behavior is to generate an error, to allow the\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n   python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/x86 && \\\n-    ln -s /android/ndk/x86-9 /android/ndk/x86 && \\\n+    ln -s /android/ndk/x86-14 /android/ndk/x86 && \\\n     python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "322d26f0adc4ce226987ca691ab76b14d7880461", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -5,7 +5,7 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip x86_64 21\n+    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip x86_64 21\n \n ENV PATH=$PATH:/android/ndk/x86_64-21/bin\n "}, {"sha": "f3509efdb988bdd51069b7bb9f7b47dc2fd9dedc", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  bzip2 \\\n+  xz-utils \\\n+  wget \\\n+  libssl-dev \\\n+  bsdtar \\\n+  pkg-config\n+\n+\n+COPY dist-x86_64-dragonfly/build-toolchain.sh /tmp/\n+COPY dist-x86_64-dragonfly/patch-toolchain /tmp/\n+RUN /tmp/build-toolchain.sh /tmp/patch-toolchain\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-ar \\\n+    CC_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-gcc \\\n+    CXX_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-g++\n+\n+ENV HOSTS=x86_64-unknown-dragonfly\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "2ebbe0cdee9b806e063b95f91d592ad879bbb16b", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/build-toolchain.sh", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,120 @@\n+#!/usr/bin/env bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+ARCH=x86_64\n+PATCH_TOOLCHAIN=$1\n+BINUTILS=2.25.1\n+GCC=6.4.0\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir binutils\n+cd binutils\n+\n+# First up, build binutils\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-$BINUTILS/configure \\\n+  --target=$ARCH-unknown-dragonfly\n+hide_output make -j10\n+hide_output make install\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download the DragonFly libc and relevant header files\n+\n+URL=http://mirror-master.dragonflybsd.org/iso-images/dfly-x86_64-5.0.0_REL.iso.bz2\n+mkdir dragonfly\n+curl $URL | bzcat | bsdtar xf - -C dragonfly ./usr/include ./usr/lib ./lib\n+\n+dst=/usr/local/$ARCH-unknown-dragonfly\n+\n+mkdir -p $dst/lib\n+cp -r dragonfly/usr/include $dst/\n+cp dragonfly/usr/lib/crt1.o $dst/lib\n+cp dragonfly/usr/lib/Scrt1.o $dst/lib\n+cp dragonfly/usr/lib/crti.o $dst/lib\n+cp dragonfly/usr/lib/crtn.o $dst/lib\n+cp dragonfly/usr/lib/libc.a $dst/lib\n+cp dragonfly/usr/lib/libutil.a $dst/lib\n+cp dragonfly/usr/lib/libm.a $dst/lib\n+cp dragonfly/usr/lib/librt.so.0 $dst/lib\n+cp dragonfly/usr/lib/libexecinfo.so.1 $dst/lib\n+cp dragonfly/lib/libc.so.8 $dst/lib\n+cp dragonfly/lib/libm.so.4 $dst/lib\n+cp dragonfly/lib/libutil.so.4 $dst/lib\n+cp dragonfly/usr/lib/libpthread.so $dst/lib/libpthread.so\n+cp dragonfly/usr/lib/thread/libthread_xu.so.2 $dst/lib/libpthread.so.0\n+\n+ln -s libc.so.8 $dst/lib/libc.so\n+ln -s libm.so.4 $dst/lib/libm.so\n+ln -s librt.so.0 $dst/lib/librt.so\n+ln -s libutil.so.4 $dst/lib/libutil.so\n+ln -s libexecinfo.so.1 $dst/lib/libexecinfo.so\n+rm -rf dragonfly\n+\n+# Finally, download and build gcc to target DragonFly\n+mkdir gcc\n+cd gcc\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.gz | tar xzf -\n+cd gcc-$GCC\n+\n+# The following three patches are taken from DragonFly's dports collection:\n+# https://github.com/DragonFlyBSD/DPorts/tree/master/lang/gcc5\n+# The dports specification for gcc5 contains a few more patches, but they are\n+# not relevant in this situation, as they are for a language we don't need\n+# (e.g. java), or a platform which is not supported by DragonFly (e.g. i386,\n+# powerpc64, ia64, arm).\n+#\n+# These patches probably only need to be updated in case the gcc version is\n+# updated.\n+\n+patch -p0 < $PATCH_TOOLCHAIN\n+\n+./contrib/download_prerequisites\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+hide_output ../gcc-$GCC/configure                \\\n+  --enable-languages=c,c++                       \\\n+  --target=$ARCH-unknown-dragonfly               \\\n+  --disable-multilib                             \\\n+  --disable-nls                                  \\\n+  --disable-libgomp                              \\\n+  --disable-libquadmath                          \\\n+  --disable-libssp                               \\\n+  --disable-libvtv                               \\\n+  --disable-libcilkrts                           \\\n+  --disable-libada                               \\\n+  --disable-libsanitizer                         \\\n+  --disable-libquadmath-support                  \\\n+  --disable-lto\n+hide_output make -j10\n+hide_output make install\n+cd ../..\n+rm -rf gcc"}, {"sha": "98424309ee23dbca8f8fb1fd82cb678174c9c558", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/patch-toolchain", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,23 @@\n+--- libstdc++-v3/config/os/bsd/dragonfly/os_defines.h.orig\t2015-07-09 16:08:54 UTC\n++++ libstdc++-v3/config/os/bsd/dragonfly/os_defines.h\n+@@ -29,4 +29,9 @@\n+ // System-specific #define, typedefs, corrections, etc, go here.  This\n+ // file will come before all others.\n+ \n++#define _GLIBCXX_USE_C99_CHECK 1\n++#define _GLIBCXX_USE_C99_DYNAMIC (!(__ISO_C_VISIBLE >= 1999))\n++#define _GLIBCXX_USE_C99_LONG_LONG_CHECK 1\n++#define _GLIBCXX_USE_C99_LONG_LONG_DYNAMIC (_GLIBCXX_USE_C99_DYNAMIC || !defined __LONG_LONG_SUPPORTED)\n++\n+ #endif\n+--- libstdc++-v3/configure.orig\t2016-05-26 18:34:47.163132921 +0200\n++++ libstdc++-v3/configure\t2016-05-26 18:35:29.594590648 +0200\n+@@ -52013,7 +52013,7 @@\n+ \n+     ;;\n+ \n+-  *-freebsd*)\n++  *-freebsd* | *-dragonfly*)\n+     SECTION_FLAGS='-ffunction-sections -fdata-sections'\n+ \n+ "}, {"sha": "a1115e254b5b2b67053fca98ae046c3fd048f681", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/build-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "a37532e203aa49d771c92a82f9849e44593b5663", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/fetch-packages.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "8653b0e8b465ec5dda9a20a1b6bf3d9d592e322d", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n # emscripten\n COPY scripts/emscripten-wasm.sh /scripts/\n-COPY disabled/wasm32-exp/node.sh /usr/local/bin/node\n+COPY wasm32-exp/node.sh /usr/local/bin/node\n RUN bash /scripts/emscripten-wasm.sh\n \n # cache"}, {"sha": "2bfddb0de99b01bb1f3df1d3351e8bc97a70c5aa", "filename": "src/ci/docker/disabled/wasm32-exp/node.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "22b719bb30755841740a4a2e8c4ddcec6edf6b56", "filename": "src/ci/docker/dist-aarch64-linux/build-toolchains.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "5d7545a3c2a956d812d09611e0db36ae2fad5dd2", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -6,9 +6,9 @@ RUN sh /scripts/android-base-apt-get.sh\n # ndk\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain arm 9 && \\\n-    make_standalone_toolchain x86 9 && \\\n+    download_ndk android-ndk-r15c-linux-x86_64.zip && \\\n+    make_standalone_toolchain arm 14 && \\\n+    make_standalone_toolchain x86 14 && \\\n     make_standalone_toolchain arm64 21 && \\\n     make_standalone_toolchain x86_64 21 && \\\n     remove_ndk\n@@ -23,9 +23,9 @@ ENV TARGETS=$TARGETS,x86_64-linux-android\n ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n       --enable-extended \\\n-      --arm-linux-androideabi-ndk=/android/ndk/arm-9 \\\n-      --armv7-linux-androideabi-ndk=/android/ndk/arm-9 \\\n-      --i686-linux-android-ndk=/android/ndk/x86-9 \\\n+      --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --i686-linux-android-ndk=/android/ndk/x86-14 \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21\n "}, {"sha": "c53cca0bb982c672352abcb69f16cf04d3622720", "filename": "src/ci/docker/dist-arm-linux/build-toolchains.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "964182a5ad5448102c1a72f028a890196d0a0fc4", "filename": "src/ci/docker/dist-armhf-linux/build-toolchains.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "40adfe5d53e0bd38d008d5fe529605319c68a801", "filename": "src/ci/docker/dist-armv7-linux/build-toolchains.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "bcd95924b427f80600bff1d2acfa20488d7a6d91", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,41 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y \\\n-  build-essential \\\n-  bzip2 \\\n-  ca-certificates \\\n-  cmake \\\n-  curl \\\n-  file \\\n-  g++ \\\n-  gdb \\\n-  git \\\n-  libedit-dev \\\n-  make \\\n-  ninja-build \\\n-  nodejs \\\n-  python2.7-dev \\\n-  sudo \\\n-  xz-utils \\\n-  unzip\n-\n-WORKDIR /tmp\n-COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh /tmp/\n-RUN /tmp/build-toolchain.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n-    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n-    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n-    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n-    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n-    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++\n-\n-ENV TARGETS=x86_64-unknown-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n-\n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n\\ No newline at end of file"}, {"sha": "2fb121968110867beb3118e879bd143a34063273", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -34,6 +34,7 @@ ENV RUST_CONFIGURE_ARGS \\\n #\n # See: https://github.com/rust-lang/rust/issues/34978\n ENV CFLAGS_i686_unknown_linux_musl=-Wa,-mrelax-relocations=no\n+ENV CFLAGS_i586_unknown_linux_gnu=-Wa,-mrelax-relocations=no\n \n ENV SCRIPT \\\n       python2.7 ../x.py test \\"}, {"sha": "883859d1fa64e89cd09c9c5917255589fd8926c0", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.16\n+MUSL=musl-1.1.17\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n CC=gcc \\"}, {"sha": "3c86a8e38175eaabe43c3fcb8c2403b98ddf1b59", "filename": "src/ci/docker/dist-i686-freebsd/build-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "f4bdbd80d0edb761dc08e34286e0c76a1ef4a0a0", "filename": "src/ci/docker/dist-i686-linux/build-binutils.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "9a3763d421ad2b721d773494cc11fc2d7ffbec28", "filename": "src/ci/docker/dist-i686-linux/build-cmake.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "edf3175b81c436321f510ec99b560f627d93a677", "filename": "src/ci/docker/dist-i686-linux/build-curl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "6b991bb59e4b0dcc5fd9018b51e70960afe9a6c9", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "ff62a68629a8bfdb79bee9d727f35c6066030434", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "2f15114d6f98028857bbeef289cedc70d1c887e0", "filename": "src/ci/docker/dist-i686-linux/build-headers.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "e7226ace020bd8bc8dc35b11e1e07b3ab9b66a53", "filename": "src/ci/docker/dist-i686-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "c6b8cdde4b9af4d57737dd910efe1ebb67c4425e", "filename": "src/ci/docker/dist-i686-linux/build-python.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "15211acb4459b8fba9e12be5ba242b65cd6aaa7d", "filename": "src/ci/docker/dist-powerpc-linux/build-powerpc-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "ac6460a472993d5411ff76eeeb3f5b6faee6d4d6", "filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "2f6937afff032cc432c453b4656ce90be5a24e99", "filename": "src/ci/docker/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -23,7 +23,7 @@ SYSROOT=/usr/local/$TARGET/sysroot\n mkdir -p $SYSROOT\n pushd $SYSROOT\n \n-centos_base=http://mirror.centos.org/altarch/7.3.1611/os/ppc64le/Packages\n+centos_base=http://vault.centos.org/altarch/7.3.1611/os/ppc64le/Packages/\n glibc_v=2.17-157.el7\n kernel_v=3.10.0-514.el7\n for package in glibc{,-devel,-headers}-$glibc_v kernel-headers-$kernel_v; do"}, {"sha": "306204dd0e1f6414a62b9c89b87c45b92d40ad25", "filename": "src/ci/docker/dist-s390x-linux/build-s390x-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "a616693311a2de33714e491aa7f81ed3ca277876", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -24,19 +24,19 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n WORKDIR /tmp\n \n-COPY cross/build-rumprun.sh /tmp/\n+COPY dist-various-1/build-rumprun.sh /tmp/\n RUN ./build-rumprun.sh\n \n-COPY cross/build-arm-musl.sh /tmp/\n+COPY dist-various-1/build-arm-musl.sh /tmp/\n RUN ./build-arm-musl.sh\n \n-COPY cross/install-mips-musl.sh /tmp/\n+COPY dist-various-1/install-mips-musl.sh /tmp/\n RUN ./install-mips-musl.sh\n \n-COPY cross/install-mipsel-musl.sh /tmp/\n+COPY dist-various-1/install-mipsel-musl.sh /tmp/\n RUN ./install-mipsel-musl.sh\n \n-COPY cross/install-x86_64-redox.sh /tmp/\n+COPY dist-various-1/install-x86_64-redox.sh /tmp/\n RUN ./install-x86_64-redox.sh\n \n ENV TARGETS=asmjs-unknown-emscripten", "previous_filename": "src/ci/docker/cross/Dockerfile"}, {"sha": "f9444a35a8b7918225c6dff98f0540790e9d5c5a", "filename": "src/ci/docker/dist-various-1/build-arm-musl.sh", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-arm-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-arm-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-arm-musl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -11,7 +11,7 @@\n \n set -ex\n \n-MUSL=1.1.16\n+MUSL=1.1.17\n \n hide_output() {\n   set +x", "previous_filename": "src/ci/docker/cross/build-arm-musl.sh"}, {"sha": "ad38cf872ad07bce5afb43a40040b0c4270e7083", "filename": "src/ci/docker/dist-various-1/build-rumprun.sh", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-rumprun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-rumprun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-rumprun.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.", "previous_filename": "src/ci/docker/cross/build-rumprun.sh"}, {"sha": "eeb4aacbbb74cd7fc3c92f99007cf4bf844838ce", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "previous_filename": "src/ci/docker/cross/install-mips-musl.sh"}, {"sha": "74b6a10e77a672dc153c73e292bd6f4e76b0903e", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "previous_filename": "src/ci/docker/cross/install-mipsel-musl.sh"}, {"sha": "9bfb57f5741c569c77e9327edba2fc15e9ad3c2f", "filename": "src/ci/docker/dist-various-1/install-x86_64-redox.sh", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.", "previous_filename": "src/ci/docker/cross/install-x86_64-redox.sh"}, {"sha": "c7885db559a64acd89aee0056b68f9869d503b36", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,55 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+RUN apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n+  build-essential \\\n+  gcc-multilib \\\n+  libedit-dev \\\n+  libgmp-dev \\\n+  libisl-dev \\\n+  libmpc-dev \\\n+  libmpfr-dev \\\n+  ninja-build \\\n+  nodejs \\\n+  python2.7-dev \\\n+  software-properties-common \\\n+  unzip\n+\n+RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n+RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2-testing main'\n+\n+WORKDIR /tmp\n+COPY dist-various-2/shared.sh dist-various-2/build-fuchsia-toolchain.sh /tmp/\n+COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n+RUN /tmp/build-fuchsia-toolchain.sh\n+RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n+RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n+    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n+    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n+    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n+    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n+    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n+\n+ENV TARGETS=x86_64-unknown-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n+ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n+ENV TARGETS=$TARGETS,x86_64-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n+\n+ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "ef8f0c37f8c370073c277c984203524ccab5db24", "filename": "src/ci/docker/dist-various-2/build-fuchsia-toolchain.sh", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.", "previous_filename": "src/ci/docker/dist-fuchsia/build-toolchain.sh"}, {"sha": "c04c8b7194c710e0c344ed94a43c558e5f0abbf8", "filename": "src/ci/docker/dist-various-2/build-solaris-toolchain.sh", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-solaris-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,107 @@\n+#!/usr/bin/env bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+ARCH=$1\n+LIB_ARCH=$2\n+APT_ARCH=$3\n+BINUTILS=2.28.1\n+GCC=6.4.0\n+\n+# First up, build binutils\n+mkdir binutils\n+cd binutils\n+\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.xz | tar xJf -\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-$BINUTILS/configure --target=$ARCH-sun-solaris2.10\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download and install the relevant solaris packages\n+mkdir solaris\n+cd solaris\n+\n+dpkg --add-architecture $APT_ARCH\n+apt-get update\n+apt-get download $(apt-cache depends --recurse --no-replaces \\\n+  libc-dev:$APT_ARCH       \\\n+  libm-dev:$APT_ARCH       \\\n+  libpthread-dev:$APT_ARCH \\\n+  libresolv-dev:$APT_ARCH  \\\n+  librt-dev:$APT_ARCH      \\\n+  libsocket-dev:$APT_ARCH  \\\n+  system-crt:$APT_ARCH     \\\n+  system-header:$APT_ARCH  \\\n+  | grep \"^\\w\")\n+\n+for deb in *$APT_ARCH.deb; do\n+  dpkg -x $deb .\n+done\n+\n+# Remove Solaris 11 functions that are optionally used by libbacktrace.\n+# This is for Solaris 10 compatibility.\n+rm usr/include/link.h\n+patch -p0  << 'EOF'\n+--- usr/include/string.h\n++++ usr/include/string10.h\n+@@ -93 +92,0 @@\n+-extern size_t strnlen(const char *, size_t);\n+EOF\n+\n+mkdir                  /usr/local/$ARCH-sun-solaris2.10/usr\n+mv usr/include         /usr/local/$ARCH-sun-solaris2.10/usr/include\n+mv usr/lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+mv     lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+\n+ln -s usr/include /usr/local/$ARCH-sun-solaris2.10/sys-include\n+ln -s usr/include /usr/local/$ARCH-sun-solaris2.10/include\n+\n+cd ..\n+rm -rf solaris\n+\n+# Finally, download and build gcc to target solaris\n+mkdir gcc\n+cd gcc\n+\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.xz | tar xJf -\n+cd gcc-$GCC\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+hide_output ../gcc-$GCC/configure \\\n+  --enable-languages=c,c++        \\\n+  --target=$ARCH-sun-solaris2.10  \\\n+  --with-gnu-as                   \\\n+  --with-gnu-ld                   \\\n+  --disable-multilib              \\\n+  --disable-nls                   \\\n+  --disable-libgomp               \\\n+  --disable-libquadmath           \\\n+  --disable-libssp                \\\n+  --disable-libvtv                \\\n+  --disable-libcilkrts            \\\n+  --disable-libada                \\\n+  --disable-libsanitizer          \\\n+  --disable-libquadmath-support   \\\n+  --disable-lto\n+\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf gcc"}, {"sha": "e26c6eb6645781c70b1948a53b8b5e1532d359d7", "filename": "src/ci/docker/dist-various-2/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-various-2%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fshared.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "previous_filename": "src/ci/docker/dist-fuchsia/shared.sh"}, {"sha": "3c86a8e38175eaabe43c3fcb8c2403b98ddf1b59", "filename": "src/ci/docker/dist-x86_64-freebsd/build-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "f4bdbd80d0edb761dc08e34286e0c76a1ef4a0a0", "filename": "src/ci/docker/dist-x86_64-linux/build-binutils.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "9a3763d421ad2b721d773494cc11fc2d7ffbec28", "filename": "src/ci/docker/dist-x86_64-linux/build-cmake.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "edf3175b81c436321f510ec99b560f627d93a677", "filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "6b991bb59e4b0dcc5fd9018b51e70960afe9a6c9", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "ff62a68629a8bfdb79bee9d727f35c6066030434", "filename": "src/ci/docker/dist-x86_64-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "2f15114d6f98028857bbeef289cedc70d1c887e0", "filename": "src/ci/docker/dist-x86_64-linux/build-headers.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "e7226ace020bd8bc8dc35b11e1e07b3ab9b66a53", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "c6b8cdde4b9af4d57737dd910efe1ebb67c4425e", "filename": "src/ci/docker/dist-x86_64-linux/build-python.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "9be8d001149e9d10788ab6c416cedfa0d2cd010a", "filename": "src/ci/docker/dist-x86_64-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.16\n+MUSL=musl-1.1.17\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n ./configure --prefix=/musl-x86_64 --disable-shared"}, {"sha": "5b4314d57e6ccd7968971032c7a80c05f00d62e4", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -52,7 +52,7 @@ curl $URL/2017-03-17-netbsd-comp.tgz | \\\n cd usr/src\n \n # The options, in order, do the following\n-# * this is an unpriviledged build\n+# * this is an unprivileged build\n # * output to a predictable location\n # * disable various uneeded stuff\n MKUNPRIVED=yes TOOLDIR=/x-tools/x86_64-unknown-netbsd \\\n@@ -64,12 +64,12 @@ cd ../..\n rm -rf usr\n \n cat > /x-tools/x86_64-unknown-netbsd/bin/x86_64--netbsd-gcc-sysroot <<'EOF'\n-#!/bin/bash\n+#!/usr/bin/env bash\n exec /x-tools/x86_64-unknown-netbsd/bin/x86_64--netbsd-gcc --sysroot=/x-tools/x86_64-unknown-netbsd/sysroot \"$@\"\n EOF\n \n cat > /x-tools/x86_64-unknown-netbsd/bin/x86_64--netbsd-g++-sysroot <<'EOF'\n-#!/bin/bash\n+#!/usr/bin/env bash\n exec /x-tools/x86_64-unknown-netbsd/bin/x86_64--netbsd-g++ --sysroot=/x-tools/x86_64-unknown-netbsd/sysroot \"$@\"\n EOF\n "}, {"sha": "a863e1a2d5dc07f658ec5e678aa048912fe29219", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -11,6 +11,8 @@\n \n set -e\n \n+export MSYS_NO_PATHCONV=1\n+\n script=`cd $(dirname $0) && pwd`/`basename $0`\n image=$1\n \n@@ -25,23 +27,32 @@ travis_fold start build_docker\n travis_time_start\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n+    dockerfile=\"$docker_dir/$image/Dockerfile\"\n+    if [ -x /usr/bin/cygpath ]; then\n+        context=\"`cygpath -w $docker_dir`\"\n+        dockerfile=\"`cygpath -w $dockerfile`\"\n+    else\n+        context=\"$docker_dir\"\n+    fi\n     retry docker \\\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      -f \"$docker_dir/$image/Dockerfile\" \\\n-      \"$docker_dir\"\n+      -f \"$dockerfile\" \\\n+      \"$context\"\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!\n         exit 1\n     fi\n-    retry docker \\\n+    # retry messes with the pipe from tar to docker. Not needed on non-travis\n+    # Transform changes the context of disabled Dockerfiles to match the enabled ones\n+    tar --transform 's#^./disabled/#./#' -C $docker_dir -c . | docker \\\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      -f \"$docker_dir/disabled/$image/Dockerfile\" \\\n-      \"$docker_dir\"\n+      -f \"$image/Dockerfile\" \\\n+      -\n else\n     echo Invalid image: $image\n     exit 1"}, {"sha": "99c5776c2e849a95b45d56dfdee5ed21d3a39e49", "filename": "src/ci/docker/scripts/android-sdk.sh", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -10,44 +10,56 @@\n \n set -ex\n \n-URL=https://dl.google.com/android/repository\n+export ANDROID_HOME=/android/sdk\n+PATH=$PATH:\"${ANDROID_HOME}/tools/bin\"\n \n download_sdk() {\n-    mkdir -p /android/sdk\n-    cd /android/sdk\n-    curl -fO $URL/$1\n-    unzip -q $1\n-    rm -rf $1\n+    mkdir -p /android\n+    curl -fo sdk.zip \"https://dl.google.com/android/repository/sdk-tools-linux-$1.zip\"\n+    unzip -q sdk.zip -d \"$ANDROID_HOME\"\n+    rm -f sdk.zip\n }\n \n download_sysimage() {\n-    # See https://developer.android.com/studio/tools/help/android.html\n     abi=$1\n     api=$2\n \n-    filter=\"platform-tools,android-$api\"\n-    filter=\"$filter,sys-img-$abi-android-$api\"\n-\n-    # Keep printing yes to accept the licenses\n-    while true; do echo yes; sleep 10; done | \\\n-        /android/sdk/tools/android update sdk -a --no-ui \\\n-            --filter \"$filter\"\n+    # See https://developer.android.com/studio/command-line/sdkmanager.html for\n+    # usage of `sdkmanager`.\n+    #\n+    # The output from sdkmanager is so noisy that it will occupy all of the 4 MB\n+    # log extremely quickly. Thus we must silence all output.\n+    yes | sdkmanager --licenses > /dev/null\n+    sdkmanager platform-tools emulator \\\n+        \"platforms;android-$api\" \\\n+        \"system-images;android-$api;default;$abi\" > /dev/null\n }\n \n create_avd() {\n-    # See https://developer.android.com/studio/tools/help/android.html\n     abi=$1\n     api=$2\n \n-    echo no | \\\n-        /android/sdk/tools/android create avd \\\n-            --name $abi-$api \\\n-            --target android-$api \\\n-            --abi $abi\n+    # See https://developer.android.com/studio/command-line/avdmanager.html for\n+    # usage of `avdmanager`.\n+    echo no | avdmanager create avd \\\n+        -n \"$abi-$api\" \\\n+        -k \"system-images;android-$api;default;$abi\"\n }\n \n download_and_create_avd() {\n     download_sdk $1\n     download_sysimage $2 $3\n     create_avd $2 $3\n }\n+\n+# Usage:\n+#\n+#       setup_android_sdk 4333796 armeabi-v7a 18\n+#\n+# 4333796 =>\n+#   SDK tool version.\n+#   Copy from https://developer.android.com/studio/index.html#command-tools\n+# armeabi-v7a =>\n+#   System image ABI\n+# 18 =>\n+#   Android API Level (18 = Android 4.3 = Jelly Bean MR2)"}, {"sha": "dc1727b7014c33a6d1999411f976e71f304be069", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n+    tar -xJ\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV TARGETS=wasm32-unknown-unknown\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+  --target=$TARGETS \\\n+  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node\n+\n+ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n+  src/test/ui \\\n+  src/test/run-pass \\\n+  src/test/compile-fail \\\n+  src/test/parse-fail \\\n+  src/test/mir-opt \\\n+  src/test/codegen-units \\\n+  src/libcore \\\n+  src/libstd_unicode/ \\"}, {"sha": "62c55f480673430e9eacde547a071275d2a2c448", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12,7 +12,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   sudo \\\n   xz-utils \\\n-  pkg-config\n+  pkg-config \\\n+  libgl1-mesa-dev \\\n+  llvm-dev \\\n+  libfreetype6-dev \\\n+  libexpat1-dev\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "6b8186048988d089a08c9e8bc8c4aa393c466f82", "filename": "src/ci/docker/x86_64-gnu-llvm-3.9/Dockerfile", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -11,15 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-3.7-tools \\\n+  llvm-3.9-tools \\\n   libedit-dev \\\n   zlib1g-dev \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+# using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-3.7\n+      --llvm-root=/usr/lib/llvm-3.9 \\\n+      --enable-llvm-link-shared\n ENV RUST_CHECK_TARGET check", "previous_filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile"}, {"sha": "fffad1c42dfd80d9ac34de825a55b0bc4c08de50", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,23 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  libssl-dev \\\n+  sudo \\\n+  xz-utils \\\n+  pkg-config\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+COPY x86_64-gnu-tools/checktools.sh /tmp/\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --save-toolstates=/tmp/toolstates.json\n+ENV SCRIPT /tmp/checktools.sh ../x.py /tmp/toolstates.json"}, {"sha": "bf39bc28a67eac2e293a03143458ea172b7ef86f", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,39 @@\n+#!/bin/sh\n+\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -eu\n+\n+X_PY=\"$1\"\n+TOOLSTATE_FILE=\"$2\"\n+\n+touch \"$TOOLSTATE_FILE\"\n+\n+set +e\n+python2.7 \"$X_PY\" test --no-fail-fast \\\n+    src/tools/rls \\\n+    src/tools/rustfmt \\\n+    src/tools/miri \\\n+    src/tools/clippy\n+TEST_RESULT=$?\n+set -e\n+\n+# FIXME: Upload this file to the repository.\n+cat \"$TOOLSTATE_FILE\"\n+\n+# FIXME: After we can properly inform dev-tool maintainers about failure,\n+#        comment out the `exit 0` below.\n+if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n+    # exit 0\n+    true\n+fi\n+\n+exit $TEST_RESULT"}, {"sha": "e073a3d99c157dc765293c8ca770a63a34a3ec33", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT."}, {"sha": "dab385c09649cd5a4b54cff972b93b1b2ff8ab0f", "filename": "src/ci/run.sh", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -37,19 +37,20 @@ if [ \"$DIST_SRC\" = \"\" ]; then\n fi\n \n # If we're deploying artifacts then we set the release channel, otherwise if\n-# we're not deploying then we want to be sure to enable all assertions becauase\n+# we're not deploying then we want to be sure to enable all assertions because\n # we'll be running tests\n #\n # FIXME: need a scheme for changing this `nightly` value to `beta` and `stable`\n #        either automatically or manually.\n+export RUST_RELEASE_CHANNEL=nightly\n if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n-  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=nightly\"\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n   elif [ \"$DEPLOY_ALT\" != \"\" ]; then\n-    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-assertions\"\n   fi\n else\n   # We almost always want debug assertions enabled, but sometimes this takes too"}, {"sha": "d3812c3accaee7ad23068ed4fc089cc05c7a538f", "filename": "src/dlmalloc", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1 @@\n+Subproject commit d3812c3accaee7ad23068ed4fc089cc05c7a538f"}, {"sha": "3944d61149fa234ea991b498d4dac4fcec68a80e", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1 +1 @@\n-Subproject commit d09c9e8144ed32170b7596abb145ade8b097acaf\n+Subproject commit 3944d61149fa234ea991b498d4dac4fcec68a80e"}, {"sha": "3784cc3c4b497fcb171297d0b136d306307656da", "filename": "src/doc/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -28,6 +28,7 @@ Rust provides a number of book-length sets of documentation, collectively\n nicknamed 'The Rust Bookshelf.'\n \n * [The Rust Programming Language][book] teaches you how to program in Rust.\n+* [The Cargo Book][cargo-book] is a guide to Cargo, Rust's build tool and dependency manager.\n * [The Unstable Book][unstable-book] has documentation for unstable features.\n * [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n * [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n@@ -53,4 +54,5 @@ before this policy was put into place. That work is being tracked\n [nomicon]: nomicon/index.html\n [unstable-book]: unstable-book/index.html\n [rustdoc-book]: rustdoc/index.html\n+[cargo-book]: cargo/index.html\n "}, {"sha": "0bb41cee2c518fbed9a7196bd2eb2f1cd373cc4c", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -152,9 +152,6 @@ never colorize output.\n \n .SH CODEGEN OPTIONS\n \n-.TP\n-\\fBar\\fR=\\fI/path/to/ar\\fR\n-Path to the archive utility to use when assembling archives.\n .TP\n \\fBlinker\\fR=\\fI/path/to/cc\\fR\n Path to the linker utility to use when linking libraries, executables, and"}, {"sha": "cfb1f2d7e5eb6143915d5a63afe4cf58e8531c27", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1 +1 @@\n-Subproject commit a4322ccb289a43cc238d4536982f184a3eec9ba7\n+Subproject commit cfb1f2d7e5eb6143915d5a63afe4cf58e8531c27"}, {"sha": "ebe7c59313fa59df5f46918639a8df3b59257f3c", "filename": "src/doc/not_found.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -22,7 +22,7 @@ Some things that might be helpful to you though:\n # Reference\n \n * [The Rust official site](https://www.rust-lang.org)\n-* [The Rust reference](https://doc.rust-lang.org/reference.html)\n+* [The Rust reference](https://doc.rust-lang.org/reference/index.html)\n \n # Docs\n "}, {"sha": "857f2c97c8075d39fa07eb4a404980519faa600a", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1 +1 @@\n-Subproject commit 266d429a48468371d2d90669f6a30dd659bb4bdb\n+Subproject commit 857f2c97c8075d39fa07eb4a404980519faa600a"}, {"sha": "e51c63cf008981ae5f4cfcfcbdb2f77cd6bb9f85", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -96,11 +96,11 @@ Using this flag looks like this:\n $ rustdoc src/lib.rs --crate-name mycrate\n ```\n \n-By default, `rustodc` assumes that the name of your crate is the same name\n+By default, `rustdoc` assumes that the name of your crate is the same name\n as the `.rs` file. `--crate-name` lets you override this assumption with\n whatever name you choose.\n \n-## `-L`/`--library-path`: \n+## `-L`/`--library-path`: where to look for dependencies\n \n Using this flag looks like this:\n \n@@ -186,7 +186,7 @@ on documentation tests](documentation-tests.html).\n \n See also `--test-args`.\n \n-## `--test-args`: \n+## `--test-args`: pass options to test runner\n \n Using this flag looks like this:\n \n@@ -199,7 +199,7 @@ For more, see [the chapter on documentation tests](documentation-tests.html).\n \n See also `--test`.\n \n-## `--target`: \n+## `--target`: generate documentation for the specified target triple\n \n Using this flag looks like this:\n \n@@ -253,7 +253,7 @@ $ rustdoc README.md --html-before-content extra.html\n ```\n \n This flag takes a list of files, and inserts them inside the `<body>` tag but\n-before the other content `rustodc` would normally produce in the rendered\n+before the other content `rustdoc` would normally produce in the rendered\n documentation.\n \n ## `--html-after-content`: include more HTML after the content\n@@ -266,7 +266,7 @@ $ rustdoc README.md --html-after-content extra.html\n ```\n \n This flag takes a list of files, and inserts them before the `</body>` tag but\n-after the other content `rustodc` would normally produce in the rendered\n+after the other content `rustdoc` would normally produce in the rendered\n documentation.\n \n \n@@ -279,7 +279,7 @@ $ rustdoc README.md --markdown-playground-url https://play.rust-lang.org/\n ```\n \n When rendering a Markdown file, this flag gives the base URL of the Rust\n-Playround, to use for generating `Run` buttons.\n+Playground, to use for generating `Run` buttons.\n \n \n ## `--markdown-no-toc`: don't generate a table of contents\n@@ -291,7 +291,7 @@ $ rustdoc README.md --markdown-no-toc\n ```\n \n When generating documentation from a Markdown file, by default, `rustdoc` will\n-generate a table of contents. This flag supresses that, and no TOC will be\n+generate a table of contents. This flag suppresses that, and no TOC will be\n generated.\n \n "}, {"sha": "e5a603a3709f6453dc4eaa4ca4610b69bbd94afe", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -38,17 +38,19 @@ function! Forcing you to write `main` for every example, no matter how small,\n adds friction. So `rustdoc` processes your examples slightly before\n running them. Here's the full algorithm rustdoc uses to preprocess examples:\n \n-1. Any leading `#![foo]` attributes are left intact as crate attributes.\n-2. Some common `allow` attributes are inserted, including\n+1. Some common `allow` attributes are inserted, including\n    `unused_variables`, `unused_assignments`, `unused_mut`,\n    `unused_attributes`, and `dead_code`. Small examples often trigger\n    these lints.\n-3. If the example does not contain `extern crate`, then `extern crate\n+2. Any attributes specified with `#![doc(test(attr(...)))]` are added.\n+3. Any leading `#![foo]` attributes are left intact as crate attributes.\n+4. If the example does not contain `extern crate`, and\n+   `#![doc(test(no_crate_inject))]` was not specified, then `extern crate\n    <mycrate>;` is inserted (note the lack of `#[macro_use]`).\n-4. Finally, if the example does not contain `fn main`, the remainder of the\n+5. Finally, if the example does not contain `fn main`, the remainder of the\n    text is wrapped in `fn main() { your_code }`.\n \n-For more about that caveat in rule 3, see \"Documeting Macros\" below.\n+For more about that caveat in rule 4, see \"Documenting Macros\" below.\n \n ## Hiding portions of the example\n \n@@ -261,4 +263,4 @@ are added.\n The `no_run` attribute will compile your code, but not run it. This is\n important for examples such as \"Here's how to retrieve a web page,\"\n which you would want to ensure compiles, but might be run in a test\n-environment that has no network access.\n\\ No newline at end of file\n+environment that has no network access."}, {"sha": "aadd72d1c902d67ca415ef4b721f4087c85ad3bc", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -103,6 +103,26 @@ to it in the docs. But if you include this:\n \n it will not.\n \n+### `test(no_crate_inject)`\n+\n+By default, `rustdoc` will automatically add a line with `extern crate my_crate;` into each doctest.\n+But if you include this:\n+\n+```rust,ignore\n+#![doc(test(no_crate_inject))]\n+```\n+\n+it will not.\n+\n+### `test(attr(...))`\n+\n+This form of the `doc` attribute allows you to add arbitrary attributes to all your doctests. For\n+example, if you want your doctests to fail if they produce any warnings, you could add this:\n+\n+```rust,ignore\n+#![doc(test(attr(deny(warnings))))]\n+```\n+\n ## At the item level\n \n These forms of the `#[doc]` attribute are used on individual items, to control how"}, {"sha": "6606f3c4e5c549c5789863165178cb13b5a1c9a0", "filename": "src/doc/unstable-book/src/language-features/attr-literals.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fattr-literals.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fattr-literals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fattr-literals.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,16 +15,16 @@ The `attr_literals` unstable feature allows other types of literals to be used\n in attributes. Here are some examples of attributes that can now be used with\n this feature enabled:\n \n-+```rust,ignore\n-+#[attr]\n-+#[attr(true)]\n-+#[attr(ident)]\n-+#[attr(ident, 100, true, \"true\", ident = 100, ident = \"hello\", ident(100))]\n-+#[attr(100)]\n-+#[attr(enabled = true)]\n-+#[enabled(true)]\n-+#[attr(\"hello\")]\n-+#[repr(C, align = 4)]\n-+#[repr(C, align(4))]\n-+```\n+```rust,ignore\n+#[attr]\n+#[attr(true)]\n+#[attr(ident)]\n+#[attr(ident, 100, true, \"true\", ident = 100, ident = \"hello\", ident(100))]\n+#[attr(100)]\n+#[attr(enabled = true)]\n+#[enabled(true)]\n+#[attr(\"hello\")]\n+#[repr(C, align = 4)]\n+#[repr(C, align(4))]\n+```\n "}, {"sha": "11b3ee8edf0b1a13329f818ba7e27f16be297f03", "filename": "src/doc/unstable-book/src/language-features/crate-visibility-modifier.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,20 @@\n+# `crate_visibility_modifier`\n+\n+The tracking issue for this feature is: [#45388]\n+\n+[#45388]: https://github.com/rust-lang/rust/issues/45388\n+\n+-----\n+\n+The `crate_visibility_modifier` feature allows the `crate` keyword to be used\n+as a visibility modifier synonymous to `pub(crate)`, indicating that a type\n+(function, _&c._) is to be visible to the entire enclosing crate, but not to\n+other crates.\n+\n+```rust\n+#![feature(crate_visibility_modifier)]\n+\n+crate struct Foo {\n+    bar: usize,\n+}\n+```"}, {"sha": "8117755fef1c8741f45648c178c98d37f4e3928d", "filename": "src/doc/unstable-book/src/language-features/doc-spotlight.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,30 @@\n+# `doc_spotlight`\n+\n+The tracking issue for this feature is: [#45040]\n+\n+The `doc_spotlight` feature allows the use of the `spotlight` parameter to the `#[doc]` attribute,\n+to \"spotlight\" a specific trait on the return values of functions. Adding a `#[doc(spotlight)]`\n+attribute to a trait definition will make rustdoc print extra information for functions which return\n+a type that implements that trait. This attribute is applied to the `Iterator`, `io::Read`, and\n+`io::Write` traits in the standard library.\n+\n+You can do this on your own traits, like this:\n+\n+```\n+#![feature(doc_spotlight)]\n+\n+#[doc(spotlight)]\n+pub trait MyTrait {}\n+\n+pub struct MyStruct;\n+impl MyTrait for MyStruct {}\n+\n+/// The docs for this function will have an extra line about `MyStruct` implementing `MyTrait`,\n+/// without having to write that yourself!\n+pub fn my_fn() -> MyStruct { MyStruct }\n+```\n+\n+This feature was originally implemented in PR [#45039].\n+\n+[#45040]: https://github.com/rust-lang/rust/issues/45040\n+[#45039]: https://github.com/rust-lang/rust/pull/45039"}, {"sha": "effae5d299949181a6cc8d7e4dc53c6a7d49cc0a", "filename": "src/doc/unstable-book/src/language-features/external-doc.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,40 @@\n+# `external_doc`\n+\n+The tracking issue for this feature is: [#44732]\n+\n+The `external_doc` feature allows the use of the `include` parameter to the `#[doc]` attribute, to\n+include external files in documentation. Use the attribute in place of, or in addition to, regular\n+doc comments and `#[doc]` attributes, and `rustdoc` will load the given file when it renders\n+documentation for your crate.\n+\n+With the following files in the same directory:\n+\n+`external-doc.md`:\n+\n+```markdown\n+# My Awesome Type\n+\n+This is the documentation for this spectacular type.\n+```\n+\n+`lib.rs`:\n+\n+```no_run (needs-external-files)\n+#![feature(external_doc)]\n+\n+#[doc(include = \"external-doc.md\")]\n+pub struct MyAwesomeType;\n+```\n+\n+`rustdoc` will load the file `external-doc.md` and use it as the documentation for the `MyAwesomeType`\n+struct.\n+\n+When locating files, `rustdoc` will base paths in the `src/` directory, as if they were alongside the\n+`lib.rs` for your crate. So if you want a `docs/` folder to live alongside the `src/` directory,\n+start your paths with `../docs/` for `rustdoc` to properly find the file.\n+\n+This feature was proposed in [RFC #1990] and initially implemented in PR [#44781].\n+\n+[#44732]: https://github.com/rust-lang/rust/issues/44732\n+[RFC #1990]: https://github.com/rust-lang/rfcs/pull/1990\n+[#44781]: https://github.com/rust-lang/rust/pull/44781"}, {"sha": "0137a052a62d868f02fcfded212f49fc0e634ba9", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -227,3 +227,95 @@ A third function, `rust_eh_unwind_resume`, is also needed if the `custom_unwind_\n flag is set in the options of the compilation target. It allows customizing the\n process of resuming unwind at the end of the landing pads. The language item's name\n is `eh_unwind_resume`.\n+\n+## List of all language items\n+\n+This is a list of all language items in Rust along with where they are located in\n+the source code.\n+\n+- Primitives\n+  - `i8`: `libcore/num/mod.rs`\n+  - `i16`: `libcore/num/mod.rs`\n+  - `i32`: `libcore/num/mod.rs`\n+  - `i64`: `libcore/num/mod.rs`\n+  - `i128`: `libcore/num/mod.rs`\n+  - `isize`: `libcore/num/mod.rs`\n+  - `u8`: `libcore/num/mod.rs`\n+  - `u16`: `libcore/num/mod.rs`\n+  - `u32`: `libcore/num/mod.rs`\n+  - `u64`: `libcore/num/mod.rs`\n+  - `u128`: `libcore/num/mod.rs`\n+  - `usize`: `libcore/num/mod.rs`\n+  - `f32`: `libstd/f32.rs`\n+  - `f64`: `libstd/f64.rs`\n+  - `char`: `libstd_unicode/char.rs`\n+  - `slice`: `liballoc/slice.rs`\n+  - `str`: `liballoc/str.rs`\n+  - `const_ptr`: `libcore/ptr.rs`\n+  - `mut_ptr`: `libcore/ptr.rs`\n+  - `unsafe_cell`: `libcore/cell.rs`\n+- Runtime\n+  - `start`: `libstd/rt.rs`\n+  - `eh_personality`: `libpanic_unwind/emcc.rs` (EMCC)\n+  - `eh_personality`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_personality`: `libpanic_unwind/seh.rs` (SEH)\n+  - `eh_unwind_resume`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_unwind_resume`: `libpanic_unwind/gcc.rs` (GCC)\n+  - `msvc_try_filter`: `libpanic_unwind/seh.rs` (SEH)\n+  - `panic`: `libcore/panicking.rs`\n+  - `panic_bounds_check`: `libcore/panicking.rs`\n+  - `panic_fmt`: `libcore/panicking.rs`\n+  - `panic_fmt`: `libstd/panicking.rs`\n+- Allocations\n+  - `owned_box`: `liballoc/boxed.rs`\n+  - `exchange_malloc`: `liballoc/heap.rs`\n+  - `box_free`: `liballoc/heap.rs`\n+- Operands\n+  - `not`: `libcore/ops/bit.rs`\n+  - `bitand`: `libcore/ops/bit.rs`\n+  - `bitor`: `libcore/ops/bit.rs`\n+  - `bitxor`: `libcore/ops/bit.rs`\n+  - `shl`: `libcore/ops/bit.rs`\n+  - `shr`: `libcore/ops/bit.rs`\n+  - `bitand_assign`: `libcore/ops/bit.rs`\n+  - `bitor_assign`: `libcore/ops/bit.rs`\n+  - `bitxor_assign`: `libcore/ops/bit.rs`\n+  - `shl_assign`: `libcore/ops/bit.rs`\n+  - `shr_assign`: `libcore/ops/bit.rs`\n+  - `deref`: `libcore/ops/deref.rs`\n+  - `deref_mut`: `libcore/ops/deref.rs`\n+  - `index`: `libcore/ops/index.rs`\n+  - `index_mut`: `libcore/ops/index.rs`\n+  - `add`: `libcore/ops/arith.rs`\n+  - `sub`: `libcore/ops/arith.rs`\n+  - `mul`: `libcore/ops/arith.rs`\n+  - `div`: `libcore/ops/arith.rs`\n+  - `rem`: `libcore/ops/arith.rs`\n+  - `neg`: `libcore/ops/arith.rs`\n+  - `add_assign`: `libcore/ops/arith.rs`\n+  - `sub_assign`: `libcore/ops/arith.rs`\n+  - `mul_assign`: `libcore/ops/arith.rs`\n+  - `div_assign`: `libcore/ops/arith.rs`\n+  - `rem_assign`: `libcore/ops/arith.rs`\n+  - `eq`: `libcore/cmp.rs`\n+  - `ord`: `libcore/cmp.rs`\n+- Functions\n+  - `fn`: `libcore/ops/function.rs`\n+  - `fn_mut`: `libcore/ops/function.rs`\n+  - `fn_once`: `libcore/ops/function.rs`\n+  - `generator_state`: `libcore/ops/generator.rs`\n+  - `generator`: `libcore/ops/generator.rs`\n+- Other\n+  - `coerce_unsized`: `libcore/ops/unsize.rs`\n+  - `drop`: `libcore/ops/drop.rs`\n+  - `drop_in_place`: `libcore/ptr.rs`\n+  - `clone`: `libcore/clone.rs`\n+  - `copy`: `libcore/marker.rs`\n+  - `send`: `libcore/marker.rs`\n+  - `sized`: `libcore/marker.rs`\n+  - `unsize`: `libcore/marker.rs`\n+  - `sync`: `libcore/marker.rs`\n+  - `phantom_data`: `libcore/marker.rs`\n+  - `freeze`: `libcore/marker.rs`\n+  - `debug_trait`: `libcore/fmt/mod.rs`\n+  - `non_zero`: `libcore/nonzero.rs`\n\\ No newline at end of file"}, {"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match_default_bindings.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,58 @@\n+# `match_default_bindings`\n+\n+The tracking issue for this feature is: [#42640]\n+\n+[#42640]: https://github.com/rust-lang/rust/issues/42640\n+\n+------------------------\n+\n+Match default bindings (also called \"default binding modes in match\") improves ergonomics for\n+pattern-matching on references by introducing automatic dereferencing (and a corresponding shift\n+in binding modes) for large classes of patterns that would otherwise not compile.\n+\n+For example, under match default bindings,\n+\n+```rust\n+#![feature(match_default_bindings)]\n+\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match x {\n+        Some(y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        None => {},\n+    }\n+}\n+```\n+\n+compiles and is equivalent to either of the below:\n+\n+```rust\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match *x {\n+        Some(ref y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        None => {},\n+    }\n+}\n+```\n+\n+or\n+\n+```rust\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match x {\n+        &Some(ref y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        &None => {},\n+    }\n+}\n+```"}, {"sha": "efb5495fe26acf32334ddd188aaa9db53c644a0b", "filename": "src/doc/unstable-book/src/language-features/non-ascii-idents.md", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,4 +15,34 @@ The `non_ascii_idents` feature adds support for non-ASCII identifiers.\n \n const \u03b5: f64 = 0.00001f64;\n const \u03a0: f64 = 3.14f64;\n-```\n\\ No newline at end of file\n+```\n+\n+## Changes to the language reference\n+\n+> **<sup>Lexer:<sup>**  \n+> IDENTIFIER :  \n+> &nbsp;&nbsp; &nbsp;&nbsp; XID_start XID_continue<sup>\\*</sup>  \n+> &nbsp;&nbsp; | `_` XID_continue<sup>+</sup>  \n+\n+An identifier is any nonempty Unicode string of the following form:\n+\n+Either\n+\n+   * The first character has property [`XID_start`]\n+   * The remaining characters have property [`XID_continue`]\n+\n+Or\n+\n+   * The first character is `_`\n+   * The identifier is more than one character, `_` alone is not an identifier\n+   * The remaining characters have property [`XID_continue`]\n+\n+that does _not_ occur in the set of [strict keywords].\n+\n+> **Note**: [`XID_start`] and [`XID_continue`] as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers.\n+\n+[`XID_start`]:  http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=\n+[`XID_continue`]: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=\n+[strict keywords]: ../reference/keywords.html#strict-keywords"}, {"sha": "f9840e1b83f2be4b84d2a7cb7883db89f2e81fce", "filename": "src/doc/unstable-book/src/language-features/non-exhaustive.md", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,75 @@\n+# `non_exhaustive`\n+\n+The tracking issue for this feature is: [#44109]\n+\n+[#44109]: https://github.com/rust-lang/rust/issues/44109\n+\n+------------------------\n+\n+The `non_exhaustive` gate allows you to use the `#[non_exhaustive]` attribute\n+on structs and enums. When applied within a crate, users of the crate will need\n+to use the `_` pattern when matching enums and use the `..` pattern when\n+matching structs. Structs marked as `non_exhaustive` will not be able to be\n+created normally outside of the defining crate. This is demonstrated below:\n+\n+```rust,ignore (pseudo-Rust)\n+use std::error::Error as StdError;\n+\n+#[non_exhaustive]\n+pub enum Error {\n+    Message(String),\n+    Other,\n+}\n+impl StdError for Error {\n+    fn description(&self) -> &str {\n+        // This will not error, despite being marked as non_exhaustive, as this\n+        // enum is defined within the current crate, it can be matched\n+        // exhaustively.\n+        match *self {\n+            Message(ref s) => s,\n+            Other => \"other or unknown error\",\n+        }\n+    }\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+use mycrate::Error;\n+\n+// This will not error as the non_exhaustive Error enum has been matched with\n+// a wildcard.\n+match error {\n+    Message(ref s) => ...,\n+    Other => ...,\n+    _ => ...,\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#[non_exhaustive]\n+pub struct Config {\n+    pub window_width: u16,\n+    pub window_height: u16,\n+}\n+\n+// We can create structs as normal within the defining crate when marked as\n+// non_exhaustive.\n+let config = Config { window_width: 640, window_height: 480 };\n+\n+// We can match structs exhaustively when within the defining crate.\n+if let Ok(Config { window_width, window_height }) = load_config() {\n+    // ...\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+use mycrate::Config;\n+\n+// We cannot create a struct like normal if it has been marked as\n+// non_exhaustive.\n+let config = Config { window_width: 640, window_height: 480 };\n+// By adding the `..` we can match the config as below outside of the crate\n+// when marked non_exhaustive.\n+let &Config { window_width, window_height, .. } = config;\n+```\n+"}, {"sha": "70c7c110b786a9569effe2e359764357b228e527", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,8 +15,8 @@ For example:\n ```rust,compile_fail\n #![feature(on_unimplemented)]\n \n-#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an \\\n-                          iterator over elements of type `{A}`\"]\n+#[rustc_on_unimplemented=\"an iterator over elements of type `{A}` \\\n+    cannot be built from a collection of type `{Self}`\"]\n trait MyIterator<A> {\n     fn next(&mut self) -> A;\n }\n@@ -37,9 +37,9 @@ error[E0277]: the trait bound `&[{integer}]: MyIterator<char>` is not satisfied\n   --> <anon>:14:5\n    |\n 14 |     iterate_chars(&[1, 2, 3][..]);\n-   |     ^^^^^^^^^^^^^ the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n+   |     ^^^^^^^^^^^^^ an iterator over elements of type `char` cannot be built from a collection of type `&[{integer}]`\n    |\n-   = note: a collection of type `&[{integer}]` cannot be built from an iterator over elements of type `char`\n+   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n    = note: required by `iterate_chars`\n \n error: aborting due to previous error"}, {"sha": "5c8124c9c6b7d459e2b19ec4a2cf381991e8ca34", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,45 @@\n+# `optin_builtin_traits`\n+\n+The tracking issue for this feature is [#13231] \n+\n+[#13231]: https://github.com/rust-lang/rust/issues/13231\n+\n+----\n+\n+The `optin_builtin_traits` feature gate allows you to define auto traits.\n+\n+Auto traits, like [`Send`] or [`Sync`] in the standard library, are marker traits\n+that are automatically implemented for every type, unless the type, or a type it contains, \n+has explicitly opted out via a negative impl. \n+\n+[`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html\n+[`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n+\n+```rust,ignore\n+impl !Type for Trait\n+```\n+\n+Example:\n+\n+```rust\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Valid {}\n+\n+struct True;\n+struct False;\n+\n+impl !Valid for False {}\n+\n+struct MaybeValid<T>(T);\n+\n+fn must_be_valid<T: Valid>(_t: T) { }\n+\n+fn main() {\n+    // works\n+    must_be_valid( MaybeValid(True) );\n+                \n+    // compiler error - trait bound not satisfied\n+    // must_be_valid( MaybeValid(False) );\n+}\n+```"}, {"sha": "1cece930eeaa56bfe65e6dd657fa88d944ff01ce", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -177,7 +177,7 @@ quasiquote as an ordinary plugin library.\n Plugins can extend [Rust's lint\n infrastructure](../reference/attributes.html#lint-check-attributes) with\n additional checks for code style, safety, etc. Now let's write a plugin\n-[`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs)\n+[`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/lint_plugin_test.rs)\n that warns about any item named `lintme`.\n \n ```rust,ignore"}, {"sha": "41aa286e69bfb320a0467ce4659e506093257807", "filename": "src/doc/unstable-book/src/language-features/trace-macros.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,39 @@\n+# `trace_macros`\n+\n+The tracking issue for this feature is [#29598].\n+\n+[#29598]: https://github.com/rust-lang/rust/issues/29598\n+\n+------------------------\n+\n+With `trace_macros` you can trace the expansion of macros in your code.\n+\n+## Examples\n+\n+```rust\n+#![feature(trace_macros)]\n+\n+fn main() {\n+    trace_macros!(true);\n+    println!(\"Hello, Rust!\");\n+    trace_macros!(false);\n+}\n+```\n+\n+The `cargo build` output:\n+\n+```txt\n+note: trace_macro\n+ --> src/main.rs:5:5\n+  |\n+5 |     println!(\"Hello, Rust!\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+  = note: expanding `println! { \"Hello, Rust!\" }`\n+  = note: to `print ! ( concat ! ( \"Hello, Rust!\" , \"\\n\" ) )`\n+  = note: expanding `print! { concat ! ( \"Hello, Rust!\" , \"\\n\" ) }`\n+  = note: to `$crate :: io :: _print ( format_args ! ( concat ! ( \"Hello, Rust!\" , \"\\n\" ) )\n+          )`\n+\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs\n+```"}, {"sha": "d845c99a88a691946d439861d7df4acec850a998", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,25 @@\n+# `unboxed_closures`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`fn_traits`](library-features/fn-traits.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `unboxed_closures` feature allows you to write functions using the `\"rust-call\"` ABI,\n+required for implementing the [`Fn*`] family of traits. `\"rust-call\"` functions must have \n+exactly one (non self) argument, a tuple representing the argument list.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+\n+extern \"rust-call\" fn add_args(args: (u32, u32)) -> u32 {\n+    args.0 + args.1\n+}\n+\n+fn main() {}\n+```"}, {"sha": "6b3c5e92720df6e9ef6ee001f4676c96dadadf98", "filename": "src/doc/unstable-book/src/language-features/universal-impl-trait.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,32 @@\n+# `universal_impl_trait`\n+\n+The tracking issue for this feature is: [#34511].\n+\n+[#34511]: https://github.com/rust-lang/rust/issues/34511\n+\n+--------------------\n+\n+The `universal_impl_trait` feature extends the [`conservative_impl_trait`]\n+feature allowing the `impl Trait` syntax in arguments (universal\n+quantification).\n+\n+[`conservative_impl_trait`]: ./language-features/conservative-impl-trait.html\n+\n+## Examples\n+\n+```rust\n+#![feature(universal_impl_trait)]\n+use std::ops::Not;\n+\n+fn any_zero(values: impl IntoIterator<Item = i32>) -> bool {\n+    for val in values { if val == 0 { return true; } }\n+    false\n+}\n+\n+fn main() {\n+    let test1 = -5..;\n+    let test2 = vec![1, 8, 42, -87, 60];\n+    assert!(any_zero(test1));\n+    assert!(bool::not(any_zero(test2)));\n+}\n+```"}, {"sha": "47b635bad736ff80af85b7ce71f0cef7b748c7e6", "filename": "src/doc/unstable-book/src/language-features/use-nested-groups.md", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,90 @@\n+# `use_nested_groups`\n+\n+The tracking issue for this feature is: [#44494]\n+\n+[#44494]: https://github.com/rust-lang/rust/issues/44494\n+\n+------------------------\n+\n+The `use_nested_groups` feature allows you to import multiple items from a\n+complex module tree easily, by nesting different imports in the same\n+declaration. For example:\n+\n+```rust\n+#![feature(use_nested_groups)]\n+# #![allow(unused_imports, dead_code)]\n+#\n+# mod foo {\n+#     pub mod bar {\n+#         pub type Foo = ();\n+#     }\n+#     pub mod baz {\n+#         pub mod quux {\n+#             pub type Bar = ();\n+#         }\n+#     }\n+# }\n+\n+use foo::{\n+    bar::{self, Foo},\n+    baz::{*, quux::Bar},\n+};\n+#\n+# fn main() {}\n+```\n+\n+## Snippet for the book's new features appendix\n+\n+When stabilizing, add this to\n+`src/doc/book/second-edition/src/appendix-07-newest-features.md`:\n+\n+### Nested groups in `use` declarations\n+\n+If you have a complex module tree with many different submodules and you need\n+to import a few items from each one, it might be useful to group all the\n+imports in the same declaration to keep your code clean and avoid repeating the\n+base modules' name.\n+\n+The `use` declaration supports nesting to help you in those cases, both with\n+simple imports and glob ones. For example this snippets imports `bar`, `Foo`,\n+all the items in `baz` and `Bar`:\n+\n+```rust\n+# #![feature(use_nested_groups)]\n+# #![allow(unused_imports, dead_code)]\n+#\n+# mod foo {\n+#     pub mod bar {\n+#         pub type Foo = ();\n+#     }\n+#     pub mod baz {\n+#         pub mod quux {\n+#             pub type Bar = ();\n+#         }\n+#     }\n+# }\n+#\n+use foo::{\n+    bar::{self, Foo},\n+    baz::{*, quux::Bar},\n+};\n+#\n+# fn main() {}\n+```\n+\n+## Updated reference\n+\n+When stabilizing, replace the shortcut list in\n+`src/doc/reference/src/items/use-declarations.md` with this updated one:\n+\n+* Simultaneously binding a list of paths with a common prefix, using the\n+  glob-like brace syntax `use a::b::{c, d, e::f, g::h::i};`\n+* Simultaneously binding a list of paths with a common prefix and their common\n+  parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`\n+* Rebinding the target name as a new local name, using the syntax `use p::q::r\n+  as x;`. This can also be used with the last two features:\n+  `use a::b::{self as ab, c as abc}`.\n+* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n+  `use a::b::*;`.\n+* Nesting groups of the previous features multiple times, such as\n+  `use a::b::{self as ab, c d::{*, e::f}};`"}, {"sha": "425d4cb79b2df7e359fbd0c05edd3c8155d3156c", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,55 +8,6 @@ See also [`alloc_system`](library-features/alloc-system.html).\n \n ------------------------\n \n-The compiler currently ships two default allocators: `alloc_system` and\n-`alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n-are normal Rust crates and contain an implementation of the routines to\n-allocate and deallocate memory. The standard library is not compiled assuming\n-either one, and the compiler will decide which allocator is in use at\n-compile-time depending on the type of output artifact being produced.\n-\n-Binaries generated by the compiler will use `alloc_jemalloc` by default (where\n-available). In this situation the compiler \"controls the world\" in the sense of\n-it has power over the final link. Primarily this means that the allocator\n-decision can be left up the compiler.\n-\n-Dynamic and static libraries, however, will use `alloc_system` by default. Here\n-Rust is typically a 'guest' in another application or another world where it\n-cannot authoritatively decide what allocator is in use. As a result it resorts\n-back to the standard APIs (e.g. `malloc` and `free`) for acquiring and releasing\n-memory.\n-\n-# Switching Allocators\n-\n-Although the compiler's default choices may work most of the time, it's often\n-necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done simply by linking to the desired allocator:\n-\n-```rust,no_run\n-#![feature(alloc_system)]\n-\n-extern crate alloc_system;\n-\n-fn main() {\n-    let a = Box::new(4); // Allocates from the system allocator.\n-    println!(\"{}\", a);\n-}\n-```\n-\n-In this example the binary generated will not link to jemalloc by default but\n-instead use the system allocator. Conversely to generate a dynamic library which\n-uses jemalloc by default one would write:\n-\n-```rust,ignore\n-#![feature(alloc_jemalloc)]\n-#![crate_type = \"dylib\"]\n-\n-extern crate alloc_jemalloc;\n-\n-pub fn foo() {\n-    let a = Box::new(4); // Allocates from jemalloc.\n-    println!(\"{}\", a);\n-}\n-# fn main() {}\n-```\n+This feature has been replaced by [the `jemallocator` crate on crates.io.][jemallocator].\n \n+[jemallocator]: https://crates.io/crates/jemallocator"}, {"sha": "9effab202cabd909b8c270110f2ff1df5f7fa568", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,10 +1,10 @@\n # `alloc_system`\n \n-The tracking issue for this feature is: [#33082]\n+The tracking issue for this feature is: [#32838]\n \n-[#33082]: https://github.com/rust-lang/rust/issues/33082\n+[#32838]: https://github.com/rust-lang/rust/issues/32838\n \n-See also [`alloc_jemalloc`](library-features/alloc-jemalloc.html).\n+See also [`global_allocator`](language-features/global-allocator.html).\n \n ------------------------\n \n@@ -30,13 +30,18 @@ memory.\n \n Although the compiler's default choices may work most of the time, it's often\n necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done simply by linking to the desired allocator:\n+which allocator is in use is done through the `#[global_allocator]` attribute:\n \n ```rust,no_run\n-#![feature(alloc_system)]\n+#![feature(alloc_system, global_allocator, allocator_api)]\n \n extern crate alloc_system;\n \n+use alloc_system::System;\n+\n+#[global_allocator]\n+static A: System = System;\n+\n fn main() {\n     let a = Box::new(4); // Allocates from the system allocator.\n     println!(\"{}\", a);\n@@ -47,16 +52,26 @@ In this example the binary generated will not link to jemalloc by default but\n instead use the system allocator. Conversely to generate a dynamic library which\n uses jemalloc by default one would write:\n \n+(The `alloc_jemalloc` crate cannot be used to control the global allocator,\n+crate.io\u2019s `jemallocator` crate provides equivalent functionality.)\n+\n+```toml\n+# Cargo.toml\n+[dependencies]\n+jemallocator = \"0.1\"\n+```\n ```rust,ignore\n-#![feature(alloc_jemalloc)]\n+#![feature(global_allocator)]\n #![crate_type = \"dylib\"]\n \n-extern crate alloc_jemalloc;\n+extern crate jemallocator;\n+\n+#[global_allocator]\n+static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n pub fn foo() {\n     let a = Box::new(4); // Allocates from jemalloc.\n     println!(\"{}\", a);\n }\n # fn main() {}\n ```\n-"}, {"sha": "5c937833c9e26a4489893b4680a58285f3833a37", "filename": "src/doc/unstable-book/src/library-features/collections.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,5 +0,0 @@\n-# `collections`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "1280c71e83c922fa2b5e3befe3419f6014aa1dd2", "filename": "src/doc/unstable-book/src/library-features/entry-and-modify.md", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,77 @@\n+# `entry_and_modify`\n+\n+The tracking issue for this feature is: [#44733]\n+\n+[#44733]: https://github.com/rust-lang/rust/issues/44733\n+\n+------------------------\n+\n+This introduces a new method for the Entry API of maps\n+(`std::collections::HashMap` and `std::collections::BTreeMap`), so that\n+occupied entries can be modified before any potential inserts into the\n+map.\n+\n+For example:\n+\n+```rust\n+#![feature(entry_and_modify)]\n+# fn main() {\n+use std::collections::HashMap;\n+\n+struct Foo {\n+    new: bool,\n+}\n+\n+let mut map: HashMap<&str, Foo> = HashMap::new();\n+\n+map.entry(\"quux\")\n+   .and_modify(|e| e.new = false)\n+   .or_insert(Foo { new: true });\n+# }\n+```\n+\n+This is not possible with the stable API alone since inserting a default\n+_before_ modifying the `new` field would mean we would lose the default state:\n+\n+```rust\n+# fn main() {\n+use std::collections::HashMap;\n+\n+struct Foo {\n+    new: bool,\n+}\n+\n+let mut map: HashMap<&str, Foo> = HashMap::new();\n+\n+map.entry(\"quux\").or_insert(Foo { new: true }).new = false;\n+# }\n+```\n+\n+In the above code the `new` field will never be `true`, even though we only\n+intended to update that field to `false` for previously extant entries.\n+\n+To achieve the same effect as `and_modify` we would have to manually match\n+against the `Occupied` and `Vacant` variants of the `Entry` enum, which is\n+a little less user-friendly, and much more verbose:\n+\n+```rust\n+# fn main() {\n+use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n+\n+struct Foo {\n+    new: bool,\n+}\n+\n+let mut map: HashMap<&str, Foo> = HashMap::new();\n+\n+match map.entry(\"quux\") {\n+    Entry::Occupied(entry) => {\n+        entry.into_mut().new = false;\n+    },\n+    Entry::Vacant(entry) => {\n+        entry.insert(Foo { new: true });\n+    },\n+};\n+# }\n+```"}, {"sha": "72a3f36c10b69ed1d6acc28e9577c085d71e9cd1", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,35 @@\n+# `fn_traits`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`unboxed_closures`](language-features/unboxed-closures.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `fn_traits` feature allows for implementation of the [`Fn*`] traits\n+for creating custom closure-like types.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+#![feature(fn_traits)]\n+\n+struct Adder {\n+    a: u32\n+}\n+\n+impl FnOnce<(u32, )> for Adder {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_once(self, b: (u32, )) -> Self::Output {\n+        self.a + b.0\n+    }\n+}\n+\n+fn main() {\n+    let adder = Adder { a: 3 };\n+    assert_eq!(adder(2), 5);\n+}\n+```"}, {"sha": "05e057be4932df41e80dfb9c52a3538e3ba1d8c5", "filename": "src/doc/unstable-book/src/library-features/hint-core-should-pause.md", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,41 +0,0 @@\n-# `hint_core_should_pause`\n-\n-The tracking issue for this feature is: [#41196]\n-\n-[#41196]: https://github.com/rust-lang/rust/issues/41196\n-\n-------------------------\n-\n-Many programs have spin loops like the following:\n-\n-```rust,no_run\n-use std::sync::atomic::{AtomicBool,Ordering};\n-\n-fn spin_loop(value: &AtomicBool) {\n-    loop {\n-        if value.load(Ordering::Acquire) {\n-             break;\n-        }\n-    }\n-}\n-```\n-\n-These programs can be improved in performance like so:\n-\n-```rust,no_run\n-#![feature(hint_core_should_pause)]\n-use std::sync::atomic;\n-use std::sync::atomic::{AtomicBool,Ordering};\n-\n-fn spin_loop(value: &AtomicBool) {\n-    loop {\n-        if value.load(Ordering::Acquire) {\n-             break;\n-        }\n-        atomic::hint_core_should_pause();\n-    }\n-}\n-```\n-\n-Further improvements could combine `hint_core_should_pause` with\n-exponential backoff or `std::thread::yield_now`."}, {"sha": "d0229d94c20bfab71f398fad760c5d2a1d2ceb40", "filename": "src/doc/unstable-book/src/library-features/rand.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,5 +0,0 @@\n-# `rand`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "ef9884d2e980d45d70b0da9446f92969479f01b8", "filename": "src/etc/cat-and-grep.sh", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fcat-and-grep.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fcat-and-grep.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcat-and-grep.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,89 @@\n+#!/bin/sh\n+set -eu\n+\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Performs `cat` and `grep` simultaneously for `run-make` tests in the Rust CI.\n+#\n+# This program will read lines from stdin and print them to stdout immediately.\n+# At the same time, it will check if the input line contains the substring or\n+# regex specified in the command line. If any match is found, the program will\n+# set the exit code to 0, otherwise 1.\n+#\n+# This is written to simplify debugging runmake tests. Since `grep` swallows all\n+# output, when a test involving `grep` failed, it is impossible to know the\n+# reason just by reading the failure log. While it is possible to `tee` the\n+# output into another stream, it becomes pretty annoying to do this for all test\n+# cases.\n+\n+USAGE='\n+cat-and-grep.sh [-v] [-e] [-i] s1 s2 s3 ... < input.txt\n+\n+Prints the stdin, and exits successfully only if all of `sN` can be found in\n+some lines of the input.\n+\n+Options:\n+    -v      Invert match, exits successfully only if all of `sN` cannot be found\n+    -e      Regex search, search using extended Regex instead of fixed string\n+    -i      Case insensitive search.\n+'\n+\n+GREPPER=fgrep\n+INVERT=0\n+GREPFLAGS='q'\n+while getopts ':vieh' OPTION; do\n+    case \"$OPTION\" in\n+        v)\n+            INVERT=1\n+            ERROR_MSG='should not be found'\n+            ;;\n+        i)\n+            GREPFLAGS=\"i$GREPFLAGS\"\n+            ;;\n+        e)\n+            GREPPER=egrep\n+            ;;\n+        h)\n+            echo \"$USAGE\"\n+            exit 2\n+            ;;\n+        *)\n+            break\n+            ;;\n+    esac\n+done\n+\n+shift $((OPTIND - 1))\n+\n+LOG=$(mktemp -t cgrep.XXXXXX)\n+trap \"rm -f $LOG\" EXIT\n+\n+printf \"[[[ begin stdout ]]]\\n\\033[90m\"\n+tee \"$LOG\"\n+echo >> \"$LOG\"   # ensure at least 1 line of output, otherwise `grep -v` may unconditionally fail.\n+printf \"\\033[0m\\n[[[ end stdout ]]]\\n\"\n+\n+HAS_ERROR=0\n+for MATCH in \"$@\"; do\n+    if \"$GREPPER\" \"-$GREPFLAGS\" -- \"$MATCH\" \"$LOG\"; then\n+        if [ \"$INVERT\" = 1 ]; then\n+            printf \"\\033[1;31mError: should not match: %s\\033[0m\\n\" \"$MATCH\"\n+            HAS_ERROR=1\n+        fi\n+    else\n+        if [ \"$INVERT\" = 0 ]; then\n+            printf \"\\033[1;31mError: cannot match: %s\\033[0m\\n\" \"$MATCH\"\n+            HAS_ERROR=1\n+        fi\n+    fi\n+done\n+\n+exit \"$HAS_ERROR\""}, {"sha": "cfe5b01e934e7032c0a99910ab144c5c63dfd7bf", "filename": "src/etc/char_private.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -177,7 +177,7 @@ def main():\n     normal1 = compress_normal(normal1)\n \n     print(\"\"\"\\\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -226,7 +226,7 @@ def main():\n     current\n }\n \n-pub fn is_printable(x: char) -> bool {\n+pub(crate) fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {"}, {"sha": "0612873e28153b445964ccaffb52021098ddf915", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -248,7 +248,10 @@ def __init__(self, val):\n     def to_string(self):\n         (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n         raw_ptr = data_ptr.get_wrapped_value()\n-        return '\"%s\"' % raw_ptr.string(encoding=\"utf-8\", length=length)\n+        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n+\n+    def display_hint(self):\n+        return \"string\"\n \n \n class RustStdVecPrinter(object):\n@@ -278,9 +281,11 @@ def __init__(self, val):\n     def to_string(self):\n         vec = self.__val.get_child_at_index(0)\n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(encoding=\"utf-8\",\n-                                                            length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n+                                                        length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustOsStringPrinter(object):\n     def __init__(self, val):\n@@ -294,8 +299,10 @@ def to_string(self):\n \n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n             vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):"}, {"sha": "15c9fc2e504a1fd4accdc69bb64eac7502b3521d", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -74,7 +74,7 @@\n \n ENUM_TUPLE, ENUM_STRUCT, STRUCT_FIELDS, STRUCT_TUPLE = range(4)\n \n-def create_test_case(type, trait, super_traits, number_of_errors):\n+def create_test_case(type, trait, super_traits, error_count):\n     string = [ENUM_STRING, ENUM_STRUCT_VARIANT_STRING, STRUCT_STRING, STRUCT_TUPLE_STRING][type]\n     all_traits = ','.join([trait] + super_traits)\n     super_traits = ','.join(super_traits)\n@@ -113,7 +113,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 9),\n+                              ('PartialOrd', ['PartialEq'], 3),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "8a11c6f7cfc4c9d27950537feb79ab27572dc4ca", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -99,6 +99,8 @@\n * `@count PATH XPATH COUNT' checks for the occurrence of given XPath\n   in the given file. The number of occurrences must match the given count.\n \n+* `@has-dir PATH` checks for the existence of the given directory.\n+\n All conditions can be negated with `!`. `@!has foo/type.NoSuch.html`\n checks if the given file does not exist, for example.\n \n@@ -308,6 +310,12 @@ def get_tree(self, path):\n             self.trees[path] = tree\n             return self.trees[path]\n \n+    def get_dir(self, path):\n+        path = self.resolve_path(path)\n+        abspath = os.path.join(self.root, path)\n+        if not(os.path.exists(abspath) and os.path.isdir(abspath)):\n+            raise FailedCheck('Directory does not exist {!r}'.format(path))\n+\n \n def check_string(data, pat, regexp):\n     if not pat:\n@@ -407,6 +415,16 @@ def check_command(c, cache):\n                 ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n+        elif c.cmd == 'has-dir': # has-dir test\n+            if len(c.args) == 1: # @has-dir <path> = has-dir test\n+                try:\n+                    cache.get_dir(c.args[0])\n+                    ret = True\n+                except FailedCheck as err:\n+                    cerr = str(err)\n+                    ret = False\n+            else:\n+                raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n         elif c.cmd == 'valid-html':\n             raise InvalidCheck('Unimplemented @valid-html')\n "}, {"sha": "21bfc448ae2b4a0c8b2ec4ede7d9285820365286", "filename": "src/etc/indenter", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Findenter", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Findenter", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Findenter?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -13,7 +13,7 @@ while True:\n     if more_re.match(line):\n         indent += 1\n \n-    print \"%03d %s%s\" % (indent, \" \" * indent, line.strip())\n+    print(\"%03d %s%s\" % (indent, \" \" * indent, line.strip()))\n \n     if less_re.match(line):\n         indent -= 1"}, {"sha": "2cfc8698c4b67f7e9c8c9cb569aaa54758645542", "filename": "src/etc/installer/exe/modpath.iss", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -144,7 +144,7 @@ begin\n \tend;\n end;\n \n-// Split a string into an array using passed delimeter\n+// Split a string into an array using passed delimiter\n procedure Explode(var Dest: TArrayOfString; Text: String; Separator: String);\n var\n \ti: Integer;"}, {"sha": "c22d60b6c5df1031313c4ed4e30c3c6e9e6d69de", "filename": "src/etc/installer/exe/rust.iss", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -46,7 +46,9 @@ Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n Name: docs; Description: \"HTML documentation\"; Types: full\n Name: cargo; Description: \"Cargo, the Rust package manager\"; Types: full\n Name: std; Description: \"The Rust Standard Library\"; Types: full\n+// tool-rls-start\n Name: rls; Description: \"RLS, the Rust Language Server\"\n+// tool-rls-end\n \n [Files]\n Source: \"rustc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n@@ -56,8 +58,10 @@ Source: \"rust-mingw/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs;\n Source: \"rust-docs/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: docs\n Source: \"cargo/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: cargo\n Source: \"rust-std/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: std\n+// tool-rls-start\n Source: \"rls/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n Source: \"rust-analysis/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n+// tool-rls-end\n \n [Code]\n const"}, {"sha": "d95b096d732f41ede7743ff8d08341b2d54392fc", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -170,8 +170,10 @@\n                     <Directory Id=\"Docs\" Name=\".\" />\n                     <Directory Id=\"Cargo\" Name=\".\" />\n                     <Directory Id=\"Std\" Name=\".\" />\n+                    <!-- tool-rls-start -->\n                     <Directory Id=\"Rls\" Name=\".\" />\n                     <Directory Id=\"Analysis\" Name=\".\" />\n+                    <!-- tool-rls-end -->\n                 </Directory>\n             </Directory>\n \n@@ -275,6 +277,7 @@\n                  <ComponentRef Id=\"PathEnvPerMachine\" />\n                  <ComponentRef Id=\"PathEnvPerUser\" />\n         </Feature>\n+        <!-- tool-rls-start -->\n         <Feature Id=\"RLS\"\n                  Title=\"RLS, the Rust Language Server\"\n                  Display=\"7\"\n@@ -283,6 +286,7 @@\n                  <ComponentGroupRef Id=\"RlsGroup\" />\n                  <ComponentGroupRef Id=\"AnalysisGroup\" />\n         </Feature>\n+        <!-- tool-rls-end -->\n \n         <UIRef Id=\"RustUI\" />\n     </Product>"}, {"sha": "077ee17511655b9018ee0fe5e2270d911edb805a", "filename": "src/etc/installer/pkg/Distribution.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -16,7 +16,9 @@\n       <line choice=\"rust-std\"/>\n       <line choice=\"cargo\"/>\n       <line choice=\"rust-docs\"/>\n+      <!-- tool-rls-start -->\n       <line choice=\"rls\"/>\n+      <!-- tool-rls-end -->\n       </line>\n       <line choice=\"uninstall\" />\n     </choices-outline>\n@@ -62,6 +64,7 @@\n         >\n         <pkg-ref id=\"org.rust-lang.rust-docs\"/>\n     </choice>\n+    <!-- tool-rls-start -->\n     <choice id=\"rls\" visible=\"true\"\n         title=\"RLS\" description=\"RLS, the Rust Language Server\"\n         selected=\"(!choices.uninstall.selected &amp;&amp; choices['rls'].selected) || (choices.uninstall.selected &amp;&amp; choices.install.selected)\"\n@@ -70,11 +73,14 @@\n         <pkg-ref id=\"org.rust-lang.rls\"/>\n         <pkg-ref id=\"org.rust-lang.rust-analysis\"/>\n     </choice>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rustc\" version=\"0\" onConclusion=\"none\">rustc.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.cargo\" version=\"0\" onConclusion=\"none\">cargo.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-docs\" version=\"0\" onConclusion=\"none\">rust-docs.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-std\" version=\"0\" onConclusion=\"none\">rust-std.pkg</pkg-ref>\n+    <!-- tool-rls-start -->\n     <pkg-ref id=\"org.rust-lang.rls\" version=\"0\" onConclusion=\"none\">rls.pkg</pkg-ref>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rust-analysis\" version=\"0\" onConclusion=\"none\">rust-analysis.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.uninstall\" version=\"0\" onConclusion=\"none\">uninstall.pkg</pkg-ref>\n     <background file=\"rust-logo.png\" mime-type=\"image/png\""}, {"sha": "24a0ce0ac3611270cd6630a26b1595d48afcc40d", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -81,7 +81,7 @@ def execute_command(command_interpreter, command):\n \n     if res.Succeeded():\n         if res.HasResult():\n-            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+            print(normalize_whitespace(res.GetOutput() or ''), end='\\n')\n \n         # If the command introduced any breakpoints, make sure to register\n         # them with the breakpoint"}, {"sha": "acb6813887c5cba389efe5b0dae0ab8dbe804396", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -219,6 +219,76 @@\n             \"llvm\": \"vsumsws\",\n             \"ret\": \"s32\",\n             \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"madd\",\n+            \"width\": [128],\n+            \"llvm\": \"vmaddfp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"nmsub\",\n+            \"width\": [128],\n+            \"llvm\": \"vnmsubfp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"expte\",\n+            \"width\": [128],\n+            \"llvm\": \"vexptefp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"floor\",\n+            \"width\": [128],\n+            \"llvm\": \"vrfim\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"ceil\",\n+            \"width\": [128],\n+            \"llvm\": \"vrfip\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"round\",\n+            \"width\": [128],\n+            \"llvm\": \"vrfin\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"trunc\",\n+            \"width\": [128],\n+            \"llvm\": \"vrfiz\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"loge\",\n+            \"width\": [128],\n+            \"llvm\": \"vlogefp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"re\",\n+            \"width\": [128],\n+            \"llvm\": \"vrefp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"rsqrte\",\n+            \"width\": [128],\n+            \"llvm\": \"vrsqrtefp\",\n+            \"ret\": \"f32\",\n+            \"args\": [\"0\"]\n         }\n     ]\n }"}, {"sha": "ac2223f4acef3052d32d35689b90eb1227ca4a19", "filename": "src/etc/sugarise-doc-comments.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -50,11 +50,11 @@ def block_trim(s):\n         lns = lns[:-1]\n \n     # remove leading horizontal whitespace\n-    n = sys.maxint\n+    n = sys.maxsize\n     for ln in lns:\n         if ln.strip():\n             n = min(n, len(re.search('^\\s*', ln).group()))\n-    if n != sys.maxint:\n+    if n != sys.maxsize:\n         lns = [ln[n:] for ln in lns]\n \n     # strip trailing whitespace"}, {"sha": "d520c9bd5c30a4f39555f22941aae1d55f5a1e93", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python2.7\n+#!/usr/bin/env python2.7\n #\n # Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n@@ -97,11 +97,15 @@\n from subprocess import Popen, check_call, PIPE\n from glob import glob\n import multiprocessing\n-import Queue\n import threading\n import ctypes\n import binascii\n \n+try:  # Python 3\n+    import queue as Queue\n+except ImportError:  # Python 2\n+    import Queue\n+\n NUM_WORKERS = 2\n UPDATE_EVERY_N = 50000\n INF = namedtuple('INF', '')()"}, {"sha": "d55083e0f8e03490aa23dea88ea1acfc810fe169", "filename": "src/etc/wasm32-shim.js", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a small \"shim\" program which is used when wasm32 unit tests are run\n+// in this repository. This program is intended to be run in node.js and will\n+// load a wasm module into memory, instantiate it with a set of imports, and\n+// then run it.\n+//\n+// There's a bunch of helper functions defined here in `imports.env`, but note\n+// that most of them aren't actually needed to execute most programs. Many of\n+// these are just intended for completeness or debugging. Hopefully over time\n+// nothing here is needed for completeness.\n+\n+const fs = require('fs');\n+const process = require('process');\n+const buffer = fs.readFileSync(process.argv[2]);\n+\n+Error.stackTraceLimit = 20;\n+\n+let m = new WebAssembly.Module(buffer);\n+\n+let memory = null;\n+\n+function copystr(a, b) {\n+  if (memory === null) {\n+    return null\n+  }\n+  let view = new Uint8Array(memory.buffer).slice(a, a + b);\n+  return String.fromCharCode.apply(null, view);\n+}\n+\n+let imports = {};\n+imports.env = {\n+  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n+  // one day this is not necessary and something will automatically do this.\n+  fmod: function(x, y) { return x % y; },\n+  exp2: function(x) { return Math.pow(2, x); },\n+  exp2f: function(x) { return Math.pow(2, x); },\n+  ldexp: function(x, y) { return x * Math.pow(2, y); },\n+  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n+  log10: Math.log10,\n+  log10f: Math.log10,\n+\n+  // These are called in src/libstd/sys/wasm/stdio.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_write_stdout: function(a, b) {\n+    let s = copystr(a, b);\n+    if (s !== null) {\n+      process.stdout.write(s);\n+    }\n+  },\n+  rust_wasm_write_stderr: function(a, b) {\n+    let s = copystr(a, b);\n+    if (s !== null) {\n+      process.stderr.write(s);\n+    }\n+  },\n+\n+  // These are called in src/libstd/sys/wasm/args.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_args_count: function() {\n+    if (memory === null)\n+      return 0;\n+    return process.argv.length - 2;\n+  },\n+  rust_wasm_args_arg_size: function(i) {\n+    return Buffer.byteLength(process.argv[i + 2]);\n+  },\n+  rust_wasm_args_arg_fill: function(idx, ptr) {\n+    let arg = process.argv[idx + 2];\n+    let view = new Uint8Array(memory.buffer);\n+    Buffer.from(arg).copy(view, ptr);\n+  },\n+\n+  // These are called in src/libstd/sys/wasm/os.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_getenv_len: function(a, b) {\n+    let key = copystr(a, b);\n+    if (key === null) {\n+      return -1;\n+    }\n+    if (!(key in process.env)) {\n+      return -1;\n+    }\n+    return Buffer.byteLength(process.env[key]);\n+  },\n+  rust_wasm_getenv_data: function(a, b, ptr) {\n+    let key = copystr(a, b);\n+    let value = process.env[key];\n+    let view = new Uint8Array(memory.buffer);\n+    Buffer.from(value).copy(view, ptr);\n+  },\n+};\n+\n+let module_imports = WebAssembly.Module.imports(m);\n+\n+for (var i = 0; i < module_imports.length; i++) {\n+  let imp = module_imports[i];\n+  if (imp.module != 'env') {\n+    continue\n+  }\n+  if (imp.name == 'memory' && imp.kind == 'memory') {\n+    memory = new WebAssembly.Memory({initial: 20});\n+    imports.env.memory = memory;\n+  }\n+}\n+\n+let instance = new WebAssembly.Instance(m, imports);"}, {"sha": "2f282c8281d6eeba11b412101461aef4a2f3baa3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -85,43 +85,60 @@ ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n <blockcomment>(.|\\n)   { }\n \n _        { return UNDERSCORE; }\n+abstract { return ABSTRACT; }\n+alignof  { return ALIGNOF; }\n as       { return AS; }\n+become   { return BECOME; }\n box      { return BOX; }\n break    { return BREAK; }\n+catch    { return CATCH; }\n const    { return CONST; }\n continue { return CONTINUE; }\n crate    { return CRATE; }\n+default  { return DEFAULT; }\n+do       { return DO; }\n else     { return ELSE; }\n enum     { return ENUM; }\n extern   { return EXTERN; }\n false    { return FALSE; }\n+final    { return FINAL; }\n fn       { return FN; }\n for      { return FOR; }\n if       { return IF; }\n impl     { return IMPL; }\n in       { return IN; }\n let      { return LET; }\n loop     { return LOOP; }\n+macro    { return MACRO; }\n match    { return MATCH; }\n mod      { return MOD; }\n move     { return MOVE; }\n mut      { return MUT; }\n+offsetof { return OFFSETOF; }\n+override { return OVERRIDE; }\n priv     { return PRIV; }\n proc     { return PROC; }\n+pure     { return PURE; }\n pub      { return PUB; }\n ref      { return REF; }\n return   { return RETURN; }\n self     { return SELF; }\n+sizeof   { return SIZEOF; }\n static   { return STATIC; }\n struct   { return STRUCT; }\n+super    { return SUPER; }\n trait    { return TRAIT; }\n true     { return TRUE; }\n type     { return TYPE; }\n typeof   { return TYPEOF; }\n+union    { return UNION; }\n unsafe   { return UNSAFE; }\n+unsized  { return UNSIZED; }\n use      { return USE; }\n+virtual  { return VIRTUAL; }\n where    { return WHERE; }\n while    { return WHILE; }\n+yield    { return YIELD; }\n \n {ident}  { return IDENT; }\n \n@@ -189,25 +206,25 @@ while    { return WHILE; }\n \\>\\>= { return SHREQ; }\n \\>    { return '>'; }\n \n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\\x27                                      { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n \n b\\x22              { BEGIN(bytestr); yymore(); }\n <bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n \n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n+<bytestr><<EOF>>                     { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<bytestr>(.|\\n)                      { yymore(); }\n \n br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n <rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n@@ -252,13 +269,13 @@ br/# {\n }\n <rawbytestr><<EOF>> { return -1; }\n \n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+b\\x27                           { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n \n r\\x22           { BEGIN(rawstr); yymore(); }\n <rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n@@ -310,12 +327,12 @@ r/#             {\n \\x22                     { BEGIN(str); yymore(); }\n <str>\\x22                { BEGIN(suffix); return LIT_STR; }\n \n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n+<str><<EOF>>                     { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<str>(.|\\n)                      { yymore(); }\n \n \\<-  { return LARROW; }\n -\\>  { return RARROW; }"}, {"sha": "de1f96aac504653db2d440a8426ea623143abc29", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 208, "deletions": 158, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -62,33 +62,49 @@ extern char *yytext;\n // keywords\n %token SELF\n %token STATIC\n+%token ABSTRACT\n+%token ALIGNOF\n %token AS\n+%token BECOME\n %token BREAK\n+%token CATCH\n %token CRATE\n+%token DO\n %token ELSE\n %token ENUM\n %token EXTERN\n %token FALSE\n+%token FINAL\n %token FN\n %token FOR\n %token IF\n %token IMPL\n %token IN\n %token LET\n %token LOOP\n+%token MACRO\n %token MATCH\n %token MOD\n %token MOVE\n %token MUT\n+%token OFFSETOF\n+%token OVERRIDE\n %token PRIV\n %token PUB\n+%token PURE\n %token REF\n %token RETURN\n+%token SIZEOF\n %token STRUCT\n+%token SUPER\n+%token UNION\n+%token UNSIZED\n %token TRUE\n %token TRAIT\n %token TYPE\n %token UNSAFE\n+%token VIRTUAL\n+%token YIELD\n %token DEFAULT\n %token USE\n %token WHILE\n@@ -141,6 +157,10 @@ extern char *yytext;\n // 'foo:bar . <' is shifted (in a trait reference occurring in a\n // bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n %precedence IDENT\n+ // Put the weak keywords that can be used as idents here as well\n+%precedence CATCH\n+%precedence DEFAULT\n+%precedence UNION\n \n // A couple fake-precedence symbols to use in rules associated with +\n // and < in trailing type contexts. These come up when you have a type\n@@ -161,13 +181,13 @@ extern char *yytext;\n %precedence FOR\n \n // Binops & unops, and their precedences\n+%precedence '?'\n %precedence BOX\n-%precedence BOXPLACE\n %nonassoc DOTDOT\n \n // RETURN needs to be lower-precedence than tokens that start\n // prefix_exprs\n-%precedence RETURN\n+%precedence RETURN YIELD\n \n %right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n %right LARROW\n@@ -321,6 +341,8 @@ view_path\n | path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n |                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n | path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n+|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n |                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n |                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n |                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n@@ -334,6 +356,7 @@ block_item\n | item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n | item_struct\n | item_enum\n+| item_union\n | item_trait\n | item_impl\n ;\n@@ -387,6 +410,7 @@ struct_decl_field\n struct_tuple_fields\n : struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n | struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n ;\n \n struct_tuple_field\n@@ -417,6 +441,11 @@ enum_args\n | %empty                         { $$ = mk_none(); }\n ;\n \n+// unions\n+item_union\n+: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n+| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n+\n item_mod\n : MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n | MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n@@ -475,7 +504,7 @@ visibility\n \n idents_or_self\n : ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n | idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -515,6 +544,7 @@ trait_item\n : trait_const\n | trait_type\n | trait_method\n+| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n ;\n \n trait_const\n@@ -547,36 +577,48 @@ trait_method\n ;\n \n type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n }\n ;\n \n method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n ;\n \n impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n+| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n+}\n ;\n \n // There are two forms of impl:\n@@ -638,26 +680,39 @@ impl_item\n | impl_type\n ;\n \n+maybe_default\n+: DEFAULT { $$ = mk_atom(\"Default\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n ;\n \n impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n ;\n \n item_fn\n : FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n }\n+| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n+}\n ;\n \n item_unsafe_fn\n : UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n }\n+| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n+}\n | UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n@@ -723,12 +778,6 @@ inferrable_param\n : pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n ;\n \n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n maybe_comma_params\n : ','            { $$ = mk_none(); }\n | ',' params     { $$ = $2; }\n@@ -784,7 +833,8 @@ ret_ty\n ;\n \n generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n+| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n@@ -837,6 +887,8 @@ path_no_types_allowed\n | MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n | SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n | MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n+| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n | path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -882,7 +934,7 @@ generic_args\n ;\n \n generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n ;\n \n maybe_ty_sums_and_or_bindings\n@@ -910,12 +962,11 @@ pat\n | ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n | '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n | '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n | '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n | lit_or_path\n | lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n | path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n | path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n | path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n | binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n@@ -953,6 +1004,7 @@ pat_field\n | BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n |              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n | binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n ;\n \n pat_fields\n@@ -965,11 +1017,26 @@ pat_struct\n | pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n | pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n | DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n ;\n \n pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_tup_elts\n+: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n+| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n ;\n \n pat_vec\n@@ -1007,24 +1074,25 @@ ty\n ;\n \n ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n+| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n | ty_bare_fn\n-| ty_proc\n | for_in_type\n ;\n \n@@ -1046,17 +1114,12 @@ ty_closure\n |        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n ;\n \n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n for_in_type\n : FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n ;\n \n for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n+: ty_bare_fn\n | trait_ref\n | ty_closure\n ;\n@@ -1100,13 +1163,23 @@ ty_sums\n ;\n \n ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum_elt\n+: ty\n+| lifetime\n ;\n \n ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_prim_sum_elt\n+: ty_prim\n+| lifetime\n ;\n \n maybe_ty_param_bounds\n@@ -1127,6 +1200,7 @@ boundseq\n polybound\n : FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n | bound\n+| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n | '?' bound { $$ = $2; }\n ;\n \n@@ -1244,26 +1318,22 @@ maybe_stmts\n // block, nonblock-prefix, and nonblock-nonprefix.\n //\n // In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n \n stmts\n : stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n | stmts stmt     { $$ = ext_node($1, 1, $2); }\n ;\n \n stmt\n-: let\n+: maybe_outer_attrs let     { $$ = $2; }\n |                 stmt_item\n |             PUB stmt_item { $$ = $2; }\n | outer_attrs     stmt_item { $$ = $2; }\n | outer_attrs PUB stmt_item { $$ = $3; }\n | full_block_expr\n-| block\n-| nonblock_expr ';'\n+| maybe_outer_attrs block   { $$ = $2; }\n+|             nonblock_expr ';'\n+| outer_attrs nonblock_expr ';' { $$ = $2; }\n | ';'                   { $$ = mk_none(); }\n ;\n \n@@ -1296,7 +1366,9 @@ path_expr\n // expressions.\n path_generic_args_with_colons\n : ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| SUPER                                              { $$ = mk_atom(\"Super\"); }\n | path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n | path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -1313,6 +1385,7 @@ nonblock_expr\n | SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n | nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1325,6 +1398,8 @@ nonblock_expr\n | RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n | nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1360,8 +1435,8 @@ nonblock_expr\n |               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | nonblock_prefix_expr\n ;\n@@ -1373,6 +1448,7 @@ expr\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1385,6 +1461,8 @@ expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1420,69 +1498,8 @@ expr\n |      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1495,6 +1512,7 @@ expr_nostruct\n   path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1507,6 +1525,8 @@ expr_nostruct\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1542,8 +1562,8 @@ expr_nostruct\n |               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1558,7 +1578,6 @@ nonblock_prefix_expr_nostruct\n | ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr_nostruct\n | MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n ;\n \n nonblock_prefix_expr\n@@ -1569,7 +1588,6 @@ nonblock_prefix_expr\n | ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr\n | MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n ;\n \n expr_qualified_path\n@@ -1606,43 +1624,42 @@ maybe_as_trait_ref\n \n lambda_expr\n : %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n | %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-lambda_expr_nostruct\n+lambda_expr_no_first_bar\n : %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n+  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n-proc_expr\n+lambda_expr_nostruct\n : %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-proc_expr_nostruct\n+lambda_expr_nostruct_no_first_bar\n : %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n vec_expr\n@@ -1654,6 +1671,7 @@ struct_expr_fields\n : field_inits\n | field_inits ','\n | maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+| %empty                               { $$ = mk_none(); }\n ;\n \n maybe_field_inits\n@@ -1668,7 +1686,9 @@ field_inits\n ;\n \n field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n+| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n ;\n \n default_field_init\n@@ -1689,10 +1709,18 @@ block_expr\n \n full_block_expr\n : block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot\n+;\n+\n+block_expr_dot\n+: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n ;\n \n expr_match\n@@ -1714,12 +1742,13 @@ match_clause\n ;\n \n nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n ;\n \n block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n ;\n \n maybe_guard\n@@ -1796,6 +1825,10 @@ maybe_ident\n \n ident\n : IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+// Weak keywords that can be used as identifiers\n+| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n ;\n \n unpaired_token\n@@ -1836,35 +1869,52 @@ unpaired_token\n | LIFETIME                   { $$ = mk_atom(yytext); }\n | SELF                       { $$ = mk_atom(yytext); }\n | STATIC                     { $$ = mk_atom(yytext); }\n+| ABSTRACT                   { $$ = mk_atom(yytext); }\n+| ALIGNOF                    { $$ = mk_atom(yytext); }\n | AS                         { $$ = mk_atom(yytext); }\n+| BECOME                     { $$ = mk_atom(yytext); }\n | BREAK                      { $$ = mk_atom(yytext); }\n+| CATCH                      { $$ = mk_atom(yytext); }\n | CRATE                      { $$ = mk_atom(yytext); }\n+| DEFAULT                    { $$ = mk_atom(yytext); }\n+| DO                         { $$ = mk_atom(yytext); }\n | ELSE                       { $$ = mk_atom(yytext); }\n | ENUM                       { $$ = mk_atom(yytext); }\n | EXTERN                     { $$ = mk_atom(yytext); }\n | FALSE                      { $$ = mk_atom(yytext); }\n+| FINAL                      { $$ = mk_atom(yytext); }\n | FN                         { $$ = mk_atom(yytext); }\n | FOR                        { $$ = mk_atom(yytext); }\n | IF                         { $$ = mk_atom(yytext); }\n | IMPL                       { $$ = mk_atom(yytext); }\n | IN                         { $$ = mk_atom(yytext); }\n | LET                        { $$ = mk_atom(yytext); }\n | LOOP                       { $$ = mk_atom(yytext); }\n+| MACRO                      { $$ = mk_atom(yytext); }\n | MATCH                      { $$ = mk_atom(yytext); }\n | MOD                        { $$ = mk_atom(yytext); }\n | MOVE                       { $$ = mk_atom(yytext); }\n | MUT                        { $$ = mk_atom(yytext); }\n+| OFFSETOF                   { $$ = mk_atom(yytext); }\n+| OVERRIDE                   { $$ = mk_atom(yytext); }\n | PRIV                       { $$ = mk_atom(yytext); }\n | PUB                        { $$ = mk_atom(yytext); }\n+| PURE                       { $$ = mk_atom(yytext); }\n | REF                        { $$ = mk_atom(yytext); }\n | RETURN                     { $$ = mk_atom(yytext); }\n | STRUCT                     { $$ = mk_atom(yytext); }\n+| SIZEOF                     { $$ = mk_atom(yytext); }\n+| SUPER                      { $$ = mk_atom(yytext); }\n | TRUE                       { $$ = mk_atom(yytext); }\n | TRAIT                      { $$ = mk_atom(yytext); }\n | TYPE                       { $$ = mk_atom(yytext); }\n+| UNION                      { $$ = mk_atom(yytext); }\n | UNSAFE                     { $$ = mk_atom(yytext); }\n+| UNSIZED                    { $$ = mk_atom(yytext); }\n | USE                        { $$ = mk_atom(yytext); }\n+| VIRTUAL                    { $$ = mk_atom(yytext); }\n | WHILE                      { $$ = mk_atom(yytext); }\n+| YIELD                      { $$ = mk_atom(yytext); }\n | CONTINUE                   { $$ = mk_atom(yytext); }\n | PROC                       { $$ = mk_atom(yytext); }\n | BOX                        { $$ = mk_atom(yytext); }\n@@ -1942,4 +1992,4 @@ brackets_delimited_token_trees\n                $2,\n                mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n }\n-;\n\\ No newline at end of file\n+;"}, {"sha": "15ea738ed0057edd741da93228106a9c3aa8fca8", "filename": "src/grammar/tokens.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -30,6 +30,7 @@ enum Token {\n   DOTDOT,\n   DOTDOTDOT,\n   MOD_SEP,\n+  LARROW,\n   RARROW,\n   FAT_ARROW,\n   LIT_BYTE,\n@@ -47,35 +48,52 @@ enum Token {\n   // keywords\n   SELF,\n   STATIC,\n+  ABSTRACT,\n+  ALIGNOF,\n   AS,\n+  BECOME,\n   BREAK,\n+  CATCH,\n   CRATE,\n+  DEFAULT,\n+  DO,\n   ELSE,\n   ENUM,\n   EXTERN,\n   FALSE,\n+  FINAL,\n   FN,\n   FOR,\n   IF,\n   IMPL,\n   IN,\n   LET,\n   LOOP,\n+  MACRO,\n   MATCH,\n   MOD,\n   MOVE,\n   MUT,\n+  OFFSETOF,\n+  OVERRIDE,\n   PRIV,\n   PUB,\n+  PURE,\n   REF,\n   RETURN,\n+  SIZEOF,\n   STRUCT,\n+  SUPER,\n+  UNION,\n   TRUE,\n   TRAIT,\n   TYPE,\n   UNSAFE,\n+  UNSIZED,\n   USE,\n+  VIRTUAL,\n   WHILE,\n+  YIELD,\n   CONTINUE,\n   PROC,\n   BOX,"}, {"sha": "0a265ee1376a0acf48d83c3463d61eaca97bd891", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -11,6 +11,9 @@ path = \"lib.rs\"\n core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n+[dev-dependencies]\n+rand = \"0.3\"\n+\n [[test]]\n name = \"collectionstests\"\n path = \"../liballoc/tests/lib.rs\""}, {"sha": "3a2022ad429f7ef85150138ac6e83e81c699b4a5", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -70,7 +70,7 @@ impl Layout {\n     ///\n     /// * `align` must be a power of two,\n     ///\n-    /// * `align` must not exceed 2^31 (i.e. `1 << 31`),\n+    /// * `align` must not exceed 2<sup>31</sup> (i.e. `1 << 31`),\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n@@ -113,7 +113,7 @@ impl Layout {\n     /// # Safety\n     ///\n     /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two that is also less than or equal to 2^31, nor\n+    /// a power-of-two that is also less than or equal to 2<sup>31</sup>, nor\n     /// that `size` aligned to `align` fits within the address space\n     /// (i.e. the `Layout::from_size_align` preconditions).\n     #[inline]\n@@ -227,7 +227,7 @@ impl Layout {\n         };\n \n         // We can assume that `self.align` is a power-of-two that does\n-        // not exceed 2^31. Furthermore, `alloc_size` has already been\n+        // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n         // rounded up to a multiple of `self.align`; therefore, the\n         // call to `Layout::from_size_align` below should never panic.\n         Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))"}, {"sha": "fc0a3c0fd881ae6029417d4fa7ac107a4aa04943", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -52,8 +52,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// also destroyed.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n-/// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n-/// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n+/// exception: you cannot generally obtain a mutable reference to something\n+/// inside an `Arc`. If you need to mutate through an `Arc`, use\n+/// [`Mutex`][mutex], [`RwLock`][rwlock], or one of the [`Atomic`][atomic]\n+/// types.\n ///\n /// ## Thread Safety\n ///\n@@ -1326,7 +1328,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.ptr, f)\n+        fmt::Pointer::fmt(&(&**self as *const T), f)\n     }\n }\n "}, {"sha": "38c94d4d8b5f36a64739c7b2d4192be4876b7e5d", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -272,15 +272,12 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n make_test!(split_a_str, s, s.split(\"a\").count());\n \n make_test!(trim_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_matches(|c: char| c.is_ascii())\n });\n make_test!(trim_left_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_left_matches(|c: char| c.is_ascii())\n });\n make_test!(trim_right_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_right_matches(|c: char| c.is_ascii())\n });\n "}, {"sha": "94bbaf92ce9b0230a8037a2cc9f3475c1c9c69da", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -926,7 +926,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     }\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {"}, {"sha": "acae0daa86b6bd30e30f12ce7f531594c3b7c233", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -191,7 +191,6 @@ impl<'a, B: ?Sized> Cow<'a, B>\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n     /// use std::borrow::Cow;\n     ///\n     /// let mut cow = Cow::Borrowed(\"foo\");\n@@ -233,7 +232,7 @@ impl<'a, B: ?Sized> Cow<'a, B>\n     ///\n     /// assert_eq!(\n     ///   cow.into_owned(),\n-    ///   Cow::Owned(String::from(s))\n+    ///   String::from(s)\n     /// );\n     /// ```\n     ///\n@@ -247,7 +246,7 @@ impl<'a, B: ?Sized> Cow<'a, B>\n     ///\n     /// assert_eq!(\n     ///   cow.into_owned(),\n-    ///   Cow::Owned(String::from(s))\n+    ///   String::from(s)\n     /// );\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6f125cdba8190d671c7ac4c1f46272ca7d94b50d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -151,7 +151,7 @@ impl<T> Place<T> for IntermediateBox<T> {\n unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n     let p = b.ptr as *mut T;\n     mem::forget(b);\n-    mem::transmute(p)\n+    Box::from_raw(p)\n }\n \n fn make_place<T>() -> IntermediateBox<T> {\n@@ -269,7 +269,38 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        mem::transmute(raw)\n+        Box::from_unique(Unique::new_unchecked(raw))\n+    }\n+\n+    /// Constructs a `Box` from a `Unique<T>` pointer.\n+    ///\n+    /// After calling this function, the memory is owned by a `Box` and `T` can\n+    /// then be destroyed and released upon drop.\n+    ///\n+    /// # Safety\n+    ///\n+    /// A `Unique<T>` can be safely created via [`Unique::new`] and thus doesn't\n+    /// necessarily own the data pointed to nor is the data guaranteed to live\n+    /// as long as the pointer.\n+    ///\n+    /// [`Unique::new`]: ../../core/ptr/struct.Unique.html#method.new\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    ///     let x = unsafe { Box::from_unique(ptr) };\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub unsafe fn from_unique(u: Unique<T>) -> Self {\n+        Box(u)\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -295,21 +326,26 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        unsafe { mem::transmute(b) }\n+        Box::into_unique(b).as_ptr()\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// proper way to do so is to either convert the `Unique<T>` pointer:\n+    ///\n+    /// - Into a `Box` with the [`Box::from_unique`] function.\n+    ///\n+    /// - Into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n+    ///   function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_unique`]: struct.Box.html#method.from_unique\n     /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     ///\n     /// # Examples\n@@ -326,7 +362,62 @@ impl<T: ?Sized> Box<T> {\n                issue = \"27730\")]\n     #[inline]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        unsafe { mem::transmute(b) }\n+        let unique = b.0;\n+        mem::forget(b);\n+        unique\n+    }\n+\n+    /// Consumes and leaks the `Box`, returning a mutable reference,\n+    /// `&'a mut T`. Here, the lifetime `'a` may be chosen to be `'static`.\n+    ///\n+    /// This function is mainly useful for data that lives for the remainder of\n+    /// the program's life. Dropping the returned reference will cause a memory\n+    /// leak. If this is not acceptable, the reference should first be wrapped\n+    /// with the [`Box::from_raw`] function producing a `Box`. This `Box` can\n+    /// then be dropped which will properly destroy `T` and release the\n+    /// allocated memory.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple usage:\n+    ///\n+    /// ```\n+    /// #![feature(box_leak)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(41);\n+    ///     let static_ref: &'static mut usize = Box::leak(x);\n+    ///     *static_ref += 1;\n+    ///     assert_eq!(*static_ref, 42);\n+    /// }\n+    /// ```\n+    ///\n+    /// Unsized data:\n+    ///\n+    /// ```\n+    /// #![feature(box_leak)]\n+    ///\n+    /// fn main() {\n+    ///     let x = vec![1, 2, 3].into_boxed_slice();\n+    ///     let static_ref = Box::leak(x);\n+    ///     static_ref[0] = 4;\n+    ///     assert_eq!(*static_ref, [4, 2, 3]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"box_leak\", reason = \"needs an FCP to stabilize\",\n+               issue = \"46179\")]\n+    #[inline]\n+    pub fn leak<'a>(b: Box<T>) -> &'a mut T\n+    where\n+        T: 'a // Technically not needed, but kept to be explicit.\n+    {\n+        unsafe { &mut *Box::into_raw(b) }\n     }\n }\n \n@@ -528,9 +619,7 @@ impl<'a> From<&'a str> for Box<str> {\n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n impl From<Box<str>> for Box<[u8]> {\n     fn from(s: Box<str>) -> Self {\n-        unsafe {\n-            mem::transmute(s)\n-        }\n+        unsafe { Box::from_raw(Box::into_raw(s) as *mut [u8]) }\n     }\n }\n \n@@ -593,7 +682,7 @@ impl Box<Any + Send> {\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n         <Box<Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker\n-            mem::transmute::<Box<Any>, Box<Any + Send>>(s)\n+            Box::from_raw(Box::into_raw(s) as *mut (Any + Send))\n         })\n     }\n }"}, {"sha": "b114dc640fbafb1f97ba4f432b9836592e180fc8", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -2102,6 +2102,40 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n             Vacant(ref entry) => entry.key(),\n         }\n     }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(entry_and_modify)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[unstable(feature = \"entry_and_modify\", issue = \"44733\")]\n+    pub fn and_modify<F>(self, mut f: F) -> Self\n+        where F: FnMut(&mut V)\n+    {\n+        match self {\n+            Occupied(mut entry) => {\n+                f(entry.get_mut());\n+                Occupied(entry)\n+            },\n+            Vacant(entry) => Vacant(entry),\n+        }\n+    }\n }\n \n impl<'a, K: Ord, V: Default> Entry<'a, K, V> {"}, {"sha": "a092bfb3b0a8a5899da6d8d5955cd5101bc4cc6e", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Utilities for formatting and printing `String`s\n+//! Utilities for formatting and printing `String`s.\n //!\n //! This module contains the runtime support for the [`format!`] syntax extension.\n //! This macro is implemented in the compiler to emit calls to this module in\n@@ -236,6 +236,8 @@\n //! writeln!     // same as write but appends a newline\n //! print!       // the format string is printed to the standard output\n //! println!     // same as print but appends a newline\n+//! eprint!      // the format string is printed to the standard error\n+//! eprintln!    // same as eprint but appends a newline\n //! format_args! // described below.\n //! ```\n //!\n@@ -264,6 +266,11 @@\n //! print!(\"Hello {}!\", \"world\");\n //! println!(\"I have a newline {}\", \"character at the end\");\n //! ```\n+//! ### `eprint!`\n+//!\n+//! The [`eprint!`] and [`eprintln!`] macros are identical to\n+//! [`print!`] and [`println!`], respectively, except they emit their\n+//! output to stderr.\n //!\n //! ### `format_args!`\n //!\n@@ -475,7 +482,6 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n //!\n-//! [`format!`]: ../../macro.format.html\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html\n@@ -491,7 +497,10 @@\n //! [`writeln!`]: ../../std/macro.writeln.html\n //! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n //! [`std::io::Write`]: ../../std/io/trait.Write.html\n+//! [`print!`]: ../../std/macro.print.html\n //! [`println!`]: ../../std/macro.println.html\n+//! [`eprint!`]: ../../std/macro.eprint.html\n+//! [`eprintln!`]: ../../std/macro.eprintln.html\n //! [`write!`]: ../../std/macro.write.html\n //! [`format_args!`]: ../../std/macro.format_args.html\n //! [`fmt::Arguments`]: struct.Arguments.html\n@@ -537,7 +546,7 @@ use string;\n /// assert_eq!(s, \"Hello, world!\");\n /// ```\n ///\n-/// Please note that using [`format!`] might be preferrable.\n+/// Please note that using [`format!`] might be preferable.\n /// Example:\n ///\n /// ```"}, {"sha": "3cc3ea467966be5a11dc56d4c6b429c00a450e0d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -83,6 +83,7 @@\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]\n+#![feature(ascii_ctype)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n@@ -93,6 +94,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n+#![feature(from_ref)]\n #![feature(fundamental)]\n #![feature(fused)]\n #![feature(generic_param_attrs)]\n@@ -121,6 +123,7 @@\n #![feature(unique)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n+#![feature(on_unimplemented)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]\n@@ -132,6 +135,8 @@\n extern crate std;\n #[cfg(test)]\n extern crate test;\n+#[cfg(test)]\n+extern crate rand;\n \n extern crate std_unicode;\n "}, {"sha": "0fe3c9724224d5b8df520e47895b677e050a90e3", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 149, "deletions": 2, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -80,7 +80,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     }\n }\n \n-// FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Self {\n@@ -220,6 +220,28 @@ impl<T> LinkedList<T> {\n             node\n         })\n     }\n+\n+    /// Unlinks the specified node from the current list.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the current list.\n+    #[inline]\n+    unsafe fn unlink_node(&mut self, mut node: Shared<Node<T>>) {\n+        let node = node.as_mut();\n+\n+        match node.prev {\n+            Some(mut prev) => prev.as_mut().next = node.next.clone(),\n+            // this node is the head node\n+            None => self.head = node.next.clone(),\n+        };\n+\n+        match node.next {\n+            Some(mut next) => next.as_mut().prev = node.prev.clone(),\n+            // this node is the tail node\n+            None => self.tail = node.prev.clone(),\n+        };\n+\n+        self.len -= 1;\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -722,6 +744,49 @@ impl<T> LinkedList<T> {\n         second_part\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a list into evens and odds, reusing the original list:\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut numbers: LinkedList<u32> = LinkedList::new();\n+    /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n+    /// ```\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool\n+    {\n+        // avoid borrow issues.\n+        let it = self.head;\n+        let old_len = self.len;\n+\n+        DrainFilter {\n+            list: self,\n+            it: it,\n+            pred: filter,\n+            idx: 0,\n+            old_len: old_len,\n+        }\n+    }\n+\n     /// Returns a place for insertion at the front of the list.\n     ///\n     /// Using this method with placement syntax is equivalent to\n@@ -967,6 +1032,56 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on LinkedList.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub struct DrainFilter<'a, T: 'a, F: 'a>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    list: &'a mut LinkedList<T>,\n+    it: Option<Shared<Node<T>>>,\n+    pred: F,\n+    idx: usize,\n+    old_len: usize,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        while let Some(mut node) = self.it {\n+            unsafe {\n+                self.it = node.as_ref().next;\n+                self.idx += 1;\n+\n+                if (self.pred)(&mut node.as_mut().element) {\n+                    self.list.unlink_node(node);\n+                    return Some(Box::from_raw(node.as_ptr()).element);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\")\n+         .field(&self.list)\n+         .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n@@ -1269,10 +1384,11 @@ unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n \n #[cfg(test)]\n mod tests {\n-    use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n \n+    use rand::{thread_rng, Rng};\n+\n     use super::{LinkedList, Node};\n \n     #[cfg(test)]\n@@ -1287,6 +1403,8 @@ mod tests {\n             let mut node_ptr: &Node<T>;\n             match list.head {\n                 None => {\n+                    // tail node should also be None.\n+                    assert!(list.tail.is_none());\n                     assert_eq!(0, list.len);\n                     return;\n                 }\n@@ -1313,6 +1431,11 @@ mod tests {\n                     }\n                 }\n             }\n+\n+            // verify that the tail node points to the last node.\n+            let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n+            assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n+            // check that len matches interior links.\n             assert_eq!(len, list.len);\n         }\n     }\n@@ -1501,4 +1624,28 @@ mod tests {\n         }\n         assert_eq!(i, v.len());\n     }\n+\n+    #[test]\n+    fn drain_filter_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+    }\n+\n+    #[test]\n+    fn drain_to_empty_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    }\n }"}, {"sha": "472eef77d7956411ddfa93d4ab60d7e291860ef9", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -72,7 +72,7 @@ macro_rules! vec {\n \n /// Creates a `String` using interpolation of runtime expressions.\n ///\n-/// The first argument `format!` recieves is a format string.  This must be a string\n+/// The first argument `format!` receives is a format string.  This must be a string\n /// literal.  The power of the formatting string is in the `{}`s contained.\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the"}, {"sha": "dbf1fb1367dda257ecb88aa7118f0be03f1b0f80", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -114,7 +114,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n impl<T> RawVec<T, Heap> {\n     /// Creates the biggest possible RawVec (on the system heap)\n     /// without allocating. If T has positive size, then this makes a\n-    /// RawVec with capacity 0. If T has 0 size, then it it makes a\n+    /// RawVec with capacity 0. If T has 0 size, then it makes a\n     /// RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {"}, {"sha": "58f08fd8bc11d854216f571034d8d0213c53606e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -19,7 +19,7 @@\n //! given value is destroyed, the pointed-to value is also destroyed.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n-//! is no exception: you cannot obtain a mutable reference to\n+//! is no exception: you cannot generally obtain a mutable reference to\n //! something inside an [`Rc`]. If you need mutability, put a [`Cell`]\n //! or [`RefCell`] inside the [`Rc`]; see [an example of mutability\n //! inside an Rc][mutability].\n@@ -346,7 +346,7 @@ impl<T> Rc<T> {\n             unsafe {\n                 let val = ptr::read(&*this); // copy the contained object\n \n-                // Indicate to Weaks that they can't be promoted by decrememting\n+                // Indicate to Weaks that they can't be promoted by decrementing\n                 // the strong count, and then remove the implicit \"strong weak\"\n                 // pointer while also handling drop logic by just crafting a\n                 // fake Weak.\n@@ -1072,7 +1072,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.ptr, f)\n+        fmt::Pointer::fmt(&(&**self as *const T), f)\n     }\n }\n "}, {"sha": "ac815629dcfb3ba4e857b501fd8ac71d59efa711", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 204, "deletions": 17, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -119,6 +119,8 @@ pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n+#[unstable(feature = \"from_ref\", issue = \"45703\")]\n+pub use core::slice::{from_ref, from_ref_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n pub use core::slice::SliceIndex;\n \n@@ -1426,15 +1428,45 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n+    /// Cloning two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.clone_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n     /// ```\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2, 3];\n     ///\n-    /// dst.clone_from_slice(&src);\n-    /// assert!(dst == [1, 2, 3]);\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `clone_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.clone_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n     /// [`copy_from_slice`]: #method.copy_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n@@ -1452,43 +1484,106 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n+    /// Copying two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.copy_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n     /// ```\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2, 3];\n     ///\n-    /// dst.copy_from_slice(&src);\n-    /// assert_eq!(src, dst);\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `copy_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.copy_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n     /// [`clone_from_slice`]: #method.clone_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n         core_slice::SliceExt::copy_from_slice(self, src)\n     }\n \n-    /// Swaps all elements in `self` with those in `src`.\n+    /// Swaps all elements in `self` with those in `other`.\n     ///\n-    /// The length of `src` must be the same as `self`.\n+    /// The length of `other` must be the same as `self`.\n     ///\n     /// # Panics\n     ///\n     /// This function will panic if the two slices have different lengths.\n     ///\n     /// # Example\n     ///\n+    /// Swapping two elements across slices:\n+    ///\n+    /// ```\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut slice1 = [0, 0];\n+    /// let mut slice2 = [1, 2, 3, 4];\n+    ///\n+    /// slice1.swap_with_slice(&mut slice2[2..]);\n+    ///\n+    /// assert_eq!(slice1, [3, 4]);\n+    /// assert_eq!(slice2, [1, 2, 0, 0]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference to a\n+    /// particular piece of data in a particular scope. Because of this,\n+    /// attempting to use `swap_with_slice` on a single slice will result in\n+    /// a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// mutable sub-slices from a slice:\n+    ///\n     /// ```\n     /// #![feature(swap_with_slice)]\n     ///\n-    /// let mut src = [1, 2, 3];\n-    /// let mut dst = [7, 8, 9];\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.swap_with_slice(&mut right[1..]);\n+    /// }\n     ///\n-    /// src.swap_with_slice(&mut dst);\n-    /// assert_eq!(src, [7, 8, 9]);\n-    /// assert_eq!(dst, [1, 2, 3]);\n+    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n     /// ```\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n-    pub fn swap_with_slice(&mut self, src: &mut [T]) {\n-        core_slice::SliceExt::swap_with_slice(self, src)\n+    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n+        core_slice::SliceExt::swap_with_slice(self, other)\n     }\n \n     /// Copies `self` into a new `Vec`.\n@@ -1531,6 +1626,98 @@ impl<T> [T] {\n     }\n }\n \n+#[lang = \"slice_u8\"]\n+#[cfg(not(test))]\n+impl [u8] {\n+    /// Checks if all bytes in this slice are within the ASCII range.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_uppercase();\n+        me\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_lowercase();\n+        me\n+    }\n+\n+    /// Checks that two slices are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| {\n+                a.eq_ignore_ascii_case(b)\n+            })\n+    }\n+\n+    /// Converts this slice to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    /// Converts this slice to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "975ea4e1a3e01eaeb806316bc891ecf33228b87b", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 139, "deletions": 15, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -363,16 +363,16 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// let v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n     ///\n     /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n     ///\n     /// // indices not on UTF-8 sequence boundaries\n-    /// assert!(v.get_mut(1..).is_none());\n-    /// assert!(v.get_mut(..8).is_none());\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n     ///\n     /// // out of bounds\n-    /// assert!(v.get_mut(..42).is_none());\n+    /// assert!(v.get(..42).is_none());\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n@@ -390,8 +390,6 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut v = String::from(\"hello\");\n     /// // correct length\n     /// assert!(v.get_mut(0..5).is_some());\n@@ -617,8 +615,6 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n     /// {\n     ///     let (first, last) = s.split_at_mut(3);\n@@ -959,13 +955,15 @@ impl str {\n     /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n     /// ```\n     ///\n-    /// More complex patterns with closures:\n+    /// More complex patterns using point-free style and closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find(char::is_whitespace), Some(5));\n     /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n+    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n     /// ```\n     ///\n     /// Not finding the pattern:\n@@ -1736,7 +1734,7 @@ impl str {\n     /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n+    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n@@ -2047,10 +2045,8 @@ impl str {\n     /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     pub fn into_string(self: Box<str>) -> String {\n-        unsafe {\n-            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n-            String::from_utf8_unchecked(slice.into_vec())\n-        }\n+        let slice = Box::<[u8]>::from(self);\n+        unsafe { String::from_utf8_unchecked(slice.into_vec()) }\n     }\n \n     /// Create a [`String`] by repeating a string `n` times.\n@@ -2070,6 +2066,134 @@ impl str {\n         s.extend((0..n).map(|_| self));\n         s\n     }\n+\n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = \"hello!\\n\";\n+    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        // We can treat each byte as character here: all multibyte characters\n+        // start with a byte that is not in the ascii range, so we will stop\n+        // there already.\n+        self.bytes().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`to_uppercase`]: #method.to_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_uppercase();\n+        // make_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`to_lowercase`]: #method.to_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_lowercase();\n+        // make_ascii_lowercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n+    }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_lowercase()\n+    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking\n@@ -2087,5 +2211,5 @@ impl str {\n /// ```\n #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n-    mem::transmute(v)\n+    Box::from_raw(Box::into_raw(v) as *mut str)\n }"}, {"sha": "cd0f4a22e9cfac32009a54cb535cfab4260129b8", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -596,7 +596,7 @@ impl String {\n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.htlm#variant.Err\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -773,8 +773,6 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut s = String::from(\"foobar\");\n     /// let s_mut_str = s.as_mut_str();\n     ///"}, {"sha": "d3ce12056bb49e0d8114e5655872a87265f7cdb9", "filename": "src/liballoc/tests/heap.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc_system::System;\n+use std::heap::{Heap, Alloc, Layout};\n+\n+/// https://github.com/rust-lang/rust/issues/45955\n+///\n+/// Note that `#[global_allocator]` is not used,\n+/// so `liballoc_jemalloc` is linked (on some platforms).\n+#[test]\n+fn alloc_system_overaligned_request() {\n+    check_overalign_requests(System)\n+}\n+\n+#[test]\n+fn std_heap_overaligned_request() {\n+    check_overalign_requests(Heap)\n+}\n+\n+fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+    let size = 8;\n+    let align = 16; // greater than size\n+    let iterations = 100;\n+    unsafe {\n+        let pointers: Vec<_> = (0..iterations).map(|_| {\n+            allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+        }).collect();\n+        for &ptr in &pointers {\n+            assert_eq!((ptr as usize) % align, 0, \"Got a pointer less aligned than requested\")\n+        }\n+\n+        // Clean up\n+        for &ptr in &pointers {\n+            allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+        }\n+    }\n+}"}, {"sha": "f1e95883b38279bddd120fb82cf48974fe76c071", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -10,6 +10,8 @@\n \n #![deny(warnings)]\n \n+#![feature(allocator_api)]\n+#![feature(alloc_system)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]\n@@ -29,7 +31,9 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n \n+extern crate alloc_system;\n extern crate std_unicode;\n+extern crate rand;\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n@@ -38,6 +42,7 @@ mod binary_heap;\n mod btree;\n mod cow_str;\n mod fmt;\n+mod heap;\n mod linked_list;\n mod slice;\n mod str;"}, {"sha": "4e3e855105eb8523f970e3019c508a0e4fdf8c22", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -366,3 +366,191 @@ fn test_contains() {\n \n     assert!(!l.contains(&3));\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = vec![(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            1,\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {   // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}"}, {"sha": "85d5ce304b88de2c27556a8414d61e93bb681173", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -10,9 +10,10 @@\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::mem;\n-use std::__rand::{Rng, thread_rng};\n use std::rc::Rc;\n \n+use rand::{Rng, thread_rng};\n+\n fn square(n: usize) -> usize {\n     n * n\n }"}, {"sha": "a14a5d32738b3198dbdec3c7c9de9eada796c063", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -706,7 +706,6 @@ fn test_split_at() {\n \n #[test]\n fn test_split_at_mut() {\n-    use std::ascii::AsciiExt;\n     let mut s = \"Hello World\".to_string();\n     {\n         let (a, b) = s.split_at_mut(5);\n@@ -1428,12 +1427,12 @@ mod pattern {\n         Reject(6, 7),\n         Match (7, 7),\n     ]);\n-    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n+    make_test!(str_searcher_multibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n         Reject(0, 3),\n         Reject(3, 6),\n         Reject(6, 9),\n     ]);\n-    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n+    make_test!(str_searcher_empty_needle_multibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n         Match (0, 0),\n         Reject(0, 3),\n         Match (3, 3),\n@@ -1456,7 +1455,7 @@ mod pattern {\n         Match (5, 6),\n         Reject(6, 7),\n     ]);\n-    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n+    make_test!(char_searcher_multibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n         Reject(0, 3),\n         Reject(3, 6),\n         Reject(6, 9),"}, {"sha": "9cfde5dcc73c8433b0f37f030a30b1b0b6fbb9b0", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ascii::AsciiExt;\n use std::borrow::Cow;\n use std::mem::size_of;\n use std::panic;\n@@ -966,5 +965,3 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n-\n-"}, {"sha": "c29449a241e4576dbf447252e9b59eebe02dd374", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -507,13 +507,9 @@ impl<T> Vec<T> {\n \n     /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n-    /// Note that this will drop any excess capacity. Calling this and\n-    /// converting back to a vector with [`into_vec`] is equivalent to calling\n-    /// [`shrink_to_fit`].\n+    /// Note that this will drop any excess capacity.\n     ///\n     /// [owned slice]: ../../std/boxed/struct.Box.html\n-    /// [`into_vec`]: ../../std/primitive.slice.html#method.into_vec\n-    /// [`shrink_to_fit`]: #method.shrink_to_fit\n     ///\n     /// # Examples\n     ///\n@@ -857,8 +853,6 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n     ///\n     /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n@@ -1095,7 +1089,7 @@ impl<T> Vec<T> {\n         // Memory safety\n         //\n         // When the Drain is first created, it shortens the length of\n-        // the source vector to make sure no uninitalized or moved-from elements\n+        // the source vector to make sure no uninitialized or moved-from elements\n         // are accessible at all if the Drain's destructor never gets to run.\n         //\n         // Drain will ptr::read out the values to remove.\n@@ -1547,6 +1541,7 @@ impl<T: Hash> Hash for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n@@ -1558,6 +1553,7 @@ impl<T> Index<usize> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> IndexMut<usize> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n@@ -1566,8 +1562,8 @@ impl<T> IndexMut<usize> for Vec<T> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1576,7 +1572,9 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1585,7 +1583,9 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1594,7 +1594,9 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n@@ -1603,7 +1605,9 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1612,7 +1616,9 @@ impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1623,41 +1629,52 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n@@ -1950,7 +1967,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(u, &[1, 2]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+    #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n         where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n     {\n@@ -2553,13 +2570,13 @@ impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n /// [`splice()`]: struct.Vec.html#method.splice\n /// [`Vec`]: struct.Vec.html\n #[derive(Debug)]\n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {\n     drain: Drain<'a, I::Item>,\n     replace_with: I,\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     type Item = I::Item;\n \n@@ -2572,18 +2589,18 @@ impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     }\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n \n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> Drop for Splice<'a, I> {\n     fn drop(&mut self) {\n         // exhaust drain first"}, {"sha": "f56aa23a4eb2f83f78b704ff025791bd86e22b00", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1922,7 +1922,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     }\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {"}, {"sha": "6d7d83dd99388aa10145a78c4b7b663dd38af802", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -19,7 +19,7 @@ libc = { path = \"../rustc/libc_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n \n [features]\n debug = []"}, {"sha": "de5006ad3960abc82b2d375fab6a318c6d015660", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n        target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n-       target.contains(\"redox\") {\n+       target.contains(\"redox\") || target.contains(\"wasm32\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }\n@@ -63,24 +63,13 @@ fn main() {\n         _ => return,\n     };\n \n-    let compiler = cc::Build::new().get_compiler();\n-    // only msvc returns None for ar so unwrap is okay\n-    let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n-    let cflags = compiler.args()\n-        .iter()\n-        .map(|s| s.to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\" \");\n-\n     let mut cmd = Command::new(\"sh\");\n     cmd.arg(native.src_dir.join(\"configure\")\n                           .to_str()\n                           .unwrap()\n                           .replace(\"C:\\\\\", \"/c/\")\n                           .replace(\"\\\\\", \"/\"))\n        .current_dir(&native.out_dir)\n-       .env(\"CC\", compiler.path())\n-       .env(\"EXTRA_CFLAGS\", cflags.clone())\n        // jemalloc generates Makefile deps using GCC's \"-MM\" flag. This means\n        // that GCC will run the preprocessor, and only the preprocessor, over\n        // jemalloc's source files. If we don't specify CPPFLAGS, then at least\n@@ -89,9 +78,7 @@ fn main() {\n        // passed to GCC, and then GCC won't define the\n        // \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\" macro that jemalloc needs to\n        // select an atomic operation implementation.\n-       .env(\"CPPFLAGS\", cflags.clone())\n-       .env(\"AR\", &ar)\n-       .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n+       .env(\"CPPFLAGS\", env::var_os(\"CFLAGS\").unwrap_or_default());\n \n     if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");\n@@ -153,6 +140,6 @@ fn main() {\n         cc::Build::new()\n             .flag(\"-fvisibility=hidden\")\n             .file(\"pthread_atfork_dummy.c\")\n-            .compile(\"libpthread_atfork_dummy.a\");\n+            .compile(\"pthread_atfork_dummy\");\n     }\n }"}, {"sha": "d7370ae400dac762d2e7a81771c9812606657cf9", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -72,8 +72,7 @@ mod contents {\n     const MALLOCX_ZERO: c_int = 0x40;\n \n     // The minimum alignment guaranteed by the architecture. This value is used to\n-    // add fast paths for low alignment values. In practice, the alignment is a\n-    // constant at the call site and the branch will be optimized out.\n+    // add fast paths for low alignment values.\n     #[cfg(all(any(target_arch = \"arm\",\n                   target_arch = \"mips\",\n                   target_arch = \"powerpc\")))]\n@@ -92,8 +91,8 @@ mod contents {\n         a.trailing_zeros() as c_int\n     }\n \n-    fn align_to_flags(align: usize) -> c_int {\n-        if align <= MIN_ALIGN {\n+    fn align_to_flags(align: usize, size: usize) -> c_int {\n+        if align <= MIN_ALIGN && align <= size {\n             0\n         } else {\n             mallocx_align(align)\n@@ -107,11 +106,11 @@ mod contents {\n     // ABI\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_alloc(size: usize,\n                                      align: usize,\n                                      err: *mut u8) -> *mut u8 {\n-        let flags = align_to_flags(align);\n+        let flags = align_to_flags(align, size);\n         let ptr = mallocx(size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             let layout = Layout::from_size_align_unchecked(size, align);\n@@ -122,27 +121,27 @@ mod contents {\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_oom(err: *const u8) -> ! {\n         System.oom((*(err as *const AllocErr)).clone())\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        let flags = align_to_flags(align);\n+        let flags = align_to_flags(align, size);\n         sdallocx(ptr as *mut c_void, size, flags);\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_usable_size(layout: *const u8,\n                                            min: *mut usize,\n                                            max: *mut usize) {\n         let layout = &*(layout as *const Layout);\n-        let flags = align_to_flags(layout.align());\n+        let flags = align_to_flags(layout.align(), layout.size());\n         let size = nallocx(layout.size(), flags) as usize;\n         *min = layout.size();\n         if size > 0 {\n@@ -153,7 +152,7 @@ mod contents {\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_realloc(ptr: *mut u8,\n                                        _old_size: usize,\n                                        old_align: usize,\n@@ -166,7 +165,7 @@ mod contents {\n             return 0 as *mut u8\n         }\n \n-        let flags = align_to_flags(new_align);\n+        let flags = align_to_flags(new_align, new_size);\n         let ptr = rallocx(ptr as *mut c_void, new_size, flags) as *mut u8;\n         if ptr.is_null() {\n             let layout = Layout::from_size_align_unchecked(new_size, new_align);\n@@ -177,14 +176,14 @@ mod contents {\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_alloc_zeroed(size: usize,\n                                             align: usize,\n                                             err: *mut u8) -> *mut u8 {\n-        let ptr = if align <= MIN_ALIGN {\n+        let ptr = if align <= MIN_ALIGN && align <= size {\n             calloc(size as size_t, 1) as *mut u8\n         } else {\n-            let flags = align_to_flags(align) | MALLOCX_ZERO;\n+            let flags = align_to_flags(align, size) | MALLOCX_ZERO;\n             mallocx(size as size_t, flags) as *mut u8\n         };\n         if ptr.is_null() {\n@@ -196,20 +195,21 @@ mod contents {\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_alloc_excess(size: usize,\n                                             align: usize,\n                                             excess: *mut usize,\n                                             err: *mut u8) -> *mut u8 {\n         let p = __rde_alloc(size, align, err);\n         if !p.is_null() {\n-            *excess = size;\n+            let flags = align_to_flags(align, size);\n+            *excess = nallocx(size, flags) as usize;\n         }\n         return p\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_realloc_excess(ptr: *mut u8,\n                                               old_size: usize,\n                                               old_align: usize,\n@@ -219,13 +219,14 @@ mod contents {\n                                               err: *mut u8) -> *mut u8 {\n         let p = __rde_realloc(ptr, old_size, old_align, new_size, new_align, err);\n         if !p.is_null() {\n-            *excess = new_size;\n+            let flags = align_to_flags(new_align, new_size);\n+            *excess = nallocx(new_size, flags) as usize;\n         }\n-        return p\n+        p\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_grow_in_place(ptr: *mut u8,\n                                              old_size: usize,\n                                              old_align: usize,\n@@ -235,14 +236,14 @@ mod contents {\n     }\n \n     #[no_mangle]\n-    #[linkage = \"external\"]\n+    #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_shrink_in_place(ptr: *mut u8,\n                                                _old_size: usize,\n                                                old_align: usize,\n                                                new_size: usize,\n                                                new_align: usize) -> u8 {\n         if old_align == new_align {\n-            let flags = align_to_flags(new_align);\n+            let flags = align_to_flags(new_align, new_size);\n             (xallocx(ptr as *mut c_void, new_size, 0, flags) == new_size) as u8\n         } else {\n             0"}, {"sha": "f9a57f7d97a74ea914602769708754e84958d9b4", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -13,3 +13,7 @@ doc = false\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n+\n+# See comments in the source for what this dependency is\n+[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+dlmalloc = { path = \"../rustc/dlmalloc_shim\" }"}, {"sha": "27259cc31a5ed56824c2138084e9dcc9b1065adb", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 95, "deletions": 6, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -14,7 +14,7 @@\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n-            issue = \"27783\")]\n+            issue = \"32838\")]\n #![feature(global_allocator)]\n #![feature(allocator_api)]\n #![feature(alloc)]\n@@ -25,21 +25,22 @@\n #![rustc_alloc_kind = \"lib\"]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values. In practice, the alignment is a\n-// constant at the call site and the branch will be optimized out.\n+// add fast paths for low alignment values.\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n               target_arch = \"powerpc64\",\n               target_arch = \"asmjs\",\n               target_arch = \"wasm32\")))]\n+#[allow(dead_code)]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\")))]\n+#[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n extern crate alloc;\n@@ -130,7 +131,7 @@ mod platform {\n     unsafe impl<'a> Alloc for &'a System {\n         #[inline]\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            let ptr = if layout.align() <= MIN_ALIGN {\n+            let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 libc::malloc(layout.size()) as *mut u8\n             } else {\n                 aligned_malloc(&layout)\n@@ -146,7 +147,7 @@ mod platform {\n         unsafe fn alloc_zeroed(&mut self, layout: Layout)\n             -> Result<*mut u8, AllocErr>\n         {\n-            if layout.align() <= MIN_ALIGN {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 let ptr = libc::calloc(layout.size(), 1) as *mut u8;\n                 if !ptr.is_null() {\n                     Ok(ptr)\n@@ -178,7 +179,7 @@ mod platform {\n                 })\n             }\n \n-            if new_layout.align() <= MIN_ALIGN {\n+            if new_layout.align() <= MIN_ALIGN  && new_layout.align() <= new_layout.size(){\n                 let ptr = libc::realloc(ptr as *mut libc::c_void, new_layout.size());\n                 if !ptr.is_null() {\n                     Ok(ptr as *mut u8)\n@@ -458,3 +459,91 @@ mod platform {\n         }\n     }\n }\n+\n+// This is an implementation of a global allocator on the wasm32 platform when\n+// emscripten is not in use. In that situation there's no actual runtime for us\n+// to lean on for allocation, so instead we provide our own!\n+//\n+// The wasm32 instruction set has two instructions for getting the current\n+// amount of memory and growing the amount of memory. These instructions are the\n+// foundation on which we're able to build an allocator, so we do so! Note that\n+// the instructions are also pretty \"global\" and this is the \"global\" allocator\n+// after all!\n+//\n+// The current allocator here is the `dlmalloc` crate which we've got included\n+// in the rust-lang/rust repository as a submodule. The crate is a port of\n+// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+// for now which is currently technically required (can't link with C yet).\n+//\n+// The crate itself provides a global allocator which on wasm has no\n+// synchronization as there are no threads!\n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+mod platform {\n+    extern crate dlmalloc;\n+\n+    use alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+    use System;\n+    use self::dlmalloc::GlobalDlmalloc;\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            GlobalDlmalloc.alloc(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n+            -> Result<*mut u8, AllocErr>\n+        {\n+            GlobalDlmalloc.alloc_zeroed(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            GlobalDlmalloc.dealloc(ptr, layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            GlobalDlmalloc.realloc(ptr, old_layout, new_layout)\n+        }\n+\n+        #[inline]\n+        fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n+            GlobalDlmalloc.usable_size(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+            GlobalDlmalloc.alloc_excess(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc_excess(&mut self,\n+                                 ptr: *mut u8,\n+                                 layout: Layout,\n+                                 new_layout: Layout) -> Result<Excess, AllocErr> {\n+            GlobalDlmalloc.realloc_excess(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn grow_in_place(&mut self,\n+                                ptr: *mut u8,\n+                                layout: Layout,\n+                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            GlobalDlmalloc.grow_in_place(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn shrink_in_place(&mut self,\n+                                  ptr: *mut u8,\n+                                  layout: Layout,\n+                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            GlobalDlmalloc.shrink_in_place(ptr, layout, new_layout)\n+        }\n+    }\n+}"}, {"sha": "8bdb29d25606f81756b37437032f286dadcad96d", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12323,6 +12323,12 @@ fi\n \n   fi\n fi\n+\n+case \"${host_os}\" in\n+darwin*)\n+  have_mmap=no ;;\n+esac\n+\n if test \"$have_mmap\" = \"no\"; then\n   VIEW_FILE=read.lo\n   ALLOC_FILE=alloc.lo\n@@ -12338,7 +12344,7 @@ else\n \n _ACEOF\n if ac_fn_c_try_cpp \"$LINENO\"; then :\n-  ALLOC_FILE=mmap.lo\n+  ALLOC_FILE=alloc.lo\n else\n   ALLOC_FILE=alloc.lo\n fi\n@@ -14578,7 +14584,7 @@ func_basename ()\n #             to NONDIR_REPLACEMENT.\n #             value returned in \"$func_dirname_result\"\n #   basename: Compute filename of FILE.\n-#             value retuned in \"$func_basename_result\"\n+#             value returned in \"$func_basename_result\"\n # Implementation must be kept synchronized with func_dirname\n # and func_basename. For efficiency, we do not delegate to\n # those functions but instead duplicate the functionality here."}, {"sha": "ea1b27d807e13d9741f4fa7821f16e6f2e0006c3", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -283,6 +283,12 @@ else\n     AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n   fi\n fi\n+\n+case \"${host_os}\" in\n+darwin*)\n+  have_mmap=no ;;\n+esac\n+\n if test \"$have_mmap\" = \"no\"; then\n   VIEW_FILE=read.lo\n   ALLOC_FILE=alloc.lo"}, {"sha": "eff9e62be8a05644a842fd99ca5ae814282797b0", "filename": "src/libbacktrace/ltmain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -177,7 +177,7 @@ basename=\"s,^.*/,,\"\n #             to NONDIR_REPLACEMENT.\n #             value returned in \"$func_dirname_result\"\n #   basename: Compute filename of FILE.\n-#             value retuned in \"$func_basename_result\"\n+#             value returned in \"$func_basename_result\"\n # Implementation must be kept synchronized with func_dirname\n # and func_basename. For efficiency, we do not delegate to\n # those functions but instead duplicate the functionality here."}, {"sha": "800e36161d245b39f36c3e33e8c0bc1daaa91641", "filename": "src/libcollections/Cargo.toml", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,12 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"collections\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"collections\"\n-path = \"lib.rs\"\n-\n-[dependencies]\n-alloc = { path = \"../liballoc\" }\n-core = { path = \"../libcore\" }"}, {"sha": "55316db3d5a4358f6582328f9951fa489e227113", "filename": "src/libcollections/lib.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"collections\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"27783\")]\n-#![rustc_deprecated(since = \"1.20.0\",\n-                    reason = \"collections moved to `alloc`\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-#![no_std]\n-#![deny(warnings)]\n-\n-#![feature(alloc)]\n-#![feature(collections_range)]\n-#![feature(macro_reexport)]\n-#![feature(staged_api)]\n-\n-//! Collection types\n-//!\n-//! See [`std::collections`](../std/collections/index.html) for a detailed\n-//! discussion of collections in Rust.\n-\n-#[macro_reexport(vec, format)]\n-extern crate alloc;\n-\n-pub use alloc::Bound;\n-\n-pub use alloc::binary_heap;\n-pub use alloc::borrow;\n-pub use alloc::fmt;\n-pub use alloc::linked_list;\n-pub use alloc::range;\n-pub use alloc::slice;\n-pub use alloc::str;\n-pub use alloc::string;\n-pub use alloc::vec;\n-pub use alloc::vec_deque;\n-\n-pub use alloc::btree_map;\n-pub use alloc::btree_set;\n-\n-#[doc(no_inline)]\n-pub use alloc::binary_heap::BinaryHeap;\n-#[doc(no_inline)]\n-pub use alloc::btree_map::BTreeMap;\n-#[doc(no_inline)]\n-pub use alloc::btree_set::BTreeSet;\n-#[doc(no_inline)]\n-pub use alloc::linked_list::LinkedList;\n-#[doc(no_inline)]\n-pub use alloc::vec_deque::VecDeque;\n-#[doc(no_inline)]\n-pub use alloc::string::String;\n-#[doc(no_inline)]\n-pub use alloc::vec::Vec;"}, {"sha": "18feaccbfd0dfbd5ab5d0a2a6eac9c04be667266", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1 +1 @@\n-Subproject commit ef4951582f620c589cd9e18ec182538bf116bce3\n+Subproject commit 18feaccbfd0dfbd5ab5d0a2a6eac9c04be667266"}, {"sha": "5af63aa970f2c7cb50a720298b73dbc875e5b4c9", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -9,9 +9,6 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n-[dev-dependencies]\n-rand = { path = \"../librand\" }\n-\n [[test]]\n name = \"coretests\"\n path = \"../libcore/tests/lib.rs\""}, {"sha": "3d24f8902bd83827be8aee45f393f9cf9f9e33a6", "filename": "src/libcore/array.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -21,6 +21,7 @@\n \n use borrow::{Borrow, BorrowMut};\n use cmp::Ordering;\n+use convert::TryFrom;\n use fmt;\n use hash::{Hash, self};\n use marker::Unsize;\n@@ -57,6 +58,30 @@ unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n     }\n }\n \n+/// The error type returned when a conversion from a slice to an array fails.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Debug, Copy, Clone)]\n+pub struct TryFromSliceError(());\n+\n+impl fmt::Display for TryFromSliceError {\n+    #[inline]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.__description(), f)\n+    }\n+}\n+\n+impl TryFromSliceError {\n+    #[unstable(feature = \"array_error_internals\",\n+           reason = \"available through Error trait and this method should not \\\n+                     be exposed publicly\",\n+           issue = \"0\")]\n+    #[inline]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        \"could not convert slice to array\"\n+    }\n+}\n+\n macro_rules! __impl_slice_eq1 {\n     ($Lhs: ty, $Rhs: ty) => {\n         __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n@@ -123,6 +148,34 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n+                type Error = TryFromSliceError;\n+\n+                fn try_from(slice: &[T]) -> Result<&[T; $N], TryFromSliceError> {\n+                    if slice.len() == $N {\n+                        let ptr = slice.as_ptr() as *const [T; $N];\n+                        unsafe { Ok(&*ptr) }\n+                    } else {\n+                        Err(TryFromSliceError(()))\n+                    }\n+                }\n+            }\n+\n+            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n+                type Error = TryFromSliceError;\n+\n+                fn try_from(slice: &mut [T]) -> Result<&mut [T; $N], TryFromSliceError> {\n+                    if slice.len() == $N {\n+                        let ptr = slice.as_mut_ptr() as *mut [T; $N];\n+                        unsafe { Ok(&mut *ptr) }\n+                    } else {\n+                        Err(TryFromSliceError(()))\n+                    }\n+                }\n+            }\n+\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: Hash> Hash for [T; $N] {\n                 fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "b284d855c45157e984894089a438e242ea6c5bc3", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 127, "deletions": 30, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -147,40 +147,137 @@ fn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n     });\n }\n \n-#[bench]\n-fn bench_flat_map_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .sum()\n-    });\n+\n+/// Helper to benchmark `sum` for iterators taken by value which\n+/// can optimize `fold`, and by reference which cannot.\n+macro_rules! bench_sums {\n+    ($bench_sum:ident, $bench_ref_sum:ident, $iter:expr) => {\n+        #[bench]\n+        fn $bench_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).sum()\n+            });\n+        }\n+\n+        #[bench]\n+        fn $bench_ref_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).by_ref().sum()\n+            });\n+        }\n+    }\n }\n \n-#[bench]\n-fn bench_flat_map_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_sum,\n+    bench_flat_map_ref_sum,\n+    (0i64..1000).flat_map(|x| x..x+1000)\n }\n \n-#[bench]\n-fn bench_flat_map_chain_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_chain_sum,\n+    bench_flat_map_chain_ref_sum,\n+    (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n }\n \n-#[bench]\n-fn bench_flat_map_chain_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_enumerate_sum,\n+    bench_enumerate_ref_sum,\n+    (0i64..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_enumerate_chain_sum,\n+    bench_enumerate_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_filter_sum,\n+    bench_filter_ref_sum,\n+    (0i64..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_chain_sum,\n+    bench_filter_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_map_sum,\n+    bench_filter_map_ref_sum,\n+    (0i64..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_filter_map_chain_sum,\n+    bench_filter_map_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_fuse_sum,\n+    bench_fuse_ref_sum,\n+    (0i64..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_fuse_chain_sum,\n+    bench_fuse_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_inspect_sum,\n+    bench_inspect_ref_sum,\n+    (0i64..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_inspect_chain_sum,\n+    bench_inspect_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_peekable_sum,\n+    bench_peekable_ref_sum,\n+    (0i64..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_peekable_chain_sum,\n+    bench_peekable_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_skip_sum,\n+    bench_skip_ref_sum,\n+    (0i64..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_chain_sum,\n+    bench_skip_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_sum,\n+    bench_skip_while_ref_sum,\n+    (0i64..1000000).skip_while(|&x| x < 1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_chain_sum,\n+    bench_skip_while_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip_while(|&x| x < 1000)\n+}\n+\n+bench_sums! {\n+    bench_take_while_chain_sum,\n+    bench_take_while_chain_ref_sum,\n+    (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n }"}, {"sha": "201064e823b1e6ecee851126f444c408fed73063", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -20,6 +20,6 @@ extern crate test;\n mod any;\n mod hash;\n mod iter;\n-mod mem;\n mod num;\n mod ops;\n+mod slice;"}, {"sha": "b2fc74544f1df22abc7c84a4842be1c202a4aac1", "filename": "src/libcore/benches/slice.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fslice.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::black_box;\n+use test::Bencher;\n+\n+enum Cache {\n+    L1,\n+    L2,\n+    L3,\n+}\n+\n+fn binary_search<F>(b: &mut Bencher, cache: Cache, mapper: F)\n+    where F: Fn(usize) -> usize\n+{\n+    let size = match cache {\n+        Cache::L1 => 1000, // 8kb\n+        Cache::L2 => 10_000, // 80kb\n+        Cache::L3 => 1_000_000, // 8Mb\n+    };\n+    let v = (0..size).map(&mapper).collect::<Vec<_>>();\n+    let mut r = 0usize;\n+    b.iter(move || {\n+        // LCG constants from https://en.wikipedia.org/wiki/Numerical_Recipes.\n+        r = r.wrapping_mul(1664525).wrapping_add(1013904223);\n+        // Lookup the whole range to get 50% hits and 50% misses.\n+        let i = mapper(r % size);\n+        black_box(v.binary_search(&i).is_ok());\n+    })\n+}\n+\n+#[bench]\n+fn binary_search_l1(b: &mut Bencher) {\n+    binary_search(b, Cache::L1, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l2(b: &mut Bencher) {\n+    binary_search(b, Cache::L2, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l3(b: &mut Bencher) {\n+    binary_search(b, Cache::L3, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l1_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L1, |i| i / 16 * 16);\n+}\n+\n+#[bench]\n+fn binary_search_l2_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L2, |i| i / 16 * 16);\n+}\n+\n+#[bench]\n+fn binary_search_l3_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L3, |i| i / 16 * 16);\n+}"}, {"sha": "d4cd3f6264efc9020318e4ef1b102ef6b62b82e5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -329,7 +329,6 @@ impl<T> Cell<T> {\n     /// let c = Cell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_cell_new\"))]\n     #[inline]\n     pub const fn new(value: T) -> Cell<T> {\n         Cell {\n@@ -544,7 +543,6 @@ impl<T> RefCell<T> {\n     /// let c = RefCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_refcell_new\"))]\n     #[inline]\n     pub const fn new(value: T) -> RefCell<T> {\n         RefCell {\n@@ -579,32 +577,62 @@ impl<T> RefCell<T> {\n     ///\n     /// This function corresponds to [`std::mem::replace`](../mem/fn.replace.html).\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(refcell_replace_swap)]\n     /// use std::cell::RefCell;\n-    /// let c = RefCell::new(5);\n-    /// let u = c.replace(6);\n-    /// assert_eq!(u, 5);\n-    /// assert_eq!(c, RefCell::new(6));\n+    /// let cell = RefCell::new(5);\n+    /// let old_value = cell.replace(6);\n+    /// assert_eq!(old_value, 5);\n+    /// assert_eq!(cell, RefCell::new(6));\n     /// ```\n+    #[inline]\n+    #[unstable(feature = \"refcell_replace_swap\", issue=\"43570\")]\n+    pub fn replace(&self, t: T) -> T {\n+        mem::replace(&mut *self.borrow_mut(), t)\n+    }\n+\n+    /// Replaces the wrapped value with a new one computed from `f`, returning\n+    /// the old value, without deinitializing either one.\n+    ///\n+    /// This function corresponds to [`std::mem::replace`](../mem/fn.replace.html).\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if the `RefCell` has any outstanding borrows,\n-    /// whether or not they are full mutable borrows.\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(refcell_replace_swap)]\n+    /// use std::cell::RefCell;\n+    /// let cell = RefCell::new(5);\n+    /// let old_value = cell.replace_with(|&mut old| old + 1);\n+    /// assert_eq!(old_value, 5);\n+    /// assert_eq!(cell, RefCell::new(6));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"refcell_replace_swap\", issue=\"43570\")]\n-    pub fn replace(&self, t: T) -> T {\n-        mem::replace(&mut *self.borrow_mut(), t)\n+    pub fn replace_with<F: FnOnce(&mut T) -> T>(&self, f: F) -> T {\n+        let mut_borrow = &mut *self.borrow_mut();\n+        let replacement = f(mut_borrow);\n+        mem::replace(mut_borrow, replacement)\n     }\n \n     /// Swaps the wrapped value of `self` with the wrapped value of `other`,\n     /// without deinitializing either one.\n     ///\n     /// This function corresponds to [`std::mem::swap`](../mem/fn.swap.html).\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -616,11 +644,6 @@ impl<T> RefCell<T> {\n     /// assert_eq!(c, RefCell::new(6));\n     /// assert_eq!(d, RefCell::new(5));\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if either `RefCell` has any outstanding borrows,\n-    /// whether or not they are full mutable borrows.\n     #[inline]\n     #[unstable(feature = \"refcell_replace_swap\", issue=\"43570\")]\n     pub fn swap(&self, other: &Self) {\n@@ -1190,7 +1213,6 @@ impl<T> UnsafeCell<T> {\n     /// let uc = UnsafeCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_unsafe_cell_new\"))]\n     #[inline]\n     pub const fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }"}, {"sha": "e6803745ab543292a51484f8355648ee646d7b76", "filename": "src/libcore/char_private.rs", "status": "modified", "additions": 83, "deletions": 74, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fchar_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fchar_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar_private.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -47,7 +47,7 @@ fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n     current\n }\n \n-pub fn is_printable(x: char) -> bool {\n+pub(crate) fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {\n@@ -64,7 +64,10 @@ pub fn is_printable(x: char) -> bool {\n         if 0x2b81e <= x && x < 0x2b820 {\n             return false;\n         }\n-        if 0x2cea2 <= x && x < 0x2f800 {\n+        if 0x2cea2 <= x && x < 0x2ceb0 {\n+            return false;\n+        }\n+        if 0x2ebe1 <= x && x < 0x2f800 {\n             return false;\n         }\n         if 0x2fa1e <= x && x < 0xe0100 {\n@@ -83,12 +86,12 @@ const SINGLETONS0U: &'static [(u8, u8)] = &[\n     (0x05, 8),\n     (0x06, 3),\n     (0x07, 4),\n-    (0x08, 7),\n+    (0x08, 8),\n     (0x09, 16),\n     (0x0a, 27),\n-    (0x0b, 24),\n+    (0x0b, 25),\n     (0x0c, 22),\n-    (0x0d, 20),\n+    (0x0d, 18),\n     (0x0e, 22),\n     (0x0f, 4),\n     (0x10, 3),\n@@ -99,16 +102,15 @@ const SINGLETONS0U: &'static [(u8, u8)] = &[\n     (0x18, 2),\n     (0x19, 3),\n     (0x1a, 7),\n-    (0x1c, 1),\n+    (0x1d, 1),\n     (0x1f, 22),\n     (0x20, 3),\n-    (0x23, 1),\n     (0x2b, 5),\n     (0x2c, 2),\n     (0x2d, 11),\n     (0x2e, 1),\n     (0x30, 3),\n-    (0x31, 1),\n+    (0x31, 3),\n     (0x32, 2),\n     (0xa7, 1),\n     (0xa8, 2),\n@@ -125,19 +127,19 @@ const SINGLETONS0L: &'static [u8] = &[\n     0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n     0x58, 0x60, 0x88, 0x8b, 0x8c, 0x90, 0x1c, 0x1d,\n     0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0x2e, 0x2f, 0x3f,\n-    0x5c, 0x5d, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91,\n-    0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6, 0xc9,\n-    0xca, 0xde, 0xe4, 0xe5, 0x04, 0x11, 0x12, 0x29,\n-    0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a,\n-    0x5d, 0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba,\n-    0xbb, 0xc6, 0xca, 0xce, 0xcf, 0xe4, 0xe5, 0x04,\n-    0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,\n-    0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65,\n-    0x84, 0x91, 0x9b, 0x9d, 0xc9, 0xce, 0xcf, 0x04,\n-    0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65,\n-    0x84, 0x8d, 0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5,\n-    0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04, 0x0d, 0x11,\n-    0x3b, 0x3c, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n+    0x5c, 0x5d, 0x5f, 0xb5, 0xe2, 0x84, 0x8d, 0x8e,\n+    0x91, 0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6,\n+    0xc9, 0xca, 0xde, 0xe4, 0xe5, 0x04, 0x11, 0x12,\n+    0x29, 0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49,\n+    0x4a, 0x5d, 0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4,\n+    0xba, 0xbb, 0xc6, 0xca, 0xce, 0xcf, 0xe4, 0xe5,\n+    0x00, 0x04, 0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31,\n+    0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e,\n+    0x64, 0x65, 0x84, 0x91, 0x9b, 0x9d, 0xc9, 0xce,\n+    0xcf, 0x04, 0x0d, 0x11, 0x29, 0x45, 0x49, 0x57,\n+    0x64, 0x65, 0x84, 0x8d, 0x91, 0xa9, 0xb4, 0xba,\n+    0xbb, 0xc5, 0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04,\n+    0x0d, 0x11, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n     0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5, 0xd7, 0xf0,\n     0xf1, 0x83, 0x85, 0x86, 0x89, 0x8b, 0x8c, 0x98,\n     0xa0, 0xa4, 0xa6, 0xa8, 0xa9, 0xac, 0xba, 0xbe,\n@@ -148,18 +150,18 @@ const SINGLETONS0L: &'static [u8] = &[\n     0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7, 0xfe,\n     0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e,\n     0x0f, 0x1f, 0x6e, 0x6f, 0x1c, 0x1d, 0x5f, 0x7d,\n-    0x7e, 0xae, 0xaf, 0xf7, 0x16, 0x17, 0x1e, 0x1f,\n+    0x7e, 0xae, 0xaf, 0xfa, 0x16, 0x17, 0x1e, 0x1f,\n     0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e,\n     0x7e, 0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0,\n-    0xf1, 0xf5, 0x72, 0x73, 0x8f, 0xff, 0x74, 0x75,\n-    0x96, 0x97, 0xc9, 0x2f, 0x5f, 0x26, 0x2e, 0x2f,\n-    0xa7, 0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf,\n-    0x9a, 0x40, 0x97, 0x98, 0x8f, 0x1f, 0xff, 0xaf,\n-    0xfe, 0xff, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b,\n-    0x07, 0x08, 0x0f, 0x10, 0x27, 0x2f, 0xee, 0xef,\n-    0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90,\n-    0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n-    0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n+    0xf1, 0xf5, 0x72, 0x73, 0x8f, 0x74, 0x75, 0x96,\n+    0x97, 0xc9, 0x2f, 0x5f, 0x26, 0x2e, 0x2f, 0xa7,\n+    0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf, 0x9a,\n+    0x40, 0x97, 0x98, 0x2f, 0x30, 0x8f, 0x1f, 0xff,\n+    0xaf, 0xfe, 0xff, 0xce, 0xff, 0x4e, 0x4f, 0x5a,\n+    0x5b, 0x07, 0x08, 0x0f, 0x10, 0x27, 0x2f, 0xee,\n+    0xef, 0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45,\n+    0x90, 0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8,\n+    0xc9, 0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n const SINGLETONS1U: &'static [(u8, u8)] = &[\n     (0x00, 6),\n@@ -176,7 +178,9 @@ const SINGLETONS1U: &'static [(u8, u8)] = &[\n     (0x13, 18),\n     (0x14, 2),\n     (0x15, 2),\n+    (0x1a, 3),\n     (0x1c, 5),\n+    (0x1d, 4),\n     (0x24, 1),\n     (0x6a, 3),\n     (0x6b, 2),\n@@ -192,7 +196,7 @@ const SINGLETONS1U: &'static [(u8, u8)] = &[\n     (0xee, 32),\n     (0xf0, 4),\n     (0xf1, 1),\n-    (0xf9, 4),\n+    (0xf9, 1),\n ];\n const SINGLETONS1L: &'static [u8] = &[\n     0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n@@ -202,18 +206,18 @@ const SINGLETONS1L: &'static [u8] = &[\n     0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12,\n     0x29, 0x31, 0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49,\n     0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5a, 0x5c, 0xb6,\n-    0xb7, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x6f, 0x5f,\n-    0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28,\n-    0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8,\n-    0xad, 0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15,\n-    0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc,\n-    0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0xc5,\n-    0xc6, 0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33,\n-    0x38, 0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53, 0x55,\n-    0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65,\n-    0x66, 0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4,\n-    0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x2f, 0x1f, 0x31,\n-    0x32, 0x3f,\n+    0xb7, 0x84, 0x85, 0x9d, 0x09, 0x37, 0x90, 0x91,\n+    0xa8, 0x07, 0x0a, 0x3b, 0x3e, 0x6f, 0x5f, 0xee,\n+    0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28, 0x55,\n+    0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8, 0xad,\n+    0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15, 0x1d,\n+    0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc, 0xcd,\n+    0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0xc5, 0xc6,\n+    0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33, 0x38,\n+    0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53, 0x55, 0x56,\n+    0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65, 0x66,\n+    0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4, 0xaa,\n+    0xaf, 0xb0, 0xc0, 0xd0, 0x2f, 0x3f,\n ];\n const NORMAL0: &'static [u8] = &[\n     0x00, 0x20,\n@@ -224,12 +228,12 @@ const NORMAL0: &'static [u8] = &[\n     0x05, 0x11,\n     0x81, 0xac, 0x0e,\n     0x3b, 0x05,\n-    0x5f, 0x41,\n+    0x6b, 0x35,\n     0x1e, 0x16,\n     0x80, 0xdf, 0x03,\n     0x19, 0x08,\n     0x01, 0x04,\n-    0x20, 0x05,\n+    0x22, 0x03,\n     0x0a, 0x04,\n     0x34, 0x04,\n     0x07, 0x03,\n@@ -238,8 +242,7 @@ const NORMAL0: &'static [u8] = &[\n     0x10, 0x0b,\n     0x50, 0x0f,\n     0x12, 0x07,\n-    0x01, 0x07,\n-    0x4d, 0x08,\n+    0x55, 0x08,\n     0x02, 0x04,\n     0x1c, 0x0a,\n     0x09, 0x03,\n@@ -258,8 +261,8 @@ const NORMAL0: &'static [u8] = &[\n     0x10, 0x08,\n     0x56, 0x07,\n     0x02, 0x07,\n-    0x15, 0x0e,\n-    0x4f, 0x04,\n+    0x15, 0x0d,\n+    0x50, 0x04,\n     0x43, 0x03,\n     0x2d, 0x03,\n     0x01, 0x04,\n@@ -304,34 +307,32 @@ const NORMAL0: &'static [u8] = &[\n     0x3c, 0x37,\n     0x08, 0x08,\n     0x2a, 0x06,\n-    0x80, 0xf6, 0x05,\n-    0x82, 0x04, 0x11,\n+    0x82, 0xff, 0x11,\n     0x18, 0x08,\n     0x2f, 0x11,\n     0x2d, 0x03,\n-    0x1f, 0x11,\n+    0x20, 0x10,\n     0x21, 0x0f,\n     0x80, 0x8c, 0x04,\n     0x82, 0x97, 0x19,\n     0x0b, 0x15,\n     0x87, 0x5a, 0x03,\n-    0x15, 0x1a,\n+    0x16, 0x19,\n     0x04, 0x10,\n     0x80, 0xf4, 0x05,\n     0x2f, 0x05,\n     0x3b, 0x07,\n     0x02, 0x0e,\n     0x18, 0x09,\n-    0x80, 0xa5, 0x3b,\n+    0x80, 0xaa, 0x36,\n     0x74, 0x0c,\n     0x80, 0xd6, 0x1a,\n     0x0c, 0x05,\n     0x80, 0xff, 0x05,\n-    0x29, 0x03,\n-    0x80, 0x8a, 0x05,\n+    0x80, 0xb6, 0x05,\n     0x24, 0x0c,\n     0x9b, 0xc6, 0x0a,\n-    0xd2, 0x16, 0x2a,\n+    0xd2, 0x2b, 0x15,\n     0x84, 0x8d, 0x03,\n     0x37, 0x09,\n     0x81, 0x5c, 0x14,\n@@ -378,8 +379,8 @@ const NORMAL1: &'static [u8] = &[\n     0x1d, 0x03,\n     0x31, 0x0f,\n     0x1c, 0x04,\n-    0x24, 0x0c,\n-    0x1b, 0x05,\n+    0x24, 0x09,\n+    0x1e, 0x05,\n     0x2b, 0x05,\n     0x44, 0x04,\n     0x0e, 0x2a,\n@@ -447,11 +448,16 @@ const NORMAL1: &'static [u8] = &[\n     0x0f, 0x04,\n     0x10, 0x81, 0x60,\n     0x53, 0x0c,\n-    0x01, 0x81, 0xc0,\n+    0x01, 0x81, 0x00,\n+    0x48, 0x08,\n+    0x53, 0x1d,\n     0x39, 0x81, 0x07,\n     0x46, 0x0a,\n     0x1d, 0x03,\n-    0x47, 0x83, 0x49,\n+    0x47, 0x49,\n+    0x37, 0x03,\n+    0x0e, 0x08,\n+    0x0a, 0x82, 0xa6,\n     0x83, 0x9a, 0x66,\n     0x75, 0x0b,\n     0x80, 0xc4, 0x8a, 0xbc,\n@@ -467,10 +473,11 @@ const NORMAL1: &'static [u8] = &[\n     0x45, 0x0b,\n     0x2f, 0x10,\n     0x11, 0x40,\n-    0x01, 0x1f,\n+    0x02, 0x1e,\n     0x97, 0xed, 0x13,\n     0x82, 0xf3, 0xa5, 0x0d,\n-    0x02, 0x8b, 0xfe,\n+    0x81, 0x1f, 0x51,\n+    0x81, 0x8c, 0x89, 0x04,\n     0x6b, 0x05,\n     0x0d, 0x03,\n     0x09, 0x07,\n@@ -503,20 +510,22 @@ const NORMAL1: &'static [u8] = &[\n     0x1d, 0x0d,\n     0x2c, 0x04,\n     0x09, 0x07,\n-    0x02, 0x80, 0xae,\n-    0x83, 0xd3, 0x0d,\n+    0x02, 0x0e,\n+    0x06, 0x80, 0x9a,\n+    0x83, 0xd5, 0x0b,\n     0x0d, 0x03,\n-    0x07, 0x09,\n+    0x09, 0x07,\n     0x74, 0x0c,\n     0x55, 0x2b,\n     0x0c, 0x04,\n     0x38, 0x08,\n     0x0a, 0x06,\n     0x28, 0x08,\n-    0x1e, 0x62,\n-    0x18, 0x08,\n-    0x1c, 0x04,\n-    0x0f, 0x21,\n-    0x12, 0x2e,\n-    0x01, 0x86, 0x3f,\n+    0x1e, 0x52,\n+    0x0c, 0x04,\n+    0x3d, 0x03,\n+    0x1c, 0x14,\n+    0x18, 0x28,\n+    0x01, 0x0f,\n+    0x17, 0x86, 0x19,\n ];"}, {"sha": "cc71e09caeacc3e4b94274e9b9f86995e6a7ece7", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -162,8 +162,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n-    // FIXME #13101: this method is used solely by #[deriving] to\n-    // assert that every component of a type implements #[deriving]\n+    // this method is used solely by #[deriving] to assert\n+    // that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n     // assertion without using a method on this trait is nearly\n     // impossible.\n@@ -456,7 +456,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(2, 1.max(2));\n     /// assert_eq!(2, 2.max(2));\n     /// ```\n-    #[stable(feature = \"ord_max_min\", since = \"1.22.0\")]\n+    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     fn max(self, other: Self) -> Self\n     where Self: Sized {\n         if other >= self { other } else { self }\n@@ -472,7 +472,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(1, 1.min(2));\n     /// assert_eq!(2, 2.min(2));\n     /// ```\n-    #[stable(feature = \"ord_max_min\", since = \"1.22.0\")]\n+    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     fn min(self, other: Self) -> Self\n     where Self: Sized {\n         if self <= other { self } else { other }"}, {"sha": "e815d72d366466e79d3b3507c36585afeca5cb28", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -48,8 +48,25 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use str::FromStr;\n+use fmt;\n \n+/// A type used as the error type for implementations of fallible conversion\n+/// traits in cases where conversions cannot actually fail.\n+///\n+/// Because `Infallible` has no variants, a value of this type can never exist.\n+/// It is used only to satisfy trait signatures that expect an error type, and\n+/// signals to both the compiler and the user that the error case is impossible.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub enum Infallible {}\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl fmt::Display for Infallible {\n+    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+        }\n+    }\n+}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -417,6 +434,17 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n     }\n }\n \n+// Infallible conversions are semantically equivalent to fallible conversions\n+// with an uninhabited error type.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl<T, U> TryFrom<U> for T where T: From<U> {\n+    type Error = Infallible;\n+\n+    fn try_from(value: U) -> Result<Self, Self::Error> {\n+        Ok(T::from(value))\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n@@ -442,14 +470,3 @@ impl AsRef<str> for str {\n         self\n     }\n }\n-\n-// FromStr implies TryFrom<&str>\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl<'a, T> TryFrom<&'a str> for T where T: FromStr\n-{\n-    type Error = <T as FromStr>::Err;\n-\n-    fn try_from(s: &'a str) -> Result<T, Self::Error> {\n-        FromStr::from_str(s)\n-    }\n-}"}, {"sha": "60b9eeb1283cdd3223cf9c568a93289541b8f731", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fmt::{self, FlagV1};\n+use fmt;\n \n struct PadAdapter<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n@@ -140,7 +140,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -233,7 +233,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -277,7 +277,7 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -519,6 +519,6 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }"}, {"sha": "551aa929ce457d44f195e8215da80820a6dddbdd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -261,6 +261,14 @@ pub struct Formatter<'a> {\n \n struct Void {\n     _priv: (),\n+    /// Erases all oibits, because `Void` erases the type of the object that\n+    /// will be used to produce formatted output. Since we do not know what\n+    /// oibits the real types have (and they can have any or none), we need to\n+    /// take the most conservative approach and forbid all oibits.\n+    ///\n+    /// It was added after #45197 showed that one could share a `!Sync`\n+    /// object across threads by passing it into `format_args!`.\n+    _oibit_remover: PhantomData<*mut Fn()>,\n }\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n@@ -322,7 +330,6 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-#[allow(dead_code)] // SignMinus isn't currently used\n enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n \n impl<'a> Arguments<'a> {\n@@ -427,7 +434,7 @@ impl<'a> Display for Arguments<'a> {\n     }\n }\n \n-/// Format trait for the `?` character.\n+/// `?` formatting.\n ///\n /// `Debug` should format the output in a programmer-facing, debugging context.\n ///\n@@ -488,13 +495,14 @@ impl<'a> Display for Arguments<'a> {\n /// The origin is: Point { x: 0, y: 0 }\n /// ```\n ///\n-/// There are a number of `debug_*` methods on `Formatter` to help you with manual\n+/// There are a number of `debug_*` methods on [`Formatter`] to help you with manual\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on `Formatter` support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n+/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n /// Pretty printing with `#?`:\n ///\n@@ -525,6 +533,26 @@ impl<'a> Display for Arguments<'a> {\n #[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Position {\n+    ///     longitude: f32,\n+    ///     latitude: f32,\n+    /// }\n+    ///\n+    /// impl fmt::Debug for Position {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"({:?}, {:?})\", self.longitude, self.latitude)\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\"(1.987, 2.983)\".to_owned(),\n+    ///            format!(\"{:?}\", Position { longitude: 1.987, latitude: 2.983, }));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n@@ -592,10 +620,13 @@ pub trait Display {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `o` character.\n+/// `o` formatting.\n ///\n /// The `Octal` trait should format its output as a number in base-8.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0o` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -611,6 +642,8 @@ pub trait Display {\n ///\n /// assert_eq!(format!(\"{:o}\", x), \"52\");\n /// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n+///\n+/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n /// ```\n ///\n /// Implementing `Octal` on a type:\n@@ -639,10 +672,13 @@ pub trait Octal {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `b` character.\n+/// `b` formatting.\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0b` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -658,6 +694,8 @@ pub trait Octal {\n ///\n /// assert_eq!(format!(\"{:b}\", x), \"101010\");\n /// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n+///\n+/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n /// ```\n ///\n /// Implementing `Binary` on a type:\n@@ -686,11 +724,14 @@ pub trait Binary {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `x` character.\n+/// `x` formatting.\n ///\n /// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n /// in lower case.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -706,6 +747,8 @@ pub trait Binary {\n ///\n /// assert_eq!(format!(\"{:x}\", x), \"2a\");\n /// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n+///\n+/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n /// ```\n ///\n /// Implementing `LowerHex` on a type:\n@@ -734,11 +777,14 @@ pub trait LowerHex {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `X` character.\n+/// `X` formatting.\n ///\n /// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n /// in upper case.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -754,6 +800,8 @@ pub trait LowerHex {\n ///\n /// assert_eq!(format!(\"{:X}\", x), \"2A\");\n /// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n+///\n+/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n /// ```\n ///\n /// Implementing `UpperHex` on a type:\n@@ -782,7 +830,7 @@ pub trait UpperHex {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `p` character.\n+/// `p` formatting.\n ///\n /// The `Pointer` trait should format its output as a memory location. This is commonly presented\n /// as hexadecimal.\n@@ -827,7 +875,7 @@ pub trait Pointer {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `e` character.\n+/// `e` formatting.\n ///\n /// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n ///\n@@ -870,7 +918,7 @@ pub trait LowerExp {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `E` character.\n+/// `E` formatting.\n ///\n /// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n ///\n@@ -932,7 +980,7 @@ pub trait UpperExp {\n /// assert_eq!(output, \"Hello world!\");\n /// ```\n ///\n-/// Please note that using [`write!`] might be preferrable. Example:\n+/// Please note that using [`write!`] might be preferable. Example:\n ///\n /// ```\n /// use std::fmt::Write;\n@@ -1275,8 +1323,11 @@ impl<'a> Formatter<'a> {\n         write(self.buf, fmt)\n     }\n \n-    /// Flags for formatting (packed version of rt::Flag)\n+    /// Flags for formatting\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.24.0\",\n+                       reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n+                                 or `sign_aware_zero_pad` methods instead\")]\n     pub fn flags(&self) -> u32 { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n@@ -1321,8 +1372,11 @@ impl<'a> Formatter<'a> {\n         self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n     }\n \n-    /// Creates a `DebugStruct` builder designed to assist with creation of\n-    /// `fmt::Debug` implementations for structs.\n+    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n+    /// [`fmt::Debug`] implementations for structs.\n+    ///\n+    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n+    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "ee989854a3772e29362d6dc94250bb18b94a7b73", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12,7 +12,6 @@\n \n #![allow(deprecated)]\n \n-// FIXME: #6220 Implement floating point formatting\n \n use fmt;\n use ops::{Div, Rem, Sub};\n@@ -135,7 +134,7 @@ macro_rules! radix {\n     }\n }\n \n-radix! { Binary,    2, \"0b\", x @  0 ...  2 => b'0' + x }\n+radix! { Binary,    2, \"0b\", x @  0 ...  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\n radix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\n radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,"}, {"sha": "15545a04b64de04e7b37e8115ad8d6b491a92cd4", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -259,7 +259,7 @@ pub trait Hasher {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     ///\n-    /// ['write']: #tymethod.write\n+    /// [`write`]: #tymethod.write\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n@@ -665,16 +665,36 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T> Hash for *const T {\n+    impl<T: ?Sized> Hash for *const T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_usize(*self as usize)\n+            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                // Thin pointer\n+                state.write_usize(*self as *const () as usize);\n+            } else {\n+                // Fat pointer\n+                let (a, b) = unsafe {\n+                    *(self as *const Self as *const (usize, usize))\n+                };\n+                state.write_usize(a);\n+                state.write_usize(b);\n+            }\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T> Hash for *mut T {\n+    impl<T: ?Sized> Hash for *mut T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_usize(*self as usize)\n+            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                // Thin pointer\n+                state.write_usize(*self as *const () as usize);\n+            } else {\n+                // Fat pointer\n+                let (a, b) = unsafe {\n+                    *(self as *const Self as *const (usize, usize))\n+                };\n+                state.write_usize(a);\n+                state.write_usize(b);\n+            }\n         }\n     }\n }"}, {"sha": "4e4d9b3f1e2f0585cfc9c3be3c366bb973268f27", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -22,7 +22,7 @@ use mem;\n /// This is currently the default hashing function used by standard library\n /// (eg. `collections::HashMap` uses it by default).\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash>\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n@@ -33,7 +33,7 @@ pub struct SipHasher13 {\n \n /// An implementation of SipHash 2-4.\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash/>\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n@@ -44,7 +44,7 @@ pub struct SipHasher24 {\n \n /// An implementation of SipHash 2-4.\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash/>\n ///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n@@ -72,6 +72,7 @@ struct Hasher<S: Sip> {\n }\n \n #[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n struct State {\n     // v0, v2 and v1, v3 show up in pairs in the algorithm,\n     // and simd implementations of SipHash will use vectors"}, {"sha": "cb215a38e5356247808236b1286732338a53ebc9", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -68,3 +68,22 @@ macro_rules! forward_ref_binop {\n         }\n     }\n }\n+\n+// implements \"T op= &U\", based on \"T op= U\"\n+// where U is expected to be `Copy`able\n+macro_rules! forward_ref_op_assign {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_op_assign!(impl $imp, $method for $t, $u,\n+                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n+    };\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n+        #[$attr]\n+        impl<'a> $imp<&'a $u> for $t {\n+            #[inline]\n+            fn $method(&mut self, other: &'a $u) {\n+                $imp::$method(self, *other);\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "f1e51e995c238a9e6d57c4d3e3736880f71b9226", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -627,6 +627,9 @@ extern \"rust-intrinsic\" {\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::process::abort`](../../std/process/fn.abort.html)\n     pub fn abort() -> !;\n \n     /// Tells LLVM that this point in the code is not reachable, enabling\n@@ -676,6 +679,10 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n+    /// The size of the referenced value in bytes.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n@@ -921,6 +928,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then may return `true` or `false`.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html).\n     pub fn needs_drop<T>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1376,17 +1386,10 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// # } }\n     /// ```\n-    #[cfg(not(stage0))]\n     pub fn align_offset(ptr: *const (), align: usize) -> usize;\n-}\n \n-#[cfg(stage0)]\n-/// remove me after the next release\n-pub unsafe fn align_offset(ptr: *const (), align: usize) -> usize {\n-    let offset = ptr as usize % align;\n-    if offset == 0 {\n-        0\n-    } else {\n-        align - offset\n-    }\n+    /// Emits a `!nontemporal` store according to LLVM (see their docs).\n+    /// Probably will never become stable.\n+    #[cfg(not(stage0))]\n+    pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }"}, {"sha": "7f6d627536da35c693c49a5ce692fb3ea4547a29", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 228, "deletions": 123, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use cmp::Ordering;\n+use ops::Try;\n \n+use super::{AlwaysOk, LoopState};\n use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n@@ -28,6 +30,7 @@ fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                             `.iter()` or a similar method\"]\n+#[doc(spotlight)]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -518,7 +521,7 @@ pub trait Iterator {\n     ///       .for_each(|(i, x)| println!(\"{}:{}\", i, x));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"iterator_for_each\", since = \"1.22.0\")]\n+    #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n     fn for_each<F>(self, mut f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n@@ -1337,6 +1340,78 @@ pub trait Iterator {\n         (left, right)\n     }\n \n+    /// An iterator method that applies a function as long as it returns\n+    /// successfully, producing a single, final value.\n+    ///\n+    /// `try_fold()` takes two arguments: an initial value, and a closure with\n+    /// two arguments: an 'accumulator', and an element. The closure either\n+    /// returns successfully, with the value that the accumulator should have\n+    /// for the next iteration, or it returns failure, with an error value that\n+    /// is propagated back to the caller immediately (short-circuiting).\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.  If applying the closure succeeded against every element of the\n+    /// iterator, `try_fold()` returns the final accumulator as success.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// # Note to Implementors\n+    ///\n+    /// Most of the other (forward) methods have default implementations in\n+    /// terms of this one, so try to implement this explicitly if it can\n+    /// do something better than the default `for` loop implementation.\n+    ///\n+    /// In particular, try to have this call `try_fold()` on the internal parts\n+    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// the `?` operator be convenient for chaining the accumulator value along,\n+    /// but beware any invariants that need to be upheld before those early\n+    /// returns.  This is a `&mut self` method, so iteration needs to be\n+    /// resumable after hitting an error here.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the checked sum of all of the elements of the array\n+    /// let sum = a.iter()\n+    ///            .try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    ///\n+    /// assert_eq!(sum, Some(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [10, 20, 30, 100, 40, 50];\n+    /// let mut it = a.iter();\n+    ///\n+    /// // This sum overflows when adding the 100 element\n+    /// let sum = it.try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    /// assert_eq!(sum, None);\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.len(), 2);\n+    /// assert_eq!(it.next(), Some(&40));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     /// An iterator method that applies a function, producing a single, final value.\n     ///\n     /// `fold()` takes two arguments: an initial value, and a closure with two\n@@ -1361,7 +1436,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// // the sum of all of the elements of a\n+    /// // the sum of all of the elements of the array\n     /// let sum = a.iter()\n     ///            .fold(0, |acc, &x| acc + x);\n     ///\n@@ -1403,14 +1478,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        let mut accum = init;\n-        for x in self {\n-            accum = f(accum, x);\n-        }\n-        accum\n+        self.try_fold(init, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1455,12 +1526,10 @@ pub trait Iterator {\n     fn all<F>(&mut self, mut f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        for x in self {\n-            if !f(x) {\n-                return false;\n-            }\n-        }\n-        true\n+        self.try_fold((), move |(), x| {\n+            if f(x) { LoopState::Continue(()) }\n+            else { LoopState::Break(()) }\n+        }) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1506,12 +1575,10 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        for x in self {\n-            if f(x) {\n-                return true;\n-            }\n-        }\n-        false\n+        self.try_fold((), move |(), x| {\n+            if f(x) { LoopState::Break(()) }\n+            else { LoopState::Continue(()) }\n+        }) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1562,10 +1629,10 @@ pub trait Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        for x in self {\n-            if predicate(&x) { return Some(x) }\n-        }\n-        None\n+        self.try_fold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -1623,18 +1690,17 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        // `enumerate` might overflow.\n-        for (i, x) in self.enumerate() {\n-            if predicate(x) {\n-                return Some(i);\n-            }\n-        }\n-        None\n+        // The addition might panic on overflow\n+        self.try_fold(0, move |i, x| {\n+            if predicate(x) { LoopState::Break(i) }\n+            else { LoopState::Continue(i + 1) }\n+        }).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -1681,17 +1747,14 @@ pub trait Iterator {\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n-        let mut i = self.len();\n-\n-        while let Some(v) = self.next_back() {\n-            // No need for an overflow check here, because `ExactSizeIterator`\n-            // implies that the number of elements fits into a `usize`.\n-            i -= 1;\n-            if predicate(v) {\n-                return Some(i);\n-            }\n-        }\n-        None\n+        // No need for an overflow check here, because `ExactSizeIterator`\n+        // implies that the number of elements fits into a `usize`.\n+        let n = self.len();\n+        self.try_rfold(n, move |i, x| {\n+            let i = i - 1;\n+            if predicate(x) { LoopState::Break(i) }\n+            else { LoopState::Continue(i) }\n+        }).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -1922,10 +1985,10 @@ pub trait Iterator {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        for (t, u) in self {\n+        self.for_each(|(t, u)| {\n             ts.extend(Some(t));\n             us.extend(Some(u));\n-        }\n+        });\n \n         (ts, us)\n     }\n@@ -2059,14 +2122,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Ordering::Equal,\n-                (None, _   ) => return Ordering::Less,\n-                (_   , None) => return Ordering::Greater,\n-                (Some(x), Some(y)) => match x.cmp(&y) {\n-                    Ordering::Equal => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Ordering::Equal\n+                } else {\n+                    return Ordering::Less\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Ordering::Greater,\n+                Some(val) => val,\n+            };\n+\n+            match x.cmp(&y) {\n+                Ordering::Equal => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2082,14 +2154,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Some(Ordering::Equal),\n-                (None, _   ) => return Some(Ordering::Less),\n-                (_   , None) => return Some(Ordering::Greater),\n-                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n-                    Some(Ordering::Equal) => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Some(Ordering::Equal)\n+                } else {\n+                    return Some(Ordering::Less)\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Some(Ordering::Greater),\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Equal) => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2105,11 +2186,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _) | (_, None) => return false,\n-                (Some(x), Some(y)) => if x != y { return false },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return false }\n         }\n     }\n \n@@ -2124,11 +2211,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _) | (_, None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return true },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return true }\n         }\n     }\n \n@@ -2143,18 +2236,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2170,18 +2266,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => { other.next(); return true; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2197,18 +2296,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                }\n+            let x = match self.next() {\n+                None => { other.next(); return false; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }\n@@ -2224,18 +2326,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }\n@@ -2258,17 +2363,17 @@ fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|mut sel| {\n-        let mut sel_p = f_proj(&sel);\n+    it.next().map(|first| {\n+        let first_p = f_proj(&first);\n \n-        for x in it {\n+        it.fold((first_p, first), |(sel_p, sel), x| {\n             let x_p = f_proj(&x);\n             if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                sel = x;\n-                sel_p = x_p;\n+                (x_p, x)\n+            } else {\n+                (sel_p, sel)\n             }\n-        }\n-        (sel_p, sel)\n+        })\n     })\n }\n "}, {"sha": "e173f43b5e6eaf176e77ce162d8a555f15cb3d98", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 617, "deletions": 7, "changes": 624, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -305,6 +305,7 @@\n use cmp;\n use fmt;\n use iter_private::TrustedRandomAccess;\n+use ops::Try;\n use usize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -336,6 +337,71 @@ mod range;\n mod sources;\n mod traits;\n \n+/// Transparent newtype used to implement foo methods in terms of try_foo.\n+/// Important until #43278 is fixed; might be better as `Result<T, !>` later.\n+struct AlwaysOk<T>(pub T);\n+\n+impl<T> Try for AlwaysOk<T> {\n+    type Ok = T;\n+    type Error = !;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> { Ok(self.0) }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self { v }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self { AlwaysOk(v) }\n+}\n+\n+/// Used to make try_fold closures more like normal loops\n+#[derive(PartialEq)]\n+enum LoopState<C, B> {\n+    Continue(C),\n+    Break(B),\n+}\n+\n+impl<C, B> Try for LoopState<C, B> {\n+    type Ok = C;\n+    type Error = B;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        match self {\n+            LoopState::Continue(y) => Ok(y),\n+            LoopState::Break(x) => Err(x),\n+        }\n+    }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self { LoopState::Break(v) }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self { LoopState::Continue(v) }\n+}\n+\n+impl<C, B> LoopState<C, B> {\n+    #[inline]\n+    fn break_value(self) -> Option<B> {\n+        match self {\n+            LoopState::Continue(..) => None,\n+            LoopState::Break(x) => Some(x),\n+        }\n+    }\n+}\n+\n+impl<R: Try> LoopState<R::Ok, R> {\n+    #[inline]\n+    fn from_try(r: R) -> Self {\n+        match Try::into_result(r) {\n+            Ok(v) => LoopState::Continue(v),\n+            Err(v) => LoopState::Break(Try::from_error(v)),\n+        }\n+    }\n+    #[inline]\n+    fn into_try(self) -> R {\n+        match self {\n+            LoopState::Continue(v) => Try::from_ok(v),\n+            LoopState::Break(v) => v,\n+        }\n+    }\n+}\n+\n /// A double-ended iterator with the direction inverted.\n ///\n /// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n@@ -359,6 +425,12 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n \n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -385,6 +457,12 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n \n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -447,6 +525,12 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -462,6 +546,12 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n         self.it.next_back().cloned()\n     }\n \n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -558,7 +648,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n \n-/// An adapter for stepping iterators by a custom amount.\n+/// An iterator for stepping iterators by a custom amount.\n ///\n /// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n /// its documentation for more.\n@@ -683,6 +773,25 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_fold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Back = self.state {\n+            accum = self.b.try_fold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -792,6 +901,25 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n         }\n     }\n \n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_rfold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Front = self.state {\n+            accum = self.a.try_rfold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1128,6 +1256,13 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n     fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1145,6 +1280,13 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n         self.iter.next_back().map(&mut self.f)\n     }\n \n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n     fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1250,6 +1392,30 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         }\n         count\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1265,6 +1431,30 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1316,6 +1506,28 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1331,6 +1543,28 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1395,6 +1629,32 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     fn count(self) -> usize {\n         self.iter.count()\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let count = &mut self.count;\n+        self.iter.try_fold(init, move |acc, item| {\n+            let acc = fold(acc, (*count, item));\n+            *count += 1;\n+            acc\n+        })\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut count = self.count;\n+        self.iter.fold(init, move |acc, item| {\n+            let acc = fold(acc, (count, item));\n+            count += 1;\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1410,6 +1670,32 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n             (self.count + len, a)\n         })\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1521,6 +1807,30 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         let hi = hi.and_then(|x| x.checked_add(peek_len));\n         (lo, hi)\n     }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1615,20 +1925,49 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref() {\n-            if self.flag || !(self.predicate)(&x) {\n-                self.flag = true;\n-                return Some(x);\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(move |x| {\n+            if *flag || !pred(x) {\n+                *flag = true;\n+                true\n+            } else {\n+                false\n             }\n-        }\n-        None\n+        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return Try::from_ok(init),\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1688,6 +2027,26 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, move |acc, x|{\n+                if p(&x) {\n+                    LoopState::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1769,6 +2128,34 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n \n         (lower, upper)\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return Try::from_ok(init);\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1783,6 +2170,22 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n             None\n         }\n     }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1844,6 +2247,23 @@ impl<I> Iterator for Take<I> where I: Iterator{\n \n         (lower, upper)\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1895,6 +2315,20 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the scan function\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, x| {\n+            match f(state, x) {\n+                None => LoopState::Break(Try::from_ok(acc)),\n+                Some(x) => LoopState::from_try(fold(acc, x)),\n+            }\n+        }).into_try()\n+    }\n }\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -1960,6 +2394,35 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         }\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_fold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        {\n+            let f = &mut self.f;\n+            let frontiter = &mut self.frontiter;\n+            init = self.iter.try_fold(init, |acc, x| {\n+                let mut mid = f(x).into_iter();\n+                let r = mid.try_fold(acc, &mut fold);\n+                *frontiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_fold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1991,6 +2454,45 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        {\n+            let f = &mut self.f;\n+            let backiter = &mut self.backiter;\n+            init = self.iter.try_rfold(init, |acc, x| {\n+                let mut mid = f(x).into_iter();\n+                let r = mid.try_rfold(acc, &mut fold);\n+                *backiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_rfold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -2068,6 +2570,30 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n             self.iter.size_hint()\n         }\n     }\n+\n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_fold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.fold(init, fold)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2082,6 +2608,30 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n             next\n         }\n     }\n+\n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_rfold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.rfold(init, fold)\n+        }\n+    }\n }\n \n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n@@ -2122,6 +2672,20 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\n@@ -2132,6 +2696,20 @@ impl<I> DoubleEndedIterator for Fuse<I>\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n         self.iter.next_back()\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, fold)\n+    }\n }\n \n \n@@ -2196,6 +2774,22 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2207,6 +2801,22 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e9aee4a4676de47fda7282106908e79d3d80b430", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -89,6 +89,7 @@ macro_rules! step_impl_unsigned {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$t>::try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n@@ -120,6 +121,7 @@ macro_rules! step_impl_signed {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$unsigned>::try_from(n) {\n                     Ok(n_as_unsigned) => {"}, {"sha": "11e668d228c48a1b71ec7925fb7b9208049cf0e8", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -7,9 +7,11 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use ops::{Mul, Add};\n+use ops::{Mul, Add, Try};\n use num::Wrapping;\n \n+use super::{AlwaysOk, LoopState};\n+\n /// Conversion from an `Iterator`.\n ///\n /// By implementing `FromIterator` for a type, you define how it will be\n@@ -415,6 +417,52 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n+    /// This is the reverse version of [`try_fold()`]: it takes elements\n+    /// starting from the back of the iterator.\n+    ///\n+    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [\"1\", \"2\", \"3\"];\n+    /// let sum = a.iter()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert_eq!(sum, Ok(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [\"1\", \"rust\", \"3\"];\n+    /// let mut it = a.iter();\n+    /// let sum = it\n+    ///     .by_ref()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert!(sum.is_err());\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.next_back(), Some(&\"1\"));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     /// An iterator method that reduces the iterator's elements to a single,\n     /// final value, starting from the back.\n     ///\n@@ -470,13 +518,10 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_rfold\", issue = \"44705\")]\n-    fn rfold<B, F>(mut self, mut accum: B, mut f: F) -> B where\n+    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        while let Some(x) = self.next_back() {\n-            accum = f(accum, x);\n-        }\n-        accum\n+        self.try_rfold(accum, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n     /// Searches for an element of an iterator from the right that satisfies a predicate.\n@@ -531,10 +576,10 @@ pub trait DoubleEndedIterator: Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        while let Some(x) = self.next_back() {\n-            if predicate(&x) { return Some(x) }\n-        }\n-        None\n+        self.try_rfold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n     }\n }\n "}, {"sha": "d5190b65863cb3f0178a377af311600f423eeb10", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -85,29 +85,12 @@\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n-#![cfg_attr(not(stage0), feature(rustc_const_unstable))]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n-\n-#![cfg_attr(not(stage0), feature(const_min_value))]\n-#![cfg_attr(not(stage0), feature(const_max_value))]\n-#![cfg_attr(not(stage0), feature(const_atomic_bool_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_isize_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_usize_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i8_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u8_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i16_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u16_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i32_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u32_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i64_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u64_new))]\n-#![cfg_attr(not(stage0), feature(const_unsafe_cell_new))]\n-#![cfg_attr(not(stage0), feature(const_cell_new))]\n-#![cfg_attr(not(stage0), feature(const_nonzero_new))]\n+#![feature(doc_spotlight)]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -190,3 +173,4 @@ pub mod fmt;\n mod char_private;\n mod iter_private;\n mod tuple;\n+mod unit;"}, {"sha": "6e3dbcbec9dc9b04a0b93cf5ccea57a15557da1e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -120,6 +120,9 @@ macro_rules! assert_eq {\n             }\n         }\n     });\n+    ($left:expr, $right:expr,) => ({\n+        assert_eq!($left, $right)\n+    });\n     ($left:expr, $right:expr, $($arg:tt)+) => ({\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n@@ -168,6 +171,9 @@ macro_rules! assert_ne {\n             }\n         }\n     });\n+    ($left:expr, $right:expr,) => {\n+        assert_ne!($left, $right)\n+    };\n     ($left:expr, $right:expr, $($arg:tt)+) => ({\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n@@ -355,7 +361,7 @@ macro_rules! try {\n     })\n }\n \n-/// Write formatted data into a buffer\n+/// Write formatted data into a buffer.\n ///\n /// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n /// formatted according to the specified format string and the result will be passed to the writer.\n@@ -606,9 +612,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! format_args { ($fmt:expr, $($args:tt)*) => ({\n-        /* compiler built-in */\n-    }) }\n+    macro_rules! format_args {\n+        ($fmt:expr) => ({ /* compiler built-in */ });\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n+    }\n \n     /// Inspect an environment variable at compile time.\n     ///\n@@ -618,7 +625,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n+        ($name:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Optionally inspect an environment variable at compile time.\n     ///\n@@ -639,7 +649,8 @@ mod builtin {\n     #[macro_export]\n     #[cfg(dox)]\n     macro_rules! concat_idents {\n-        ($($e:ident),*) => ({ /* compiler built-in */ })\n+        ($($e:ident),*) => ({ /* compiler built-in */ });\n+        ($($e:ident,)*) => ({ /* compiler built-in */ });\n     }\n \n     /// Concatenates literals into a static string slice.\n@@ -650,7 +661,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+    macro_rules! concat {\n+        ($($e:expr),*) => ({ /* compiler built-in */ });\n+        ($($e:expr,)*) => ({ /* compiler built-in */ });\n+    }\n \n     /// A macro which expands to the line number on which it was invoked.\n     ///\n@@ -682,15 +696,15 @@ mod builtin {\n     #[cfg(dox)]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which stringifies its argument.\n+    /// A macro which stringifies its arguments.\n     ///\n     /// For more information, see the documentation for [`std::stringify!`].\n     ///\n     /// [`std::stringify!`]: ../std/macro.stringify.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n     ///"}, {"sha": "17e77654cf5ef2975ba15a975e54918d7698a7fb", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -39,13 +39,14 @@ use hash::Hasher;\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send {\n     // empty.\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unknown_lints)]\n+#[allow(auto_impl)]\n unsafe impl Send for .. { }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -122,7 +123,7 @@ pub trait Sized {\n /// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n-#[lang=\"unsize\"]\n+#[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n@@ -312,7 +313,7 @@ pub trait Copy : Clone {\n ///\n /// For cases when one does need thread-safe interior mutability,\n /// Rust provides [atomic data types], as well as explicit locking via\n-/// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n+/// [`sync::Mutex`][mutex] and [`sync::RwLock`][rwlock]. These types\n /// ensure that any mutation cannot cause data races, hence the types\n /// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n /// analogue of [`Rc`][rc].\n@@ -349,6 +350,8 @@ pub unsafe trait Sync {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unknown_lints)]\n+#[allow(auto_impl)]\n unsafe impl Sync for .. { }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -562,6 +565,8 @@ mod impls {\n #[lang = \"freeze\"]\n unsafe trait Freeze {}\n \n+#[allow(unknown_lints)]\n+#[allow(auto_impl)]\n unsafe impl Freeze for .. {}\n \n impl<T: ?Sized> !Freeze for UnsafeCell<T> {}"}, {"sha": "5b1a9399c39bfda3932cb975a1817706f85a342d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 85, "deletions": 7, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -209,6 +209,35 @@ pub fn forget<T>(t: T) {\n /// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n /// have the same size. Likewise for `*const T` and `*mut T`.\n ///\n+/// # Size of `#[repr(C)]` items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Size of Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Size of Enums\n+///\n+/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Size of Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n /// # Examples\n ///\n /// ```\n@@ -231,9 +260,57 @@ pub fn forget<T>(t: T) {\n /// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n /// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n /// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2, so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_size_of\"))]\n pub const fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -325,7 +402,6 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_align_of\"))]\n pub const fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -351,9 +427,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns whether dropping values of type `T` matters.\n ///\n-/// This is purely an optimization hint, and may be implemented conservatively.\n-/// For instance, always returning `true` would be a valid implementation of\n-/// this function.\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n ///\n /// Low level implementations of things like collections, which need to manually\n /// drop their data, should use this function to avoid unnecessarily\n@@ -402,7 +480,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n /// }\n /// ```\n #[inline]\n-#[stable(feature = \"needs_drop\", since = \"1.22.0\")]\n+#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n pub fn needs_drop<T>() -> bool {\n     unsafe { intrinsics::needs_drop::<T>() }\n }\n@@ -758,7 +836,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n ///\n /// See the `discriminant` function in this module for more information.\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<*const T>);\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n \n // N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n "}, {"sha": "2c966eb3b5794e2e15791d95136c5f4ab22a1721", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -28,8 +28,7 @@ macro_rules! impl_zeroable_for_pointer_types {\n             unsafe impl<T: ?Sized> Zeroable for $Ptr {\n                 #[inline]\n                 fn is_zero(&self) -> bool {\n-                    // Cast because `is_null` is only available on thin pointers\n-                    (*self as *mut u8).is_null()\n+                    (*self).is_null()\n                 }\n             }\n         )+\n@@ -71,7 +70,6 @@ impl<T: Zeroable> NonZero<T> {\n     #[unstable(feature = \"nonzero\",\n                reason = \"needs an RFC to flesh out the design\",\n                issue = \"27730\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_nonzero_new\"))]\n     #[inline]\n     pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)"}, {"sha": "7c7562eac5152e6de9a88c907ea40a0ccd37cc96", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 755, "deletions": 103, "changes": 858, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12,9 +12,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::TryFrom;\n+use convert::{Infallible, TryFrom};\n use fmt;\n use intrinsics;\n+use ops;\n use str::FromStr;\n \n /// Provides intentionally-wrapped arithmetic on `T`.\n@@ -109,7 +110,6 @@ macro_rules! int_impl {\n         /// assert_eq!(i8::min_value(), -128);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_min_value\"))]\n         #[inline]\n         pub const fn min_value() -> Self {\n             !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n@@ -123,15 +123,21 @@ macro_rules! int_impl {\n         /// assert_eq!(i8::max_value(), 127);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_max_value\"))]\n         #[inline]\n         pub const fn max_value() -> Self {\n             !Self::min_value()\n         }\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n+        /// The string is expected to be an optional `+` or `-` sign\n+        /// followed by digits.\n         /// Leading and trailing whitespace represent an error.\n+        /// Digits are a subset of these characters, depending on `radix`:\n+        ///\n+        /// * `0-9`\n+        /// * `a-z`\n+        /// * `A-Z`\n         ///\n         /// # Panics\n         ///\n@@ -374,7 +380,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -387,12 +393,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -405,12 +411,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -423,13 +429,13 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -442,16 +448,16 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_div(self, other) })\n+                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -466,11 +472,11 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -553,7 +559,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -566,15 +572,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::max_value(),\n+                None if rhs >= 0 => Self::max_value(),\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -587,15 +593,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::min_value(),\n+                None if rhs >= 0 => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -611,17 +617,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or_else(|| {\n-                if (self < 0 && other < 0) || (self > 0 && other > 0) {\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or_else(|| {\n+                if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n                     Self::max_value()\n                 } else {\n                     Self::min_value()\n                 }\n             })\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -640,7 +646,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -660,7 +666,7 @@ macro_rules! int_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -678,7 +684,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`,\n+        /// Wrapping (modular) division. Computes `self / rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// The only case where such wrapping can occur is when one\n@@ -706,7 +712,7 @@ macro_rules! int_impl {\n             self.overflowing_div(rhs).0\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// Wrapping (modular) remainder. Computes `self % rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// Such wrap-around never actually occurs mathematically;\n@@ -1282,7 +1288,6 @@ macro_rules! uint_impl {\n         /// assert_eq!(u8::min_value(), 0);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_min_value\"))]\n         #[inline]\n         pub const fn min_value() -> Self { 0 }\n \n@@ -1294,13 +1299,23 @@ macro_rules! uint_impl {\n         /// assert_eq!(u8::max_value(), 255);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_max_value\"))]\n         #[inline]\n         pub const fn max_value() -> Self { !0 }\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n+        /// The string is expected to be an optional `+` sign\n+        /// followed by digits.\n         /// Leading and trailing whitespace represent an error.\n+        /// Digits are a subset of these characters, depending on `radix`:\n+        ///\n+        /// * `0-9`\n+        /// * `a-z`\n+        /// * `A-Z`\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function panics if `radix` is not in the range from 2 to 36.\n         ///\n         /// # Examples\n         ///\n@@ -1558,7 +1573,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -1571,12 +1586,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -1589,12 +1604,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -1607,13 +1622,13 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1625,15 +1640,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            match other {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            match rhs {\n                 0 => None,\n-                other => Some(unsafe { intrinsics::unchecked_div(self, other) }),\n+                rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1645,11 +1660,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -1709,7 +1724,7 @@ macro_rules! uint_impl {\n             if b {None} else {Some(a)}\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1722,14 +1737,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1742,14 +1757,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1764,11 +1779,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or(Self::max_value())\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or(Self::max_value())\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1787,7 +1802,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1807,7 +1822,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -1825,7 +1840,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`.\n+        /// Wrapping (modular) division. Computes `self / rhs`.\n         /// Wrapped division on unsigned types is just normal division.\n         /// There's no way wrapping could ever happen.\n         /// This function exists, so that all operations\n@@ -1844,7 +1859,7 @@ macro_rules! uint_impl {\n             self / rhs\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`.\n+        /// Wrapping (modular) remainder. Computes `self % rhs`.\n         /// Wrapped remainder calculation on unsigned types is\n         /// just the regular remainder calculation.\n         /// There's no way wrapping could ever happen.\n@@ -2223,7 +2238,8 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn next_power_of_two(self) -> Self {\n-            self.one_less_than_next_power_of_two() + 1\n+            // Call the trait to get overflow checks\n+            ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n         }\n \n         /// Returns the smallest power of two greater than or equal to `n`. If\n@@ -2257,6 +2273,547 @@ impl u8 {\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n+\n+\n+    /// Checks if the value is within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 97u8;\n+    /// let non_ascii = 150u8;\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        *self & 128 == 0\n+    }\n+\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let lowercase_a = 97u8;\n+    ///\n+    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> u8 {\n+        ASCII_UPPERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> u8 {\n+        ASCII_LOWERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Checks that two values are an ASCII case-insensitive match.\n+    ///\n+    /// This is equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let lowercase_a = 97u8;\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n+    }\n+\n+    /// Converts this value to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut byte = b'a';\n+    ///\n+    /// byte.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!(b'A', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        *self = self.to_ascii_uppercase();\n+    }\n+\n+    /// Converts this value to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut byte = b'A';\n+    ///\n+    /// byte.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!(b'a', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        *self = self.to_ascii_lowercase();\n+    }\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphabetic());\n+    /// assert!(uppercase_g.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_uppercase());\n+    /// assert!(uppercase_g.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_lowercase());\n+    /// assert!(!uppercase_g.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphanumeric());\n+    /// assert!(uppercase_g.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_digit());\n+    /// assert!(!uppercase_g.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_hexdigit());\n+    /// assert!(!uppercase_g.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | Lx | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_punctuation());\n+    /// assert!(!uppercase_g.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_graphic());\n+    /// assert!(uppercase_g.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Ux | U | Lx | L | D | P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_whitespace());\n+    /// assert!(!uppercase_g.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Cw | W => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_control());\n+    /// assert!(!uppercase_g.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            C | Cw => true,\n+            _ => false\n+        }\n+    }\n }\n \n #[lang = \"u16\"]\n@@ -2507,16 +3064,24 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(infallible: Infallible) -> TryFromIntError {\n+        match infallible {\n+        }\n+    }\n+}\n+\n // no possible bounds violation\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n+            type Error = Infallible;\n \n             #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                Ok(u as $target)\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n             }\n         }\n     )*}\n@@ -2588,31 +3153,17 @@ macro_rules! rev {\n }\n \n /// intra-sign conversions\n-try_from_unbounded!(u8, u8, u16, u32, u64, u128);\n-try_from_unbounded!(u16, u16, u32, u64, u128);\n-try_from_unbounded!(u32, u32, u64, u128);\n-try_from_unbounded!(u64, u64, u128);\n-try_from_unbounded!(u128, u128);\n try_from_upper_bounded!(u16, u8);\n try_from_upper_bounded!(u32, u16, u8);\n try_from_upper_bounded!(u64, u32, u16, u8);\n try_from_upper_bounded!(u128, u64, u32, u16, u8);\n \n-try_from_unbounded!(i8, i8, i16, i32, i64, i128);\n-try_from_unbounded!(i16, i16, i32, i64, i128);\n-try_from_unbounded!(i32, i32, i64, i128);\n-try_from_unbounded!(i64, i64, i128);\n-try_from_unbounded!(i128, i128);\n try_from_both_bounded!(i16, i8);\n try_from_both_bounded!(i32, i16, i8);\n try_from_both_bounded!(i64, i32, i16, i8);\n try_from_both_bounded!(i128, i64, i32, i16, i8);\n \n // unsigned-to-signed\n-try_from_unbounded!(u8, i16, i32, i64, i128);\n-try_from_unbounded!(u16, i32, i64, i128);\n-try_from_unbounded!(u32, i64, i128);\n-try_from_unbounded!(u64, i128);\n try_from_upper_bounded!(u8, i8);\n try_from_upper_bounded!(u16, i8, i16);\n try_from_upper_bounded!(u32, i8, i16, i32);\n@@ -2631,15 +3182,13 @@ try_from_both_bounded!(i64, u32, u16, u8);\n try_from_both_bounded!(i128, u64, u32, u16, u8);\n \n // usize/isize\n-try_from_unbounded!(usize, usize);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n-try_from_unbounded!(isize, isize);\n \n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8);\n     try_from_unbounded!(usize, u16, u32, u64, u128);\n@@ -2651,21 +3200,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8);\n     try_from_unbounded!(isize, i16, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16);\n+    rev!(try_from_unbounded, usize, u16);\n     rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8);\n     rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16);\n+    rev!(try_from_unbounded, isize, i16);\n     rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16);\n     try_from_unbounded!(usize, u32, u64, u128);\n@@ -2677,21 +3226,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16);\n     try_from_unbounded!(isize, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32);\n+    rev!(try_from_unbounded, usize, u16, u32);\n     rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16);\n     rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32);\n+    rev!(try_from_unbounded, isize, i16, i32);\n     rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16, u32);\n     try_from_unbounded!(usize, u64, u128);\n@@ -2703,14 +3252,14 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16, i32);\n     try_from_unbounded!(isize, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32, u64);\n+    rev!(try_from_unbounded, usize, u16, u32, u64);\n     rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16, u32);\n     rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32, i64);\n+    rev!(try_from_unbounded, isize, i16, i32, i64);\n     rev!(try_from_both_bounded, isize, i128);\n }\n \n@@ -2934,3 +3483,106 @@ impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // Float -> Float\n impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+static ASCII_LOWERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@',\n+\n+          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z',\n+\n+                      b'[', b'\\\\', b']', b'^', b'_',\n+    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+static ASCII_UPPERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n+    b'`',\n+\n+          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z',\n+\n+                      b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+];"}, {"sha": "ae1b0b3ce11b209cfff581408724b3a05a4c864f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -36,6 +36,7 @@ macro_rules! sh_impl_signed {\n                 *self = *self << other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for Wrapping<$t> {\n@@ -58,6 +59,7 @@ macro_rules! sh_impl_signed {\n                 *self = *self >> other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     )\n }\n \n@@ -80,6 +82,7 @@ macro_rules! sh_impl_unsigned {\n                 *self = *self << other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for Wrapping<$t> {\n@@ -98,6 +101,7 @@ macro_rules! sh_impl_unsigned {\n                 *self = *self >> other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     )\n }\n \n@@ -142,6 +146,7 @@ macro_rules! wrapping_impl {\n                 *self = *self + other;\n             }\n         }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for Wrapping<$t> {\n@@ -162,6 +167,7 @@ macro_rules! wrapping_impl {\n                 *self = *self - other;\n             }\n         }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for Wrapping<$t> {\n@@ -182,6 +188,7 @@ macro_rules! wrapping_impl {\n                 *self = *self * other;\n             }\n         }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n         impl Div for Wrapping<$t> {\n@@ -202,6 +209,7 @@ macro_rules! wrapping_impl {\n                 *self = *self / other;\n             }\n         }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl Rem for Wrapping<$t> {\n@@ -222,6 +230,7 @@ macro_rules! wrapping_impl {\n                 *self = *self % other;\n             }\n         }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for Wrapping<$t> {\n@@ -254,6 +263,7 @@ macro_rules! wrapping_impl {\n                 *self = *self ^ other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for Wrapping<$t> {\n@@ -274,6 +284,7 @@ macro_rules! wrapping_impl {\n                 *self = *self | other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for Wrapping<$t> {\n@@ -294,6 +305,7 @@ macro_rules! wrapping_impl {\n                 *self = *self & other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n         impl Neg for Wrapping<$t> {"}, {"sha": "8b3d662a6db774382bd9b14e7591ed55bffca87e", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -662,6 +662,8 @@ macro_rules! add_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn add_assign(&mut self, other: $t) { *self += other }\n         }\n+\n+        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n     )+)\n }\n \n@@ -713,6 +715,8 @@ macro_rules! sub_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn sub_assign(&mut self, other: $t) { *self -= other }\n         }\n+\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n     )+)\n }\n \n@@ -755,6 +759,8 @@ macro_rules! mul_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn mul_assign(&mut self, other: $t) { *self *= other }\n         }\n+\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n     )+)\n }\n \n@@ -796,6 +802,8 @@ macro_rules! div_assign_impl {\n             #[inline]\n             fn div_assign(&mut self, other: $t) { *self /= other }\n         }\n+\n+        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n     )+)\n }\n \n@@ -841,6 +849,8 @@ macro_rules! rem_assign_impl {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) { *self %= other }\n         }\n+\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n     )+)\n }\n "}, {"sha": "7ac5fc4debf1489150e9f1d4e151e1c60231edc0", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -593,6 +593,8 @@ macro_rules! bitand_assign_impl {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) { *self &= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n     )+)\n }\n \n@@ -638,6 +640,8 @@ macro_rules! bitor_assign_impl {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) { *self |= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n     )+)\n }\n \n@@ -683,6 +687,8 @@ macro_rules! bitxor_assign_impl {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n     )+)\n }\n \n@@ -729,6 +735,8 @@ macro_rules! shl_assign_impl {\n                 *self <<= other\n             }\n         }\n+\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n     )\n }\n \n@@ -793,6 +801,8 @@ macro_rules! shr_assign_impl {\n                 *self >>= other\n             }\n         }\n+\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n     )\n }\n "}, {"sha": "80c48c7b28efd9dea8f25df881c2f699b7720497", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -18,7 +18,7 @@\n /// Implementing `Deref` for smart pointers makes accessing the data behind them\n /// convenient, which is why they implement `Deref`. On the other hand, the\n /// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n-/// accomodate smart pointers. Because of this, **`Deref` should only be\n+/// accommodate smart pointers. Because of this, **`Deref` should only be\n /// implemented for smart pointers** to avoid confusion.\n ///\n /// For similar reasons, **this trait should never fail**. Failure during\n@@ -40,7 +40,7 @@\n /// [book]: ../../book/second-edition/ch15-02-deref.html\n /// [`DerefMut`]: trait.DerefMut.html\n /// [more]: #more-on-deref-coercion\n-/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n /// [ref-deref-trait]: ../../reference/the-deref-trait.html\n /// [type coercions]: ../../reference/type-coercions.html\n ///\n@@ -103,7 +103,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// Implementing `DerefMut` for smart pointers makes mutating the data behind\n /// them convenient, which is why they implement `DerefMut`. On the other hand,\n /// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n-/// accomodate smart pointers. Because of this, **`DerefMut` should only be\n+/// accommodate smart pointers. Because of this, **`DerefMut` should only be\n /// implemented for smart pointers** to avoid confusion.\n ///\n /// For similar reasons, **this trait should never fail**. Failure during\n@@ -127,7 +127,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// [book]: ../../book/second-edition/ch15-02-deref.html\n /// [`Deref`]: trait.Deref.html\n /// [more]: #more-on-deref-coercion\n-/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n /// [ref-deref-trait]: ../../reference/the-deref-trait.html\n /// [type coercions]: ../../reference/type-coercions.html\n ///"}, {"sha": "dc7669d195c1397435a0da4baccef83cc24b0682", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -14,7 +14,7 @@\n /// possible return values of a generator. Currently this corresponds to either\n /// a suspension point (`Yielded`) or a termination point (`Complete`).\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n-#[cfg_attr(not(stage0), lang = \"generator_state\")]\n+#[lang = \"generator_state\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub enum GeneratorState<Y, R> {\n     /// The generator suspended with a value.\n@@ -70,7 +70,7 @@ pub enum GeneratorState<Y, R> {\n /// More documentation of generators can be found in the unstable book.\n ///\n /// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n-#[cfg_attr(not(stage0), lang = \"generator\")]\n+#[lang = \"generator\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]\n pub trait Generator {"}, {"sha": "70ef4487334c9e6626392eca744efb4fa0f026e9", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -150,7 +150,7 @@\n //! [`Sub`]: trait.Sub.html\n //! [`Mul`]: trait.Mul.html\n //! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n-//! [operator precedence]: ../../reference/expressions.html#operator-precedence\n+//! [operator precedence]: ../../reference/expressions.html#expression-precedence\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "81e5cb5c35045796fdd2b10ee1bfa34e796949ef", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,24 +15,19 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[cfg_attr(stage0,\n-           rustc_on_unimplemented = \"the `?` operator can only be used in a \\\n-                                     function that returns `Result` \\\n-                                     (or another type that implements `{Try}`)\")]\n-#[cfg_attr(not(stage0),\n-           rustc_on_unimplemented(\n-               on(all(\n-                   any(from_method=\"from_error\", from_method=\"from_ok\"),\n-                   from_desugaring=\"?\"),\n-                  message=\"the `?` operator can only be used in a \\\n-                           function that returns `Result` \\\n-                           (or another type that implements `{Try}`)\",\n-                  label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n-               on(all(from_method=\"into_result\", from_desugaring=\"?\"),\n-                  message=\"the `?` operator can only be applied to values \\\n-                           that implement `{Try}`\",\n-                  label=\"the `?` operator cannot be applied to type `{Self}`\")\n-))]\n+#[rustc_on_unimplemented(\n+   on(all(\n+       any(from_method=\"from_error\", from_method=\"from_ok\"),\n+       from_desugaring=\"?\"),\n+      message=\"the `?` operator can only be used in a \\\n+               function that returns `Result` \\\n+               (or another type that implements `{Try}`)\",\n+      label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n+   on(all(from_method=\"into_result\", from_desugaring=\"?\"),\n+      message=\"the `?` operator can only be applied to values \\\n+               that implement `{Try}`\",\n+      label=\"the `?` operator cannot be applied to type `{Self}`\")\n+)]\n pub trait Try {\n     /// The type of this value when viewed as successful.\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "cd896859b16bc7eb703de393279305f37d8529b5", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -42,7 +42,7 @@ use marker::Unsize;\n /// [unsize]: ../marker/trait.Unsize.html\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-#[lang=\"coerce_unsized\"]\n+#[lang = \"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty.\n }"}, {"sha": "12e6e8430562a8baeb3f1472b00a5c7121ed8094", "filename": "src/libcore/option.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -146,7 +146,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use iter::{FromIterator, FusedIterator, TrustedLen};\n-use mem;\n+use {mem, ops};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -607,6 +607,41 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Returns `None` if the option is `None`, otherwise calls `predicate`\n+    /// with the wrapped value and returns:\n+    ///\n+    /// - `Some(t)` if `predicate` returns `true` (where `t` is the wrapped\n+    ///   value), and\n+    /// - `None` if `predicate` returns `false`.\n+    ///\n+    /// This function works similar to `Iterator::filter()`. You can imagine\n+    /// the `Option<T>` being an iterator over one or zero elements. `filter()`\n+    /// lets you decide which elements to keep.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_filter)]\n+    ///\n+    /// fn is_even(n: &i32) -> bool {\n+    ///     n % 2 == 0\n+    /// }\n+    ///\n+    /// assert_eq!(None.filter(is_even), None);\n+    /// assert_eq!(Some(3).filter(is_even), None);\n+    /// assert_eq!(Some(4).filter(is_even), Some(4));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_filter\", issue = \"45860\")]\n+    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n+        if let Some(x) = self {\n+            if predicate(&x) {\n+                return Some(x)\n+            }\n+        }\n+        None\n+    }\n+\n     /// Returns the option if it contains a value, otherwise returns `optb`.\n     ///\n     /// # Examples\n@@ -1123,3 +1158,29 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         }\n     }\n }\n+\n+/// The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n+/// to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n+/// implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n+/// returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+pub struct NoneError;\n+\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+impl<T> ops::Try for Option<T> {\n+    type Ok = T;\n+    type Error = NoneError;\n+\n+    fn into_result(self) -> Result<T, NoneError> {\n+        self.ok_or(NoneError)\n+    }\n+\n+    fn from_ok(v: T) -> Self {\n+        Some(v)\n+    }\n+\n+    fn from_error(_: NoneError) -> Self {\n+        None\n+    }\n+}"}, {"sha": "5e70c8283f454f0ffe0c1aad366bc9bc0e4c6506", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -27,8 +27,6 @@ use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n \n-// FIXME #19649: intrinsic docs don't render, so these have no docs :(\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::copy_nonoverlapping;\n \n@@ -56,7 +54,7 @@ pub use intrinsics::write_bytes;\n /// This has all the same safety problems as `ptr::read` with respect to\n /// invalid pointers, types, and double drops.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n-#[lang=\"drop_in_place\"]\n+#[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the\n@@ -76,7 +74,6 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_null\"))]\n pub const fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -91,7 +88,6 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_null_mut\"))]\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n@@ -230,7 +226,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// moves the value out of `src` without preventing further usage of `src`.\n /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n /// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n@@ -266,7 +262,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// moves the value out of `src` without preventing further usage of `src`.\n /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n /// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n@@ -399,7 +395,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// moves the value out of `src` without preventing further usage of `src`.\n /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n /// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n@@ -476,6 +472,11 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n impl<T: ?Sized> *const T {\n     /// Returns `true` if the pointer is null.\n     ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -487,8 +488,10 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool where T: Sized {\n-        self == null()\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *const u8) == null()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -519,7 +522,7 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n         } else {\n@@ -553,7 +556,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -686,7 +689,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -745,7 +748,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -873,7 +876,7 @@ impl<T: ?Sized> *const T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n@@ -927,7 +930,7 @@ impl<T: ?Sized> *const T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// # Examples\n@@ -963,7 +966,7 @@ impl<T: ?Sized> *const T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// # Examples\n@@ -1107,6 +1110,11 @@ impl<T: ?Sized> *const T {\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n     ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1118,8 +1126,10 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool where T: Sized {\n-        self == null_mut()\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *mut u8) == null_mut()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -1150,7 +1160,7 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n         } else {\n@@ -1184,7 +1194,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1274,7 +1284,7 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> where T: Sized {\n+    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n         if self.is_null() {\n             None\n         } else {\n@@ -1384,7 +1394,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1443,7 +1453,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1571,7 +1581,7 @@ impl<T: ?Sized> *mut T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n@@ -1625,7 +1635,7 @@ impl<T: ?Sized> *mut T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `src` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// # Examples\n@@ -1661,7 +1671,7 @@ impl<T: ?Sized> *mut T {\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n     /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `zero_memory`, or `copy_memory`). Note that `*self = foo` counts as a use\n+    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n     /// # Examples\n@@ -2335,7 +2345,6 @@ impl<T: ?Sized> Unique<T> {\n     ///\n     /// `ptr` must be non-null.\n     #[unstable(feature = \"unique\", issue = \"27730\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_unique_new\"))]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n     }\n@@ -2470,7 +2479,6 @@ impl<T: ?Sized> Shared<T> {\n     ///\n     /// `ptr` must be non-null.\n     #[unstable(feature = \"shared\", issue = \"27730\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_shared_new\"))]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n     }"}, {"sha": "db5bffced10cce609149f61088e049930e1dd615", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1060,7 +1060,7 @@ unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n /// [`Result`]: enum.Result.html\n /// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n /// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n "}, {"sha": "49c51f4f04fdccfb37f72f8dcd26fdaf2ae68d9b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 87, "deletions": 137, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -16,9 +16,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-// FIXME: after next stage0, change RangeInclusive { ... } back to ..=\n-use ops::RangeInclusive;\n-\n // How this module is organized.\n //\n // The library infrastructure for slices is fairly messy. There's\n@@ -43,7 +40,7 @@ use cmp;\n use fmt;\n use intrinsics::assume;\n use iter::*;\n-use ops::{FnMut, self};\n+use ops::{FnMut, Try, self};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n@@ -394,23 +391,25 @@ impl<T> SliceExt for [T] {\n     fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a T) -> Ordering\n     {\n+        let s = self;\n+        let mut size = s.len();\n+        if size == 0 {\n+            return Err(0);\n+        }\n         let mut base = 0usize;\n-        let mut s = self;\n-\n-        loop {\n-            let (head, tail) = s.split_at(s.len() >> 1);\n-            if tail.is_empty() {\n-                return Err(base)\n-            }\n-            match f(&tail[0]) {\n-                Less => {\n-                    base += head.len() + 1;\n-                    s = &tail[1..];\n-                }\n-                Greater => s = head,\n-                Equal => return Ok(base + head.len()),\n-            }\n+        while size > 1 {\n+            let half = size / 2;\n+            let mid = base + half;\n+            // mid is always in [0, size).\n+            // mid >= 0: by definition\n+            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n+            let cmp = f(unsafe { s.get_unchecked(mid) });\n+            base = if cmp == Greater { base } else { mid };\n+            size -= half;\n         }\n+        // base is always in [0, size) because base <= mid.\n+        let cmp = f(unsafe { s.get_unchecked(base) });\n+        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n     }\n \n     #[inline]\n@@ -1047,32 +1046,32 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (RangeInclusive { start: 0, end: self.end }).get(slice)\n+        (0..=self.end).get(slice)\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (RangeInclusive { start: 0, end: self.end }).get_mut(slice)\n+        (0..=self.end).get_mut(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (RangeInclusive { start: 0, end: self.end }).get_unchecked(slice)\n+        (0..=self.end).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (RangeInclusive { start: 0, end: self.end }).get_unchecked_mut(slice)\n+        (0..=self.end).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        (RangeInclusive { start: 0, end: self.end }).index(slice)\n+        (0..=self.end).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (RangeInclusive { start: 0, end: self.end }).index_mut(slice)\n+        (0..=self.end).index_mut(slice)\n     }\n }\n \n@@ -1166,62 +1165,37 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n-            fn all<F>(&mut self, mut predicate: F) -> bool\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                self.search_while(true, move |elt| {\n-                    if predicate(elt) {\n-                        SearchWhile::Continue\n-                    } else {\n-                        SearchWhile::Done(false)\n-                    }\n-                })\n-            }\n-\n-            fn any<F>(&mut self, mut predicate: F) -> bool\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                !self.all(move |elt| !predicate(elt))\n-            }\n-\n-            fn find<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n-                where F: FnMut(&Self::Item) -> bool,\n+            #[inline]\n+            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n             {\n-                self.search_while(None, move |elt| {\n-                    if predicate(&elt) {\n-                        SearchWhile::Done(Some(elt))\n-                    } else {\n-                        SearchWhile::Continue\n+                // manual unrolling is needed when there are conditional exits from the loop\n+                let mut accum = init;\n+                unsafe {\n+                    while ptrdistance(self.ptr, self.end) >= 4 {\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                     }\n-                })\n-            }\n-\n-            fn position<F>(&mut self, mut predicate: F) -> Option<usize>\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                let mut index = 0;\n-                self.search_while(None, move |elt| {\n-                    if predicate(elt) {\n-                        SearchWhile::Done(Some(index))\n-                    } else {\n-                        index += 1;\n-                        SearchWhile::Continue\n+                    while self.ptr != self.end {\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                     }\n-                })\n+                }\n+                Try::from_ok(accum)\n             }\n \n-            fn rposition<F>(&mut self, mut predicate: F) -> Option<usize>\n-                where F: FnMut(Self::Item) -> bool,\n+            #[inline]\n+            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n             {\n-                let mut index = self.len();\n-                self.rsearch_while(None, move |elt| {\n-                    index -= 1;\n-                    if predicate(elt) {\n-                        SearchWhile::Done(Some(index))\n-                    } else {\n-                        SearchWhile::Continue\n-                    }\n-                })\n+                // Let LLVM unroll this, rather than using the default\n+                // impl that would force the manual unrolling above\n+                let mut accum = init;\n+                while let Some(x) = self.next() {\n+                    accum = f(accum, x);\n+                }\n+                accum\n             }\n         }\n \n@@ -1243,59 +1217,37 @@ macro_rules! iterator {\n                 }\n             }\n \n-            fn rfind<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n-                where F: FnMut(&Self::Item) -> bool,\n-            {\n-                self.rsearch_while(None, move |elt| {\n-                    if predicate(&elt) {\n-                        SearchWhile::Done(Some(elt))\n-                    } else {\n-                        SearchWhile::Continue\n-                    }\n-                })\n-            }\n-\n-        }\n-\n-        // search_while is a generalization of the internal iteration methods.\n-        impl<'a, T> $name<'a, T> {\n-            // search through the iterator's element using the closure `g`.\n-            // if no element was found, return `default`.\n-            fn search_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n-                where Self: Sized,\n-                      G: FnMut($elem) -> SearchWhile<Acc>\n+            #[inline]\n+            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n             {\n                 // manual unrolling is needed when there are conditional exits from the loop\n+                let mut accum = init;\n                 unsafe {\n                     while ptrdistance(self.ptr, self.end) >= 4 {\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                     }\n                     while self.ptr != self.end {\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                     }\n                 }\n-                default\n+                Try::from_ok(accum)\n             }\n \n-            fn rsearch_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n-                where Self: Sized,\n-                      G: FnMut($elem) -> SearchWhile<Acc>\n+            #[inline]\n+            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n             {\n-                unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                    }\n-                    while self.ptr != self.end {\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                    }\n+                // Let LLVM unroll this, rather than using the default\n+                // impl that would force the manual unrolling above\n+                let mut accum = init;\n+                while let Some(x) = self.next_back() {\n+                    accum = f(accum, x);\n                 }\n-                default\n+                accum\n             }\n         }\n     }\n@@ -1329,24 +1281,6 @@ macro_rules! make_mut_slice {\n     }}\n }\n \n-// An enum used for controlling the execution of `.search_while()`.\n-enum SearchWhile<T> {\n-    // Continue searching\n-    Continue,\n-    // Fold is complete and will return this value\n-    Done(T),\n-}\n-\n-// helper macro for search while's control flow\n-macro_rules! search_while {\n-    ($e:expr) => {\n-        match $e {\n-            SearchWhile::Continue => { }\n-            SearchWhile::Done(done) => return done,\n-        }\n-    }\n-}\n-\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices].\n@@ -1654,7 +1588,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for Split<'a, T, P> where P: FnMut(&T\n     }\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Split<'a, T, P> {\n@@ -2093,7 +2027,7 @@ pub struct Windows<'a, T:'a> {\n     size: usize\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Windows<'a, T> {\n     fn clone(&self) -> Windows<'a, T> {\n@@ -2195,7 +2129,7 @@ pub struct Chunks<'a, T:'a> {\n     size: usize\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Chunks<'a, T> {\n     fn clone(&self) -> Chunks<'a, T> {\n@@ -2450,6 +2384,22 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     mem::transmute(Repr { data: p, len: len })\n }\n \n+/// Converts a reference to T into a slice of length 1 (without copying).\n+#[unstable(feature = \"from_ref\", issue = \"45703\")]\n+pub fn from_ref<T>(s: &T) -> &[T] {\n+    unsafe {\n+        from_raw_parts(s, 1)\n+    }\n+}\n+\n+/// Converts a reference to T into a slice of length 1 (without copying).\n+#[unstable(feature = \"from_ref\", issue = \"45703\")]\n+pub fn from_ref_mut<T>(s: &mut T) -> &mut [T] {\n+    unsafe {\n+        from_raw_parts_mut(s, 1)\n+    }\n+}\n+\n // This function is public only because there is no other way to unit test heapsort.\n #[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"0\")]\n #[doc(hidden)]"}, {"sha": "be5108238fc0491a3e8bf2018211636220af0cec", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -18,7 +18,6 @@ use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use convert::TryFrom;\n use fmt;\n use iter::{Map, Cloned, FusedIterator, TrustedLen};\n use iter_private::TrustedRandomAccess;\n@@ -77,9 +76,12 @@ pub trait FromStr: Sized {\n \n     /// Parses a string `s` to return a value of this type.\n     ///\n-    /// If parsing succeeds, return the value inside `Ok`, otherwise\n+    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n     /// when the string is ill-formatted return an error specific to the\n-    /// inside `Err`. The error type is specific to implementation of the trait.\n+    /// inside [`Err`]. The error type is specific to implementation of the trait.\n+    ///\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -1406,16 +1408,6 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n #[allow(deprecated)]\n impl<'a> FusedIterator for LinesAny<'a> {}\n \n-/*\n-Section: Comparing strings\n-*/\n-\n-/// Bytewise slice equality\n-#[inline]\n-fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_bytes() == b.as_bytes()\n-}\n-\n /*\n Section: UTF-8 validation\n */\n@@ -1591,7 +1583,6 @@ mod traits {\n     use cmp::Ordering;\n     use ops;\n     use slice::{self, SliceIndex};\n-    use str::eq_slice;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1612,7 +1603,7 @@ mod traits {\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n-            eq_slice(self, other)\n+            self.as_bytes() == other.as_bytes()\n         }\n         #[inline]\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n@@ -2198,7 +2189,7 @@ pub trait StrExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_empty(&self) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn parse<'a, T: TryFrom<&'a str>>(&'a self) -> Result<T, T::Error>;\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n // truncate `&str` to length at most equal to `max`\n@@ -2518,9 +2509,7 @@ impl StrExt for str {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n \n     #[inline]\n-    fn parse<'a, T>(&'a self) -> Result<T, T::Error> where T: TryFrom<&'a str> {\n-        T::try_from(self)\n-    }\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4c6ff4d1bb475d99f16286e1c7cfd762e3947e76", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -103,9 +103,8 @@ use fmt;\n ///\n /// On some platforms this function may not do anything at all.\n #[inline]\n-#[unstable(feature = \"hint_core_should_pause\", issue = \"41196\")]\n-pub fn hint_core_should_pause()\n-{\n+#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n+pub fn spin_loop_hint() {\n     #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     unsafe {\n         asm!(\"pause\" ::: \"memory\" : \"volatile\");\n@@ -119,7 +118,9 @@ pub fn hint_core_should_pause()\n \n /// A boolean type which can be safely shared between threads.\n ///\n-/// This type has the same in-memory representation as a `bool`.\n+/// This type has the same in-memory representation as a [`bool`].\n+///\n+/// [`bool`]: ../../../std/primitive.bool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n@@ -241,16 +242,17 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_atomic_bool_new\"))]\n     pub const fn new(v: bool) -> AtomicBool {\n         AtomicBool { v: UnsafeCell::new(v as u8) }\n     }\n \n-    /// Returns a mutable reference to the underlying `bool`.\n+    /// Returns a mutable reference to the underlying [`bool`].\n     ///\n     /// This is safe because the mutable reference guarantees that no other threads are\n     /// concurrently accessing the atomic data.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -369,7 +371,7 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n@@ -378,6 +380,7 @@ impl AtomicBool {\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -401,7 +404,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n@@ -412,6 +415,7 @@ impl AtomicBool {\n     /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n     /// be equivalent or weaker than the success ordering.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -452,7 +456,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n@@ -465,6 +469,7 @@ impl AtomicBool {\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -650,7 +655,6 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_atomic_ptr_new\"))]\n     pub const fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p) }\n     }\n@@ -920,16 +924,44 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n+#[cfg(target_has_atomic = \"8\")]\n+#[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n+impl From<bool> for AtomicBool {\n+    #[inline]\n+    fn from(b: bool) -> Self { Self::new(b) }\n+}\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n+#[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n+impl<T> From<*mut T> for AtomicPtr<T> {\n+    #[inline]\n+    fn from(p: *mut T) -> Self { Self::new(p) }\n+}\n+\n #[cfg(target_has_atomic = \"ptr\")]\n macro_rules! atomic_int {\n-    ($stable:meta, $const_unstable:meta,\n+    ($stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n+     $s_int_type:expr, $int_ref:expr,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n-        /// This type has the same in-memory representation as the underlying integer type.\n+        /// This type has the same in-memory representation as the underlying\n+        /// integer type, [`\n+        #[doc = $s_int_type]\n+        /// `](\n+        #[doc = $int_ref]\n+        /// ). For more about the differences between atomic types and\n+        /// non-atomic types, please see the [module-level documentation].\n+        ///\n+        /// Please note that examples are shared between atomic variants of\n+        /// primitive integer types, so it's normal that they are all\n+        /// demonstrating [`AtomicIsize`].\n+        ///\n+        /// [module-level documentation]: index.html\n+        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -946,6 +978,12 @@ macro_rules! atomic_int {\n             }\n         }\n \n+        #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n+        impl From<$int_type> for $atomic_type {\n+            #[inline]\n+            fn from(v: $int_type) -> Self { Self::new(v) }\n+        }\n+\n         #[$stable_debug]\n         impl fmt::Debug for $atomic_type {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -971,7 +1009,6 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n-            #[cfg_attr(not(stage0), $const_unstable)]\n             pub const fn new(v: $int_type) -> Self {\n                 $atomic_type {v: UnsafeCell::new(v)}\n             }\n@@ -1335,91 +1372,91 @@ macro_rules! atomic_int {\n #[cfg(target_has_atomic = \"8\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i8_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i8\", \"../../../std/primitive.i8.html\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u8_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u8\", \"../../../std/primitive.u8.html\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i16_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i16\", \"../../../std/primitive.i16.html\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u16_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u16\", \"../../../std/primitive.u16.html\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i32_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i32\", \"../../../std/primitive.i32.html\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u32_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u32\", \"../../../std/primitive.u32.html\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i64_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i64\", \"../../../std/primitive.i64.html\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u64_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u64\", \"../../../std/primitive.u64.html\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    rustc_const_unstable(feature = \"const_atomic_isize_new\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+    \"isize\", \"../../../std/primitive.isize.html\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    rustc_const_unstable(feature = \"const_atomic_usize_new\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+    \"usize\", \"../../../std/primitive.usize.html\",\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1752,7 +1789,7 @@ pub fn fence(order: Ordering) {\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n /// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n #[inline]\n-#[stable(feature = \"compiler_fences\", since = \"1.22.0\")]\n+#[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n     unsafe {\n         match order {"}, {"sha": "6278d5e23e0d69a3fb9ab4f7096a94a472ae6dcc", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use core::array::FixedSizeArray;\n+use core::convert::TryFrom;\n \n #[test]\n fn fixed_size_array() {\n@@ -26,3 +27,25 @@ fn fixed_size_array() {\n     assert_eq!(FixedSizeArray::as_mut_slice(&mut empty_array).len(), 0);\n     assert_eq!(FixedSizeArray::as_mut_slice(&mut empty_zero_sized).len(), 0);\n }\n+\n+#[test]\n+fn array_try_from() {\n+    macro_rules! test {\n+        ($($N:expr)+) => {\n+            $({\n+                type Array = [u8; $N];\n+                let array: Array = [0; $N];\n+                let slice: &[u8] = &array[..];\n+\n+                let result = <&Array>::try_from(slice);\n+                assert_eq!(&array, result.unwrap());\n+            })+\n+        }\n+    }\n+    test! {\n+         0  1  2  3  4  5  6  7  8  9\n+        10 11 12 13 14 15 16 17 18 19\n+        20 21 22 23 24 25 26 27 28 29\n+        30 31 32\n+    }\n+}"}, {"sha": "4e10ceac878b6a4c5669d49a2b7fd9838efb4ca8", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -32,7 +32,6 @@ fn test_convert() {\n #[test]\n fn test_from_str() {\n     assert_eq!(char::from_str(\"a\").unwrap(), 'a');\n-    assert_eq!(char::try_from(\"a\").unwrap(), 'a');\n     assert_eq!(char::from_str(\"\\0\").unwrap(), '\\0');\n     assert_eq!(char::from_str(\"\\u{D7FF}\").unwrap(), '\\u{d7FF}');\n     assert!(char::from_str(\"\").is_err());"}, {"sha": "8716421b424deb3106639ead19edc26954838fd3", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -12,6 +12,7 @@ mod sip;\n \n use std::hash::{Hash, Hasher};\n use std::default::Default;\n+use std::rc::Rc;\n \n struct MyHasher {\n     hash: u64,\n@@ -64,18 +65,28 @@ fn test_writer_hasher() {\n     assert_eq!(hash(& s), 97 + 0xFF);\n     let s: Box<str> = String::from(\"a\").into_boxed_str();\n     assert_eq!(hash(& s), 97 + 0xFF);\n+    let s: Rc<&str> = Rc::new(\"a\");\n+    assert_eq!(hash(&s), 97 + 0xFF);\n     let cs: &[u8] = &[1, 2, 3];\n     assert_eq!(hash(& cs), 9);\n     let cs: Box<[u8]> = Box::new([1, 2, 3]);\n     assert_eq!(hash(& cs), 9);\n-\n-    // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n+    let cs: Rc<[u8]> = Rc::new([1, 2, 3]);\n+    assert_eq!(hash(& cs), 9);\n \n     let ptr = 5_usize as *const i32;\n     assert_eq!(hash(&ptr), 5);\n \n     let ptr = 5_usize as *mut i32;\n     assert_eq!(hash(&ptr), 5);\n+\n+    let cs: &mut [u8] = &mut [1, 2, 3];\n+    let ptr = cs.as_ptr();\n+    let slice_ptr = cs as *const [u8];\n+    assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n+\n+    let slice_ptr = cs as *mut [u8];\n+    assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n }\n \n struct Custom { hash: u64 }"}, {"sha": "c6dd41798f2a7ad388ee9b9b3c312a9019a68f9a", "filename": "src/libcore/tests/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -243,24 +243,22 @@ fn test_siphash_2_4() {\n         t += 1;\n     }\n }\n-#[test] #[cfg(target_arch = \"arm\")]\n+\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert!(hash(&(val as u64)) != hash(&(val as usize)));\n     assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n-#[test] #[cfg(target_arch = \"x86_64\")]\n+\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n     assert!(hash(&(val as u32)) != hash(&(val as usize)));\n }\n-#[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_usize() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-}\n \n #[test]\n fn test_hash_idempotent() {"}, {"sha": "5cac5b26d88bd238f3eb722885d744a3f2e16f3f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 400, "deletions": 3, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -248,6 +248,25 @@ fn test_filter_map() {\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n+#[test]\n+fn test_filter_map_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0*0, 2*2, 4*4, 6*6, 8*8];\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_enumerate() {\n     let xs = [0, 1, 2, 3, 4, 5];\n@@ -282,7 +301,31 @@ fn test_iterator_enumerate_nth() {\n #[test]\n fn test_iterator_enumerate_count() {\n     let xs = [0, 1, 2, 3, 4, 5];\n-    assert_eq!(xs.iter().count(), 6);\n+    assert_eq!(xs.iter().enumerate().count(), 6);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    // steal a couple to get an interesting offset\n+    assert_eq!(it.next(), Some((0, &0)));\n+    assert_eq!(it.next(), Some((1, &1)));\n+    let i = it.fold(2, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let mut it = xs.iter().enumerate();\n+    assert_eq!(it.next(), Some((0, &0)));\n+    let i = it.rfold(xs.len() - 1, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -291,6 +334,25 @@ fn test_iterator_filter_count() {\n     assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n }\n \n+#[test]\n+fn test_iterator_filter_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0, 2, 4, 6, 8];\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n@@ -381,6 +443,18 @@ fn test_iterator_peekable_last() {\n     assert_eq!(it.last(), None);\n }\n \n+#[test]\n+fn test_iterator_peekable_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -470,6 +544,26 @@ fn test_iterator_skip_while() {\n     assert_eq!(i, ys.len());\n }\n \n+#[test]\n+fn test_iterator_skip_while_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip_while(|&x| *x < 15);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+\n #[test]\n fn test_iterator_skip() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n@@ -566,6 +660,45 @@ fn test_iterator_skip_last() {\n     assert_eq!(it.last(), Some(&30));\n }\n \n+#[test]\n+fn test_iterator_skip_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+\n+    let it = xs.iter().skip(5);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().skip(5);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 0);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 1);\n+\n+}\n+\n #[test]\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -661,13 +794,22 @@ fn test_iterator_flat_map_fold() {\n     let xs = [0, 3, 6];\n     let ys = [1, 2, 3, 4, 5, 6, 7];\n     let mut it = xs.iter().flat_map(|&x| x..x+3);\n-    it.next();\n-    it.next_back();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n     let i = it.fold(0, |i, x| {\n         assert_eq!(x, ys[i]);\n         i + 1\n     });\n     assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().flat_map(|&x| x..x+3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -684,6 +826,32 @@ fn test_inspect() {\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n+#[test]\n+fn test_inspect_fold() {\n+    let xs = [1, 2, 3, 4];\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.fold(0, |i, &x| {\n+            assert_eq!(x, xs[i]);\n+            i + 1\n+        });\n+        assert_eq!(i, xs.len());\n+    }\n+    assert_eq!(n, xs.len());\n+\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.rfold(xs.len(), |i, &x| {\n+            assert_eq!(x, xs[i - 1]);\n+            i - 1\n+        });\n+        assert_eq!(i, 0);\n+    }\n+    assert_eq!(n, xs.len());\n+}\n+\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n@@ -1241,6 +1409,31 @@ fn test_fuse_count() {\n     // Can't check len now because count consumes.\n }\n \n+#[test]\n+fn test_fuse_fold() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().rfold(xs.len(), |i, &x| {\n+        assert_eq!(x, xs[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+\n+    let it = xs.iter().scan((), |_, &x| Some(x)); // `!FusedIterator`\n+    let i = it.fuse().fold(0, |i, x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n #[test]\n fn test_once() {\n     let mut it = once(42);\n@@ -1304,3 +1497,207 @@ fn test_step_replace_no_between() {\n     assert_eq!(x, 1);\n     assert_eq!(y, 5);\n }\n+\n+#[test]\n+fn test_rev_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..10).rev().try_fold(7, f), (1..10).try_rfold(7, f));\n+    assert_eq!((1..10).rev().try_rfold(7, f), (1..10).try_fold(7, f));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(&70));\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(&60));\n+}\n+\n+#[test]\n+fn test_cloned_try_folds() {\n+    let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    let f_ref = &|acc, &x| i32::checked_add(2*acc, x);\n+    assert_eq!(a.iter().cloned().try_fold(7, f), a.iter().try_fold(7, f_ref));\n+    assert_eq!(a.iter().cloned().try_rfold(7, f), a.iter().try_rfold(7, f_ref));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_fold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(60));\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(70));\n+}\n+\n+#[test]\n+fn test_chain_try_folds() {\n+    let c = || (0..10).chain(10..20);\n+\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!(c().try_fold(7, f), (0..20).try_fold(7, f));\n+    assert_eq!(c().try_rfold(7, f), (0..20).rev().try_fold(7, f));\n+\n+    let mut iter = c();\n+    assert_eq!(iter.position(|x| x == 5), Some(5));\n+    assert_eq!(iter.next(), Some(6), \"stopped in front, state Both\");\n+    assert_eq!(iter.position(|x| x == 13), Some(6));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Back\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc+x)), Some((15..20).sum()));\n+\n+    let mut iter = c().rev(); // use rev to access try_rfold\n+    assert_eq!(iter.position(|x| x == 15), Some(4));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Both\");\n+    assert_eq!(iter.position(|x| x == 5), Some(8));\n+    assert_eq!(iter.next(), Some(4), \"stopped in front, state Front\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc+x)), Some((0..4).sum()));\n+\n+    let mut iter = c();\n+    iter.by_ref().rev().nth(14); // skip the last 15, ending in state Front\n+    assert_eq!(iter.try_fold(7, f), (0..5).try_fold(7, f));\n+\n+    let mut iter = c();\n+    iter.nth(14); // skip the first 15, ending in state Back\n+    assert_eq!(iter.try_rfold(7, f), (15..20).try_rfold(7, f));\n+}\n+\n+#[test]\n+fn test_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((0..10).map(|x| x+3).try_fold(7, f), (3..13).try_fold(7, f));\n+    assert_eq!((0..10).map(|x| x+3).try_rfold(7, f), (3..13).try_rfold(7, f));\n+\n+    let mut iter = (0..40).map(|x| x+10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(46));\n+}\n+\n+#[test]\n+fn test_filter_try_folds() {\n+    fn p(&x: &i32) -> bool { 0 <= x && x < 10 }\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((-10..20).filter(p).try_fold(7, f), (0..10).try_fold(7, f));\n+    assert_eq!((-10..20).filter(p).try_rfold(7, f), (0..10).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter(|&x| x % 2 == 1);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(25));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(31));\n+}\n+\n+#[test]\n+fn test_filter_map_try_folds() {\n+    let mp = &|x| if 0 <= x && x < 10 { Some(x*2) } else { None };\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((-9..20).filter_map(mp).try_fold(7, f), (0..10).map(|x| 2*x).try_fold(7, f));\n+    assert_eq!((-9..20).filter_map(mp).try_rfold(7, f), (0..10).map(|x| 2*x).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter_map(|x| if x%2 == 1 { None } else { Some(x*2 + 10) });\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(38));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(78));\n+}\n+\n+#[test]\n+fn test_enumerate_try_folds() {\n+    let f = &|acc, (i, x)| usize::checked_add(2*acc, x/(i+1) + i);\n+    assert_eq!((9..18).enumerate().try_fold(7, f), (0..9).map(|i| (i, i+9)).try_fold(7, f));\n+    assert_eq!((9..18).enumerate().try_rfold(7, f), (0..9).map(|i| (i, i+9)).try_rfold(7, f));\n+\n+    let mut iter = (100..200).enumerate();\n+    let f = &|acc, (i, x)| u8::checked_add(acc, u8::checked_div(x, i as u8 + 1)?);\n+    assert_eq!(iter.try_fold(0, f), None);\n+    assert_eq!(iter.next(), Some((7, 107)));\n+    assert_eq!(iter.try_rfold(0, f), None);\n+    assert_eq!(iter.next_back(), Some((11, 111)));\n+}\n+\n+#[test]\n+fn test_peek_try_fold() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&40));\n+}\n+\n+#[test]\n+fn test_skip_while_try_fold() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    fn p(&x: &i32) -> bool { (x % 10) <= 5 }\n+    assert_eq!((1..20).skip_while(p).try_fold(7, f), (6..20).try_fold(7, f));\n+    let mut iter = (1..20).skip_while(p);\n+    assert_eq!(iter.nth(5), Some(11));\n+    assert_eq!(iter.try_fold(7, f), (12..20).try_fold(7, f));\n+\n+    let mut iter = (0..50).skip_while(|&x| (x % 20) < 15);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(23));\n+}\n+\n+#[test]\n+fn test_take_while_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).take_while(|&x| x != 10).try_fold(7, f), (1..10).try_fold(7, f));\n+    let mut iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.try_fold(0, |x, y| Some(x+y)), Some((1..10).sum()));\n+    assert_eq!(iter.next(), None, \"flag should be set\");\n+    let iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.fold(0, |x, y| x+y), (1..10).sum());\n+\n+    let mut iter = (10..50).take_while(|&x| x != 40);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+}\n+\n+#[test]\n+fn test_skip_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).skip(9).try_fold(7, f), (10..20).try_fold(7, f));\n+    assert_eq!((1..20).skip(9).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (0..30).skip(10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+}\n+\n+#[test]\n+fn test_take_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n+    //assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (10..30).take(20);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    //assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    //assert_eq!(iter.next_back(), Some(24));\n+}\n+\n+#[test]\n+fn test_flat_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).flat_map(mr).try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).flat_map(mr).try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).flat_map(mr);\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).flat_map(|x| (4*x)..(4*x + 4));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}"}, {"sha": "0e445cdac358a1bbe0018816a787f753d0039a56", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -24,9 +24,10 @@\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n+#![feature(iterator_try_fold)]\n #![feature(iter_rfind)]\n+#![feature(iter_rfold)]\n #![feature(nonzero)]\n-#![feature(rand)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]\n@@ -38,15 +39,11 @@\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_from)]\n+#![feature(try_trait)]\n #![feature(unique)]\n \n-#![feature(const_atomic_bool_new)]\n-#![feature(const_atomic_usize_new)]\n-#![feature(const_atomic_isize_new)]\n-\n extern crate core;\n extern crate test;\n-extern crate rand;\n \n mod any;\n mod array;"}, {"sha": "f55a1c81463f77ab0a8a6dd7c1946ae3c0c33a4a", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -121,3 +121,19 @@ fn test_transmute() {\n     }\n }\n \n+#[test]\n+#[allow(dead_code)]\n+fn test_discriminant_send_sync() {\n+    enum Regular {\n+        A,\n+        B(i32)\n+    }\n+    enum NotSendSync {\n+        A(*const i32)\n+    }\n+\n+    fn is_send_sync<T: Send + Sync>() { }\n+\n+    is_send_sync::<Discriminant<Regular>>();\n+    is_send_sync::<Discriminant<NotSendSync>>();\n+}"}, {"sha": "857aae72c8a5bd5d92a0088a36bbe3c37fc58b37", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME https://github.com/kripken/emscripten/issues/4563\n-// NB we have to actually not compile this test to avoid\n-// an undefined symbol error\n-#![cfg(not(target_os = \"emscripten\"))]\n-\n use core::num::flt2dec::estimator::*;\n \n #[test]"}, {"sha": "ef0178815f98b27dbd9d3829fa35118bd60ecb69", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -9,10 +9,7 @@\n // except according to those terms.\n \n use std::prelude::v1::*;\n-use std::{str, mem, i16, f32, f64, fmt};\n-use std::__rand as rand;\n-use rand::{Rand, XorShiftRng};\n-use rand::distributions::{IndependentSample, Range};\n+use std::{str, i16, f32, f64, fmt};\n \n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n use core::num::flt2dec::{MAX_SIG_DIGITS, round_up, Part, Formatted, Sign};\n@@ -464,87 +461,6 @@ pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]\n                       exp: 0, inclusive: false} => b\"99999999999999999\", 17);\n }\n \n-fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n-              V: FnMut(usize) -> Decoded {\n-    assert!(k <= 1024);\n-\n-    let mut npassed = 0; // f(x) = Some(g(x))\n-    let mut nignored = 0; // f(x) = None\n-\n-    for i in 0..n {\n-        if (i & 0xfffff) == 0 {\n-            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n-                     i, n, nignored, npassed, i - nignored - npassed);\n-        }\n-\n-        let decoded = v(i);\n-        let mut buf1 = [0; 1024];\n-        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n-            let mut buf2 = [0; 1024];\n-            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n-            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n-                npassed += 1;\n-            } else {\n-                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n-                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n-                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n-            }\n-        } else {\n-            nignored += 1;\n-        }\n-    }\n-    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n-             func, k, nignored, npassed, n - nignored - npassed);\n-    assert!(nignored + npassed == n,\n-            \"{}({}): {} out of {} values returns an incorrect value!\",\n-            func, k, n - nignored - npassed, n);\n-    (npassed, nignored)\n-}\n-\n-pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n-    let f32_range = Range::new(0x0000_0001u32, 0x7f80_0000);\n-    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n-        let i: u32 = f32_range.ind_sample(&mut rng);\n-        let x: f32 = unsafe {mem::transmute(i)};\n-        decode_finite(x)\n-    });\n-}\n-\n-pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n-    let f64_range = Range::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n-    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n-        let i: u64 = f64_range.ind_sample(&mut rng);\n-        let x: f64 = unsafe {mem::transmute(i)};\n-        decode_finite(x)\n-    });\n-}\n-\n-pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n-    // so why not simply testing all of them?\n-    //\n-    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n-    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n-\n-    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n-    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n-                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n-        let x: f32 = unsafe {mem::transmute(i as u32 + 1)};\n-        decode_finite(x)\n-    });\n-    assert_eq!((npassed, nignored), (2121451881, 17643158));\n-}\n-\n fn to_string_with_parts<F>(mut f: F) -> String\n         where F: for<'a> FnMut(&'a mut [u8], &'a mut [Part<'a>]) -> Formatted<'a> {\n     let mut buf = [0; 1024];"}, {"sha": "286b39d8cf3b3ba8d9c684d07f0d3fe662b62780", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::i16;\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n@@ -46,35 +45,6 @@ fn shortest_sanity_test() {\n     more_shortest_sanity_test(format_shortest);\n }\n \n-#[test]\n-fn shortest_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n-    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n-}\n-\n-#[test] #[ignore] // it is too expensive\n-fn shortest_f32_exhaustive_equivalence_test() {\n-    // it is hard to directly test the optimality of the output, but we can at least test if\n-    // two different algorithms agree to each other.\n-    //\n-    // this reports the progress and the number of f32 values returned `None`.\n-    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n-    // `done, ignored=17643158 passed=2121451881 failed=0`.\n-\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n-}\n-\n-#[test] #[ignore] // it is too expensive\n-fn shortest_f64_hard_random_equivalence_test() {\n-    // this again probably has to use appropriate rustc flags.\n-\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback,\n-                                         MAX_SIG_DIGITS, 100_000_000);\n-}\n-\n #[test]\n fn exact_sanity_test() {\n     // See comments in dragon.rs's exact_sanity_test for why this test is\n@@ -85,24 +55,6 @@ fn exact_sanity_test() {\n     f32_exact_sanity_test(format_exact);\n }\n \n-#[test]\n-fn exact_f32_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    for k in 1..21 {\n-        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n-    }\n-}\n-\n-#[test]\n-fn exact_f64_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    for k in 1..21 {\n-        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n-    }\n-}\n-\n #[test]\n fn test_to_shortest_str() {\n     to_shortest_str_test(format_shortest);"}, {"sha": "7eb5ff988577766058c656e5d681f40319792448", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::convert::TryFrom;\n+use core::convert::{TryFrom, TryInto};\n use core::cmp::PartialEq;\n use core::fmt::Debug;\n use core::marker::Copy;\n+use core::num::TryFromIntError;\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::option::Option;\n use core::option::Option::{Some, None};\n@@ -134,6 +135,13 @@ fn test_empty() {\n     assert_eq!(\"\".parse::<u8>().ok(), None);\n }\n \n+#[test]\n+fn test_infallible_try_from_int_error() {\n+    let func = |x: i8| -> Result<i32, TryFromIntError> { Ok(x.try_into()?) };\n+\n+    assert!(func(0).is_ok());\n+}\n+\n macro_rules! test_impl_from {\n     ($fn_name: ident, $Small: ty, $Large: ty) => {\n         #[test]"}, {"sha": "22109e28edd9b810534dffb3cbf371b77945b5f6", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -270,3 +270,30 @@ fn test_cloned() {\n     assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1));\n }\n+\n+#[test]\n+fn test_try() {\n+    fn try_option_some() -> Option<u8> {\n+        let val = Some(1)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_option_some(), Some(1));\n+\n+    fn try_option_none() -> Option<u8> {\n+        let val = None?;\n+        Some(val)\n+    }\n+    assert_eq!(try_option_none(), None);\n+\n+    fn try_option_ok() -> Result<u8, NoneError> {\n+        let val = Some(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_option_ok(), Ok(1));\n+\n+    fn try_option_err() -> Result<u8, NoneError> {\n+        let val = None?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_option_err(), Err(NoneError));\n+}"}, {"sha": "98436f0e1d1cd968d613e70acfe8995c8b8a5257", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -62,6 +62,39 @@ fn test_is_null() {\n \n     let mq = unsafe { mp.offset(1) };\n     assert!(!mq.is_null());\n+\n+    // Pointers to unsized types -- slices\n+    let s: &mut [u8] = &mut [1, 2, 3];\n+    let cs: *const [u8] = s;\n+    assert!(!cs.is_null());\n+\n+    let ms: *mut [u8] = s;\n+    assert!(!ms.is_null());\n+\n+    let cz: *const [u8] = &[];\n+    assert!(!cz.is_null());\n+\n+    let mz: *mut [u8] = &mut [];\n+    assert!(!mz.is_null());\n+\n+    let ncs: *const [u8] = null::<[u8; 3]>();\n+    assert!(ncs.is_null());\n+\n+    let nms: *mut [u8] = null_mut::<[u8; 3]>();\n+    assert!(nms.is_null());\n+\n+    // Pointers to unsized types -- trait objects\n+    let ci: *const ToString = &3;\n+    assert!(!ci.is_null());\n+\n+    let mi: *mut ToString = &mut 3;\n+    assert!(!mi.is_null());\n+\n+    let nci: *const ToString = null::<isize>();\n+    assert!(nci.is_null());\n+\n+    let nmi: *mut ToString = null_mut::<isize>();\n+    assert!(nmi.is_null());\n }\n \n #[test]\n@@ -85,6 +118,39 @@ fn test_as_ref() {\n             let p = &u as *const isize;\n             assert_eq!(p.as_ref().unwrap(), &2);\n         }\n+\n+        // Pointers to unsized types -- slices\n+        let s: &mut [u8] = &mut [1, 2, 3];\n+        let cs: *const [u8] = s;\n+        assert_eq!(cs.as_ref(), Some(&*s));\n+\n+        let ms: *mut [u8] = s;\n+        assert_eq!(ms.as_ref(), Some(&*s));\n+\n+        let cz: *const [u8] = &[];\n+        assert_eq!(cz.as_ref(), Some(&[][..]));\n+\n+        let mz: *mut [u8] = &mut [];\n+        assert_eq!(mz.as_ref(), Some(&[][..]));\n+\n+        let ncs: *const [u8] = null::<[u8; 3]>();\n+        assert_eq!(ncs.as_ref(), None);\n+\n+        let nms: *mut [u8] = null_mut::<[u8; 3]>();\n+        assert_eq!(nms.as_ref(), None);\n+\n+        // Pointers to unsized types -- trait objects\n+        let ci: *const ToString = &3;\n+        assert!(ci.as_ref().is_some());\n+\n+        let mi: *mut ToString = &mut 3;\n+        assert!(mi.as_ref().is_some());\n+\n+        let nci: *const ToString = null::<isize>();\n+        assert!(nci.as_ref().is_none());\n+\n+        let nmi: *mut ToString = null_mut::<isize>();\n+        assert!(nmi.as_ref().is_none());\n     }\n }\n \n@@ -103,6 +169,24 @@ fn test_as_mut() {\n             let p = &mut u as *mut isize;\n             assert!(p.as_mut().unwrap() == &mut 2);\n         }\n+\n+        // Pointers to unsized types -- slices\n+        let s: &mut [u8] = &mut [1, 2, 3];\n+        let ms: *mut [u8] = s;\n+        assert_eq!(ms.as_mut(), Some(s));\n+\n+        let mz: *mut [u8] = &mut [];\n+        assert_eq!(mz.as_mut(), Some(&mut [][..]));\n+\n+        let nms: *mut [u8] = null_mut::<[u8; 3]>();\n+        assert_eq!(nms.as_mut(), None);\n+\n+        // Pointers to unsized types -- trait objects\n+        let mi: *mut ToString = &mut 3;\n+        assert!(mi.as_mut().is_some());\n+\n+        let nmi: *mut ToString = null_mut::<isize>();\n+        assert!(nmi.as_mut().is_none());\n     }\n }\n "}, {"sha": "ce41bde8342edbbe2784cc4dc6a695d77a0a6d6f", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::option::*;\n+\n fn op1() -> Result<isize, &'static str> { Ok(666) }\n fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n@@ -202,3 +204,30 @@ pub fn test_unwrap_or_default() {\n     assert_eq!(op1().unwrap_or_default(), 666);\n     assert_eq!(op2().unwrap_or_default(), 0);\n }\n+\n+#[test]\n+fn test_try() {\n+    fn try_result_some() -> Option<u8> {\n+        let val = Ok(1)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_result_some(), Some(1));\n+\n+    fn try_result_none() -> Option<u8> {\n+        let val = Err(NoneError)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_result_none(), None);\n+\n+    fn try_result_ok() -> Result<u8, u8> {\n+        let val = Ok(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_result_ok(), Ok(1));\n+\n+    fn try_result_err() -> Result<u8, u8> {\n+        let val = Err(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_result_err(), Err(1));\n+}"}, {"sha": "fa4c2e9b3736f8298b8b16b4457dcca9c1ae9a81", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 67, "deletions": 81, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -8,29 +8,63 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::Ordering::{Equal, Greater, Less};\n-use core::slice::heapsort;\n use core::result::Result::{Ok, Err};\n-use rand::{Rng, XorShiftRng};\n \n #[test]\n fn test_binary_search() {\n+    let b: [i32; 0] = [];\n+    assert_eq!(b.binary_search(&5), Err(0));\n+\n+    let b = [4];\n+    assert_eq!(b.binary_search(&3), Err(0));\n+    assert_eq!(b.binary_search(&4), Ok(0));\n+    assert_eq!(b.binary_search(&5), Err(1));\n+\n     let b = [1, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n-    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n+    assert_eq!(b.binary_search(&5), Err(3));\n+    assert_eq!(b.binary_search(&6), Ok(3));\n+    assert_eq!(b.binary_search(&7), Err(4));\n+    assert_eq!(b.binary_search(&8), Ok(4));\n+\n+    let b = [1, 2, 4, 5, 6, 8];\n+    assert_eq!(b.binary_search(&9), Err(6));\n+\n     let b = [1, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n+    assert_eq!(b.binary_search(&6), Ok(3));\n+    assert_eq!(b.binary_search(&5), Err(3));\n+    assert_eq!(b.binary_search(&8), Ok(5));\n+\n     let b = [1, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n-    assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n-    let b = [1, 2, 4, 5, 6, 8];\n-    assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n+    assert_eq!(b.binary_search(&7), Err(5));\n+    assert_eq!(b.binary_search(&0), Err(0));\n+\n+    let b = [1, 3, 3, 3, 7];\n+    assert_eq!(b.binary_search(&0), Err(0));\n+    assert_eq!(b.binary_search(&1), Ok(0));\n+    assert_eq!(b.binary_search(&2), Err(1));\n+    assert!(match b.binary_search(&3) { Ok(1...3) => true, _ => false });\n+    assert!(match b.binary_search(&3) { Ok(1...3) => true, _ => false });\n+    assert_eq!(b.binary_search(&4), Err(4));\n+    assert_eq!(b.binary_search(&5), Err(4));\n+    assert_eq!(b.binary_search(&6), Err(4));\n+    assert_eq!(b.binary_search(&7), Ok(4));\n+    assert_eq!(b.binary_search(&8), Err(5));\n+}\n+\n+#[test]\n+// Test implementation specific behavior when finding equivalent elements.\n+// It is ok to break this test but when you do a crater run is highly advisable.\n+fn test_binary_search_implementation_details() {\n+    let b = [1, 1, 2, 2, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(1));\n+    assert_eq!(b.binary_search(&2), Ok(3));\n+    assert_eq!(b.binary_search(&3), Ok(6));\n+    let b = [1, 1, 1, 1, 1, 3, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(4));\n+    assert_eq!(b.binary_search(&3), Ok(8));\n+    let b = [1, 1, 1, 1, 3, 3, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(3));\n+    assert_eq!(b.binary_search(&3), Ok(8));\n }\n \n #[test]\n@@ -238,6 +272,23 @@ fn test_find_rfind() {\n     assert_eq!(v.iter().rfind(|&&x| x <= 3), Some(&3));\n }\n \n+#[test]\n+fn test_iter_folds() {\n+    let a = [1, 2, 3, 4, 5]; // len>4 so the unroll is used\n+    assert_eq!(a.iter().fold(0, |acc, &x| 2*acc + x), 57);\n+    assert_eq!(a.iter().rfold(0, |acc, &x| 2*acc + x), 129);\n+    let fold = |acc: i32, &x| acc.checked_mul(2)?.checked_add(x);\n+    assert_eq!(a.iter().try_fold(0, &fold), Some(57));\n+    assert_eq!(a.iter().try_rfold(0, &fold), Some(129));\n+\n+    // short-circuiting try_fold, through other methods\n+    let a = [0, 1, 2, 3, 5, 5, 5, 7, 8, 9];\n+    let mut iter = a.iter();\n+    assert_eq!(iter.position(|&x| x == 3), Some(3));\n+    assert_eq!(iter.rfind(|&&x| x == 5), Some(&5));\n+    assert_eq!(iter.len(), 2);\n+}\n+\n #[test]\n fn test_rotate() {\n     const N: usize = 600;\n@@ -253,68 +304,3 @@ fn test_rotate() {\n         assert_eq!(a[(i+k)%N], i);\n     }\n }\n-\n-#[test]\n-fn sort_unstable() {\n-    let mut v = [0; 600];\n-    let mut tmp = [0; 600];\n-    let mut rng = XorShiftRng::new_unseeded();\n-\n-    for len in (2..25).chain(500..510) {\n-        let v = &mut v[0..len];\n-        let tmp = &mut tmp[0..len];\n-\n-        for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..100 {\n-                for i in 0..len {\n-                    v[i] = rng.gen::<i32>() % modulus;\n-                }\n-\n-                // Sort in default order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable();\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in ascending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| a.cmp(b));\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in descending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| b.cmp(a));\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-\n-                // Test heapsort using `<` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a < b);\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Test heapsort using `>` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a > b);\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-            }\n-        }\n-    }\n-\n-    // Sort using a completely random comparison function.\n-    // This will reorder the elements *somehow*, but won't panic.\n-    for i in 0..v.len() {\n-        v[i] = i as i32;\n-    }\n-    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n-    v.sort_unstable();\n-    for i in 0..v.len() {\n-        assert_eq!(v[i], i as i32);\n-    }\n-\n-    // Should not panic.\n-    [0i32; 0].sort_unstable();\n-    [(); 10].sort_unstable();\n-    [(); 100].sort_unstable();\n-\n-    let mut v = [0xDEADBEEFu64];\n-    v.sort_unstable();\n-    assert!(v == [0xDEADBEEF]);\n-}"}, {"sha": "087ddf9688ab7da8fe40aeaee334ceaa5907402c", "filename": "src/libcore/unit.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use iter::FromIterator;\n+\n+/// Collapses all unit items from an iterator into one.\n+///\n+/// This is more useful when combined with higher-level abstractions, like\n+/// collecting to a `Result<(), E>` where you only care about errors:\n+///\n+/// ```\n+/// use std::io::*;\n+/// let data = vec![1, 2, 3, 4, 5];\n+/// let res: Result<()> = data.iter()\n+///     .map(|x| writeln!(stdout(), \"{}\", x))\n+///     .collect();\n+/// assert!(res.is_ok());\n+/// ```\n+#[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\n+impl FromIterator<()> for () {\n+    fn from_iter<I: IntoIterator<Item=()>>(iter: I) -> Self {\n+        iter.into_iter().for_each(|()| {})\n+    }\n+}"}, {"sha": "44cdb5e8a3676b23e6ead56ebedbdcf7ff9cf5f5", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -73,7 +73,9 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The argument is located at a specific index.\n+    /// The arugment is implied to be located at an index\n+    ArgumentImplicitlyIs(usize),\n+    /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n     ArgumentNamed(&'a str),\n@@ -275,7 +277,7 @@ impl<'a> Parser<'a> {\n             None => {\n                 let i = self.curarg;\n                 self.curarg += 1;\n-                ArgumentIs(i)\n+                ArgumentImplicitlyIs(i)\n             }\n         };\n \n@@ -517,7 +519,7 @@ mod tests {\n     fn format_nothing() {\n         same(\"{}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: fmtdflt(),\n                })]);\n     }\n@@ -595,7 +597,7 @@ mod tests {\n     fn format_counts() {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -607,7 +609,7 @@ mod tests {\n                })]);\n         same(\"{:10$.10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -619,7 +621,7 @@ mod tests {\n                })]);\n         same(\"{:.*s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(1),\n+                   position: ArgumentImplicitlyIs(1),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -631,7 +633,7 @@ mod tests {\n                })]);\n         same(\"{:.10$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -643,7 +645,7 @@ mod tests {\n                })]);\n         same(\"{:a$.b$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -658,7 +660,7 @@ mod tests {\n     fn format_flags() {\n         same(\"{:-}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -670,7 +672,7 @@ mod tests {\n                })]);\n         same(\"{:+#}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,"}, {"sha": "81fa0374f549e903f5384737f1d000d6c4a8ba2d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -731,7 +731,9 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             }\n         }\n \n-        // FIXME: #5516 should be graphemes not codepoints\n+        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n+        // should be graphemes not codepoints\n+        //\n         // here we just need to indent the start of the description\n         let rowlen = row.chars().count();\n         if rowlen < 24 {\n@@ -749,14 +751,17 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             desc_normalized_whitespace.push(' ');\n         }\n \n-        // FIXME: #5516 should be graphemes not codepoints\n+        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n+        // should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n         each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n             desc_rows.push(substr.to_owned());\n             true\n         });\n \n-        // FIXME: #5516 should be graphemes not codepoints\n+        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n+        // should be graphemes not codepoints\n+        //\n         // wrapped description\n         row.push_str(&desc_rows.join(&desc_sep[..]));\n "}, {"sha": "1a2f9639f8d293cefbe050053a574decbfe863f7", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -1 +1 @@\n-Subproject commit 44e4018e1a37716286ec98cb5b7dd7d33ecaf940\n+Subproject commit 1a2f9639f8d293cefbe050053a574decbfe863f7"}, {"sha": "29a9e1aadaf3c94b8e911c5afac3b045db9efffc", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -20,13 +20,13 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n #![deny(warnings)]\n-\n-#![feature(staged_api)]\n-\n #![panic_runtime]\n+#![allow(unused_features)]\n+\n+#![feature(core_intrinsics)]\n+#![feature(libc)]\n #![feature(panic_runtime)]\n-#![cfg_attr(unix, feature(libc))]\n-#![cfg_attr(any(target_os = \"redox\", windows), feature(core_intrinsics))]\n+#![feature(staged_api)]\n \n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n@@ -59,7 +59,9 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n         libc::abort();\n     }\n \n-    #[cfg(any(target_os = \"redox\", windows))]\n+    #[cfg(any(target_os = \"redox\",\n+              windows,\n+              all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }\n@@ -92,7 +94,6 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {\n-\n     #[no_mangle]\n     #[cfg(not(all(target_os = \"windows\",\n                   target_env = \"gnu\","}, {"sha": "6b8da7a51ceb8c2f2696f9ac1950b515a6969d87", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -34,9 +34,7 @@\n #![feature(core_intrinsics)]\n #![feature(lang_items)]\n #![feature(libc)]\n-#![cfg_attr(not(any(target_env = \"msvc\",\n-                    all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))),\n-            feature(panic_unwind))]\n+#![feature(panic_unwind)]\n #![feature(raw)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n@@ -80,6 +78,10 @@ mod imp;\n #[path = \"emcc.rs\"]\n mod imp;\n \n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+#[path = \"wasm32.rs\"]\n+mod imp;\n+\n mod dwarf;\n mod windows;\n "}, {"sha": "8aed61b3c385a954b07e116c71859ab7d66cc621", "filename": "src/libpanic_unwind/wasm32.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_unwind%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibpanic_unwind%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwasm32.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwinding for wasm32\n+//!\n+//! Right now we don't support this, so this is just stubs\n+\n+use alloc::boxed::Box;\n+use core::any::Any;\n+use core::intrinsics;\n+\n+pub fn payload() -> *mut u8 {\n+    0 as *mut u8\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<Any + Send> {\n+    intrinsics::abort()\n+}\n+\n+pub unsafe fn panic(_data: Box<Any + Send>) -> u32 {\n+    intrinsics::abort()\n+}"}, {"sha": "4a6841aedca1299a33bce3f8ede40a90e5025850", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 137, "deletions": 11, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -50,6 +50,7 @@ mod diagnostic;\n pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n+use std::rc::Rc;\n use std::str::FromStr;\n \n use syntax::ast;\n@@ -58,7 +59,7 @@ use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::DUMMY_SP;\n-use syntax_pos::SyntaxContext;\n+use syntax_pos::{FileMap, Pos, SyntaxContext};\n use syntax_pos::hygiene::Mark;\n \n /// The main type provided by this crate, representing an abstract stream of\n@@ -94,7 +95,7 @@ impl FromStr for TokenStream {\n             // notify the expansion info that it is unhygienic\n             let mark = Mark::fresh(mark);\n             mark.set_expn_info(expn_info);\n-            let span = call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n+            let span = call_site.with_ctxt(call_site.ctxt().apply_mark(mark));\n             let stream = parse::parse_stream_from_source_str(name, src, sess, Some(span));\n             Ok(__internal::token_stream_wrap(stream))\n         })\n@@ -173,12 +174,13 @@ impl TokenStream {\n \n /// A region of source code, along with macro expansion information.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Span(syntax_pos::Span);\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl Default for Span {\n-    fn default() -> Span {\n+impl Span {\n+    /// A span that resolves at the macro definition site.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn def_site() -> Span {\n         ::__internal::with_sess(|(_, mark)| {\n             let call_site = mark.expn_info().unwrap().call_site;\n             Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n@@ -190,7 +192,7 @@ impl Default for Span {\n /// This is needed to implement a custom quoter.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub fn quote_span(span: Span) -> TokenStream {\n-    TokenStream(quote::Quote::quote(&span.0))\n+    quote::Quote::quote(span)\n }\n \n macro_rules! diagnostic_method {\n@@ -211,12 +213,132 @@ impl Span {\n         ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n     }\n \n+    /// The original source file into which this span points.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn source_file(&self) -> SourceFile {\n+        SourceFile {\n+            filemap: __internal::lookup_char_pos(self.0.lo()).file,\n+        }\n+    }\n+\n+    /// Get the starting line/column in the source file for this span.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn start(&self) -> LineColumn {\n+        let loc = __internal::lookup_char_pos(self.0.lo());\n+        LineColumn {\n+            line: loc.line,\n+            column: loc.col.to_usize()\n+        }\n+    }\n+\n+    /// Get the ending line/column in the source file for this span.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn end(&self) -> LineColumn {\n+        let loc = __internal::lookup_char_pos(self.0.hi());\n+        LineColumn {\n+            line: loc.line,\n+            column: loc.col.to_usize()\n+        }\n+    }\n+\n+    /// Create a new span encompassing `self` and `other`.\n+    ///\n+    /// Returns `None` if `self` and `other` are from different files.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn join(&self, other: Span) -> Option<Span> {\n+        let self_loc = __internal::lookup_char_pos(self.0.lo());\n+        let other_loc = __internal::lookup_char_pos(self.0.lo());\n+\n+        if self_loc.file.name != other_loc.file.name { return None }\n+\n+        Some(Span(self.0.to(other.0)))\n+    }\n+\n     diagnostic_method!(error, Level::Error);\n     diagnostic_method!(warning, Level::Warning);\n     diagnostic_method!(note, Level::Note);\n     diagnostic_method!(help, Level::Help);\n }\n \n+/// A line-column pair representing the start or end of a `Span`.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineColumn {\n+    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n+    line: usize,\n+    /// The 0-indexed column (in UTF-8 characters) in the source file on which\n+    /// the span starts or ends (inclusive).\n+    column: usize\n+}\n+\n+/// The source file of a given `Span`.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Clone)]\n+pub struct SourceFile {\n+    filemap: Rc<FileMap>,\n+}\n+\n+impl SourceFile {\n+    /// Get the path to this source file as a string.\n+    ///\n+    /// ### Note\n+    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n+    /// may not be an actual path on the filesystem. Use [`is_real`] to check.\n+    ///\n+    /// Also note that even if `is_real` returns `true`, if `-Z remap-path-prefix-*` was passed on\n+    /// the command line, the path as given may not actually be valid.\n+    ///\n+    /// [`is_real`]: #method.is_real\n+    # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn as_str(&self) -> &str {\n+        &self.filemap.name\n+    }\n+\n+    /// Returns `true` if this source file is a real source file, and not generated by an external\n+    /// macro's expansion.\n+    # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn is_real(&self) -> bool {\n+        // This is a hack until intercrate spans are implemented and we can have real source files\n+        // for spans generated in external macros.\n+        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n+        self.filemap.is_real_file()\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl AsRef<str> for SourceFile {\n+    fn as_ref(&self) -> &str {\n+        self.as_str()\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl fmt::Debug for SourceFile {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SourceFile\")\n+            .field(\"path\", &self.as_str())\n+            .field(\"is_real\", &self.is_real())\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl PartialEq for SourceFile {\n+    fn eq(&self, other: &Self) -> bool {\n+        Rc::ptr_eq(&self.filemap, &other.filemap)\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl Eq for SourceFile {}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl PartialEq<str> for SourceFile {\n+    fn eq(&self, other: &str) -> bool {\n+        self.as_ref() == other\n+    }\n+}\n+\n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone, Debug)]\n@@ -230,7 +352,7 @@ pub struct TokenTree {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<TokenNode> for TokenTree {\n     fn from(kind: TokenNode) -> TokenTree {\n-        TokenTree { span: Span::default(), kind: kind }\n+        TokenTree { span: Span::def_site(), kind: kind }\n     }\n }\n \n@@ -367,7 +489,7 @@ impl Literal {\n     pub fn string(string: &str) -> Literal {\n         let mut escaped = String::new();\n         for ch in string.chars() {\n-            escaped.extend(ch.escape_unicode());\n+            escaped.extend(ch.escape_debug());\n         }\n         Literal(token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None))\n     }\n@@ -607,7 +729,7 @@ impl TokenTree {\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod __internal {\n-    pub use quote::{Quoter, __rt};\n+    pub use quote::{LiteralKind, Quoter, unquote};\n \n     use std::cell::Cell;\n \n@@ -618,10 +740,14 @@ pub mod __internal {\n     use syntax::parse::{self, ParseSess};\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n-    use syntax_pos::DUMMY_SP;\n+    use syntax_pos::{BytePos, Loc, DUMMY_SP};\n \n     use super::{TokenStream, LexError};\n \n+    pub fn lookup_char_pos(pos: BytePos) -> Loc {\n+        with_sess(|(sess, _)| sess.codemap().lookup_char_pos(pos))\n+    }\n+\n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n         let token = Token::interpolated(token::NtItem(item));\n         TokenStream(tokenstream::TokenTree::Token(DUMMY_SP, token).into())"}, {"sha": "8b5add1a0f0d70744261b96b37dcede510ca91ba", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 156, "deletions": 154, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -11,253 +11,255 @@\n //! # Quasiquoter\n //! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n \n-//! This quasiquoter uses macros 2.0 hygiene to reliably use items from `__rt`,\n-//! including re-exported API `libsyntax`, to build a `syntax::tokenstream::TokenStream`\n-//! and wrap it into a `proc_macro::TokenStream`.\n+//! This quasiquoter uses macros 2.0 hygiene to reliably access\n+//! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n+\n+use {Delimiter, Literal, Spacing, Span, Term, TokenNode, TokenStream, TokenTree};\n \n-use syntax::ast::Ident;\n use syntax::ext::base::{ExtCtxt, ProcMacro};\n-use syntax::parse::token::{self, Token, Lit};\n-use syntax::symbol::Symbol;\n-use syntax::tokenstream::{Delimited, TokenTree, TokenStream, TokenStreamBuilder};\n-use syntax_pos::{DUMMY_SP, Span};\n-use syntax_pos::hygiene::SyntaxContext;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n \n pub struct Quoter;\n \n-pub mod __rt {\n-    pub use syntax::ast::Ident;\n-    pub use syntax::parse::token;\n-    pub use syntax::symbol::Symbol;\n-    pub use syntax::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree, Delimited};\n-    pub use super::{ctxt, span};\n-\n-    pub fn unquote<T: Into<::TokenStream> + Clone>(tokens: &T) -> TokenStream {\n-        T::into(tokens.clone()).0\n-    }\n-}\n-\n-pub fn ctxt() -> SyntaxContext {\n-    ::__internal::with_sess(|(_, mark)| SyntaxContext::empty().apply_mark(mark))\n-}\n-\n-pub fn span() -> Span {\n-    ::Span::default().0\n+pub fn unquote<T: Into<TokenStream> + Clone>(tokens: &T) -> TokenStream {\n+    T::into(tokens.clone())\n }\n \n pub trait Quote {\n-    fn quote(&self) -> TokenStream;\n+    fn quote(self) -> TokenStream;\n }\n \n macro_rules! quote_tok {\n-    (,) => { Token::Comma };\n-    (.) => { Token::Dot };\n-    (:) => { Token::Colon };\n-    (::) => { Token::ModSep };\n-    (!) => { Token::Not };\n-    (<) => { Token::Lt };\n-    (>) => { Token::Gt };\n-    (_) => { Token::Underscore };\n-    (0) => { Token::Literal(token::Lit::Integer(Symbol::intern(\"0\")), None) };\n-    (&) => { Token::BinOp(token::And) };\n-    ($i:ident) => { Token::Ident(Ident { name: Symbol::intern(stringify!($i)), ctxt: ctxt() }) };\n+    (,) => { TokenNode::Op(',', Spacing::Alone) };\n+    (.) => { TokenNode::Op('.', Spacing::Alone) };\n+    (:) => { TokenNode::Op(':', Spacing::Alone) };\n+    (::) => {\n+        [\n+            TokenNode::Op(':', Spacing::Joint),\n+            TokenNode::Op(':', Spacing::Alone)\n+        ].iter().cloned().collect::<TokenStream>()\n+    };\n+    (!) => { TokenNode::Op('!', Spacing::Alone) };\n+    (<) => { TokenNode::Op('<', Spacing::Alone) };\n+    (>) => { TokenNode::Op('>', Spacing::Alone) };\n+    (_) => { TokenNode::Op('_', Spacing::Alone) };\n+    (0) => { TokenNode::Literal(::Literal::integer(0)) };\n+    (&) => { TokenNode::Op('&', Spacing::Alone) };\n+    ($i:ident) => { TokenNode::Term(Term::intern(stringify!($i))) };\n }\n \n macro_rules! quote_tree {\n-    ((unquote $($t:tt)*)) => { TokenStream::from($($t)*) };\n+    ((unquote $($t:tt)*)) => { $($t)* };\n     ((quote $($t:tt)*)) => { ($($t)*).quote() };\n-    (($($t:tt)*)) => { delimit(token::Paren, quote!($($t)*)) };\n-    ([$($t:tt)*]) => { delimit(token::Bracket, quote!($($t)*)) };\n-    ({$($t:tt)*}) => { delimit(token::Brace, quote!($($t)*)) };\n-    (rt) => { quote!(::__internal::__rt) };\n-    ($t:tt) => { TokenStream::from(TokenTree::Token(span(), quote_tok!($t))) };\n-}\n-\n-fn delimit(delim: token::DelimToken, stream: TokenStream) -> TokenStream {\n-    TokenTree::Delimited(span(), Delimited { delim: delim, tts: stream.into() }).into()\n+    (($($t:tt)*)) => { TokenNode::Group(Delimiter::Parenthesis, quote!($($t)*)) };\n+    ([$($t:tt)*]) => { TokenNode::Group(Delimiter::Bracket, quote!($($t)*)) };\n+    ({$($t:tt)*}) => { TokenNode::Group(Delimiter::Brace, quote!($($t)*)) };\n+    ($t:tt) => { quote_tok!($t) };\n }\n \n macro_rules! quote {\n     () => { TokenStream::empty() };\n-    ($($t:tt)*) => { [ $( quote_tree!($t), )* ].iter().cloned().collect::<TokenStream>() };\n+    ($($t:tt)*) => {\n+        [\n+            $(TokenStream::from(quote_tree!($t)),)*\n+        ].iter().cloned().collect::<TokenStream>()\n+    };\n }\n \n impl ProcMacro for Quoter {\n-    fn expand<'cx>(&self, cx: &'cx mut ExtCtxt, _: Span, stream: TokenStream) -> TokenStream {\n+    fn expand<'cx>(&self, cx: &'cx mut ExtCtxt,\n+                   _: ::syntax_pos::Span,\n+                   stream: tokenstream::TokenStream)\n+                   -> tokenstream::TokenStream {\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n         info.callee.allow_internal_unstable = true;\n         cx.current_expansion.mark.set_expn_info(info);\n-        ::__internal::set_sess(cx, || quote!(::TokenStream { 0: (quote stream) }))\n+        ::__internal::set_sess(cx, || TokenStream(stream).quote().0)\n     }\n }\n \n impl<T: Quote> Quote for Option<T> {\n-    fn quote(&self) -> TokenStream {\n-        match *self {\n-            Some(ref t) => quote!(Some((quote t))),\n+    fn quote(self) -> TokenStream {\n+        match self {\n+            Some(t) => quote!(Some((quote t))),\n             None => quote!(None),\n         }\n     }\n }\n \n impl Quote for TokenStream {\n-    fn quote(&self) -> TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        builder.push(quote!(rt::TokenStreamBuilder::new()));\n-\n-        let mut trees = self.trees();\n-        loop {\n-            let (mut tree, mut is_joint) = match trees.next_as_stream() {\n-                Some(next) => next.as_tree(),\n-                None => return builder.add(quote!(.build())).build(),\n-            };\n-            if let TokenTree::Token(_, Token::Dollar) = tree {\n-                let (next_tree, next_is_joint) = match trees.next_as_stream() {\n-                    Some(next) => next.as_tree(),\n-                    None => panic!(\"unexpected trailing `$` in `quote!`\"),\n-                };\n-                match next_tree {\n-                    TokenTree::Token(_, Token::Ident(..)) => {\n-                        builder.push(quote!(.add(rt::unquote(&(unquote next_tree)))));\n-                        continue\n-                    }\n-                    TokenTree::Token(_, Token::Dollar) => {\n-                        tree = next_tree;\n-                        is_joint = next_is_joint;\n+    fn quote(self) -> TokenStream {\n+        if self.is_empty() {\n+            return quote!(::TokenStream::empty());\n+        }\n+        let mut after_dollar = false;\n+        let tokens = self.into_iter().filter_map(|tree| {\n+            if after_dollar {\n+                after_dollar = false;\n+                match tree.kind {\n+                    TokenNode::Term(_) => {\n+                        return Some(quote!(::__internal::unquote(&(unquote tree)),));\n                     }\n+                    TokenNode::Op('$', _) => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n                 }\n+            } else if let TokenNode::Op('$', _) = tree.kind {\n+                after_dollar = true;\n+                return None;\n             }\n \n-            builder.push(match is_joint {\n-                true => quote!(.add((quote tree).joint())),\n-                false => quote!(.add(rt::TokenStream::from((quote tree)))),\n-            });\n+            Some(quote!(::TokenStream::from((quote tree)),))\n+        }).collect::<TokenStream>();\n+\n+        if after_dollar {\n+            panic!(\"unexpected trailing `$` in `quote!`\");\n         }\n+\n+        quote!([(unquote tokens)].iter().cloned().collect::<::TokenStream>())\n     }\n }\n \n impl Quote for TokenTree {\n-    fn quote(&self) -> TokenStream {\n-        match *self {\n-            TokenTree::Token(span, ref token) => quote! {\n-                rt::TokenTree::Token((quote span), (quote token))\n-            },\n-            TokenTree::Delimited(span, ref delimited) => quote! {\n-                rt::TokenTree::Delimited((quote span), (quote delimited))\n-            },\n-        }\n+    fn quote(self) -> TokenStream {\n+        quote!(::TokenTree { span: (quote self.span), kind: (quote self.kind) })\n     }\n }\n \n-impl Quote for Delimited {\n-    fn quote(&self) -> TokenStream {\n-        quote!(rt::Delimited { delim: (quote self.delim), tts: (quote self.stream()).into() })\n+impl Quote for TokenNode {\n+    fn quote(self) -> TokenStream {\n+        macro_rules! gen_match {\n+            ($($i:ident($($arg:ident),+)),*) => {\n+                match self {\n+                    $(TokenNode::$i($($arg),+) => quote! {\n+                        ::TokenNode::$i($((quote $arg)),+)\n+                    },)*\n+                }\n+            }\n+        }\n+\n+        gen_match! { Op(op, kind), Group(delim, tokens), Term(term), Literal(lit) }\n     }\n }\n \n-impl<'a> Quote for &'a str {\n-    fn quote(&self) -> TokenStream {\n-        TokenTree::Token(span(), Token::Literal(token::Lit::Str_(Symbol::intern(self)), None))\n-            .into()\n+impl Quote for char {\n+    fn quote(self) -> TokenStream {\n+        TokenNode::Literal(Literal::character(self)).into()\n     }\n }\n \n-impl Quote for usize {\n-    fn quote(&self) -> TokenStream {\n-        let integer_symbol = Symbol::intern(&self.to_string());\n-        TokenTree::Token(DUMMY_SP, Token::Literal(token::Lit::Integer(integer_symbol), None))\n-            .into()\n+impl<'a> Quote for &'a str {\n+    fn quote(self) -> TokenStream {\n+        TokenNode::Literal(Literal::string(self)).into()\n     }\n }\n \n-impl Quote for Ident {\n-    fn quote(&self) -> TokenStream {\n-        quote!(rt::Ident { name: (quote self.name), ctxt: rt::ctxt() })\n+impl Quote for usize {\n+    fn quote(self) -> TokenStream {\n+        TokenNode::Literal(Literal::integer(self as i128)).into()\n     }\n }\n \n-impl Quote for Symbol {\n-    fn quote(&self) -> TokenStream {\n-        quote!(rt::Symbol::intern((quote &*self.as_str())))\n+impl Quote for Term {\n+    fn quote(self) -> TokenStream {\n+        quote!(::Term::intern((quote self.as_str())))\n     }\n }\n \n impl Quote for Span {\n-    fn quote(&self) -> TokenStream {\n-        quote!(rt::span())\n+    fn quote(self) -> TokenStream {\n+        quote!(::Span::def_site())\n     }\n }\n \n-impl Quote for Token {\n-    fn quote(&self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*; $($t:tt)*) => {\n-                match *self {\n-                    $( Token::$i => quote!(rt::token::$i), )*\n-                    $( $t )*\n+macro_rules! literals {\n+    ($($i:ident),*; $($raw:ident),*) => {\n+        pub enum LiteralKind {\n+            $($i,)*\n+            $($raw(usize),)*\n+        }\n+\n+        impl LiteralKind {\n+            pub fn with_contents_and_suffix(self, contents: Term, suffix: Option<Term>)\n+                                            -> Literal {\n+                let contents = contents.0;\n+                let suffix = suffix.map(|t| t.0);\n+                match self {\n+                    $(LiteralKind::$i => {\n+                        Literal(token::Literal(token::Lit::$i(contents), suffix))\n+                    })*\n+                    $(LiteralKind::$raw(n) => {\n+                        Literal(token::Literal(token::Lit::$raw(contents, n), suffix))\n+                    })*\n                 }\n             }\n         }\n \n-        gen_match! {\n-            Eq, Lt, Le, EqEq, Ne, Ge, Gt, AndAnd, OrOr, Not, Tilde, At, Dot, DotDot, DotDotDot,\n-            DotDotEq, Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar,\n-            Question, Underscore;\n-\n-            Token::OpenDelim(delim) => quote!(rt::token::OpenDelim((quote delim))),\n-            Token::CloseDelim(delim) => quote!(rt::token::CloseDelim((quote delim))),\n-            Token::BinOp(tok) => quote!(rt::token::BinOp((quote tok))),\n-            Token::BinOpEq(tok) => quote!(rt::token::BinOpEq((quote tok))),\n-            Token::Ident(ident) => quote!(rt::token::Ident((quote ident))),\n-            Token::Lifetime(ident) => quote!(rt::token::Lifetime((quote ident))),\n-            Token::Literal(lit, sfx) => quote!(rt::token::Literal((quote lit), (quote sfx))),\n-            _ => panic!(\"Unhandled case!\"),\n+        impl Literal {\n+            fn kind_contents_and_suffix(self) -> (LiteralKind, Term, Option<Term>) {\n+                let (lit, suffix) = match self.0 {\n+                    token::Literal(lit, suffix) => (lit, suffix),\n+                    _ => panic!(\"unsupported literal {:?}\", self.0),\n+                };\n+\n+                let (kind, contents) = match lit {\n+                    $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n+                    $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n+                };\n+                (kind, Term(contents), suffix.map(Term))\n+            }\n         }\n-    }\n-}\n \n-impl Quote for token::BinOpToken {\n-    fn quote(&self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident),*) => {\n-                match *self {\n-                    $( token::BinOpToken::$i => quote!(rt::token::BinOpToken::$i), )*\n+        impl Quote for LiteralKind {\n+            fn quote(self) -> TokenStream {\n+                match self {\n+                    $(LiteralKind::$i => quote! {\n+                        ::__internal::LiteralKind::$i\n+                    },)*\n+                    $(LiteralKind::$raw(n) => quote! {\n+                        ::__internal::LiteralKind::$raw((quote n))\n+                    },)*\n                 }\n             }\n         }\n \n-        gen_match!(Plus, Minus, Star, Slash, Percent, Caret, And, Or, Shl, Shr)\n+        impl Quote for Literal {\n+            fn quote(self) -> TokenStream {\n+                let (kind, contents, suffix) = self.kind_contents_and_suffix();\n+                quote! {\n+                    (quote kind).with_contents_and_suffix((quote contents), (quote suffix))\n+                }\n+            }\n+        }\n     }\n }\n \n-impl Quote for Lit {\n-    fn quote(&self) -> TokenStream {\n+literals!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw);\n+\n+impl Quote for Delimiter {\n+    fn quote(self) -> TokenStream {\n         macro_rules! gen_match {\n-            ($($i:ident),*; $($raw:ident),*) => {\n-                match *self {\n-                    $( Lit::$i(lit) => quote!(rt::token::Lit::$i((quote lit))), )*\n-                    $( Lit::$raw(lit, n) => {\n-                        quote!(::syntax::parse::token::Lit::$raw((quote lit), (quote n)))\n-                    })*\n+            ($($i:ident),*) => {\n+                match self {\n+                    $(Delimiter::$i => { quote!(::Delimiter::$i) })*\n                 }\n             }\n         }\n \n-        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw)\n+        gen_match!(Parenthesis, Brace, Bracket, None)\n     }\n }\n \n-impl Quote for token::DelimToken {\n-    fn quote(&self) -> TokenStream {\n+impl Quote for Spacing {\n+    fn quote(self) -> TokenStream {\n         macro_rules! gen_match {\n             ($($i:ident),*) => {\n-                match *self {\n-                    $(token::DelimToken::$i => { quote!(rt::token::DelimToken::$i) })*\n+                match self {\n+                    $(Spacing::$i => { quote!(::Spacing::$i) })*\n                 }\n             }\n         }\n \n-        gen_match!(Paren, Bracket, Brace, NoDelim)\n+        gen_match!(Alone, Joint)\n     }\n }"}, {"sha": "04f456917b95703b5eebe33a62e81baa864a36d7", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -15,4 +15,4 @@ doc = false\n core = { path = \"../libcore\" }\n \n [build-dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "dd88dd933f6911f50ebca356411c774d862e59d5", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "patch": "@@ -56,5 +56,5 @@ fn main() {\n         cfg.file(Path::new(\"../libcompiler_builtins/compiler-rt/lib/profile\").join(src));\n     }\n \n-    cfg.compile(\"libprofiler-rt.a\");\n+    cfg.compile(\"profiler-rt\");\n }"}, {"sha": "eda5f217565de80a1876fc146ff4d925fa63a159", "filename": "src/librand/Cargo.toml", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2FCargo.toml?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,12 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rand\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rand\"\n-path = \"lib.rs\"\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }"}, {"sha": "e355eb44e4667f292e4265e9393e09c07d13b5a4", "filename": "src/librand/chacha.rs", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,309 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The ChaCha random number generator.\n-\n-use core::fmt;\n-use {Rand, Rng, SeedableRng};\n-\n-const KEY_WORDS: usize = 8; // 8 words for the 256-bit key\n-const STATE_WORDS: usize = 16;\n-const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n-\n-/// A random number generator that uses the ChaCha20 algorithm [1].\n-///\n-/// The ChaCha algorithm is widely accepted as suitable for\n-/// cryptographic purposes, but this implementation has not been\n-/// verified as such. Prefer a generator like `OsRng` that defers to\n-/// the operating system for cases that need high security.\n-///\n-/// [1]: D. J. Bernstein, [*ChaCha, a variant of\n-/// Salsa20*](http://cr.yp.to/chacha.html)\n-#[derive(Copy, Clone)]\n-pub struct ChaChaRng {\n-    buffer: [u32; STATE_WORDS], // Internal buffer of output\n-    state: [u32; STATE_WORDS], // Initial state\n-    index: usize, // Index into state\n-}\n-\n-impl fmt::Debug for ChaChaRng {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ChaChaRng\")\n-         .field(\"buffer\", &self.buffer.iter())\n-         .field(\"state\", &self.state.iter())\n-         .field(\"index\", &self.index)\n-         .finish()\n-    }\n-}\n-\n-static EMPTY: ChaChaRng = ChaChaRng {\n-    buffer: [0; STATE_WORDS],\n-    state: [0; STATE_WORDS],\n-    index: STATE_WORDS,\n-};\n-\n-\n-macro_rules! quarter_round{\n-    ($a: expr, $b: expr, $c: expr, $d: expr) => {{\n-        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left(16);\n-        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left(12);\n-        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left( 8);\n-        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left( 7);\n-    }}\n-}\n-\n-macro_rules! double_round{\n-    ($x: expr) => {{\n-        // Column round\n-        quarter_round!($x[ 0], $x[ 4], $x[ 8], $x[12]);\n-        quarter_round!($x[ 1], $x[ 5], $x[ 9], $x[13]);\n-        quarter_round!($x[ 2], $x[ 6], $x[10], $x[14]);\n-        quarter_round!($x[ 3], $x[ 7], $x[11], $x[15]);\n-        // Diagonal round\n-        quarter_round!($x[ 0], $x[ 5], $x[10], $x[15]);\n-        quarter_round!($x[ 1], $x[ 6], $x[11], $x[12]);\n-        quarter_round!($x[ 2], $x[ 7], $x[ 8], $x[13]);\n-        quarter_round!($x[ 3], $x[ 4], $x[ 9], $x[14]);\n-    }}\n-}\n-\n-#[inline]\n-fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n-    *output = *input;\n-\n-    for _ in 0..CHACHA_ROUNDS / 2 {\n-        double_round!(output);\n-    }\n-\n-    for i in 0..STATE_WORDS {\n-        output[i] = output[i].wrapping_add(input[i]);\n-    }\n-}\n-\n-impl ChaChaRng {\n-    /// Create an ChaCha random number generator using the default\n-    /// fixed key of 8 zero words.\n-    pub fn new_unseeded() -> ChaChaRng {\n-        let mut rng = EMPTY;\n-        rng.init(&[0; KEY_WORDS]);\n-        rng\n-    }\n-\n-    /// Sets the internal 128-bit ChaCha counter to\n-    /// a user-provided value. This permits jumping\n-    /// arbitrarily ahead (or backwards) in the pseudorandom stream.\n-    ///\n-    /// Since the nonce words are used to extend the counter to 128 bits,\n-    /// users wishing to obtain the conventional ChaCha pseudorandom stream\n-    /// associated with a particular nonce can call this function with\n-    /// arguments `0, desired_nonce`.\n-    pub fn set_counter(&mut self, counter_low: u64, counter_high: u64) {\n-        self.state[12] = (counter_low >> 0) as u32;\n-        self.state[13] = (counter_low >> 32) as u32;\n-        self.state[14] = (counter_high >> 0) as u32;\n-        self.state[15] = (counter_high >> 32) as u32;\n-        self.index = STATE_WORDS; // force recomputation\n-    }\n-\n-    /// Initializes `self.state` with the appropriate key and constants\n-    ///\n-    /// We deviate slightly from the ChaCha specification regarding\n-    /// the nonce, which is used to extend the counter to 128 bits.\n-    /// This is provably as strong as the original cipher, though,\n-    /// since any distinguishing attack on our variant also works\n-    /// against ChaCha with a chosen-nonce. See the XSalsa20 [1]\n-    /// security proof for a more involved example of this.\n-    ///\n-    /// The modified word layout is:\n-    /// ```text\n-    /// constant constant constant constant\n-    /// key      key      key      key\n-    /// key      key      key      key\n-    /// counter  counter  counter  counter\n-    /// ```\n-    /// [1]: Daniel J. Bernstein. [*Extending the Salsa20\n-    /// nonce.*](http://cr.yp.to/papers.html#xsalsa)\n-    fn init(&mut self, key: &[u32; KEY_WORDS]) {\n-        self.state[0] = 0x61707865;\n-        self.state[1] = 0x3320646E;\n-        self.state[2] = 0x79622D32;\n-        self.state[3] = 0x6B206574;\n-\n-        for i in 0..KEY_WORDS {\n-            self.state[4 + i] = key[i];\n-        }\n-\n-        self.state[12] = 0;\n-        self.state[13] = 0;\n-        self.state[14] = 0;\n-        self.state[15] = 0;\n-\n-        self.index = STATE_WORDS;\n-    }\n-\n-    /// Refill the internal output buffer (`self.buffer`)\n-    fn update(&mut self) {\n-        core(&mut self.buffer, &self.state);\n-        self.index = 0;\n-        // update 128-bit counter\n-        self.state[12] += 1;\n-        if self.state[12] != 0 {\n-            return;\n-        }\n-        self.state[13] += 1;\n-        if self.state[13] != 0 {\n-            return;\n-        }\n-        self.state[14] += 1;\n-        if self.state[14] != 0 {\n-            return;\n-        }\n-        self.state[15] += 1;\n-    }\n-}\n-\n-impl Rng for ChaChaRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        if self.index == STATE_WORDS {\n-            self.update();\n-        }\n-\n-        let value = self.buffer[self.index % STATE_WORDS];\n-        self.index += 1;\n-        value\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n-    fn reseed(&mut self, seed: &'a [u32]) {\n-        // reset state\n-        self.init(&[0; KEY_WORDS]);\n-        // set key in place\n-        let key = &mut self.state[4..4 + KEY_WORDS];\n-        for (k, s) in key.iter_mut().zip(seed) {\n-            *k = *s;\n-        }\n-    }\n-\n-    /// Create a ChaCha generator from a seed,\n-    /// obtained from a variable-length u32 array.\n-    /// Only up to 8 words are used; if less than 8\n-    /// words are used, the remaining are set to zero.\n-    fn from_seed(seed: &'a [u32]) -> ChaChaRng {\n-        let mut rng = EMPTY;\n-        rng.reseed(seed);\n-        rng\n-    }\n-}\n-\n-impl Rand for ChaChaRng {\n-    fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n-        let mut key: [u32; KEY_WORDS] = [0; KEY_WORDS];\n-        for word in &mut key {\n-            *word = other.gen();\n-        }\n-        SeedableRng::from_seed(&key[..])\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::prelude::v1::*;\n-\n-    use {Rng, SeedableRng};\n-    use super::ChaChaRng;\n-\n-    #[test]\n-    fn test_rng_rand_seeded() {\n-        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(&*s);\n-        let mut rb: ChaChaRng = SeedableRng::from_seed(&*s);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded() {\n-        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-        let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_reseed() {\n-        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut r: ChaChaRng = SeedableRng::from_seed(&*s);\n-        let string1: String = r.gen_ascii_chars().take(100).collect();\n-\n-        r.reseed(&s);\n-\n-        let string2: String = r.gen_ascii_chars().take(100).collect();\n-        assert_eq!(string1, string2);\n-    }\n-\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_rng_true_values() {\n-        // Test vectors 1 and 2 from\n-        // http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-04\n-        let seed: &[_] = &[0; 8];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-\n-        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n-                        0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n-                        0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n-                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2]);\n-\n-        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n-                        0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n-                        0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n-                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b]);\n-\n-\n-        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-\n-        // Store the 17*i-th 32-bit word,\n-        // i.e., the i-th word of the i-th 16-word block\n-        let mut v: Vec<u32> = Vec::new();\n-        for _ in 0..16 {\n-            v.push(ra.next_u32());\n-            for _ in 0..16 {\n-                ra.next_u32();\n-            }\n-        }\n-\n-        assert_eq!(v,\n-                   vec![0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n-                        0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n-                        0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n-                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4]);\n-    }\n-\n-    #[test]\n-    fn test_rng_clone() {\n-        let seed: &[_] = &[0; 8];\n-        let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n-        let mut clone = rng.clone();\n-        for _ in 0..16 {\n-            assert_eq!(rng.next_u64(), clone.next_u64());\n-        }\n-    }\n-}"}, {"sha": "3337cc2a6273cf78731a7ad12b3f2ef46e91b543", "filename": "src/librand/distributions/exponential.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,155 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The exponential distribution.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Rand, Rng};\n-use distributions::{IndependentSample, Sample, ziggurat, ziggurat_tables};\n-\n-/// A wrapper around an `f64` to generate Exp(1) random numbers.\n-///\n-/// See `Exp` for the general exponential distribution. Note that this has to\n-/// be unwrapped before use as an `f64` (using either `*` or `mem::transmute`\n-/// is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n-/// exact description in the paper was adjusted to use tables for the\n-/// exponential distribution rather than normal.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-#[derive(Copy, Clone)]\n-pub struct Exp1(pub f64);\n-\n-// This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n-impl Rand for Exp1 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Exp1 {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            (-x).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R: Rng>(rng: &mut R, _u: f64) -> f64 {\n-            ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n-        }\n-\n-        Exp1(ziggurat(rng,\n-                      false,\n-                      &ziggurat_tables::ZIG_EXP_X,\n-                      &ziggurat_tables::ZIG_EXP_F,\n-                      pdf,\n-                      zero_case))\n-    }\n-}\n-\n-impl fmt::Debug for Exp1 {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Exp1\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-/// The exponential distribution `Exp(lambda)`.\n-///\n-/// This distribution has density function: `f(x) = lambda *\n-/// exp(-lambda * x)` for `x > 0`.\n-#[derive(Copy, Clone)]\n-pub struct Exp {\n-    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n-    lambda_inverse: f64,\n-}\n-\n-impl Exp {\n-    /// Construct a new `Exp` with the given shape parameter\n-    /// `lambda`. Panics if `lambda <= 0`.\n-    pub fn new(lambda: f64) -> Exp {\n-        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n-        Exp { lambda_inverse: 1.0 / lambda }\n-    }\n-}\n-\n-impl Sample<f64> for Exp {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Exp {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let Exp1(n) = rng.gen::<Exp1>();\n-        n * self.lambda_inverse\n-    }\n-}\n-\n-impl fmt::Debug for Exp {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Exp\")\n-         .field(\"lambda_inverse\", &self.lambda_inverse)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::Exp;\n-\n-    #[test]\n-    fn test_exp() {\n-        let mut exp = Exp::new(10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            assert!(exp.sample(&mut rng) >= 0.0);\n-            assert!(exp.ind_sample(&mut rng) >= 0.0);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_exp_invalid_lambda_zero() {\n-        Exp::new(0.0);\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_exp_invalid_lambda_neg() {\n-        Exp::new(-10.0);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use super::Exp;\n-    use distributions::Sample;\n-\n-    #[bench]\n-    fn rand_exp(b: &mut Bencher) {\n-        let mut rng = ::test::weak_rng();\n-        let mut exp = Exp::new(2.71828 * 3.14159);\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                exp.sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "e796197ab5bf24e16ae23416cd17c66b7fb9d758", "filename": "src/librand/distributions/gamma.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,439 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Gamma and derived distributions.\n-\n-use core::fmt;\n-\n-use self::GammaRepr::*;\n-use self::ChiSquaredRepr::*;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Open01, Rng};\n-use super::normal::StandardNormal;\n-use super::{Exp, IndependentSample, Sample};\n-\n-/// The Gamma distribution `Gamma(shape, scale)` distribution.\n-///\n-/// The density function of this distribution is\n-///\n-/// ```text\n-/// f(x) =  x^(k - 1) * exp(-x / \u03b8) / (\u0393(k) * \u03b8^k)\n-/// ```\n-///\n-/// where `\u0393` is the Gamma function, `k` is the shape and `\u03b8` is the\n-/// scale and both `k` and `\u03b8` are strictly positive.\n-///\n-/// The algorithm used is that described by Marsaglia & Tsang 2000[1],\n-/// falling back to directly sampling from an Exponential for `shape\n-/// == 1`, and using the boosting technique described in [1] for\n-/// `shape < 1`.\n-///\n-/// [1]: George Marsaglia and Wai Wan Tsang. 2000. \"A Simple Method\n-/// for Generating Gamma Variables\" *ACM Trans. Math. Softw.* 26, 3\n-/// (September 2000),\n-/// 363-372. DOI:[10.1145/358407.358414](http://doi.acm.org/10.1145/358407.358414)\n-pub struct Gamma {\n-    repr: GammaRepr,\n-}\n-\n-impl fmt::Debug for Gamma {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Gamma\")\n-         .field(\"repr\",\n-                &match self.repr {\n-                    GammaRepr::Large(_) => \"Large\",\n-                    GammaRepr::One(_) => \"Exp\",\n-                    GammaRepr::Small(_) => \"Small\"\n-                })\n-          .finish()\n-    }\n-}\n-\n-enum GammaRepr {\n-    Large(GammaLargeShape),\n-    One(Exp),\n-    Small(GammaSmallShape),\n-}\n-\n-// These two helpers could be made public, but saving the\n-// match-on-Gamma-enum branch from using them directly (e.g. if one\n-// knows that the shape is always > 1) doesn't appear to be much\n-// faster.\n-\n-/// Gamma distribution where the shape parameter is less than 1.\n-///\n-/// Note, samples from this require a compulsory floating-point `pow`\n-/// call, which makes it significantly slower than sampling from a\n-/// gamma distribution where the shape parameter is greater than or\n-/// equal to 1.\n-///\n-/// See `Gamma` for sampling from a Gamma distribution with general\n-/// shape parameters.\n-struct GammaSmallShape {\n-    inv_shape: f64,\n-    large_shape: GammaLargeShape,\n-}\n-\n-/// Gamma distribution where the shape parameter is larger than 1.\n-///\n-/// See `Gamma` for sampling from a Gamma distribution with general\n-/// shape parameters.\n-struct GammaLargeShape {\n-    scale: f64,\n-    c: f64,\n-    d: f64,\n-}\n-\n-impl Gamma {\n-    /// Construct an object representing the `Gamma(shape, scale)`\n-    /// distribution.\n-    ///\n-    /// Panics if `shape <= 0` or `scale <= 0`.\n-    pub fn new(shape: f64, scale: f64) -> Gamma {\n-        assert!(shape > 0.0, \"Gamma::new called with shape <= 0\");\n-        assert!(scale > 0.0, \"Gamma::new called with scale <= 0\");\n-\n-        let repr = if shape == 1.0 {\n-            One(Exp::new(1.0 / scale))\n-        } else if 0.0 <= shape && shape < 1.0 {\n-            Small(GammaSmallShape::new_raw(shape, scale))\n-        } else {\n-            Large(GammaLargeShape::new_raw(shape, scale))\n-        };\n-        Gamma { repr }\n-    }\n-}\n-\n-impl GammaSmallShape {\n-    fn new_raw(shape: f64, scale: f64) -> GammaSmallShape {\n-        GammaSmallShape {\n-            inv_shape: 1. / shape,\n-            large_shape: GammaLargeShape::new_raw(shape + 1.0, scale),\n-        }\n-    }\n-}\n-\n-impl GammaLargeShape {\n-    fn new_raw(shape: f64, scale: f64) -> GammaLargeShape {\n-        let d = shape - 1. / 3.;\n-        GammaLargeShape {\n-            scale,\n-            c: 1. / (9. * d).sqrt(),\n-            d,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for Gamma {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-impl Sample<f64> for GammaSmallShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-impl Sample<f64> for GammaLargeShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Gamma {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match self.repr {\n-            Small(ref g) => g.ind_sample(rng),\n-            One(ref g) => g.ind_sample(rng),\n-            Large(ref g) => g.ind_sample(rng),\n-        }\n-    }\n-}\n-impl IndependentSample<f64> for GammaSmallShape {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let Open01(u) = rng.gen::<Open01<f64>>();\n-\n-        self.large_shape.ind_sample(rng) * u.powf(self.inv_shape)\n-    }\n-}\n-impl IndependentSample<f64> for GammaLargeShape {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        loop {\n-            let StandardNormal(x) = rng.gen::<StandardNormal>();\n-            let v_cbrt = 1.0 + self.c * x;\n-            if v_cbrt <= 0.0 {\n-                // a^3 <= 0 iff a <= 0\n-                continue;\n-            }\n-\n-            let v = v_cbrt * v_cbrt * v_cbrt;\n-            let Open01(u) = rng.gen::<Open01<f64>>();\n-\n-            let x_sqr = x * x;\n-            if u < 1.0 - 0.0331 * x_sqr * x_sqr ||\n-               u.ln() < 0.5 * x_sqr + self.d * (1.0 - v + v.ln()) {\n-                return self.d * v * self.scale;\n-            }\n-        }\n-    }\n-}\n-\n-/// The chi-squared distribution `\u03c7\u00b2(k)`, where `k` is the degrees of\n-/// freedom.\n-///\n-/// For `k > 0` integral, this distribution is the sum of the squares\n-/// of `k` independent standard normal random variables. For other\n-/// `k`, this uses the equivalent characterization `\u03c7\u00b2(k) = Gamma(k/2,\n-/// 2)`.\n-pub struct ChiSquared {\n-    repr: ChiSquaredRepr,\n-}\n-\n-impl fmt::Debug for ChiSquared {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ChiSquared\")\n-         .field(\"repr\",\n-                &match self.repr {\n-                    ChiSquaredRepr::DoFExactlyOne => \"DoFExactlyOne\",\n-                    ChiSquaredRepr::DoFAnythingElse(_) => \"DoFAnythingElse\",\n-                })\n-         .finish()\n-    }\n-}\n-\n-enum ChiSquaredRepr {\n-    // k == 1, Gamma(alpha, ..) is particularly slow for alpha < 1,\n-    // e.g. when alpha = 1/2 as it would be for this case, so special-\n-    // casing and using the definition of N(0,1)^2 is faster.\n-    DoFExactlyOne,\n-    DoFAnythingElse(Gamma),\n-}\n-\n-impl ChiSquared {\n-    /// Create a new chi-squared distribution with degrees-of-freedom\n-    /// `k`. Panics if `k < 0`.\n-    pub fn new(k: f64) -> ChiSquared {\n-        let repr = if k == 1.0 {\n-            DoFExactlyOne\n-        } else {\n-            assert!(k > 0.0, \"ChiSquared::new called with `k` < 0\");\n-            DoFAnythingElse(Gamma::new(0.5 * k, 2.0))\n-        };\n-        ChiSquared { repr: repr }\n-    }\n-}\n-\n-impl Sample<f64> for ChiSquared {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for ChiSquared {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match self.repr {\n-            DoFExactlyOne => {\n-                // k == 1 => N(0,1)^2\n-                let StandardNormal(norm) = rng.gen::<StandardNormal>();\n-                norm * norm\n-            }\n-            DoFAnythingElse(ref g) => g.ind_sample(rng),\n-        }\n-    }\n-}\n-\n-/// The Fisher F distribution `F(m, n)`.\n-///\n-/// This distribution is equivalent to the ratio of two normalized\n-/// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n-/// (\u03c7\u00b2(n)/n)`.\n-pub struct FisherF {\n-    numer: ChiSquared,\n-    denom: ChiSquared,\n-    // denom_dof / numer_dof so that this can just be a straight\n-    // multiplication, rather than a division.\n-    dof_ratio: f64,\n-}\n-\n-impl FisherF {\n-    /// Create a new `FisherF` distribution, with the given\n-    /// parameter. Panics if either `m` or `n` are not positive.\n-    pub fn new(m: f64, n: f64) -> FisherF {\n-        assert!(m > 0.0, \"FisherF::new called with `m < 0`\");\n-        assert!(n > 0.0, \"FisherF::new called with `n < 0`\");\n-\n-        FisherF {\n-            numer: ChiSquared::new(m),\n-            denom: ChiSquared::new(n),\n-            dof_ratio: n / m,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for FisherF {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for FisherF {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.numer.ind_sample(rng) / self.denom.ind_sample(rng) * self.dof_ratio\n-    }\n-}\n-\n-impl fmt::Debug for FisherF {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FisherF\")\n-         .field(\"numer\", &self.numer)\n-         .field(\"denom\", &self.denom)\n-         .field(\"dof_ratio\", &self.dof_ratio)\n-         .finish()\n-    }\n-}\n-\n-/// The Student t distribution, `t(nu)`, where `nu` is the degrees of\n-/// freedom.\n-pub struct StudentT {\n-    chi: ChiSquared,\n-    dof: f64,\n-}\n-\n-impl StudentT {\n-    /// Create a new Student t distribution with `n` degrees of\n-    /// freedom. Panics if `n <= 0`.\n-    pub fn new(n: f64) -> StudentT {\n-        assert!(n > 0.0, \"StudentT::new called with `n <= 0`\");\n-        StudentT {\n-            chi: ChiSquared::new(n),\n-            dof: n,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for StudentT {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for StudentT {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let StandardNormal(norm) = rng.gen::<StandardNormal>();\n-        norm * (self.dof / self.chi.ind_sample(rng)).sqrt()\n-    }\n-}\n-\n-impl fmt::Debug for StudentT {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"StudentT\")\n-         .field(\"chi\", &self.chi)\n-         .field(\"dof\", &self.dof)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::{ChiSquared, FisherF, StudentT};\n-\n-    #[test]\n-    fn test_chi_squared_one() {\n-        let mut chi = ChiSquared::new(1.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    fn test_chi_squared_small() {\n-        let mut chi = ChiSquared::new(0.5);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    fn test_chi_squared_large() {\n-        let mut chi = ChiSquared::new(30.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_chi_squared_invalid_dof() {\n-        ChiSquared::new(-1.0);\n-    }\n-\n-    #[test]\n-    fn test_f() {\n-        let mut f = FisherF::new(2.0, 32.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            f.sample(&mut rng);\n-            f.ind_sample(&mut rng);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_t() {\n-        let mut t = StudentT::new(11.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            t.sample(&mut rng);\n-            t.ind_sample(&mut rng);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use distributions::IndependentSample;\n-    use super::Gamma;\n-\n-\n-    #[bench]\n-    fn bench_gamma_large_shape(b: &mut Bencher) {\n-        let gamma = Gamma::new(10., 1.0);\n-        let mut rng = ::test::weak_rng();\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                gamma.ind_sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn bench_gamma_small_shape(b: &mut Bencher) {\n-        let gamma = Gamma::new(0.1, 1.0);\n-        let mut rng = ::test::weak_rng();\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                gamma.ind_sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "47967a719d397a8972d39bf4e90ac356721af550", "filename": "src/librand/distributions/mod.rs", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,397 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sampling from random distributions.\n-//!\n-//! This is a generalization of `Rand` to allow parameters to control the\n-//! exact properties of the generated values, e.g. the mean and standard\n-//! deviation of a normal distribution. The `Sample` trait is the most\n-//! general, and allows for generating values that change some state\n-//! internally. The `IndependentSample` trait is for generating values\n-//! that do not need to record state.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use core::num::Float;\n-\n-use core::marker::PhantomData;\n-\n-use {Rand, Rng};\n-\n-pub use self::range::Range;\n-pub use self::gamma::{ChiSquared, FisherF, Gamma, StudentT};\n-pub use self::normal::{LogNormal, Normal};\n-pub use self::exponential::Exp;\n-\n-pub mod range;\n-pub mod gamma;\n-pub mod normal;\n-pub mod exponential;\n-\n-/// Types that can be used to create a random instance of `Support`.\n-pub trait Sample<Support> {\n-    /// Generate a random value of `Support`, using `rng` as the\n-    /// source of randomness.\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Support;\n-}\n-\n-/// `Sample`s that do not require keeping track of state.\n-///\n-/// Since no state is recorded, each sample is (statistically)\n-/// independent of all others, assuming the `Rng` used has this\n-/// property.\n-// FIXME maybe having this separate is overkill (the only reason is to\n-// take &self rather than &mut self)? or maybe this should be the\n-// trait called `Sample` and the other should be `DependentSample`.\n-pub trait IndependentSample<Support>: Sample<Support> {\n-    /// Generate a random value.\n-    fn ind_sample<R: Rng>(&self, _: &mut R) -> Support;\n-}\n-\n-/// A wrapper for generating types that implement `Rand` via the\n-/// `Sample` & `IndependentSample` traits.\n-pub struct RandSample<Sup> {\n-    _marker: PhantomData<Sup>,\n-}\n-\n-impl<Sup> RandSample<Sup> {\n-    pub fn new() -> RandSample<Sup> {\n-        RandSample { _marker: PhantomData }\n-    }\n-}\n-\n-impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n-        rng.gen()\n-    }\n-}\n-\n-impl<Sup> fmt::Debug for RandSample<Sup> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"RandSample { .. }\")\n-    }\n-}\n-\n-/// A value with a particular weight for use with `WeightedChoice`.\n-pub struct Weighted<T> {\n-    /// The numerical weight of this item\n-    pub weight: usize,\n-    /// The actual item which is being weighted\n-    pub item: T,\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Weighted<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Weighted\")\n-         .field(\"weight\", &self.weight)\n-         .field(\"item\", &self.item)\n-         .finish()\n-    }\n-}\n-\n-/// A distribution that selects from a finite collection of weighted items.\n-///\n-/// Each item has an associated weight that influences how likely it\n-/// is to be chosen: higher weight is more likely.\n-///\n-/// The `Clone` restriction is a limitation of the `Sample` and\n-/// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n-/// all `T`, as is `usize`, so one can store references or indices into\n-/// another vector.\n-pub struct WeightedChoice<'a, T: 'a> {\n-    items: &'a mut [Weighted<T>],\n-    weight_range: Range<usize>,\n-}\n-\n-impl<'a, T: Clone> WeightedChoice<'a, T> {\n-    /// Create a new `WeightedChoice`.\n-    ///\n-    /// Panics if:\n-    /// - `v` is empty\n-    /// - the total weight is 0\n-    /// - the total weight is larger than a `usize` can contain.\n-    pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n-        // strictly speaking, this is subsumed by the total weight == 0 case\n-        assert!(!items.is_empty(),\n-                \"WeightedChoice::new called with no items\");\n-\n-        let mut running_total = 0_usize;\n-\n-        // we convert the list from individual weights to cumulative\n-        // weights so we can binary search. This *could* drop elements\n-        // with weight == 0 as an optimisation.\n-        for item in &mut *items {\n-            running_total = match running_total.checked_add(item.weight) {\n-                Some(n) => n,\n-                None => {\n-                    panic!(\"WeightedChoice::new called with a total weight larger than a usize \\\n-                            can contain\")\n-                }\n-            };\n-\n-            item.weight = running_total;\n-        }\n-        assert!(running_total != 0,\n-                \"WeightedChoice::new called with a total weight of 0\");\n-\n-        WeightedChoice {\n-            items,\n-            // we're likely to be generating numbers in this range\n-            // relatively often, so might as well cache it\n-            weight_range: Range::new(0, running_total),\n-        }\n-    }\n-}\n-\n-impl<'a, T: Clone> Sample<T> for WeightedChoice<'a, T> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> T {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<'a, T: Clone> IndependentSample<T> for WeightedChoice<'a, T> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n-        // we want to find the first element that has cumulative\n-        // weight > sample_weight, which we do by binary since the\n-        // cumulative weights of self.items are sorted.\n-\n-        // choose a weight in [0, total_weight)\n-        let sample_weight = self.weight_range.ind_sample(rng);\n-\n-        // short circuit when it's the first item\n-        if sample_weight < self.items[0].weight {\n-            return self.items[0].item.clone();\n-        }\n-\n-        let mut idx = 0;\n-        let mut modifier = self.items.len();\n-\n-        // now we know that every possibility has an element to the\n-        // left, so we can just search for the last element that has\n-        // cumulative weight <= sample_weight, then the next one will\n-        // be \"it\". (Note that this greatest element will never be the\n-        // last element of the vector, since sample_weight is chosen\n-        // in [0, total_weight) and the cumulative weight of the last\n-        // one is exactly the total weight.)\n-        while modifier > 1 {\n-            let i = idx + modifier / 2;\n-            if self.items[i].weight <= sample_weight {\n-                // we're small, so look to the right, but allow this\n-                // exact element still.\n-                idx = i;\n-                // we need the `/ 2` to round up otherwise we'll drop\n-                // the trailing elements when `modifier` is odd.\n-                modifier += 1;\n-            } else {\n-                // otherwise we're too big, so go left. (i.e. do\n-                // nothing)\n-            }\n-            modifier /= 2;\n-        }\n-        return self.items[idx + 1].item.clone();\n-    }\n-}\n-\n-impl<'a, T: fmt::Debug> fmt::Debug for WeightedChoice<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"WeightedChoice\")\n-         .field(\"items\", &self.items)\n-         .field(\"weight_range\", &self.weight_range)\n-         .finish()\n-    }\n-}\n-\n-mod ziggurat_tables;\n-\n-/// Sample a random number using the Ziggurat method (specifically the\n-/// ZIGNOR variant from Doornik 2005). Most of the arguments are\n-/// directly from the paper:\n-///\n-/// * `rng`: source of randomness\n-/// * `symmetric`: whether this is a symmetric distribution, or one-sided with P(x < 0) = 0.\n-/// * `X`: the $x_i$ abscissae.\n-/// * `F`: precomputed values of the PDF at the $x_i$, (i.e. $f(x_i)$)\n-/// * `F_DIFF`: precomputed values of $f(x_i) - f(x_{i+1})$\n-/// * `pdf`: the probability density function\n-/// * `zero_case`: manual sampling from the tail when we chose the\n-///    bottom box (i.e. i == 0)\n-// the perf improvement (25-50%) is definitely worth the extra code\n-// size from force-inlining.\n-#[inline(always)]\n-fn ziggurat<R: Rng, P, Z>(rng: &mut R,\n-                          symmetric: bool,\n-                          x_tab: ziggurat_tables::ZigTable,\n-                          f_tab: ziggurat_tables::ZigTable,\n-                          mut pdf: P,\n-                          mut zero_case: Z)\n-                          -> f64\n-    where P: FnMut(f64) -> f64,\n-          Z: FnMut(&mut R, f64) -> f64\n-{\n-    const SCALE: f64 = (1u64 << 53) as f64;\n-    loop {\n-        // reimplement the f64 generation as an optimisation suggested\n-        // by the Doornik paper: we have a lot of precision-space\n-        // (i.e. there are 11 bits of the 64 of a u64 to use after\n-        // creating a f64), so we might as well reuse some to save\n-        // generating a whole extra random number. (Seems to be 15%\n-        // faster.)\n-        //\n-        // This unfortunately misses out on the benefits of direct\n-        // floating point generation if an RNG like dSMFT is\n-        // used. (That is, such RNGs create floats directly, highly\n-        // efficiently and overload next_f32/f64, so by not calling it\n-        // this may be slower than it would be otherwise.)\n-        // FIXME: investigate/optimise for the above.\n-        let bits: u64 = rng.gen();\n-        let i = (bits & 0xff) as usize;\n-        let f = (bits >> 11) as f64 / SCALE;\n-\n-        // u is either U(-1, 1) or U(0, 1) depending on if this is a\n-        // symmetric distribution or not.\n-        let u = if symmetric { 2.0 * f - 1.0 } else { f };\n-        let x = u * x_tab[i];\n-\n-        let test_x = if symmetric { x.abs() } else { x };\n-\n-        // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n-        if test_x < x_tab[i + 1] {\n-            return x;\n-        }\n-        if i == 0 {\n-            return zero_case(rng, u);\n-        }\n-        // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if f_tab[i + 1] + (f_tab[i] - f_tab[i + 1]) * rng.gen::<f64>() < pdf(x) {\n-            return x;\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use {Rand, Rng};\n-    use super::{IndependentSample, RandSample, Sample, Weighted, WeightedChoice};\n-\n-    #[derive(PartialEq, Debug)]\n-    struct ConstRand(usize);\n-    impl Rand for ConstRand {\n-        fn rand<R: Rng>(_: &mut R) -> ConstRand {\n-            ConstRand(0)\n-        }\n-    }\n-\n-    // 0, 1, 2, 3, ...\n-    struct CountingRng {\n-        i: u32,\n-    }\n-    impl Rng for CountingRng {\n-        fn next_u32(&mut self) -> u32 {\n-            self.i += 1;\n-            self.i - 1\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            self.next_u32() as u64\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rand_sample() {\n-        let mut rand_sample = RandSample::<ConstRand>::new();\n-\n-        assert_eq!(rand_sample.sample(&mut ::test::rng()), ConstRand(0));\n-        assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));\n-    }\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice() {\n-        // this makes assumptions about the internal implementation of\n-        // WeightedChoice, specifically: it doesn't reorder the items,\n-        // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n-        // 1, internally; modulo a modulo operation).\n-\n-        macro_rules! t {\n-            ($items:expr, $expected:expr) => {{\n-                let mut items = $items;\n-                let wc = WeightedChoice::new(&mut items);\n-                let expected = $expected;\n-\n-                let mut rng = CountingRng { i: 0 };\n-\n-                for &val in &expected {\n-                    assert_eq!(wc.ind_sample(&mut rng), val)\n-                }\n-            }}\n-        }\n-\n-        t!(vec![Weighted { weight: 1, item: 10 }],\n-           [10]);\n-\n-        // skip some\n-        t!(vec![Weighted { weight: 0, item: 20 },\n-                Weighted { weight: 2, item: 21 },\n-                Weighted { weight: 0, item: 22 },\n-                Weighted { weight: 1, item: 23 }],\n-           [21, 21, 23]);\n-\n-        // different weights\n-        t!(vec![Weighted { weight: 4, item: 30 },\n-                Weighted { weight: 3, item: 31 }],\n-           [30, 30, 30, 30, 31, 31, 31]);\n-\n-        // check that we're binary searching\n-        // correctly with some vectors of odd\n-        // length.\n-        t!(vec![Weighted { weight: 1, item: 40 },\n-                Weighted { weight: 1, item: 41 },\n-                Weighted { weight: 1, item: 42 },\n-                Weighted { weight: 1, item: 43 },\n-                Weighted { weight: 1, item: 44 }],\n-           [40, 41, 42, 43, 44]);\n-        t!(vec![Weighted { weight: 1, item: 50 },\n-                Weighted { weight: 1, item: 51 },\n-                Weighted { weight: 1, item: 52 },\n-                Weighted { weight: 1, item: 53 },\n-                Weighted { weight: 1, item: 54 },\n-                Weighted { weight: 1, item: 55 },\n-                Weighted { weight: 1, item: 56 }],\n-           [50, 51, 52, 53, 54, 55, 56]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_weighted_choice_no_items() {\n-        WeightedChoice::<isize>::new(&mut []);\n-    }\n-    #[test]\n-    #[should_panic]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0 },\n-                                  Weighted { weight: 0, item: 1 }]);\n-    }\n-    #[test]\n-    #[should_panic]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice_weight_overflows() {\n-        let x = (!0) as usize / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n-                                  Weighted { weight: 1, item: 1 },\n-                                  Weighted { weight: x, item: 2 },\n-                                  Weighted { weight: 1, item: 3 }]);\n-    }\n-}"}, {"sha": "e1518dab21c2b9bb3215f6fa805547d39d44d40f", "filename": "src/librand/distributions/normal.rs", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,234 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The normal and derived distributions.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Open01, Rand, Rng};\n-use distributions::{IndependentSample, Sample, ziggurat, ziggurat_tables};\n-\n-/// A wrapper around an `f64` to generate N(0, 1) random numbers\n-/// (a.k.a.  a standard normal, or Gaussian).\n-///\n-/// See `Normal` for the general normal distribution. That this has to\n-/// be unwrapped before use as an `f64` (using either `*` or\n-/// `mem::transmute` is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-#[derive(Copy, Clone)]\n-pub struct StandardNormal(pub f64);\n-\n-impl Rand for StandardNormal {\n-    fn rand<R: Rng>(rng: &mut R) -> StandardNormal {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            (-x * x / 2.0).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R: Rng>(rng: &mut R, u: f64) -> f64 {\n-            // compute a random number in the tail by hand\n-\n-            // strange initial conditions, because the loop is not\n-            // do-while, so the condition should be true on the first\n-            // run, they get overwritten anyway (0 < 1, so these are\n-            // good).\n-            let mut x = 1.0f64;\n-            let mut y = 0.0f64;\n-\n-            while -2.0 * y < x * x {\n-                let Open01(x_) = rng.gen::<Open01<f64>>();\n-                let Open01(y_) = rng.gen::<Open01<f64>>();\n-\n-                x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n-                y = y_.ln();\n-            }\n-\n-            if u < 0.0 {\n-                x - ziggurat_tables::ZIG_NORM_R\n-            } else {\n-                ziggurat_tables::ZIG_NORM_R - x\n-            }\n-        }\n-\n-        StandardNormal(ziggurat(rng,\n-                                true, // this is symmetric\n-                                &ziggurat_tables::ZIG_NORM_X,\n-                                &ziggurat_tables::ZIG_NORM_F,\n-                                pdf,\n-                                zero_case))\n-    }\n-}\n-\n-impl fmt::Debug for StandardNormal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"StandardNormal\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-/// The normal distribution `N(mean, std_dev**2)`.\n-///\n-/// This uses the ZIGNOR variant of the Ziggurat method, see\n-/// `StandardNormal` for more details.\n-#[derive(Copy, Clone)]\n-pub struct Normal {\n-    mean: f64,\n-    std_dev: f64,\n-}\n-\n-impl Normal {\n-    /// Construct a new `Normal` distribution with the given mean and\n-    /// standard deviation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `std_dev < 0`.\n-    pub fn new(mean: f64, std_dev: f64) -> Normal {\n-        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n-        Normal {\n-            mean,\n-            std_dev,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for Normal {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Normal {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let StandardNormal(n) = rng.gen::<StandardNormal>();\n-        self.mean + self.std_dev * n\n-    }\n-}\n-\n-impl fmt::Debug for Normal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Normal\")\n-         .field(\"mean\", &self.mean)\n-         .field(\"std_dev\", &self.std_dev)\n-         .finish()\n-    }\n-}\n-\n-\n-/// The log-normal distribution `ln N(mean, std_dev**2)`.\n-///\n-/// If `X` is log-normal distributed, then `ln(X)` is `N(mean,\n-/// std_dev**2)` distributed.\n-#[derive(Copy, Clone)]\n-pub struct LogNormal {\n-    norm: Normal,\n-}\n-\n-impl LogNormal {\n-    /// Construct a new `LogNormal` distribution with the given mean\n-    /// and standard deviation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `std_dev < 0`.\n-    pub fn new(mean: f64, std_dev: f64) -> LogNormal {\n-        assert!(std_dev >= 0.0, \"LogNormal::new called with `std_dev` < 0\");\n-        LogNormal { norm: Normal::new(mean, std_dev) }\n-    }\n-}\n-\n-impl Sample<f64> for LogNormal {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for LogNormal {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.norm.ind_sample(rng).exp()\n-    }\n-}\n-\n-impl fmt::Debug for LogNormal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LogNormal\")\n-         .field(\"norm\", &self.norm)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::{LogNormal, Normal};\n-\n-    #[test]\n-    fn test_normal() {\n-        let mut norm = Normal::new(10.0, 10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            norm.sample(&mut rng);\n-            norm.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_normal_invalid_sd() {\n-        Normal::new(10.0, -1.0);\n-    }\n-\n-\n-    #[test]\n-    fn test_log_normal() {\n-        let mut lnorm = LogNormal::new(10.0, 10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            lnorm.sample(&mut rng);\n-            lnorm.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_log_normal_invalid_sd() {\n-        LogNormal::new(10.0, -1.0);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use distributions::Sample;\n-    use super::Normal;\n-\n-    #[bench]\n-    fn rand_normal(b: &mut Bencher) {\n-        let mut rng = ::test::weak_rng();\n-        let mut normal = Normal::new(-2.71828, 3.14159);\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                normal.sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "f2f8132e5b47ba18fa6910bb06abc7bf972728cc", "filename": "src/librand/distributions/range.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generating numbers between two others.\n-\n-// this is surprisingly complicated to be both generic & correct\n-\n-use core::fmt;\n-use core::marker::Sized;\n-use Rng;\n-use distributions::{IndependentSample, Sample};\n-\n-/// Sample values uniformly between two bounds.\n-///\n-/// This gives a uniform distribution (assuming the RNG used to sample\n-/// it is itself uniform & the `SampleRange` implementation for the\n-/// given type is correct), even for edge cases like `low = 0`,\n-/// `high = 170`, for which a naive modulo operation would return\n-/// numbers less than 85 with double the probability to those greater\n-/// than 85.\n-///\n-/// Types should attempt to sample in `[low, high)`, i.e., not\n-/// including `high`, but this may be very difficult. All the\n-/// primitive integer types satisfy this property, and the float types\n-/// normally satisfy it, but rounding may mean `high` can occur.\n-pub struct Range<X> {\n-    low: X,\n-    range: X,\n-    accept_zone: X,\n-}\n-\n-impl<X: SampleRange + PartialOrd> Range<X> {\n-    /// Create a new `Range` instance that samples uniformly from\n-    /// `[low, high)`. Panics if `low >= high`.\n-    pub fn new(low: X, high: X) -> Range<X> {\n-        assert!(low < high, \"Range::new called with `low >= high`\");\n-        SampleRange::construct_range(low, high)\n-    }\n-}\n-\n-impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n-    #[inline]\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n-        SampleRange::sample_range(self, rng)\n-    }\n-}\n-\n-impl<X: fmt::Debug> fmt::Debug for Range<X> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Range\")\n-         .field(\"low\", &self.low)\n-         .field(\"range\", &self.range)\n-         .field(\"accept_zone\", &self.accept_zone)\n-         .finish()\n-    }\n-}\n-\n-/// The helper trait for types that have a sensible way to sample\n-/// uniformly between two values. This should not be used directly,\n-/// and is only to facilitate `Range`.\n-#[doc(hidden)]\n-pub trait SampleRange: Sized {\n-    /// Construct the `Range` object that `sample_range`\n-    /// requires. This should not ever be called directly, only via\n-    /// `Range::new`, which will check that `low < high`, so this\n-    /// function doesn't have to repeat the check.\n-    fn construct_range(low: Self, high: Self) -> Range<Self>;\n-\n-    /// Sample a value from the given `Range` with the given `Rng` as\n-    /// a source of randomness.\n-    fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;\n-}\n-\n-macro_rules! integer_impl {\n-    ($ty:ident, $unsigned:ident) => {\n-        impl SampleRange for $ty {\n-            // we play free and fast with unsigned vs signed here\n-            // (when $ty is signed), but that's fine, since the\n-            // contract of this macro is for $ty and $unsigned to be\n-            // \"bit-equal\", so casting between them is a no-op & a\n-            // bijection.\n-\n-            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n-                let unsigned_max: $unsigned = $unsigned::max_value();\n-\n-                // this is the largest number that fits into $unsigned\n-                // that `range` divides evenly, so, if we've sampled\n-                // `n` uniformly from this region, then `n % range` is\n-                // uniform in [0, range)\n-                let zone = unsigned_max - unsigned_max % range;\n-\n-                Range {\n-                    low,\n-                    range: range as $ty,\n-                    accept_zone: zone as $ty\n-                }\n-            }\n-            #[inline]\n-            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n-                loop {\n-                    // rejection sample\n-                    let v = rng.gen::<$unsigned>();\n-                    // until we find something that fits into the\n-                    // region which r.range evenly divides (this will\n-                    // be uniformly distributed)\n-                    if v < r.accept_zone as $unsigned {\n-                        // and return it, with some adjustments\n-                        return r.low.wrapping_add((v % r.range as $unsigned) as $ty);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-integer_impl! { i8, u8 }\n-integer_impl! { i16, u16 }\n-integer_impl! { i32, u32 }\n-integer_impl! { i64, u64 }\n-integer_impl! { isize, usize }\n-integer_impl! { u8, u8 }\n-integer_impl! { u16, u16 }\n-integer_impl! { u32, u32 }\n-integer_impl! { u64, u64 }\n-integer_impl! { usize, usize }\n-\n-macro_rules! float_impl {\n-    ($ty:ty) => {\n-        impl SampleRange for $ty {\n-            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                Range {\n-                    low,\n-                    range: high - low,\n-                    accept_zone: 0.0 // unused\n-                }\n-            }\n-            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n-                r.low + r.range * rng.gen::<$ty>()\n-            }\n-        }\n-    }\n-}\n-\n-float_impl! { f32 }\n-float_impl! { f64 }\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::Range;\n-\n-    #[should_panic]\n-    #[test]\n-    fn test_range_bad_limits_equal() {\n-        Range::new(10, 10);\n-    }\n-    #[should_panic]\n-    #[test]\n-    fn test_range_bad_limits_flipped() {\n-        Range::new(10, 5);\n-    }\n-\n-    #[test]\n-    fn test_integers() {\n-        let mut rng = ::test::rng();\n-        macro_rules! t {\n-            ($($ty:ident),*) => {{\n-                $(\n-                   let v: &[($ty, $ty)] = &[(0, 10),\n-                                            (10, 127),\n-                                            ($ty::min_value(), $ty::max_value())];\n-                   for &(low, high) in v {\n-                        let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0..1000 {\n-                            let v = sampler.sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                            let v = sampler.ind_sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                        }\n-                    }\n-                 )*\n-            }}\n-        }\n-        t!(i8, i16, i32, i64, isize, u8, u16, u32, u64, usize)\n-    }\n-\n-    #[test]\n-    fn test_floats() {\n-        let mut rng = ::test::rng();\n-        macro_rules! t {\n-            ($($ty:ty),*) => {{\n-                $(\n-                   let v: &[($ty, $ty)] = &[(0.0, 100.0),\n-                                            (-1e35, -1e25),\n-                                            (1e-35, 1e-25),\n-                                            (-1e35, 1e35)];\n-                   for &(low, high) in v {\n-                        let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0..1000 {\n-                            let v = sampler.sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                            let v = sampler.ind_sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                        }\n-                    }\n-                 )*\n-            }}\n-        }\n-\n-        t!(f32, f64)\n-    }\n-\n-}"}, {"sha": "7dfb0f131a2c50bde150dbc0ebcee01859b49c53", "filename": "src/librand/distributions/ziggurat_tables.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "96ce0905e384da72f72f008acd0f8be8dc71fad7", "filename": "src/librand/isaac.rs", "status": "removed", "additions": 0, "deletions": 745, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "90b3020fff9d1ebfa6a9bb2c1baef5220fd2db45", "filename": "src/librand/lib.rs", "status": "removed", "additions": 0, "deletions": 480, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "b0d824da3ab4795a45b39b449300eed1c3a5f1ae", "filename": "src/librand/rand_impls.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "2821b7a8232df4622e4a12df47c49115c22aaff1", "filename": "src/librand/reseeding.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "4222e81d2a3dd257a734671aa845d768c89e7fd7", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "ddf71a06d607c7f7016546b0cc6fdb7da8ee3bef", "filename": "src/librustc/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "63e74778fb92a6766dc3fe2b84bffce046da66bd", "filename": "src/librustc/benches/dispatch.rs", "status": "renamed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fdispatch.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3", "previous_filename": "src/libcore/benches/mem.rs"}, {"sha": "24294ec49ceed58e243f1029e3d4cd7fb6b8aaae", "filename": "src/librustc/benches/lib.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "638b1ce3f75301dab95a1aae49e2ac12a7109ee8", "filename": "src/librustc/benches/pattern.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fbenches%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fpattern.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "1fc3b04adb86ddf65dbe66e5c9726a80431b86bb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 112, "deletions": 141, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "b12db11cb6af692f83ba54042ffd179cfa9bc9d0", "filename": "src/librustc/dep_graph/edges.rs", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c442d65c150b99d18202a5cce4a2cbdbd4dc83/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=d4c442d65c150b99d18202a5cce4a2cbdbd4dc83"}, {"sha": "96d6b0f79cffffaf74641a18a7689b187c3cfc33", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 524, "deletions": 122, "changes": 646, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "a472183698abf5bf205efd69a32062d25dfb5c0a", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "6c43b5c5ff197acc0c88704fac3ac35a5da2f783", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "5728bcc7d27710dbccc7cfa69e32a904bc79976e", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "c96040ab9b6e3eab996aafdb875c90fc6d3217a4", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "8089a88a9e8d483a3b2ca0a1ca612a6282f45b25", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "e283fc40c50a345fc9ed5658753bc45eb9d6836a", "filename": "src/librustc/hir/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "003255f87966fb753bf5cf1808b2d32c9f4bafbb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "64bcdc7920a0151761fe37518a680d7ee39f2240", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "8858023ec1d7ba6eaececfc866d1920a904aeed0", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 85, "deletions": 64, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "c9d35158ed002c8565043fbcd0d04a2d791861bf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "2221ecf07b434913b079643d283b48afeeed7d5f", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "63b80a3f3c1e261d742b12690e01daee3d19f0b3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 811, "deletions": 249, "changes": 1060, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "02a1e33eeb918413ae62a6ea7af85289edafd9cb", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "17a4c66edb9c923168d0743808e6e02abc364891", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "7c2f0bc3cef8440b09f2b289f11dc3e8f0f6b927", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "28527b6f0bc64aea4a8ba8d3dffa538382114be4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "39ec33eef1fec518542f3001a5335fd914459042", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 107, "deletions": 15, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "2bec224362ea64710106683d573240ba914afacc", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "d94dd24af3edc74277110793b5c7a9e6449ee334", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "3d089d8e75fb1fff3645ee6387ef9549a117bb05", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "d95b825b9e562782a07e30ac539f01a03b79cf12", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}, {"sha": "77bf3da679dd776fbe19b8cd355c70a74e74e28c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 82, "deletions": 52, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acdf83f2288e1b80259dafeca4a0cee9a42973c3/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=acdf83f2288e1b80259dafeca4a0cee9a42973c3"}]}