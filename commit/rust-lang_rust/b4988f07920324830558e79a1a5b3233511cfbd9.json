{"sha": "b4988f07920324830558e79a1a5b3233511cfbd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OTg4ZjA3OTIwMzI0ODMwNTU4ZTc5YTFhNWIzMjMzNTExY2ZiZDk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-16T21:54:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: keep overloaded autoderef MethodCallee's in Adjust.", "tree": {"sha": "062e016c2c69e90b596ac05ee4a39c9f6a36dc1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/062e016c2c69e90b596ac05ee4a39c9f6a36dc1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4988f07920324830558e79a1a5b3233511cfbd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4988f07920324830558e79a1a5b3233511cfbd9", "html_url": "https://github.com/rust-lang/rust/commit/b4988f07920324830558e79a1a5b3233511cfbd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4988f07920324830558e79a1a5b3233511cfbd9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a53c3e90470c893a1b087babb03dec039c64b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a53c3e90470c893a1b087babb03dec039c64b79", "html_url": "https://github.com/rust-lang/rust/commit/9a53c3e90470c893a1b087babb03dec039c64b79"}], "stats": {"total": 1223, "additions": 518, "deletions": 705}, "files": [{"sha": "2246621f83ca0401174e99b726c94f0c355d6584", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -412,8 +412,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             pred: CFGIndex,\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n-        let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tables.method_map.get(&method_call) {\n+        let fn_ty = match self.tables.method_map.get(&call_expr.id) {\n             Some(method) => method.ty,\n             None => self.tables.expr_ty_adjusted(func_or_rcvr),\n         };"}, {"sha": "0575bfcf926f5d8379f1ba1cd11e20f9367400ea", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n             ty::adjustment::Adjust::MutToConstPointer => {}\n-            ty::adjustment::Adjust::DerefRef { autoderefs, ref autoref, unsize } => {\n+            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n                 autoderefs.hash_stable(hcx, hasher);\n                 autoref.hash_stable(hcx, hasher);\n                 unsize.hash_stable(hcx, hasher);\n@@ -112,7 +112,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n }\n \n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::MethodCall { expr_id, autoderef });\n impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n@@ -626,17 +625,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n             ich::hash_stable_nodemap(hcx, hasher, item_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n-\n-            ich::hash_stable_hashmap(hcx, hasher, method_map, |hcx, method_call| {\n-                let ty::MethodCall {\n-                    expr_id,\n-                    autoderef\n-                } = *method_call;\n-\n-                let def_id = hcx.tcx().hir.local_def_id(expr_id);\n-                (hcx.def_path_hash(def_id), autoderef)\n-            });\n-\n+            ich::hash_stable_nodemap(hcx, hasher, method_map);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "f05f411945089d58dafdc3d5e0eba58cfbce7067", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -564,13 +564,14 @@ impl<'tcx, T> InferOk<'tcx, T> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot {\n+pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n     was_in_snapshot: bool,\n+    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -888,7 +889,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot(&self) -> CombinedSnapshot {\n+    fn start_snapshot<'b>(&'b self) -> CombinedSnapshot<'b, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.get();\n@@ -901,6 +902,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n             was_in_snapshot: in_snapshot,\n+            // Borrow tables \"in progress\" (i.e. during typeck)\n+            // to ban writes from within a snapshot to them.\n+            _in_progress_tables: match self.tables {\n+                InferTables::InProgress(ref tables) => tables.try_borrow().ok(),\n+                _ => None\n+            }\n         }\n     }\n \n@@ -911,7 +918,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               was_in_snapshot } = snapshot;\n+                               was_in_snapshot,\n+                               _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n@@ -938,7 +946,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               was_in_snapshot } = snapshot;\n+                               was_in_snapshot,\n+                               _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n@@ -1645,29 +1654,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n     }\n \n-    pub fn node_method_ty(&self, method_call: ty::MethodCall)\n-                          -> Option<Ty<'tcx>> {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.ty)\n-            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n-    }\n-\n-    pub fn node_method_id(&self, method_call: ty::MethodCall)\n-                          -> Option<DefId> {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.def_id)\n-    }\n-\n-    pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n-    }\n-\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }"}, {"sha": "ebae3933bddb11ccd18db603331e2905b1ccea6c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -95,9 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n-        let method_call = ty::MethodCall::expr(id);\n-        let method = self.tables.method_map[&method_call];\n-        self.check_def_id(method.def_id);\n+        self.check_def_id(self.tables.method_map[&id].def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {"}, {"sha": "1d3f8e426e7130e53321e904efbce877c5ce5d6e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -13,7 +13,6 @@\n use self::RootUnsafeContext::*;\n \n use ty::{self, Ty, TyCtxt};\n-use ty::MethodCall;\n use lint;\n \n use syntax::ast;\n@@ -174,8 +173,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tables.method_map[&method_call].ty;\n+                let base_type = self.tables.method_map[&expr.id].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "64880bf4fadf42b96a5f9fef5f29a60c3bf8cf0d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -563,19 +563,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let overloaded_call_type =\n-                    match self.mc.infcx.node_method_id(ty::MethodCall::expr(call.id)) {\n-                        Some(method_id) => {\n-                            OverloadedCallType::from_method_id(self.tcx(), method_id)\n-                        }\n-                        None => {\n-                            span_bug!(\n-                                callee.span,\n-                                \"unexpected callee type {}\",\n-                                callee_ty)\n-                        }\n-                    };\n-                match overloaded_call_type {\n+                let method = self.mc.infcx.tables.borrow().method_map[&call.id];\n+                match OverloadedCallType::from_method_id(self.tcx(), method.def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n@@ -717,7 +706,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n         let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = infcx.tables.borrow().adjustments.get(&expr.id).map(|x| x.clone());\n+        let adj = infcx.tables.borrow().adjustments.get(&expr.id).cloned();\n+        let cmt_unadjusted =\n+            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         if let Some(adjustment) = adj {\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n@@ -728,17 +719,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment: trivial adjustment\");\n-                    let cmt_unadjusted =\n-                        return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                adjustment::Adjust::DerefRef { ref autoderefs, autoref, unsize } => {\n                     debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n \n-                    self.walk_autoderefs(expr, autoderefs);\n-\n                     let cmt_derefd =\n-                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n+                        return_if_err!(self.walk_autoderefs(expr, cmt_unadjusted, autoderefs));\n \n                     let cmt_refd =\n                         self.walk_autoref(expr, cmt_derefd, autoref);\n@@ -757,30 +744,30 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// `deref()` is declared with `&self`, this is an autoref of `x`.\n     fn walk_autoderefs(&mut self,\n                        expr: &hir::Expr,\n-                       autoderefs: usize) {\n-        debug!(\"walk_autoderefs expr={:?} autoderefs={}\", expr, autoderefs);\n-\n-        for i in 0..autoderefs {\n-            let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n-            if let Some(method_ty) = self.mc.infcx.node_method_ty(deref_id) {\n-                let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n+                       mut cmt: mc::cmt<'tcx>,\n+                       autoderefs: &[Option<ty::MethodCallee<'tcx>>])\n+                       -> mc::McResult<mc::cmt<'tcx>> {\n+        debug!(\"walk_autoderefs expr={:?} autoderefs={:?}\", expr, autoderefs);\n \n+        for &overloaded in autoderefs {\n+            if let Some(method) = overloaded {\n                 // the method call infrastructure should have\n                 // replaced all late-bound regions with variables:\n-                let self_ty = method_ty.fn_sig().input(0);\n+                let self_ty = method.ty.fn_sig().input(0);\n+                let self_ty = self.mc.infcx.resolve_type_vars_if_possible(&self_ty);\n                 let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n \n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n-                    _ => span_bug!(expr.span,\n-                                   \"bad overloaded deref type {:?}\",\n-                                   method_ty)\n+                    _ => span_bug!(expr.span, \"bad overloaded deref type {:?}\", self_ty)\n                 };\n                 let bk = ty::BorrowKind::from_mutbl(m);\n-                self.delegate.borrow(expr.id, expr.span, cmt,\n+                self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n                                      r, bk, AutoRef);\n             }\n+            cmt = self.mc.cat_deref(expr, cmt, overloaded)?;\n         }\n+        Ok(cmt)\n     }\n \n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n@@ -863,7 +850,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                 pass_args: PassArgs)\n                                 -> bool\n     {\n-        if !self.mc.infcx.is_method_call(expr.id) {\n+        if !self.mc.infcx.tables.borrow().is_method_call(expr.id) {\n             return false;\n         }\n "}, {"sha": "d5c0a67f71ce936839010aff47f2c145a7da0ef4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -1084,8 +1084,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprMethodCall(.., ref args) => {\n-            let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.tables.method_map[&method_call].ty;\n+            let method_ty = self.tables.method_map[&expr.id].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln"}, {"sha": "4e2150dc2c61fe212e3d573a980dbf6fdf99342b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -480,14 +480,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n+                debug!(\"cat_expr({:?}): {:?}\", adjustment, expr);\n                 match adjustment.kind {\n                     adjustment::Adjust::DerefRef {\n-                        autoderefs,\n+                        ref autoderefs,\n                         autoref: None,\n                         unsize: false\n                     } => {\n                         // Equivalent to *expr or something similar.\n-                        self.cat_expr_autoderefd(expr, autoderefs)\n+                        let mut cmt = self.cat_expr_unadjusted(expr)?;\n+                        debug!(\"cat_expr: autoderefs={:?}, cmt={:?}\",\n+                               autoderefs, cmt);\n+                        for &overloaded in autoderefs {\n+                            cmt = self.cat_deref(expr, cmt, overloaded)?;\n+                        }\n+                        return Ok(cmt);\n                     }\n \n                     adjustment::Adjust::NeverToAny |\n@@ -496,9 +503,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     adjustment::Adjust::ClosureFnPointer |\n                     adjustment::Adjust::MutToConstPointer |\n                     adjustment::Adjust::DerefRef {..} => {\n-                        debug!(\"cat_expr({:?}): {:?}\",\n-                               adjustment,\n-                               expr);\n                         // Result is an rvalue.\n                         let expr_ty = self.expr_ty_adjusted(expr)?;\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n@@ -508,28 +512,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self,\n-                               expr: &hir::Expr,\n-                               autoderefs: usize)\n-                               -> McResult<cmt<'tcx>> {\n-        let mut cmt = self.cat_expr_unadjusted(expr)?;\n-        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={:?}\",\n-               autoderefs,\n-               cmt);\n-        for deref in 1..autoderefs + 1 {\n-            cmt = self.cat_deref(expr, cmt, deref)?;\n-        }\n-        return Ok(cmt);\n-    }\n-\n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             let base_cmt = self.cat_expr(&e_base)?;\n-            self.cat_deref(expr, base_cmt, 0)\n+            let method = self.infcx.tables.borrow().method_map\n+                .get(&expr.id).cloned();\n+            self.cat_deref(expr, base_cmt, method)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -547,12 +539,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            let method_call = ty::MethodCall::expr(expr.id());\n-            match self.infcx.node_method_ty(method_call) {\n-                Some(method_ty) => {\n+            let method = self.infcx.tables.borrow().method_map.get(&expr.id()).cloned();\n+            match method {\n+                Some(method) => {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n-                    let ret_ty = self.overloaded_method_return_ty(method_ty);\n+                    let ret_ty = self.overloaded_method_return_ty(method);\n \n                     // The index method always returns an `&T`, so\n                     // dereference it to find the result type.\n@@ -932,24 +924,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    fn cat_deref<N:ast_node>(&self,\n-                             node: &N,\n-                             base_cmt: cmt<'tcx>,\n-                             deref_cnt: usize)\n-                             -> McResult<cmt<'tcx>> {\n-        let method_call = ty::MethodCall {\n-            expr_id: node.id(),\n-            autoderef: deref_cnt as u32\n-        };\n-        let method_ty = self.infcx.node_method_ty(method_call);\n-\n-        debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n-               method_call, method_ty.map(|ty| ty));\n+    pub fn cat_deref<N:ast_node>(&self,\n+                                 node: &N,\n+                                 base_cmt: cmt<'tcx>,\n+                                 overloaded: Option<ty::MethodCallee<'tcx>>)\n+                                 -> McResult<cmt<'tcx>> {\n+        debug!(\"cat_deref: overloaded={:?}\", overloaded);\n \n-        let base_cmt = match method_ty {\n-            Some(method_ty) => {\n-                let ref_ty =\n-                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+        let base_cmt = match overloaded {\n+            Some(method) => {\n+                let ref_ty = self.overloaded_method_return_ty(method);\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -1020,12 +1004,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! - `elt`: the AST node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n \n-        let method_call = ty::MethodCall::expr(elt.id());\n-        let method_ty = self.infcx.node_method_ty(method_call);\n-\n-        let (element_ty, element_kind) = match method_ty {\n-            Some(method_ty) => {\n-                let ref_ty = self.overloaded_method_return_ty(method_ty);\n+        let method = self.infcx.tables.borrow().method_map.get(&elt.id()).cloned();\n+        let (element_ty, element_kind) = match method {\n+            Some(method) => {\n+                let ref_ty = self.overloaded_method_return_ty(method);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n                 (ref_ty.builtin_deref(false, ty::NoPreference).unwrap().ty,\n@@ -1234,7 +1216,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, 0)?;\n+            let method = self.infcx.tables.borrow().method_map\n+                .get(&pat.id).cloned();\n+            let subcmt = self.cat_deref(pat, cmt, method)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n@@ -1262,16 +1246,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn overloaded_method_return_ty(&self,\n-                                   method_ty: Ty<'tcx>)\n+                                   method: ty::MethodCallee<'tcx>)\n                                    -> Ty<'tcx>\n     {\n         // When we process an overloaded `*` or `[]` etc, we often\n         // need to extract the return type of the method. These method\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n-           .unwrap()\n+        let ret_ty = method.ty.fn_ret();\n+        let ret_ty = self.infcx.resolve_type_vars_if_possible(&ret_ty);\n+        self.tcx().no_late_bound_regions(&ret_ty).unwrap()\n     }\n }\n "}, {"sha": "e5cc7aae4e9ceaea4ff861024f1e9263471be7de", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -110,8 +110,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                 Some(self.tables.qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tables.method_map[&method_call].def_id;\n+                let def_id = self.tables.method_map[&expr.id].def_id;\n                 Some(Def::Method(def_id))\n             }\n             _ => None"}, {"sha": "629f94609aa3795cfe4ea4bce8274323920dd270", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 25, "deletions": 48, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n use ty::{self, Ty, TyCtxt, TypeAndMut};\n-use ty::LvaluePreference::{NoPreference};\n-\n-use syntax::ast;\n-use syntax_pos::Span;\n \n use hir;\n \n@@ -43,10 +39,10 @@ pub enum Adjust<'tcx> {\n     /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n     ///\n     /// We transform pointers by following the following steps in order:\n-    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+    /// 1. Deref the pointer through `self.autoderefs` steps (may be no steps).\n     /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n     ///    `&` or `*` pointer.\n-    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+    /// 3. If `unsize` is `true`, then apply the unsize transformation,\n     ///    which will do things like convert thin pointers to fat\n     ///    pointers, or convert structs containing thin pointers to\n     ///    structs containing fat pointers, or convert between fat\n@@ -61,23 +57,26 @@ pub enum Adjust<'tcx> {\n     /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n     /// Here the pointer will be dereferenced N times (where a dereference can\n     /// happen to raw or borrowed pointers or any smart pointer which implements\n-    /// Deref, including Box<_>). The number of dereferences is given by\n+    /// Deref, including Box<_>). The types of dereferences is given by\n     /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n     /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-    /// None.\n+    /// `false`.\n     ///\n     /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n     /// with a thin pointer, deref a number of times, unsize the underlying data,\n     /// then autoref. The 'unsize' phase may change a fixed length array to a\n     /// dynamically sized one, a concrete object to a trait object, or statically\n-    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+    /// sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n     /// represented by:\n     ///\n     /// ```\n-    /// Adjust::DerefRef {\n-    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n-    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+    /// Adjustment {\n+    ///     kind: Adjust::DerefRef {\n+    ///         autoderefs: vec![None],         // &[i32; 4] -> [i32; 4]\n+    ///         autoref: Some(AutoBorrow::Ref), // [i32; 4] -> &[i32; 4]\n+    ///         unsize: true,                   // &[i32; 4] -> &[i32]\n+    ///     },\n+    ///     target: `[i32]`,\n     /// }\n     /// ```\n     ///\n@@ -95,15 +94,18 @@ pub enum Adjust<'tcx> {\n     /// Box<[i32]> is represented by:\n     ///\n     /// ```\n-    /// Adjust::DerefRef {\n-    ///     autoderefs: 0,\n-    ///     autoref: None,\n-    ///     unsize: Some(Box<[i32]>),\n+    /// Adjustment {\n+    ///     Adjust::DerefRef {\n+    ///         autoderefs: vec![],\n+    ///         autoref: None,\n+    ///         unsize: true,\n+    ///     },\n+    ///     target: `Box<[i32]>`,\n     /// }\n     /// ```\n     DerefRef {\n         /// Step 1. Apply a number of dereferences, producing an lvalue.\n-        autoderefs: usize,\n+        autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n \n         /// Step 2. Optionally produce a pointer/reference from the value.\n         autoref: Option<AutoBorrow<'tcx>>,\n@@ -119,7 +121,11 @@ impl<'tcx> Adjustment<'tcx> {\n         match self.kind {\n             Adjust::NeverToAny => self.target.is_never(),\n \n-            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+            Adjust::DerefRef {\n+                ref autoderefs,\n+                autoref: None,\n+                unsize: false\n+            } if autoderefs.is_empty() => true,\n \n             Adjust::ReifyFnPointer |\n             Adjust::UnsafeFnPointer |\n@@ -161,35 +167,6 @@ pub enum CustomCoerceUnsized {\n }\n \n impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   expr_id: ast::NodeId,\n-                                   expr_span: Span,\n-                                   autoderef: u32, // how many autoderefs so far?\n-                                   mut method_type: F)\n-                                   -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        let method_call = ty::MethodCall::autoderef(expr_id, autoderef);\n-        let mut adjusted_ty = self;\n-        if let Some(method_ty) = method_type(method_call) {\n-            // Method calls always have all late-bound regions\n-            // fully instantiated.\n-            adjusted_ty = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-        }\n-        match adjusted_ty.builtin_deref(true, NoPreference) {\n-            Some(mt) => mt.ty,\n-            None => {\n-                span_bug!(\n-                    expr_span,\n-                    \"the {}th autoderef for {} failed: {}\",\n-                    autoderef,\n-                    expr_id,\n-                    adjusted_ty);\n-            }\n-        }\n-    }\n-\n     pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               autoref: Option<AutoBorrow<'tcx>>)\n                               -> Ty<'tcx> {"}, {"sha": "76882b94315374208f400ea15c8f7f94023d5b40", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -222,7 +222,7 @@ pub struct TypeckTables<'tcx> {\n \n     pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n-    pub method_map: ty::MethodMap<'tcx>,\n+    pub method_map: NodeMap<ty::MethodCallee<'tcx>>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n@@ -358,11 +358,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n-        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n-    }\n-\n-    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+        self.method_map.contains_key(&expr_id)\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {"}, {"sha": "08016ac91bf29b8a1a0be0d3dfd8bd4a542ac8e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -398,44 +398,6 @@ pub struct MethodCallee<'tcx> {\n     pub substs: &'tcx Substs<'tcx>\n }\n \n-/// With method calls, we store some extra information in\n-/// side tables (i.e method_map). We use\n-/// MethodCall as a key to index into these tables instead of\n-/// just directly using the expression's NodeId. The reason\n-/// for this being that we may apply adjustments (coercions)\n-/// with the resulting expression also needing to use the\n-/// side tables. The problem with this is that we don't\n-/// assign a separate NodeId to this new expression\n-/// and so it would clash with the base expression if both\n-/// needed to add to the side tables. Thus to disambiguate\n-/// we also keep track of whether there's an adjustment in\n-/// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct MethodCall {\n-    pub expr_id: NodeId,\n-    pub autoderef: u32\n-}\n-\n-impl MethodCall {\n-    pub fn expr(id: NodeId) -> MethodCall {\n-        MethodCall {\n-            expr_id: id,\n-            autoderef: 0\n-        }\n-    }\n-\n-    pub fn autoderef(expr_id: NodeId, autoderef: u32) -> MethodCall {\n-        MethodCall {\n-            expr_id: expr_id,\n-            autoderef: 1 + autoderef\n-        }\n-    }\n-}\n-\n-// maps from an expression id that corresponds to a method call to the details\n-// of the method to be invoked\n-pub type MethodMap<'tcx> = FxHashMap<MethodCall, MethodCallee<'tcx>>;\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "13c69d105302f0d9e1bea2db3be546e9f2914358", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -882,19 +882,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             use rustc::ty::adjustment::*;\n \n             // Check for method calls and overloaded operators.\n-            let opt_m = cx.tables.method_map.get(&ty::MethodCall::expr(id)).cloned();\n-            if let Some(m) = opt_m {\n+            if let Some(m) = cx.tables.method_map.get(&id).cloned() {\n                 if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = cx.tables.adjustments.get(&id).cloned();\n-            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n-                for i in 0..autoderefs {\n-                    let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = cx.tables.method_map.get(&method_call).cloned() {\n+            if let Some(Adjustment {\n+                kind: Adjust::DerefRef { ref autoderefs, .. }, ..\n+            }) = cx.tables.adjustments.get(&id).cloned() {\n+                for &overloaded in autoderefs {\n+                    if let Some(m) = overloaded {\n                         if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }"}, {"sha": "6c48e0120ba7e860c37e7cd2292b475c8353a722", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -31,16 +31,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n-        let adj = cx.tables().adjustments.get(&self.id).cloned();\n+        let adj = cx.tables().adjustments.get(&self.id);\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n                expr,\n                adj);\n \n         // Now apply adjustments, if any.\n-        match adj.map(|adj| (adj.kind, adj.target)) {\n+        match adj.map(|adj| (&adj.kind, adj.target)) {\n             None => {}\n-            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n@@ -49,7 +49,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n@@ -58,7 +58,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some((ty::adjustment::Adjust::ClosureFnPointer, adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::ClosureFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n@@ -67,7 +67,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::ClosureFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n@@ -76,7 +76,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::NeverToAny { source: expr.to_ref() },\n                 };\n             }\n-            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n@@ -85,25 +85,18 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n+            Some((&ty::adjustment::Adjust::DerefRef { ref autoderefs, autoref, unsize },\n                   adjusted_ty)) => {\n-                for i in 0..autoderefs {\n-                    let i = i as u32;\n-                    let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n-                            cx.tables().method_map.get(&mc).map(|m| m.ty)\n-                        });\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n-                           i,\n-                           adjusted_ty);\n-                    let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty = cx.tables().method_map.get(&method_key).map(|m| m.ty);\n-                    let kind = if let Some(meth_ty) = meth_ty {\n-                        debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n-\n-                        let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n-                        let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n+                for &overloaded in autoderefs {\n+                    let mut ref_ty = expr.ty;\n+                    let kind = if let Some(method) = overloaded {\n+                        debug!(\"make_mirror: overloaded autoderef (method={:?})\", method);\n+\n+                        // Method calls always have all late-bound regions\n+                        // fully instantiated.\n+                        ref_ty = cx.tcx.no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n+                        let (region, mutbl) = match ref_ty.sty {\n+                            ty::TyRef(region, mt) => (region, mt.mutbl),\n                             _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n@@ -125,14 +118,22 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n                         overloaded_lvalue(cx,\n                                           self,\n-                                          method_key,\n+                                          method,\n                                           PassArgs::ByRef,\n                                           expr.to_ref(),\n                                           vec![])\n                     } else {\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n                     };\n+                    let adjusted_ty = match ref_ty.builtin_deref(true,\n+                                                ty::LvaluePreference::NoPreference) {\n+                        Some(mt) => mt.ty,\n+                        None => {\n+                            span_bug!(self.span, \"autoderef for {} failed: {}\", self.id, ref_ty);\n+                        }\n+                    };\n+                    debug!(\"make_mirror: autoderef adjusted_ty={:?}\", adjusted_ty);\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n                         temp_lifetime_was_shrunk: was_shrunk,\n@@ -243,7 +244,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // Here comes the interesting stuff:\n         hir::ExprMethodCall(.., ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-            let expr = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n+            let method = cx.tables().method_map[&expr.id];\n+            let expr = method_callee(cx, expr, method);\n             let args = args.iter()\n                 .map(|e| e.to_ref())\n                 .collect();\n@@ -255,15 +257,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n                 // callee-object as expr parameter.\n \n                 // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n-                let method = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n+                let method = method_callee(cx, expr, method);\n \n                 let sig = method.ty.fn_sig();\n \n@@ -352,15 +354,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n                 };\n                 overloaded_operator(cx,\n                                     expr,\n-                                    ty::MethodCall::expr(expr.id),\n+                                    method,\n                                     pass_args,\n                                     lhs.to_ref(),\n                                     vec![rhs])\n@@ -376,15 +378,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n                 };\n                 overloaded_operator(cx,\n                                     expr,\n-                                    ty::MethodCall::expr(expr.id),\n+                                    method,\n                                     pass_args,\n                                     lhs.to_ref(),\n                                     vec![rhs])\n@@ -436,10 +438,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n-                                  ty::MethodCall::expr(expr.id),\n+                                  method,\n                                   PassArgs::ByValue,\n                                   lhs.to_ref(),\n                                   vec![index])\n@@ -452,10 +454,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n-                                  ty::MethodCall::expr(expr.id),\n+                                  method,\n                                   PassArgs::ByValue,\n                                   arg.to_ref(),\n                                   vec![])\n@@ -465,10 +467,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n-                                    ty::MethodCall::expr(expr.id),\n+                                    method,\n                                     PassArgs::ByValue,\n                                     arg.to_ref(),\n                                     vec![])\n@@ -481,10 +483,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n-                                    ty::MethodCall::expr(expr.id),\n+                                    method,\n                                     PassArgs::ByValue,\n                                     arg.to_ref(),\n                                     vec![])\n@@ -703,9 +705,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n-                                 method_call: ty::MethodCall)\n+                                 callee: ty::MethodCallee<'tcx>)\n                                  -> Expr<'tcx> {\n-    let callee = cx.tables().method_map[&method_call];\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -948,7 +949,7 @@ enum PassArgs {\n \n fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                        expr: &'tcx hir::Expr,\n-                                       method_call: ty::MethodCall,\n+                                       method: ty::MethodCallee<'tcx>,\n                                        pass_args: PassArgs,\n                                        receiver: ExprRef<'tcx>,\n                                        args: Vec<&'tcx P<hir::Expr>>)\n@@ -991,7 +992,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n \n     // now create the call itself\n-    let fun = method_callee(cx, expr, method_call);\n+    let fun = method_callee(cx, expr, method);\n     ExprKind::Call {\n         ty: fun.ty,\n         fun: fun.to_ref(),\n@@ -1001,7 +1002,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n-                                     method_call: ty::MethodCall,\n+                                     method: ty::MethodCallee<'tcx>,\n                                      pass_args: PassArgs,\n                                      receiver: ExprRef<'tcx>,\n                                      args: Vec<&'tcx P<hir::Expr>>)\n@@ -1011,14 +1012,14 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let ref_ty = cx.tables().method_map[&method_call].ty.fn_ret();\n+    let ref_ty = method.ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n-    let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n+    let ref_kind = overloaded_operator(cx, expr, method, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,"}, {"sha": "712f5f7ad3906a9c3afb65371f600d8615f87aa0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -280,11 +280,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         _ => {}\n     }\n \n-    let method_call = ty::MethodCall::expr(e.id);\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tables.method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tables.method_map.contains_key(&e.id) => {\n             v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n@@ -381,7 +380,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tables.method_map[&method_call];\n+            let method = v.tables.method_map[&e.id];\n             match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n@@ -450,9 +449,8 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(&Adjust::ClosureFnPointer) |\n         Some(&Adjust::MutToConstPointer) => {}\n \n-        Some(&Adjust::DerefRef { autoderefs, .. }) => {\n-            if (0..autoderefs as u32)\n-                .any(|autoderef| v.tables.is_overloaded_autoderef(e.id, autoderef)) {\n+        Some(&Adjust::DerefRef { ref autoderefs, .. }) => {\n+            if autoderefs.iter().any(|overloaded| overloaded.is_some()) {\n                 v.promotable = false;\n             }\n         }"}, {"sha": "d0809f0f6429d5d9dddad652e6916fa244106d2f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -564,8 +564,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tables.method_map[&method_call].def_id;\n+                let method_id = self.tables.method_map[&expr.id].def_id;\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "098674519b4d804beefa82fbd8bf074c5651d907", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -12,14 +12,12 @@ use astconv::AstConv;\n \n use super::{FnCtxt, LvalueOp};\n \n-use check::coercion::AsCoercionSite;\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n-use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::{LvaluePreference, NoPreference};\n-use rustc::hir;\n+use rustc::ty::adjustment::AutoBorrow;\n \n use syntax_pos::Span;\n use syntax::symbol::Symbol;\n@@ -149,52 +147,45 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n-    pub fn finalize(self, pref: LvaluePreference, expr: &hir::Expr) {\n-        let fcx = self.fcx;\n-        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, &[expr]));\n+    pub fn step_count(&self) -> usize {\n+        self.steps.len()\n+    }\n+\n+    /// Returns the steps required in adjustments (overloaded deref calls).\n+    pub fn adjust_steps(&self, pref: LvaluePreference)\n+                        -> Vec<Option<ty::MethodCallee<'tcx>>> {\n+        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n     }\n \n-    pub fn finalize_as_infer_ok<E>(self, pref: LvaluePreference, exprs: &[E])\n-                                   -> InferOk<'tcx, ()>\n-        where E: AsCoercionSite\n-    {\n-        let Autoderef { fcx, span, mut obligations, steps, .. } = self;\n-        let methods: Vec<_> = steps\n-            .iter()\n-            .map(|&(ty, kind)| {\n-                if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(span, None, ty, pref)\n-                        .map(|InferOk { value, obligations: o }| {\n-                            obligations.extend(o);\n-                            value\n-                        })\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect();\n-\n-        debug!(\"finalize({:?}) - {:?},{:?}\",\n-               pref,\n-               methods,\n-               obligations);\n-\n-        for expr in exprs {\n-            let expr = expr.as_coercion_site();\n-            debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n-            for (n, method) in methods.iter().enumerate() {\n-                if let &Some(method) = method {\n-                    let method_call = MethodCall::autoderef(expr.id, n as u32);\n-                    fcx.tables.borrow_mut().method_map.insert(method_call, method);\n-                }\n+    pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n+                                    -> InferOk<'tcx, Vec<Option<ty::MethodCallee<'tcx>>>> {\n+        let mut obligations = vec![];\n+        let steps: Vec<_> = self.steps.iter().map(|&(ty, kind)| {\n+            if let AutoderefKind::Overloaded = kind {\n+                self.fcx.try_overloaded_deref(self.span, ty, pref)\n+                    .map(|InferOk { value: (_, method), obligations: o }| {\n+                        obligations.extend(o);\n+                        method\n+                    })\n+            } else {\n+                None\n             }\n-        }\n+        }).collect();\n \n         InferOk {\n-            value: (),\n-            obligations\n+            obligations,\n+            value: steps\n         }\n     }\n+\n+    pub fn finalize(self) {\n+        let fcx = self.fcx;\n+        fcx.register_predicates(self.into_obligations());\n+    }\n+\n+    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.obligations\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -211,14 +202,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn try_overloaded_deref(&self,\n                                 span: Span,\n-                                base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n                                 pref: LvaluePreference)\n-                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let rcvr = base_expr.map(|base_expr| super::AdjustedRcvr {\n-            rcvr_expr: base_expr, autoderefs: 0, unsize: false\n-        });\n-\n-        self.try_overloaded_lvalue_op(span, rcvr, base_ty, &[], pref, LvalueOp::Deref)\n+                                -> Option<InferOk<'tcx,\n+                                    (Option<AutoBorrow<'tcx>>,\n+                                     ty::MethodCallee<'tcx>)>> {\n+        self.try_overloaded_lvalue_op(span, base_ty, &[], pref, LvalueOp::Deref)\n     }\n }"}, {"sha": "ce3dbf8c23ed49da653b4bbd5e13c120eb2ca1aa", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::autoderef::Autoderef;\n \n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n use rustc::ty::subst::Subst;\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -33,7 +35,7 @@ pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefI\n }\n \n enum CallStep<'tcx> {\n-    Builtin,\n+    Builtin(Ty<'tcx>),\n     DeferredClosure(ty::FnSig<'tcx>),\n     Overloaded(ty::MethodCallee<'tcx>),\n }\n@@ -49,21 +51,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.structurally_resolved_type(call_expr.span, original_callee_ty);\n \n         let mut autoderef = self.autoderef(callee_expr.span, expr_ty);\n-        let result = autoderef.by_ref()\n-            .flat_map(|(adj_ty, idx)| {\n-                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-            })\n-            .next();\n-        let callee_ty = autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, callee_expr);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n+        }\n+        autoderef.finalize();\n \n         let output = match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n                 self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n             }\n \n-            Some(CallStep::Builtin) => {\n+            Some(CallStep::Builtin(callee_ty)) => {\n                 self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n             }\n \n@@ -89,19 +89,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn try_overloaded_call_step(&self,\n                                 call_expr: &'gcx hir::Expr,\n                                 callee_expr: &'gcx hir::Expr,\n-                                adjusted_ty: Ty<'tcx>,\n-                                autoderefs: usize)\n+                                autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n                                 -> Option<CallStep<'tcx>> {\n-        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n+        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n                call_expr,\n-               adjusted_ty,\n-               autoderefs);\n+               adjusted_ty);\n \n         // If the callee is a bare function or a closure, then we're all set.\n-        match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n+        match adjusted_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n                 self.apply_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n-                return Some(CallStep::Builtin);\n+                return Some(CallStep::Builtin(adjusted_ty));\n             }\n \n             ty::TyClosure(def_id, substs) => {\n@@ -116,15 +116,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n                         .0;\n-                    self.record_deferred_call_resolution(def_id,\n-                                                         Box::new(CallResolution {\n-                                                             call_expr: call_expr,\n-                                                             callee_expr: callee_expr,\n-                                                             adjusted_ty: adjusted_ty,\n-                                                             autoderefs: autoderefs,\n-                                                             fn_sig: fn_sig.clone(),\n-                                                             closure_def_id: def_id,\n-                                                         }));\n+                    let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                    self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n+                        call_expr: call_expr,\n+                        callee_expr: callee_expr,\n+                        adjusted_ty: adjusted_ty,\n+                        autoderefs: autoderefs,\n+                        fn_sig: fn_sig.clone(),\n+                        closure_def_id: def_id,\n+                    });\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n             }\n@@ -137,23 +137,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // over the top. The simplest fix by far is to just ignore\n             // this case and deref again, so we wind up with\n             // `FnMut::call_mut(&mut *x, ())`.\n-            ty::TyRef(..) if autoderefs == 0 => {\n+            ty::TyRef(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }\n \n             _ => {}\n         }\n \n-        self.try_overloaded_call_traits(call_expr, callee_expr, adjusted_ty, autoderefs)\n-            .map(|method_callee| CallStep::Overloaded(method_callee))\n+        self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n+            let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+            self.apply_adjustment(callee_expr.id, Adjustment {\n+                kind: Adjust::DerefRef {\n+                    autoderefs,\n+                    autoref,\n+                    unsize: false\n+                },\n+                target: *method.ty.fn_sig().input(0).skip_binder()\n+            });\n+            CallStep::Overloaded(method)\n+        })\n     }\n \n     fn try_overloaded_call_traits(&self,\n                                   call_expr: &hir::Expr,\n-                                  callee_expr: &hir::Expr,\n-                                  adjusted_ty: Ty<'tcx>,\n-                                  autoderefs: usize)\n-                                  -> Option<ty::MethodCallee<'tcx>> {\n+                                  adjusted_ty: Ty<'tcx>)\n+                                  -> Option<(Option<AutoBorrow<'tcx>>,\n+                                             ty::MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name) in\n             &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n@@ -165,20 +174,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             match self.lookup_method_in_trait_adjusted(call_expr.span,\n-                                                       Some(super::AdjustedRcvr {\n-                                                           rcvr_expr: callee_expr,\n-                                                           autoderefs,\n-                                                           unsize: false\n-                                                       }),\n                                                        method_name,\n                                                        trait_def_id,\n                                                        adjusted_ty,\n                                                        None) {\n                 None => continue,\n-                Some(ok) => {\n-                    let method_callee = self.register_infer_ok_obligations(ok);\n-                    return Some(method_callee);\n-                }\n+                Some(ok) => return Some(self.register_infer_ok_obligations(ok))\n             }\n         }\n \n@@ -313,30 +314,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_overloaded_call_method_map(call_expr, method_callee);\n+        self.tables.borrow_mut().method_map.insert(call_expr.id, method_callee);\n         output_type\n     }\n-\n-    fn write_overloaded_call_method_map(&self,\n-                                        call_expr: &hir::Expr,\n-                                        method_callee: ty::MethodCallee<'tcx>) {\n-        let method_call = ty::MethodCall::expr(call_expr.id);\n-        self.tables.borrow_mut().method_map.insert(method_call, method_callee);\n-    }\n }\n \n #[derive(Debug)]\n-struct CallResolution<'gcx: 'tcx, 'tcx> {\n+pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n     call_expr: &'gcx hir::Expr,\n     callee_expr: &'gcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n-    autoderefs: usize,\n+    autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n }\n \n-impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n+    pub fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {:?}\", self);\n \n         // we should not be invoked until the closure kind has been\n@@ -345,10 +339,8 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr,\n-                                             self.callee_expr,\n-                                             self.adjusted_ty,\n-                                             self.autoderefs) {\n-            Some(method_callee) => {\n+                                             self.adjusted_ty) {\n+            Some((autoref, method_callee)) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature\n                 // from the call trait. This has to be reconciled with\n@@ -370,7 +362,16 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n \n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n \n-                fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n+                fcx.apply_adjustment(self.callee_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs: self.autoderefs,\n+                        autoref,\n+                        unsize: false\n+                    },\n+                    target: method_sig.inputs()[0]\n+                });\n+\n+                fcx.tables.borrow_mut().method_map.insert(self.call_expr.id, method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "78559e470aee5e81ce82c4dc9a92ffef2f4ca600", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -110,7 +110,7 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n \n fn identity<'tcx>() -> Adjust<'tcx> {\n     Adjust::DerefRef {\n-        autoderefs: 0,\n+        autoderefs: vec![],\n         autoref: None,\n         unsize: false,\n     }\n@@ -157,13 +157,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn coerce<E>(&self,\n-                 exprs: &[E],\n-                 a: Ty<'tcx>,\n-                 b: Ty<'tcx>)\n-                 -> CoerceResult<'tcx>\n-        where E: AsCoercionSite\n-    {\n+    fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n@@ -210,7 +204,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n \n             ty::TyRef(r_b, mt_b) => {\n-                return self.coerce_borrowed_pointer(exprs, a, b, r_b, mt_b);\n+                return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n \n             _ => {}\n@@ -245,15 +239,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer<E>(&self,\n-                                  exprs: &[E],\n-                                  a: Ty<'tcx>,\n-                                  b: Ty<'tcx>,\n-                                  r_b: ty::Region<'tcx>,\n-                                  mt_b: TypeAndMut<'tcx>)\n-                                  -> CoerceResult<'tcx>\n-        where E: AsCoercionSite\n-    {\n+    fn coerce_borrowed_pointer(&self,\n+                               a: Ty<'tcx>,\n+                               b: Ty<'tcx>,\n+                               r_b: ty::Region<'tcx>,\n+                               mt_b: TypeAndMut<'tcx>)\n+                               -> CoerceResult<'tcx> {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n@@ -375,7 +366,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                               });\n             match self.unify(derefd_ty_a, b) {\n                 Ok(ok) => {\n-                    found = Some((ok, autoderefs));\n+                    found = Some(ok);\n                     break;\n                 }\n                 Err(err) => {\n@@ -391,7 +382,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let (InferOk { value: ty, mut obligations }, autoderefs) = match found {\n+        let InferOk { value: ty, mut obligations } = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n@@ -400,7 +391,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n+        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -423,17 +414,21 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n+\n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        let InferOk { value: autoderefs, obligations: o }\n+            = autoderef.adjust_steps_as_infer_ok(pref);\n+        obligations.extend(o);\n+        obligations.extend(autoderef.into_obligations());\n+\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n                ty,\n                autoderefs,\n                autoref);\n \n-        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n-        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs).obligations);\n-\n         success(Adjust::DerefRef {\n-            autoderefs: autoderefs,\n-            autoref: autoref,\n+            autoderefs,\n+            autoref,\n             unsize: false,\n         }, ty, obligations)\n     }\n@@ -477,7 +472,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n \n         let adjust = Adjust::DerefRef {\n-            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n+            autoderefs: if reborrow.is_some() { vec![None] } else { vec![] },\n             autoref: reborrow,\n             unsize: true,\n         };\n@@ -668,7 +663,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // regionck knows that the region for `a` must be valid here.\n         self.unify_and(a_unsafe, b, if is_ref {\n             Adjust::DerefRef {\n-                autoderefs: 1,\n+                autoderefs: vec![None],\n                 autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n                 unsize: false,\n             }\n@@ -703,7 +698,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n-        let ok = self.commit_if_ok(|_| coerce.coerce(&[expr], source, target))?;\n+        let ok = self.commit_if_ok(|_| coerce.coerce(source, target))?;\n \n         let adjustment = self.register_infer_ok_obligations(ok);\n         self.apply_adjustment(expr.id, adjustment);\n@@ -721,7 +716,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n-        self.probe(|_| coerce.coerce::<hir::Expr>(&[], source, target)).is_ok()\n+        self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n     /// Given some expressions, their known unified type and another expression,\n@@ -796,7 +791,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| coerce.coerce(&[new], new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n                     let adjustment = self.register_infer_ok_obligations(ok);\n@@ -815,10 +810,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let expr = expr.as_coercion_site();\n             let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| &adj.kind) {\n                 Some(&Adjust::DerefRef {\n-                    autoderefs: 1,\n+                    ref autoderefs,\n                     autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n                     unsize: false\n-                }) => {\n+                }) if autoderefs.len() == 1 => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n@@ -842,7 +837,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| coerce.coerce(&exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| coerce.coerce(prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {"}, {"sha": "b6cd1dfc3d0127e7af9c180af27061edb01380d4", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -136,17 +136,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let (autoderefd_ty, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n \n+        let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+\n         autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, self.self_expr);\n+        autoderef.finalize();\n \n         let target = pick.unsize.unwrap_or(autoderefd_ty);\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n \n         // Write out the final adjustment.\n         self.apply_adjustment(self.self_expr.id, Adjustment {\n             kind: Adjust::DerefRef {\n-                autoderefs: pick.autoderefs,\n-                autoref: autoref,\n+                autoderefs,\n+                autoref,\n                 unsize: pick.unsize.is_some(),\n             },\n             target: target\n@@ -436,19 +438,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let autoderefs = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => autoderefs,\n-                Some(_) | None => 0\n-            };\n-\n-            if autoderefs > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                autoderef.nth(autoderefs).unwrap_or_else(|| {\n-                    span_bug!(expr.span,\n-                              \"expr was deref-able {} times but now isn't?\",\n-                              autoderefs);\n-                });\n-                autoderef.finalize(PreferMutLvalue, expr);\n+            let expr_ty = self.node_ty(expr.id);\n+            if let Some(adj) = self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n+                if let Adjust::DerefRef { ref mut autoderefs, .. } = adj.kind {\n+                    let mut autoderef = self.autoderef(expr.span, expr_ty);\n+                    autoderef.nth(autoderefs.len()).unwrap_or_else(|| {\n+                        span_bug!(expr.span,\n+                                \"expr was deref-able as {:?} but now isn't?\",\n+                                autoderefs);\n+                    });\n+                    *autoderefs = autoderef.adjust_steps(LvaluePreference::PreferMutLvalue);\n+                    autoderef.finalize();\n+                }\n             }\n \n             match expr.node {\n@@ -474,8 +475,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n                op, expr, base_expr, arg_tys);\n-        let method_call = ty::MethodCall::expr(expr.id);\n-        if !self.tables.borrow().method_map.contains_key(&method_call) {\n+        if !self.tables.borrow().method_map.contains_key(&expr.id) {\n             debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n             return\n         }\n@@ -490,14 +490,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .ty;\n \n         let method = self.try_overloaded_lvalue_op(\n-            expr.span, None, base_ty, arg_tys, PreferMutLvalue, op);\n+            expr.span, base_ty, arg_tys, PreferMutLvalue, op);\n         let ok = match method {\n             Some(method) => method,\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n-        let method = self.register_infer_ok_obligations(ok);\n+        let (_, method) = self.register_infer_ok_obligations(ok);\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.tables.borrow_mut().method_map.insert(method_call, method);\n+        self.tables.borrow_mut().method_map.insert(expr.id, method);\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability."}, {"sha": "7397c3d48e79976bfbe3fba355b2431ab13f8ec0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -10,13 +10,13 @@\n \n //! Method lookup: the secret sauce of Rust. See `README.md`.\n \n-use check::{FnCtxt, AdjustedRcvr};\n+use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::AutoBorrow;\n use rustc::ty::subst::Subst;\n use rustc::infer::{self, InferOk};\n \n@@ -166,16 +166,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// this method is basically the same as confirmation.\n     pub fn lookup_method_in_trait_adjusted(&self,\n                                            span: Span,\n-                                           self_info: Option<AdjustedRcvr>,\n                                            m_name: ast::Name,\n                                            trait_def_id: DefId,\n                                            self_ty: ty::Ty<'tcx>,\n-                                           opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                           -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n-        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_info={:?}, \\\n+                                           opt_input_types: Option<&[ty::Ty<'tcx>]>)\n+                                           -> Option<InferOk<'tcx,\n+                                                (Option<AutoBorrow<'tcx>>,\n+                                                 ty::MethodCallee<'tcx>)>> {\n+        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n-               self_info,\n                m_name,\n                trait_def_id);\n \n@@ -237,7 +237,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 value\n             }\n         };\n-        let transformed_self_ty = fn_sig.inputs()[0];\n         let method_ty = tcx.mk_fn_def(def_id, substs, ty::Binder(fn_sig));\n \n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n@@ -267,36 +266,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Also add an obligation for the method type being well-formed.\n         obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n-        // Insert any adjustments needed (always an autoref of some mutability).\n-        if let Some(AdjustedRcvr { rcvr_expr, autoderefs, unsize }) = self_info {\n-            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                    (self-id={}, autoderefs={}, unsize={}, fty={:?})\",\n-                    rcvr_expr.id, autoderefs, unsize, original_method_ty);\n-\n-            let original_sig = original_method_ty.fn_sig();\n-            let autoref = match (&original_sig.input(0).skip_binder().sty,\n-                                 &transformed_self_ty.sty) {\n-                (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n-                    // Trait method is fn(&self) or fn(&mut self), need an\n-                    // autoref. Pull the region etc out of the type of first argument.\n-                    Some(AutoBorrow::Ref(region, mutbl))\n-                }\n-                _ => {\n-                    // Trait method is fn(self), no transformation needed.\n-                    assert!(!unsize);\n-                    None\n-                }\n-            };\n-\n-            self.apply_adjustment(rcvr_expr.id, Adjustment {\n-                kind: Adjust::DerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: autoref,\n-                    unsize: unsize\n-                },\n-                target: transformed_self_ty\n-            });\n-        }\n+        let autoref = match (&original_method_ty.fn_sig().input(0).skip_binder().sty,\n+                                      &method_ty.fn_sig().input(0).skip_binder().sty) {\n+            (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n+                // Trait method is fn(&self) or fn(&mut self), need an\n+                // autoref. Pull the region etc out of the type of first argument.\n+                Some(AutoBorrow::Ref(region, mutbl))\n+            }\n+            _ => {\n+                // Trait method is fn(self), no transformation needed.\n+                None\n+            }\n+        };\n \n         let callee = ty::MethodCallee {\n             def_id: def_id,\n@@ -308,7 +289,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         Some(InferOk {\n             obligations,\n-            value: callee\n+            value: (autoref, callee)\n         })\n     }\n "}, {"sha": "ed37b55d0305710ae7176c55e442a126f3813aa9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 93, "deletions": 99, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -77,6 +77,8 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n+use self::autoderef::Autoderef;\n+use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n@@ -93,7 +95,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n-use rustc::ty::{MethodCall, MethodCallee};\n+use rustc::ty::{MethodCallee};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n@@ -168,7 +170,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // decision. We keep these deferred resolutions grouped by the\n     // def-id of the closure, so that once we decide, we can easily go\n     // back and process them.\n-    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>>>,\n+    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolution<'gcx, 'tcx>>>>,\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n@@ -194,12 +196,6 @@ impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-trait DeferredCallResolution<'gcx, 'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>);\n-}\n-\n-type DeferredCallResolutionHandler<'gcx, 'tcx> = Box<DeferredCallResolution<'gcx, 'tcx>+'tcx>;\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy, Clone, Debug)]\n@@ -375,13 +371,6 @@ pub enum LvalueOp {\n     Index\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct AdjustedRcvr<'a> {\n-    pub rcvr_expr: &'a hir::Expr,\n-    pub autoderefs: usize,\n-    pub unsize: bool\n-}\n-\n /// Tracks whether executing a node may exit normally (versus\n /// return/break/panic, which \"diverge\", leaving dead code in their\n /// wake). Tracked semi-automatically (through type variables marked\n@@ -1729,17 +1718,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn record_deferred_call_resolution(&self,\n                                        closure_def_id: DefId,\n-                                       r: DeferredCallResolutionHandler<'gcx, 'tcx>) {\n+                                       r: DeferredCallResolution<'gcx, 'tcx>) {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_insert(vec![]).push(r);\n     }\n \n     fn remove_deferred_call_resolutions(&self,\n                                         closure_def_id: DefId)\n-                                        -> Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>\n+                                        -> Vec<DeferredCallResolution<'gcx, 'tcx>>\n     {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n-        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(Vec::new())\n+        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(vec![])\n     }\n \n     pub fn tag(&self) -> String {\n@@ -1782,11 +1771,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn apply_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      derefs: usize,\n+                                      autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n                                       adjusted_ty: Ty<'tcx>) {\n         self.apply_adjustment(node_id, Adjustment {\n             kind: Adjust::DerefRef {\n-                autoderefs: derefs,\n+                autoderefs,\n                 autoref: None,\n                 unsize: false\n             },\n@@ -1805,29 +1794,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n-                let composed_kind = match (&entry.get().kind, &adj.kind) {\n+                match (&entry.get().kind, &adj.kind) {\n                     // Applying any adjustment on top of a NeverToAny\n                     // is a valid NeverToAny adjustment, because it can't\n                     // be reached.\n-                    (&Adjust::NeverToAny, _) => Adjust::NeverToAny,\n+                    (&Adjust::NeverToAny, _) => return,\n                     (&Adjust::DerefRef {\n-                        autoderefs: 1,\n+                        autoderefs: ref old,\n                         autoref: Some(AutoBorrow::Ref(..)),\n                         unsize: false\n-                    }, &Adjust::DerefRef { autoderefs, .. }) if autoderefs > 0 => {\n+                    }, &Adjust::DerefRef {\n+                        autoderefs: ref new, ..\n+                    }) if old.len() == 1 && new.len() >= 1 => {\n                         // A reborrow has no effect before a dereference.\n-                        adj.kind\n                     }\n                     // FIXME: currently we never try to compose autoderefs\n                     // and ReifyFnPointer/UnsafeFnPointer, but we could.\n                     _ =>\n                         bug!(\"while adjusting {}, can't compose {:?} and {:?}\",\n                              node_id, entry.get(), adj)\n                 };\n-                *entry.get_mut() = Adjustment {\n-                    kind: composed_kind,\n-                    target: adj.target\n-                };\n+                *entry.get_mut() = adj;\n             }\n         }\n     }\n@@ -2189,32 +2176,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // consolidated.\n \n         let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-\n-        while let Some((adj_ty, autoderefs)) = autoderef.next() {\n-            if let Some(final_mt) = self.try_index_step(\n-                MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n-                    rcvr_expr: base_expr,\n-                    autoderefs,\n-                    unsize: false\n-                }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n-            {\n-                autoderef.finalize(lvalue_pref, base_expr);\n-                return Some(final_mt);\n-            }\n-\n-            if let ty::TyArray(element_ty, _) = adj_ty.sty {\n-                autoderef.finalize(lvalue_pref, base_expr);\n-                let adj_ty = self.tcx.mk_slice(element_ty);\n-                return self.try_index_step(\n-                    MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n-                        rcvr_expr: base_expr,\n-                        autoderefs,\n-                        unsize: true\n-                    }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n-            }\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, lvalue_pref, idx_ty);\n         }\n-        autoderef.unambiguous_final_ty();\n-        None\n+        autoderef.finalize();\n+        result\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef\n@@ -2223,52 +2190,74 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This loop implements one step in that search; the autoderef loop\n     /// is implemented by `lookup_indexing`.\n     fn try_index_step(&self,\n-                      method_call: MethodCall,\n                       expr: &hir::Expr,\n-                      base_expr: Option<AdjustedRcvr>,\n-                      base_span: Span,\n-                      adjusted_ty: Ty<'tcx>,\n+                      base_expr: &hir::Expr,\n+                      autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n                       lvalue_pref: LvaluePreference,\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n-        let tcx = self.tcx;\n+        let mut adjusted_ty = autoderef.unambiguous_final_ty();\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n                expr,\n                base_expr,\n                adjusted_ty,\n                index_ty);\n \n-        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_span));\n \n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n-                // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n-                if let Some(base_expr) = base_expr {\n-                    assert!(!base_expr.unsize);\n-                    self.apply_autoderef_adjustment(\n-                        base_expr.rcvr_expr.id, base_expr.autoderefs, adjusted_ty);\n-                }\n-                return Some((tcx.types.usize, ty));\n+                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_autoderef_adjustment(\n+                    base_expr.id, autoderefs, adjusted_ty);\n+                return Some((self.tcx.types.usize, ty));\n             }\n             _ => {}\n         }\n \n-        // If some lookup succeeds, write callee into table and extract index/element\n-        // type from the method signature.\n-        // If some lookup succeeded, install method in table\n-        let method = self.try_overloaded_lvalue_op(\n-            expr.span, base_expr, adjusted_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n-\n-        method.map(|ok| {\n-            debug!(\"try_index_step: success, using overloaded indexing\");\n-            let method = self.register_infer_ok_obligations(ok);\n-            self.tables.borrow_mut().method_map.insert(method_call, method);\n-            (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n-        })\n+        for &unsize in &[false, true] {\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::TyArray(element_ty, _) = adjusted_ty.sty {\n+                    adjusted_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let method = self.try_overloaded_lvalue_op(\n+                expr.span, adjusted_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let (autoref, method) = self.register_infer_ok_obligations(ok);\n+\n+                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_adjustment(base_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs,\n+                        autoref,\n+                        unsize\n+                    },\n+                    target: *method.ty.fn_sig().input(0).skip_binder()\n+                });\n+\n+                self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n     }\n \n     fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n@@ -2287,16 +2276,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn try_overloaded_lvalue_op(&self,\n                                 span: Span,\n-                                base_expr: Option<AdjustedRcvr>,\n                                 base_ty: Ty<'tcx>,\n                                 arg_tys: &[Ty<'tcx>],\n                                 lvalue_pref: LvaluePreference,\n                                 op: LvalueOp)\n-                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n+                                -> Option<InferOk<'tcx,\n+                                    (Option<AutoBorrow<'tcx>>,\n+                                     ty::MethodCallee<'tcx>)>>\n     {\n-        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?},{:?})\",\n+        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n                span,\n-               base_expr,\n                base_ty,\n                lvalue_pref,\n                op);\n@@ -2306,11 +2295,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let method = match (lvalue_pref, mut_tr) {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(span,\n-                                                     base_expr,\n                                                      mut_op,\n                                                      trait_did,\n                                                      base_ty,\n-                                                     Some(arg_tys.to_owned()))\n+                                                     Some(arg_tys))\n             }\n             _ => None,\n         };\n@@ -2320,11 +2308,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(span,\n-                                                     base_expr,\n                                                      imm_op,\n                                                      trait_did,\n                                                      base_ty,\n-                                                     Some(arg_tys.to_owned()))\n+                                                     Some(arg_tys))\n             }\n             (method, _) => method,\n         };\n@@ -2802,10 +2789,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              expr,\n                                              rcvr) {\n             Ok(method) => {\n-                let method_ty = method.ty;\n-                let method_call = MethodCall::expr(expr.id);\n-                self.tables.borrow_mut().method_map.insert(method_call, method);\n-                method_ty\n+                self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                method.ty\n             }\n             Err(error) => {\n                 if method_name.node != keywords::Invalid.name() {\n@@ -2912,7 +2897,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, autoderefs)) = autoderef.next() {\n+        while let Some((base_t, _)) = autoderef.next() {\n             match base_t.sty {\n                 ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n@@ -2922,8 +2907,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            autoderef.finalize(lvalue_pref, base);\n+                            let autoderefs = autoderef.adjust_steps(lvalue_pref);\n                             self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                            autoderef.finalize();\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n \n@@ -3020,7 +3006,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, autoderefs)) = autoderef.next() {\n+        while let Some((base_t, _)) = autoderef.next() {\n             let field = match base_t.sty {\n                 ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n                     tuple_like = base_def.struct_variant().ctor_kind == CtorKind::Fn;\n@@ -3055,8 +3041,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                autoderef.finalize(lvalue_pref, base);\n+                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n                 self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                autoderef.finalize();\n                 return field_ty;\n             }\n         }\n@@ -3470,11 +3457,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n-                            let method = self.register_infer_ok_obligations(ok);\n+                                expr.span, oprnd_t, lvalue_pref) {\n+                            let (autoref, method) = self.register_infer_ok_obligations(ok);\n+                            self.apply_adjustment(oprnd.id, Adjustment {\n+                                kind: Adjust::DerefRef {\n+                                    autoderefs: vec![],\n+                                    autoref,\n+                                    unsize: false\n+                                },\n+                                target: *method.ty.fn_sig().input(0).skip_binder()\n+                            });\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n-                                                                           method);\n+                            self.tables.borrow_mut().method_map.insert(expr.id, method);\n                         } else {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\"}, {"sha": "0ac568f2090b6408b83a9d731e4f894f30e39162", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -14,6 +14,7 @@ use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n+use rustc::ty::adjustment::{Adjustment, Adjust};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax::ast;\n@@ -184,7 +185,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // particularly for things like `String + &String`.\n         let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n-        let return_ty = self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n+        let return_ty = self.lookup_op_method(expr, lhs_ty, &[rhs_ty_var],\n                                               Symbol::intern(name), trait_def_id,\n                                               lhs_expr);\n \n@@ -214,7 +215,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n                             if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty],\n+                                self.lookup_op_method(expr, ty_mut.ty, &[rhs_ty],\n                                     Symbol::intern(name), trait_def_id,\n                                     lhs_expr).is_ok() {\n                                 err.note(\n@@ -313,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         assert!(op.is_by_value());\n         let mname = Symbol::intern(mname);\n-        match self.lookup_op_method(ex, operand_ty, vec![], mname, trait_did, operand_expr) {\n+        match self.lookup_op_method(ex, operand_ty, &[], mname, trait_did, operand_expr) {\n             Ok(t) => t,\n             Err(()) => {\n                 let actual = self.resolve_type_vars_if_possible(&operand_ty);\n@@ -382,7 +383,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn lookup_op_method(&self,\n                         expr: &'gcx hir::Expr,\n                         lhs_ty: Ty<'tcx>,\n-                        other_tys: Vec<Ty<'tcx>>,\n+                        other_tys: &[Ty<'tcx>],\n                         opname: ast::Name,\n                         trait_did: Option<DefId>,\n                         lhs_expr: &'a hir::Expr)\n@@ -398,11 +399,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let method = match trait_did {\n             Some(trait_did) => {\n-                let lhs_expr = Some(super::AdjustedRcvr {\n-                    rcvr_expr: lhs_expr, autoderefs: 0, unsize: false\n-                });\n                 self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     lhs_expr,\n                                                      opname,\n                                                      trait_did,\n                                                      lhs_ty,\n@@ -413,18 +410,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match method {\n             Some(ok) => {\n-                let method = self.register_infer_ok_obligations(ok);\n+                let (autoref, method) = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible();\n \n-                let method_ty = method.ty;\n-\n-                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n-                let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n-                self.tables.borrow_mut().method_map.insert(method_call, method);\n+                self.apply_adjustment(lhs_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs: vec![],\n+                        autoref,\n+                        unsize: false\n+                    },\n+                    target: *method.ty.fn_sig().input(0).skip_binder()\n+                });\n+                self.tables.borrow_mut().method_map.insert(expr.id, method);\n \n                 // extract return type for method; all late bound regions\n                 // should have been instantiated by now\n-                let ret_ty = method_ty.fn_ret();\n+                let ret_ty = method.ty.fn_ret();\n                 Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap())\n             }\n             None => {"}, {"sha": "6cb9375c5de796d38b1b99b51f549ea28a4670d6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 59, "deletions": 76, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -91,7 +91,7 @@ use middle::region::{CodeExtent, RegionMaps};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -520,8 +520,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n-        let method_call = MethodCall::expr(expr.id);\n-        let opt_method_callee = self.tables.borrow().method_map.get(&method_call).cloned();\n+        let opt_method_callee = self.tables.borrow().method_map.get(&expr.id).cloned();\n         let has_method_map = opt_method_callee.is_some();\n \n         // If we are calling a method (either explicitly or via an\n@@ -548,11 +547,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         if let Some(adjustment) = adjustment {\n             debug!(\"adjustment={:?}\", adjustment);\n             match adjustment.kind {\n-                adjustment::Adjust::DerefRef { autoderefs, ref autoref, .. } => {\n-                    let expr_ty = self.resolve_node_type(expr.id);\n-                    self.constrain_autoderefs(expr, autoderefs, expr_ty);\n+                adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, .. } => {\n+                    let cmt = ignore_err!(self.constrain_autoderefs(expr, autoderefs));\n                     if let Some(ref autoref) = *autoref {\n-                        self.link_autoref(expr, autoderefs, autoref);\n+                        self.link_autoref(expr, cmt, autoref);\n \n                         // Require that the resulting region encompasses\n                         // the current node.\n@@ -690,8 +688,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n-                let method_call = MethodCall::expr(expr.id);\n-                let base_ty = match self.tables.borrow().method_map.get(&method_call) {\n+                let base_ty = match self.tables.borrow().method_map.get(&expr.id) {\n                     Some(method) => {\n                         self.constrain_call(expr, Some(&base),\n                                             None::<hir::Expr>.iter(), true);\n@@ -914,79 +911,68 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n     fn constrain_autoderefs(&mut self,\n                             deref_expr: &hir::Expr,\n-                            derefs: usize,\n-                            mut derefd_ty: Ty<'tcx>)\n+                            autoderefs: &[Option<ty::MethodCallee<'tcx>>])\n+                            -> mc::McResult<mc::cmt<'tcx>>\n     {\n-        debug!(\"constrain_autoderefs(deref_expr={:?}, derefs={}, derefd_ty={:?})\",\n+        debug!(\"constrain_autoderefs(deref_expr={:?}, autoderefs={:?})\",\n                deref_expr,\n-               derefs,\n-               derefd_ty);\n+               autoderefs);\n+\n+        let mut cmt = {\n+            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n+            mc.cat_expr_unadjusted(deref_expr)?\n+        };\n \n         let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n-        for i in 0..derefs {\n-            let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n-            debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n-\n-            let method = self.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n-\n-            derefd_ty = match method {\n-                Some(method) => {\n-                    debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n-                           i, method);\n-\n-                    let origin = infer::ParameterOrigin::OverloadedDeref;\n-                    self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n-\n-                    // Treat overloaded autoderefs as if an AutoBorrow adjustment\n-                    // was applied on the base type, as that is always the case.\n-                    let fn_sig = method.ty.fn_sig();\n-                    let fn_sig = // late-bound regions should have been instantiated\n-                        self.tcx.no_late_bound_regions(&fn_sig).unwrap();\n-                    let self_ty = fn_sig.inputs()[0];\n-                    let (m, r) = match self_ty.sty {\n-                        ty::TyRef(r, ref m) => (m.mutbl, r),\n-                        _ => {\n-                            span_bug!(\n-                                deref_expr.span,\n-                                \"bad overloaded deref type {:?}\",\n-                                method.ty)\n-                        }\n-                    };\n-\n-                    debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                           r, m);\n-\n-                    {\n-                        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                        let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n-                        debug!(\"constrain_autoderefs: self_cmt={:?}\",\n-                               self_cmt);\n-                        self.link_region(deref_expr.span, r,\n-                                         ty::BorrowKind::from_mutbl(m), self_cmt);\n+        for &overloaded in autoderefs {\n+            if let Some(method) = overloaded {\n+                debug!(\"constrain_autoderefs: overloaded, method={:?}\", method);\n+\n+                let origin = infer::ParameterOrigin::OverloadedDeref;\n+                self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n+\n+                // Treat overloaded autoderefs as if an AutoBorrow adjustment\n+                // was applied on the base type, as that is always the case.\n+                let fn_sig = method.ty.fn_sig();\n+                let fn_sig = // late-bound regions should have been instantiated\n+                    self.tcx.no_late_bound_regions(&fn_sig).unwrap();\n+                let self_ty = fn_sig.inputs()[0];\n+                let (m, r) = match self_ty.sty {\n+                    ty::TyRef(r, ref m) => (m.mutbl, r),\n+                    _ => {\n+                        span_bug!(\n+                            deref_expr.span,\n+                            \"bad overloaded deref type {:?}\",\n+                            method.ty)\n                     }\n+                };\n \n-                    // Specialized version of constrain_call.\n-                    self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n-                                           self_ty, r_deref_expr);\n-                    self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                           fn_sig.output(), r_deref_expr);\n-                    fn_sig.output()\n-                }\n-                None => derefd_ty\n-            };\n+                debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n+                       r, m);\n \n-            if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n-                self.mk_subregion_due_to_dereference(deref_expr.span,\n-                                                     r_deref_expr, r_ptr);\n+                debug!(\"constrain_autoderefs: self_cmt={:?}\", cmt);\n+                self.link_region(deref_expr.span, r,\n+                                 ty::BorrowKind::from_mutbl(m), cmt.clone());\n+\n+                // Specialized version of constrain_call.\n+                self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n+                                       self_ty, r_deref_expr);\n+                self.type_must_outlive(infer::CallReturn(deref_expr.span),\n+                                       fn_sig.output(), r_deref_expr);\n             }\n \n-            match derefd_ty.builtin_deref(true, ty::NoPreference) {\n-                Some(mt) => derefd_ty = mt.ty,\n-                /* if this type can't be dereferenced, then there's already an error\n-                   in the session saying so. Just bail out for now */\n-                None => break\n+            {\n+                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n+                cmt = mc.cat_deref(deref_expr, cmt, overloaded)?;\n+            }\n+\n+            if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n+                self.mk_subregion_due_to_dereference(deref_expr.span,\n+                                                     r_deref_expr, r_ptr);\n             }\n         }\n+\n+        Ok(cmt)\n     }\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n@@ -1151,13 +1137,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n-                    autoderefs: usize,\n+                    expr_cmt: mc::cmt<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n-        debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n-        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-        debug!(\"expr_cmt={:?}\", expr_cmt);\n+        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {"}, {"sha": "286d0ad1b35a39e73d47472779f33bfc38302294", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -216,9 +216,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n-            let mut deferred_call_resolutions =\n+            let deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n-            for deferred_call_resolution in &mut deferred_call_resolutions {\n+            for deferred_call_resolution in deferred_call_resolutions {\n                 deferred_call_resolution.resolve(self.fcx);\n             }\n         }"}, {"sha": "5fa5bb8f7af99269b645185d0e6fa9acd3defa3e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4988f07920324830558e79a1a5b3233511cfbd9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b4988f07920324830558e79a1a5b3233511cfbd9", "patch": "@@ -16,7 +16,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n-use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n+use rustc::ty::{self, Ty, TyCtxt, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::util::nodemap::DefIdSet;\n@@ -106,7 +106,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                    self.fcx.tables.borrow_mut().method_map.remove(&e.id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n@@ -118,7 +118,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                    self.fcx.tables.borrow_mut().method_map.remove(&e.id);\n \n                     // weird but true: the by-ref binops put an\n                     // adjustment on the lhs but not the rhs; the\n@@ -164,7 +164,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(e.span, e.id);\n-        self.visit_method_map_entry(e.span, MethodCall::expr(e.id));\n+        self.visit_method_map_entry(e.span, e.id);\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n@@ -335,13 +335,16 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     }\n \n                     adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n-                        for autoderef in 0..autoderefs {\n-                            let method_call = MethodCall::autoderef(node_id, autoderef as u32);\n-                            self.visit_method_map_entry(span, method_call);\n-                        }\n-\n                         adjustment::Adjust::DerefRef {\n-                            autoderefs: autoderefs,\n+                            autoderefs: autoderefs.iter().map(|overloaded| {\n+                                overloaded.map(|method| {\n+                                    MethodCallee {\n+                                        def_id: method.def_id,\n+                                        ty: self.resolve(&method.ty, &span),\n+                                        substs: self.resolve(&method.substs, &span),\n+                                    }\n+                                })\n+                            }).collect(),\n                             autoref: self.resolve(&autoref, &span),\n                             unsize: unsize,\n                         }\n@@ -359,27 +362,22 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_method_map_entry(&mut self,\n                               method_span: Span,\n-                              method_call: MethodCall) {\n+                              node_id: ast::NodeId) {\n         // Resolve any method map entry\n-        let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&method_call) {\n+        let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&node_id) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n-                       method_call,\n-                       method);\n-                let new_method = MethodCallee {\n+                Some(MethodCallee {\n                     def_id: method.def_id,\n                     ty: self.resolve(&method.ty, &method_span),\n                     substs: self.resolve(&method.substs, &method_span),\n-                };\n-\n-                Some(new_method)\n+                })\n             }\n             None => None\n         };\n \n         //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n         if let Some(method) = new_method {\n-            self.tables.method_map.insert(method_call, method);\n+            self.tables.method_map.insert(node_id, method);\n         }\n     }\n "}]}