{"sha": "4c9cefa12232aa0224b1680f51654fe10f5cf3b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOWNlZmExMjIzMmFhMDIyNGIxNjgwZjUxNjU0ZmUxMGY1Y2YzYjc=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-18T08:51:52Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-31T16:50:33Z"}, "message": "Move linting out in its own function", "tree": {"sha": "986525ba1c71445e0a0975503250ebb739ce5bac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/986525ba1c71445e0a0975503250ebb739ce5bac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9cefa12232aa0224b1680f51654fe10f5cf3b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl7T4FkACgkQaTCGhp1Q\nZjfWRg/5AZC8gzO0rrXHppRkzSv90K6qxUXaaLUucwJCzdoM+nO9Sp21ZEpMdDTJ\nPWsQzrFbRfF1YlA8YUdcRQAOYGilub+qwsIhImuACVA1K+DcSmu+H+nM4nVo2EgH\nymJR+A34AWWzK412/HxGz9QEt2NloAh1v8XpkcPL9aBCmxfKDwa3sLH3ny6zP0aX\nYzR2lY+qP1SM6f2B5BOQGXbrF91qaNO2KY9x9g/rvNkaXsk6V2XPbt4Q7h0cnjhW\nhNNpQWV+QoO6CX2Yph6Z6DVSZZmTMdsaBOzDcxrzsZWBeMUUayu6YQlxL5MWA2P4\na5TYuqAA+ssZsiCQodlvxDpuinUJoSFKbcxtaqZotnFY1Xjhy6ck3i7qrwD4ZO6a\nuO7ATBJ9aC7LNSUNqI/wGGXvhIiA8SGwsOHxb+JveprBlZdOrrkNf34qW/P2Hzwq\n1O223d3Ni8LmPlxqpDWMAurVFfKcRBuftMkx288QBxqQd4ywOrwpoN8OG39qp/h+\nDiaijbzDOHqBoS02bzH03ihiip5aak/xHn9gm4OAkvenbQ13/erh33Mn8o+gtJw8\n9UWsxnqxvOkdU28cF1PI8m0Luq442EnvZipq0K7nGhVNE4fNWc39uEQCvEbFhiIf\nIQgYfK9YdKv0a3cg68Pgb4bIzpFZccPsKVhWsBJZi4cXxWt2uP4=\n=fuvT\n-----END PGP SIGNATURE-----", "payload": "tree 986525ba1c71445e0a0975503250ebb739ce5bac\nparent f9c325f5b657e0c37ba2016a51cddbeab7f7693f\nauthor flip1995 <hello@philkrones.com> 1582015912 +0100\ncommitter flip1995 <hello@philkrones.com> 1590943833 +0200\n\nMove linting out in its own function\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9cefa12232aa0224b1680f51654fe10f5cf3b7", "html_url": "https://github.com/rust-lang/rust/commit/4c9cefa12232aa0224b1680f51654fe10f5cf3b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9cefa12232aa0224b1680f51654fe10f5cf3b7/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c325f5b657e0c37ba2016a51cddbeab7f7693f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c325f5b657e0c37ba2016a51cddbeab7f7693f", "html_url": "https://github.com/rust-lang/rust/commit/f9c325f5b657e0c37ba2016a51cddbeab7f7693f"}], "stats": {"total": 171, "additions": 91, "deletions": 80}, "files": [{"sha": "6866635b904be4e10fce8d047fe994c5550aba86", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 91, "deletions": 80, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/4c9cefa12232aa0224b1680f51654fe10f5cf3b7/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9cefa12232aa0224b1680f51654fe10f5cf3b7/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=4c9cefa12232aa0224b1680f51654fe10f5cf3b7", "patch": "@@ -779,96 +779,107 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n         match expr.kind {\n             ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n-                let mut args_to_recover = vec![];\n-                for arg in args {\n-                    if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n-                        if let ExprKind::Match(.., match_source) = &arg.kind {\n-                            if *match_source == MatchSource::TryDesugar {\n-                                continue;\n+                let args_to_recover = args\n+                    .iter()\n+                    .filter(|arg| {\n+                        if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n+                            if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n+                                false\n+                            } else {\n+                                true\n                             }\n+                        } else {\n+                            false\n                         }\n-\n-                        args_to_recover.push(arg);\n-                    }\n-                }\n+                    })\n+                    .collect::<Vec<_>>();\n                 if !args_to_recover.is_empty() {\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    span_lint_and_then(cx, UNIT_ARG, expr.span, \"passing a unit value to a function\", |db| {\n-                        let mut or = \"\";\n-                        args_to_recover\n-                            .iter()\n-                            .filter_map(|arg| {\n-                                if_chain! {\n-                                    if let ExprKind::Block(block, _) = arg.kind;\n-                                    if block.expr.is_none();\n-                                    if let Some(last_stmt) = block.stmts.iter().last();\n-                                    if let StmtKind::Semi(last_expr) = last_stmt.kind;\n-                                    if let Some(snip) = snippet_opt(cx, last_expr.span);\n-                                    then {\n-                                        Some((\n-                                            last_stmt.span,\n-                                            snip,\n-                                        ))\n-                                    }\n-                                    else {\n-                                        None\n-                                    }\n-                                }\n-                            })\n-                            .for_each(|(span, sugg)| {\n-                                db.span_suggestion(\n-                                    span,\n-                                    \"remove the semicolon from the last statement in the block\",\n-                                    sugg,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                or = \"or \";\n-                            });\n-                        let sugg = args_to_recover\n-                            .iter()\n-                            .enumerate()\n-                            .map(|(i, arg)| {\n-                                let indent = if i == 0 {\n-                                    0\n-                                } else {\n-                                    indent_of(cx, expr.span).unwrap_or(0)\n-                                };\n-                                format!(\n-                                    \"{}{};\",\n-                                    \" \".repeat(indent),\n-                                    snippet_block_with_applicability(\n-                                        cx,\n-                                        arg.span,\n-                                        \"..\",\n-                                        Some(expr.span),\n-                                        &mut applicability\n-                                    )\n-                                )\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\"\\n\");\n-                        db.span_suggestion(\n-                            expr.span.with_hi(expr.span.lo()),\n-                            &format!(\"{}move the expressions in front of the call...\", or),\n-                            format!(\"{}\\n\", sugg),\n-                            applicability,\n-                        );\n-                        db.multipart_suggestion(\n-                            \"...and use unit literals instead\",\n-                            args_to_recover\n-                                .iter()\n-                                .map(|arg| (arg.span, \"()\".to_string()))\n-                                .collect::<Vec<_>>(),\n-                            applicability,\n-                        );\n-                    });\n+                    lint_unit_args(cx, expr, &args_to_recover);\n                 }\n             },\n             _ => (),\n         }\n     }\n }\n \n+fn lint_unit_args(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let (singular, plural) = if args_to_recover.len() > 1 {\n+        (\"\", \"s\")\n+    } else {\n+        (\"a \", \"\")\n+    };\n+    span_lint_and_then(\n+        cx,\n+        UNIT_ARG,\n+        expr.span,\n+        &format!(\"passing {}unit value{} to a function\", singular, plural),\n+        |db| {\n+            let mut or = \"\";\n+            args_to_recover\n+                .iter()\n+                .filter_map(|arg| {\n+                    if_chain! {\n+                        if let ExprKind::Block(block, _) = arg.kind;\n+                        if block.expr.is_none();\n+                        if let Some(last_stmt) = block.stmts.iter().last();\n+                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n+                        then {\n+                            Some((\n+                                last_stmt.span,\n+                                snip,\n+                            ))\n+                        }\n+                        else {\n+                            None\n+                        }\n+                    }\n+                })\n+                .for_each(|(span, sugg)| {\n+                    db.span_suggestion(\n+                        span,\n+                        \"remove the semicolon from the last statement in the block\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    or = \"or \";\n+                });\n+            let sugg = args_to_recover\n+                .iter()\n+                .enumerate()\n+                .map(|(i, arg)| {\n+                    let indent = if i == 0 {\n+                        0\n+                    } else {\n+                        indent_of(cx, expr.span).unwrap_or(0)\n+                    };\n+                    format!(\n+                        \"{}{};\",\n+                        \" \".repeat(indent),\n+                        snippet_block_with_applicability(cx, arg.span, \"..\", Some(expr.span), &mut applicability)\n+                    )\n+                })\n+                .collect::<Vec<String>>()\n+                .join(\"\\n\");\n+            db.span_suggestion(\n+                expr.span.with_hi(expr.span.lo()),\n+                &format!(\"{}move the expression{} in front of the call...\", or, plural),\n+                format!(\"{}\\n\", sugg),\n+                applicability,\n+            );\n+            db.multipart_suggestion(\n+                &format!(\"...and use {}unit literal{} instead\", singular, plural),\n+                args_to_recover\n+                    .iter()\n+                    .map(|arg| (arg.span, \"()\".to_string()))\n+                    .collect::<Vec<_>>(),\n+                applicability,\n+            );\n+        },\n+    );\n+}\n+\n fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::DesugaringKind;\n     if let ExprKind::Call(ref callee, _) = expr.kind {"}]}