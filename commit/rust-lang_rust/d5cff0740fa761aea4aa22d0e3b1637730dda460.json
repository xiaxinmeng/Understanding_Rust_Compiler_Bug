{"sha": "d5cff0740fa761aea4aa22d0e3b1637730dda460", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Y2ZmMDc0MGZhNzYxYWVhNGFhMjJkMGUzYjE2Mzc3MzBkZGE0NjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-01T18:55:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-13T11:03:28Z"}, "message": "normalize fn sig as part of reification", "tree": {"sha": "fe4de9be73027acac867889c25a84fbfebb61ce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4de9be73027acac867889c25a84fbfebb61ce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5cff0740fa761aea4aa22d0e3b1637730dda460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5cff0740fa761aea4aa22d0e3b1637730dda460", "html_url": "https://github.com/rust-lang/rust/commit/d5cff0740fa761aea4aa22d0e3b1637730dda460", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5cff0740fa761aea4aa22d0e3b1637730dda460/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c26d8fcd1b171beaf467d1e6ea0157b88bc5a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c26d8fcd1b171beaf467d1e6ea0157b88bc5a2a", "html_url": "https://github.com/rust-lang/rust/commit/0c26d8fcd1b171beaf467d1e6ea0157b88bc5a2a"}], "stats": {"total": 182, "additions": 124, "deletions": 58}, "files": [{"sha": "0fa24b3478d51c992fbb558632a2a3ebd379f3d5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 86, "deletions": 58, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d5cff0740fa761aea4aa22d0e3b1637730dda460/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5cff0740fa761aea4aa22d0e3b1637730dda460/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=d5cff0740fa761aea4aa22d0e3b1637730dda460", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, Ty, TyCtxt, TypeVariants, ToPolyTraitRef};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::tcx::PlaceTy;\n@@ -193,13 +193,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                             assert_eq!(def_id, ty_def_id);\n                             substs\n                         }\n-                        _ => {\n-                            span_bug!(\n-                                self.last_span,\n-                                \"unexpected type for constant function: {:?}\",\n-                                value.ty\n-                            )\n-                        }\n+                        _ => span_bug!(\n+                            self.last_span,\n+                            \"unexpected type for constant function: {:?}\",\n+                            value.ty\n+                        ),\n                     };\n \n                     let instantiated_predicates =\n@@ -585,12 +583,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n         }\n \n-        self.infcx.process_registered_region_obligations(\n-            &[],\n-            None,\n-            self.param_env,\n-            self.body_id,\n-        );\n+        self.infcx\n+            .process_registered_region_obligations(&[], None, self.param_env, self.body_id);\n \n         let data = self.infcx.take_and_reset_region_constraints();\n         if !data.is_empty() {\n@@ -1164,18 +1158,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n \n-            Rvalue::Repeat(operand, const_usize) => {\n-                if const_usize.as_u64() > 1 {\n-                    let operand_ty = operand.ty(mir, tcx);\n+            Rvalue::Repeat(operand, const_usize) => if const_usize.as_u64() > 1 {\n+                let operand_ty = operand.ty(mir, tcx);\n \n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().copy_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(operand_ty, &[]),\n-                    };\n+                let trait_ref = ty::TraitRef {\n+                    def_id: tcx.lang_items().copy_trait().unwrap(),\n+                    substs: tcx.mk_substs_trait(operand_ty, &[]),\n+                };\n \n-                    self.prove_trait_ref(trait_ref, location);\n-                }\n-            }\n+                self.prove_trait_ref(trait_ref, location);\n+            },\n \n             Rvalue::NullaryOp(_, ty) => {\n                 let trait_ref = ty::TraitRef {\n@@ -1186,50 +1178,87 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.prove_trait_ref(trait_ref, location);\n             }\n \n-            Rvalue::Cast(cast_kind, op, ty) => {\n-                match cast_kind {\n-                    CastKind::ReifyFnPointer => {\n-                        let ty_fn_ptr_from = tcx.mk_fn_ptr(op.ty(mir, tcx).fn_sig(tcx));\n+            Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n+                CastKind::ReifyFnPointer => {\n+                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n \n-                        if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n-                            span_mirbug!(self, \"\", \"casting {:?}\", terr);\n-                        }\n-                    }\n+                    // The type that we see in the fcx is like\n+                    // `foo::<'a, 'b>`, where `foo` is the path to a\n+                    // function definition. When we extract the\n+                    // signature, it comes from the `fn_sig` query,\n+                    // and hence may contain unnormalized results.\n+                    let fn_sig = self.normalize(&fn_sig, location);\n \n-                    CastKind::ClosureFnPointer => {\n-                        let sig = match op.ty(mir, tcx).sty {\n-                            ty::TyClosure(def_id, substs) => {\n-                                substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n+                    let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n-                        if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n-                            span_mirbug!(self, \"\", \"casting {:?}\", terr);\n-                        }\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n                     }\n+                }\n \n-                    CastKind::UnsafeFnPointer => {\n-                        let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(op.ty(mir, tcx).fn_sig(tcx));\n-\n-                        if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n-                            span_mirbug!(self, \"\", \"casting {:?}\", terr);\n+                CastKind::ClosureFnPointer => {\n+                    let sig = match op.ty(mir, tcx).sty {\n+                        ty::TyClosure(def_id, substs) => {\n+                            substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n                         }\n+                        _ => bug!(),\n+                    };\n+                    let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n+\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n                     }\n+                }\n \n-                    CastKind::Unsize => {\n-                        let trait_ref = ty::TraitRef {\n-                            def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty]),\n-                        };\n+                CastKind::UnsafeFnPointer => {\n+                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+\n+                    // The type that we see in the fcx is like\n+                    // `foo::<'a, 'b>`, where `foo` is the path to a\n+                    // function definition. When we extract the\n+                    // signature, it comes from the `fn_sig` query,\n+                    // and hence may contain unnormalized results.\n+                    let fn_sig = self.normalize(&fn_sig, location);\n \n-                        self.prove_trait_ref(trait_ref, location);\n+                    let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n+\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n                     }\n+                }\n \n-                    CastKind::Misc => {}\n+                CastKind::Unsize => {\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty]),\n+                    };\n+\n+                    self.prove_trait_ref(trait_ref, location);\n                 }\n-            }\n+\n+                CastKind::Misc => {}\n+            },\n \n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..) |\n@@ -1344,8 +1373,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n             }\n \n-            AggregateKind::Array(_) |\n-            AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n+            AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n         };\n \n         let predicates = self.normalize(&instantiated_predicates.predicates, location);"}, {"sha": "11918d3739d4bf8b4ca1e6b816708550660b3e91", "filename": "src/test/run-pass/mir-typeck-normalize-fn-sig.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d5cff0740fa761aea4aa22d0e3b1637730dda460/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5cff0740fa761aea4aa22d0e3b1637730dda460/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs?ref=d5cff0740fa761aea4aa22d0e3b1637730dda460", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This code was creating an ICE in the MIR type checker. The reason\n+// is that we are reifying a reference to a function (`foo::<'x>`),\n+// which involves extracting its signature, but we were not\n+// normalizing the signature afterwards. As a result, we sometimes got\n+// errors around the `<u32 as Foo<'x>>::Value`, which can be\n+// normalized to `f64`.\n+\n+#![allow(dead_code)]\n+\n+trait Foo<'x> {\n+    type Value;\n+}\n+\n+impl<'x> Foo<'x> for u32 {\n+    type Value = f64;\n+}\n+\n+struct Providers<'x> {\n+    foo: for<'y> fn(x: &'x u32, y: &'y u32) -> <u32 as Foo<'x>>::Value,\n+}\n+\n+fn foo<'y, 'x: 'x>(x: &'x u32, y: &'y u32) -> <u32 as Foo<'x>>::Value {\n+    *x as f64\n+}\n+\n+fn main() {\n+    Providers { foo };\n+}"}]}