{"sha": "837bf370de144a682041e68bb67469b9f68a55ce", "node_id": "C_kwDOAAsO6NoAKDgzN2JmMzcwZGUxNDRhNjgyMDQxZTY4YmI2NzQ2OWI5ZjY4YTU1Y2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-28T04:18:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-28T04:18:19Z"}, "message": "Auto merge of #102388 - JohnTitor:rollup-mbyw6fl, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #100747 (Add long description and test for E0311)\n - #102232 (Stabilize bench_black_box)\n - #102288 (Suggest unwrapping `???<T>` if a method cannot be found on it but is present on `T`.)\n - #102338 (Deny associated type bindings within associated type bindings)\n - #102347 (Unescaping cleanups)\n - #102348 (Tweak `FulfillProcessor`.)\n - #102378 (Use already resolved `self_ty` in `confirm_fn_pointer_candidate`)\n - #102380 (rustdoc: remove redundant mobile `.source > .sidebar` CSS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ad6fb53f2919d4c12d206c01acf057104ff212aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad6fb53f2919d4c12d206c01acf057104ff212aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/837bf370de144a682041e68bb67469b9f68a55ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/837bf370de144a682041e68bb67469b9f68a55ce", "html_url": "https://github.com/rust-lang/rust/commit/837bf370de144a682041e68bb67469b9f68a55ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/837bf370de144a682041e68bb67469b9f68a55ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6734be398fde0b078cde298e0d84eeccd71d08e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6734be398fde0b078cde298e0d84eeccd71d08e", "html_url": "https://github.com/rust-lang/rust/commit/d6734be398fde0b078cde298e0d84eeccd71d08e"}, {"sha": "ce15514df969522d507c6ab63f7472dc2c45d86c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce15514df969522d507c6ab63f7472dc2c45d86c", "html_url": "https://github.com/rust-lang/rust/commit/ce15514df969522d507c6ab63f7472dc2c45d86c"}], "stats": {"total": 749, "additions": 622, "deletions": 127}, "files": [{"sha": "ad108c34992e30efa101dc5d71fa5f832e45788f", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,4 +1,4 @@\n-#![feature(core_intrinsics, generators, generator_trait, is_sorted, bench_black_box)]\n+#![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n \n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;"}, {"sha": "75779622b54cd2d255b1781074bdf3932ddf8796", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -3,7 +3,7 @@\n // Run-time:\n //   status: 0\n \n-#![feature(bench_black_box, const_black_box, core_intrinsics, start)]\n+#![feature(const_black_box, core_intrinsics, start)]\n \n #![no_std]\n "}, {"sha": "1e86d159668ffe5d6b1bca194df8bb1a359c6d18", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -159,6 +159,7 @@ E0307: include_str!(\"./error_codes/E0307.md\"),\n E0308: include_str!(\"./error_codes/E0308.md\"),\n E0309: include_str!(\"./error_codes/E0309.md\"),\n E0310: include_str!(\"./error_codes/E0310.md\"),\n+E0311: include_str!(\"./error_codes/E0311.md\"),\n E0312: include_str!(\"./error_codes/E0312.md\"),\n E0316: include_str!(\"./error_codes/E0316.md\"),\n E0317: include_str!(\"./error_codes/E0317.md\"),\n@@ -568,7 +569,6 @@ E0790: include_str!(\"./error_codes/E0790.md\"),\n //  E0300, // unexpanded macro\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n-    E0311, // thing may not live long enough\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured\n            // variable\n //  E0314, // closure outlives stack frame"}, {"sha": "08159d3f469ac8bad44d7385ffa0ab41b3e710ad", "filename": "compiler/rustc_error_codes/src/error_codes/E0311.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,42 @@\n+This error occurs when there is an unsatisfied outlives bound involving an\n+elided region and a generic type parameter or associated type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0311\n+fn no_restriction<T>(x: &()) -> &() {\n+    with_restriction::<T>(x)\n+}\n+\n+fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    x\n+}\n+```\n+\n+Why doesn't this code compile? It helps to look at the lifetime bounds that are\n+automatically added by the compiler. For more details see the documentation for\n+[lifetime elision]( https://doc.rust-lang.org/reference/lifetime-elision.html).\n+\n+The compiler elides the lifetime of `x` and the return type to some arbitrary\n+lifetime `'anon` in `no_restriction()`. The only information available to the\n+compiler is that `'anon` is valid for the duration of the function. When\n+calling `with_restriction()`, the compiler requires the completely unrelated\n+type parameter `T` to outlive `'anon` because of the `T: 'a` bound in\n+`with_restriction()`. This causes an error because `T` is not required to\n+outlive `'anon` in `no_restriction()`.\n+\n+If `no_restriction()` were to use `&T` instead of `&()` as an argument, the\n+compiler would have added an implied bound, causing this to compile.\n+\n+This error can be resolved by explicitly naming the elided lifetime for `x` and\n+then explicily requiring that the generic parameter `T` outlives that lifetime:\n+\n+```\n+fn no_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    with_restriction::<T>(x)\n+}\n+\n+fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    x\n+}\n+```"}, {"sha": "244018ebbeb7434cd6681b01319ca30a3f9c94ce", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -595,16 +595,22 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             \"create_substs_for_associated_item(span: {:?}, item_def_id: {:?}, item_segment: {:?}\",\n             span, item_def_id, item_segment\n         );\n-        self.create_substs_for_ast_path(\n+        let (args, _) = self.create_substs_for_ast_path(\n             span,\n             item_def_id,\n             parent_substs,\n             item_segment,\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n-        )\n-        .0\n+        );\n+\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(item_segment.args());\n+        if let Some(b) = assoc_bindings.first() {\n+            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+        }\n+\n+        args\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's"}, {"sha": "0e82e4956c7c17d582329b4c3a7f313c260f9f1f", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "modified", "additions": 149, "deletions": 61, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::check::FnCtxt;\n+use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -30,7 +31,7 @@ use rustc_trait_selection::traits::{\n use std::cmp::Ordering;\n use std::iter;\n \n-use super::probe::{IsSuggestion, Mode, ProbeScope};\n+use super::probe::{AutorefOrPtrAdjustment, IsSuggestion, Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -983,7 +984,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_field_method(&mut err, source, span, actual, item_name);\n                 }\n \n-                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1395,7 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_unwrap_self(\n+    fn check_for_inner_self(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -1408,81 +1409,168 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n \n         let ty::Adt(kind, substs) = actual.kind() else { return; };\n-        if !kind.is_enum() {\n-            return;\n-        }\n+        match kind.adt_kind() {\n+            ty::AdtKind::Enum => {\n+                let matching_variants: Vec<_> = kind\n+                    .variants()\n+                    .iter()\n+                    .flat_map(|variant| {\n+                        let [field] = &variant.fields[..] else { return None; };\n+                        let field_ty = field.ty(tcx, substs);\n+\n+                        // Skip `_`, since that'll just lead to ambiguity.\n+                        if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n+                            return None;\n+                        }\n \n-        let matching_variants: Vec<_> = kind\n-            .variants()\n-            .iter()\n-            .flat_map(|variant| {\n-                let [field] = &variant.fields[..] else { return None; };\n-                let field_ty = field.ty(tcx, substs);\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                        )\n+                        .ok()\n+                        .map(|pick| (variant, field, pick))\n+                    })\n+                    .collect();\n+\n+                let ret_ty_matches = |diagnostic_item| {\n+                    if let Some(ret_ty) = self\n+                        .ret_coercion\n+                        .as_ref()\n+                        .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                        && let ty::Adt(kind, _) = ret_ty.kind()\n+                        && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                };\n \n-                // Skip `_`, since that'll just lead to ambiguity.\n-                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n-                    return None;\n+                match &matching_variants[..] {\n+                    [(_, field, pick)] => {\n+                        let self_ty = field.ty(tcx, substs);\n+                        err.span_note(\n+                            tcx.def_span(pick.item.def_id),\n+                            &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                        );\n+                        let (article, kind, variant, question) =\n+                            if tcx.is_diagnostic_item(sym::Result, kind.did()) {\n+                                (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                            } else if tcx.is_diagnostic_item(sym::Option, kind.did()) {\n+                                (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                            } else {\n+                                return;\n+                            };\n+                        if question {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                                    {article} `{kind}::{variant}` value to the caller\"\n+                                ),\n+                                \"?\",\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                                    panicking if the value is {article} `{kind}::{variant}`\"\n+                                ),\n+                                \".expect(\\\"REASON\\\")\",\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                    // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+                    _ => {}\n                 }\n-\n-                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n-                    .ok()\n-                    .map(|pick| (variant, field, pick))\n-            })\n-            .collect();\n-\n-        let ret_ty_matches = |diagnostic_item| {\n-            if let Some(ret_ty) = self\n-                .ret_coercion\n-                .as_ref()\n-                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n-                && let ty::Adt(kind, _) = ret_ty.kind()\n-                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n-            {\n-                true\n-            } else {\n-                false\n             }\n-        };\n+            // Target wrapper types - types that wrap or pretend to wrap another type,\n+            // perhaps this inner type is meant to be called?\n+            ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                let [first] = ***substs else { return; };\n+                let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n+                let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                        )  else { return; };\n \n-        match &matching_variants[..] {\n-            [(_, field, pick)] => {\n-                let self_ty = field.ty(tcx, substs);\n-                err.span_note(\n-                    tcx.def_span(pick.item.def_id),\n-                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n-                );\n-                let (article, kind, variant, question) =\n-                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n-                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n-                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n-                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n-                    } else {\n-                        return;\n+                let name = self.ty_to_value_string(actual);\n+                let inner_id = kind.did();\n+                let mutable = if let Some(AutorefOrPtrAdjustment::Autoref { mutbl, .. }) =\n+                    pick.autoref_or_ptr_adjustment\n+                {\n+                    Some(mutbl)\n+                } else {\n+                    None\n+                };\n+\n+                if tcx.is_diagnostic_item(sym::LocalKey, inner_id) {\n+                    err.help(\"use `with` or `try_with` to access thread local storage\");\n+                } else if Some(kind.did()) == tcx.lang_items().maybe_uninit() {\n+                    err.help(format!(\n+                        \"if this `{name}` has been initialized, \\\n+                        use one of the `assume_init` methods to access the inner value\"\n+                    ));\n+                } else if tcx.is_diagnostic_item(sym::RefCell, inner_id) {\n+                    let (suggestion, borrow_kind, panic_if) = match mutable {\n+                        Some(Mutability::Not) => (\".borrow()\", \"borrow\", \"a mutable borrow exists\"),\n+                        Some(Mutability::Mut) => {\n+                            (\".borrow_mut()\", \"mutably borrow\", \"any borrows exist\")\n+                        }\n+                        None => return,\n                     };\n-                if question {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n-                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n-                            {article} `{kind}::{variant}` value to the caller\"\n+                            \"use `{suggestion}` to {borrow_kind} the `{ty}`, \\\n+                            panicking if {panic_if}\"\n                         ),\n-                        \"?\",\n-                        Applicability::MachineApplicable,\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n                     );\n-                } else {\n+                } else if tcx.is_diagnostic_item(sym::Mutex, inner_id) {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n-                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n-                             panicking if the value is {article} `{kind}::{variant}`\"\n+                            \"use `.lock().unwrap()` to borrow the `{ty}`, \\\n+                            blocking the current thread until it can be acquired\"\n                         ),\n-                        \".expect(\\\"REASON\\\")\",\n-                        Applicability::HasPlaceholders,\n+                        \".lock().unwrap()\",\n+                        Applicability::MaybeIncorrect,\n                     );\n-                }\n+                } else if tcx.is_diagnostic_item(sym::RwLock, inner_id) {\n+                    let (suggestion, borrow_kind) = match mutable {\n+                        Some(Mutability::Not) => (\".read().unwrap()\", \"borrow\"),\n+                        Some(Mutability::Mut) => (\".write().unwrap()\", \"mutably borrow\"),\n+                        None => return,\n+                    };\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"use `{suggestion}` to {borrow_kind} the `{ty}`, \\\n+                            blocking the current thread until it can be acquired\"\n+                        ),\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    return;\n+                };\n+\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{ty}`\"),\n+                );\n             }\n-            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n-            _ => {}\n         }\n     }\n "}, {"sha": "23a4c1f069662262f0306405815c43ed4c44ff0c", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,7 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(allow_internal_unstable)]\n-#![feature(bench_black_box)]\n #![feature(extend_one)]\n #![feature(min_specialization)]\n #![feature(new_uninit)]"}, {"sha": "8f64b5f5158e4222ec74ec5acddc0095cf045b99", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -93,7 +93,7 @@ where\n         // NOTE: Raw strings do not perform any explicit character escaping, here we\n         // only translate CRLF to LF and produce errors on bare CR.\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n         }\n     }\n }\n@@ -105,7 +105,7 @@ pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    assert!(mode.is_bytes());\n+    debug_assert!(mode.is_bytes());\n     unescape_literal(literal_text, mode, &mut |range, result| {\n         callback(range, result.map(byte_from_char));\n     })\n@@ -129,7 +129,7 @@ pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n }\n \n /// What kind of literal do we parse.\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n pub enum Mode {\n     Char,\n     Str,\n@@ -140,17 +140,13 @@ pub enum Mode {\n }\n \n impl Mode {\n-    pub fn in_single_quotes(self) -> bool {\n+    pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => false,\n+            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn in_double_quotes(self) -> bool {\n-        !self.in_single_quotes()\n-    }\n-\n     pub fn is_bytes(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n@@ -184,7 +180,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n             let value = hi * 16 + lo;\n \n-            // For a byte literal verify that it is within ASCII range.\n+            // For a non-byte literal verify that it is within ASCII range.\n             if !mode.is_bytes() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n@@ -263,6 +259,7 @@ fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n }\n \n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match first_char {\n         '\\\\' => scan_escape(chars, mode),\n@@ -282,7 +279,7 @@ fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n     let initial_len = src.len();\n     let mut chars = src.chars();\n     while let Some(first_char) = chars.next() {\n@@ -344,11 +341,11 @@ where\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n /// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n     let initial_len = literal_text.len();\n \n     let mut chars = literal_text.chars();\n@@ -368,7 +365,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n+    debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}, {"sha": "07f3656d086b870d610e8b8be79874e56a9e9848", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -224,6 +224,7 @@ symbols! {\n         Left,\n         LinkedList,\n         LintPass,\n+        LocalKey,\n         Mutex,\n         MutexGuard,\n         N,\n@@ -266,6 +267,7 @@ symbols! {\n         Rc,\n         Ready,\n         Receiver,\n+        RefCell,\n         Relaxed,\n         Release,\n         Result,\n@@ -274,6 +276,7 @@ symbols! {\n         Rust,\n         RustcDecodable,\n         RustcEncodable,\n+        RwLock,\n         RwLockReadGuard,\n         RwLockWriteGuard,\n         Send,"}, {"sha": "f13736a76b21450cca5f93f87fbc7e0a5a911155", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     /// Attempts to select obligations using `selcx`.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+    fn select(&mut self, selcx: SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         let span = debug_span!(\"select\", obligation_forest_size = ?self.predicates.len());\n         let _enter = span.enter();\n \n@@ -197,8 +197,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Vec<FulfillmentError<'tcx>> {\n-        let mut selcx = SelectionContext::new(infcx);\n-        self.select(&mut selcx)\n+        let selcx = SelectionContext::new(infcx);\n+        self.select(selcx)\n     }\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n@@ -210,8 +210,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     }\n }\n \n-struct FulfillProcessor<'a, 'b, 'tcx> {\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+struct FulfillProcessor<'a, 'tcx> {\n+    selcx: SelectionContext<'a, 'tcx>,\n }\n \n fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligation<'_>> {\n@@ -220,7 +220,7 @@ fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligatio\n         .collect()\n }\n \n-impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n     type OUT = Outcome<Self::Obligation, Self::Error>;\n@@ -291,7 +291,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         if obligation.predicate.has_projections() {\n             let mut obligations = Vec::new();\n             let predicate = crate::traits::project::try_normalize_with_depth_to(\n-                self.selcx,\n+                &mut self.selcx,\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n@@ -608,7 +608,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n+impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, obligation, stalled_on))]\n     fn process_trait_obligation(\n         &mut self,\n@@ -643,7 +643,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // information about the types in the trait.\n                 stalled_on.clear();\n                 stalled_on.extend(substs_infer_vars(\n-                    self.selcx,\n+                    &self.selcx,\n                     trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),\n                 ));\n \n@@ -695,12 +695,12 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n             }\n         }\n \n-        match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n+        match project::poly_project_and_unify_type(&mut self.selcx, &project_obligation) {\n             ProjectAndUnifyResult::Holds(os) => ProcessResult::Changed(mk_pending(os)),\n             ProjectAndUnifyResult::FailedNormalization => {\n                 stalled_on.clear();\n                 stalled_on.extend(substs_infer_vars(\n-                    self.selcx,\n+                    &self.selcx,\n                     project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),\n                 ));\n                 ProcessResult::Unchanged\n@@ -718,7 +718,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n /// Returns the set of inference variables contained in `substs`.\n fn substs_infer_vars<'a, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'tcx>,\n+    selcx: &SelectionContext<'a, 'tcx>,\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx"}, {"sha": "dd49dcecf77e395cb9609d334ac6aa91626ea095", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -626,7 +626,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the signature, as evidenced by how we treat it during projection.\n         // The safe thing to do here is to liberate it, though, which should\n         // have no worse effect than skipping the binder here.\n-        let liberated_fn_ty = self.infcx.replace_bound_vars_with_placeholders(obligation.self_ty());\n+        let liberated_fn_ty =\n+            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate.rebind(self_ty));\n         let output_ty = self\n             .infcx\n             .replace_bound_vars_with_placeholders(liberated_fn_ty.fn_sig(self.tcx()).output());"}, {"sha": "f30ebd77e2466c095ff3680e53d28ed73ba48674", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -41,7 +41,6 @@\n #![feature(pointer_is_aligned)]\n #![feature(slice_flatten)]\n #![feature(thin_box)]\n-#![feature(bench_black_box)]\n #![feature(strict_provenance)]\n #![feature(once_cell)]\n #![feature(drain_keep_rest)]"}, {"sha": "288cab1ef399470a93149829a93d369932276e00", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -614,6 +614,7 @@ impl<T, const N: usize> Cell<[T; N]> {\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](self) for more.\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"RefCell\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,"}, {"sha": "f9267371aa74556025ecf53289447d5115651eba", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -217,7 +217,7 @@ pub fn spin_loop() {\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n #[inline]\n-#[unstable(feature = \"bench_black_box\", issue = \"64102\")]\n+#[stable(feature = \"bench_black_box\", since = \"CURRENT_RUSTC_VERSION\")]\n #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n pub const fn black_box<T>(dummy: T) -> T {\n     crate::intrinsics::black_box(dummy)"}, {"sha": "6d58ed9743d6a30690ffc1ee7c629c2d0706bdb6", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -2,7 +2,6 @@\n #![feature(array_chunks)]\n #![feature(array_methods)]\n #![feature(array_windows)]\n-#![feature(bench_black_box)]\n #![feature(bigint_helper_methods)]\n #![feature(cell_update)]\n #![feature(const_assume)]"}, {"sha": "64b62fd3bba4fe77dc136bfbdd6766aac1151b37", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -348,7 +348,6 @@\n #![feature(trace_macros)]\n //\n // Only used in tests/benchmarks:\n-#![feature(bench_black_box)]\n //\n // Only for const-ness:\n #![feature(const_io_structs)]"}, {"sha": "ee2c79b6669b8d94b8dc8f1acb26b3d10aa36c33", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -76,6 +76,7 @@ use crate::sys_common::rwlock as sys;\n ///\n /// [`Mutex`]: super::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"RwLock\")]\n pub struct RwLock<T: ?Sized> {\n     inner: sys::MovableRwLock,\n     poison: poison::Flag,"}, {"sha": "ffd17dc99093aeb036898c96abe21b3f4bd03d9d", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -95,6 +95,7 @@ use crate::fmt;\n /// [loader lock]: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n /// [`JoinHandle::join`]: crate::thread::JoinHandle::join\n /// [`with`]: LocalKey::with\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"LocalKey\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LocalKey<T: 'static> {\n     // This outer `LocalKey<T>` type is what's going to be stored in statics,"}, {"sha": "33c6ea58532278f6473009a8e2920505e77cd935", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -15,7 +15,6 @@\n \n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n-#![feature(bench_black_box)]\n #![feature(internal_output_capture)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]"}, {"sha": "0ea6d9c38b69fbf78e7734dc0efdb26199b0bb1f", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1776,9 +1776,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t}\n \n \t.rustdoc.source > .sidebar {\n-\t\tposition: fixed;\n-\t\tmargin: 0;\n-\t\tz-index: 11;\n \t\twidth: 0;\n \t}\n "}, {"sha": "6f51c9729e3706e15e09cd655258c317d6fae109", "filename": "src/test/incremental/spans_significant_w_panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -8,7 +8,6 @@\n // compile-flags: -C overflow-checks=on -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n-#![feature(bench_black_box)]\n #![rustc_partition_codegened(module = \"spans_significant_w_panic\", cfg = \"rpass2\")]\n #![rustc_partition_codegened(module = \"spans_significant_w_panic\", cfg = \"rpass4\")]\n "}, {"sha": "f60cb92da7f6b8eb1c9e001eedab7e62fee02170", "filename": "src/test/ui/associated-consts/issue-102335-const.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,12 @@\n+#![feature(associated_const_equality)]\n+\n+trait T {\n+    type A: S<C<X = 0i32> = 34>;\n+    //~^ ERROR associated type bindings are not allowed here\n+}\n+\n+trait S {\n+    const C: i32;\n+}\n+\n+fn main() {}"}, {"sha": "531d15c5900c58d81024597c2b7aa4e6ba61b88a", "filename": "src/test/ui/associated-consts/issue-102335-const.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-102335-const.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,9 @@\n+error[E0229]: associated type bindings are not allowed here\n+  --> $DIR/issue-102335-const.rs:4:17\n+   |\n+LL |     type A: S<C<X = 0i32> = 34>;\n+   |                 ^^^^^^^^ associated type not allowed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0229`."}, {"sha": "363df73c1ffd7d84b4376b83465e622f324a2370", "filename": "src/test/ui/associated-type-bounds/issue-102335-ty.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,12 @@\n+trait T {\n+    type A: S<C<i32 = u32> = ()>;\n+    //~^ ERROR associated type bindings are not allowed here\n+}\n+\n+trait Q {}\n+\n+trait S {\n+    type C: Q;\n+}\n+\n+fn main() {}"}, {"sha": "8777b2965153a8b23f8ebcd5bb7ce3a407d16a68", "filename": "src/test/ui/associated-type-bounds/issue-102335-ty.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-102335-ty.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,9 @@\n+error[E0229]: associated type bindings are not allowed here\n+  --> $DIR/issue-102335-ty.rs:2:17\n+   |\n+LL |     type A: S<C<i32 = u32> = ()>;\n+   |                 ^^^^^^^^^ associated type not allowed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0229`."}, {"sha": "0611fabc15c0880acca6ee5b3d7c194044943663", "filename": "src/test/ui/box/issue-95036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fbox%2Fissue-95036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fbox%2Fissue-95036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fissue-95036.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -O\n // build-pass\n \n-#![feature(allocator_api, bench_black_box)]\n+#![feature(allocator_api)]\n \n #[inline(never)]\n pub fn by_ref(node: &mut Box<[u8; 1], &std::alloc::Global>) {"}, {"sha": "2767f178fb6644519147b9b5a75e19090c435695", "filename": "src/test/ui/consts/cast-discriminant-zst-enum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n // Test a ZST enum whose dicriminant is ~0i128. This caused an ICE when casting to an i32.\n-#![feature(bench_black_box)]\n use std::hint::black_box;\n \n #[derive(Copy, Clone)]"}, {"sha": "79e68590e85d4ff0dcb25f0d02d9ae7b1056c2a6", "filename": "src/test/ui/consts/const_discriminant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![feature(const_discriminant)]\n-#![feature(bench_black_box)]\n #![allow(dead_code)]\n \n use std::mem::{discriminant, Discriminant};"}, {"sha": "566b518b4331dec8dec96379f1a10649698193eb", "filename": "src/test/ui/error-codes/E0311.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ferror-codes%2FE0311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ferror-codes%2FE0311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0311.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,9 @@\n+fn no_restriction<T>(x: &()) -> &() {\n+    with_restriction::<T>(x) //~ ERROR E0311\n+}\n+\n+fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "9873b5ae6ff1330a100c37313270ec46b0b41b12", "filename": "src/test/ui/error-codes/E0311.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ferror-codes%2FE0311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ferror-codes%2FE0311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0311.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,24 @@\n+error[E0311]: the parameter type `T` may not live long enough\n+  --> $DIR/E0311.rs:2:5\n+   |\n+LL |     with_restriction::<T>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `T` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/E0311.rs:1:25\n+   |\n+LL | fn no_restriction<T>(x: &()) -> &() {\n+   |                         ^^^\n+note: ...so that the type `T` will meet its required lifetime bounds\n+  --> $DIR/E0311.rs:2:5\n+   |\n+LL |     with_restriction::<T>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn no_restriction<'a, T: 'a>(x: &()) -> &() {\n+   |                   +++  ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0311`."}, {"sha": "de394ca9ad6d41c06f8e940175bec6425e9fd587", "filename": "src/test/ui/function-pointer/issue-102289.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ffunction-pointer%2Fissue-102289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Ffunction-pointer%2Fissue-102289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunction-pointer%2Fissue-102289.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,54 @@\n+// check-pass\n+\n+pub(crate) trait Parser: Sized {\n+    type Output;\n+    fn parse(&mut self, _input: &str) -> Result<(), ()> {\n+        loop {}\n+    }\n+    fn map<F, B>(self, _f: F) -> Map<Self, F>\n+    where\n+        F: FnMut(Self::Output) -> B,\n+    {\n+        todo!()\n+    }\n+}\n+\n+pub(crate) struct Chainl1<P, Op>(P, Op);\n+impl<P, Op> Parser for Chainl1<P, Op>\n+where\n+    P: Parser,\n+    Op: Parser,\n+    Op::Output: FnOnce(P::Output, P::Output) -> P::Output,\n+{\n+    type Output = P::Output;\n+}\n+pub(crate) fn chainl1<P, Op>(_parser: P, _op: Op) -> Chainl1<P, Op>\n+where\n+    P: Parser,\n+    Op: Parser,\n+    Op::Output: FnOnce(P::Output, P::Output) -> P::Output,\n+{\n+    loop {}\n+}\n+\n+pub(crate) struct Map<P, F>(P, F);\n+impl<A, B, P, F> Parser for Map<P, F>\n+where\n+    P: Parser<Output = A>,\n+    F: FnMut(A) -> B,\n+{\n+    type Output = B;\n+}\n+\n+impl Parser for u32 {\n+    type Output = ();\n+}\n+\n+pub fn chainl1_error_consume() {\n+    fn first<T, U>(t: T, _: U) -> T {\n+        t\n+    }\n+    let _ = chainl1(1, 1.map(|_| first)).parse(\"\");\n+}\n+\n+fn main() {}"}, {"sha": "a7255fdcbf5e10c569e6a78c451599ec063cb91b", "filename": "src/test/ui/generic-associated-types/issue-102335-gat.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,12 @@\n+trait T {\n+    type A: S<C<(), i32 = ()> = ()>;\n+    //~^ ERROR associated type bindings are not allowed here\n+}\n+\n+trait Q {}\n+\n+trait S {\n+    type C<T>: Q;\n+}\n+\n+fn main() {}"}, {"sha": "7a7900a1e656ab6912c828aa9dc3f77b76e77eef", "filename": "src/test/ui/generic-associated-types/issue-102335-gat.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102335-gat.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,9 @@\n+error[E0229]: associated type bindings are not allowed here\n+  --> $DIR/issue-102335-gat.rs:2:21\n+   |\n+LL |     type A: S<C<(), i32 = ()> = ()>;\n+   |                     ^^^^^^^^ associated type not allowed here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0229`."}, {"sha": "2e81d5e8221c490d40cc14eb5681ab0937af7693", "filename": "src/test/ui/issues/issue-99838.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-99838.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![feature(bench_black_box)]\n+\n use std::hint;\n \n struct U16(u16);"}, {"sha": "31fd8a4d633e9135d8d6c2cce59bc49ff755593c", "filename": "src/test/ui/lifetimes/suggest-introducing-and-adding-missing-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -21,3 +21,4 @@ LL | fn no_restriction<'a, T: 'a>(x: &()) -> &() {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0311`."}, {"sha": "21a8fb2b22bee306e833a193493f66efcb2a2756", "filename": "src/test/ui/oom_unwind.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Foom_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Foom_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foom_unwind.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -4,8 +4,6 @@\n // needs-unwind\n // only-linux\n \n-#![feature(bench_black_box)]\n-\n use std::hint::black_box;\n use std::mem::forget;\n use std::panic::catch_unwind;"}, {"sha": "08b30b600e7370f8deb1e4715fd057da637a8873", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -7,7 +7,6 @@\n // ignore-sgx no processes\n // ignore-android: FIXME(#85261)\n \n-#![feature(bench_black_box)]\n #![feature(rustc_private)]\n #![feature(never_type)]\n #![feature(panic_always_abort)]"}, {"sha": "5b2cea87560fde49c5c268c1fda039d81dc32ee0", "filename": "src/test/ui/sanitize/address.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -5,9 +5,7 @@\n //\n // run-fail\n // error-pattern: AddressSanitizer: stack-buffer-overflow\n-// error-pattern: 'xs' (line 15) <== Memory access at offset\n-\n-#![feature(bench_black_box)]\n+// error-pattern: 'xs' (line 13) <== Memory access at offset\n \n use std::hint::black_box;\n "}, {"sha": "f9b37a155aad7a0fab899304e4daf7fcd73e47ad", "filename": "src/test/ui/sanitize/hwaddress.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fhwaddress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fhwaddress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fhwaddress.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -10,8 +10,6 @@\n // run-fail\n // error-pattern: HWAddressSanitizer: tag-mismatch\n \n-#![feature(bench_black_box)]\n-\n use std::hint::black_box;\n \n fn main() {"}, {"sha": "cbb44ae8acd60a8a0922b9f0facf9e5abbc6656c", "filename": "src/test/ui/sanitize/leak.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -6,8 +6,6 @@\n // run-fail\n // error-pattern: LeakSanitizer: detected memory leaks\n \n-#![feature(bench_black_box)]\n-\n use std::hint::black_box;\n use std::mem;\n "}, {"sha": "0018c2f7581822f6a3f265bfbec6d1df42283243", "filename": "src/test/ui/sanitize/memory-eager.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fmemory-eager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fmemory-eager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fmemory-eager.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -17,7 +17,6 @@\n \n #![feature(core_intrinsics)]\n #![feature(start)]\n-#![feature(bench_black_box)]\n \n use std::hint::black_box;\n use std::mem::MaybeUninit;"}, {"sha": "1a9ac3a4f3c327cdd7102a2f92c06b3cbdb0d2c3", "filename": "src/test/ui/sanitize/memory.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -16,7 +16,6 @@\n \n #![feature(core_intrinsics)]\n #![feature(start)]\n-#![feature(bench_black_box)]\n #![allow(invalid_value)]\n \n use std::hint::black_box;"}, {"sha": "7af7391ca851d5148c2584869aa58e05979881fe", "filename": "src/test/ui/suggestions/inner_type.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.borrow().method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+\n+    other_item.borrow_mut().some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP .borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.lock().unwrap().method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    let another_item = std::sync::RwLock::new(Struct { p: 42_u32 });\n+\n+    another_item.read().unwrap().method();\n+    //~^ ERROR no method named `method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP  use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    another_item.write().unwrap().some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+}"}, {"sha": "4aca50716258aa746a4b50ce87a7a4ba451bc983", "filename": "src/test/ui/suggestions/inner_type.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+\n+    other_item.some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP .borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    let another_item = std::sync::RwLock::new(Struct { p: 42_u32 });\n+\n+    another_item.method();\n+    //~^ ERROR no method named `method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP  use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    another_item.some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+}"}, {"sha": "5ac3d04f104142d803267d33be1ef9ec72112c08", "filename": "src/test/ui/suggestions/inner_type.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,83 @@\n+error[E0599]: no method named `method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:17:16\n+   |\n+LL |     other_item.method();\n+   |                ^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+   |\n+LL |     other_item.borrow().method();\n+   |               +++++++++\n+\n+error[E0599]: no method named `some_mutable_method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:21:16\n+   |\n+LL |     other_item.some_mutable_method();\n+   |                ^^^^^^^^^^^^^^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `some_mutable_method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:11:5\n+   |\n+LL |     pub fn some_mutable_method(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+   |\n+LL |     other_item.borrow_mut().some_mutable_method();\n+   |               +++++++++++++\n+\n+error[E0599]: no method named `method` found for struct `Mutex` in the current scope\n+  --> $DIR/inner_type.rs:27:18\n+   |\n+LL |     another_item.method();\n+   |                  ^^^^^^ method not found in `Mutex<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.lock().unwrap().method();\n+   |                 ++++++++++++++++\n+\n+error[E0599]: no method named `method` found for struct `RwLock` in the current scope\n+  --> $DIR/inner_type.rs:33:18\n+   |\n+LL |     another_item.method();\n+   |                  ^^^^^^ method not found in `RwLock<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.read().unwrap().method();\n+   |                 ++++++++++++++++\n+\n+error[E0599]: no method named `some_mutable_method` found for struct `RwLock` in the current scope\n+  --> $DIR/inner_type.rs:37:18\n+   |\n+LL |     another_item.some_mutable_method();\n+   |                  ^^^^^^^^^^^^^^^^^^^ method not found in `RwLock<Struct<u32>>`\n+   |\n+note: the method `some_mutable_method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:11:5\n+   |\n+LL |     pub fn some_mutable_method(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.write().unwrap().some_mutable_method();\n+   |                 +++++++++++++++++\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "c56ea7c030d8e1b685dd34df73e7ddf95e9569cc", "filename": "src/test/ui/suggestions/inner_type2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,26 @@\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+thread_local! {\n+    static STRUCT: Struct<u32> = Struct {\n+        p: 42_u32\n+    };\n+}\n+\n+fn main() {\n+    STRUCT.method();\n+    //~^ ERROR no method named `method` found for struct `LocalKey` in the current scope [E0599]\n+    //~| HELP use `with` or `try_with` to access thread local storage\n+\n+    let item = std::mem::MaybeUninit::new(Struct { p: 42_u32 });\n+    item.method();\n+    //~^ ERROR no method named `method` found for union `MaybeUninit` in the current scope [E0599]\n+    //~| HELP if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+}"}, {"sha": "eddfd9d63409d3d6eca49c29c3317ce2e4562e58", "filename": "src/test/ui/suggestions/inner_type2.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -0,0 +1,29 @@\n+error[E0599]: no method named `method` found for struct `LocalKey` in the current scope\n+  --> $DIR/inner_type2.rs:18:12\n+   |\n+LL |     STRUCT.method();\n+   |            ^^^^^^ method not found in `LocalKey<Struct<u32>>`\n+   |\n+   = help: use `with` or `try_with` to access thread local storage\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `method` found for union `MaybeUninit` in the current scope\n+  --> $DIR/inner_type2.rs:23:10\n+   |\n+LL |     item.method();\n+   |          ^^^^^^ method not found in `MaybeUninit<Struct<u32>>`\n+   |\n+   = help: if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "02b5fb61894e9fc60a7615532e8fcb272b2b0795", "filename": "src/test/ui/suggestions/issue-85347.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -2,6 +2,7 @@ use std::ops::Deref;\n trait Foo {\n     type Bar<'a>: Deref<Target = <Self>::Bar<Target = Self>>;\n     //~^ ERROR this associated type takes 1 lifetime argument but 0 lifetime arguments were supplied\n+    //~| ERROR associated type bindings are not allowed here\n     //~| HELP add missing\n }\n "}, {"sha": "17c1b7dc4cce992a111da46f6cd0478896146722", "filename": "src/test/ui/suggestions/issue-85347.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-85347.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -14,6 +14,13 @@ help: add missing lifetime argument\n LL |     type Bar<'a>: Deref<Target = <Self>::Bar<'a, Target = Self>>;\n    |                                              +++\n \n-error: aborting due to previous error\n+error[E0229]: associated type bindings are not allowed here\n+  --> $DIR/issue-85347.rs:3:46\n+   |\n+LL |     type Bar<'a>: Deref<Target = <Self>::Bar<Target = Self>>;\n+   |                                              ^^^^^^^^^^^^^ associated type not allowed here\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0107, E0229.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "872263fd7311b5ce87cc693f01b7d684cafc4018", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -27,3 +27,4 @@ LL | fn func<'a, T: Test + 'a>(foo: &Foo, t: T) {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0311`."}, {"sha": "171f4b333db4e231452fcf7054d297a37ceb92e7", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -164,5 +164,5 @@ LL |     G: Get<T> + 'a,\n \n error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0261, E0309, E0621, E0700.\n+Some errors have detailed explanations: E0261, E0309, E0311, E0621, E0700.\n For more information about an error, try `rustc --explain E0261`."}, {"sha": "dde414f417740c9d244563469caff44a7c36f8cf", "filename": "src/tools/miri/tests/fail/invalid_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Finvalid_bool.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,7 +1,7 @@\n // Validation makes this fail in the wrong place\n // Make sure we find these even with many checks disabled.\n //@compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation\n-#![feature(bench_black_box)]\n+\n \n fn main() {\n     let b = unsafe { std::mem::transmute::<u8, bool>(2) };"}, {"sha": "ce62fb0de04f80cf107a21a22688d03cbc1ead00", "filename": "src/tools/miri/tests/pass/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffloat.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,4 +1,4 @@\n-#![feature(stmt_expr_attributes, bench_black_box)]\n+#![feature(stmt_expr_attributes)]\n #![allow(arithmetic_overflow)]\n use std::fmt::Debug;\n use std::hint::black_box;"}, {"sha": "6def529dbe7c3e030627775fd748791e67f43931", "filename": "src/tools/miri/tests/pass/u128.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837bf370de144a682041e68bb67469b9f68a55ce/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fu128.rs?ref=837bf370de144a682041e68bb67469b9f68a55ce", "patch": "@@ -1,4 +1,3 @@\n-#![feature(bench_black_box)]\n use std::hint::black_box as b;\n \n fn main() {"}]}