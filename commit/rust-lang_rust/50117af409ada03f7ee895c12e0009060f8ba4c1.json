{"sha": "50117af409ada03f7ee895c12e0009060f8ba4c1", "node_id": "C_kwDOAAsO6NoAKDUwMTE3YWY0MDlhZGEwM2Y3ZWU4OTVjMTJlMDAwOTA2MGY4YmE0YzE", "commit": {"author": {"name": "Nikolay Arhipov", "email": "n@arhipov.net", "date": "2023-06-04T14:44:43Z"}, "committer": {"name": "Nikolay Arhipov", "email": "n@arhipov.net", "date": "2023-06-05T16:14:09Z"}, "message": "Std support improvement for ps vita target", "tree": {"sha": "83a8eaa50c78ef150caa34043a58788918722b94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83a8eaa50c78ef150caa34043a58788918722b94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50117af409ada03f7ee895c12e0009060f8ba4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50117af409ada03f7ee895c12e0009060f8ba4c1", "html_url": "https://github.com/rust-lang/rust/commit/50117af409ada03f7ee895c12e0009060f8ba4c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50117af409ada03f7ee895c12e0009060f8ba4c1/comments", "author": {"login": "nikarh", "id": 5517011, "node_id": "MDQ6VXNlcjU1MTcwMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/5517011?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikarh", "html_url": "https://github.com/nikarh", "followers_url": "https://api.github.com/users/nikarh/followers", "following_url": "https://api.github.com/users/nikarh/following{/other_user}", "gists_url": "https://api.github.com/users/nikarh/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikarh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikarh/subscriptions", "organizations_url": "https://api.github.com/users/nikarh/orgs", "repos_url": "https://api.github.com/users/nikarh/repos", "events_url": "https://api.github.com/users/nikarh/events{/privacy}", "received_events_url": "https://api.github.com/users/nikarh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikarh", "id": 5517011, "node_id": "MDQ6VXNlcjU1MTcwMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/5517011?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikarh", "html_url": "https://github.com/nikarh", "followers_url": "https://api.github.com/users/nikarh/followers", "following_url": "https://api.github.com/users/nikarh/following{/other_user}", "gists_url": "https://api.github.com/users/nikarh/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikarh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikarh/subscriptions", "organizations_url": "https://api.github.com/users/nikarh/orgs", "repos_url": "https://api.github.com/users/nikarh/repos", "events_url": "https://api.github.com/users/nikarh/events{/privacy}", "received_events_url": "https://api.github.com/users/nikarh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7452822843cf461b56742f0fc648af35889a3070", "url": "https://api.github.com/repos/rust-lang/rust/commits/7452822843cf461b56742f0fc648af35889a3070", "html_url": "https://github.com/rust-lang/rust/commit/7452822843cf461b56742f0fc648af35889a3070"}], "stats": {"total": 172, "additions": 84, "deletions": 88}, "files": [{"sha": "828480431903369bb7e56063bfc73515d40f2667", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -1902,9 +1902,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.143\"\n+version = \"0.2.145\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"edc207893e85c5d6be840e969b496b53d94cec8be2d501b214f50daa97fa8024\"\n+checksum = \"fc86cde3ff845662b8f4ef6cb50ea0e20c524eb3d29ae048287e06a1b3fa6a81\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "62c93603621abdbb156c4d910a630310f6a2ef6c", "filename": "compiler/rustc_target/src/spec/armv7_sony_vita_newlibeabihf.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -1,15 +1,18 @@\n use crate::abi::Endian;\n-use crate::spec::{cvs, Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, Target, TargetOptions};\n+use crate::spec::{cvs, Cc, LinkerFlavor, Lld, RelocModel, Target, TargetOptions};\n \n /// A base target for PlayStation Vita devices using the VITASDK toolchain (using newlib).\n ///\n /// Requires the VITASDK toolchain on the host system.\n \n pub fn target() -> Target {\n-    let pre_link_args = TargetOptions::link_args(LinkerFlavor::Gnu(Cc::Yes, Lld::No), &[\"-Wl,-q\"]);\n+    let pre_link_args = TargetOptions::link_args(\n+        LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n+        &[\"-Wl,-q\", \"-Wl,--pic-veneer\"],\n+    );\n \n     Target {\n-        llvm_target: \"armv7a-vita-eabihf\".into(),\n+        llvm_target: \"thumbv7a-vita-eabihf\".into(),\n         pointer_width: 32,\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n         arch: \"arm\".into(),\n@@ -18,21 +21,19 @@ pub fn target() -> Target {\n             os: \"vita\".into(),\n             endian: Endian::Little,\n             c_int_width: \"32\".into(),\n-            dynamic_linking: false,\n             env: \"newlib\".into(),\n             vendor: \"sony\".into(),\n             abi: \"eabihf\".into(),\n             linker_flavor: LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n             no_default_libraries: false,\n             cpu: \"cortex-a9\".into(),\n-            executables: true,\n             families: cvs![\"unix\"],\n             linker: Some(\"arm-vita-eabi-gcc\".into()),\n             relocation_model: RelocModel::Static,\n-            features: \"+v7,+neon\".into(),\n+            features: \"+v7,+neon,+vfp3,+thumb2,+thumb-mode\".into(),\n             pre_link_args,\n             exe_suffix: \".elf\".into(),\n-            panic_strategy: PanicStrategy::Abort,\n+            has_thumb_interworking: true,\n             max_atomic_width: Some(64),\n             ..Default::default()\n         },"}, {"sha": "74b61db0c1c59189088f97363ee5a0692238b476", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -17,7 +17,7 @@ cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\", public = true }\n-libc = { version = \"0.2.143\", default-features = false, features = ['rustc-dep-of-std'], public = true }\n+libc = { version = \"0.2.145\", default-features = false, features = ['rustc-dep-of-std'], public = true }\n compiler_builtins = { version = \"0.1.92\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "2b40b672d9f0aa629b9099ed276fa9f0bfa7241c", "filename": "library/std/src/os/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -15,7 +15,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use cfg_if::cfg_if;\n \n cfg_if! {\n-    if #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\"))] {\n+    if #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))] {\n         type UserId = u16;\n         type GroupId = u16;\n     } else if #[cfg(target_os = \"nto\")] {"}, {"sha": "69c93c920036738e6e33704289b4e4730c0aa690", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -402,7 +402,10 @@ impl FileDesc {\n         }\n     }\n     #[cfg(any(\n-        all(target_env = \"newlib\", not(any(target_os = \"espidf\", target_os = \"horizon\"))),\n+        all(\n+            target_env = \"newlib\",\n+            not(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))\n+        ),\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"emscripten\",\n@@ -424,10 +427,10 @@ impl FileDesc {\n             Ok(())\n         }\n     }\n-    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n+    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n-        // FD_CLOEXEC is not supported in ESP-IDF and Horizon OS but there's no need to,\n-        // because neither supports spawning processes.\n+        // FD_CLOEXEC is not supported in ESP-IDF, Horizon OS and Vita but there's no need to,\n+        // because none of them supports spawning processes.\n         Ok(())\n     }\n "}, {"sha": "d2fb6238387a12455e4281207cefbbd45f8a1c05", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -15,6 +15,7 @@ use crate::mem;\n     target_os = \"redox\",\n     target_os = \"illumos\",\n     target_os = \"nto\",\n+    target_os = \"vita\",\n ))]\n use crate::mem::MaybeUninit;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n@@ -58,6 +59,7 @@ use libc::fstatat64;\n     target_os = \"redox\",\n     target_os = \"illumos\",\n     target_os = \"nto\",\n+    target_os = \"vita\",\n ))]\n use libc::readdir as readdir64;\n #[cfg(target_os = \"linux\")]\n@@ -74,6 +76,7 @@ use libc::readdir64_r;\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n     target_os = \"nto\",\n+    target_os = \"vita\",\n )))]\n use libc::readdir_r as readdir64_r;\n #[cfg(target_os = \"android\")]\n@@ -283,6 +286,7 @@ unsafe impl Sync for Dir {}\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n     target_os = \"nto\",\n+    target_os = \"vita\"\n ))]\n pub struct DirEntry {\n     dir: Arc<InnerReadDir>,\n@@ -304,10 +308,16 @@ pub struct DirEntry {\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n     target_os = \"nto\",\n+    target_os = \"vita\",\n ))]\n struct dirent64_min {\n     d_ino: u64,\n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"nto\")))]\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"nto\",\n+        target_os = \"vita\"\n+    )))]\n     d_type: u8,\n }\n \n@@ -319,6 +329,7 @@ struct dirent64_min {\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n     target_os = \"nto\",\n+    target_os = \"vita\",\n )))]\n pub struct DirEntry {\n     dir: Arc<InnerReadDir>,\n@@ -520,6 +531,7 @@ impl FileAttr {\n         target_os = \"macos\",\n         target_os = \"ios\",\n         target_os = \"watchos\",\n+        target_os = \"vita\",\n     )))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         cfg_has_statx! {\n@@ -541,6 +553,11 @@ impl FileAttr {\n                             currently\",\n         ))\n     }\n+\n+    #[cfg(target_os = \"vita\")]\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::new(self.stat.st_ctime as i64, 0))\n+    }\n }\n \n #[cfg(target_os = \"nto\")]\n@@ -645,6 +662,7 @@ impl Iterator for ReadDir {\n         target_os = \"redox\",\n         target_os = \"illumos\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         if self.end_of_stream {\n@@ -725,6 +743,7 @@ impl Iterator for ReadDir {\n                     continue;\n                 }\n \n+                #[cfg(not(target_os = \"vita\"))]\n                 let entry = dirent64_min {\n                     d_ino: *offset_ptr!(entry_ptr, d_ino) as u64,\n                     #[cfg(not(any(\n@@ -735,6 +754,9 @@ impl Iterator for ReadDir {\n                     d_type: *offset_ptr!(entry_ptr, d_type) as u8,\n                 };\n \n+                #[cfg(target_os = \"vita\")]\n+                let entry = dirent64_min { d_ino: 0u64 };\n+\n                 return Some(Ok(DirEntry {\n                     entry,\n                     name: name.to_owned(),\n@@ -752,6 +774,7 @@ impl Iterator for ReadDir {\n         target_os = \"redox\",\n         target_os = \"illumos\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     )))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         if self.end_of_stream {\n@@ -842,6 +865,7 @@ impl DirEntry {\n         target_os = \"haiku\",\n         target_os = \"vxworks\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     ))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         self.metadata().map(|m| m.file_type())\n@@ -853,6 +877,7 @@ impl DirEntry {\n         target_os = \"haiku\",\n         target_os = \"vxworks\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     )))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n@@ -939,6 +964,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     )))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n@@ -951,6 +977,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n         target_os = \"nto\",\n+        target_os = \"vita\",\n     ))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n@@ -1543,7 +1570,7 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n     run_path_with_cstr(original, |original| {\n         run_path_with_cstr(link, |link| {\n             cfg_if::cfg_if! {\n-                if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\", target_os = \"horizon\"))] {\n+                if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))] {\n                     // VxWorks, Redox and ESP-IDF lack `linkat`, so use `link` instead. POSIX leaves\n                     // it implementation-defined whether `link` follows symlinks, so rely on the\n                     // `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.\n@@ -1666,6 +1693,8 @@ fn open_to_and_set_permissions(\n         .truncate(true)\n         .open(to)?;\n     let writer_metadata = writer.metadata()?;\n+    // fchmod is broken on vita\n+    #[cfg(not(target_os = \"vita\"))]\n     if writer_metadata.is_file() {\n         // Set the correct file permissions, in case the file already existed.\n         // Don't set the permissions on already existing non-files like\n@@ -1844,11 +1873,12 @@ pub fn chroot(dir: &Path) -> io::Result<()> {\n \n pub use remove_dir_impl::remove_dir_all;\n \n-// Fallback for REDOX, ESP-ID, Horizon, and Miri\n+// Fallback for REDOX, ESP-ID, Horizon, Vita and Miri\n #[cfg(any(\n     target_os = \"redox\",\n     target_os = \"espidf\",\n     target_os = \"horizon\",\n+    target_os = \"vita\",\n     target_os = \"nto\",\n     miri\n ))]\n@@ -1861,6 +1891,7 @@ mod remove_dir_impl {\n     target_os = \"redox\",\n     target_os = \"espidf\",\n     target_os = \"horizon\",\n+    target_os = \"vita\",\n     target_os = \"nto\",\n     miri\n )))]"}, {"sha": "24566d96bcd61035ce19502ad0b58dabbc8863ab", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -163,12 +163,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n     }\n \n     unsafe fn reset_sigpipe(#[allow(unused_variables)] sigpipe: u8) {\n-        #[cfg(not(any(\n-            target_os = \"emscripten\",\n-            target_os = \"fuchsia\",\n-            target_os = \"horizon\",\n-            target_os = \"vita\"\n-        )))]\n+        #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\", target_os = \"horizon\")))]\n         {\n             // We don't want to add this as a public type to std, nor do we\n             // want to `include!` a file from the compiler (which would break\n@@ -206,7 +201,6 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n     target_os = \"emscripten\",\n     target_os = \"fuchsia\",\n     target_os = \"horizon\",\n-    target_os = \"vita\"\n )))]\n static UNIX_SIGPIPE_ATTR_SPECIFIED: crate::sync::atomic::AtomicBool =\n     crate::sync::atomic::AtomicBool::new(false);\n@@ -216,7 +210,6 @@ static UNIX_SIGPIPE_ATTR_SPECIFIED: crate::sync::atomic::AtomicBool =\n     target_os = \"emscripten\",\n     target_os = \"fuchsia\",\n     target_os = \"horizon\",\n-    target_os = \"vita\",\n )))]\n pub(crate) fn unix_sigpipe_attr_specified() -> bool {\n     UNIX_SIGPIPE_ATTR_SPECIFIED.load(crate::sync::atomic::Ordering::Relaxed)\n@@ -407,6 +400,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(all(target_os = \"linux\", target_env = \"uclibc\"))] {\n         #[link(name = \"dl\")]\n         extern \"C\" {}\n+    } else if #[cfg(target_os = \"vita\")] {\n+        #[link(name = \"pthread\", kind = \"static\", modifiers = \"-bundle\")]\n+        extern \"C\" {}\n     }\n }\n "}, {"sha": "ca80cabc3b07788e0c0f03ca23bec91acf8f5d55", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -454,12 +454,21 @@ impl Socket {\n         Ok(passcred != 0)\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"vita\")))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as libc::c_int;\n         cvt(unsafe { libc::ioctl(self.as_raw_fd(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n     }\n \n+    #[cfg(target_os = \"vita\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let option = match nonblocking {\n+            true => 1,\n+            false => 0,\n+        };\n+        setsockopt(self, libc::SOL_SOCKET, libc::SO_NONBLOCK, option)\n+    }\n+\n     #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         // FIONBIO is inadequate for sockets on illumos/Solaris, so use the"}, {"sha": "8bf4bae7a3f77d488ce34c1c4a59ee1e84a0608b", "filename": "library/std/src/sys/unix/thread_parking/pthread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -123,7 +123,8 @@ impl Parker {\n                 target_os = \"watchos\",\n                 target_os = \"l4re\",\n                 target_os = \"android\",\n-                target_os = \"redox\"\n+                target_os = \"redox\",\n+                target_os = \"vita\",\n             ))] {\n                 addr_of_mut!((*parker).cvar).write(UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER));\n             } else if #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))] {"}, {"sha": "49eed366dacf09791e8fdc6ae25f6f85de4c9e25", "filename": "src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md", "status": "modified", "additions": 15, "deletions": 60, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/50117af409ada03f7ee895c12e0009060f8ba4c1/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md", "raw_url": "https://github.com/rust-lang/rust/raw/50117af409ada03f7ee895c12e0009060f8ba4c1/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md?ref=50117af409ada03f7ee895c12e0009060f8ba4c1", "patch": "@@ -7,7 +7,7 @@ This tier supports the ARM Cortex A9 processor running on a PlayStation Vita con\n Rust support for this target is not affiliated with Sony, and is not derived\n from nor used with any official Sony SDK.\n \n-## Designated Developers\n+## Target maintainers\n \n * [@amg98](https://github.com/amg98)\n * [@nikarh](https://github.com/nikarh)\n@@ -27,53 +27,19 @@ In order to support some APIs, binaries must be linked against `libc` written\n for the target, using a linker for the target. These are provided by the\n VITASDK toolchain.\n \n-This target generates binaries in the ELF format.\n+This target generates binaries in the ELF format with thumb ISA.\n \n-## Building\n+## Building the target\n \n Rust does not ship pre-compiled artifacts for this target. You can use `build-std` flag to build binaries with `std`:\n \n ```sh\n cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release\n ```\n \n-## Cross-compilation\n-\n-This target can be cross-compiled from `x86_64` on either Windows, MacOS or Linux systems. Other hosts are not supported for cross-compilation.\n-\n-## Testing\n-\n-Currently there is no support to run the rustc test suite for this target.\n-\n-## Building and Running Rust Programs\n+## Building Rust programs\n \n-`std` support for this target relies on newlib. In order to work, newlib must be initialized correctly. The easiest way to achieve this with VITASDK newlib implementation is by compiling your program as a staticlib with and exposing your main function from rust to `_init` function in `crt0`.\n-\n-Add this to your `Cargo.toml`:\n-\n-```toml\n-[lib]\n-crate-type = [\"staticlib\"]\n-\n-[profile.release]\n-panic = 'abort'\n-lto = true\n-opt-level = 3\n-```\n-\n-Your entrypoint should look roughly like this, `src/lib.rs`:\n-```rust,ignore,no_run\n-#[used]\n-#[export_name = \"_newlib_heap_size_user\"]\n-pub static _NEWLIB_HEAP_SIZE_USER: u32 = 100 * 1024 * 1024; // Default heap size is only 32mb, increase it to something suitable for your application\n-\n-#[no_mangle]\n-pub extern \"C\" fn main() {\n-    println!(\"Hello, world!\");\n-}\n-```\n-\n-To test your developed rust programs on PlayStation Vita, first you must correctly link and package your rust staticlib. These steps can be preformed using tools available in VITASDK, and can be automated using tools like `cargo-make`.\n+To test your developed rust programs on PlayStation Vita, first you must correctly package your elf. These steps can be preformed using tools available in VITASDK, and can be automated using a tool like `cargo-make`.\n \n First, set up environment variables for `VITASDK`, and it's binaries:\n \n@@ -88,40 +54,21 @@ Use the example below as a template for your project:\n [env]\n TITLE = \"Rust Hello World\"\n TITLEID = \"RUST00001\"\n-# Add other libs required by your project here\n-LINKER_LIBS = \"-lpthread -lm -lmathneon\"\n \n # At least a \"sce_sys\" folder should be place there for app metadata (title, icons, description...)\n # You can find sample assets for that on $VITASDK/share/gcc-arm-vita-eabi/samples/hello_world/sce_sys/\n STATIC_DIR = \"static\"   # Folder where static assets should be placed (sce_sys folder is at $STATIC_DIR/sce_sys)\n CARGO_TARGET_DIR = { script = [\"echo ${CARGO_TARGET_DIR:=target}\"] }\n-RUST_TARGET = \"armv7-sony-vita-newlibeabihf\"\n CARGO_OUT_DIR = \"${CARGO_TARGET_DIR}/${RUST_TARGET}/release\"\n \n-TARGET_LINKER = \"arm-vita-eabi-gcc\"\n-TARGET_LINKER_FLAGS = \"-Wl,-q\"\n-\n [tasks.build]\n-description = \"Build the project using `cargo` as a static lib.\"\n+description = \"Build the project using `cargo`.\"\n command = \"cargo\"\n args = [\"build\", \"-Z\", \"build-std=std,panic_abort\", \"--target=armv7-sony-vita-newlibeabihf\", \"--release\"]\n \n-[tasks.link]\n-description = \"Build an ELF executable using the `vitasdk` linker.\"\n-dependencies = [\"build\"]\n-script = [\n-    \"\"\"\n-    ${TARGET_LINKER} ${TARGET_LINKER_FLAGS} \\\n-        -L\"${CARGO_OUT_DIR}\" \\\n-        -l\"${CARGO_MAKE_CRATE_FS_NAME}\" \\\n-        ${LINKER_LIBS} \\\n-        -o\"${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_NAME}.elf\"\n-    \"\"\"\n-]\n-\n [tasks.strip]\n description = \"Strip the produced ELF executable.\"\n-dependencies = [\"link\"]\n+dependencies = [\"build\"]\n command = \"arm-vita-eabi-strip\"\n args = [\"-g\", '${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_FS_NAME}.elf']\n \n@@ -194,3 +141,11 @@ script = [\n ```\n \n After running the above script, you should be able to get a *.vpk file in the same folder your *.elf executable resides. Now you can pick it and install it on your own PlayStation Vita using, or you can use an [Vita3K](https://vita3k.org/) emulator.\n+\n+## Testing\n+\n+Currently there is no support to run the rustc test suite for this target.\n+\n+## Cross-compilation\n+\n+This target can be cross-compiled from `x86_64` on either Windows, MacOS or Linux systems. Other hosts are not supported for cross-compilation."}]}