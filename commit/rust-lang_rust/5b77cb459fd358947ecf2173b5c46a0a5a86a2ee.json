{"sha": "5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "node_id": "C_kwDOAAsO6NoAKDViNzdjYjQ1OWZkMzU4OTQ3ZWNmMjE3M2I1YzQ2YTBhNWE4NmEyZWU", "commit": {"author": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-01-24T20:40:43Z"}, "committer": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-01-24T20:51:01Z"}, "message": "Port pgo.sh to Python", "tree": {"sha": "065ca1e7791c4289d3ccaf61f9e13c05612a3b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/065ca1e7791c4289d3ccaf61f9e13c05612a3b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEzFQynJm4WzBnfhz8kJzQ0mSDUWsFAmPQRLUACgkQkJzQ0mSD\nUWuL+gwAyKi7sCdyQrPHQJP1UOcSpj481+yELS37fYYHvm0PCAprMdjnVjVhk8wd\nYBoOgkaSriGkPTyn0u6eunadGYig4ZsqHXGQovyWdTeuoXGDjkrfxKN5VaueappP\ndKkmIWnlwUG/v7zZr754Xvz1V0/gaW9KCNfGDfPBnH49QFcEHMRSMyaLiH4l4cSP\n6i3pHhtAAwyiycY/645Fm5guz0GB8nVBYXS5INaweP70nDf2Ozb0SeIkXpZEl9a9\ngJkjMFu+IczBxM+D88n3esnRMTWuHQvoRfSgjRJp7Mo3KP5sd/IKh//NAnTdF6CF\nnkp3WOyVBdSfIaRco43hNhvVR4myT9XuxQUPjCrkEfuRezcpW9FFGW1nSQ4ZndkA\nK2OjplG3BTEVY+nJQMxrR68MD8ho04XO1exzZsRku180DD4GSAnwhHNtQWP42NSf\n5MGkoa8b/zAIQ8TmByURqU54tFQ3SFe5X63ZYEUNTuVDXHKoGiJ8oMtJvh8FwzYo\nXvna/hbd\n=f141\n-----END PGP SIGNATURE-----", "payload": "tree 065ca1e7791c4289d3ccaf61f9e13c05612a3b76\nparent 44a500c8c187b245638684748f54bd6ec67e0b25\nauthor Jakub Ber\u00e1nek <berykubik@gmail.com> 1674592843 +0100\ncommitter Jakub Ber\u00e1nek <berykubik@gmail.com> 1674593461 +0100\n\nPort pgo.sh to Python\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "html_url": "https://github.com/rust-lang/rust/commit/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/comments", "author": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a500c8c187b245638684748f54bd6ec67e0b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/44a500c8c187b245638684748f54bd6ec67e0b25", "html_url": "https://github.com/rust-lang/rust/commit/44a500c8c187b245638684748f54bd6ec67e0b25"}], "stats": {"total": 669, "additions": 666, "deletions": 3}, "files": [{"sha": "04a50f1f107850666b8fea406c778840ac82c471", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "patch": "@@ -439,7 +439,7 @@ jobs:\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc"}, {"sha": "5feba4e0605ecb55b2b04bcaa30576014c5492ee", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "patch": "@@ -81,7 +81,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --set rust.jemalloc \\\n       --set rust.use-lld=true \\\n       --set rust.lto=thin\n-ENV SCRIPT ../src/ci/pgo.sh python3 ../x.py dist \\\n+ENV SCRIPT python3 ../src/ci/stage-build.py python3 ../x.py dist \\\n     --host $HOSTS --target $HOSTS \\\n     --include-default-paths \\\n     build-manifest bootstrap"}, {"sha": "8d86590777be3a6972c5aee56490eb474da9f61f", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "patch": "@@ -676,7 +676,7 @@ jobs:\n                 --enable-full-tools\n                 --enable-profiler\n                 --set rust.lto=thin\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             <<: *job-windows-xl\n "}, {"sha": "c373edfcf46a26ffefb1f21142f54afb0af4c198", "filename": "src/ci/stage-build.py", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "patch": "@@ -0,0 +1,663 @@\n+#!/usr/bin/env python3\n+# ignore-tidy-linelength\n+\n+# Compatible with Python 3.6+\n+\n+import contextlib\n+import getpass\n+import glob\n+import logging\n+import os\n+import pprint\n+import shutil\n+import subprocess\n+import sys\n+import time\n+import traceback\n+import urllib.request\n+from collections import OrderedDict\n+from io import StringIO\n+from pathlib import Path\n+from typing import Callable, Dict, Iterable, List, Optional, Union\n+\n+PGO_HOST = os.environ[\"PGO_HOST\"]\n+\n+LOGGER = logging.getLogger(\"stage-build\")\n+\n+LLVM_PGO_CRATES = [\n+    \"syn-1.0.89\",\n+    \"cargo-0.60.0\",\n+    \"serde-1.0.136\",\n+    \"ripgrep-13.0.0\",\n+    \"regex-1.5.5\",\n+    \"clap-3.1.6\",\n+    \"hyper-0.14.18\"\n+]\n+\n+RUSTC_PGO_CRATES = [\n+    \"externs\",\n+    \"ctfe-stress-5\",\n+    \"cargo-0.60.0\",\n+    \"token-stream-stress\",\n+    \"match-stress\",\n+    \"tuple-stress\",\n+    \"diesel-1.4.8\",\n+    \"bitmaps-3.1.0\"\n+]\n+\n+LLVM_BOLT_CRATES = LLVM_PGO_CRATES\n+\n+\n+class Pipeline:\n+    # Paths\n+    def checkout_path(self) -> Path:\n+        \"\"\"\n+        The root checkout, where the source is located.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        \"\"\"\n+        Directory where the host LLVM is located.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def build_root(self) -> Path:\n+        \"\"\"\n+        The main directory where the build occurs.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def build_artifacts(self) -> Path:\n+        return self.build_root() / \"build\" / PGO_HOST\n+\n+    def rustc_stage_0(self) -> Path:\n+        return self.build_artifacts() / \"stage0\" / \"bin\" / \"rustc\"\n+\n+    def cargo_stage_0(self) -> Path:\n+        return self.build_artifacts() / \"stage0\" / \"bin\" / \"cargo\"\n+\n+    def rustc_stage_2(self) -> Path:\n+        return self.build_artifacts() / \"stage2\" / \"bin\" / \"rustc\"\n+\n+    def opt_artifacts(self) -> Path:\n+        raise NotImplementedError\n+\n+    def llvm_profile_dir_root(self) -> Path:\n+        return self.opt_artifacts() / \"llvm-pgo\"\n+\n+    def llvm_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"llvm-pgo.profdata\"\n+\n+    def rustc_perf_dir(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-perf\"\n+\n+    def build_rustc_perf(self):\n+        raise NotImplementedError()\n+\n+    def rustc_profile_dir_root(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-pgo\"\n+\n+    def rustc_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-pgo.profdata\"\n+\n+    def rustc_profile_template_path(self) -> Path:\n+        \"\"\"\n+        The profile data is written into a single filepath that is being repeatedly merged when each\n+        rustc invocation ends. Empirically, this can result in some profiling data being lost. That's\n+        why we override the profile path to include the PID. This will produce many more profiling\n+        files, but the resulting profile will produce a slightly faster rustc binary.\n+        \"\"\"\n+        return self.rustc_profile_dir_root() / \"default_%m_%p.profraw\"\n+\n+    def supports_bolt(self) -> bool:\n+        raise NotImplementedError\n+\n+    def llvm_bolt_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"bolt.profdata\"\n+\n+\n+class LinuxPipeline(Pipeline):\n+    def checkout_path(self) -> Path:\n+        return Path(\"/checkout\")\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        return Path(\"/rustroot\")\n+\n+    def build_root(self) -> Path:\n+        return self.checkout_path() / \"obj\"\n+\n+    def opt_artifacts(self) -> Path:\n+        return Path(\"/tmp/tmp-multistage/opt-artifacts\")\n+\n+    def build_rustc_perf(self):\n+        # /tmp/rustc-perf comes from the Dockerfile\n+        shutil.copytree(\"/tmp/rustc-perf\", self.rustc_perf_dir())\n+        cmd([\"chown\", \"-R\", f\"{getpass.getuser()}:\", self.rustc_perf_dir()])\n+\n+        with change_cwd(self.rustc_perf_dir()):\n+            cmd([self.cargo_stage_0(), \"build\", \"-p\", \"collector\"], env=dict(\n+                RUSTC=str(self.rustc_stage_0()),\n+                RUSTC_BOOTSTRAP=\"1\"\n+            ))\n+\n+    def supports_bolt(self) -> bool:\n+        return True\n+\n+\n+class WindowsPipeline(Pipeline):\n+    def __init__(self):\n+        self.checkout_dir = Path(os.getcwd())\n+\n+    def checkout_path(self) -> Path:\n+        return self.checkout_dir\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        return self.checkout_path() / \"citools\" / \"clang-rust\"\n+\n+    def build_root(self) -> Path:\n+        return self.checkout_path()\n+\n+    def opt_artifacts(self) -> Path:\n+        return self.checkout_path() / \"opt-artifacts\"\n+\n+    def rustc_stage_0(self) -> Path:\n+        return super().rustc_stage_0().with_suffix(\".exe\")\n+\n+    def cargo_stage_0(self) -> Path:\n+        return super().cargo_stage_0().with_suffix(\".exe\")\n+\n+    def rustc_stage_2(self) -> Path:\n+        return super().rustc_stage_2().with_suffix(\".exe\")\n+\n+    def build_rustc_perf(self):\n+        # rustc-perf version from 2022-07-22\n+        perf_commit = \"3c253134664fdcba862c539d37f0de18557a9a4c\"\n+        rustc_perf_zip_path = self.opt_artifacts() / \"perf.zip\"\n+\n+        def download_rustc_perf():\n+            download_file(\n+                f\"https://github.com/rust-lang/rustc-perf/archive/{perf_commit}.zip\",\n+                rustc_perf_zip_path\n+            )\n+            with change_cwd(self.opt_artifacts()):\n+                unpack_archive(rustc_perf_zip_path)\n+                move_path(Path(f\"rustc-perf-{perf_commit}\"), self.rustc_perf_dir())\n+                delete_file(rustc_perf_zip_path)\n+\n+        retry_action(download_rustc_perf, \"Download rustc-perf\")\n+\n+        with change_cwd(self.rustc_perf_dir()):\n+            cmd([self.cargo_stage_0(), \"build\", \"-p\", \"collector\"], env=dict(\n+                RUSTC=str(self.rustc_stage_0()),\n+                RUSTC_BOOTSTRAP=\"1\"\n+            ))\n+\n+    def rustc_profile_template_path(self) -> Path:\n+        \"\"\"\n+        On Windows, we don't have enough space to use separate files for each rustc invocation.\n+        Therefore, we use a single file for the generated profiles.\n+        \"\"\"\n+        return self.rustc_profile_dir_root() / \"default_%m.profraw\"\n+\n+    def supports_bolt(self) -> bool:\n+        return False\n+\n+\n+class Timer:\n+    def __init__(self):\n+        # We want this dictionary to be ordered by insertion.\n+        # We use `OrderedDict` for compatibility with older Python versions.\n+        self.stages = OrderedDict()\n+\n+    @contextlib.contextmanager\n+    def stage(self, name: str):\n+        assert name not in self.stages\n+\n+        start = time.time()\n+        exc = None\n+        try:\n+            LOGGER.info(f\"Stage `{name}` starts\")\n+            yield\n+        except BaseException as exception:\n+            exc = exception\n+            raise\n+        finally:\n+            end = time.time()\n+            duration = end - start\n+            self.stages[name] = duration\n+            if exc is None:\n+                LOGGER.info(f\"Stage `{name}` ended: OK ({duration:.2f}s)\")\n+            else:\n+                LOGGER.info(f\"Stage `{name}` ended: FAIL ({duration:.2f}s)\")\n+\n+    def print_stats(self):\n+        total_duration = sum(self.stages.values())\n+\n+        # 57 is the width of the whole table\n+        divider = \"-\" * 57\n+\n+        with StringIO() as output:\n+            print(divider, file=output)\n+            for (name, duration) in self.stages.items():\n+                pct = (duration / total_duration) * 100\n+                name_str = f\"{name}:\"\n+                print(f\"{name_str:<34} {duration:>12.2f}s ({pct:>5.2f}%)\", file=output)\n+\n+            total_duration_label = \"Total duration:\"\n+            print(f\"{total_duration_label:<34} {total_duration:>12.2f}s\", file=output)\n+            print(divider, file=output, end=\"\")\n+            LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n+\n+\n+@contextlib.contextmanager\n+def change_cwd(dir: Path):\n+    \"\"\"\n+    Temporarily change working directory to `dir`.\n+    \"\"\"\n+    cwd = os.getcwd()\n+    LOGGER.debug(f\"Changing working dir from `{cwd}` to `{dir}`\")\n+    os.chdir(dir)\n+    try:\n+        yield\n+    finally:\n+        LOGGER.debug(f\"Reverting working dir to `{cwd}`\")\n+        os.chdir(cwd)\n+\n+\n+def move_path(src: Path, dst: Path):\n+    LOGGER.info(f\"Moving `{src}` to `{dst}`\")\n+    shutil.move(src, dst)\n+\n+\n+def delete_file(path: Path):\n+    LOGGER.info(f\"Deleting file `{path}`\")\n+    os.unlink(path)\n+\n+\n+def delete_directory(path: Path):\n+    LOGGER.info(f\"Deleting directory `{path}`\")\n+    shutil.rmtree(path)\n+\n+\n+def unpack_archive(archive: Path):\n+    LOGGER.info(f\"Unpacking archive `{archive}`\")\n+    shutil.unpack_archive(archive)\n+\n+\n+def download_file(src: str, target: Path):\n+    LOGGER.info(f\"Downloading `{src}` into `{target}`\")\n+    urllib.request.urlretrieve(src, str(target))\n+\n+\n+def retry_action(action, name: str, max_fails: int = 5):\n+    LOGGER.info(f\"Attempting to perform action `{name}` with retry\")\n+    for iteration in range(max_fails):\n+        LOGGER.info(f\"Attempt {iteration + 1}/{max_fails}\")\n+        try:\n+            action()\n+            return\n+        except:\n+            LOGGER.error(f\"Action `{name}` has failed\\n{traceback.format_exc()}\")\n+\n+    raise Exception(f\"Action `{name}` has failed after {max_fails} attempts\")\n+\n+\n+def cmd(\n+        args: List[Union[str, Path]],\n+        env: Optional[Dict[str, str]] = None,\n+        output_path: Optional[Path] = None\n+):\n+    args = [str(arg) for arg in args]\n+\n+    environment = os.environ.copy()\n+\n+    cmd_str = \"\"\n+    if env is not None:\n+        environment.update(env)\n+        cmd_str += \" \".join(f\"{k}={v}\" for (k, v) in (env or {}).items())\n+        cmd_str += \" \"\n+    cmd_str += \" \".join(args)\n+    if output_path is not None:\n+        cmd_str += f\" > {output_path}\"\n+    LOGGER.info(f\"Executing `{cmd_str}`\")\n+\n+    if output_path is not None:\n+        with open(output_path, \"w\") as f:\n+            return subprocess.run(\n+                args,\n+                env=environment,\n+                check=True,\n+                stdout=f\n+            )\n+    return subprocess.run(args, env=environment, check=True)\n+\n+\n+def run_compiler_benchmarks(\n+        pipeline: Pipeline,\n+        profiles: List[str],\n+        scenarios: List[str],\n+        crates: List[str],\n+        env: Optional[Dict[str, str]] = None\n+):\n+    env = env if env is not None else {}\n+\n+    # Compile libcore, both in opt-level=0 and opt-level=3\n+    with change_cwd(pipeline.build_root()):\n+        cmd([\n+            pipeline.rustc_stage_2(),\n+            \"--edition\", \"2021\",\n+            \"--crate-type\", \"lib\",\n+            str(pipeline.checkout_path() / \"library/core/src/lib.rs\"),\n+            \"--out-dir\", pipeline.opt_artifacts()\n+        ], env=dict(RUSTC_BOOTSTRAP=\"1\", **env))\n+\n+        cmd([\n+            pipeline.rustc_stage_2(),\n+            \"--edition\", \"2021\",\n+            \"--crate-type\", \"lib\",\n+            \"-Copt-level=3\",\n+            str(pipeline.checkout_path() / \"library/core/src/lib.rs\"),\n+            \"--out-dir\", pipeline.opt_artifacts()\n+        ], env=dict(RUSTC_BOOTSTRAP=\"1\", **env))\n+\n+    # Run rustc-perf benchmarks\n+    # Benchmark using profile_local with eprintln, which essentially just means\n+    # don't actually benchmark -- just make sure we run rustc a bunch of times.\n+    with change_cwd(pipeline.rustc_perf_dir()):\n+        cmd([\n+            pipeline.cargo_stage_0(),\n+            \"run\",\n+            \"-p\", \"collector\", \"--bin\", \"collector\", \"--\",\n+            \"profile_local\", \"eprintln\",\n+            pipeline.rustc_stage_2(),\n+            \"--id\", \"Test\",\n+            \"--cargo\", pipeline.cargo_stage_0(),\n+            \"--profiles\", \",\".join(profiles),\n+            \"--scenarios\", \",\".join(scenarios),\n+            \"--include\", \",\".join(crates)\n+        ], env=dict(\n+            RUST_LOG=\"collector=debug\",\n+            RUSTC=str(pipeline.rustc_stage_0()),\n+            RUSTC_BOOTSTRAP=\"1\",\n+            **env\n+        ))\n+\n+\n+# https://stackoverflow.com/a/31631711/1107768\n+def format_bytes(size: int) -> str:\n+    \"\"\"Return the given bytes as a human friendly KiB, MiB or GiB string.\"\"\"\n+    KB = 1024\n+    MB = KB ** 2  # 1,048,576\n+    GB = KB ** 3  # 1,073,741,824\n+    TB = KB ** 4  # 1,099,511,627,776\n+\n+    if size < KB:\n+        return f\"{size} B\"\n+    elif KB <= size < MB:\n+        return f\"{size / KB:.2f} KiB\"\n+    elif MB <= size < GB:\n+        return f\"{size / MB:.2f} MiB\"\n+    elif GB <= size < TB:\n+        return f\"{size / GB:.2f} GiB\"\n+    else:\n+        return str(size)\n+\n+\n+# https://stackoverflow.com/a/63307131/1107768\n+def count_files(path: Path) -> int:\n+    return sum(1 for p in path.rglob(\"*\") if p.is_file())\n+\n+\n+def count_files_with_prefix(path: Path) -> int:\n+    return sum(1 for p in glob.glob(f\"{path}*\") if Path(p).is_file())\n+\n+\n+# https://stackoverflow.com/a/55659577/1107768\n+def get_path_size(path: Path) -> int:\n+    if path.is_dir():\n+        return sum(p.stat().st_size for p in path.rglob(\"*\"))\n+    return path.stat().st_size\n+\n+\n+def get_path_prefix_size(path: Path) -> int:\n+    \"\"\"\n+    Get size of all files beginning with the prefix `path`.\n+    Alternative to shell `du -sh <path>*`.\n+    \"\"\"\n+    return sum(Path(p).stat().st_size for p in glob.glob(f\"{path}*\"))\n+\n+\n+def get_files(directory: Path, filter: Optional[Callable[[Path], bool]] = None) -> Iterable[Path]:\n+    for file in os.listdir(directory):\n+        path = directory / file\n+        if filter is None or filter(path):\n+            yield path\n+\n+\n+def build_rustc(\n+        pipeline: Pipeline,\n+        args: List[str],\n+        env: Optional[Dict[str, str]] = None\n+):\n+    arguments = [\n+                    sys.executable,\n+                    pipeline.checkout_path() / \"x.py\",\n+                    \"build\",\n+                    \"--target\", PGO_HOST,\n+                    \"--host\", PGO_HOST,\n+                    \"--stage\", \"2\",\n+                    \"library/std\"\n+                ] + args\n+    cmd(arguments, env=env)\n+\n+\n+def create_pipeline() -> Pipeline:\n+    if sys.platform == \"linux\":\n+        return LinuxPipeline()\n+    elif sys.platform in (\"cygwin\", \"win32\"):\n+        return WindowsPipeline()\n+    else:\n+        raise Exception(f\"Optimized build is not supported for platform {sys.platform}\")\n+\n+\n+def gather_llvm_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with PGO instrumented LLVM\")\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Debug\", \"Opt\"],\n+        scenarios=[\"Full\"],\n+        crates=LLVM_PGO_CRATES\n+    )\n+\n+    profile_path = pipeline.llvm_profile_merged_file()\n+    LOGGER.info(f\"Merging LLVM PGO profiles to {profile_path}\")\n+    cmd([\n+        pipeline.downloaded_llvm_dir() / \"bin\" / \"llvm-profdata\",\n+        \"merge\",\n+        \"-o\", profile_path,\n+        pipeline.llvm_profile_dir_root()\n+    ])\n+\n+    LOGGER.info(\"LLVM PGO statistics\")\n+    LOGGER.info(f\"{profile_path}: {format_bytes(get_path_size(profile_path))}\")\n+    LOGGER.info(\n+        f\"{pipeline.llvm_profile_dir_root()}: {format_bytes(get_path_size(pipeline.llvm_profile_dir_root()))}\")\n+    LOGGER.info(f\"Profile file count: {count_files(pipeline.llvm_profile_dir_root())}\")\n+\n+    # We don't need the individual .profraw files now that they have been merged\n+    # into a final .profdata\n+    delete_directory(pipeline.llvm_profile_dir_root())\n+\n+\n+def gather_rustc_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with PGO instrumented rustc\")\n+\n+    # Here we're profiling the `rustc` frontend, so we also include `Check`.\n+    # The benchmark set includes various stress tests that put the frontend under pressure.\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Check\", \"Debug\", \"Opt\"],\n+        scenarios=[\"All\"],\n+        crates=RUSTC_PGO_CRATES,\n+        env=dict(\n+            LLVM_PROFILE_FILE=str(pipeline.rustc_profile_template_path())\n+        )\n+    )\n+\n+    profile_path = pipeline.rustc_profile_merged_file()\n+    LOGGER.info(f\"Merging Rustc PGO profiles to {profile_path}\")\n+    cmd([\n+        pipeline.build_artifacts() / \"llvm\" / \"bin\" / \"llvm-profdata\",\n+        \"merge\",\n+        \"-o\", profile_path,\n+        pipeline.rustc_profile_dir_root()\n+    ])\n+\n+    LOGGER.info(\"Rustc PGO statistics\")\n+    LOGGER.info(f\"{profile_path}: {format_bytes(get_path_size(profile_path))}\")\n+    LOGGER.info(\n+        f\"{pipeline.rustc_profile_dir_root()}: {format_bytes(get_path_size(pipeline.rustc_profile_dir_root()))}\")\n+    LOGGER.info(f\"Profile file count: {count_files(pipeline.rustc_profile_dir_root())}\")\n+\n+    # We don't need the individual .profraw files now that they have been merged\n+    # into a final .profdata\n+    delete_directory(pipeline.rustc_profile_dir_root())\n+\n+\n+def gather_llvm_bolt_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with BOLT instrumented LLVM\")\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Check\", \"Debug\", \"Opt\"],\n+        scenarios=[\"Full\"],\n+        crates=LLVM_BOLT_CRATES\n+    )\n+\n+    merged_profile_path = pipeline.llvm_bolt_profile_merged_file()\n+    profile_files_path = Path(\"/tmp/prof.fdata\")\n+    LOGGER.info(f\"Merging LLVM BOLT profiles to {merged_profile_path}\")\n+\n+    profile_files = sorted(glob.glob(f\"{profile_files_path}*\"))\n+    cmd([\n+        \"merge-fdata\",\n+        *profile_files,\n+    ], output_path=merged_profile_path)\n+\n+    LOGGER.info(\"LLVM BOLT statistics\")\n+    LOGGER.info(f\"{merged_profile_path}: {format_bytes(get_path_size(merged_profile_path))}\")\n+    LOGGER.info(\n+        f\"{profile_files_path}: {format_bytes(get_path_prefix_size(profile_files_path))}\")\n+    LOGGER.info(f\"Profile file count: {count_files_with_prefix(profile_files_path)}\")\n+\n+\n+def clear_llvm_files(pipeline: Pipeline):\n+    \"\"\"\n+    Rustbuild currently doesn't support rebuilding LLVM when PGO options\n+    change (or any other llvm-related options); so just clear out the relevant\n+    directories ourselves.\n+    \"\"\"\n+    LOGGER.info(\"Clearing LLVM build files\")\n+    delete_directory(pipeline.build_artifacts() / \"llvm\")\n+    delete_directory(pipeline.build_artifacts() / \"lld\")\n+\n+\n+def print_binary_sizes(pipeline: Pipeline):\n+    bin_dir = pipeline.build_artifacts() / \"stage2\" / \"bin\"\n+    binaries = get_files(bin_dir)\n+\n+    lib_dir = pipeline.build_artifacts() / \"stage2\" / \"lib\"\n+    libraries = get_files(lib_dir, lambda p: p.suffix == \".so\")\n+\n+    paths = sorted(binaries) + sorted(libraries)\n+    with StringIO() as output:\n+        for path in paths:\n+            path_str = f\"{path.name}:\"\n+            print(f\"{path_str:<30}{format_bytes(path.stat().st_size):>14}\", file=output)\n+        LOGGER.info(f\"Rustc binary size\\n{output.getvalue()}\")\n+\n+\n+def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: List[str]):\n+    # Clear and prepare tmp directory\n+    shutil.rmtree(pipeline.opt_artifacts(), ignore_errors=True)\n+    os.makedirs(pipeline.opt_artifacts(), exist_ok=True)\n+\n+    pipeline.build_rustc_perf()\n+\n+    # Stage 1: Build rustc + PGO instrumented LLVM\n+    with timer.stage(\"Build rustc (LLVM PGO)\"):\n+        build_rustc(pipeline, args=[\n+            \"--llvm-profile-generate\"\n+        ], env=dict(\n+            LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n+        ))\n+\n+    with timer.stage(\"Gather profiles (LLVM PGO)\"):\n+        gather_llvm_profiles(pipeline)\n+\n+    clear_llvm_files(pipeline)\n+    final_build_args += [\n+        \"--llvm-profile-use\",\n+        pipeline.llvm_profile_merged_file()\n+    ]\n+\n+    # Stage 2: Build PGO instrumented rustc + LLVM\n+    with timer.stage(\"Build rustc (rustc PGO)\"):\n+        build_rustc(pipeline, args=[\n+            \"--rust-profile-generate\",\n+            pipeline.rustc_profile_dir_root()\n+        ])\n+\n+    with timer.stage(\"Gather profiles (rustc PGO)\"):\n+        gather_rustc_profiles(pipeline)\n+\n+    clear_llvm_files(pipeline)\n+    final_build_args += [\n+        \"--rust-profile-use\",\n+        pipeline.rustc_profile_merged_file()\n+    ]\n+\n+    # Stage 3: Build rustc + BOLT instrumented LLVM\n+    if pipeline.supports_bolt():\n+        with timer.stage(\"Build rustc (LLVM BOLT)\"):\n+            build_rustc(pipeline, args=[\n+                \"--llvm-profile-use\",\n+                pipeline.llvm_profile_merged_file(),\n+                \"--llvm-bolt-profile-generate\",\n+            ])\n+        with timer.stage(\"Gather profiles (LLVM BOLT)\"):\n+            gather_llvm_bolt_profiles(pipeline)\n+\n+        clear_llvm_files(pipeline)\n+        final_build_args += [\n+            \"--llvm-bolt-profile-use\",\n+            pipeline.llvm_bolt_profile_merged_file()\n+        ]\n+\n+    # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n+    with timer.stage(\"Final build\"):\n+        cmd(final_build_args)\n+\n+\n+if __name__ == \"__main__\":\n+    logging.basicConfig(\n+        level=logging.DEBUG,\n+        format=\"%(name)s %(levelname)-4s: %(message)s\",\n+    )\n+\n+    LOGGER.info(f\"Running multi-stage build using Python {sys.version}\")\n+    LOGGER.info(f\"Environment values\\n{pprint.pformat(dict(os.environ), indent=2)}\")\n+\n+    build_args = sys.argv[1:]\n+\n+    timer = Timer()\n+    pipeline = create_pipeline()\n+    try:\n+        execute_build_pipeline(timer, pipeline, build_args)\n+    except BaseException as e:\n+        LOGGER.error(\"The multi-stage build has failed\")\n+        raise e\n+    finally:\n+        timer.print_stats()\n+\n+    print_binary_sizes(pipeline)"}]}