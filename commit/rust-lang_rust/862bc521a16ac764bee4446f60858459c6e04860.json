{"sha": "862bc521a16ac764bee4446f60858459c6e04860", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MmJjNTIxYTE2YWM3NjRiZWU0NDQ2ZjYwODU4NDU5YzZlMDQ4NjA=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-16T17:57:44Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-16T17:59:49Z"}, "message": "Removing tasks, ports and chans from the compiler.", "tree": {"sha": "70bb0c06171ae662599773efa80ff57364201214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70bb0c06171ae662599773efa80ff57364201214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/862bc521a16ac764bee4446f60858459c6e04860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/862bc521a16ac764bee4446f60858459c6e04860", "html_url": "https://github.com/rust-lang/rust/commit/862bc521a16ac764bee4446f60858459c6e04860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/862bc521a16ac764bee4446f60858459c6e04860/comments", "author": null, "committer": null, "parents": [{"sha": "f05a91a0dca0bcbb9d9e20584923803df827e35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a91a0dca0bcbb9d9e20584923803df827e35b", "html_url": "https://github.com/rust-lang/rust/commit/f05a91a0dca0bcbb9d9e20584923803df827e35b"}], "stats": {"total": 348, "additions": 7, "deletions": 341}, "files": [{"sha": "95933ffec7f234430e0944c2b3fed38cc076b020", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -219,9 +219,6 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n       'V' { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n       'I' { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n-      'a' { ret ty::mk_task(st.tcx); }\n-      'P' { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n-      'C' { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n       'R' {\n         assert (next(st) as char == '[');\n         let fields: [ty::field] = ~[];"}, {"sha": "2b5345a1e72a059b8341ce282c266157ae7eb55a", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -130,8 +130,6 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n       ty::ty_vec(mt) { w.write_char('V'); enc_mt(w, cx, mt); }\n       ty::ty_ivec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n-      ty::ty_port(t) { w.write_char('P'); enc_ty(w, cx, t); }\n-      ty::ty_chan(t) { w.write_char('C'); enc_ty(w, cx, t); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\");\n         for field: ty::field in fields {\n@@ -188,7 +186,6 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n-      ty::ty_task. { w.write_char('a'); }\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);"}, {"sha": "a555076a30e2d37a07993fa0a73c89cd05b082c7", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -35,8 +35,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n         ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. |\n         ty::ty_float. | ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. |\n         ty::ty_istr. | ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) |\n-        ty::ty_port(_) | ty::ty_chan(_) | ty::ty_task. | ty::ty_type. |\n-        ty::ty_native(_) {\n+        ty::ty_type. | ty::ty_native(_) {\n             ret false;\n         }\n "}, {"sha": "cf4c9e2f05a3fdf12b2317cb676e1b6d12ed0746", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -357,13 +357,6 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n         add_size_hint(ccx, s, mt.ty);\n         add_substr(s, shape_of(ccx, mt.ty));\n       }\n-      ty::ty_port(t) {\n-        s += ~[shape_port];\n-        add_substr(s, shape_of(ccx, t));\n-      }\n-      ty::ty_chan(t) { s += ~[shape_chan]; }\n-      ty::ty_task. { s += ~[shape_task]; }\n-\n       ty::ty_rec(fields) {\n         s += ~[shape_struct];\n         let sub = ~[];"}, {"sha": "54aff99ffd788601ed57b4d91cf7f15107a57117", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -220,9 +220,6 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n         } else { llty = T_ivec(type_of_inner(cx, sp, mt.ty)); }\n       }\n       ty::ty_ptr(mt) { llty = T_ptr(type_of_inner(cx, sp, mt.ty)); }\n-      ty::ty_port(t) { llty = T_ptr(T_port(type_of_inner(cx, sp, t))); }\n-      ty::ty_chan(t) { llty = T_ptr(T_chan(type_of_inner(cx, sp, t))); }\n-      ty::ty_task. { llty = T_taskptr(*cx); }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = ~[];\n         for f: ty::field in fields {\n@@ -1255,18 +1252,7 @@ fn make_copy_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t) {\n \n     let bcx;\n \n-    if ty::type_is_task(bcx_tcx(cx), t) {\n-        let task_ptr = cx.build.Load(v);\n-        cx.build.Call(bcx_ccx(cx).upcalls.take_task,\n-                      ~[cx.fcx.lltaskptr, task_ptr]);\n-        bcx = cx;\n-    } else if ty::type_is_chan(bcx_tcx(cx), t) {\n-        let ptr = cx.build.Load(v);\n-        ptr = cx.build.PointerCast(ptr, T_opaque_chan_ptr());\n-        cx.build.Call(bcx_ccx(cx).upcalls.take_chan,\n-                      ~[cx.fcx.lltaskptr, ptr]);\n-        bcx = cx;\n-    } else if ty::type_is_boxed(bcx_tcx(cx), t) {\n+    if ty::type_is_boxed(bcx_tcx(cx), t) {\n         bcx = incr_refcnt_of_boxed(cx, cx.build.Load(v)).bcx;\n     } else if (ty::type_is_structural(bcx_tcx(cx), t)) {\n         bcx = duplicate_heap_parts_if_necessary(cx, v, t).bcx;\n@@ -1342,21 +1328,6 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n           ty::ty_uniq(_) {\n             fail \"free uniq unimplemented\";\n           }\n-          ty::ty_port(_) {\n-            let v = cx.build.Load(v0);\n-            cx.build.Call(bcx_ccx(cx).upcalls.del_port,\n-                          ~[cx.fcx.lltaskptr,\n-                            cx.build.PointerCast(v, T_opaque_port_ptr())]);\n-            rslt(cx, C_int(0))\n-          }\n-          ty::ty_chan(_) {\n-            let v = cx.build.Load(v0);\n-            cx.build.Call(bcx_ccx(cx).upcalls.del_chan,\n-                          ~[cx.fcx.lltaskptr,\n-                            cx.build.PointerCast(v, T_opaque_chan_ptr())]);\n-            rslt(cx, C_int(0))\n-          }\n-          ty::ty_task. { rslt(cx, C_nil()) }\n           ty::ty_obj(_) {\n             let box_cell =\n                 cx.build.GEP(v0, ~[C_int(0), C_int(abi::obj_field_box)]);\n@@ -1450,20 +1421,6 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n           }\n           ty::ty_box(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n           ty::ty_uniq(_) { fail \"drop uniq unimplemented\"; }\n-          ty::ty_port(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_chan(_) {\n-            let ptr = cx.build.Load(v0);\n-            ptr = cx.build.PointerCast(ptr, T_opaque_chan_ptr());\n-            {bcx: cx,\n-             val: cx.build.Call(bcx_ccx(cx).upcalls.drop_chan,\n-                                ~[cx.fcx.lltaskptr, ptr])}\n-          }\n-          ty::ty_task. {\n-            let task_ptr = cx.build.Load(v0);\n-            {bcx: cx,\n-             val: cx.build.Call(bcx_ccx(cx).upcalls.drop_task,\n-                                ~[cx.fcx.lltaskptr, task_ptr])}\n-          }\n           ty::ty_obj(_) {\n             let box_cell =\n                 cx.build.GEP(v0, ~[C_int(0), C_int(abi::obj_field_box)]);"}, {"sha": "c3c265b07453325ea2e46763a7c5bfb7cb5de541", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -356,13 +356,6 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n           _ { }\n         }\n       }\n-      expr_spawn(_, _, operator, operands) {\n-        let /* copy */args = operands;\n-        args += ~[operator];\n-        find_pre_post_exprs(fcx, args, e.id);\n-        forget_args_moved_in(fcx, e, callee_modes(fcx, operator.id),\n-                             operands);\n-      }\n       expr_vec(args, _, _) { find_pre_post_exprs(fcx, args, e.id); }\n       expr_path(p) {\n         let rslt = expr_pp(fcx.ccx, e);\n@@ -374,10 +367,6 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         find_pre_post_expr(fcx, arg);\n         copy_pre_post(fcx.ccx, e.id, arg);\n       }\n-      expr_chan(arg) {\n-        find_pre_post_expr(fcx, arg);\n-        copy_pre_post(fcx.ccx, e.id, arg);\n-      }\n       expr_put(opt) {\n         alt opt {\n           some(arg) {\n@@ -413,10 +402,6 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n       expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }\n       expr_assign(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_assign); }\n-      expr_recv(lhs, rhs) {\n-        // note inversion of lhs and rhs\n-        handle_update(fcx, e, rhs, lhs, oper_assign);\n-      }\n       expr_assign_op(_, lhs, rhs) {\n         /* Different from expr_assign in that the lhs *must*\n            already be initialized */\n@@ -460,7 +445,6 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n                               expr_postcond(fcx.ccx, l));\n         } else { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n       }\n-      expr_send(l, r) { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n       expr_unary(_, operand) {\n         find_pre_post_expr(fcx, operand);\n         copy_pre_post(fcx.ccx, e.id, operand);\n@@ -585,7 +569,6 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n       expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_port(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.inner_obj {"}, {"sha": "001c5f7d0e7669ac5563a560af09cc3603eff73f", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -323,11 +323,6 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n                                      operands,\n                                      controlflow_expr(fcx.ccx, operator));\n       }\n-      expr_spawn(_, _, operator, operands) {\n-        ret find_pre_post_state_call(fcx, pres, operator, e.id,\n-                                     callee_arg_init_ops(fcx, operator.id),\n-                                     operands, return);\n-      }\n       expr_bind(operator, maybe_args) {\n         let args = ~[];\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n@@ -350,9 +345,6 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_log(_, ex) {\n         ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n       }\n-      expr_chan(ex) {\n-        ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n-      }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_put(maybe_e) {\n         alt maybe_e {\n@@ -407,19 +399,6 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         // Could be more precise and actually swap the role of\n         // lhs and rhs in constraints\n       }\n-      expr_recv(lhs, rhs) {\n-        // Opposite order as most other binary operations,\n-        // so not using find_pre_post_state_two\n-        let changed =\n-            set_prestate_ann(fcx.ccx, e.id, pres) |\n-                find_pre_post_state_expr(fcx, pres, lhs) |\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n-                                         rhs);\n-        let post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n-        forget_in_poststate_still_init(fcx, post, rhs.id);\n-        gen_if_local(fcx, post, rhs);\n-        ret changed | set_poststate_ann(fcx.ccx, e.id, post);\n-      }\n       expr_ret(maybe_ret_val) {\n         let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n         /* normally, everything is true if execution continues after\n@@ -467,9 +446,6 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n             ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n         }\n       }\n-      expr_send(l, r) {\n-        ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n-      }\n       expr_assign_op(op, lhs, rhs) {\n         ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n                                     oper_assign_op);\n@@ -615,7 +591,6 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       }\n       expr_break. { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_cont. { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_port(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_self_method(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.inner_obj {"}, {"sha": "11341a0b489f7ad5f25695b392bc35c861d65234", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 102, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -62,7 +62,6 @@ export method_ty_to_fn_ty;\n export mk_bool;\n export mk_bot;\n export mk_box;\n-export mk_chan;\n export mk_char;\n export mk_constr;\n export mk_ctxt;\n@@ -81,12 +80,10 @@ export mk_nil;\n export mk_obj;\n export mk_res;\n export mk_param;\n-export mk_port;\n export mk_ptr;\n export mk_rec;\n export mk_str;\n export mk_tag;\n-export mk_task;\n export mk_tup;\n export mk_type;\n export mk_uint;\n@@ -123,7 +120,6 @@ export ty_native_fn;\n export ty_bool;\n export ty_bot;\n export ty_box;\n-export ty_chan;\n export ty_char;\n export ty_constr;\n export ty_constr_arg;\n@@ -141,12 +137,10 @@ export ty_nil;\n export ty_obj;\n export ty_res;\n export ty_param;\n-export ty_port;\n export ty_ptr;\n export ty_rec;\n export ty_str;\n export ty_tag;\n-export ty_task;\n export ty_tup;\n export ty_type;\n export ty_uint;\n@@ -169,8 +163,6 @@ export type_is_bool;\n export type_is_bot;\n export type_is_box;\n export type_is_boxed;\n-export type_is_chan;\n-export type_is_task;\n export type_is_fp;\n export type_is_integral;\n export type_is_native;\n@@ -273,9 +265,6 @@ tag sty {\n     ty_vec(mt);\n     ty_ivec(mt);\n     ty_ptr(mt);\n-    ty_port(t);\n-    ty_chan(t);\n-    ty_task;\n     ty_rec([field]);\n     ty_fn(ast::proto, [arg], t, controlflow, [@constr]);\n     ty_native_fn(ast::native_abi, [arg], t);\n@@ -356,13 +345,11 @@ const idx_str: uint = 16u;\n \n const idx_istr: uint = 17u;\n \n-const idx_task: uint = 18u;\n+const idx_type: uint = 18u;\n \n-const idx_type: uint = 19u;\n+const idx_bot: uint = 19u;\n \n-const idx_bot: uint = 20u;\n-\n-const idx_first_others: uint = 21u;\n+const idx_first_others: uint = 20u;\n \n type type_store = interner::interner[@raw_t];\n \n@@ -390,7 +377,6 @@ fn populate_type_store(cx: &ctxt) {\n     intern(cx, ty_char, none);\n     intern(cx, ty_str, none);\n     intern(cx, ty_istr, none);\n-    intern(cx, ty_task, none);\n     intern(cx, ty_type, none);\n     intern(cx, ty_bot, none);\n     assert (vec::len(cx.ts.vect) == idx_first_others);\n@@ -469,7 +455,6 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n       ty_char. {/* no-op */ }\n       ty_str. {/* no-op */ }\n       ty_istr. {/* no-op */ }\n-      ty_task. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_param(_,_) { has_params = true; }\n@@ -482,8 +467,6 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n       ty_vec(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_ivec(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_ptr(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n-      ty_port(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n-      ty_chan(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n       ty_rec(flds) {\n         for f: field in flds {\n             derive_flags_mt(cx, has_params, has_vars, f.mt);\n@@ -591,12 +574,6 @@ fn mk_imm_vec(cx: &ctxt, typ: &t) -> t {\n     ret gen_ty(cx, ty_vec({ty: typ, mut: ast::imm}));\n }\n \n-fn mk_port(cx: &ctxt, ty: &t) -> t { ret gen_ty(cx, ty_port(ty)); }\n-\n-fn mk_chan(cx: &ctxt, ty: &t) -> t { ret gen_ty(cx, ty_chan(ty)); }\n-\n-fn mk_task(cx: &ctxt) -> t { ret gen_ty(cx, ty_task); }\n-\n fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n@@ -664,14 +641,11 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_str. {/* no-op */ }\n       ty_istr. {/* no-op */ }\n       ty_type. {/* no-op */ }\n-      ty_task. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_vec(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_ivec(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_port(subty) { walk_ty(cx, walker, subty); }\n-      ty_chan(subty) { walk_ty(cx, walker, subty); }\n       ty_tag(tid, subtys) {\n         for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n@@ -737,7 +711,6 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_istr. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n-      ty_task. {/* no-op */ }\n       ty_box(tm) {\n         ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -751,8 +724,6 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_ivec(tm) {\n         ty = mk_ivec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n-      ty_port(subty) { ty = mk_port(cx, fold_ty(cx, fld, subty)); }\n-      ty_chan(subty) { ty = mk_chan(cx, fold_ty(cx, fld, subty)); }\n       ty_tag(tid, subtys) {\n         let new_subtys: [t] = ~[];\n         for subty: t in subtys { new_subtys += ~[fold_ty(cx, fld, subty)]; }\n@@ -862,14 +833,6 @@ fn type_is_bool(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) { ty_bool. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_chan(cx: &ctxt, ty: &t) -> bool {\n-    alt struct(cx, ty) { ty_chan(_) { ret true; } _ { ret false; } }\n-}\n-\n-fn type_is_task(cx: &ctxt, ty: &t) -> bool {\n-    alt struct(cx, ty) { ty_task. { ret true; } _ { ret false; } }\n-}\n-\n fn type_is_structural(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_rec(_) { ret true; }\n@@ -967,9 +930,6 @@ fn type_is_boxed(cx: &ctxt, ty: &t) -> bool {\n       ty_str. { ret true; }\n       ty_vec(_) { ret true; }\n       ty_box(_) { ret true; }\n-      ty_port(_) { ret true; }\n-      ty_chan(_) { ret true; }\n-      ty_task. { ret true; }\n       _ { ret false; }\n     }\n }\n@@ -1083,7 +1043,7 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n       }\n \n       // Those things with refcounts-to-interior are just shared.\n-      ty_str. | ty_task. {\n+      ty_str. {\n         result = kind_shared;\n       }\n \n@@ -1107,18 +1067,6 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n         result = ast::kind_shared;\n       }\n \n-      // FIXME: remove ports. Ports currently contribute 'shared'\n-      ty_port(t) {\n-        result = kind::lower_kind(ast::kind_shared,\n-                                  type_kind(cx, t));\n-      }\n-\n-      // FIXME: remove chans. Chans currently contribute only\n-      // their inner.\n-      ty_chan(t) {\n-        result = type_kind(cx, t);\n-      }\n-\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_ivec(tm) {\n@@ -1205,9 +1153,6 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_vec(_) { ret false; }\n       ty_ivec(mt) { ret type_has_dynamic_size(cx, mt.ty); }\n       ty_ptr(_) { ret false; }\n-      ty_port(_) { ret false; }\n-      ty_chan(_) { ret false; }\n-      ty_task. { ret false; }\n       ty_rec(fields) {\n         let i = 0u;\n         while i < vec::len[field](fields) {\n@@ -1357,9 +1302,6 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       ty_ptr(_) {\n         result = false;\n       }\n-      ty_port(_) { result = false; }\n-      ty_chan(_) { result = false; }\n-      ty_task. { result = false; }\n       ty_var(_) { fail \"ty_var in type_owns_heap_mem\"; }\n       ty_param(_,_) { result = false; }\n     }\n@@ -1380,8 +1322,7 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n \n         // Boxed types\n         ty_str. | ty_istr. | ty_box(_) | ty_vec(_) | ty_ivec(_) |\n-        ty_fn(_,_,_,_,_) | ty_native_fn(_,_,_) | ty_obj(_) | ty_port(_) |\n-        ty_chan(_) | ty_task. { result = false; }\n+        ty_fn(_,_,_,_,_) | ty_native_fn(_,_,_) | ty_obj(_) { result = false; }\n \n         // Structural types\n         ty_tag(did, tps) {\n@@ -1545,9 +1486,6 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n       ty_vec(mt) { ret hash_subty(20u, mt.ty); }\n       ty_ivec(mt) { ret hash_subty(21u, mt.ty); }\n-      ty_port(typ) { ret hash_subty(22u, typ); }\n-      ty_chan(typ) { ret hash_subty(23u, typ); }\n-      ty_task. { ret 24u; }\n       ty_rec(fields) {\n         let h = 26u;\n         for f: field in fields { h += h << 5u + hash_ty(f.mt.ty); }\n@@ -1717,13 +1655,6 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_ptr(mt_a) {\n         alt b { ty_ptr(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n       }\n-      ty_port(t_a) {\n-        alt b { ty_port(t_b) { ret eq_ty(t_a, t_b); } _ { ret false; } }\n-      }\n-      ty_chan(t_a) {\n-        alt b { ty_chan(t_b) { ret eq_ty(t_a, t_b); } _ { ret false; } }\n-      }\n-      ty_task. { alt b { ty_task. { ret true; } _ { ret false; } } }\n       ty_rec(flds_a) {\n         alt b {\n           ty_rec(flds_b) {\n@@ -2626,20 +2557,6 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_port(expected_sub) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_port(actual_sub) {\n-                let result = unify_step(cx, expected_sub, actual_sub);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    ret ures_ok(mk_port(cx.tcx, result_sub));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n-          }\n           ty::ty_res(ex_id, ex_inner, ex_tps) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_res(act_id, act_inner, act_tps) {\n@@ -2667,20 +2584,6 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_chan(expected_sub) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_chan(actual_sub) {\n-                let result = unify_step(cx, expected_sub, actual_sub);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    ret ures_ok(mk_chan(cx.tcx, result_sub));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n-          }\n           ty::ty_rec(expected_fields) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_rec(actual_fields) {"}, {"sha": "eeeebc7e9b81d1c7d348bee0a65ad587e5fcb721", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -333,13 +333,6 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       ast::ty_ptr(mt) {\n         typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n-      ast::ty_task. { typ = ty::mk_task(tcx); }\n-      ast::ty_port(t) {\n-        typ = ty::mk_port(tcx, ast_ty_to_ty(tcx, getter, t));\n-      }\n-      ast::ty_chan(t) {\n-        typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n-      }\n       ast::ty_tup(fields) {\n         let flds = vec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n@@ -1984,22 +1977,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         check_binop_type_compat(fcx, expr.span, expr_ty(tcx, lhs),\n                                 op);\n       }\n-      ast::expr_send(lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n-        let rhs_t = next_ty_var(fcx);\n-        let chan_t = ty::mk_chan(tcx, rhs_t);\n-        bot = check_expr_with(fcx, lhs, chan_t) |\n-              check_expr_with(fcx, rhs, rhs_t);\n-        write::ty_only_fixup(fcx, id, chan_t);\n-      }\n-      ast::expr_recv(lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n-        let rhs_t = next_ty_var(fcx);\n-        let port_t = ty::mk_port(tcx, rhs_t);\n-        bot = check_expr_with(fcx, lhs, port_t) |\n-              check_expr_with(fcx, rhs, rhs_t);\n-        write::ty_only_fixup(fcx, id, rhs_t);\n-      }\n       ast::expr_if(cond, thn, elsopt) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n               check_then_else(fcx, thn, elsopt, id, expr.span);\n@@ -2187,28 +2164,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         write::ty_only_fixup(fcx, id, t);\n         require_impure(tcx.sess, fcx.purity, expr.span);\n       }\n-      ast::expr_spawn(_, _, f, args) {\n-        bot = check_call(fcx, expr.span, f, args, kind_spawn);\n-        let fty = expr_ty(tcx, f);\n-        let ret_ty = alt structure_of(fcx, expr.span, fty) {\n-          ty::ty_fn(_, _, rt, _, _) { rt }\n-          ty::ty_native_fn(_, _, rt) { rt }\n-          _ { fail \"LHS of spawn expr didn't have a function type?!\" }\n-        };\n-\n-        demand::simple(fcx, f.span, ty::mk_nil(tcx), ret_ty);\n-\n-        // make sure they aren't spawning a function with type params\n-        if ty::expr_has_ty_params(tcx, f) {\n-            tcx.sess.span_fatal(\n-                f.span,\n-                \"spawning functions with type params not allowed (for now)\");\n-        }\n-\n-        // FIXME: Other typechecks needed\n-        let typ = ty::mk_task(tcx);\n-        write::ty_only_fixup(fcx, id, typ);\n-      }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n@@ -2360,15 +2315,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           }\n         }\n       }\n-      ast::expr_port(typ) {\n-        let pt = ty::mk_port(tcx, ast_ty_to_ty_crate_tyvar(fcx, typ));\n-        write::ty_only_fixup(fcx, id, pt);\n-      }\n-      ast::expr_chan(x) {\n-        let t = next_ty_var(fcx);\n-        check_expr_with(fcx, x, ty::mk_port(tcx, t));\n-        write::ty_only_fixup(fcx, id, ty::mk_chan(tcx, t));\n-      }\n       ast::expr_anon_obj(ao) {\n         let fields: [ast::anon_obj_field] = ~[];\n         alt ao.fields { none. { } some(v) { fields = v; } }"}, {"sha": "53e00e8c6b4f8b15344a0d8e800ae504c8b0a91f", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -298,7 +298,6 @@ tag expr_ {\n     expr_tup([@expr]);\n     expr_self_method(ident);\n     expr_bind(@expr, [option::t[@expr]]);\n-    expr_spawn(spawn_dom, option::t[str], @expr, [@expr]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);\n     expr_lit(@lit);\n@@ -321,8 +320,6 @@ tag expr_ {\n     expr_assign(@expr, @expr);\n     expr_swap(@expr, @expr);\n     expr_assign_op(binop, @expr, @expr);\n-    expr_send(@expr, @expr);\n-    expr_recv(@expr, @expr);\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_path(path);\n@@ -340,8 +337,6 @@ tag expr_ {\n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n     expr_if_check(@expr, blk, option::t[@expr]);\n-    expr_port(@ty);\n-    expr_chan(@expr);\n     expr_anon_obj(anon_obj);\n     expr_mac(mac);\n     expr_uniq(@expr);"}, {"sha": "9cf9bf3e8b46aac1326631338010ab8e457f28fb", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -357,10 +357,6 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             let opt_map_se = bind option::map(fld.fold_expr, _);\n             expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))\n           }\n-          expr_spawn(spawn_dom, name, f, args) {\n-            expr_spawn(spawn_dom, name, fld.fold_expr(f),\n-                       fld.map_exprs(fld.fold_expr, args))\n-          }\n           expr_binary(binop, lhs, rhs) {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n           }\n@@ -409,12 +405,6 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n           expr_assign_op(op, el, er) {\n             expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_send(el, er) {\n-            expr_send(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_recv(el, er) {\n-            expr_recv(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n           expr_field(el, id) {\n             expr_field(fld.fold_expr(el), fld.fold_ident(id))\n           }\n@@ -435,10 +425,6 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n                           option::map(fld.fold_expr, fl))\n           }\n-          expr_port(t) {\n-            expr_port(fld.fold_ty(t))\n-          }\n-          expr_chan(e) { expr_chan(fld.fold_expr(e)) }\n           expr_anon_obj(ao) { expr_anon_obj(fold_anon_obj(ao)) }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n           expr_uniq(e) { expr_uniq(fld.fold_expr(e)) }"}, {"sha": "780d67b4b27b7eb322c3b101a848065fa94b6af6", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -1351,21 +1351,6 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ast::expr_alt(discriminant, arms));\n }\n \n-fn parse_spawn_expr(p: &parser) -> @ast::expr {\n-    let lo = p.get_last_lo_pos();\n-    // FIXME: Parse domain and name\n-    // FIXME: why no full expr?\n-\n-    let fn_expr = parse_bottom_expr(p);\n-    let es =\n-        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                  parse_expr, p);\n-    let hi = es.span.hi;\n-    ret mk_expr(p, lo, hi,\n-                ast::expr_spawn(ast::dom_implicit, option::none, fn_expr,\n-                                es.node));\n-}\n-\n fn parse_expr(p: &parser) -> @ast::expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n@@ -1614,7 +1599,6 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n               ast::expr_call(_, _) { true }\n               ast::expr_self_method(_) { false }\n               ast::expr_bind(_, _) { true }\n-              ast::expr_spawn(_, _, _, _) { true }\n               ast::expr_binary(_, _, _) { true }\n               ast::expr_unary(_, _) { true }\n               ast::expr_lit(_) { true }\n@@ -1632,8 +1616,6 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n               ast::expr_assign(_, _) { true }\n               ast::expr_swap(_, _) { true }\n               ast::expr_assign_op(_, _, _) { true }\n-              ast::expr_send(_, _) { true }\n-              ast::expr_recv(_, _) { true }\n               ast::expr_field(_, _) { true }\n               ast::expr_index(_, _) { true }\n               ast::expr_path(_) { true }\n@@ -1647,8 +1629,6 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n               ast::expr_log(_, _) { true }\n               ast::expr_check(_, _) { true }\n               ast::expr_if_check(_, _, _) { false }\n-              ast::expr_port(_) { true }\n-              ast::expr_chan(_) { true }\n               ast::expr_anon_obj(_) { false }\n               ast::expr_assert(_) { true }\n             }"}, {"sha": "c3291314c70be6eae290bb454d641ea72c3fbd3a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -783,13 +783,6 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         commasep(s, inconsistent, args, print_opt);\n         pclose(s);\n       }\n-      ast::expr_spawn(_, _, e, es) {\n-        word_nbsp(s, \"spawn\");\n-        print_expr(s, e);\n-        popen(s);\n-        commasep_exprs(s, inconsistent, es);\n-        pclose(s);\n-      }\n       ast::expr_binary(op, lhs, rhs) {\n         let prec = operator_prec(op);\n         print_maybe_parens(s, lhs, prec);\n@@ -928,18 +921,6 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_send(lhs, rhs) {\n-        print_expr(s, lhs);\n-        space(s.s);\n-        word_space(s, \"<|\");\n-        print_expr(s, rhs);\n-      }\n-      ast::expr_recv(lhs, rhs) {\n-        print_expr(s, lhs);\n-        space(s.s);\n-        word_space(s, \"|>\");\n-        print_expr(s, rhs);\n-      }\n       ast::expr_field(expr, id) {\n         print_expr_parens_if_unary(s, expr);\n         word(s.s, \".\");\n@@ -997,21 +978,6 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         pclose(s);\n       }\n       ast::expr_mac(m) { print_mac(s, m); }\n-      ast::expr_port(t) {\n-        word(s.s, \"port\");\n-        alt t.node {\n-          ast::ty_infer. { }\n-          _ { word(s.s, \"[\"); print_type(s, t); word(s.s, \"]\"); }\n-        }\n-        popen(s);\n-        pclose(s);\n-      }\n-      ast::expr_chan(expr) {\n-        word(s.s, \"chan\");\n-        popen(s);\n-        print_expr(s, expr);\n-        pclose(s);\n-      }\n       ast::expr_anon_obj(anon_obj) {\n         head(s, \"obj\");\n "}, {"sha": "2f259ddcc306e98916a62f9ce6f855e624773bb9", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -262,10 +262,6 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n         v.visit_expr(callee, e, v);\n         for eo: option::t[@expr] in args { visit_expr_opt(eo, e, v); }\n       }\n-      expr_spawn(_, _, callee, args) {\n-        v.visit_expr(callee, e, v);\n-        visit_exprs(args, e, v);\n-      }\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_unary(_, a) { v.visit_expr(a, e, v); }\n       expr_lit(_) { }\n@@ -306,8 +302,6 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n         v.visit_expr(b, e, v);\n         v.visit_expr(a, e, v);\n       }\n-      expr_send(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n-      expr_recv(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_field(x, _) { v.visit_expr(x, e, v); }\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n@@ -320,8 +314,6 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n       expr_log(_, x) { v.visit_expr(x, e, v); }\n       expr_check(_, x) { v.visit_expr(x, e, v); }\n       expr_assert(x) { v.visit_expr(x, e, v); }\n-      expr_port(t) { v.visit_ty(t, e, v); }\n-      expr_chan(x) { v.visit_expr(x, e, v); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.fields {\n           none. { }"}, {"sha": "4b1c3a8ad765009747400680c4f8ac28bd3e51e3", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bc521a16ac764bee4446f60858459c6e04860/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=862bc521a16ac764bee4446f60858459c6e04860", "patch": "@@ -94,10 +94,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       ty_uniq(t) { s += \"~\" + ty_to_str(cx, t); }\n       ty_vec(tm) { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n       ty_ivec(tm) { s += \"[\" + mt_to_str(cx, tm) + \"]\"; }\n-      ty_port(t) { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n-      ty_chan(t) { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n       ty_type. { s += \"type\"; }\n-      ty_task. { s += \"task\"; }\n       ty_rec(elems) {\n         let strs: [str] = ~[];\n         for fld: field in elems { strs += ~[field_to_str(cx, fld)]; }"}]}