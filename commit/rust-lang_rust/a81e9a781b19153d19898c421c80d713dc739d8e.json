{"sha": "a81e9a781b19153d19898c421c80d713dc739d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MWU5YTc4MWIxOTE1M2QxOTg5OGM0MjFjODBkNzEzZGM3MzlkOGU=", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2020-05-19T13:37:06Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2020-05-21T16:38:41Z"}, "message": "Improve documentation of `slice::from_raw_parts`\n\nThis is to provide a more explicit statement against a code pattern that\nmany people end up coming with, since the reason of it being unsound\ncomes from the badly known single-allocation validity rule.\n\nProviding that very pattern as a counter-example could help mitigate that.\n\nCo-authored-by: Ralf Jung <post@ralfj.de>", "tree": {"sha": "09a76f43bfeb8ccb6f5a9fee1281df6258342626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a76f43bfeb8ccb6f5a9fee1281df6258342626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a81e9a781b19153d19898c421c80d713dc739d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a81e9a781b19153d19898c421c80d713dc739d8e", "html_url": "https://github.com/rust-lang/rust/commit/a81e9a781b19153d19898c421c80d713dc739d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a81e9a781b19153d19898c421c80d713dc739d8e/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c9fef822b890054fcefa9a567b57eb6edfe638", "url": "https://api.github.com/repos/rust-lang/rust/commits/06c9fef822b890054fcefa9a567b57eb6edfe638", "html_url": "https://github.com/rust-lang/rust/commit/06c9fef822b890054fcefa9a567b57eb6edfe638"}], "stats": {"total": 31, "additions": 30, "deletions": 1}, "files": [{"sha": "2e1dd89433d9e22d628a47670fe4b5518976b1af", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a81e9a781b19153d19898c421c80d713dc739d8e/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a81e9a781b19153d19898c421c80d713dc739d8e/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a81e9a781b19153d19898c421c80d713dc739d8e", "patch": "@@ -5740,7 +5740,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n ///   and it must be properly aligned. This means in particular:\n ///\n ///     * The entire memory range of this slice must be contained within a single allocated object!\n-///       Slices can never span across multiple allocated objects.\n+///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n+///       for an example incorrectly not taking this into account.\n ///     * `data` must be non-null and aligned even for zero-length slices. One\n ///       reason for this is that enum layout optimizations may rely on references\n ///       (including slices of any length) being aligned and non-null to distinguish\n@@ -5773,6 +5774,34 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n /// assert_eq!(slice[0], 42);\n /// ```\n ///\n+/// ### Incorrect usage\n+///\n+/// The following `join_slices` function is **unsound** \u26a0\ufe0f\n+///\n+/// ```rust,no_run\n+/// use std::slice;\n+///\n+/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n+///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n+///     let snd_start = snd.as_ptr();\n+///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n+///     unsafe {\n+///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n+///         // still be contained within _different allocated objects_, in which case\n+///         // creating this slice is undefined behavior.\n+///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     // `a` and `b` are different allocated objects...\n+///     let a = 42;\n+///     let b = 27;\n+///     // ... which may nevertheless be laid out contiguous in memory: | a | b |\n+///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n+/// }\n+/// ```\n+///\n /// [valid]: ../../std/ptr/index.html#safety\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset"}]}