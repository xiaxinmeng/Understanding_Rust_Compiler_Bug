{"sha": "f08af9a7a56bd91475502ffb5921db461be63281", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOGFmOWE3YTU2YmQ5MTQ3NTUwMmZmYjU5MjFkYjQ2MWJlNjMyODE=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-01-30T02:30:22Z"}, "committer": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-01-31T04:18:08Z"}, "message": "RIMOV, round 5\n\nfind ./ -type f -name \"*.rs\" -exec sed -i \"s/\\&\\[mut /\\&mut \\[/g\" {} \\;", "tree": {"sha": "2b4369122679ffc0507cf97614c5ba2cb987a7a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b4369122679ffc0507cf97614c5ba2cb987a7a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f08af9a7a56bd91475502ffb5921db461be63281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f08af9a7a56bd91475502ffb5921db461be63281", "html_url": "https://github.com/rust-lang/rust/commit/f08af9a7a56bd91475502ffb5921db461be63281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f08af9a7a56bd91475502ffb5921db461be63281/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e8151fb0345d926b2e211e8088f8b89236baa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e8151fb0345d926b2e211e8088f8b89236baa4", "html_url": "https://github.com/rust-lang/rust/commit/12e8151fb0345d926b2e211e8088f8b89236baa4"}], "stats": {"total": 124, "additions": 64, "deletions": 60}, "files": [{"sha": "210ecfd70aaef71d81fb871d7978054a2b291666", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -223,7 +223,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n+    fn borrow_mut<R>(op: fn(x: &mut [A]) -> R) -> R {\n         do self.check_out |v| {\n             let mut v = move v;\n             let result = op(v);"}, {"sha": "9f6eac1d4202524b302ee58b3e6105d6620ffefc", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -59,7 +59,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n \n     /// Read a single byte, returning a negative value for EOF or read error.\n     fn read_byte(&self) -> int;\n@@ -419,7 +419,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n                 assert buf_len >= len;\n@@ -464,7 +464,7 @@ struct Wrapper<T, C> {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<R: Reader, C> Wrapper<R, C>: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n     fn read_byte(&self) -> int { self.base.read_byte() }\n@@ -531,7 +531,7 @@ pub struct BytesReader {\n }\n \n impl BytesReader: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n         let view = vec::view(self.bytes, self.pos, self.bytes.len());"}, {"sha": "8f0fc02ac216e962ead38d72d441857929910ee2", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -254,7 +254,7 @@ impl Rng {\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(values: &[mut T]) {\n+    fn shuffle_mut<T>(values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place."}, {"sha": "5361e4a58345cedb0786dc1d96009ba53c1f320c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -1263,12 +1263,12 @@ pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-pub fn swap<T>(v: &[mut T], a: uint, b: uint) {\n+pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n /// Reverse the order of elements in a vector, in place\n-pub fn reverse<T>(v: &[mut T]) {\n+pub fn reverse<T>(v: &mut [T]) {\n     let mut i: uint = 0;\n     let ln = len::<T>(v);\n     while i < ln / 2 { v[i] <-> v[ln - i - 1]; i += 1; }\n@@ -1349,7 +1349,7 @@ pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1519,7 +1519,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pub pure fn as_mut_buf<T,U>(s: &[mut T],\n+pub pure fn as_mut_buf<T,U>(s: &mut [T],\n                         f: fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n@@ -2066,7 +2066,7 @@ pub mod raw {\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n+    pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n@@ -2099,7 +2099,7 @@ pub mod raw {\n      * is newly allocated.\n      */\n     #[inline(always)]\n-    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n+    pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -2133,7 +2133,7 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub unsafe fn copy_memory<T>(dst: &[mut T], src: &[const T],\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n                                  count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n@@ -2199,8 +2199,12 @@ pub mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n+<<<<<<< HEAD\n     #[inline(always)]\n     pub fn copy_memory(dst: &[mut u8], src: &[const u8], count: uint) {\n+=======\n+    pub fn copy_memory(dst: &mut [u8], src: &[const u8], count: uint) {\n+>>>>>>> RIMOV, round 5\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }"}, {"sha": "699b82b7dd4bb1fe57422c786feeb42a7d00612d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -127,13 +127,13 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn all_mem(cls: &[mut x86_64_reg_class]) {\n+    fn all_mem(cls: &mut [x86_64_reg_class]) {\n         for uint::range(0, cls.len()) |i| {\n             cls[i] = memory_class;\n         }\n     }\n \n-    fn unify(cls: &[mut x86_64_reg_class],\n+    fn unify(cls: &mut [x86_64_reg_class],\n              i: uint,\n              newv: x86_64_reg_class) {\n         if cls[i] == newv {\n@@ -159,7 +159,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn classify_struct(tys: &[TypeRef],\n-                       cls: &[mut x86_64_reg_class], i: uint,\n+                       cls: &mut [x86_64_reg_class], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n         for vec::each(tys) |ty| {\n@@ -170,7 +170,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn classify(ty: TypeRef,\n-                cls: &[mut x86_64_reg_class], ix: uint,\n+                cls: &mut [x86_64_reg_class], ix: uint,\n                 off: uint) {\n         unsafe {\n             let t_align = ty_align(ty);\n@@ -220,7 +220,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n+    fn fixup(ty: TypeRef, cls: &mut [x86_64_reg_class]) {\n         unsafe {\n             let mut i = 0u;\n             let llty = llvm::LLVMGetTypeKind(ty) as int;"}, {"sha": "34798387d730a8bbdd6be4a84581b018f1673107", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -778,7 +778,7 @@ pub impl LookupContext {\n         /*!\n          *\n          * In the event that we are invoking a method with a receiver\n-         * of a linear borrowed type like `&mut T` or `&[mut T]`,\n+         * of a linear borrowed type like `&mut T` or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n          * you have a call `r.inc()` and where `r` has type `&mut T`,\n          * then we treat that like `(&mut *r).inc()`.  This avoids"}, {"sha": "9a90b811e44c540fbca0a48fa328754356ef0ff3", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -43,7 +43,7 @@ pub impl BufReader {\n }\n \n impl BufReader: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.as_bytes_reader(|r| r.read(bytes, len) )\n     }\n     fn read_byte(&self) -> int {"}, {"sha": "b3673a0f2a18055cb91b0070e92413f1c7ad84b6", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -863,7 +863,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(&self, buf: &[mut u8], len: uint) -> uint {\n+    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n         if len == 0 { return 0 }\n         let mut count: uint = 0;\n "}, {"sha": "977008e5995f1e192bbe2c30bb46de1dd599f728", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -788,7 +788,7 @@ pub mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    pub fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n+    pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {"}, {"sha": "c8e6fedbc5d02a3471c2dbe6cac3da8a3ff97262", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -64,7 +64,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(arr: &[mut T], left: uint,\n+fn part<T: Copy>(arr: &mut [T], left: uint,\n                 right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -81,7 +81,7 @@ fn part<T: Copy>(arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(arr: &[mut T], left: uint,\n+fn qsort<T: Copy>(arr: &mut [T], left: uint,\n              right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -100,12 +100,12 @@ fn qsort<T: Copy>(arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(arr: &[mut T], compare_func: Le<T>) {\n+pub fn quick_sort<T: Copy>(arr: &mut [T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n-fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n+fn qsort3<T: Copy Ord Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -162,7 +162,7 @@ fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-pub fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n+pub fn quick_sort3<T: Copy Ord Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n@@ -171,15 +171,15 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T: Copy Ord Eq> &[mut T] : Sort {\n+impl<T: Copy Ord Eq> &mut [T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n+pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -218,7 +218,7 @@ pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n+fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n     assert start <= size;\n@@ -249,7 +249,7 @@ fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n }\n \n // Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n+fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n         util::swap(&mut v[i], &mut v[end - i - 1]);\n@@ -268,7 +268,7 @@ pure fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T: Copy Ord>(array: &[mut T]) -> uint {\n+fn count_run_ascending<T: Copy Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -412,7 +412,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.push(tmp);\n     }\n \n-    fn merge_at(&self, n: uint, array: &[mut T]) {\n+    fn merge_at(&self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n         assert size >= 2;\n         assert n == size-2 || n == size-3;\n@@ -453,7 +453,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.pop();\n     }\n \n-    fn merge_lo(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_lo(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n@@ -556,7 +556,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_hi(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n@@ -674,7 +674,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_collapse(&self, array: &[mut T]) {\n+    fn merge_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             let chk = do self.runs.borrow |arr| {\n@@ -692,7 +692,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_force_collapse(&self, array: &[mut T]) {\n+    fn merge_force_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             if n > 0 {\n@@ -708,7 +708,7 @@ impl<T: Copy Ord> MergeState<T> {\n }\n \n #[inline(always)]\n-fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n+fn copy_vec<T: Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n@@ -726,7 +726,7 @@ mod test_qsort3 {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -772,7 +772,7 @@ mod test_qsort {\n     use core::int;\n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -923,7 +923,7 @@ mod test_tim_sort {\n         pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n-    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         tim_sort::<int>(v1);\n         let mut i = 0u;"}, {"sha": "b679b83228589de369a6c42ad24ca55f43b79fba", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -16,7 +16,7 @@ fn eval_A(i: uint, j: uint) -> float {\n     1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n }\n \n-fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_A_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -30,7 +30,7 @@ fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -44,7 +44,7 @@ fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_AtA_times_u(u: &[const float], AtAu: &[mut float]) {\n+fn eval_AtA_times_u(u: &[const float], AtAu: &mut [float]) {\n     let v = vec::cast_to_mut(vec::from_elem(vec::len(u), 0.0));\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);"}, {"sha": "bc0340983ae3491348db9d9806f51d1d5e50fbb6", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn write(v: &[mut int]) {\n+fn write(v: &mut [int]) {\n     v[0] += 1;\n }\n "}, {"sha": "926b6b324f87aa5e8249ab0bce32d9a87e9b87f2", "filename": "src/test/compile-fail/issue-3243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test\n-fn function() -> &[mut int] {\n+fn function() -> &mut [int] {\n     let mut x: &static/[int] = &[1,2,3];\n     x[0] = 12345;\n     x //~ ERROR bad"}, {"sha": "2b60bf31beac762b08f7b52db03147f7a4eb8a59", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -4,7 +4,7 @@ pure fn sum(x: &[int]) -> int {\n     return sum;\n }\n \n-fn sum_mut(y: &[mut int]) -> int {\n+fn sum_mut(y: &mut [int]) -> int {\n     sum(y)\n }\n "}, {"sha": "ad8779cdbbf1e35c26e46479fd3aeaa4d965c8b6", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -2,7 +2,7 @@ fn foo(v: &[const uint]) -> ~[uint] {\n     v.to_vec()\n }\n \n-fn bar(v: &[mut uint]) -> ~[uint] {\n+fn bar(v: &mut [uint]) -> ~[uint] {\n     v.to_vec()\n }\n "}, {"sha": "e5cf8b3919a1238226f9c64c27857a07d539fd37", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -2,7 +2,7 @@ trait Reverser {\n     fn reverse(&self);\n }\n \n-fn bar(v: &[mut uint]) {\n+fn bar(v: &mut [uint]) {\n     vec::reverse(v);\n     vec::reverse(v);\n     vec::reverse(v);"}, {"sha": "63b12a8a12a0dc8e355bce24d8255b474c80a9ad", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -2,13 +2,13 @@ trait Reverser {\n     fn reverse(&self);\n }\n \n-impl &[mut uint] : Reverser {\n+impl &mut [uint] : Reverser {\n     fn reverse(&self) {\n         vec::reverse(*self);\n     }\n }\n \n-fn bar(v: &[mut uint]) {\n+fn bar(v: &mut [uint]) {\n     v.reverse();\n     v.reverse();\n     v.reverse();"}, {"sha": "9557b5d566539c1b1d7e73e9aa877709decd1f33", "filename": "src/test/run-pass/explicit-self-objects-ext-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "9557b5d566539c1b1d7e73e9aa877709decd1f33", "filename": "src/test/run-pass/explicit-self-objects-ext-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "404a94f467b995d636bb5b030bb55e3351603be6", "filename": "src/test/run-pass/explicit-self-objects-ext-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "e2970f515febdbd9a856baba47cb1e194dca12b2", "filename": "src/test/run-pass/explicit-self-objects-ext-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(bytes: &[mut u8], len: uint) -> uint;\n+    fn read(bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(bytes: &[mut u8], len: uint) -> uint {\n+    fn read(bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "c2c3d077799fb56b1856038e8789256f4e47f061", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08af9a7a56bd91475502ffb5921db461be63281/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=f08af9a7a56bd91475502ffb5921db461be63281", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn swap<T>(v: &[mut T], i: int, j: int) { v[i] <-> v[j]; }\n+fn swap<T>(v: &mut [T], i: int, j: int) { v[i] <-> v[j]; }\n \n fn main() {\n     let mut a: ~[int] = ~[0, 1, 2, 3, 4, 5, 6];"}]}