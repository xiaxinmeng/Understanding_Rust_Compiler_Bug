{"sha": "4bb68828de9c424c572a7ec11417660478ca7501", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYjY4ODI4ZGU5YzQyNGM1NzJhN2VjMTE0MTc2NjA0NzhjYTc1MDE=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-01-18T19:08:11Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-01-20T21:00:01Z"}, "message": "Read metadata from rmeta exclusively, if possible\n\nWhen we're producing an rlib, we do not need anything more than an rmeta file\nfor each of our dependencies (this is indeed utilized by Cargo for pipelining).\nPreviously, we were still storing the paths of possible rlib/dylib crates, which\nmeant that they could still plausibly be accessed. With -Zbinary-dep-depinfo,\nthat meant that Cargo thought that rustc was using both the rlib and an (earlier\nemitted) rmeta, and so needed a recompile, as the rlib may have finished writing\n*after* compilation started (for more detail, see issue 68149).\n\nThis commit changes metadata loading to not store the filepaths of dylib/rlib if\nwe're going to end up creating an rlib only.", "tree": {"sha": "7e25feca93fbb4b5ea690e11131378428a115f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e25feca93fbb4b5ea690e11131378428a115f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb68828de9c424c572a7ec11417660478ca7501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb68828de9c424c572a7ec11417660478ca7501", "html_url": "https://github.com/rust-lang/rust/commit/4bb68828de9c424c572a7ec11417660478ca7501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb68828de9c424c572a7ec11417660478ca7501/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48840618382eccb8a799320c8e5d08e3b52f4c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/48840618382eccb8a799320c8e5d08e3b52f4c42", "html_url": "https://github.com/rust-lang/rust/commit/48840618382eccb8a799320c8e5d08e3b52f4c42"}], "stats": {"total": 44, "additions": 38, "deletions": 6}, "files": [{"sha": "75182e32ae5b9587193f0b34e18825cef540af90", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4bb68828de9c424c572a7ec11417660478ca7501/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb68828de9c424c572a7ec11417660478ca7501/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=4bb68828de9c424c572a7ec11417660478ca7501", "patch": "@@ -656,14 +656,36 @@ impl<'a> CrateLocator<'a> {\n         dylibs: FxHashMap<PathBuf, PathKind>,\n     ) -> Option<(Svh, Library)> {\n         let mut slot = None;\n+        // Order here matters, rmeta should come first. See comment in\n+        // `extract_one` below.\n         let source = CrateSource {\n-            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n             rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n             dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n         };\n         slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n     }\n \n+    fn needs_crate_flavor(&self, flavor: CrateFlavor) -> bool {\n+        if flavor == CrateFlavor::Dylib && self.is_proc_macro == Some(true) {\n+            return true;\n+        }\n+\n+        // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n+        // legal and produces both inside this type.\n+        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == config::CrateType::Rlib);\n+        let needs_object_code = self.sess.opts.output_types.should_codegen();\n+        // If we're producing an rlib, then we don't need object code.\n+        // Or, if we're not producing object code, then we don't need it either\n+        // (e.g., if we're a cdylib but emitting just metadata).\n+        if is_rlib || !needs_object_code {\n+            flavor == CrateFlavor::Rmeta\n+        } else {\n+            // we need all flavors (perhaps not true, but what we do for now)\n+            true\n+        }\n+    }\n+\n     // Attempts to extract *one* library from the set `m`. If the set has no\n     // elements, `None` is returned. If the set has more than one element, then\n     // the errors and notes are emitted about the set of libraries.\n@@ -681,12 +703,22 @@ impl<'a> CrateLocator<'a> {\n         let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n \n+        // If we are producing an rlib, and we've already loaded metadata, then\n+        // we should not attempt to discover further crate sources (unless we're\n+        // locating a proc macro; exact logic is in needs_crate_flavor). This means\n+        // that under -Zbinary-dep-depinfo we will not emit a dependency edge on\n+        // the *unused* rlib, and by returning `None` here immediately we\n+        // guarantee that we do indeed not use it.\n+        //\n+        // See also #68149 which provides more detail on why emitting the\n+        // dependency on the rlib is a bad thing.\n+        //\n+        // We currenty do not verify that these other sources are even in sync,\n+        // and this is arguably a bug (see #10786), but because reading metadata\n+        // is quite slow (especially from dylibs) we currently do not read it\n+        // from the other crate sources.\n         if slot.is_some() {\n-            // FIXME(#10786): for an optimization, we only read one of the\n-            //                libraries' metadata sections. In theory we should\n-            //                read both, but reading dylib metadata is quite\n-            //                slow.\n-            if m.is_empty() {\n+            if m.is_empty() || !self.needs_crate_flavor(flavor) {\n                 return None;\n             } else if m.len() == 1 {\n                 return Some(m.into_iter().next().unwrap());"}]}