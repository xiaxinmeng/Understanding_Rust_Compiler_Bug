{"sha": "3342da41135a63ba6d20c3f3e90fb40419164706", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNDJkYTQxMTM1YTYzYmE2ZDIwYzNmM2U5MGZiNDA0MTkxNjQ3MDY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T23:16:27Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:50Z"}, "message": "trans: Don't treat closure types like function types in declare.", "tree": {"sha": "2bf97980ce1a3d05d9f197f2fea0315b696f500a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bf97980ce1a3d05d9f197f2fea0315b696f500a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3342da41135a63ba6d20c3f3e90fb40419164706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3342da41135a63ba6d20c3f3e90fb40419164706", "html_url": "https://github.com/rust-lang/rust/commit/3342da41135a63ba6d20c3f3e90fb40419164706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3342da41135a63ba6d20c3f3e90fb40419164706/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da66431d06b961efd323f25978964df54d44d3c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/da66431d06b961efd323f25978964df54d44d3c4", "html_url": "https://github.com/rust-lang/rust/commit/da66431d06b961efd323f25978964df54d44d3c4"}], "stats": {"total": 165, "additions": 65, "deletions": 100}, "files": [{"sha": "6c99632341fbdf358638afacd7f26fe6738013b5", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=3342da41135a63ba6d20c3f3e90fb40419164706", "patch": "@@ -13,13 +13,11 @@ use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n use middle::ty;\n use middle::infer;\n-use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use rustc_front::hir;\n use trans::abi::Abi;\n-use trans::base;\n use trans::common;\n use trans::context::CrateContext;\n use trans::machine;\n@@ -130,21 +128,12 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                               -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n-    let function_type;\n-    let (fn_sig, abi, env_ty) = match fn_type.sty {\n-        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => (&f.sig, f.abi, None),\n-        ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n-                                                      &ccx.tcx().tables,\n-                                                      ProjectionMode::Any);\n-            function_type = infcx.closure_type(closure_did, substs);\n-            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n-            (&function_type.sig, Abi::RustCall, Some(self_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or function.\")\n+    let f = match fn_type.sty {\n+        ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => f,\n+        _ => unreachable!(\"expected fn type, found {:?}\", fn_type)\n     };\n \n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n     let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n \n     let mut attrs = llvm::AttrBuilder::new();\n@@ -153,30 +142,17 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_type.sty {\n-        ty::TyClosure(..) => {\n-            assert!(abi == Abi::RustCall);\n-\n-            match fn_sig.inputs[0].sty {\n-                ty::TyTuple(ref inputs) => {\n-                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n-                    full_inputs.extend_from_slice(inputs);\n-                    full_inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        },\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) if abi == Abi::RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) if f.abi == Abi::RustCall => {\n+            let first = Some(fn_sig.inputs[0]).into_iter();\n \n             match fn_sig.inputs[1].sty {\n                 ty::TyTuple(ref t_in) => {\n-                    inputs.extend_from_slice(&t_in[..]);\n-                    inputs\n+                    first.chain(t_in.iter().cloned())\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.inputs.clone()\n+        _ => None.into_iter().chain(fn_sig.inputs.iter().cloned())\n     };\n \n     // Index 0 is the return value of the llvm func, so we start at 1\n@@ -228,7 +204,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n         }\n     }\n \n-    for &t in input_tys.iter() {\n+    for t in input_tys {\n         match t.sty {\n             _ if type_of::arg_is_indirect(ccx, t) => {\n                 let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));"}, {"sha": "905ccda198c570c399a7b2ca240286d2003b5f12", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3342da41135a63ba6d20c3f3e90fb40419164706", "patch": "@@ -192,22 +192,6 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       closure_id: DefId,\n-                                       fn_ty: Ty<'tcx>)\n-                                       -> Ty<'tcx> {\n-    let closure_kind = ccx.tcx().closure_kind(closure_id);\n-    match closure_kind {\n-        ty::ClosureKind::Fn => {\n-            ccx.tcx().mk_imm_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n-        }\n-        ty::ClosureKind::FnMut => {\n-            ccx.tcx().mk_mut_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n-        }\n-        ty::ClosureKind::FnOnce => fn_ty,\n-    }\n-}\n-\n pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKind {\n     *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }"}, {"sha": "df8dd1a09b7a377d92217a81df2ffcded0636121", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=3342da41135a63ba6d20c3f3e90fb40419164706", "patch": "@@ -14,7 +14,7 @@ use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::traits::ProjectionMode;\n-use trans::abi::Abi::RustCall;\n+use trans::abi::Abi;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -30,7 +30,7 @@ use trans::monomorphize::{Instance};\n use trans::type_of::*;\n use trans::value::Value;\n use trans::Disr;\n-use middle::ty;\n+use middle::ty::{self, Ty, TyCtxt};\n use session::config::FullDebugInfo;\n \n use syntax::ast;\n@@ -49,7 +49,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Special case for small by-value selfs.\n     let closure_ty = node_id_type(bcx, bcx.fcx.id);\n-    let self_type = self_type_for_closure(bcx.ccx(), closure_def_id, closure_ty);\n+    let self_type = get_self_type(bcx.tcx(), closure_def_id, closure_ty);\n     let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n     let llenv = if kind == ty::ClosureKind::FnOnce &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n@@ -131,6 +131,21 @@ impl<'a> ClosureEnv<'a> {\n     }\n }\n \n+pub fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+                           closure_id: DefId,\n+                           fn_ty: Ty<'tcx>)\n+                           -> Ty<'tcx> {\n+    match tcx.closure_kind(closure_id) {\n+        ty::ClosureKind::Fn => {\n+            tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), fn_ty)\n+        }\n+        ty::ClosureKind::FnMut => {\n+            tcx.mk_mut_ref(tcx.mk_region(ty::ReStatic), fn_ty)\n+        }\n+        ty::ClosureKind::FnOnce => fn_ty,\n+    }\n+}\n+\n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -139,31 +154,47 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                    -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let substs = ccx.tcx().erase_regions(substs);\n-    let mono_id = Instance {\n+    let tcx = ccx.tcx();\n+    let substs = tcx.erase_regions(substs);\n+    let instance = Instance {\n         def: closure_id,\n         params: &substs.func_substs.types\n     };\n \n-    if let Some(&llfn) = ccx.closure_vals().borrow().get(&mono_id) {\n+    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               mono_id, Value(llfn));\n+               instance, Value(llfn));\n         return llfn;\n     }\n \n-    let path = ccx.tcx().def_path(closure_id);\n+    let path = tcx.def_path(closure_id);\n     let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n \n-    let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n+    // Compute the rust-call form of the closure call method.\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let sig = &infcx.closure_type(closure_id, &substs).sig;\n+    let sig = tcx.erase_late_bound_regions(sig);\n+    let sig = infer::normalize_associated_type(tcx, &sig);\n+    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, Box::new(substs));\n+    let function_type = tcx.mk_fn_ptr(ty::BareFnTy {\n+        unsafety: hir::Unsafety::Normal,\n+        abi: Abi::RustCall,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: Some(get_self_type(tcx, closure_id, closure_type))\n+                        .into_iter().chain(sig.inputs).collect(),\n+            output: sig.output,\n+            variadic: false\n+        })\n+    });\n     let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?}: {:?}\",\n-           mono_id, Value(llfn));\n-    ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n+           instance, Value(llfn));\n+    ccx.instances().borrow_mut().insert(instance, llfn);\n \n     llfn\n }\n@@ -347,7 +378,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n-    assert_eq!(abi, RustCall);\n+    assert_eq!(abi, Abi::RustCall);\n     sig.0.inputs[0] = closure_ty;\n     let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: unsafety,"}, {"sha": "7bee48039359b0b5132d448ee086ae8f0eed3b10", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=3342da41135a63ba6d20c3f3e90fb40419164706", "patch": "@@ -22,10 +22,8 @@\n use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n-use middle::traits::ProjectionMode;\n use trans::abi::{Abi, FnType};\n use trans::attributes;\n-use trans::base;\n use trans::context::CrateContext;\n use trans::type_::Type;\n use trans::type_of;\n@@ -94,37 +92,21 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n /// update the declaration and return existing ValueRef instead.\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n-           fn_type);\n-\n-    let function_type; // placeholder so that the memory ownership works out ok\n-    let (sig, abi, env) = match fn_type.sty {\n-        ty::TyFnDef(_, _, f) |\n-        ty::TyFnPtr(f) => {\n-            (&f.sig, f.abi, None)\n-        }\n-        ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n-                                                      &ccx.tcx().tables,\n-                                                      ProjectionMode::Any);\n-            function_type = infcx.closure_type(closure_did, substs);\n-            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n-            debug!(\"declare_rust_fn function_type={:?} self_type={:?}\",\n-                   function_type, self_type);\n-            (&function_type.sig, Abi::RustCall, Some(self_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or fn\")\n-    };\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n \n+    let f = match fn_type.sty {\n+        ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => f,\n+        _ => unreachable!(\"expected fn type for {:?}, found {:?}\", name, fn_type)\n+    };\n \n-    let sig = ccx.tcx().erase_late_bound_regions(sig);\n+    let sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let (cconv, llfty) = if abi == Abi::Rust || abi == Abi::RustCall {\n-        (llvm::CCallConv, type_of::type_of_rust_fn(ccx, env, &sig, abi))\n+    let (cconv, llfty) = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n+        (llvm::CCallConv, type_of::type_of_rust_fn(ccx, &sig, f.abi))\n     } else {\n-        let fty = FnType::new(ccx, abi, &sig, &[]);\n+        let fty = FnType::new(ccx, f.abi, &sig, &[]);\n         (fty.cconv, fty.to_llvm(ccx))\n     };\n \n@@ -137,10 +119,10 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n-    if abi == Abi::Rust || abi == Abi::RustCall {\n+    if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n         attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n     } else {\n-        FnType::new(ccx, abi, &sig, &[]).add_attributes(llfn);\n+        FnType::new(ccx, f.abi, &sig, &[]).add_attributes(llfn);\n     }\n \n     llfn"}, {"sha": "b4f431f09e8c72e11b78fc569c0fc879d1e0ce44", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3342da41135a63ba6d20c3f3e90fb40419164706/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=3342da41135a63ba6d20c3f3e90fb40419164706", "patch": "@@ -88,14 +88,11 @@ pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 maybe_env: Option<Ty<'tcx>>,\n                                  sig: &ty::FnSig<'tcx>,\n                                  abi: Abi)\n                                  -> Type\n {\n-    debug!(\"type_of_rust_fn(sig={:?},abi={:?})\",\n-           sig,\n-           abi);\n+    debug!(\"type_of_rust_fn(sig={:?}, abi={:?})\", sig, abi);\n \n     assert!(!sig.variadic); // rust fns are never variadic\n \n@@ -129,11 +126,6 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::FnDiverging => Type::void(cx)\n     };\n \n-    // Arg 1: Environment\n-    if let Some(env_ty) = maybe_env {\n-        atys.push(type_of_explicit_arg(cx, env_ty));\n-    }\n-\n     // ... then explicit args.\n     for input in inputs {\n         let arg_ty = type_of_explicit_arg(cx, input);\n@@ -384,7 +376,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n         let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n         if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            type_of_rust_fn(cx, None, &sig, f.abi).ptr_to()\n+            type_of_rust_fn(cx, &sig, f.abi).ptr_to()\n         } else {\n             FnType::new(cx, f.abi, &sig, &[]).to_llvm(cx).ptr_to()\n         }"}]}