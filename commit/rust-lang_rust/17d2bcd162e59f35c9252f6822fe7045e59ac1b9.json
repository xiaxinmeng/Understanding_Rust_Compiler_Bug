{"sha": "17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ZDJiY2QxNjJlNTlmMzVjOTI1MmY2ODIyZmU3MDQ1ZTU5YWMxYjk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-09T19:23:27Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-10T12:57:28Z"}, "message": "For box expressions, use NZ drop instead of a free block\n\nThis falls naturally out of making drop elaboration work with `box`\nexpressions, which is probably required for sane MIR borrow-checking.\nThis is a pure refactoring with no intentional functional effects.", "tree": {"sha": "6e838b331ab6ced0364a935d59a119182f67c20c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e838b331ab6ced0364a935d59a119182f67c20c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "html_url": "https://github.com/rust-lang/rust/commit/17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f977baf34ed32c64c4ff185b4ef6ae2c2948afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f977baf34ed32c64c4ff185b4ef6ae2c2948afc", "html_url": "https://github.com/rust-lang/rust/commit/3f977baf34ed32c64c4ff185b4ef6ae2c2948afc"}], "stats": {"total": 241, "additions": 84, "deletions": 157}, "files": [{"sha": "a801804d502a141567a0b78c199d3414c73fa821", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -135,6 +135,11 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n }\n \n+pub enum RvalueInitializationState {\n+    Shallow,\n+    Deep\n+}\n+\n impl<'tcx> Rvalue<'tcx> {\n     pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n         where D: HasLocalDecls<'tcx>\n@@ -206,6 +211,16 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    /// Returns whether this rvalue is deeply initialized (most rvalues) or\n+    /// whether its only shallowly initialized (`Rvalue::Box`).\n+    pub fn initialization_state(&self) -> RvalueInitializationState {\n+        match *self {\n+            Rvalue::NullaryOp(NullOp::Box, _) => RvalueInitializationState::Shallow,\n+            _ => RvalueInitializationState::Deep\n+        }\n+    }\n }\n \n impl<'tcx> Operand<'tcx> {"}, {"sha": "8974c4ec1fbfd126907f5aaaccb5232845e7a606", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -94,19 +94,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n-            ExprKind::Box { value, value_extents } => {\n+            ExprKind::Box { value } => {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty, expr_span);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg.push_assign(block, source_info, &result, box_);\n-                this.in_scope((value_extents, source_info), block, |this| {\n+                if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n-                    this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n-                    // initialize the box contents:\n-                    unpack!(block = this.into(&result.clone().deref(), block, value));\n-                    block.and(Rvalue::Use(Operand::Consume(result)))\n-                })\n+                    this.schedule_drop(expr_span, scope, &result, value.ty);\n+                }\n+                // initialize the box contents:\n+                unpack!(block = this.into(&result.clone().deref(), block, value));\n+                block.and(Rvalue::Use(Operand::Consume(result)))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "a4a89a7f8185a18946f4b70c9a34916bb07ae820", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -89,9 +89,6 @@ should go to.\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region::CodeExtent;\n-use rustc::middle::lang_items;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n@@ -127,21 +124,6 @@ pub struct Scope<'tcx> {\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData<'tcx>>,\n \n-    /// A scope may only have one associated free, because:\n-    ///\n-    /// 1. We require a `free` to only be scheduled in the scope of\n-    ///    `EXPR` in `box EXPR`;\n-    /// 2. It only makes sense to have it translated into the diverge-path.\n-    ///\n-    /// This kind of drop will be run *after* all the regular drops\n-    /// scheduled onto this scope, because drops may have dependencies\n-    /// on the allocated memory.\n-    ///\n-    /// This is expected to go away once `box EXPR` becomes a sugar\n-    /// for placement protocol and gets desugared in some earlier\n-    /// stage.\n-    free: Option<FreeData<'tcx>>,\n-\n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n@@ -170,22 +152,6 @@ enum DropKind {\n     Storage\n }\n \n-#[derive(Debug)]\n-struct FreeData<'tcx> {\n-    /// span where free obligation was incurred\n-    span: Span,\n-\n-    /// Lvalue containing the allocated box.\n-    value: Lvalue<'tcx>,\n-\n-    /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n-    item_ty: Ty<'tcx>,\n-\n-    /// The cached block containing code to run the free. The block will also execute all the drops\n-    /// in the scope.\n-    cached_block: Option<BasicBlock>\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n@@ -224,9 +190,6 @@ impl<'tcx> Scope<'tcx> {\n                 *cached_block = None;\n             }\n         }\n-        if let Some(ref mut freedata) = self.free {\n-            freedata.cached_block = None;\n-        }\n     }\n \n     /// Returns the cached entrypoint for diverging exit from this scope.\n@@ -242,8 +205,6 @@ impl<'tcx> Scope<'tcx> {\n         });\n         if let Some(cached_block) = drops.next() {\n             Some(cached_block.expect(\"drop cache is not filled\"))\n-        } else if let Some(ref data) = self.free {\n-            Some(data.cached_block.expect(\"free cache is not filled\"))\n         } else {\n             None\n         }\n@@ -333,7 +294,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent_span: extent.1.span,\n             needs_cleanup: false,\n             drops: vec![],\n-            free: None,\n             cached_exits: FxHashMap()\n         });\n     }\n@@ -382,7 +342,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         });\n         let len = self.scopes.len();\n         assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n-        let tmp = self.get_unit_temp();\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n@@ -415,13 +374,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // End all regions for scopes out of which we are breaking.\n             self.cfg.push_end_region(block, extent.1, scope.extent);\n-\n-            if let Some(ref free_data) = scope.free {\n-                let next = self.cfg.start_new_block();\n-                let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.source_info(span), free);\n-                block = next;\n-            }\n         }\n         }\n         let scope = &self.scopes[len - scope_count];\n@@ -607,36 +559,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n     }\n \n-    /// Schedule dropping of a not-yet-fully-initialised box.\n-    ///\n-    /// This cleanup will only be translated into unwind branch.\n-    /// The extent should be for the `EXPR` inside `box EXPR`.\n-    /// There may only be one \u201cfree\u201d scheduled in any given scope.\n-    pub fn schedule_box_free(&mut self,\n-                             span: Span,\n-                             extent: CodeExtent,\n-                             value: &Lvalue<'tcx>,\n-                             item_ty: Ty<'tcx>) {\n-        for scope in self.scopes.iter_mut().rev() {\n-            // See the comment in schedule_drop above. The primary difference is that we invalidate\n-            // the unwind blocks unconditionally. That\u2019s because the box free may be considered\n-            // outer-most cleanup within the scope.\n-            scope.invalidate_cache(true);\n-            if scope.extent == extent {\n-                assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n-                scope.needs_cleanup = true;\n-                scope.free = Some(FreeData {\n-                    span: span,\n-                    value: value.clone(),\n-                    item_ty: item_ty,\n-                    cached_block: None\n-                });\n-                return;\n-            }\n-        }\n-        span_bug!(span, \"extent {:?} not in scope to free {:?}\", extent, value);\n-    }\n-\n     // Other\n     // =====\n     /// Creates a path that performs all required cleanup for unwinding.\n@@ -650,7 +572,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         assert!(!self.scopes.is_empty()); // or `any` above would be false\n \n-        let unit_temp = self.get_unit_temp();\n         let Builder { ref mut hir, ref mut cfg, ref mut scopes,\n                       ref mut cached_resume_block, .. } = *self;\n \n@@ -679,7 +600,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         for scope in scopes.iter_mut() {\n             target = build_diverge_scope(\n-                hir.tcx(), cfg, &unit_temp, scope.extent_span, scope, target);\n+                hir.tcx(), cfg, scope.extent_span, scope, target);\n         }\n         Some(target)\n     }\n@@ -805,9 +726,8 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn build_diverge_scope<'a, 'gcx, 'tcx>(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        cfg: &mut CFG<'tcx>,\n-                                       unit_temp: &Lvalue<'tcx>,\n                                        span: Span,\n                                        scope: &mut Scope<'tcx>,\n                                        mut target: BasicBlock)\n@@ -832,19 +752,6 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         scope: visibility_scope\n     };\n \n-    // Next, build up any free.\n-    if let Some(ref mut free_data) = scope.free {\n-        target = if let Some(cached_block) = free_data.cached_block {\n-            cached_block\n-        } else {\n-            let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into, source_info(free_data.span),\n-                          build_free(tcx, unit_temp, free_data, target));\n-            free_data.cached_block = Some(into);\n-            into\n-        };\n-    }\n-\n     // Next, build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n@@ -888,24 +795,3 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     target\n }\n-\n-fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              unit_temp: &Lvalue<'tcx>,\n-                              data: &FreeData<'tcx>,\n-                              target: BasicBlock)\n-                              -> TerminatorKind<'tcx> {\n-    let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(data.item_ty)]);\n-    TerminatorKind::Call {\n-        func: Operand::Constant(box Constant {\n-            span: data.span,\n-            ty: tcx.type_of(free_func).subst(tcx, substs),\n-            literal: Literal::Value {\n-                value: ConstVal::Function(free_func, substs),\n-            }\n-        }),\n-        args: vec![Operand::Consume(data.value.clone())],\n-        destination: Some((unit_temp.clone(), target)),\n-        cleanup: None\n-    }\n-}"}, {"sha": "890fe3c091ab2f166a62c835b8897d1a6d39c272", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -240,7 +240,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n         let lookup_result = move_data.rev_lookup.find(&lvalue);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,\n-                              |moi| callback(moi, DropFlagState::Present));\n+                              |mpi| callback(mpi, DropFlagState::Present));\n     }\n }\n \n@@ -270,7 +270,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n \n         on_all_children_bits(tcx, mir, move_data,\n                              path,\n-                             |moi| callback(moi, DropFlagState::Absent))\n+                             |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n     let block = &mir[loc.block];\n@@ -279,11 +279,21 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             mir::StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscrimant should not exist during borrowck\");\n             }\n-            mir::StatementKind::Assign(ref lvalue, _) => {\n-                debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                 on_lookup_result_bits(tcx, mir, move_data,\n-                                       move_data.rev_lookup.find(lvalue),\n-                                       |moi| callback(moi, DropFlagState::Present))\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        debug!(\"drop_flag_effects: box assignment {:?}\", stmt);\n+                        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(lvalue) {\n+                            callback(mpi, DropFlagState::Present);\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n+                        on_lookup_result_bits(tcx, mir, move_data,\n+                                              move_data.rev_lookup.find(lvalue),\n+                                              |mpi| callback(mpi, DropFlagState::Present))\n+                    }\n+                }\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n@@ -298,7 +308,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                 mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                     on_lookup_result_bits(tcx, mir, move_data,\n                                           move_data.rev_lookup.find(location),\n-                                          |moi| callback(moi, DropFlagState::Present))\n+                                          |mpi| callback(mpi, DropFlagState::Present))\n                 }\n                 _ => {\n                     // other terminators do not contain move-ins"}, {"sha": "d68e64abe4f2ddf0f1ca4693f18d7bce2ff8ef2e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -23,6 +23,7 @@ use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n+use super::move_paths::LookupResult;\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -469,18 +470,30 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n             }\n-            mir::StatementKind::Assign(ref lvalue, _) => {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 // assigning into this `lvalue` kills all\n                 // MoveOuts from it, and *also* all MoveOuts\n                 // for children and associated fragment sets.\n-                on_lookup_result_bits(tcx,\n-                                     mir,\n-                                     move_data,\n-                                     rev_lookup.find(lvalue),\n-                                     |mpi| for moi in &path_map[mpi] {\n-                                         assert!(moi.index() < bits_per_block);\n-                                         sets.kill_set.add(&moi);\n-                                     });\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n+                             for moi in &path_map[mpi] {\n+                                 assert!(moi.index() < bits_per_block);\n+                                 sets.kill_set.add(&moi);\n+                             }\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        on_lookup_result_bits(tcx,\n+                                              mir,\n+                                              move_data,\n+                                              rev_lookup.find(lvalue),\n+                                              |mpi| for moi in &path_map[mpi] {\n+                                                  assert!(moi.index() < bits_per_block);\n+                                                  sets.kill_set.add(&moi);\n+                                              });\n+                    }\n+                }\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |"}, {"sha": "20a61418d85a57731d12d5c947aada26945e2ff3", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -11,6 +11,7 @@\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n+use rustc::mir::tcx::RvalueInitializationState;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n@@ -406,6 +407,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {\n                 self.create_move_path(lval);\n+                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n+                    // Box starts out uninitialized - need to create a separate\n+                    // move-path for the interior so it will be separate from\n+                    // the exterior.\n+                    self.create_move_path(&lval.clone().deref());\n+                }\n                 self.gather_rvalue(loc, rval);\n             }\n             StatementKind::StorageLive(_) |"}, {"sha": "b7fc37675e29c64c42bdaff82e3a708b7c60d37b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -559,7 +559,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: CodeExtent::Misc(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },"}, {"sha": "e46c18b2dcfe44a1a72c698e8036c28b4d8f93db", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -116,7 +116,6 @@ pub enum ExprKind<'tcx> {\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,"}, {"sha": "0b34231b4eec6b0fc84ce5752619e1466f1a3427", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -34,10 +34,9 @@ fn foo(i: i32) {\n //     let _1: D;\n //     let _2: i32;\n //     let _3: &'6_2rce i32;\n-//     let _7: &'6_4rce i32;\n+//     let _6: &'6_4rce i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n-//     let mut _6: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n@@ -51,10 +50,10 @@ fn foo(i: i32) {\n //     }\n //     bb1: {\n //         StorageDead(_5);\n-//         StorageLive(_7);\n-//         _7 = &'6_4rce _2;\n+//         StorageLive(_6);\n+//         _6 = &'6_4rce _2;\n //         _0 = ();\n-//         StorageDead(_7);\n+//         StorageDead(_6);\n //         EndRegion('6_4rce);\n //         StorageDead(_3);\n //         EndRegion('6_2rce);"}, {"sha": "e51bb9350db60520aa52886a4f811606c84ffec5", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(18) d:&'19mce D];\n //     let mut _4: &'19mce D;\n-//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "c55e6d105cbdc3fe9c8d4c5ba83ca1568f172731", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:&'23mce D];\n //     let mut _4: &'23mce D;\n-//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "9c8e3ec08d498956b271f04d2e54ef62e85f3011", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:D];\n //     let mut _4: D;\n-//     let mut _5: ();\n //\n //     bb0: {\n //         StorageLive(_1);\n@@ -77,7 +76,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: i32;\n //     let _2: &'14_0rce D;\n //     let mut _3: i32;\n-//     let mut _4: ();\n //\n //     bb0: {\n //         StorageLive(_2);"}, {"sha": "b4dbec5cd2dd7ec5e159feb418640a8459f54303", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -35,7 +35,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //    let mut _3: ();\n //    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n //    let mut _5: &'6_1rce D;\n-//    let mut _6: ();\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "3a8b5c449c22ad7fe94d8c633be20a6fa24aa10d", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -39,8 +39,7 @@ impl S {\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n-//    let mut _5: ();\n-//    let mut _6: bool;\n+//    let mut _5: bool;\n //\n //    bb0: {\n // END rustc.node4.ElaborateDrops.after.mir\n@@ -50,9 +49,8 @@ impl S {\n //    let mut _2: S;\n //    let mut _3: ();\n //    let mut _4: S;\n-//    let mut _5: ();\n-//    let mut _6: S;\n-//    let mut _7: bool;\n+//    let mut _5: S;\n+//    let mut _6: bool;\n //\n //    bb0: {\n // END rustc.node13.ElaborateDrops.after.mir"}, {"sha": "1aba47af1e9dca30f48f8f877da20e840bff37b0", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17d2bcd162e59f35c9252f6822fe7045e59ac1b9/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=17d2bcd162e59f35c9252f6822fe7045e59ac1b9", "patch": "@@ -161,6 +161,11 @@ fn vec_simple(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n+#[allow(unreachable_code)]\n+fn vec_unreachable(a: &Allocator) {\n+    let _x = vec![a.alloc(), a.alloc(), a.alloc(), return];\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -209,6 +214,7 @@ fn main() {\n \n     run_test(|a| array_simple(a));\n     run_test(|a| vec_simple(a));\n+    run_test(|a| vec_unreachable(a));\n \n     run_test(|a| struct_dynamic_drop(a, false, false, false));\n     run_test(|a| struct_dynamic_drop(a, false, false, true));"}]}