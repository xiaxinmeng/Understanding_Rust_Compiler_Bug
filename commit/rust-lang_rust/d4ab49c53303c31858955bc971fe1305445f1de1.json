{"sha": "d4ab49c53303c31858955bc971fe1305445f1de1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWI0OWM1MzMwM2MzMTg1ODk1NWJjOTcxZmUxMzA1NDQ1ZjFkZTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-14T12:46:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-14T12:46:38Z"}, "message": "Merge #9263\n\n9263: fix: don't use display-related functionality where semantics matters r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "25e390e55550e9b8ee6bd27d8a3a1fbcbc32a321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25e390e55550e9b8ee6bd27d8a3a1fbcbc32a321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ab49c53303c31858955bc971fe1305445f1de1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgx0+uCRBK7hj4Ov3rIwAAYWEIAIcpTGRr+uVmRbUMnFmJSD/O\nBajp7luntNRaDlZMou9FoIiCgsTmzzX1h13lO06jGX6TA4emMpeG0BzFCQ9DJJ7s\nkS+Th47zzh8nmCEyv6rV+IL7UJlItg7JuO3dfM0Zlb1mg36mbsPATOF24wgbs3bv\nNxqyw54VqWq3YAgjTeXkPIoYHsxPzMyeVtlOhfiQzskT2quxuxqXlR1ZljeBxn8y\nQ6Loz5D2M7HzHUMRxoJ3KULaf7/WnjI0ILjxJ1BCi5FElEr6JIaqDDyfLRX/wQr9\nNauxu1tTDk69QwIkMjuRTZfvAo4lOXWkboL1/oLu/FU82ZXDwx4edxerd/2Ror4=\n=Yoo8\n-----END PGP SIGNATURE-----\n", "payload": "tree 25e390e55550e9b8ee6bd27d8a3a1fbcbc32a321\nparent 278ae172df6c1c49e2d8ecf6ef47de4dc73ddc59\nparent e696188672be804889f012e19b1c799cc59adee2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623674798 +0000\ncommitter GitHub <noreply@github.com> 1623674798 +0000\n\nMerge #9263\n\n9263: fix: don't use display-related functionality where semantics matters r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ab49c53303c31858955bc971fe1305445f1de1", "html_url": "https://github.com/rust-lang/rust/commit/d4ab49c53303c31858955bc971fe1305445f1de1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ab49c53303c31858955bc971fe1305445f1de1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "278ae172df6c1c49e2d8ecf6ef47de4dc73ddc59", "url": "https://api.github.com/repos/rust-lang/rust/commits/278ae172df6c1c49e2d8ecf6ef47de4dc73ddc59", "html_url": "https://github.com/rust-lang/rust/commit/278ae172df6c1c49e2d8ecf6ef47de4dc73ddc59"}, {"sha": "e696188672be804889f012e19b1c799cc59adee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e696188672be804889f012e19b1c799cc59adee2", "html_url": "https://github.com/rust-lang/rust/commit/e696188672be804889f012e19b1c799cc59adee2"}], "stats": {"total": 160, "additions": 119, "deletions": 41}, "files": [{"sha": "e1ed6de3525cbf1fb2515db66749f77e3139ee09", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 119, "deletions": 41, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d4ab49c53303c31858955bc971fe1305445f1de1/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ab49c53303c31858955bc971fe1305445f1de1/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=d4ab49c53303c31858955bc971fe1305445f1de1", "patch": "@@ -5,9 +5,9 @@\n use std::fmt::{self, Display};\n \n use either::Either;\n-use hir::{AsAssocItem, InFile, Module, ModuleDef, ModuleSource, Semantics};\n+use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId},\n+    base_db::{AnchoredPathBuf, FileId, FileRange},\n     defs::{Definition, NameClass, NameRefClass},\n     search::FileReference,\n     RootDatabase,\n@@ -20,7 +20,7 @@ use syntax::{\n \n use text_edit::TextEdit;\n \n-use crate::{display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n+use crate::{FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n \n type RenameResult<T> = Result<T, RenameError>;\n #[derive(Debug)]\n@@ -52,26 +52,9 @@ pub(crate) fn prepare_rename(\n     let syntax = source_file.syntax();\n \n     let def = find_definition(&sema, syntax, position)?;\n-    match def {\n-        Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(ModuleDef::BuiltinType(_)) => bail!(\"Cannot rename builtin type\"),\n-        Definition::ModuleDef(ModuleDef::Module(_)) => (),\n-        _ => {\n-            let nav = def\n-                .try_to_nav(sema.db)\n-                .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-            nav.focus_range.ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-        }\n-    };\n-    let name_like = sema\n-        .find_node_at_offset_with_descend(syntax, position.offset)\n+    let frange = def_name_range(&&sema, def)\n         .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-    let node = match &name_like {\n-        ast::NameLike::Name(it) => it.syntax(),\n-        ast::NameLike::NameRef(it) => it.syntax(),\n-        ast::NameLike::Lifetime(it) => it.syntax(),\n-    };\n-    Ok(RangeInfo::new(sema.original_range(node).range, ()))\n+    Ok(RangeInfo::new(frange.range, ()))\n }\n \n // Feature: Rename\n@@ -104,9 +87,11 @@ pub(crate) fn rename_with_semantics(\n \n     let def = find_definition(sema, syntax, position)?;\n     match def {\n-        Definition::ModuleDef(ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n         Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(ModuleDef::BuiltinType(_)) => bail!(\"Cannot rename builtin type\"),\n+        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            bail!(\"Cannot rename builtin type\")\n+        }\n         def => rename_reference(sema, def, new_name),\n     }\n }\n@@ -194,7 +179,7 @@ fn find_definition(\n \n fn rename_mod(\n     sema: &Semantics<RootDatabase>,\n-    module: Module,\n+    module: hir::Module,\n     new_name: &str,\n ) -> RenameResult<SourceChange> {\n     if IdentifierKind::Ident != check_identifier(new_name)? {\n@@ -227,7 +212,7 @@ fn rename_mod(\n             _ => never!(\"Module source node is missing a name\"),\n         }\n     }\n-    let def = Definition::ModuleDef(ModuleDef::Module(module));\n+    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n         (file_id, source_edit_from_references(references, def, new_name))\n@@ -293,21 +278,21 @@ fn rename_reference(\n             .and_then(|it| it.containing_trait_impl(sema.db))\n             .and_then(|it| {\n                 it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n-                    (hir::AssocItem::Function(trait_func), ModuleDef::Function(func))\n+                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n                         if trait_func.name(sema.db) == func.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(ModuleDef::Function(trait_func)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n                     }\n-                    (hir::AssocItem::Const(trait_konst), ModuleDef::Const(konst))\n+                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n                         if trait_konst.name(sema.db) == konst.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(ModuleDef::Const(trait_konst)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n                     }\n                     (\n                         hir::AssocItem::TypeAlias(trait_type_alias),\n-                        ModuleDef::TypeAlias(type_alias),\n+                        hir::ModuleDef::TypeAlias(type_alias),\n                     ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::ModuleDef(ModuleDef::TypeAlias(trait_type_alias)))\n+                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n                     }\n                     _ => None,\n                 })\n@@ -557,12 +542,11 @@ fn source_edit_from_def(\n     def: Definition,\n     new_name: &str,\n ) -> RenameResult<(FileId, TextEdit)> {\n-    let nav =\n-        def.try_to_nav(sema.db).ok_or_else(|| format_err!(\"No references found at position\"))?;\n+    let frange: FileRange = def_name_range(sema, def)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n \n     let mut replacement_text = String::new();\n-    let mut repl_range =\n-        nav.focus_range.ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+    let mut repl_range = frange.range;\n     if let Definition::Local(local) = def {\n         if let Either::Left(pat) = local.source(sema.db).value {\n             if matches!(\n@@ -582,7 +566,101 @@ fn source_edit_from_def(\n         replacement_text.push_str(new_name);\n     }\n     let edit = TextEdit::replace(repl_range, replacement_text);\n-    Ok((nav.file_id, edit))\n+    Ok((frange.file_id, edit))\n+}\n+\n+fn def_name_range(sema: &Semantics<RootDatabase>, def: Definition) -> Option<FileRange> {\n+    // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n+    // and _fall back_ to the entirety of the macro call. Such fall back is\n+    // incorrect for renames. The safe behavior would be to return an error for\n+    // such cases. The correct behavior would be to return an auxiliary list of\n+    // \"can't rename these occurrences in macros\" items, and then show some kind\n+    // of a dialog to the user.\n+\n+    let res = match def {\n+        Definition::Macro(mac) => {\n+            let src = mac.source(sema.db)?;\n+            let name = match &src.value {\n+                Either::Left(it) => it.name()?,\n+                Either::Right(it) => it.name()?,\n+            };\n+            src.with_value(name.syntax()).original_file_range(sema.db)\n+        }\n+        Definition::Field(field) => {\n+            let src = field.source(sema.db)?;\n+\n+            match &src.value {\n+                FieldSource::Named(record_field) => {\n+                    let name = record_field.name()?;\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                FieldSource::Pos(_) => {\n+                    return None;\n+                }\n+            }\n+        }\n+        Definition::ModuleDef(module_def) => match module_def {\n+            hir::ModuleDef::Module(module) => {\n+                let src = module.declaration_source(sema.db)?;\n+                let name = src.value.name()?;\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            hir::ModuleDef::Function(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Adt(adt) => match adt {\n+                hir::Adt::Struct(it) => name_range(it, sema)?,\n+                hir::Adt::Union(it) => name_range(it, sema)?,\n+                hir::Adt::Enum(it) => name_range(it, sema)?,\n+            },\n+            hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Const(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Static(it) => name_range(it, sema)?,\n+            hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n+            hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n+            hir::ModuleDef::BuiltinType(_) => return None,\n+        },\n+        Definition::SelfType(_) => return None,\n+        Definition::Local(local) => {\n+            let src = local.source(sema.db);\n+            let name = match &src.value {\n+                Either::Left(bind_pat) => bind_pat.name()?,\n+                Either::Right(_) => return None,\n+            };\n+            src.with_value(name.syntax()).original_file_range(sema.db)\n+        }\n+        Definition::GenericParam(generic_param) => match generic_param {\n+            hir::GenericParam::TypeParam(type_param) => {\n+                let src = type_param.source(sema.db)?;\n+                let name = match &src.value {\n+                    Either::Left(_) => return None,\n+                    Either::Right(type_param) => type_param.name()?,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            hir::GenericParam::LifetimeParam(lifetime_param) => {\n+                let src = lifetime_param.source(sema.db)?;\n+                let lifetime = src.value.lifetime()?;\n+                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+            }\n+            hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n+        },\n+        Definition::Label(label) => {\n+            let src = label.source(sema.db);\n+            let lifetime = src.value.lifetime()?;\n+            src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+        }\n+    };\n+    return Some(res);\n+\n+    fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n+    where\n+        D: HasSource,\n+        D::Ast: ast::NameOwner,\n+    {\n+        let src = def.source(sema.db)?;\n+        let name = src.value.name()?;\n+        let res = src.with_value(name.syntax()).original_file_range(sema.db);\n+        Some(res)\n+    }\n }\n \n #[cfg(test)]\n@@ -659,7 +737,7 @@ mod tests {\n     fn test_prepare_rename_namelikes() {\n         check_prepare(r\"fn name$0<'lifetime>() {}\", expect![[r#\"3..7: name\"#]]);\n         check_prepare(r\"fn name<'lifetime$0>() {}\", expect![[r#\"8..17: 'lifetime\"#]]);\n-        check_prepare(r\"fn name<'lifetime>() { name$0(); }\", expect![[r#\"23..27: name\"#]]);\n+        check_prepare(r\"fn name<'lifetime>() { name$0(); }\", expect![[r#\"3..7: name\"#]]);\n     }\n \n     #[test]\n@@ -691,7 +769,7 @@ fn baz() {\n     x.0$0 = 5;\n }\n \"#,\n-            expect![[r#\"No identifier available to rename\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n \n@@ -703,7 +781,7 @@ fn foo() {\n     let x: i32$0 = 0;\n }\n \"#,\n-            expect![[r#\"Cannot rename builtin type\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n \n@@ -719,7 +797,7 @@ impl Foo {\n     }\n }\n \"#,\n-            expect![[r#\"Cannot rename `Self`\"#]],\n+            expect![[r#\"No references found at position\"#]],\n         );\n     }\n "}]}