{"sha": "86ff1d4809b978f821f4339a200c9ca0f13e422e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZmYxZDQ4MDliOTc4ZjgyMWY0MzM5YTIwMGM5Y2EwZjEzZTQyMmU=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T21:27:31Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T21:27:31Z"}, "message": "allow `&mut param` when extracting function\n\nRecognise &mut as variable modification.\nThis allows extracting functions with\n`&mut var` with `var` being in outer scope", "tree": {"sha": "bdbbf66610b47f0978cd9e16a943aca2369b386b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdbbf66610b47f0978cd9e16a943aca2369b386b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ff1d4809b978f821f4339a200c9ca0f13e422e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ff1d4809b978f821f4339a200c9ca0f13e422e", "html_url": "https://github.com/rust-lang/rust/commit/86ff1d4809b978f821f4339a200c9ca0f13e422e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ff1d4809b978f821f4339a200c9ca0f13e422e/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f102616aaea2894508f8f078cfb20ceef5411d12", "url": "https://api.github.com/repos/rust-lang/rust/commits/f102616aaea2894508f8f078cfb20ceef5411d12", "html_url": "https://github.com/rust-lang/rust/commit/f102616aaea2894508f8f078cfb20ceef5411d12"}], "stats": {"total": 110, "additions": 107, "deletions": 3}, "files": [{"sha": "a4b23d756234867804f8041cedbfedf8140af73e", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/86ff1d4809b978f821f4339a200c9ca0f13e422e/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ff1d4809b978f821f4339a200c9ca0f13e422e/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=86ff1d4809b978f821f4339a200c9ca0f13e422e", "patch": "@@ -2,7 +2,7 @@ use either::Either;\n use hir::{HirDisplay, Local};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n-    search::{ReferenceAccess, SearchScope},\n+    search::{FileReference, ReferenceAccess, SearchScope},\n };\n use itertools::Itertools;\n use stdx::format_to;\n@@ -15,7 +15,7 @@ use syntax::{\n     },\n     Direction, SyntaxElement,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n-    SyntaxNode, TextRange, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, T,\n };\n use test_utils::mark;\n \n@@ -140,7 +140,18 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 .iter()\n                 .flat_map(|(_, rs)| rs.iter())\n                 .filter(|reference| body.contains_range(reference.range))\n-                .any(|reference| reference.access == Some(ReferenceAccess::Write));\n+                .any(|reference| {\n+                    if reference.access == Some(ReferenceAccess::Write) {\n+                        return true;\n+                    }\n+\n+                    let path = path_at_offset(&body, reference);\n+                    if is_mut_ref_expr(path.as_ref()).unwrap_or(false) {\n+                        return true;\n+                    }\n+\n+                    false\n+                });\n \n             Param { node, has_usages_afterwards, has_mut_inside_body, is_copy: true }\n         })\n@@ -405,6 +416,19 @@ fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> Stri\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+fn path_at_offset(body: &FunctionBody, reference: &FileReference) -> Option<ast::Expr> {\n+    let var = body.token_at_offset(reference.range.start()).right_biased()?;\n+    let path = var.ancestors().find_map(ast::Expr::cast)?;\n+    stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n+    Some(path)\n+}\n+\n+fn is_mut_ref_expr(path: Option<&ast::Expr>) -> Option<bool> {\n+    let path = path?;\n+    let ref_expr = path.syntax().parent().and_then(ast::RefExpr::cast)?;\n+    Some(ref_expr.mut_token().is_some())\n+}\n+\n fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n     let mut rewriter = SyntaxRewriter::default();\n     for param in params {\n@@ -551,6 +575,38 @@ impl FunctionBody {\n         }\n     }\n \n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n+            FunctionBody::Span { elements, .. } => {\n+                stdx::always!(self.text_range().contains(offset));\n+                let mut iter = elements\n+                    .iter()\n+                    .filter(|element| element.text_range().contains_inclusive(offset));\n+                let element1 = iter.next().expect(\"offset does not fall into body\");\n+                let element2 = iter.next();\n+                stdx::always!(iter.next().is_none(), \"> 2 tokens at offset\");\n+                let t1 = match element1 {\n+                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n+                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n+                };\n+                let t2 = element2.map(|e| match e {\n+                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n+                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n+                });\n+\n+                match t2 {\n+                    Some(t2) => match (t1.clone().right_biased(), t2.clone().left_biased()) {\n+                        (Some(e1), Some(e2)) => TokenAtOffset::Between(e1, e2),\n+                        (Some(_), None) => t1,\n+                        (None, _) => t2,\n+                    },\n+                    None => t1,\n+                }\n+            }\n+        }\n+    }\n+\n     fn text_range(&self) -> TextRange {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().text_range(),\n@@ -1403,6 +1459,54 @@ fn foo() {\n \n fn $0fun_name(mut n: i32) {\n     n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_because_of_mut_ref() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0let v = &mut n;\n+    *v += 1;$0\n+    let k = n;\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let k = n;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    let v = n;\n+    *v += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_by_value_because_of_mut_ref() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0let v = &mut n;\n+    *v += 1;$0\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(mut n: i32) {\n+    let v = &mut n;\n+    *v += 1;\n }\",\n         );\n     }"}]}