{"sha": "b7fea94c96769e939ecdc98f368bb6daa330aa0b", "node_id": "C_kwDOAAsO6NoAKGI3ZmVhOTRjOTY3NjllOTM5ZWNkYzk4ZjM2OGJiNmRhYTMzMGFhMGI", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-01-14T02:20:17Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-05-22T00:02:31Z"}, "message": "Generically implement ToBitMaskArray", "tree": {"sha": "a26313a111f1e33e3050db8e66678b6d58447a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26313a111f1e33e3050db8e66678b6d58447a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7fea94c96769e939ecdc98f368bb6daa330aa0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fea94c96769e939ecdc98f368bb6daa330aa0b", "html_url": "https://github.com/rust-lang/rust/commit/b7fea94c96769e939ecdc98f368bb6daa330aa0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7fea94c96769e939ecdc98f368bb6daa330aa0b/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939914e39da859b82e904210db144bd67a41486e", "url": "https://api.github.com/repos/rust-lang/rust/commits/939914e39da859b82e904210db144bd67a41486e", "html_url": "https://github.com/rust-lang/rust/commit/939914e39da859b82e904210db144bd67a41486e"}], "stats": {"total": 144, "additions": 141, "deletions": 3}, "files": [{"sha": "e65548a32873fdab82179bcddf50d275b7ee0cb1", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=b7fea94c96769e939ecdc98f368bb6daa330aa0b", "patch": "@@ -13,7 +13,10 @@\n mod mask_impl;\n \n mod to_bitmask;\n-pub use to_bitmask::ToBitMask;\n+pub use to_bitmask::{ToBitMask, ToBitMaskArray};\n+\n+#[cfg(feature = \"generic_const_exprs\")]\n+pub use to_bitmask::bitmask_len;\n \n use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SimdPartialEq, SupportedLaneCount};\n use core::cmp::Ordering;"}, {"sha": "2e2c0a45c51ea1218fc435738d0ff0caf90badc3", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=b7fea94c96769e939ecdc98f368bb6daa330aa0b", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask, ToBitMaskArray};\n use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n@@ -115,6 +115,24 @@ where\n         unsafe { Self(intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n+    pub fn to_bitmask_array<const N: usize>(self) -> [u8; N] {\n+        assert!(core::mem::size_of::<Self>() == N);\n+\n+        // Safety: converting an integer to an array of bytes of the same size is safe\n+        unsafe { core::mem::transmute_copy(&self.0) }\n+    }\n+\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    pub fn from_bitmask_array<const N: usize>(bitmask: [u8; N]) -> Self {\n+        assert!(core::mem::size_of::<Self>() == N);\n+\n+        // Safety: converting an array of bytes to an integer of the same size is safe\n+        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    }\n+\n     #[inline]\n     pub fn to_bitmask_integer<U>(self) -> U\n     where"}, {"sha": "b1c3b2b88ad915558f69deb4f38d97ef873ae950", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=b7fea94c96769e939ecdc98f368bb6daa330aa0b", "patch": "@@ -2,7 +2,7 @@\n \n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask, ToBitMaskArray};\n \n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n@@ -139,6 +139,72 @@ where\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n+    pub fn to_bitmask_array<const N: usize>(self) -> [u8; N]\n+    where\n+        super::Mask<T, LANES>: ToBitMaskArray,\n+        [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n+    {\n+        assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n+\n+        // Safety: N is the correct bitmask size\n+        //\n+        // The transmute below allows this function to be marked safe, since it will prevent\n+        // monomorphization errors in the case of an incorrect size.\n+        unsafe {\n+            // Compute the bitmask\n+            let bitmask: [u8; <super::Mask<T, LANES> as ToBitMaskArray>::BYTES] =\n+                intrinsics::simd_bitmask(self.0);\n+\n+            // Transmute to the return type, previously asserted to be the same size\n+            let mut bitmask: [u8; N] = core::mem::transmute_copy(&bitmask);\n+\n+            // LLVM assumes bit order should match endianness\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            };\n+\n+            bitmask\n+        }\n+    }\n+\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    pub fn from_bitmask_array<const N: usize>(mut bitmask: [u8; N]) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMaskArray,\n+        [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n+    {\n+        assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n+\n+        // Safety: N is the correct bitmask size\n+        //\n+        // The transmute below allows this function to be marked safe, since it will prevent\n+        // monomorphization errors in the case of an incorrect size.\n+        unsafe {\n+            // LLVM assumes bit order should match endianness\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            }\n+\n+            // Transmute to the bitmask type, previously asserted to be the same size\n+            let bitmask: [u8; <super::Mask<T, LANES> as ToBitMaskArray>::BYTES] =\n+                core::mem::transmute_copy(&bitmask);\n+\n+            // Compute the regular mask\n+            Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n+                bitmask,\n+                Self::splat(true).to_int(),\n+                Self::splat(false).to_int(),\n+            ))\n+        }\n+    }\n+\n     #[inline]\n     pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n     where"}, {"sha": "ee229fc7a445e84f1ee1aed2465234553fa3e1c6", "filename": "crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=b7fea94c96769e939ecdc98f368bb6daa330aa0b", "patch": "@@ -31,6 +31,24 @@ pub unsafe trait ToBitMask: Sealed {\n     fn from_bitmask(bitmask: Self::BitMask) -> Self;\n }\n \n+/// Converts masks to and from byte array bitmasks.\n+///\n+/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB of the first byte.\n+///\n+/// # Safety\n+/// This trait is `unsafe` and sealed, since the `BYTES` value must match the number of lanes in\n+/// the mask.\n+pub unsafe trait ToBitMaskArray: Sealed {\n+    /// The length of the bitmask array.\n+    const BYTES: usize;\n+\n+    /// Converts a mask to a bitmask.\n+    fn to_bitmask_array(self) -> [u8; Self::BYTES];\n+\n+    /// Converts a bitmask to a mask.\n+    fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self;\n+}\n+\n macro_rules! impl_integer_intrinsic {\n     { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n         $(\n@@ -58,3 +76,23 @@ impl_integer_intrinsic! {\n     unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>\n     unsafe impl ToBitMask<BitMask=u64> for Mask<_, 64>\n }\n+\n+/// Returns the minimum numnber of bytes in a bitmask with `lanes` lanes.\n+pub const fn bitmask_len(lanes: usize) -> usize {\n+    (lanes + 7) / 8\n+}\n+\n+unsafe impl<T: MaskElement, const LANES: usize> ToBitMaskArray for Mask<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    const BYTES: usize = bitmask_len(LANES);\n+\n+    fn to_bitmask_array(self) -> [u8; Self::BYTES] {\n+        self.0.to_bitmask_array()\n+    }\n+\n+    fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self {\n+        Mask(mask_impl::Mask::from_bitmask_array(bitmask))\n+    }\n+}"}, {"sha": "6150124b8ca00429e9d14e462e85f3edab9687bb", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fea94c96769e939ecdc98f368bb6daa330aa0b/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=b7fea94c96769e939ecdc98f368bb6daa330aa0b", "patch": "@@ -122,6 +122,19 @@ macro_rules! test_mask_api {\n                 cast_impl::<i64>();\n                 cast_impl::<isize>();\n             }\n+\n+            #[test]\n+            fn roundtrip_bitmask_array_conversion() {\n+                use core_simd::ToBitMaskArray;\n+                let values = [\n+                    true, false, false, true, false, false, true, false,\n+                    true, true, false, false, false, false, false, true,\n+                ];\n+                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let bitmask = mask.to_bitmask_array();\n+                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n+            }\n         }\n     }\n }"}]}