{"sha": "36872e4180331e4a7f00329abe7972488ce216cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ODcyZTQxODAzMzFlNGE3ZjAwMzI5YWJlNzk3MjQ4OGNlMjE2Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T06:00:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T06:00:52Z"}, "message": "auto merge of #9203 : thestinger/rust/range_step, r=huonw", "tree": {"sha": "0712d374de8cf52a7df5e2205f756d2a9015d943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0712d374de8cf52a7df5e2205f756d2a9015d943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36872e4180331e4a7f00329abe7972488ce216cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36872e4180331e4a7f00329abe7972488ce216cf", "html_url": "https://github.com/rust-lang/rust/commit/36872e4180331e4a7f00329abe7972488ce216cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36872e4180331e4a7f00329abe7972488ce216cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccadbd3b7c936dacab69856cc3963aad477c7f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccadbd3b7c936dacab69856cc3963aad477c7f06", "html_url": "https://github.com/rust-lang/rust/commit/ccadbd3b7c936dacab69856cc3963aad477c7f06"}, {"sha": "48f61ecbf93740359b62ad5326e70759e738d9e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/48f61ecbf93740359b62ad5326e70759e738d9e6", "html_url": "https://github.com/rust-lang/rust/commit/48f61ecbf93740359b62ad5326e70759e738d9e6"}], "stats": {"total": 722, "additions": 82, "deletions": 640}, "files": [{"sha": "8e07c7ee1c7cac43a4903a382022ce6d867e4350", "filename": "src/libextra/crypto/md5.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::uint;\n+use std::iter::range_step;\n \n use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};\n use digest::Digest;\n@@ -86,46 +86,42 @@ impl Md5State {\n         read_u32v_le(data, input);\n \n         // round 1\n-        do uint::range_step(0, 16, 4) |i| {\n+        for i in range_step(0u, 16, 4) {\n             a = op_f(a, b, c, d, data[i] + C1[i], 7);\n             d = op_f(d, a, b, c, data[i + 1] + C1[i + 1], 12);\n             c = op_f(c, d, a, b, data[i + 2] + C1[i + 2], 17);\n             b = op_f(b, c, d, a, data[i + 3] + C1[i + 3], 22);\n-            true\n-        };\n+        }\n \n         // round 2\n         let mut t = 1;\n-        do uint::range_step(0, 16, 4) |i| {\n+        for i in range_step(0u, 16, 4) {\n             a = op_g(a, b, c, d, data[t & 0x0f] + C2[i], 5);\n             d = op_g(d, a, b, c, data[(t + 5) & 0x0f] + C2[i + 1], 9);\n             c = op_g(c, d, a, b, data[(t + 10) & 0x0f] + C2[i + 2], 14);\n             b = op_g(b, c, d, a, data[(t + 15) & 0x0f] + C2[i + 3], 20);\n             t += 20;\n-            true\n-        };\n+        }\n \n         // round 3\n         t = 5;\n-        do uint::range_step(0, 16, 4) |i| {\n+        for i in range_step(0u, 16, 4) {\n             a = op_h(a, b, c, d, data[t & 0x0f] + C3[i], 4);\n             d = op_h(d, a, b, c, data[(t + 3) & 0x0f] + C3[i + 1], 11);\n             c = op_h(c, d, a, b, data[(t + 6) & 0x0f] + C3[i + 2], 16);\n             b = op_h(b, c, d, a, data[(t + 9) & 0x0f] + C3[i + 3], 23);\n             t += 12;\n-            true\n-        };\n+        }\n \n         // round 4\n         t = 0;\n-        do uint::range_step(0, 16, 4) |i| {\n+        for i in range_step(0u, 16, 4) {\n             a = op_i(a, b, c, d, data[t & 0x0f] + C4[i], 6);\n             d = op_i(d, a, b, c, data[(t + 7) & 0x0f] + C4[i + 1], 10);\n             c = op_i(c, d, a, b, data[(t + 14) & 0x0f] + C4[i + 2], 15);\n             b = op_i(b, c, d, a, data[(t + 21) & 0x0f] + C4[i + 3], 21);\n             t += 28;\n-            true\n-        };\n+        }\n \n         self.s0 += a;\n         self.s1 += b;"}, {"sha": "10289fb8b976465ebde8557f07746ddd25ff7994", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::uint;\n+use std::iter::range_step;\n \n use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,\n     add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n@@ -111,7 +111,7 @@ impl Engine512State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        do uint::range_step(0, 64, 8) |t| {\n+        for t in range_step(0u, 64, 8) {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -129,10 +129,9 @@ impl Engine512State {\n             sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-            true\n-        };\n+        }\n \n-        do uint::range_step(64, 80, 8) |t| {\n+        for t in range_step(64u, 80, 8) {\n             sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n@@ -141,8 +140,7 @@ impl Engine512State {\n             sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-            true\n-        };\n+        }\n \n         self.H0 += a;\n         self.H1 += b;\n@@ -527,7 +525,7 @@ impl Engine256State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        do uint::range_step(0, 48, 8) |t| {\n+        for t in range_step(0u, 48, 8) {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -545,10 +543,9 @@ impl Engine256State {\n             sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-            true\n-        };\n+        }\n \n-        do uint::range_step(48, 64, 8) |t| {\n+        for t in range_step(48u, 64, 8) {\n             sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n@@ -557,8 +554,7 @@ impl Engine256State {\n             sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n             sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-            true\n-        };\n+        }\n \n         self.H0 += a;\n         self.H1 += b;"}, {"sha": "911d883f88ac98c1f537b6c768ec306706c9a2ce", "filename": "src/libstd/char.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -12,7 +12,7 @@\n \n use cast::transmute;\n use option::{None, Option, Some};\n-use i32;\n+use iter::{Iterator, range_step};\n use str::StrSlice;\n use unicode::{derived_property, general_category, decompose};\n use to_str::ToStr;\n@@ -286,15 +286,14 @@ pub fn escape_unicode(c: char, f: &fn(char)) {\n         (c <= '\\uffff') { f('u'); 4 }\n         _               { f('U'); 8 }\n     );\n-    do i32::range_step(4 * (pad - 1), -1, -4) |offset| {\n+    for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n         unsafe {\n             match ((c as i32) >> offset) & 0xf {\n                 i @ 0 .. 9 => { f(transmute('0' as i32 + i)); }\n                 i => { f(transmute('a' as i32 + (i - 10))); }\n             }\n         }\n-        true\n-    };\n+    }\n }\n \n ///"}, {"sha": "07d2aeac627b87be769bbaf7e2d143993f362b28", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -1790,17 +1790,17 @@ pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> R\n     RangeInclusive{range: range(start, stop), done: false}\n }\n \n-impl<A: Add<A, A> + Ord + Clone> Iterator<A> for RangeInclusive<A> {\n+impl<A: Add<A, A> + Eq + Ord + Clone> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n             Some(x) => Some(x),\n             None => {\n-                if self.done {\n-                    None\n-                } else {\n+                if !self.done && self.range.state == self.range.stop {\n                     self.done = true;\n                     Some(self.range.stop.clone())\n+                } else {\n+                    None\n                 }\n             }\n         }\n@@ -1829,11 +1829,11 @@ impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for RangeInclu\n             let result = self.range.stop.clone();\n             self.range.stop = self.range.stop - self.range.one;\n             Some(result)\n-        } else if self.done {\n-            None\n-        } else {\n+        } else if !self.done && self.range.state == self.range.stop {\n             self.done = true;\n             Some(self.range.stop.clone())\n+        } else {\n+            None\n         }\n     }\n }\n@@ -1857,7 +1857,7 @@ pub fn range_step<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A, step: A\n impl<A: CheckedAdd + Ord + Clone> Iterator<A> for RangeStep<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        if (self.rev && self.state > self.stop) || self.state < self.stop {\n+        if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n             let result = self.state.clone();\n             match self.state.checked_add(&self.step) {\n                 Some(x) => self.state = x,\n@@ -1891,22 +1891,14 @@ pub fn range_step_inclusive<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop:\n impl<A: CheckedAdd + Ord + Clone + Eq> Iterator<A> for RangeStepInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        if !self.done {\n-            if (self.rev && self.state > self.stop) || self.state < self.stop {\n-                let result = self.state.clone();\n-                match self.state.checked_add(&self.step) {\n-                    Some(x) => self.state = x,\n-                    None => self.done = true\n-                }\n-                Some(result)\n-            } else {\n-                if self.state == self.stop {\n-                    self.done = true;\n-                    Some(self.state.clone())\n-                } else {\n-                    None\n-                }\n+        if !self.done && ((self.rev && self.state >= self.stop) ||\n+                          (!self.rev && self.state <= self.stop)) {\n+            let result = self.state.clone();\n+            match self.state.checked_add(&self.step) {\n+                Some(x) => self.state = x,\n+                None => self.done = true\n             }\n+            Some(result)\n         } else {\n             None\n         }\n@@ -2716,24 +2708,44 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_range() {\n+        assert_eq!(range(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4]);\n+        assert_eq!(range(0i, 5).invert().collect::<~[int]>(), ~[4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).collect::<~[int]>(), ~[]);\n+        assert_eq!(range(200, -5).invert().collect::<~[int]>(), ~[]);\n+        assert_eq!(range(200, 200).collect::<~[int]>(), ~[]);\n+        assert_eq!(range(200, 200).invert().collect::<~[int]>(), ~[]);\n+    }\n+\n     #[test]\n     fn test_range_inclusive() {\n         assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4, 5]);\n         assert_eq!(range_inclusive(0i, 5).invert().collect::<~[int]>(), ~[5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), ~[]);\n+        assert_eq!(range_inclusive(200, -5).invert().collect::<~[int]>(), ~[]);\n+        assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), ~[200]);\n+        assert_eq!(range_inclusive(200, 200).invert().collect::<~[int]>(), ~[200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n         assert_eq!(range_step(0i, 20, 5).collect::<~[int]>(), ~[0, 5, 10, 15]);\n         assert_eq!(range_step(20i, 0, -5).collect::<~[int]>(), ~[20, 15, 10, 5]);\n+        assert_eq!(range_step(20i, 0, -6).collect::<~[int]>(), ~[20, 14, 8, 2]);\n         assert_eq!(range_step(200u8, 255, 50).collect::<~[u8]>(), ~[200u8, 250]);\n+        assert_eq!(range_step(200, -5, 1).collect::<~[int]>(), ~[]);\n+        assert_eq!(range_step(200, 200, 1).collect::<~[int]>(), ~[]);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n         assert_eq!(range_step_inclusive(0i, 20, 5).collect::<~[int]>(), ~[0, 5, 10, 15, 20]);\n         assert_eq!(range_step_inclusive(20i, 0, -5).collect::<~[int]>(), ~[20, 15, 10, 5, 0]);\n+        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<~[int]>(), ~[20, 14, 8, 2]);\n         assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<~[u8]>(), ~[200u8, 250]);\n+        assert_eq!(range_step_inclusive(200, -5, 1).collect::<~[int]>(), ~[]);\n+        assert_eq!(range_step_inclusive(200, 200, 1).collect::<~[int]>(), ~[200]);\n     }\n \n     #[test]"}, {"sha": "39f32c5ff426eab0055a252a870edc46050efca6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -41,101 +41,6 @@ impl CheckedDiv for $T {\n     }\n }\n \n-enum Range { Closed, HalfOpen }\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n-/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n-///\n-/// If no such nonnegative integer `n` exists, then the iteration range\n-/// is empty.\n-///\n-fn range_step_core(start: $T, stop: $T, step: $T, r: Range, it: &fn($T) -> bool) -> bool {\n-    let mut i = start;\n-    if step == 0 {\n-        fail!(~\"range_step called with step == 0\");\n-    } else if step == (1 as $T) { // elide bounds check to tighten loop\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // no need for overflow check;\n-            // cannot have i + 1 > max_value because i < stop <= max_value\n-            i += (1 as $T);\n-        }\n-    } else if step == (-1 as $T) { // elide bounds check to tighten loop\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // no need for underflow check;\n-            // cannot have i - 1 < min_value because i > stop >= min_value\n-            i -= (1 as $T);\n-        }\n-    } else if step > 0 { // ascending\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // avoiding overflow. break if i + step > max_value\n-            if i > max_value - step { return true; }\n-            i += step;\n-        }\n-    } else { // descending\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // avoiding underflow. break if i + step < min_value\n-            if i < min_value - step { return true; }\n-            i += step;\n-        }\n-    }\n-    match r {\n-        HalfOpen => return true,\n-        Closed => return (i != stop || it(i))\n-    }\n-}\n-\n-#[inline]\n-///\n-/// Iterate through the range [`start`..`stop`) with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// * `x_i == start + step*i`, and\n-/// * `n` is the greatest nonnegative integer such that `x_n < stop`\n-///\n-/// (If no such `n` exists, then the iteration range is empty.)\n-///\n-/// # Arguments\n-///\n-/// * `start` - lower bound, inclusive\n-/// * `stop` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~\n-/// let mut sum = 0;\n-/// for int::range(1, 5) |i| {\n-///     sum += i;\n-/// }\n-/// assert!(sum == 10);\n-/// ~~~\n-///\n-pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, stop, step, HalfOpen, it)\n-}\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n-///\n-/// (If no such nonnegative integer `n` exists, then the iteration\n-///  range is empty.)\n-///\n-pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, last, step, Closed, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -878,56 +783,6 @@ mod tests {\n         assert!(i64::from_str(\"-9223372036854775809\").is_none());\n     }\n \n-    #[test]\n-    fn test_ranges() {\n-        let mut l = ~[];\n-\n-        do range_step(20,26,2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(36,30,-2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 2, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 3, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 2, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 3, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        assert_eq!(l, ~[20,22,24,\n-                        36,34,32,\n-                        max_value-2,\n-                        max_value-3,max_value-1,\n-                        min_value+2,\n-                        min_value+3,min_value+1]);\n-\n-        // None of the `fail`s should execute.\n-        do range_step(10,0,1) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n-        do range_step(0,10,-1) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step() {\n-        do range_step(0,10,0) |_i| { true };\n-    }\n-\n     #[test]\n     fn test_signed_checked_div() {\n         assert_eq!(10i.checked_div(&2), Some(5));"}, {"sha": "4c64efb9114aa65d35dfbdb6d77d3bf51bc5353c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -42,101 +42,6 @@ impl CheckedDiv for $T {\n     }\n }\n \n-enum Range { Closed, HalfOpen }\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n-/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n-///\n-/// If no such nonnegative integer `n` exists, then the iteration range\n-/// is empty.\n-///\n-fn range_step_core(start: $T, stop: $T, step: $T_SIGNED, r: Range, it: &fn($T) -> bool) -> bool {\n-    let mut i = start;\n-    if step == 0 {\n-        fail!(\"range_step called with step == 0\");\n-    } else if step == (1 as $T_SIGNED) { // elide bounds check to tighten loop\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // no need for overflow check;\n-            // cannot have i + 1 > max_value because i < stop <= max_value\n-            i += (1 as $T);\n-        }\n-    } else if step == (-1 as $T_SIGNED) { // elide bounds check to tighten loop\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // no need for underflow check;\n-            // cannot have i - 1 < min_value because i > stop >= min_value\n-            i -= (1 as $T);\n-        }\n-    } else if step > 0 { // ascending\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // avoiding overflow. break if i + step > max_value\n-            if i > max_value - (step as $T) { return true; }\n-            i += step as $T;\n-        }\n-    } else { // descending\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // avoiding underflow. break if i + step < min_value\n-            if i < min_value + ((-step) as $T) { return true; }\n-            i -= -step as $T;\n-        }\n-    }\n-    match r {\n-        HalfOpen => return true,\n-        Closed => return (i != stop || it(i))\n-    }\n-}\n-\n-#[inline]\n-///\n-/// Iterate through the range [`start`..`stop`) with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// - `x_i == start + step*i`, and\n-/// - `n` is the greatest nonnegative integer such that `x_n < stop`\n-///\n-/// (If no such `n` exists, then the iteration range is empty.)\n-///\n-/// # Arguments\n-///\n-/// * `start` - lower bound, inclusive\n-/// * `stop` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~ {.rust}\n-/// let nums = [1,2,3,4,5,6,7];\n-///\n-/// for uint::range_step(0, nums.len() - 1, 2) |i| {\n-///     printfln!(\"%d & %d\", nums[i], nums[i+1]);\n-/// }\n-/// ~~~\n-///\n-pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, stop, step, HalfOpen, it)\n-}\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n-///\n-/// (If no such nonnegative integer `n` exists, then the iteration\n-///  range is empty.)\n-///\n-pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, last, step, Closed, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -653,62 +558,6 @@ mod tests {\n         100u.to_str_radix(37u);\n     }\n \n-    #[test]\n-    pub fn test_ranges() {\n-        let mut l = ~[];\n-\n-        do range_step(20,26,2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(36,30,-2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 2, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 3, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 2, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 3, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-\n-        assert_eq!(l, ~[20,22,24,\n-                        36,34,32,\n-                        max_value-2,\n-                        max_value-3,max_value-1,\n-                        min_value+2,\n-                        min_value+3,min_value+1]);\n-\n-        // None of the `fail`s should execute.\n-        do range_step(10,0,1) |_i| {\n-            fail!(\"unreachable\");\n-        };\n-        do range_step(0,1,-10) |_i| {\n-            fail!(\"unreachable\");\n-        };\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step_up() {\n-        do range_step(0,10,0) |_i| { true };\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step_down() {\n-        do range_step(0,-10,0) |_i| { true };\n-    }\n-\n     #[test]\n     fn test_unsigned_checked_div() {\n         assert_eq!(10u.checked_div(&2), Some(5));"}, {"sha": "5269eca888af8c31c9ebf9cae452724a441a8f19", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -1895,8 +1895,8 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        oldhome.iter().advance(|s| { setenv(\"HOME\", *s); true });\n-        olduserprofile.iter().advance(|s| { setenv(\"USERPROFILE\", *s); true });\n+        for s in oldhome.iter() { setenv(\"HOME\", *s) }\n+        for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n     }\n \n     #[test]"}, {"sha": "1330096ee36a6f59fa475f0cb1a4ba57e0cc1b82", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -48,7 +48,7 @@ use clone::Clone;\n use cmp;\n use container::Container;\n use int;\n-use iter::{Iterator, range};\n+use iter::{Iterator, range, range_step};\n use local_data;\n use num;\n use prelude::*;\n@@ -748,7 +748,7 @@ impl IsaacRng {\n         if use_rsl {\n             macro_rules! memloop (\n                 ($arr:expr) => {{\n-                    do u32::range_step(0, RAND_SIZE, 8) |i| {\n+                    for i in range_step(0u32, RAND_SIZE, 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n                         c+=$arr[i+2]; d+=$arr[i+3];\n                         e+=$arr[i+4]; f+=$arr[i+5];\n@@ -758,22 +758,20 @@ impl IsaacRng {\n                         self.mem[i+2]=c; self.mem[i+3]=d;\n                         self.mem[i+4]=e; self.mem[i+5]=f;\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n-                        true\n-                    };\n+                    }\n                 }}\n             );\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            do u32::range_step(0, RAND_SIZE, 8) |i| {\n+            for i in range_step(0u32, RAND_SIZE, 8) {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n                 self.mem[i+4]=e; self.mem[i+5]=f;\n                 self.mem[i+6]=g; self.mem[i+7]=h;\n-                true\n-            };\n+            }\n         }\n \n         self.isaac();\n@@ -794,7 +792,7 @@ impl IsaacRng {\n         });\n         macro_rules! rngstep(\n             ($j:expr, $shift:expr) => {{\n-                let base = base + $j;\n+                let base = $j;\n                 let mix = if $shift < 0 {\n                     a >> -$shift as uint\n                 } else {\n@@ -813,13 +811,12 @@ impl IsaacRng {\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n-            do uint::range_step(0, MIDPOINT, 4) |base| {\n-                rngstep!(0, 13);\n-                rngstep!(1, -6);\n-                rngstep!(2, 2);\n-                rngstep!(3, -16);\n-                true\n-            };\n+            for i in range_step(0u, MIDPOINT, 4) {\n+                rngstep!(i + 0, 13);\n+                rngstep!(i + 1, -6);\n+                rngstep!(i + 2, 2);\n+                rngstep!(i + 3, -16);\n+            }\n         }\n \n         self.a = a;"}, {"sha": "88a953a1601e92191fb9e251bd44c7900c4147b6", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36872e4180331e4a7f00329abe7972488ce216cf/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=36872e4180331e4a7f00329abe7972488ce216cf", "patch": "@@ -520,6 +520,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n mod test_map {\n     use super::*;\n     use prelude::*;\n+    use iter::range_step;\n     use uint;\n \n     #[test]\n@@ -538,41 +539,37 @@ mod test_map {\n     #[test]\n     fn test_step() {\n         let mut trie = TrieMap::new();\n-        let n = 300;\n+        let n = 300u;\n \n-        do uint::range_step(1, n, 2) |x| {\n+        for x in range_step(1u, n, 2) {\n             assert!(trie.insert(x, x + 1));\n             assert!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n-            true\n-        };\n+        }\n \n-        do uint::range_step(0, n, 2) |x| {\n+        for x in range_step(0u, n, 2) {\n             assert!(!trie.contains_key(&x));\n             assert!(trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n-            true\n-        };\n+        }\n \n         for x in range(0u, n) {\n             assert!(trie.contains_key(&x));\n             assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n-        do uint::range_step(1, n, 2) |x| {\n+        for x in range_step(1u, n, 2) {\n             assert!(trie.remove(&x));\n             assert!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n-            true\n-        };\n+        }\n \n-        do uint::range_step(0, n, 2) |x| {\n+        for x in range_step(0u, n, 2) {\n             assert!(trie.contains_key(&x));\n             assert!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n-            true\n-        };\n+        }\n     }\n \n     #[test]\n@@ -715,11 +712,10 @@ mod test_map {\n         let value = 42u;\n \n         let mut map : TrieMap<uint> = TrieMap::new();\n-        do uint::range_step(0u, last, step as int) |x| {\n+        for x in range_step(0u, last, step) {\n             assert!(x % step == 0);\n             map.insert(x, value);\n-            true\n-        };\n+        }\n \n         for i in range(0u, last - step) {\n             let mut lb = map.lower_bound_iter(i);"}, {"sha": "ea7d4a651f75d181b88bc80fa85fa9f771e9768d", "filename": "src/test/run-pass/num-range-rev.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ccadbd3b7c936dacab69856cc3963aad477c7f06/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccadbd3b7c936dacab69856cc3963aad477c7f06/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=ccadbd3b7c936dacab69856cc3963aad477c7f06", "patch": "@@ -1,126 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::int;\n-use std::uint;\n-\n-fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n-    range(lo, hi).advance(it)\n-}\n-\n-fn int_range(lo: int,  hi: int, it: &fn(int) -> bool) -> bool {\n-    range(lo, hi).advance(it)\n-}\n-\n-fn uint_range_rev(hi: uint, lo: uint, it: &fn(uint) -> bool) -> bool {\n-    range(lo, hi).invert().advance(it)\n-}\n-\n-fn int_range_rev(hi: int,  lo: int, it: &fn(int) -> bool) -> bool {\n-    range(lo, hi).invert().advance(it)\n-}\n-\n-fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n-    int::range_step(a, b, step, it)\n-}\n-\n-fn uint_range_step(a: uint, b: uint, step: int, it: &fn(uint) -> bool) -> bool {\n-    uint::range_step(a, b, step, it)\n-}\n-\n-\n-pub fn main() {\n-    // int and uint have same result for\n-    //   Sum{100 > i >= 2} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n-    let mut sum = 0u;\n-    do uint_range_rev(100, 2) |i| {\n-        sum += i;\n-        true\n-    };\n-    assert_eq!(sum, 4949);\n-\n-    let mut sum = 0i;\n-    do int_range_rev(100, 2) |i| {\n-        sum += i;\n-        true\n-    };\n-    assert_eq!(sum, 4949);\n-\n-\n-    // elements are visited in correct order\n-    let primes = [2,3,5,7,11];\n-    let mut prod = 1i;\n-    do uint_range_rev(5, 0) |i| {\n-        printfln!(\"uint 4 downto 0: %u\", i);\n-        prod *= int::pow(primes[i], i);\n-        true\n-    };\n-    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n-    let mut prod = 1i;\n-    do int_range_rev(5, 0) |i| {\n-        printfln!(\"int 4 downto 0: %d\", i);\n-        prod *= int::pow(primes[i], i as uint);\n-        true\n-    };\n-    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n-\n-\n-    // range and range_rev are symmetric.\n-    let mut sum_up = 0u;\n-    do uint_range(10, 30) |i| {\n-        sum_up += i;\n-        true\n-    };\n-    let mut sum_down = 0u;\n-    do uint_range_rev(30, 10) |i| {\n-        sum_down += i;\n-        true\n-    };\n-    assert_eq!(sum_up, sum_down);\n-\n-    let mut sum_up = 0;\n-    do int_range(-20, 10) |i| {\n-        sum_up += i;\n-        true\n-    };\n-    let mut sum_down = 0;\n-    do int_range_rev(10, -20) |i| {\n-        sum_down += i;\n-        true\n-    };\n-    assert_eq!(sum_up, sum_down);\n-\n-\n-    // empty ranges\n-    do int_range_rev(10, 10) |_| {\n-        fail!(\"range should be empty when start == stop\");\n-        true\n-    };\n-\n-    do uint_range_rev(0, 1) |_| {\n-        fail!(\"range should be empty when start-1 underflows\");\n-        true\n-    };\n-\n-    // range iterations do not wrap/underflow\n-    let mut uflo_loop_visited = ~[];\n-    do int_range_step(int::min_value+15, int::min_value, -4) |x| {\n-        uflo_loop_visited.push(x - int::min_value);\n-        true\n-    };\n-    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n-\n-    let mut uflo_loop_visited = ~[];\n-    do uint_range_step(uint::min_value+15, uint::min_value, -4) |x| {\n-        uflo_loop_visited.push(x - uint::min_value);\n-        true\n-    };\n-    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n-}"}, {"sha": "7376edef8a8f6c9c2f5637519cf3a016c6971e7b", "filename": "src/test/run-pass/num-range.rs", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ccadbd3b7c936dacab69856cc3963aad477c7f06/src%2Ftest%2Frun-pass%2Fnum-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccadbd3b7c936dacab69856cc3963aad477c7f06/src%2Ftest%2Frun-pass%2Fnum-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range.rs?ref=ccadbd3b7c936dacab69856cc3963aad477c7f06", "patch": "@@ -1,132 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::int;\n-use std::uint;\n-\n-fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n-    range(lo, hi).advance(it)\n-}\n-\n-fn int_range(lo: int, hi: int, it: &fn(int) -> bool) -> bool {\n-    range(lo, hi).advance(it)\n-}\n-\n-fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n-    int::range_step(a, b, step, it)\n-}\n-\n-fn uint_range_step(a: uint, b: uint, s: int, it: &fn(uint) -> bool) -> bool {\n-    uint::range_step(a, b, s, it)\n-}\n-\n-pub fn main() {\n-    println(\"num-range start\");\n-    // int and uint have same result for\n-    //   Sum{2 <= i < 100} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n-    let mut sum = 0u;\n-    do uint_range(2, 100) |i| {\n-        sum += i;\n-        true\n-    };\n-    assert_eq!(sum, 4949);\n-\n-    let mut sum = 0i;\n-    do int_range(2, 100) |i| {\n-        sum += i;\n-        true\n-    };\n-    assert_eq!(sum, 4949);\n-\n-\n-    // elements are visited in correct order\n-    let primes = [2,3,5,7];\n-    let mut prod = 1i;\n-    do uint_range(0, 4) |i| {\n-        prod *= int::pow(primes[i], i);\n-        true\n-    };\n-    assert_eq!(prod, 1*3*5*5*7*7*7);\n-    let mut prod = 1i;\n-    do int_range(0, 4) |i| {\n-        prod *= int::pow(primes[i], i as uint);\n-        true\n-    };\n-    assert_eq!(prod, 1*3*5*5*7*7*7);\n-\n-\n-    // empty ranges\n-    do int_range(10, 10) |_| {\n-        fail!(\"range should be empty when start == stop\");\n-        true\n-    };\n-\n-    do uint_range(10, 10) |_| {\n-        fail!(\"range should be empty when start == stop\");\n-        true\n-    };\n-\n-\n-    // range iterations do not wrap/overflow\n-    let mut oflo_loop_visited = ~[];\n-    do uint_range_step(uint::max_value-15, uint::max_value, 4) |x| {\n-        oflo_loop_visited.push(uint::max_value - x);\n-        true\n-    };\n-    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n-\n-    let mut oflo_loop_visited = ~[];\n-    do int_range_step(int::max_value-15, int::max_value, 4) |x| {\n-        oflo_loop_visited.push(int::max_value - x);\n-        true\n-    };\n-    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n-\n-\n-    // range_step never passes nor visits the stop element\n-    do int_range_step(0, 21, 3) |x| {\n-        assert!(x < 21);\n-        true\n-    };\n-\n-    // range_step_inclusive will never pass stop element, and may skip it.\n-    let mut saw21 = false;\n-    do uint::range_step_inclusive(0, 21, 4) |x| {\n-        assert!(x <= 21);\n-        if x == 21 { saw21 = true; }\n-        true\n-    };\n-    assert!(!saw21);\n-    let mut saw21 = false;\n-    do int::range_step_inclusive(0, 21, 4) |x| {\n-        assert!(x <= 21);\n-        if x == 21 { saw21 = true; }\n-        true\n-    };\n-    assert!(!saw21);\n-\n-    // range_step_inclusive will never pass stop element, but may visit it.\n-    let mut saw21 = false;\n-    do uint::range_step_inclusive(0, 21, 3) |x| {\n-        assert!(x <= 21);\n-        printfln!(\"saw: %u\", x);\n-        if x == 21 { saw21 = true; }\n-        true\n-    };\n-    assert!(saw21);\n-    let mut saw21 = false;\n-    do int::range_step_inclusive(0, 21, 3) |x| {\n-        assert!(x <= 21);\n-        if x == 21 { saw21 = true; }\n-        true\n-    };\n-    assert!(saw21);\n-\n-}"}]}