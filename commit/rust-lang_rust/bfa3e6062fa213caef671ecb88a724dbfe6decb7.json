{"sha": "bfa3e6062fa213caef671ecb88a724dbfe6decb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYTNlNjA2MmZhMjEzY2FlZjY3MWVjYjg4YTcyNGRiZmU2ZGVjYjc=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2014-02-14T19:03:39Z"}, "committer": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2014-02-15T18:12:32Z"}, "message": "Clean up the Perlin noise benchmark", "tree": {"sha": "902891f0ca4095277d13829782583761ad623acb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/902891f0ca4095277d13829782583761ad623acb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa3e6062fa213caef671ecb88a724dbfe6decb7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa3e6062fa213caef671ecb88a724dbfe6decb7", "html_url": "https://github.com/rust-lang/rust/commit/bfa3e6062fa213caef671ecb88a724dbfe6decb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa3e6062fa213caef671ecb88a724dbfe6decb7/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92c5738aae54a15717005e84499a522d173a4a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/92c5738aae54a15717005e84499a522d173a4a09", "html_url": "https://github.com/rust-lang/rust/commit/92c5738aae54a15717005e84499a522d173a4a09"}], "stats": {"total": 114, "additions": 49, "deletions": 65}, "files": [{"sha": "42918ae5aa006f6c9cf44d516f320250492301c8", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 49, "deletions": 65, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/bfa3e6062fa213caef671ecb88a724dbfe6decb7/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa3e6062fa213caef671ecb88a724dbfe6decb7/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=bfa3e6062fa213caef671ecb88a724dbfe6decb7", "patch": "@@ -8,128 +8,112 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Perlin noise benchmark from https://gist.github.com/1170424\n+// Multi-language Perlin noise benchmark.\n+// See https://github.com/nsf/pnoise for timings and alternative implementations.\n \n-use std::f64;\n-use std::rand::Rng;\n-use std::rand;\n+use std::f32::consts::PI;\n+use std::rand::{Rng, StdRng};\n \n struct Vec2 {\n     x: f32,\n     y: f32,\n }\n \n-#[inline(always)]\n fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n \n-#[inline(always)]\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n-fn random_gradient<R:Rng>(r: &mut R) -> Vec2 {\n-    let v = 2.0 * f64::consts::PI * r.gen();\n-    Vec2 {\n-        x: v.cos() as f32,\n-        y: v.sin() as f32,\n-    }\n+fn random_gradient<R: Rng>(r: &mut R) -> Vec2 {\n+    let v = PI * 2.0 * r.gen();\n+    Vec2 { x: v.cos(), y: v.sin() }\n }\n \n fn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n-    let sp = Vec2 {x: p.x - orig.x, y: p.y - orig.y};\n-    grad.x * sp.x + grad.y * sp.y\n+    (p.x - orig.x) * grad.x + (p.y - orig.y) * grad.y\n }\n \n struct Noise2DContext {\n     rgradients: [Vec2, ..256],\n-    permutations: [int, ..256],\n+    permutations: [i32, ..256],\n }\n \n impl Noise2DContext {\n-    pub fn new() -> Noise2DContext {\n-        let mut r = rand::rng();\n-        let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n-        for i in range(0, 256) {\n-            rgradients[i] = random_gradient(&mut r);\n-        }\n-        let mut permutations = [ 0, ..256 ];\n-        for i in range(0, 256) {\n-            permutations[i] = i;\n+    fn new() -> Noise2DContext {\n+        let mut rng = StdRng::new();\n+\n+        let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }, ..256];\n+        for x in rgradients.mut_iter() {\n+            *x = random_gradient(&mut rng);\n         }\n-        r.shuffle_mut(permutations);\n \n-        Noise2DContext {\n-            rgradients: rgradients,\n-            permutations: permutations,\n+        let mut permutations = [0i32, ..256];\n+        for (i, x) in permutations.mut_iter().enumerate() {\n+            *x = i as i32;\n         }\n+        rng.shuffle_mut(permutations);\n+\n+        Noise2DContext { rgradients: rgradients, permutations: permutations }\n     }\n \n-    #[inline(always)]\n-    pub fn get_gradient(&self, x: int, y: int) -> Vec2 {\n+    fn get_gradient(&self, x: i32, y: i32) -> Vec2 {\n         let idx = self.permutations[x & 255] + self.permutations[y & 255];\n         self.rgradients[idx & 255]\n     }\n \n-    #[inline]\n-    pub fn get_gradients(&self,\n-                         gradients: &mut [Vec2, ..4],\n-                         origins: &mut [Vec2, ..4],\n-                         x: f32,\n-                         y: f32) {\n+    fn get_gradients(&self, x: f32, y: f32) -> ([Vec2, ..4], [Vec2, ..4]) {\n         let x0f = x.floor();\n         let y0f = y.floor();\n-        let x0 = x0f as int;\n-        let y0 = y0f as int;\n+        let x1f = x0f + 1.0;\n+        let y1f = y0f + 1.0;\n+\n+        let x0 = x0f as i32;\n+        let y0 = y0f as i32;\n         let x1 = x0 + 1;\n         let y1 = y0 + 1;\n \n-        gradients[0] = self.get_gradient(x0, y0);\n-        gradients[1] = self.get_gradient(x1, y0);\n-        gradients[2] = self.get_gradient(x0, y1);\n-        gradients[3] = self.get_gradient(x1, y1);\n-\n-        origins[0] = Vec2 {x: x0f + 0.0, y: y0f + 0.0};\n-        origins[1] = Vec2 {x: x0f + 1.0, y: y0f + 0.0};\n-        origins[2] = Vec2 {x: x0f + 0.0, y: y0f + 1.0};\n-        origins[3] = Vec2 {x: x0f + 1.0, y: y0f + 1.0};\n+        ([self.get_gradient(x0, y0), self.get_gradient(x1, y0),\n+          self.get_gradient(x0, y1), self.get_gradient(x1, y1)],\n+         [Vec2 { x: x0f, y: y0f }, Vec2 { x: x1f, y: y0f },\n+          Vec2 { x: x0f, y: y1f }, Vec2 { x: x1f, y: y1f }])\n     }\n \n-    #[inline]\n-    pub fn get(&self, x: f32, y: f32) -> f32 {\n+    fn get(&self, x: f32, y: f32) -> f32 {\n         let p = Vec2 {x: x, y: y};\n-        let mut gradients = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];\n-        let mut origins = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];\n-        self.get_gradients(&mut gradients, &mut origins, x, y);\n+        let (gradients, origins) = self.get_gradients(x, y);\n+\n         let v0 = gradient(origins[0], gradients[0], p);\n         let v1 = gradient(origins[1], gradients[1], p);\n         let v2 = gradient(origins[2], gradients[2], p);\n         let v3 = gradient(origins[3], gradients[3], p);\n+\n         let fx = smooth(x - origins[0].x);\n         let vx0 = lerp(v0, v1, fx);\n         let vx1 = lerp(v2, v3, fx);\n         let fy = smooth(y - origins[0].y);\n+\n         lerp(vx0, vx1, fy)\n     }\n }\n \n fn main() {\n-    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n+    let symbols = [' ', '\u2591', '\u2592', '\u2593', '\u2588', '\u2588'];\n     let mut pixels = [0f32, ..256*256];\n-    let n2d = ~Noise2DContext::new();\n-    for _ in range(0, 100u) {\n+    let n2d = Noise2DContext::new();\n+\n+    for _ in range(0, 100) {\n         for y in range(0, 256) {\n             for x in range(0, 256) {\n-                let v = n2d.get(\n-                    x as f32 * 0.1f32,\n-                    y as f32 * 0.1f32\n-                ) * 0.5f32 + 0.5f32;\n-                pixels[y*256+x] = v;\n-            };\n-        };\n-    };\n+                let v = n2d.get(x as f32 * 0.1, y as f32 * 0.1);\n+                pixels[y*256+x] = v * 0.5 + 0.5;\n+            }\n+        }\n+    }\n \n     for y in range(0, 256) {\n         for x in range(0, 256) {\n-            print!(\"{}\", symbols[(pixels[y*256+x] / 0.2f32) as int]);\n+            let idx = (pixels[y*256+x] / 0.2) as uint;\n+            print!(\"{:c}\", symbols[idx]);\n         }\n-        println!(\"\");\n+        print!(\"\\n\");\n     }\n }"}]}