{"sha": "a59cc5774b2b599e697db5175c331f5f98e42001", "node_id": "C_kwDOAAsO6NoAKGE1OWNjNTc3NGIyYjU5OWU2OTdkYjUxNzVjMzMxZjVmOThlNDIwMDE", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-04-16T16:20:11Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-04-16T16:20:11Z"}, "message": "fix an invalid error for a suggestion to add a slice in pattern-matching", "tree": {"sha": "96a45562654631f414361a40688012757c4a9208", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96a45562654631f414361a40688012757c4a9208"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a59cc5774b2b599e697db5175c331f5f98e42001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a59cc5774b2b599e697db5175c331f5f98e42001", "html_url": "https://github.com/rust-lang/rust/commit/a59cc5774b2b599e697db5175c331f5f98e42001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a59cc5774b2b599e697db5175c331f5f98e42001/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7575f9670f3c837def3d186ae09366c75c7632e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7575f9670f3c837def3d186ae09366c75c7632e", "html_url": "https://github.com/rust-lang/rust/commit/e7575f9670f3c837def3d186ae09366c75c7632e"}], "stats": {"total": 115, "additions": 69, "deletions": 46}, "files": [{"sha": "deaa0c7c7419e6ab4c8b902bf58e45ca884c0c82", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a59cc5774b2b599e697db5175c331f5f98e42001/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59cc5774b2b599e697db5175c331f5f98e42001/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=a59cc5774b2b599e697db5175c331f5f98e42001", "patch": "@@ -2044,63 +2044,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.sess,\n             span,\n             E0529,\n-            \"expected an array or slice, found `{}`\",\n-            expected_ty\n+            \"expected an array or slice, found `{expected_ty}`\"\n         );\n-        if let ty::Ref(_, ty, _) = expected_ty.kind() {\n-            if let ty::Array(..) | ty::Slice(..) = ty.kind() {\n-                err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n-            }\n+        if let ty::Ref(_, ty, _) = expected_ty.kind()\n+            && let ty::Array(..) | ty::Slice(..) = ty.kind()\n+        {\n+            err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n         } else if Autoderef::new(&self.infcx, self.param_env, self.body_id, span, expected_ty, span)\n             .any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n+            && let (Some(span), true) = (ti.span, ti.origin_expr)\n+            && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n         {\n-            if let (Some(span), true) = (ti.span, ti.origin_expr) {\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    let applicability = Autoderef::new(\n-                        &self.infcx,\n-                        self.param_env,\n-                        self.body_id,\n-                        span,\n-                        self.resolve_vars_if_possible(ti.expected),\n-                        span,\n-                    )\n-                    .find_map(|(ty, _)| {\n-                        match ty.kind() {\n-                            ty::Adt(adt_def, _)\n-                                if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n-                                    || self.tcx.is_diagnostic_item(sym::Result, adt_def.did()) =>\n-                            {\n-                                // Slicing won't work here, but `.as_deref()` might (issue #91328).\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider using `as_deref` here\",\n-                                    format!(\"{}.as_deref()\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                Some(None)\n-                            }\n-\n-                            ty::Slice(..) | ty::Array(..) => {\n-                                Some(Some(Applicability::MachineApplicable))\n-                            }\n-\n-                            _ => None,\n-                        }\n-                    })\n-                    .unwrap_or(Some(Applicability::MaybeIncorrect));\n-\n-                    if let Some(applicability) = applicability {\n+            let any_target_ty = Autoderef::new(\n+                &self.infcx,\n+                self.param_env,\n+                self.body_id,\n+                span,\n+                self.resolve_vars_if_possible(ti.expected),\n+                span,\n+            )\n+            .any(|(ty, _)| {\n+                debug!(\"kind={:?}\", ty.kind());\n+                match ty.kind() {\n+                    ty::Adt(adt_def, _)\n+                        if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n+                            || self.tcx.is_diagnostic_item(sym::Result, adt_def.did()) =>\n+                    {\n+                        // Slicing won't work here, but `.as_deref()` might (issue #91328).\n                         err.span_suggestion(\n                             span,\n-                            \"consider slicing here\",\n-                            format!(\"{}[..]\", snippet),\n-                            applicability,\n+                            \"consider using `as_deref` here\",\n+                            format!(\"{snippet}.as_deref()\"),\n+                            Applicability::MaybeIncorrect,\n                         );\n+                        false\n                     }\n+                    _ => self.is_slice_or_array_or_vector(ty),\n                 }\n+            });\n+\n+            if any_target_ty {\n+                err.span_suggestion(\n+                    span,\n+                    \"consider slicing here\",\n+                    format!(\"{snippet}[..]\"),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n-        err.span_label(span, format!(\"pattern cannot match with input type `{}`\", expected_ty));\n+        err.span_label(span, format!(\"pattern cannot match with input type `{expected_ty}`\"));\n         err.emit();\n     }\n+\n+    fn is_slice_or_array_or_vector(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) if self.tcx.is_diagnostic_item(sym::Vec, adt_def.did()) => true,\n+            ty::Ref(_, ty, _) => self.is_slice_or_array_or_vector(*ty),\n+            ty::Slice(..) | ty::Array(..) => true,\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "1a9fc2f0050a70a5b571275efb683668154f63fa", "filename": "src/test/ui/suggestions/pattern-struct-with-slice-vec-field.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a59cc5774b2b599e697db5175c331f5f98e42001/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59cc5774b2b599e697db5175c331f5f98e42001/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs?ref=a59cc5774b2b599e697db5175c331f5f98e42001", "patch": "@@ -0,0 +1,13 @@\n+struct Foo {\n+    v: Vec<u32>,\n+}\n+\n+fn f(foo: &Foo) {\n+    match foo {\n+        Foo { v: [1, 2] } => {}\n+        //~^ ERROR expected an array or slice, found `Vec<u32>\n+        _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cb408d38fd2769f250945a2f20b1de8310a1e910", "filename": "src/test/ui/suggestions/pattern-struct-with-slice-vec-field.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a59cc5774b2b599e697db5175c331f5f98e42001/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a59cc5774b2b599e697db5175c331f5f98e42001/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr?ref=a59cc5774b2b599e697db5175c331f5f98e42001", "patch": "@@ -0,0 +1,9 @@\n+error[E0529]: expected an array or slice, found `Vec<u32>`\n+  --> $DIR/pattern-struct-with-slice-vec-field.rs:7:18\n+   |\n+LL |         Foo { v: [1, 2] } => {}\n+   |                  ^^^^^^ pattern cannot match with input type `Vec<u32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0529`."}]}