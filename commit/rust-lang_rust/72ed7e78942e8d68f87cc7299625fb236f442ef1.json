{"sha": "72ed7e78942e8d68f87cc7299625fb236f442ef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZWQ3ZTc4OTQyZThkNjhmODdjYzcyOTk2MjVmYjIzNmY0NDJlZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T01:23:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T01:23:48Z"}, "message": "Auto merge of #32900 - alexcrichton:panic2abort, r=nikomatsakis\n\nrustc: Implement custom panic runtimes\n\nThis commit is an implementation of [RFC 1513] which allows applications to\nalter the behavior of panics at compile time. A new compiler flag, `-C panic`,\nis added and accepts the values `unwind` or `panic`, with the default being\n`unwind`. This model affects how code is generated for the local crate, skipping\ngeneration of landing pads with `-C panic=abort`.\n\n[RFC 1513]: https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md\n\nPanic implementations are then provided by crates tagged with\n`#![panic_runtime]` and lazily required by crates with\n`#![needs_panic_runtime]`. The panic strategy (`-C panic` value) of the panic\nruntime must match the final product, and if the panic strategy is not `abort`\nthen the entire DAG must have the same panic strategy.\n\nWith the `-C panic=abort` strategy, users can expect a stable method to disable\ngeneration of landing pads, improving optimization in niche scenarios,\ndecreasing compile time, and decreasing output binary size. With the `-C\npanic=unwind` strategy users can expect the existing ability to isolate failure\nin Rust code from the outside world.\n\nOrganizationally, this commit dismantles the `sys_common::unwind` module in\nfavor of some bits moving part of it to `libpanic_unwind` and the rest into the\n`panicking` module in libstd. The custom panic runtime support is pretty similar\nto the custom allocator support with the only major difference being how the\npanic runtime is injected (takes the `-C panic` flag into account).\n\nCloses #32837", "tree": {"sha": "e74300ede603b26b6815e909e70f94f9841126bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74300ede603b26b6815e909e70f94f9841126bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72ed7e78942e8d68f87cc7299625fb236f442ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed7e78942e8d68f87cc7299625fb236f442ef1", "html_url": "https://github.com/rust-lang/rust/commit/72ed7e78942e8d68f87cc7299625fb236f442ef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72ed7e78942e8d68f87cc7299625fb236f442ef1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "html_url": "https://github.com/rust-lang/rust/commit/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1"}, {"sha": "38e6e5d0a9681b53cb517a3af665059e83988c3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e6e5d0a9681b53cb517a3af665059e83988c3d", "html_url": "https://github.com/rust-lang/rust/commit/38e6e5d0a9681b53cb517a3af665059e83988c3d"}], "stats": {"total": 3253, "additions": 2322, "deletions": 931}, "files": [{"sha": "1583515014a3941184ac5973e38e68f75073a079", "filename": "mk/crates.mk", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -53,7 +53,8 @@ TARGET_CRATES := libc std term \\\n                  getopts collections test rand \\\n                  core alloc \\\n                  rustc_unicode rustc_bitflags \\\n-\t\t alloc_system alloc_jemalloc\n+\t\t alloc_system alloc_jemalloc \\\n+\t\t panic_abort panic_unwind unwind\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics \\\n@@ -72,10 +73,18 @@ DEPS_libc := core\n DEPS_rand := core\n DEPS_rustc_bitflags := core\n DEPS_rustc_unicode := core\n+DEPS_panic_abort := libc alloc\n+DEPS_panic_unwind := libc alloc unwind\n+DEPS_unwind := libc\n+\n+# FIXME(stage0): change this to just `RUSTFLAGS_panic_abort := ...`\n+RUSTFLAGS1_panic_abort := -C panic=abort\n+RUSTFLAGS2_panic_abort := -C panic=abort\n+RUSTFLAGS3_panic_abort := -C panic=abort\n \n DEPS_std := core libc rand alloc collections rustc_unicode \\\n \tnative:backtrace \\\n-\talloc_system\n+\talloc_system panic_abort panic_unwind unwind\n DEPS_arena := std\n DEPS_glob := std\n DEPS_flate := std native:miniz\n@@ -148,6 +157,9 @@ ONLY_RLIB_rustc_unicode := 1\n ONLY_RLIB_rustc_bitflags := 1\n ONLY_RLIB_alloc_system := 1\n ONLY_RLIB_alloc_jemalloc := 1\n+ONLY_RLIB_panic_unwind := 1\n+ONLY_RLIB_panic_abort := 1\n+ONLY_RLIB_unwind := 1\n \n TARGET_SPECIFIC_alloc_jemalloc := 1\n "}, {"sha": "ea610f63dbf22d30ed3c7eaa1e102f87be9bac92", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -23,7 +23,8 @@ DEPS_collectionstest :=\n $(eval $(call RUST_CRATE,collectionstest))\n \n TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n-\t\t     \t\t  alloc_jemalloc,$(TARGET_CRATES)) \\\n+\t\t     \t\t  alloc_jemalloc panic_unwind \\\n+\t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES) arena flate fmt_macros getopts graphviz \\\n                 log rand rbml serialize syntax term test"}, {"sha": "046bc34438c4293e7345c9fc59996c39d9d488b4", "filename": "src/bootstrap/rustc.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -48,10 +48,11 @@ fn main() {\n     } else {\n         env::var_os(\"RUSTC_REAL\").unwrap()\n     };\n+    let stage = env::var(\"RUSTC_STAGE\").unwrap();\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n-       .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()));\n+       .arg(\"--cfg\").arg(format!(\"stage{}\", stage));\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n@@ -78,6 +79,22 @@ fn main() {\n             cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n         }\n \n+        // If we're compiling specifically the `panic_abort` crate then we pass\n+        // the `-C panic=abort` option. Note that we do not do this for any\n+        // other crate intentionally as this is the only crate for now that we\n+        // ship with panic=abort.\n+        //\n+        // This... is a bit of a hack how we detect this. Ideally this\n+        // information should be encoded in the crate I guess? Would likely\n+        // require an RFC amendment to RFC 1513, however.\n+        let is_panic_abort = args.windows(2).any(|a| {\n+            &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\"\n+        });\n+        // FIXME(stage0): remove this `stage != \"0\"` condition\n+        if is_panic_abort && stage != \"0\" {\n+            cmd.arg(\"-C\").arg(\"panic=abort\");\n+        }\n+\n         // Set various options from config.toml to configure how we're building\n         // code.\n         if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {"}, {"sha": "a22299c5e1a54dbe640c3364bd21f969f062209f", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -18,10 +18,8 @@\n                       form or name\",\n             issue = \"27783\")]\n #![feature(allocator)]\n-#![feature(libc)]\n #![feature(staged_api)]\n-\n-extern crate libc;\n+#![cfg_attr(unix, feature(libc))]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n@@ -72,9 +70,10 @@ pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n \n #[cfg(unix)]\n mod imp {\n+    extern crate libc;\n+\n     use core::cmp;\n     use core::ptr;\n-    use libc;\n     use MIN_ALIGN;\n \n     pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {"}, {"sha": "a7905703f596f3f6e2e332c2d4bafb0ec15f73b4", "filename": "src/libpanic_abort/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"panic_abort\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }"}, {"sha": "c085ddeb75b97f407ab552f825c4b66a381b45b7", "filename": "src/libpanic_abort/lib.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of Rust panics via process aborts\n+//!\n+//! When compared to the implementation via unwinding, this crate is *much*\n+//! simpler! That being said, it's not quite as versatile, but here goes!\n+\n+#![no_std]\n+#![crate_name = \"panic_abort\"]\n+#![crate_type = \"rlib\"]\n+#![unstable(feature = \"panic_abort\", issue = \"32837\")]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(staged_api)]\n+\n+#![cfg_attr(not(stage0), panic_runtime)]\n+#![cfg_attr(not(stage0), feature(panic_runtime))]\n+#![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(windows, feature(core_intrinsics))]\n+\n+// Rust's \"try\" function, but if we're aborting on panics we just call the\n+// function as there's nothing else we need to do here.\n+#[no_mangle]\n+pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n+                                              data: *mut u8,\n+                                              _data_ptr: *mut usize,\n+                                              _vtable_ptr: *mut usize) -> u32 {\n+    f(data);\n+    0\n+}\n+\n+// \"Leak\" the payload and shim to the relevant abort on the platform in\n+// question.\n+//\n+// For Unix we just use `abort` from libc as it'll trigger debuggers, core\n+// dumps, etc, as one might expect. On Windows, however, the best option we have\n+// is the `__fastfail` intrinsics, but that's unfortunately not defined in LLVM,\n+// and the `RaiseFailFastException` function isn't available until Windows 7\n+// which would break compat with XP. For now just use `intrinsics::abort` which\n+// will kill us with an illegal instruction, which will do a good enough job for\n+// now hopefully.\n+#[no_mangle]\n+pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n+    return abort();\n+\n+    #[cfg(unix)]\n+    unsafe fn abort() -> ! {\n+        extern crate libc;\n+        libc::abort();\n+    }\n+\n+    #[cfg(windows)]\n+    unsafe fn abort() -> ! {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+// This... is a bit of an oddity. The tl;dr; is that this is required to link\n+// correctly, the longer explanation is below.\n+//\n+// Right now the binaries of libcore/libstd that we ship are all compiled with\n+// `-C panic=unwind`. This is done to ensure that the binaries are maximally\n+// compatible with as many situations as possible. The compiler, however,\n+// requires a \"personality function\" for all functions compiled with `-C\n+// panic=unwind`. This personality function is hardcoded to the symbol\n+// `rust_eh_personality` and is defined by the `eh_personality` lang item.\n+//\n+// So... why not just define that lang item here? Good question! The way that\n+// panic runtimes are linked in is actually a little subtle in that they're\n+// \"sort of\" in the compiler's crate store, but only actually linked if another\n+// isn't actually linked. This ends up meaning that both this crate and the\n+// panic_unwind crate can appear in the compiler's crate store, and if both\n+// define the `eh_personality` lang item then that'll hit an error.\n+//\n+// To handle this the compiler only requires the `eh_personality` is defined if\n+// the panic runtime being linked in is the unwinding runtime, and otherwise\n+// it's not required to be defined (rightfully so). In this case, however, this\n+// library just defines this symbol so there's at least some personality\n+// somewhere.\n+//\n+// Essentially this symbol is just defined to get wired up to libcore/libstd\n+// binaries, but it should never be called as we don't link in an unwinding\n+// runtime at all.\n+#[cfg(not(stage0))]\n+pub mod personalities {\n+\n+    #[no_mangle]\n+    #[cfg(not(all(target_os = \"windows\",\n+                  target_env = \"gnu\",\n+                  target_arch = \"x86_64\")))]\n+    pub extern fn rust_eh_personality() {}\n+\n+    // On x86_64-pc-windows-gnu we use our own personality function that needs\n+    // to return `ExceptionContinueSearch` as we're passing on all our frames.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\",\n+              target_env = \"gnu\",\n+              target_arch = \"x86_64\"))]\n+    pub extern fn rust_eh_personality(_record: usize,\n+                                      _frame: usize,\n+                                      _context: usize,\n+                                      _dispatcher: usize) -> u32 {\n+        1 // `ExceptionContinueSearch`\n+    }\n+\n+    // Similar to above, this corresponds to the `eh_unwind_resume` lang item\n+    // that's only used on Windows currently.\n+    //\n+    // Note that we don't execute landing pads, so this is never called, so it's\n+    // body is empty.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\"))]\n+    pub extern fn rust_eh_unwind_resume() {}\n+\n+    // These two are called by our startup objects on i686-pc-windows-gnu, but\n+    // they don't need to do anything so the bodies are nops.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n+    pub extern fn rust_eh_register_frames() {}\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n+    pub extern fn rust_eh_unregister_frames() {}\n+}"}, {"sha": "20d826d4a470ee7c7c14d85b6760caade6f26eef", "filename": "src/libpanic_unwind/Cargo.lock", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.lock?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,27 @@\n+[root]\n+name = \"panic_unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+"}, {"sha": "27edecd6f9668e83ded991ad2be037a63a0bbff6", "filename": "src/libpanic_unwind/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"panic_unwind\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+alloc = { path = \"../liballoc\" }\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }\n+unwind = { path = \"../libunwind\" }"}, {"sha": "1c3fca98a1f71efdbd4afea1a6429aa85580a804", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -21,8 +21,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(unused)]\n \n-use prelude::v1::*;\n-use sys_common::dwarf::DwarfReader;\n+use dwarf::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit     : u8 = 0xFF;", "previous_filename": "src/libstd/sys/common/dwarf/eh.rs"}, {"sha": "cde21f90811dee249bd893e9cb6d92c4180aca27", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -18,7 +18,6 @@\n \n pub mod eh;\n \n-use prelude::v1::*;\n use core::mem;\n \n pub struct DwarfReader {", "previous_filename": "src/libstd/sys/common/dwarf/mod.rs"}, {"sha": "50b2e1534d70ddba657a1e3f8f0c294da00adb25", "filename": "src/libpanic_unwind/gcc.rs", "status": "renamed", "additions": 84, "deletions": 29, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -8,30 +8,76 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of panics backed by libgcc/libunwind (in some form)\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!     http://mentorembedded.github.io/cxx-abi/abi-eh.html\n+//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//!     http://www.airs.com/blog/index.php?s=exception+frames\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup\n+//! phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine\n+//! exception object being thrown, and to decide whether it should be caught at\n+//! that stack frame.  Once the handler frame has been identified, cleanup phase\n+//! begins.\n+//!\n+//! In the cleanup phase, the unwinder invokes each personality routine again.\n+//! This time it decides which (if any) cleanup code needs to be run for\n+//! the current stack frame.  If so, the control is transferred to a special\n+//! branch in the function body, the \"landing pad\", which invokes destructors,\n+//! frees memory, etc.  At the end of the landing pad, control is transferred\n+//! back to the unwinder and unwinding resumes.\n+//!\n+//! Once stack has been unwound down to the handler frame level, unwinding stops\n+//! and the last personality routine transfers control to the catch block.\n+//!\n+//! ## `eh_personality` and `eh_unwind_resume`\n+//!\n+//! These language items are used by the compiler when generating unwind info.\n+//! The first one is the personality routine described above.  The second one\n+//! allows compilation target to customize the process of resuming unwind at the\n+//! end of the landing pads. `eh_unwind_resume` is used only if\n+//! `custom_unwind_resume` flag in the target options is set.\n+\n #![allow(private_no_mangle_fns)]\n \n-use prelude::v1::*;\n+use core::any::Any;\n+use alloc::boxed::Box;\n \n-use any::Any;\n-use sys_common::libunwind as uw;\n+use unwind as uw;\n \n+#[repr(C)]\n struct Exception {\n-    uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<Any + Send + 'static>>,\n+    _uwe: uw::_Unwind_Exception,\n+    cause: Option<Box<Any + Send>>,\n }\n \n-pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n-    let exception: Box<_> = box Exception {\n-        uwe: uw::_Unwind_Exception {\n+pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+    let exception = Box::new(Exception {\n+        _uwe: uw::_Unwind_Exception {\n             exception_class: rust_exception_class(),\n             exception_cleanup: exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n         cause: Some(data),\n-    };\n+    });\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n-    let error = uw::_Unwind_RaiseException(exception_param);\n-    rtabort!(\"Could not unwind stack, error = {}\", error as isize);\n+    return uw::_Unwind_RaiseException(exception_param) as u32;\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n                                 exception: *mut uw::_Unwind_Exception) {\n@@ -45,7 +91,7 @@ pub fn payload() -> *mut u8 {\n     0 as *mut u8\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n     let my_ep = ptr as *mut Exception;\n     let cause = (*my_ep).cause.take();\n     uw::_Unwind_DeleteException(ptr as *mut _);\n@@ -59,7 +105,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     0x4d4f5a_00_52555354\n }\n \n-// We could implement our personality routine in pure Rust, however exception\n+// We could implement our personality routine in Rust, however exception\n // info decoding is tedious.  More importantly, personality routines have to\n // handle various platform quirks, which are not fun to maintain.  For this\n // reason, we attempt to reuse personality routine of the C language:\n@@ -79,10 +125,9 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n // See also: rustc_trans::trans::intrinsic::trans_gnu_try\n \n #[cfg(all(not(target_arch = \"arm\"),\n-          not(all(windows, target_arch = \"x86_64\")),\n-          not(test)))]\n+          not(all(windows, target_arch = \"x86_64\"))))]\n pub mod eabi {\n-    use sys_common::libunwind as uw;\n+    use unwind as uw;\n     use libc::c_int;\n \n     extern {\n@@ -136,9 +181,9 @@ pub mod eabi {\n // iOS on armv7 is using SjLj exceptions and therefore requires to use\n // a specialized personality routine: __gcc_personality_sj0\n \n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n pub mod eabi {\n-    use sys_common::libunwind as uw;\n+    use unwind as uw;\n     use libc::c_int;\n \n     extern {\n@@ -191,9 +236,9 @@ pub mod eabi {\n \n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n pub mod eabi {\n-    use sys_common::libunwind as uw;\n+    use unwind as uw;\n     use libc::c_int;\n \n     extern {\n@@ -242,19 +287,31 @@ pub mod eabi {\n }\n \n // See docs in the `unwind` module.\n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\", not(test)))]\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n unsafe extern fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n     uw::_Unwind_Resume(panic_ctx as *mut uw::_Unwind_Exception);\n }\n \n+// Frame unwind info registration\n+//\n+// Each module's image contains a frame unwind info section (usually\n+// \".eh_frame\").  When a module is loaded/unloaded into the process, the\n+// unwinder must be informed about the location of this section in memory. The\n+// methods of achieving that vary by the platform.  On some (e.g. Linux), the\n+// unwinder can discover unwind info sections on its own (by dynamically\n+// enumerating currently loaded modules via the dl_iterate_phdr() API and\n+// finding their \".eh_frame\" sections); Others, like Windows, require modules\n+// to actively register their unwind info sections via unwinder API.\n+//\n+// This module defines two symbols which are referenced and called from\n+// rsbegin.rs to reigster our information with the GCC runtime. The\n+// implementation of stack unwinding is (for now) deferred to libgcc_eh, however\n+// Rust crates use these Rust-specific entry points to avoid potential clashes\n+// with any GCC runtime.\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n pub mod eh_frame_registry {\n-    // The implementation of stack unwinding is (for now) deferred to libgcc_eh, however Rust\n-    // crates use these Rust-specific entry points to avoid potential clashes with GCC runtime.\n-    // See also: rtbegin.rs, `unwind` module.\n-\n     #[link(name = \"gcc_eh\")]\n     #[cfg(not(cargobuild))]\n     extern {}\n@@ -263,16 +320,14 @@ pub mod eh_frame_registry {\n         fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n         fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n     }\n-    #[cfg(not(test))]\n+\n     #[no_mangle]\n-    #[unstable(feature = \"libstd_sys_internals\", issue = \"0\")]\n     pub unsafe extern fn rust_eh_register_frames(eh_frame_begin: *const u8,\n                                                  object: *mut u8) {\n         __register_frame_info(eh_frame_begin, object);\n     }\n-    #[cfg(not(test))]\n+\n     #[no_mangle]\n-    #[unstable(feature = \"libstd_sys_internals\", issue = \"0\")]\n     pub  unsafe extern fn rust_eh_unregister_frames(eh_frame_begin: *const u8,\n                                                    object: *mut u8) {\n         __deregister_frame_info(eh_frame_begin, object);", "previous_filename": "src/libstd/sys/common/unwind/gcc.rs"}, {"sha": "17cbd2e0d4c39b299a2530e12f7e2d05487874cf", "filename": "src/libpanic_unwind/lib.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of panics via stack unwinding\n+//!\n+//! This crate is an implementation of panics in Rust using \"most native\" stack\n+//! unwinding mechanism of the platform this is being compiled for. This\n+//! essentially gets categorized into three buckets currently:\n+//!\n+//! 1. MSVC targets use SEH in the `seh.rs` file.\n+//! 2. The 64-bit MinGW target half-uses SEH and half-use gcc-like information\n+//!    in the `seh64_gnu.rs` module.\n+//! 3. All other targets use libunwind/libgcc in the `gcc/mod.rs` module.\n+//!\n+//! More documentation about each implementation can be found in the respective\n+//! module.\n+\n+#![no_std]\n+#![crate_name = \"panic_unwind\"]\n+#![crate_type = \"rlib\"]\n+#![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(alloc)]\n+#![feature(core_intrinsics)]\n+#![feature(lang_items)]\n+#![feature(libc)]\n+#![feature(panic_unwind)]\n+#![feature(raw)]\n+#![feature(staged_api)]\n+#![feature(unwind_attributes)]\n+#![cfg_attr(target_env = \"msvc\", feature(raw))]\n+\n+#![cfg_attr(not(stage0), panic_runtime)]\n+#![cfg_attr(not(stage0), feature(panic_runtime))]\n+\n+extern crate alloc;\n+extern crate libc;\n+extern crate unwind;\n+\n+use core::intrinsics;\n+use core::mem;\n+use core::raw;\n+\n+// Rust runtime's startup objects depend on these symbols, so make them public.\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub use imp::eh_frame_registry::*;\n+\n+// *-pc-windows-msvc\n+#[cfg(target_env = \"msvc\")]\n+#[path = \"seh.rs\"]\n+mod imp;\n+\n+// x86_64-pc-windows-gnu\n+#[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))]\n+#[path = \"seh64_gnu.rs\"]\n+mod imp;\n+\n+// i686-pc-windows-gnu and all others\n+#[cfg(any(unix, all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n+#[path = \"gcc.rs\"]\n+mod imp;\n+\n+mod dwarf;\n+mod windows;\n+\n+// Entry point for catching an exception, implemented using the `try` intrinsic\n+// in the compiler.\n+//\n+// The interaction between the `payload` function and the compiler is pretty\n+// hairy and tightly coupled, for more information see the compiler's\n+// implementation of this.\n+#[no_mangle]\n+pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n+                                              data: *mut u8,\n+                                              data_ptr: *mut usize,\n+                                              vtable_ptr: *mut usize)\n+                                              -> u32 {\n+    let mut payload = imp::payload();\n+    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n+        0\n+    } else {\n+        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));\n+        *data_ptr = obj.data as usize;\n+        *vtable_ptr = obj.vtable as usize;\n+        1\n+    }\n+}\n+\n+// Entry point for raising an exception, just delegates to the platform-specific\n+// implementation.\n+#[no_mangle]\n+pub unsafe extern fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n+    imp::panic(mem::transmute(raw::TraitObject {\n+        data: data as *mut (),\n+        vtable: vtable as *mut (),\n+    }))\n+}"}, {"sha": "04a3f7b9663fbe203ad1a87a30f3dc34329b7077", "filename": "src/libpanic_unwind/seh.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,326 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows SEH\n+//!\n+//! On Windows (currently only on MSVC), the default exception handling\n+//! mechanism is Structured Exception Handling (SEH). This is quite different\n+//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n+//! terms of compiler internals, so LLVM is required to have a good deal of\n+//! extra support for SEH.\n+//!\n+//! In a nutshell, what happens here is:\n+//!\n+//! 1. The `panic` function calls the standard Windows function\n+//!    `_CxxThrowException` to throw a C++-like exception, triggering the\n+//!    unwinding process.\n+//! 2. All landing pads generated by the compiler use the personality function\n+//!    `__CxxFrameHandler3`, a function in the CRT, and the unwinding code in\n+//!    Windows will use this personality function to execute all cleanup code on\n+//!    the stack.\n+//! 3. All compiler-generated calls to `invoke` have a landing pad set as a\n+//!    `cleanuppad` LLVM instruction, which indicates the start of the cleanup\n+//!    routine. The personality (in step 2, defined in the CRT) is responsible\n+//!    for running the cleanup routines.\n+//! 4. Eventually the \"catch\" code in the `try` intrinsic (generated by the\n+//!    compiler) is executed and indicates that control should come back to\n+//!    Rust. This is done via a `catchswitch` plus a `catchpad` instruction in\n+//!    LLVM IR terms, finally returning normal control to the program with a\n+//!    `catchret` instruction.\n+//!\n+//! Some specific differences from the gcc-based exception handling are:\n+//!\n+//! * Rust has no custom personality function, it is instead *always*\n+//!   `__CxxFrameHandler3`. Additionally, no extra filtering is performed, so we\n+//!   end up catching any C++ exceptions that happen to look like the kind we're\n+//!   throwing. Note that throwing an exception into Rust is undefined behavior\n+//!   anyway, so this should be fine.\n+//! * We've got some data to transmit across the unwinding boundary,\n+//!   specifically a `Box<Any + Send>`. Like with Dwarf exceptions\n+//!   these two pointers are stored as a payload in the exception itself. On\n+//!   MSVC, however, there's no need for an extra heap allocation because the\n+//!   call stack is preserved while filter functions are being executed. This\n+//!   means that the pointers are passed directly to `_CxxThrowException` which\n+//!   are then recovered in the filter function to be written to the stack frame\n+//!   of the `try` intrinsic.\n+//!\n+//! [win64]: http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx\n+//! [llvm]: http://llvm.org/docs/ExceptionHandling.html#background-on-windows-exceptions\n+\n+#![allow(bad_style)]\n+#![allow(private_no_mangle_fns)]\n+\n+use alloc::boxed::Box;\n+use core::any::Any;\n+use core::mem;\n+use core::raw;\n+\n+use windows as c;\n+use libc::{c_int, c_uint};\n+\n+// First up, a whole bunch of type definitions. There's a few platform-specific\n+// oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n+// of all this is to implement the `panic` function below through a call to\n+// `_CxxThrowException`.\n+//\n+// This function takes two arguments. The first is a pointer to the data we're\n+// passing in, which in this case is our trait object. Pretty easy to find! The\n+// next, however, is more complicated. This is a pointer to a `_ThrowInfo`\n+// structure, and it generally is just intended to just describe the exception\n+// being thrown.\n+//\n+// Currently the definition of this type [1] is a little hairy, and the main\n+// oddity (and difference from the online article) is that on 32-bit the\n+// pointers are pointers but on 64-bit the pointers are expressed as 32-bit\n+// offsets from the `__ImageBase` symbol. The `ptr_t` and `ptr!` macro in the\n+// modules below are used to express this.\n+//\n+// The maze of type definitions also closely follows what LLVM emits for this\n+// sort of operation. For example, if you compile this C++ code on MSVC and emit\n+// the LLVM IR:\n+//\n+//      #include <stdin.h>\n+//\n+//      void foo() {\n+//          uint64_t a[2] = {0, 1};\n+//          throw a;\n+//      }\n+//\n+// That's essentially what we're trying to emulate. Most of the constant values\n+// below were just copied from LLVM, I'm at least not 100% sure what's going on\n+// everywhere. For example the `.PA_K\\0` and `.PEA_K\\0` strings below (stuck in\n+// the names of a few of these) I'm not actually sure what they do, but it seems\n+// to mirror what LLVM does!\n+//\n+// In any case, these structures are all constructed in a similar manner, and\n+// it's just somewhat verbose for us.\n+//\n+// [1]: http://www.geoffchappell.com/studies/msvc/language/predefined/\n+\n+#[cfg(target_arch = \"x86\")]\n+#[macro_use]\n+mod imp {\n+    pub type ptr_t = *mut u8;\n+    pub const OFFSET: i32 = 4;\n+\n+    pub const NAME1: [u8; 7] = [b'.', b'P', b'A', b'_', b'K', 0, 0];\n+    pub const NAME2: [u8; 7] = [b'.', b'P', b'A', b'X', 0, 0, 0];\n+\n+    macro_rules! ptr {\n+        (0) => (0 as *mut u8);\n+        ($e:expr) => ($e as *mut u8);\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[macro_use]\n+mod imp {\n+    pub type ptr_t = u32;\n+    pub const OFFSET: i32 = 8;\n+\n+    pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n+    pub const NAME2: [u8; 7] = [b'.', b'P', b'E', b'A', b'X', 0, 0];\n+\n+    extern {\n+        pub static __ImageBase: u8;\n+    }\n+\n+    macro_rules! ptr {\n+        (0) => (0);\n+        ($e:expr) => {\n+            (($e as usize) - (&imp::__ImageBase as *const _ as usize)) as u32\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct _ThrowInfo {\n+    pub attribues: c_uint,\n+    pub pnfnUnwind: imp::ptr_t,\n+    pub pForwardCompat: imp::ptr_t,\n+    pub pCatchableTypeArray: imp::ptr_t,\n+}\n+\n+#[repr(C)]\n+pub struct _CatchableTypeArray {\n+    pub nCatchableTypes: c_int,\n+    pub arrayOfCatchableTypes: [imp::ptr_t; 2],\n+}\n+\n+#[repr(C)]\n+pub struct _CatchableType {\n+    pub properties: c_uint,\n+    pub pType: imp::ptr_t,\n+    pub thisDisplacement: _PMD,\n+    pub sizeOrOffset: c_int,\n+    pub copy_function: imp::ptr_t,\n+}\n+\n+#[repr(C)]\n+pub struct _PMD {\n+    pub mdisp: c_int,\n+    pub pdisp: c_int,\n+    pub vdisp: c_int,\n+}\n+\n+#[repr(C)]\n+pub struct _TypeDescriptor {\n+    pub pVFTable: *const u8,\n+    pub spare: *mut u8,\n+    pub name: [u8; 7],\n+}\n+\n+static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n+    attribues: 0,\n+    pnfnUnwind: ptr!(0),\n+    pForwardCompat: ptr!(0),\n+    pCatchableTypeArray: ptr!(0),\n+};\n+\n+static mut CATCHABLE_TYPE_ARRAY: _CatchableTypeArray = _CatchableTypeArray {\n+    nCatchableTypes: 2,\n+    arrayOfCatchableTypes: [\n+        ptr!(0),\n+        ptr!(0),\n+    ],\n+};\n+\n+static mut CATCHABLE_TYPE1: _CatchableType = _CatchableType {\n+    properties: 1,\n+    pType: ptr!(0),\n+    thisDisplacement: _PMD {\n+        mdisp: 0,\n+        pdisp: -1,\n+        vdisp: 0,\n+    },\n+    sizeOrOffset: imp::OFFSET,\n+    copy_function: ptr!(0),\n+};\n+\n+static mut CATCHABLE_TYPE2: _CatchableType = _CatchableType {\n+    properties: 1,\n+    pType: ptr!(0),\n+    thisDisplacement: _PMD {\n+        mdisp: 0,\n+        pdisp: -1,\n+        vdisp: 0,\n+    },\n+    sizeOrOffset: imp::OFFSET,\n+    copy_function: ptr!(0),\n+};\n+\n+extern {\n+    // The leading `\\x01` byte here is actually a magical signal to LLVM to\n+    // *not* apply any other mangling like prefixing with a `_` character.\n+    //\n+    // This symbol is the vtable used by C++'s `std::type_info`. Objects of type\n+    // `std::type_info`, type descriptors, have a pointer to this table. Type\n+    // descriptors are referenced by the C++ EH structures defined above and\n+    // that we construct below.\n+    #[link_name = \"\\x01??_7type_info@@6B@\"]\n+    static TYPE_INFO_VTABLE: *const u8;\n+}\n+\n+// We use #[lang = \"msvc_try_filter\"] here as this is the type descriptor which\n+// we'll use in LLVM's `catchpad` instruction which ends up also being passed as\n+// an argument to the C++ personality function.\n+//\n+// Again, I'm not entirely sure what this is describing, it just seems to work.\n+#[cfg_attr(all(not(test), not(stage0)),\n+           lang = \"msvc_try_filter\")]\n+static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n+    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    spare: 0 as *mut _,\n+    name: imp::NAME1,\n+};\n+\n+static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n+    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    spare: 0 as *mut _,\n+    name: imp::NAME2,\n+};\n+\n+pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+    use core::intrinsics::atomic_store;\n+\n+    // _CxxThrowException executes entirely on this stack frame, so there's no\n+    // need to otherwise transfer `data` to the heap. We just pass a stack\n+    // pointer to this function.\n+    //\n+    // The first argument is the payload being thrown (our two pointers), and\n+    // the second argument is the type information object describing the\n+    // exception (constructed above).\n+    let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n+    let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n+    let mut ptrs_ptr = ptrs.as_mut_ptr();\n+\n+    // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n+    // pointers between these structure are just that, pointers. On 64-bit MSVC,\n+    // however, the pointers between structures are rather expressed as 32-bit\n+    // offsets from `__ImageBase`.\n+    //\n+    // Consequently, on 32-bit MSVC we can declare all these pointers in the\n+    // `static`s above. On 64-bit MSVC, we would have to express subtraction of\n+    // pointers in statics, which Rust does not currently allow, so we can't\n+    // actually do that.\n+    //\n+    // The next best thing, then is to fill in these structures at runtime\n+    // (panicking is already the \"slow path\" anyway). So here we reinterpret all\n+    // of these pointer fields as 32-bit integers and then store the\n+    // relevant value into it (atomically, as concurrent panics may be\n+    // happening). Technically the runtime will probably do a nonatomic read of\n+    // these fields, but in theory they never read the *wrong* value so it\n+    // shouldn't be too bad...\n+    //\n+    // In any case, we basically need to do something like this until we can\n+    // express more operations in statics (and we may never be able to).\n+    atomic_store(&mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[0] as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE1 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[1] as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE2 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE1.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR1 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE2.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR2 as *const _) as u32);\n+\n+    c::_CxxThrowException(&mut ptrs_ptr as *mut _ as *mut _,\n+                          &mut THROW_INFO as *mut _ as *mut _);\n+    u32::max_value()\n+}\n+\n+pub fn payload() -> [u64; 2] {\n+    [0; 2]\n+}\n+\n+pub unsafe fn cleanup(payload: [u64; 2]) -> Box<Any + Send> {\n+    mem::transmute(raw::TraitObject {\n+        data: payload[0] as *mut _,\n+        vtable: payload[1] as *mut _,\n+    })\n+}\n+\n+#[lang = \"msvc_try_filter\"]\n+#[cfg(stage0)]\n+unsafe extern fn __rust_try_filter(_eh_ptrs: *mut u8,\n+                                   _payload: *mut u8) -> i32 {\n+    return 0\n+}\n+\n+// This is required by the compiler to exist (e.g. it's a lang item), but\n+// it's never actually called by the compiler because __C_specific_handler\n+// or _except_handler3 is the personality function that is always used.\n+// Hence this is just an aborting stub.\n+#[lang = \"eh_personality\"]\n+#[cfg(not(test))]\n+fn rust_eh_personality() {\n+    unsafe { ::core::intrinsics::abort() }\n+}"}, {"sha": "adb38d857eac7ff6588f303ea2c1f2bd6b0779e3", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "renamed", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -14,13 +14,12 @@\n #![allow(bad_style)]\n #![allow(private_no_mangle_fns)]\n \n-use prelude::v1::*;\n+use alloc::boxed::Box;\n \n-use any::Any;\n-use sys_common::dwarf::eh;\n-use core::mem;\n-use core::ptr;\n-use sys::c;\n+use core::any::Any;\n+use core::intrinsics;\n+use dwarf::eh;\n+use windows as c;\n \n // Define our exception codes:\n // according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,\n@@ -37,24 +36,24 @@ const RUST_PANIC: c::DWORD  = ETYPE | (1 << 24) | MAGIC;\n \n #[repr(C)]\n struct PanicData {\n-    data: Box<Any + Send + 'static>\n+    data: Box<Any + Send>\n }\n \n-pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n     let panic_ctx = Box::new(PanicData { data: data });\n     let params = [Box::into_raw(panic_ctx) as c::ULONG_PTR];\n     c::RaiseException(RUST_PANIC,\n                       c::EXCEPTION_NONCONTINUABLE,\n                       params.len() as c::DWORD,\n                       &params as *const c::ULONG_PTR);\n-    rtabort!(\"could not unwind stack\");\n+    u32::max_value()\n }\n \n pub fn payload() -> *mut u8 {\n     0 as *mut u8\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n     return panic_ctx.data;\n }\n@@ -115,14 +114,12 @@ unsafe extern fn rust_eh_personality(\n                                er.ExceptionInformation[0] as c::LPVOID, // pointer to PanicData\n                                contextRecord,\n                                dc.HistoryTable);\n-                rtabort!(\"could not unwind\");\n             }\n         }\n     }\n     c::ExceptionContinueSearch\n }\n \n-#[cfg(not(test))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n unsafe extern fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n@@ -131,7 +128,7 @@ unsafe extern fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n                       c::EXCEPTION_NONCONTINUABLE,\n                       params.len() as c::DWORD,\n                       &params as *const c::ULONG_PTR);\n-    rtabort!(\"could not resume unwind\");\n+    intrinsics::abort();\n }\n \n unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {", "previous_filename": "src/libstd/sys/common/unwind/seh64_gnu.rs"}, {"sha": "9cca018ff111a52ba465dd43019891230454e14b", "filename": "src/libpanic_unwind/windows.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(bad_style)]\n+#![allow(dead_code)]\n+#![cfg(windows)]\n+\n+use libc::{c_void, c_ulong, c_long, c_ulonglong};\n+\n+pub type DWORD = c_ulong;\n+pub type LONG = c_long;\n+pub type ULONG_PTR = c_ulonglong;\n+pub type LPVOID = *mut c_void;\n+\n+pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+pub const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n+pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n+pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n+pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n+pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n+pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n+                                    EXCEPTION_EXIT_UNWIND |\n+                                    EXCEPTION_TARGET_UNWIND |\n+                                    EXCEPTION_COLLIDED_UNWIND;\n+\n+#[repr(C)]\n+pub struct EXCEPTION_RECORD {\n+    pub ExceptionCode: DWORD,\n+    pub ExceptionFlags: DWORD,\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ExceptionAddress: LPVOID,\n+    pub NumberParameters: DWORD,\n+    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+}\n+\n+#[repr(C)]\n+pub struct EXCEPTION_POINTERS {\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ContextRecord: *mut CONTEXT,\n+}\n+\n+pub enum UNWIND_HISTORY_TABLE {}\n+\n+#[repr(C)]\n+pub struct RUNTIME_FUNCTION {\n+    pub BeginAddress: DWORD,\n+    pub EndAddress: DWORD,\n+    pub UnwindData: DWORD,\n+}\n+\n+pub enum CONTEXT {}\n+\n+#[repr(C)]\n+pub struct DISPATCHER_CONTEXT {\n+    pub ControlPc: LPVOID,\n+    pub ImageBase: LPVOID,\n+    pub FunctionEntry: *const RUNTIME_FUNCTION,\n+    pub EstablisherFrame: LPVOID,\n+    pub TargetIp: LPVOID,\n+    pub ContextRecord: *const CONTEXT,\n+    pub LanguageHandler: LPVOID,\n+    pub HandlerData: *const u8,\n+    pub HistoryTable: *const UNWIND_HISTORY_TABLE,\n+}\n+\n+#[repr(C)]\n+pub enum EXCEPTION_DISPOSITION {\n+    ExceptionContinueExecution,\n+    ExceptionContinueSearch,\n+    ExceptionNestedException,\n+    ExceptionCollidedUnwind\n+}\n+pub use self::EXCEPTION_DISPOSITION::*;\n+\n+extern \"system\" {\n+    #[unwind]\n+    pub fn RaiseException(dwExceptionCode: DWORD,\n+                          dwExceptionFlags: DWORD,\n+                          nNumberOfArguments: DWORD,\n+                          lpArguments: *const ULONG_PTR);\n+    #[unwind]\n+    pub fn RtlUnwindEx(TargetFrame: LPVOID,\n+                       TargetIp: LPVOID,\n+                       ExceptionRecord: *const EXCEPTION_RECORD,\n+                       ReturnValue: LPVOID,\n+                       OriginalContext: *const CONTEXT,\n+                       HistoryTable: *const UNWIND_HISTORY_TABLE);\n+    #[unwind]\n+    pub fn _CxxThrowException(pExceptionObject: *mut c_void,\n+                              pThrowInfo: *mut u8);\n+}"}, {"sha": "035505655967c384c9d4f4ccc42e1f0368f55e7a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -31,6 +31,7 @@ use hir::def_id::{DefId, DefIndex};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n+use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n use std::any::Any;\n@@ -222,6 +223,8 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool;\n+    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy;\n     fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n     /// The name of the crate as it is referred to in source code of the current\n@@ -408,6 +411,10 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n+    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+        bug!(\"panic_strategy\")\n+    }\n     fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n         { bug!(\"crate_attrs\") }"}, {"sha": "fe22cfdb43f73ce7643b209557f8b8231d2cbc87", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 99, "deletions": 38, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -64,7 +64,7 @@\n use syntax::ast;\n \n use session;\n-use session::config;\n+use session::config::{self, PanicStrategy};\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FnvHashMap;\n \n@@ -193,10 +193,15 @@ fn calculate_type(sess: &session::Session,\n     }\n \n     // We've gotten this far because we're emitting some form of a final\n-    // artifact which means that we're going to need an allocator of some form.\n-    // No allocator may have been required or linked so far, so activate one\n-    // here if one isn't set.\n-    activate_allocator(sess, &mut ret);\n+    // artifact which means that we may need to inject dependencies of some\n+    // form.\n+    //\n+    // Things like allocators and panic runtimes may not have been activated\n+    // quite yet, so do so here.\n+    activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n+                          &|cnum| sess.cstore.is_allocator(cnum));\n+    activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| sess.cstore.is_panic_runtime(cnum));\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n@@ -270,40 +275,42 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n         }\n     }).collect::<Vec<_>>();\n \n-    // Our allocator may not have been activated as it's not flagged with\n-    // explicitly_linked, so flag it here if necessary.\n-    activate_allocator(sess, &mut ret);\n+    // Our allocator/panic runtime may not have been linked above if it wasn't\n+    // explicitly linked, which is the case for any injected dependency. Handle\n+    // that here and activate them.\n+    activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n+                          &|cnum| sess.cstore.is_allocator(cnum));\n+    activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| sess.cstore.is_panic_runtime(cnum));\n \n     Some(ret)\n }\n \n // Given a list of how to link upstream dependencies so far, ensure that an\n-// allocator is activated. This will not do anything if one was transitively\n-// included already (e.g. via a dylib or explicitly so).\n+// injected dependency is activated. This will not do anything if one was\n+// transitively included already (e.g. via a dylib or explicitly so).\n //\n-// If an allocator was not found then we're guaranteed the metadata::creader\n-// module has injected an allocator dependency (not listed as a required\n-// dependency) in the session's `injected_allocator` field. If this field is not\n-// set then this compilation doesn't actually need an allocator and we can also\n-// skip this step entirely.\n-fn activate_allocator(sess: &session::Session, list: &mut DependencyList) {\n-    let mut allocator_found = false;\n+// If an injected dependency was not found then we're guaranteed the\n+// metadata::creader module has injected that dependency (not listed as\n+// a required dependency) in one of the session's field. If this field is not\n+// set then this compilation doesn't actually need the dependency and we can\n+// also skip this step entirely.\n+fn activate_injected_dep(injected: Option<ast::CrateNum>,\n+                         list: &mut DependencyList,\n+                         replaces_injected: &Fn(ast::CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n         let cnum = (i + 1) as ast::CrateNum;\n-        if !sess.cstore.is_allocator(cnum) {\n+        if !replaces_injected(cnum) {\n             continue\n         }\n-        if let Linkage::NotLinked = *slot {\n-            continue\n+        if *slot != Linkage::NotLinked {\n+            return\n         }\n-        allocator_found = true;\n     }\n-    if !allocator_found {\n-        if let Some(injected_allocator) = sess.injected_allocator.get() {\n-            let idx = injected_allocator as usize - 1;\n-            assert_eq!(list[idx], Linkage::NotLinked);\n-            list[idx] = Linkage::Static;\n-        }\n+    if let Some(injected) = injected {\n+        let idx = injected as usize - 1;\n+        assert_eq!(list[idx], Linkage::NotLinked);\n+        list[idx] = Linkage::Static;\n     }\n }\n \n@@ -314,21 +321,75 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n         return\n     }\n     let mut allocator = None;\n+    let mut panic_runtime = None;\n     for (i, linkage) in list.iter().enumerate() {\n-        let cnum = (i + 1) as ast::CrateNum;\n-        if !sess.cstore.is_allocator(cnum) {\n-            continue\n-        }\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n-        if let Some(prev_alloc) = allocator {\n-            let prev_name = sess.cstore.crate_name(prev_alloc);\n-            let cur_name = sess.cstore.crate_name(cnum);\n-            sess.err(&format!(\"cannot link together two \\\n-                               allocators: {} and {}\",\n-                              prev_name, cur_name));\n+        let cnum = (i + 1) as ast::CrateNum;\n+        if sess.cstore.is_allocator(cnum) {\n+            if let Some(prev) = allocator {\n+                let prev_name = sess.cstore.crate_name(prev);\n+                let cur_name = sess.cstore.crate_name(cnum);\n+                sess.err(&format!(\"cannot link together two \\\n+                                   allocators: {} and {}\",\n+                                  prev_name, cur_name));\n+            }\n+            allocator = Some(cnum);\n+        }\n+\n+        if sess.cstore.is_panic_runtime(cnum) {\n+            if let Some((prev, _)) = panic_runtime {\n+                let prev_name = sess.cstore.crate_name(prev);\n+                let cur_name = sess.cstore.crate_name(cnum);\n+                sess.err(&format!(\"cannot link together two \\\n+                                   panic runtimes: {} and {}\",\n+                                  prev_name, cur_name));\n+            }\n+            panic_runtime = Some((cnum, sess.cstore.panic_strategy(cnum)));\n+        }\n+    }\n+\n+    // If we found a panic runtime, then we know by this point that it's the\n+    // only one, but we perform validation here that all the panic strategy\n+    // compilation modes for the whole DAG are valid.\n+    if let Some((cnum, found_strategy)) = panic_runtime {\n+        let desired_strategy = sess.opts.cg.panic.clone();\n+\n+        // First up, validate that our selected panic runtime is indeed exactly\n+        // our same strategy.\n+        if found_strategy != desired_strategy {\n+            sess.err(&format!(\"the linked panic runtime `{}` is \\\n+                               not compiled with this crate's \\\n+                               panic strategy `{}`\",\n+                              sess.cstore.crate_name(cnum),\n+                              desired_strategy.desc()));\n+        }\n+\n+        // Next up, verify that all other crates are compatible with this panic\n+        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n+        // is abort then it's compatible with everything. Otherwise all crates'\n+        // panic strategy must match our own.\n+        for (i, linkage) in list.iter().enumerate() {\n+            if let Linkage::NotLinked = *linkage {\n+                continue\n+            }\n+            if desired_strategy == PanicStrategy::Abort {\n+                continue\n+            }\n+            let cnum = (i + 1) as ast::CrateNum;\n+            let found_strategy = sess.cstore.panic_strategy(cnum);\n+            if desired_strategy == found_strategy {\n+                continue\n+            }\n+\n+            sess.err(&format!(\"the crate `{}` is compiled with the \\\n+                               panic strategy `{}` which is \\\n+                               incompatible with this crate's \\\n+                               strategy of `{}`\",\n+                              sess.cstore.crate_name(cnum),\n+                              found_strategy.desc(),\n+                              desired_strategy.desc()));\n         }\n-        allocator = Some(cnum);\n     }\n }"}, {"sha": "b7dfc86720458c7590f914a613aadec7a2c52ccc", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -10,7 +10,7 @@\n \n //! Validity checking for weak lang items\n \n-use session::config;\n+use session::config::{self, PanicStrategy};\n use session::Session;\n use middle::lang_items;\n \n@@ -75,7 +75,9 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n             config::CrateTypeRlib => false,\n         }\n     });\n-    if !needs_check { return }\n+    if !needs_check {\n+        return\n+    }\n \n     let mut missing = HashSet::new();\n     for cnum in sess.cstore.crates() {\n@@ -84,8 +86,19 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n         }\n     }\n \n+    // If we're not compiling with unwinding, we won't actually need these\n+    // symbols. Other panic runtimes ensure that the relevant symbols are\n+    // available to link things together, but they're never exercised.\n+    let mut whitelisted = HashSet::new();\n+    if sess.opts.cg.panic != PanicStrategy::Unwind {\n+        whitelisted.insert(lang_items::EhPersonalityLangItem);\n+        whitelisted.insert(lang_items::EhUnwindResumeLangItem);\n+    }\n+\n     $(\n-        if missing.contains(&lang_items::$item) && items.$name().is_none() {\n+        if missing.contains(&lang_items::$item) &&\n+           !whitelisted.contains(&lang_items::$item) &&\n+           items.$name().is_none() {\n             sess.err(&format!(\"language item required, but not found: `{}`\",\n                               stringify!($name)));\n "}, {"sha": "7d1d5dba39839030d995996cefd8eb88a3a8bcff", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -317,6 +317,21 @@ impl Passes {\n     }\n }\n \n+#[derive(Clone, PartialEq)]\n+pub enum PanicStrategy {\n+    Unwind,\n+    Abort,\n+}\n+\n+impl PanicStrategy {\n+    pub fn desc(&self) -> &str {\n+        match *self {\n+            PanicStrategy::Unwind => \"unwind\",\n+            PanicStrategy::Abort => \"abort\",\n+        }\n+    }\n+}\n+\n /// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n@@ -402,11 +417,13 @@ macro_rules! options {\n             Some(\"a space-separated list of passes, or `all`\");\n         pub const parse_opt_uint: Option<&'static str> =\n             Some(\"a number\");\n+        pub const parse_panic_strategy: Option<&'static str> =\n+            Some(\"either `panic` or `abort`\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, SomePasses, AllPasses};\n+        use super::{$struct_name, Passes, SomePasses, AllPasses, PanicStrategy};\n \n         $(\n             pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n@@ -510,6 +527,15 @@ macro_rules! options {\n                 }\n             }\n         }\n+\n+        fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"unwind\") => *slot = PanicStrategy::Unwind,\n+                Some(\"abort\") => *slot = PanicStrategy::Abort,\n+                _ => return false\n+            }\n+            true\n+        }\n     }\n ) }\n \n@@ -575,6 +601,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n     inline_threshold: Option<usize> = (None, parse_opt_uint,\n         \"set the inlining threshold for\"),\n+    panic: PanicStrategy = (PanicStrategy::Unwind, parse_panic_strategy,\n+        \"panic strategy to compile crate with\"),\n }\n \n "}, {"sha": "1bea01c4849e756b036d9bd6acff3512c75a4c83", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -12,6 +12,7 @@ use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n+use session::config::PanicStrategy;\n use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n use mir::transform as mir_pass;\n@@ -82,9 +83,11 @@ pub struct Session {\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n \n-    /// The metadata::creader module may inject an allocator dependency if it\n-    /// didn't already find one, and this tracks what was injected.\n+    /// The metadata::creader module may inject an allocator/panic_runtime\n+    /// dependency if it didn't already find one, and this tracks what was\n+    /// injected.\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n+    pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n \n     /// Names of all bang-style macros and syntax extensions\n     /// available in this crate\n@@ -295,7 +298,8 @@ impl Session {\n         self.opts.cg.lto\n     }\n     pub fn no_landing_pads(&self) -> bool {\n-        self.opts.debugging_opts.no_landing_pads\n+        self.opts.debugging_opts.no_landing_pads ||\n+            self.opts.cg.panic == PanicStrategy::Abort\n     }\n     pub fn unstable_options(&self) -> bool {\n         self.opts.debugging_opts.unstable_options\n@@ -502,6 +506,7 @@ pub fn build_session_(sopts: config::Options,\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n+        injected_panic_runtime: Cell::new(None),\n         available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n     };"}, {"sha": "2b972af07ff91f64120c79bd46ba9e620eed9a67", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -250,3 +250,5 @@ pub fn rustc_version() -> String {\n         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n     )\n }\n+\n+pub const tag_panic_strategy: usize = 0x114;"}, {"sha": "190e8552d199a4caa68cecc2aa48b653185e968e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 122, "deletions": 30, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -20,6 +20,7 @@ use loader::{self, CratePaths};\n use rustc::hir::svh::Svh;\n use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n+use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::FnvHashMap;\n@@ -630,6 +631,85 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n+    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n+        // If we're only compiling an rlib, then there's no need to select a\n+        // panic runtime, so we just skip this section entirely.\n+        let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n+            *ct != config::CrateTypeRlib\n+        });\n+        if !any_non_rlib {\n+            info!(\"panic runtime injection skipped, only generating rlib\");\n+            return\n+        }\n+\n+        // If we need a panic runtime, we try to find an existing one here. At\n+        // the same time we perform some general validation of the DAG we've got\n+        // going such as ensuring everything has a compatible panic strategy.\n+        //\n+        // The logic for finding the panic runtime here is pretty much the same\n+        // as the allocator case with the only addition that the panic strategy\n+        // compilation mode also comes into play.\n+        let desired_strategy = self.sess.opts.cg.panic.clone();\n+        let mut runtime_found = false;\n+        let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n+                                                          \"needs_panic_runtime\");\n+        self.cstore.iter_crate_data(|cnum, data| {\n+            needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n+                // Inject a dependency from all #![needs_panic_runtime] to this\n+                // #![panic_runtime] crate.\n+                self.inject_dependency_if(cnum, \"a panic runtime\",\n+                                          &|data| data.needs_panic_runtime());\n+                runtime_found = runtime_found || data.explicitly_linked.get();\n+            }\n+        });\n+\n+        // If an explicitly linked and matching panic runtime was found, or if\n+        // we just don't need one at all, then we're done here and there's\n+        // nothing else to do.\n+        if !needs_panic_runtime || runtime_found {\n+            return\n+        }\n+\n+        // By this point we know that we (a) need a panic runtime and (b) no\n+        // panic runtime was explicitly linked. Here we just load an appropriate\n+        // default runtime for our panic strategy and then inject the\n+        // dependencies.\n+        //\n+        // We may resolve to an already loaded crate (as the crate may not have\n+        // been explicitly linked prior to this) and we may re-inject\n+        // dependencies again, but both of those situations are fine.\n+        //\n+        // Also note that we have yet to perform validation of the crate graph\n+        // in terms of everyone has a compatible panic runtime format, that's\n+        // performed later as part of the `dependency_format` module.\n+        let name = match desired_strategy {\n+            PanicStrategy::Unwind => \"panic_unwind\",\n+            PanicStrategy::Abort => \"panic_abort\",\n+        };\n+        info!(\"panic runtime not found -- loading {}\", name);\n+\n+        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n+                                                 codemap::DUMMY_SP,\n+                                                 PathKind::Crate, false);\n+\n+        // Sanity check the loaded crate to ensure it is indeed a panic runtime\n+        // and the panic strategy is indeed what we thought it was.\n+        if !data.is_panic_runtime() {\n+            self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n+                                   name));\n+        }\n+        if data.panic_strategy() != desired_strategy {\n+            self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n+                                    strategy `{}`\",\n+                                   name, desired_strategy.desc()));\n+        }\n+\n+        self.sess.injected_panic_runtime.set(Some(cnum));\n+        self.inject_dependency_if(cnum, \"a panic runtime\",\n+                                  &|data| data.needs_panic_runtime());\n+    }\n+\n     fn inject_allocator_crate(&mut self) {\n         // Make sure that we actually need an allocator, if none of our\n         // dependencies need one then we definitely don't!\n@@ -641,8 +721,9 @@ impl<'a> CrateReader<'a> {\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_allocator = needs_allocator || data.needs_allocator();\n             if data.is_allocator() {\n-                debug!(\"{} required by rlib and is an allocator\", data.name());\n-                self.inject_allocator_dependency(cnum);\n+                info!(\"{} required by rlib and is an allocator\", data.name());\n+                self.inject_dependency_if(cnum, \"an allocator\",\n+                                          &|data| data.needs_allocator());\n                 found_required_allocator = found_required_allocator ||\n                     data.explicitly_linked.get();\n             }\n@@ -692,58 +773,68 @@ impl<'a> CrateReader<'a> {\n                                                  codemap::DUMMY_SP,\n                                                  PathKind::Crate, false);\n \n-        // To ensure that the `-Z allocation-crate=foo` option isn't abused, and\n-        // to ensure that the allocator is indeed an allocator, we verify that\n-        // the crate loaded here is indeed tagged #![allocator].\n+        // Sanity check the crate we loaded to ensure that it is indeed an\n+        // allocator.\n         if !data.is_allocator() {\n             self.sess.err(&format!(\"the allocator crate `{}` is not tagged \\\n                                     with #![allocator]\", data.name()));\n         }\n \n         self.sess.injected_allocator.set(Some(cnum));\n-        self.inject_allocator_dependency(cnum);\n+        self.inject_dependency_if(cnum, \"an allocator\",\n+                                  &|data| data.needs_allocator());\n     }\n \n-    fn inject_allocator_dependency(&self, allocator: ast::CrateNum) {\n+    fn inject_dependency_if(&self,\n+                            krate: ast::CrateNum,\n+                            what: &str,\n+                            needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n+        // don't perform this validation if the session has errors, as one of\n+        // those errors may indicate a circular dependency which could cause\n+        // this to stack overflow.\n+        if self.sess.has_errors() {\n+            return\n+        }\n+\n         // Before we inject any dependencies, make sure we don't inject a\n-        // circular dependency by validating that this allocator crate doesn't\n-        // transitively depend on any `#![needs_allocator]` crates.\n-        validate(self, allocator, allocator);\n-\n-        // All crates tagged with `needs_allocator` do not explicitly depend on\n-        // the allocator selected for this compile, but in order for this\n-        // compilation to be successfully linked we need to inject a dependency\n-        // (to order the crates on the command line correctly).\n-        //\n-        // Here we inject a dependency from all crates with #![needs_allocator]\n-        // to the crate tagged with #![allocator] for this compilation unit.\n+        // circular dependency by validating that this crate doesn't\n+        // transitively depend on any crates satisfying `needs_dep`.\n+        validate(self, krate, krate, what, needs_dep);\n+\n+        // All crates satisfying `needs_dep` do not explicitly depend on the\n+        // crate provided for this compile, but in order for this compilation to\n+        // be successfully linked we need to inject a dependency (to order the\n+        // crates on the command line correctly).\n         self.cstore.iter_crate_data(|cnum, data| {\n-            if !data.needs_allocator() {\n+            if !needs_dep(data) {\n                 return\n             }\n \n-            info!(\"injecting a dep from {} to {}\", cnum, allocator);\n+            info!(\"injecting a dep from {} to {}\", cnum, krate);\n             let mut cnum_map = data.cnum_map.borrow_mut();\n             let remote_cnum = cnum_map.len() + 1;\n-            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, allocator);\n+            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, krate);\n             assert!(prev.is_none());\n         });\n \n-        fn validate(me: &CrateReader, krate: ast::CrateNum,\n-                    allocator: ast::CrateNum) {\n+        fn validate(me: &CrateReader,\n+                    krate: ast::CrateNum,\n+                    root: ast::CrateNum,\n+                    what: &str,\n+                    needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n             let data = me.cstore.get_crate_data(krate);\n-            if data.needs_allocator() {\n+            if needs_dep(&data) {\n                 let krate_name = data.name();\n-                let data = me.cstore.get_crate_data(allocator);\n-                let alloc_name = data.name();\n-                me.sess.err(&format!(\"the allocator crate `{}` cannot depend \\\n-                                      on a crate that needs an allocator, but \\\n-                                      it depends on `{}`\", alloc_name,\n+                let data = me.cstore.get_crate_data(root);\n+                let root_name = data.name();\n+                me.sess.err(&format!(\"the crate `{}` cannot depend \\\n+                                      on a crate that needs {}, but \\\n+                                      it depends on `{}`\", root_name, what,\n                                       krate_name));\n             }\n \n             for (_, &dep) in data.cnum_map.borrow().iter() {\n-                validate(me, dep, allocator);\n+                validate(me, dep, root, what, needs_dep);\n             }\n         }\n     }\n@@ -774,6 +865,7 @@ impl<'a> LocalCrateReader<'a> {\n         self.process_crate(self.krate);\n         visit::walk_crate(self, self.krate);\n         self.creader.inject_allocator_crate();\n+        self.creader.inject_panic_runtime(self.krate);\n \n         if log_enabled!(log::INFO) {\n             dump_crates(&self.cstore);"}, {"sha": "e4a0731be559a6fe4f2bf026838f021669854ad4", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -24,6 +24,7 @@ use rustc::hir::map as hir_map;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::session::config::PanicStrategy;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -306,6 +307,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_allocator()\n     }\n \n+    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).is_panic_runtime()\n+    }\n+\n+    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+        self.get_crate_data(cnum).panic_strategy()\n+    }\n+\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n     {\n         decoder::get_crate_attributes(self.get_crate_data(cnum).data())"}, {"sha": "04b6e1c42b98a010331699f8ef8654958ab8581b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -23,6 +23,7 @@ use loader;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{ExternCrate};\n+use rustc::session::config::PanicStrategy;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -281,6 +282,20 @@ impl crate_metadata {\n         let attrs = decoder::get_crate_attributes(self.data());\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n+\n+    pub fn is_panic_runtime(&self) -> bool {\n+        let attrs = decoder::get_crate_attributes(self.data());\n+        attr::contains_name(&attrs, \"panic_runtime\")\n+    }\n+\n+    pub fn needs_panic_runtime(&self) -> bool {\n+        let attrs = decoder::get_crate_attributes(self.data());\n+        attr::contains_name(&attrs, \"needs_panic_runtime\")\n+    }\n+\n+    pub fn panic_strategy(&self) -> PanicStrategy {\n+        decoder::get_panic_strategy(self.data())\n+    }\n }\n \n impl MetadataBlob {"}, {"sha": "72fbbf8051533911f0fa474f3957bf04f46f8121", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -27,6 +27,7 @@ use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n+use rustc::session::config::PanicStrategy;\n \n use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n@@ -1760,3 +1761,13 @@ pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n     debug!(\"def_path(id={:?})\", id);\n     hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent))\n }\n+\n+pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {\n+    let crate_doc = rbml::Doc::new(data);\n+    let strat_doc = reader::get_doc(crate_doc, tag_panic_strategy);\n+    match reader::doc_as_u8(strat_doc) {\n+        b'U' => PanicStrategy::Unwind,\n+        b'A' => PanicStrategy::Abort,\n+        b => panic!(\"unknown panic strategy in metadata: {}\", b),\n+    }\n+}"}, {"sha": "4a0c3bbf18702f29e89d6bd5bd68482623f76d69", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -33,7 +33,7 @@ use rustc::ty::util::IntTypeExt;\n \n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n-use rustc::session::config;\n+use rustc::session::config::{self, PanicStrategy};\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use rustc_serialize::Encodable;\n@@ -1828,6 +1828,17 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     }\n }\n \n+fn encode_panic_strategy(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n+    match ecx.tcx.sess.opts.cg.panic {\n+        PanicStrategy::Unwind => {\n+            rbml_w.wr_tagged_u8(tag_panic_strategy, b'U');\n+        }\n+        PanicStrategy::Abort => {\n+            rbml_w.wr_tagged_u8(tag_panic_strategy, b'A');\n+        }\n+    }\n+}\n+\n // NB: Increment this as you change the metadata encoding version.\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n@@ -1915,6 +1926,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n     encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.crate_disambiguator.get().as_str());\n     encode_dylib_dependency_formats(rbml_w, &ecx);\n+    encode_panic_strategy(rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_attributes(rbml_w, &krate.attrs);"}, {"sha": "cbb4be5b30022b7cc9557c43d9a7b707fe4af450", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -1829,7 +1829,9 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     let _icx = push_ctxt(\"trans_closure\");\n-    attributes::emit_uwtable(llfndecl, true);\n+    if !ccx.sess().no_landing_pads() {\n+        attributes::emit_uwtable(llfndecl, true);\n+    }\n \n     debug!(\"trans_closure(..., {})\", instance);\n "}, {"sha": "2b7345453d7c415dac74124ed332ce91fbd6d58a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -463,20 +463,18 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         // landing pads as \"landing pads for SEH\".\n         let ccx = self.ccx;\n         let tcx = ccx.tcx();\n-        let target = &ccx.sess().target.target;\n         match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n                 Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n-            _ => if let Some(llpersonality) = ccx.eh_personality().get() {\n-                llpersonality\n-            } else {\n-                let name = if !base::wants_msvc_seh(ccx.sess()) {\n-                    \"rust_eh_personality\"\n-                } else if target.arch == \"x86\" {\n-                    \"_except_handler3\"\n+            _ => {\n+                if let Some(llpersonality) = ccx.eh_personality().get() {\n+                    return llpersonality\n+                }\n+                let name = if base::wants_msvc_seh(ccx.sess()) {\n+                    \"__CxxFrameHandler3\"\n                 } else {\n-                    \"__C_specific_handler\"\n+                    \"rust_eh_personality\"\n                 };\n                 let fty = Type::variadic_func(&[], &Type::i32(ccx));\n                 let f = declare::declare_cfn(ccx, name, fty);"}, {"sha": "e1d5a3f7ee1577748dae1af6c23211c6fe5e2328", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 101, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -1096,9 +1096,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // We're generating an IR snippet that looks like:\n         //\n         //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca i8*\n-        //      call @llvm.localescape(%slot)\n-        //      store %ptr, %slot\n+        //      %slot = alloca i64*\n         //      invoke %func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n@@ -1108,36 +1106,54 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         //      %cs = catchswitch within none [%catchpad] unwind to caller\n         //\n         //   catchpad:\n-        //      %tok = catchpad within %cs [%rust_try_filter]\n+        //      %tok = catchpad within %cs [%type_descriptor, 0, %slot]\n+        //      %ptr[0] = %slot[0]\n+        //      %ptr[1] = %slot[1]\n         //      catchret from %tok to label %caught\n         //\n         //   caught:\n         //      ret i32 1\n         //   }\n         //\n-        // This structure follows the basic usage of the instructions in LLVM\n-        // (see their documentation/test cases for examples), but a\n-        // perhaps-surprising part here is the usage of the `localescape`\n-        // intrinsic. This is used to allow the filter function (also generated\n-        // here) to access variables on the stack of this intrinsic. This\n-        // ability enables us to transfer information about the exception being\n-        // thrown to this point, where we're catching the exception.\n+        // This structure follows the basic usage of throw/try/catch in LLVM.\n+        // For example, compile this C++ snippet to see what LLVM generates:\n+        //\n+        //      #include <stdint.h>\n+        //\n+        //      int bar(void (*foo)(void), uint64_t *ret) {\n+        //          try {\n+        //              foo();\n+        //              return 0;\n+        //          } catch(uint64_t a[2]) {\n+        //              ret[0] = a[0];\n+        //              ret[1] = a[1];\n+        //              return 1;\n+        //          }\n+        //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let slot = Alloca(bcx, Type::i8p(ccx), \"slot\");\n-        let localescape = ccx.get_intrinsic(&\"llvm.localescape\");\n-        Call(bcx, localescape, &[slot], dloc);\n-        Store(bcx, local_ptr, slot);\n+        let i64p = Type::i64(ccx).ptr_to();\n+        let slot = Alloca(bcx, i64p, \"slot\");\n         Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, dloc);\n \n         Ret(normal, C_i32(ccx, 0), dloc);\n \n         let cs = CatchSwitch(catchswitch, None, None, 1);\n         AddHandler(catchswitch, cs, catchpad.llbb);\n \n-        let filter = generate_filter_fn(bcx.fcx, bcx.fcx.llfn);\n-        let filter = BitCast(catchpad, filter, Type::i8p(ccx));\n-        let tok = CatchPad(catchpad, cs, &[filter]);\n+        let tcx = ccx.tcx();\n+        let tydesc = match tcx.lang_items.msvc_try_filter() {\n+            Some(did) => ::consts::get_static(ccx, did).to_llref(),\n+            None => bug!(\"msvc_try_filter not defined\"),\n+        };\n+        let tok = CatchPad(catchpad, cs, &[tydesc, C_i32(ccx, 0), slot]);\n+        let addr = Load(catchpad, slot);\n+        let arg1 = Load(catchpad, addr);\n+        let val1 = C_i32(ccx, 1);\n+        let arg2 = Load(catchpad, InBoundsGEP(catchpad, addr, &[val1]));\n+        let local_ptr = BitCast(catchpad, local_ptr, i64p);\n+        Store(catchpad, arg1, local_ptr);\n+        Store(catchpad, arg2, InBoundsGEP(catchpad, local_ptr, &[val1]));\n         CatchRet(catchpad, tok, caught.llbb);\n \n         Ret(caught, C_i32(ccx, 1), dloc);\n@@ -1289,89 +1305,6 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     return rust_try\n }\n \n-// For MSVC-style exceptions (SEH), the compiler generates a filter function\n-// which is used to determine whether an exception is being caught (e.g. if it's\n-// a Rust exception or some other).\n-//\n-// This function is used to generate said filter function. The shim generated\n-// here is actually just a thin wrapper to call the real implementation in the\n-// standard library itself. For reasons as to why, see seh.rs in the standard\n-// library.\n-fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                rust_try_fn: ValueRef)\n-                                -> ValueRef {\n-    let ccx = fcx.ccx;\n-    let tcx = ccx.tcx();\n-    let dloc = DebugLoc::None;\n-\n-    let rust_try_filter = match tcx.lang_items.msvc_try_filter() {\n-        Some(did) => {\n-            Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n-        }\n-        None => bug!(\"msvc_try_filter not defined\"),\n-    };\n-\n-    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n-    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-\n-    let frameaddress = ccx.get_intrinsic(&\"llvm.frameaddress\");\n-    let recoverfp = ccx.get_intrinsic(&\"llvm.x86.seh.recoverfp\");\n-    let localrecover = ccx.get_intrinsic(&\"llvm.localrecover\");\n-\n-    // On all platforms, once we have the EXCEPTION_POINTERS handle as well as\n-    // the base pointer, we follow the standard layout of:\n-    //\n-    //      block:\n-    //          %parentfp = call i8* llvm.x86.seh.recoverfp(@rust_try_fn, %bp)\n-    //          %arg = call i8* llvm.localrecover(@rust_try_fn, %parentfp, 0)\n-    //          %ret = call i32 @the_real_filter_function(%ehptrs, %arg)\n-    //          ret i32 %ret\n-    //\n-    // The recoverfp intrinsic is used to recover the frame pointer of the\n-    // `rust_try_fn` function, which is then in turn passed to the\n-    // `localrecover` intrinsic (pairing with the `localescape` intrinsic\n-    // mentioned above). Putting all this together means that we now have a\n-    // handle to the arguments passed into the `try` function, allowing writing\n-    // to the stack over there.\n-    //\n-    // For more info, see seh.rs in the standard library.\n-    let do_trans = |bcx: Block, ehptrs, base_pointer| {\n-        let rust_try_fn = BitCast(bcx, rust_try_fn, Type::i8p(ccx));\n-        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer], dloc);\n-        let arg = Call(bcx, localrecover,\n-                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], dloc);\n-        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], dloc);\n-        Ret(bcx, ret, dloc);\n-    };\n-\n-    if ccx.tcx().sess.target.target.arch == \"x86\" {\n-        // On x86 the filter function doesn't actually receive any arguments.\n-        // Instead the %ebp register contains some contextual information.\n-        //\n-        // Unfortunately I don't know of any great documentation as to what's\n-        // going on here, all I can say is that there's a few tests cases in\n-        // LLVM's test suite which follow this pattern of instructions, so we\n-        // just do the same.\n-        gen_fn(fcx, \"__rustc_try_filter\", vec![], output, &mut |bcx| {\n-            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], dloc);\n-            let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n-            let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n-            do_trans(bcx, exn, ebp);\n-        })\n-    } else if ccx.tcx().sess.target.target.arch == \"x86_64\" {\n-        // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n-        // are passed in as arguments to the filter function, so we just pass\n-        // those along.\n-        gen_fn(fcx, \"__rustc_try_filter\", vec![i8p, i8p], output, &mut |bcx| {\n-            let exn = llvm::get_param(bcx.fcx.llfn, 0);\n-            let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n-            do_trans(bcx, exn, rbp);\n-        })\n-    } else {\n-        bug!(\"unknown target to generate a filter function\")\n-    }\n-}\n-\n fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }"}, {"sha": "6d33fb311cff05d16cd87abb30b3630725cfafbb", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -14,11 +14,14 @@ test = false\n alloc = { path = \"../liballoc\" }\n alloc_jemalloc = { path = \"../liballoc_jemalloc\", optional = true }\n alloc_system = { path = \"../liballoc_system\" }\n+panic_unwind = { path = \"../libpanic_unwind\" }\n+panic_abort = { path = \"../libpanic_abort\" }\n collections = { path = \"../libcollections\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n rand = { path = \"../librand\" }\n rustc_unicode = { path = \"../librustc_unicode\" }\n+unwind = { path = \"../libunwind\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "e879d440643f90d8e982d69749518f3cfb35c13c", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -28,37 +28,21 @@ fn main() {\n     }\n \n     if target.contains(\"linux\") {\n-        if target.contains(\"musl\") && (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n-            println!(\"cargo:rustc-link-lib=static=unwind\");\n-        } else if target.contains(\"android\") {\n+        if target.contains(\"android\") {\n             println!(\"cargo:rustc-link-lib=dl\");\n             println!(\"cargo:rustc-link-lib=log\");\n             println!(\"cargo:rustc-link-lib=gcc\");\n         } else {\n             println!(\"cargo:rustc-link-lib=dl\");\n             println!(\"cargo:rustc-link-lib=rt\");\n             println!(\"cargo:rustc-link-lib=pthread\");\n-            println!(\"cargo:rustc-link-lib=gcc_s\");\n         }\n     } else if target.contains(\"freebsd\") {\n         println!(\"cargo:rustc-link-lib=execinfo\");\n         println!(\"cargo:rustc-link-lib=pthread\");\n-        println!(\"cargo:rustc-link-lib=gcc_s\");\n     } else if target.contains(\"dragonfly\") || target.contains(\"bitrig\") ||\n               target.contains(\"netbsd\") || target.contains(\"openbsd\") {\n         println!(\"cargo:rustc-link-lib=pthread\");\n-\n-        if target.contains(\"rumprun\") {\n-            println!(\"cargo:rustc-link-lib=unwind\");\n-        } else if target.contains(\"netbsd\") {\n-            println!(\"cargo:rustc-link-lib=gcc_s\");\n-        } else if target.contains(\"openbsd\") {\n-            println!(\"cargo:rustc-link-lib=gcc\");\n-        } else if target.contains(\"bitrig\") {\n-            println!(\"cargo:rustc-link-lib=c++abi\");\n-        } else if target.contains(\"dragonfly\") {\n-            println!(\"cargo:rustc-link-lib=gcc_pic\");\n-        }\n     } else if target.contains(\"apple-darwin\") {\n         println!(\"cargo:rustc-link-lib=System\");\n     } else if target.contains(\"apple-ios\") {\n@@ -67,9 +51,6 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=framework=Security\");\n         println!(\"cargo:rustc-link-lib=framework=Foundation\");\n     } else if target.contains(\"windows\") {\n-        if target.contains(\"windows-gnu\") {\n-            println!(\"cargo:rustc-link-lib=gcc_eh\");\n-        }\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");\n         println!(\"cargo:rustc-link-lib=userenv\");"}, {"sha": "8f41bdf39e97a0c054f1b1645489781e908c95c8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -245,6 +245,7 @@\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n+#![feature(panic_unwind)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n #![feature(raw)]\n@@ -283,6 +284,13 @@\n #![allow(unused_features)] // std may use features in a platform-specific way\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+// FIXME(stage0): after a snapshot, move needs_panic_runtime up above and remove\n+//                this `extern crate` declaration and feature(panic_unwind)\n+#![cfg_attr(not(stage0), needs_panic_runtime)]\n+#![cfg_attr(not(stage0), feature(needs_panic_runtime))]\n+#[cfg(stage0)]\n+extern crate panic_unwind as __please_just_link_me_dont_reference_me;\n+\n #[cfg(test)] extern crate test;\n \n // We want to reexport a few macros from core but libcore has already been\n@@ -301,6 +309,9 @@ extern crate alloc;\n extern crate rustc_unicode;\n extern crate libc;\n \n+// We always need an unwinder currently for backtraces\n+extern crate unwind;\n+\n #[cfg(stage0)]\n extern crate alloc_system;\n "}, {"sha": "d69789cedaf2c0e39454c999c28715c8d31b784c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -17,9 +17,9 @@\n /// The entry point for panic of Rust threads.\n ///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n-/// unwind and panic entirely. Each thread's panic can be reaped as the\n-/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n-/// the value which is transmitted.\n+/// panic entirely. Each thread's panic can be reaped as the `Box<Any>` type,\n+/// and the single-argument form of the `panic!` macro will be the value which\n+/// is transmitted.\n ///\n /// The multi-argument form of this macro panics with a string and has the\n /// `format!` syntax for building a string.\n@@ -41,14 +41,14 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_unwind($msg, {\n+        $crate::rt::begin_panic($msg, {\n             // static requires less code at runtime, more constant data\n             static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n             &_FILE_LINE\n         })\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_unwind_fmt(format_args!($fmt, $($arg)+), {\n+        $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+), {\n             // The leading _'s are to avoid dead code warnings if this is\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have"}, {"sha": "9a195d93afde4e4df9312419945e782b532b3e98", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -16,10 +16,10 @@ use any::Any;\n use boxed::Box;\n use cell::UnsafeCell;\n use ops::{Deref, DerefMut};\n+use panicking;\n use ptr::{Unique, Shared};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock};\n-use sys_common::unwind;\n use thread::Result;\n \n #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n@@ -383,12 +383,9 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n /// ```\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n-    let mut result = None;\n     unsafe {\n-        let result = &mut result;\n-        unwind::try(move || *result = Some(f()))?\n+        panicking::try(f)\n     }\n-    Ok(result.unwrap())\n }\n \n /// Deprecated, renamed to `catch_unwind`\n@@ -425,7 +422,7 @@ pub fn recover<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n /// ```\n #[stable(feature = \"resume_unwind\", since = \"1.9.0\")]\n pub fn resume_unwind(payload: Box<Any + Send>) -> ! {\n-    unwind::rust_panic(payload)\n+    panicking::rust_panic(payload)\n }\n \n /// Deprecated, use resume_unwind instead"}, {"sha": "b85d4b330a6e336d9107747d45624b1108eb8d23", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 186, "deletions": 31, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -8,13 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of various bits and pieces of the `panic!` macro and\n+//! associated runtime pieces.\n+//!\n+//! Specifically, this module contains the implementation of:\n+//!\n+//! * Panic hooks\n+//! * Executing a panic up to doing the actual implementation\n+//! * Shims around \"try\"\n+\n use prelude::v1::*;\n use io::prelude::*;\n \n use any::Any;\n use cell::Cell;\n use cell::RefCell;\n+use fmt;\n use intrinsics;\n+use mem;\n+use raw;\n use sync::StaticRwLock;\n use sync::atomic::{AtomicBool, Ordering};\n use sys::stdio::Stderr;\n@@ -23,14 +35,34 @@ use sys_common::thread_info;\n use sys_common::util;\n use thread;\n \n-thread_local! { pub static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n-\n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n+thread_local! { pub static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+\n+// Binary interface to the panic runtime that the standard library depends on.\n+//\n+// The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n+// RFC 1513) to indicate that it requires some other crate tagged with\n+// `#![panic_runtime]` to exist somewhere. Each panic runtime is intended to\n+// implement these symbols (with the same signatures) so we can get matched up\n+// to them.\n+//\n+// One day this may look a little less ad-hoc with the compiler helping out to\n+// hook up these functions, but it is not this day!\n+#[allow(improper_ctypes)]\n+extern {\n+    fn __rust_maybe_catch_panic(f: fn(*mut u8),\n+                                data: *mut u8,\n+                                data_ptr: *mut usize,\n+                                vtable_ptr: *mut usize) -> u32;\n+    #[unwind]\n+    fn __rust_start_panic(data: usize, vtable: usize) -> u32;\n+}\n+\n #[derive(Copy, Clone)]\n enum Hook {\n     Default,\n@@ -57,7 +89,7 @@ static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n /// # Panics\n ///\n /// Panics if called from a panicking thread.\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n     if thread::panicking() {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n@@ -82,7 +114,7 @@ pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n /// # Panics\n ///\n /// Panics if called from a panicking thread.\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n     if thread::panicking() {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n@@ -102,7 +134,7 @@ pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n }\n \n /// A struct providing information about a panic.\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n pub struct PanicInfo<'a> {\n     payload: &'a (Any + Send),\n     location: Location<'a>,\n@@ -112,7 +144,7 @@ impl<'a> PanicInfo<'a> {\n     /// Returns the payload associated with the panic.\n     ///\n     /// This will commonly, but not always, be a `&'static str` or `String`.\n-    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n     pub fn payload(&self) -> &(Any + Send) {\n         self.payload\n     }\n@@ -122,35 +154,35 @@ impl<'a> PanicInfo<'a> {\n     ///\n     /// This method will currently always return `Some`, but this may change\n     /// in future versions.\n-    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n     pub fn location(&self) -> Option<&Location> {\n         Some(&self.location)\n     }\n }\n \n /// A struct containing information about the location of a panic.\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n pub struct Location<'a> {\n     file: &'a str,\n     line: u32,\n }\n \n impl<'a> Location<'a> {\n     /// Returns the name of the source file from which the panic originated.\n-    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n     pub fn file(&self) -> &str {\n         self.file\n     }\n \n     /// Returns the line number from which the panic originated.\n-    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n     pub fn line(&self) -> u32 {\n         self.line\n     }\n }\n \n fn default_hook(info: &PanicInfo) {\n-    let panics = PANIC_COUNT.with(|s| s.get());\n+    let panics = PANIC_COUNT.with(|c| c.get());\n \n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n@@ -195,41 +227,151 @@ fn default_hook(info: &PanicInfo) {\n     }\n }\n \n-pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n-    let panics = PANIC_COUNT.with(|s| {\n-        let count = s.get() + 1;\n-        s.set(count);\n-        count\n+/// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n+pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n+    let mut slot = None;\n+    let mut f = Some(f);\n+    let ret = PANIC_COUNT.with(|s| {\n+        let prev = s.get();\n+        s.set(0);\n+\n+        let mut to_run = || {\n+            slot = Some(f.take().unwrap()());\n+        };\n+        let fnptr = get_call(&mut to_run);\n+        let dataptr = &mut to_run as *mut _ as *mut u8;\n+        let mut any_data = 0;\n+        let mut any_vtable = 0;\n+        let fnptr = mem::transmute::<fn(&mut _), fn(*mut u8)>(fnptr);\n+        let r = __rust_maybe_catch_panic(fnptr,\n+                                         dataptr,\n+                                         &mut any_data,\n+                                         &mut any_vtable);\n+        s.set(prev);\n+\n+        if r == 0 {\n+            Ok(())\n+        } else {\n+            Err(mem::transmute(raw::TraitObject {\n+                data: any_data as *mut _,\n+                vtable: any_vtable as *mut _,\n+            }))\n+        }\n+    });\n+\n+    return ret.map(|()| {\n+        slot.take().unwrap()\n     });\n \n-    // If this is the third nested call, on_panic triggered the last panic,\n-    // otherwise the double-panic check would have aborted the process.\n-    // Even if it is likely that on_panic was unable to log the backtrace,\n-    // abort immediately to avoid infinite recursion, so that attaching a\n-    // debugger provides a useable stacktrace.\n-    if panics >= 3 {\n+    fn get_call<F: FnMut()>(_: &mut F) -> fn(&mut F) {\n+        call\n+    }\n+\n+    fn call<F: FnMut()>(f: &mut F) {\n+        f()\n+    }\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+pub fn panicking() -> bool {\n+    PANIC_COUNT.with(|c| c.get() != 0)\n+}\n+\n+/// Entry point of panic from the libcore crate.\n+#[cfg(not(test))]\n+#[lang = \"panic_fmt\"]\n+#[unwind]\n+pub extern fn rust_begin_panic(msg: fmt::Arguments,\n+                               file: &'static str,\n+                               line: u32) -> ! {\n+    begin_panic_fmt(&msg, &(file, line))\n+}\n+\n+/// The entry point for panicking with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[unstable(feature = \"libstd_sys_internals\",\n+           reason = \"used by the panic! macro\",\n+           issue = \"0\")]\n+#[inline(never)] #[cold]\n+pub fn begin_panic_fmt(msg: &fmt::Arguments,\n+                       file_line: &(&'static str, u32)) -> ! {\n+    use fmt::Write;\n+\n+    // We do two allocations here, unfortunately. But (a) they're\n+    // required with the current scheme, and (b) we don't handle\n+    // panic + OOM properly anyway (see comment in begin_panic\n+    // below).\n+\n+    let mut s = String::new();\n+    let _ = s.write_fmt(*msg);\n+    begin_panic(s, file_line)\n+}\n+\n+/// This is the entry point of panicking for panic!() and assert!().\n+#[unstable(feature = \"libstd_sys_internals\",\n+           reason = \"used by the panic! macro\",\n+           issue = \"0\")]\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    rust_panic_with_hook(Box::new(msg), file_line)\n+}\n+\n+/// Executes the primary logic for a panic, including checking for recursive\n+/// panics and panic hooks.\n+///\n+/// This is the entry point or panics from libcore, formatted panics, and\n+/// `Box<Any>` panics. Here we'll verify that we're not panicking recursively,\n+/// run panic hooks, and then delegate to the actual implementation of panics.\n+#[inline(never)]\n+#[cold]\n+fn rust_panic_with_hook(msg: Box<Any + Send>,\n+                        file_line: &(&'static str, u32)) -> ! {\n+    let (file, line) = *file_line;\n+\n+    let panics = PANIC_COUNT.with(|c| {\n+        let prev = c.get();\n+        c.set(prev + 1);\n+        prev\n+    });\n+\n+    // If this is the third nested call (e.g. panics == 2, this is 0-indexed),\n+    // the panic hook probably triggered the last panic, otherwise the\n+    // double-panic check would have aborted the process. In this case abort the\n+    // process real quickly as we don't want to try calling it again as it'll\n+    // probably just panic again.\n+    if panics > 1 {\n         util::dumb_print(format_args!(\"thread panicked while processing \\\n                                        panic. aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n \n-    let info = PanicInfo {\n-        payload: obj,\n-        location: Location {\n-            file: file,\n-            line: line,\n-        },\n-    };\n-\n     unsafe {\n+        let info = PanicInfo {\n+            payload: &*msg,\n+            location: Location {\n+                file: file,\n+                line: line,\n+            },\n+        };\n         let _lock = HOOK_LOCK.read();\n         match HOOK {\n             Hook::Default => default_hook(&info),\n             Hook::Custom(ptr) => (*ptr)(&info),\n         }\n     }\n \n-    if panics >= 2 {\n+    if panics > 0 {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n@@ -238,4 +380,17 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n                                        aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n+\n+    rust_panic(msg)\n+}\n+\n+/// A private no-mangle function on which to slap yer breakpoints.\n+#[no_mangle]\n+#[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\n+pub fn rust_panic(msg: Box<Any + Send>) -> ! {\n+    let code = unsafe {\n+        let obj = mem::transmute::<_, raw::TraitObject>(msg);\n+        __rust_start_panic(obj.data as usize, obj.vtable as usize)\n+    };\n+    rtabort!(\"failed to initiate panic, error {}\", code)\n }"}, {"sha": "6eee4ee9bbe5f66edc86d89c8fe451984025356e", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -25,12 +25,10 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-pub use sys_common::unwind::{begin_unwind, begin_unwind_fmt};\n+pub use panicking::{begin_panic, begin_panic_fmt};\n \n-// Rust runtime's startup objects depend on these symbols, so they must be public.\n-// Since sys_common isn't public, we have to re-export them here.\n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n-pub use sys_common::unwind::imp::eh_frame_registry::*;\n+#[cfg(stage0)]\n+pub use panicking::begin_panic as begin_unwind;\n \n #[cfg(not(test))]\n #[lang = \"start\"]"}, {"sha": "c9279883ae59d8e2bb32c2a0d32bfee6c73b9800", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -30,9 +30,7 @@ pub mod args;\n pub mod at_exit_imp;\n pub mod backtrace;\n pub mod condvar;\n-pub mod dwarf;\n pub mod io;\n-pub mod libunwind;\n pub mod mutex;\n pub mod net;\n pub mod poison;\n@@ -41,7 +39,6 @@ pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local;\n-pub mod unwind;\n pub mod util;\n pub mod wtf8;\n "}, {"sha": "527c2e63030d59bc9ddf0a82bba19112e6da53a9", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1,241 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of Rust stack unwinding\n-//!\n-//! For background on exception handling and stack unwinding please see\n-//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n-//! documents linked from it.\n-//! These are also good reads:\n-//!     http://mentorembedded.github.io/cxx-abi/abi-eh.html\n-//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n-//!     http://www.airs.com/blog/index.php?s=exception+frames\n-//!\n-//! ## A brief summary\n-//!\n-//! Exception handling happens in two phases: a search phase and a cleanup phase.\n-//!\n-//! In both phases the unwinder walks stack frames from top to bottom using\n-//! information from the stack frame unwind sections of the current process's\n-//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n-//! dynamic library).\n-//!\n-//! For each stack frame, it invokes the associated \"personality routine\", whose\n-//! address is also stored in the unwind info section.\n-//!\n-//! In the search phase, the job of a personality routine is to examine exception\n-//! object being thrown, and to decide whether it should be caught at that stack\n-//! frame.  Once the handler frame has been identified, cleanup phase begins.\n-//!\n-//! In the cleanup phase, the unwinder invokes each personality routine again.\n-//! This time it decides which (if any) cleanup code needs to be run for\n-//! the current stack frame.  If so, the control is transferred to a special branch\n-//! in the function body, the \"landing pad\", which invokes destructors, frees memory,\n-//! etc.  At the end of the landing pad, control is transferred back to the unwinder\n-//! and unwinding resumes.\n-//!\n-//! Once stack has been unwound down to the handler frame level, unwinding stops\n-//! and the last personality routine transfers control to the catch block.\n-//!\n-//! ## `eh_personality` and `eh_unwind_resume`\n-//!\n-//! These language items are used by the compiler when generating unwind info.\n-//! The first one is the personality routine described above.  The second one\n-//! allows compilation target to customize the process of resuming unwind at the\n-//! end of the landing pads.  `eh_unwind_resume` is used only if `custom_unwind_resume`\n-//! flag in the target options is set.\n-//!\n-//! ## Frame unwind info registration\n-//!\n-//! Each module's image contains a frame unwind info section (usually \".eh_frame\").\n-//! When a module is loaded/unloaded into the process, the unwinder must be informed\n-//! about the location of this section in memory. The methods of achieving that vary\n-//! by the platform.\n-//! On some (e.g. Linux), the unwinder can discover unwind info sections on its own\n-//! (by dynamically enumerating currently loaded modules via the dl_iterate_phdr() API\n-//! and finding their \".eh_frame\" sections);\n-//! Others, like Windows, require modules to actively register their unwind info\n-//! sections via unwinder API (see `rust_eh_register_frames`/`rust_eh_unregister_frames`).\n-\n-#![allow(dead_code)]\n-#![allow(unused_imports)]\n-\n-use prelude::v1::*;\n-\n-use any::Any;\n-use boxed;\n-use cmp;\n-use panicking::{self,PANIC_COUNT};\n-use fmt;\n-use intrinsics;\n-use mem;\n-use sync::atomic::{self, Ordering};\n-use sys_common::mutex::Mutex;\n-\n-// The actual unwinding implementation is cfg'd here, and we've got two current\n-// implementations. One goes through SEH on Windows and the other goes through\n-// libgcc via the libunwind-like API.\n-\n-// *-pc-windows-msvc\n-#[cfg(target_env = \"msvc\")]\n-#[path = \"seh.rs\"] #[doc(hidden)]\n-pub mod imp;\n-\n-// x86_64-pc-windows-gnu\n-#[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))]\n-#[path = \"seh64_gnu.rs\"] #[doc(hidden)]\n-pub mod imp;\n-\n-// i686-pc-windows-gnu and all others\n-#[cfg(any(unix, all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n-#[path = \"gcc.rs\"] #[doc(hidden)]\n-pub mod imp;\n-\n-/// Invoke a closure, capturing the cause of panic if one occurs.\n-///\n-/// This function will return `Ok(())` if the closure did not panic, and will\n-/// return `Err(cause)` if the closure panics. The `cause` returned is the\n-/// object with which panic was originally invoked.\n-///\n-/// This function also is unsafe for a variety of reasons:\n-///\n-/// * This is not safe to call in a nested fashion. The unwinding\n-///   interface for Rust is designed to have at most one try/catch block per\n-///   thread, not multiple. No runtime checking is currently performed to uphold\n-///   this invariant, so this function is not safe. A nested try/catch block\n-///   may result in corruption of the outer try/catch block's state, especially\n-///   if this is used within a thread itself.\n-///\n-/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n-///   have runtime checks in place to ensure this invariant, but it is not\n-///   guaranteed that a rust thread is in place when invoking this function.\n-///   Unwinding twice can lead to resource leaks where some destructors are not\n-///   run.\n-pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n-    let mut f = Some(f);\n-    return inner_try(try_fn::<F>, &mut f as *mut _ as *mut u8);\n-\n-    fn try_fn<F: FnOnce()>(opt_closure: *mut u8) {\n-        let opt_closure = opt_closure as *mut Option<F>;\n-        unsafe { (*opt_closure).take().unwrap()(); }\n-    }\n-}\n-\n-unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n-                    -> Result<(), Box<Any + Send>> {\n-    PANIC_COUNT.with(|s| {\n-        let prev = s.get();\n-        s.set(0);\n-\n-        // The \"payload\" here is a platform-specific region of memory which is\n-        // used to transmit information about the exception being thrown from\n-        // the point-of-throw back to this location.\n-        //\n-        // A pointer to this data is passed to the `try` intrinsic itself,\n-        // allowing this function, the `try` intrinsic, imp::payload(), and\n-        // imp::cleanup() to all work in concert to transmit this information.\n-        //\n-        // More information about what this pointer actually is can be found in\n-        // each implementation as well as browsing the compiler source itself.\n-        let mut payload = imp::payload();\n-        let r = intrinsics::try(f, data, &mut payload as *mut _ as *mut _);\n-        s.set(prev);\n-        if r == 0 {\n-            Ok(())\n-        } else {\n-            Err(imp::cleanup(payload))\n-        }\n-    })\n-}\n-\n-/// Determines whether the current thread is unwinding because of panic.\n-pub fn panicking() -> bool {\n-    PANIC_COUNT.with(|s| s.get() != 0)\n-}\n-\n-// An uninlined, unmangled function upon which to slap yer breakpoints\n-#[inline(never)]\n-#[no_mangle]\n-#[allow(private_no_mangle_fns)]\n-pub fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n-    unsafe {\n-        imp::panic(cause)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-/// Entry point of panic from the libcore crate.\n-#[lang = \"panic_fmt\"]\n-#[unwind]\n-pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n-                                file: &'static str, line: u32) -> ! {\n-    begin_unwind_fmt(msg, &(file, line))\n-}\n-\n-/// The entry point for unwinding with a formatted message.\n-///\n-/// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `panic!()` has as low an impact\n-/// on (e.g.) the inlining of other functions as possible), by moving\n-/// the actual formatting into this shared place.\n-#[unstable(feature = \"libstd_sys_internals\",\n-           reason = \"used by the panic! macro\",\n-           issue = \"0\")]\n-#[inline(never)] #[cold]\n-pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n-    use fmt::Write;\n-\n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_unwind\n-    // below).\n-\n-    let mut s = String::new();\n-    let _ = s.write_fmt(msg);\n-    begin_unwind_inner(Box::new(s), file_line)\n-}\n-\n-/// This is the entry point of unwinding for panic!() and assert!().\n-#[unstable(feature = \"libstd_sys_internals\",\n-           reason = \"used by the panic! macro\",\n-           issue = \"0\")]\n-#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    // see below for why we do the `Any` coercion here.\n-    begin_unwind_inner(Box::new(msg), file_line)\n-}\n-\n-/// The core of the unwinding.\n-///\n-/// This is non-generic to avoid instantiation bloat in other crates\n-/// (which makes compilation of small crates noticeably slower). (Note:\n-/// we need the `Any` object anyway, we're not just creating it to\n-/// avoid being generic.)\n-///\n-/// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n-/// }` from ~1900/3700 (-O/no opts) to 180/590.\n-#[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: Box<Any + Send>,\n-                      file_line: &(&'static str, u32)) -> ! {\n-    let (file, line) = *file_line;\n-\n-    // First, invoke the default panic handler.\n-    panicking::on_panic(&*msg, file, line);\n-\n-    // Finally, perform the unwinding.\n-    rust_panic(msg);\n-}"}, {"sha": "94da42f0092f5092a984f71b5b24368c1df83330", "filename": "src/libstd/sys/common/unwind/seh.rs", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1,153 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Windows SEH\n-//!\n-//! On Windows (currently only on MSVC), the default exception handling\n-//! mechanism is Structured Exception Handling (SEH). This is quite different\n-//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n-//! terms of compiler internals, so LLVM is required to have a good deal of\n-//! extra support for SEH.\n-//!\n-//! In a nutshell, what happens here is:\n-//!\n-//! 1. The `panic` function calls the standard Windows function `RaiseException`\n-//!    with a Rust-specific code, triggering the unwinding process.\n-//! 2. All landing pads generated by the compiler use the personality function\n-//!    `__C_specific_handler` on 64-bit and `__except_handler3` on 32-bit,\n-//!    functions in the CRT, and the unwinding code in Windows will use this\n-//!    personality function to execute all cleanup code on the stack.\n-//! 3. All compiler-generated calls to `invoke` have a landing pad set as a\n-//!    `cleanuppad` LLVM instruction, which indicates the start of the cleanup\n-//!    routine. The personality (in step 2, defined in the CRT) is responsible\n-//!    for running the cleanup routines.\n-//! 4. Eventually the \"catch\" code in the `try` intrinsic (generated by the\n-//!    compiler) is executed, which will ensure that the exception being caught\n-//!    is indeed a Rust exception, indicating that control should come back to\n-//!    Rust. This is done via a `catchswitch` plus a `catchpad` instruction in\n-//!    LLVM IR terms, finally returning normal control to the program with a\n-//!    `catchret` instruction. The `try` intrinsic uses a filter function to\n-//!    detect what kind of exception is being thrown, and this detection is\n-//!    implemented as the msvc_try_filter language item below.\n-//!\n-//! Some specific differences from the gcc-based exception handling are:\n-//!\n-//! * Rust has no custom personality function, it is instead *always*\n-//!   __C_specific_handler or __except_handler3, so the filtering is done in a\n-//!   C++-like manner instead of in the personality function itself. Note that\n-//!   the precise codegen for this was lifted from an LLVM test case for SEH\n-//!   (this is the `__rust_try_filter` function below).\n-//! * We've got some data to transmit across the unwinding boundary,\n-//!   specifically a `Box<Any + Send + 'static>`. Like with Dwarf exceptions\n-//!   these two pointers are stored as a payload in the exception itself. On\n-//!   MSVC, however, there's no need for an extra allocation because the call\n-//!   stack is preserved while filter functions are being executed. This means\n-//!   that the pointers are passed directly to `RaiseException` which are then\n-//!   recovered in the filter function to be written to the stack frame of the\n-//!   `try` intrinsic.\n-//!\n-//! [win64]: http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx\n-//! [llvm]: http://llvm.org/docs/ExceptionHandling.html#background-on-windows-exceptions\n-\n-use sys::c;\n-\n-// A code which indicates panics that originate from Rust. Note that some of the\n-// upper bits are used by the system so we just set them to 0 and ignore them.\n-//                           0x 0 R S T\n-const RUST_PANIC: c::DWORD = 0x00525354;\n-\n-pub use self::imp::*;\n-\n-mod imp {\n-    use prelude::v1::*;\n-\n-    use any::Any;\n-    use mem;\n-    use raw;\n-    use super::RUST_PANIC;\n-    use sys::c;\n-\n-    pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n-        // As mentioned above, the call stack here is preserved while the filter\n-        // functions are running, so it's ok to pass stack-local arrays into\n-        // `RaiseException`.\n-        //\n-        // The two pointers of the `data` trait object are written to the stack,\n-        // passed to `RaiseException`, and they're later extracted by the filter\n-        // function below in the \"custom exception information\" section of the\n-        // `EXCEPTION_RECORD` type.\n-        let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n-        let ptrs = [ptrs.data, ptrs.vtable];\n-        c::RaiseException(RUST_PANIC, 0, 2, ptrs.as_ptr() as *mut _);\n-        rtabort!(\"could not unwind stack\");\n-    }\n-\n-    pub fn payload() -> [usize; 2] {\n-        [0; 2]\n-    }\n-\n-    pub unsafe fn cleanup(payload: [usize; 2]) -> Box<Any + Send + 'static> {\n-        mem::transmute(raw::TraitObject {\n-            data: payload[0] as *mut _,\n-            vtable: payload[1] as *mut _,\n-        })\n-    }\n-\n-    // This is quite a special function, and it's not literally passed in as the\n-    // filter function for the `catchpad` of the `try` intrinsic. The compiler\n-    // actually generates its own filter function wrapper which will delegate to\n-    // this for the actual execution logic for whether the exception should be\n-    // caught. The reasons for this are:\n-    //\n-    // * Each architecture has a slightly different ABI for the filter function\n-    //   here. For example on x86 there are no arguments but on x86_64 there are\n-    //   two.\n-    // * This function needs access to the stack frame of the `try` intrinsic\n-    //   which is using this filter as a catch pad. This is because the payload\n-    //   of this exception, `Box<Any>`, needs to be transmitted to that\n-    //   location.\n-    //\n-    // Both of these differences end up using a ton of weird llvm-specific\n-    // intrinsics, so it's actually pretty difficult to express the entire\n-    // filter function in Rust itself. As a compromise, the compiler takes care\n-    // of all the weird LLVM-specific and platform-specific stuff, getting to\n-    // the point where this function makes the actual decision about what to\n-    // catch given two parameters.\n-    //\n-    // The first parameter is `*mut EXCEPTION_POINTERS` which is some contextual\n-    // information about the exception being filtered, and the second pointer is\n-    // `*mut *mut [usize; 2]` (the payload here). This value points directly\n-    // into the stack frame of the `try` intrinsic itself, and we use it to copy\n-    // information from the exception onto the stack.\n-    #[lang = \"msvc_try_filter\"]\n-    #[cfg(not(test))]\n-    unsafe extern fn __rust_try_filter(eh_ptrs: *mut u8,\n-                                       payload: *mut u8) -> i32 {\n-        let eh_ptrs = eh_ptrs as *mut c::EXCEPTION_POINTERS;\n-        let payload = payload as *mut *mut [usize; 2];\n-        let record = &*(*eh_ptrs).ExceptionRecord;\n-        if record.ExceptionCode != RUST_PANIC {\n-            return 0\n-        }\n-        (**payload)[0] = record.ExceptionInformation[0] as usize;\n-        (**payload)[1] = record.ExceptionInformation[1] as usize;\n-        return 1\n-    }\n-}\n-\n-// This is required by the compiler to exist (e.g. it's a lang item), but\n-// it's never actually called by the compiler because __C_specific_handler\n-// or _except_handler3 is the personality function that is always used.\n-// Hence this is just an aborting stub.\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-fn rust_eh_personality() {\n-    unsafe { ::intrinsics::abort() }\n-}"}, {"sha": "5f7ad6918cdd26830366c5605a6c0cb4a6b5c7a8", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "modified", "additions": 1, "deletions": 123, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -15,6 +15,7 @@ use mem;\n use sync::StaticMutex;\n \n use super::super::printing::print;\n+use unwind as uw;\n \n #[inline(never)] // if we know this is a function call, we can skip it when\n                  // tracing\n@@ -102,126 +103,3 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n         uw::_URC_NO_REASON\n     }\n }\n-\n-/// Unwind library interface used for backtraces\n-///\n-/// Note that dead code is allowed as here are just bindings\n-/// iOS doesn't use all of them it but adding more\n-/// platform-specific configs pollutes the code too much\n-#[allow(non_camel_case_types)]\n-#[allow(non_snake_case)]\n-mod uw {\n-    pub use self::_Unwind_Reason_Code::*;\n-\n-    use libc;\n-\n-    #[repr(C)]\n-    pub enum _Unwind_Reason_Code {\n-        _URC_NO_REASON = 0,\n-        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-        _URC_FATAL_PHASE2_ERROR = 2,\n-        _URC_FATAL_PHASE1_ERROR = 3,\n-        _URC_NORMAL_STOP = 4,\n-        _URC_END_OF_STACK = 5,\n-        _URC_HANDLER_FOUND = 6,\n-        _URC_INSTALL_CONTEXT = 7,\n-        _URC_CONTINUE_UNWIND = 8,\n-        _URC_FAILURE = 9, // used only by ARM EABI\n-    }\n-\n-    pub enum _Unwind_Context {}\n-\n-    pub type _Unwind_Trace_Fn =\n-            extern fn(ctx: *mut _Unwind_Context,\n-                      arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n-\n-    extern {\n-        // No native _Unwind_Backtrace on iOS\n-        #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                                 trace_argument: *mut libc::c_void)\n-                    -> _Unwind_Reason_Code;\n-\n-        // available since GCC 4.2.0, should be fine for our purpose\n-        #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n-                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                                 ip_before_insn: *mut libc::c_int)\n-                    -> libc::uintptr_t;\n-\n-        #[cfg(all(not(target_os = \"android\"),\n-                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-            -> *mut libc::c_void;\n-    }\n-\n-    // On android, the function _Unwind_GetIP is a macro, and this is the\n-    // expansion of the macro. This is all copy/pasted directly from the\n-    // header file with the definition of _Unwind_GetIP.\n-    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n-        #[repr(C)]\n-        enum _Unwind_VRS_Result {\n-            _UVRSR_OK = 0,\n-            _UVRSR_NOT_IMPLEMENTED = 1,\n-            _UVRSR_FAILED = 2,\n-        }\n-        #[repr(C)]\n-        enum _Unwind_VRS_RegClass {\n-            _UVRSC_CORE = 0,\n-            _UVRSC_VFP = 1,\n-            _UVRSC_FPA = 2,\n-            _UVRSC_WMMXD = 3,\n-            _UVRSC_WMMXC = 4,\n-        }\n-        #[repr(C)]\n-        enum _Unwind_VRS_DataRepresentation {\n-            _UVRSD_UINT32 = 0,\n-            _UVRSD_VFPX = 1,\n-            _UVRSD_FPAX = 2,\n-            _UVRSD_UINT64 = 3,\n-            _UVRSD_FLOAT = 4,\n-            _UVRSD_DOUBLE = 5,\n-        }\n-\n-        type _Unwind_Word = libc::c_uint;\n-        extern {\n-            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n-                               klass: _Unwind_VRS_RegClass,\n-                               word: _Unwind_Word,\n-                               repr: _Unwind_VRS_DataRepresentation,\n-                               data: *mut libc::c_void)\n-                -> _Unwind_VRS_Result;\n-        }\n-\n-        let mut val: _Unwind_Word = 0;\n-        let ptr = &mut val as *mut _Unwind_Word;\n-        let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n-                                _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n-                                ptr as *mut libc::c_void);\n-        (val & !1) as libc::uintptr_t\n-    }\n-\n-    // This function doesn't exist on Android or ARM/Linux, so make it same\n-    // to _Unwind_GetIP\n-    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                                    ip_before_insn: *mut libc::c_int)\n-        -> libc::uintptr_t\n-    {\n-        *ip_before_insn = 0;\n-        _Unwind_GetIP(ctx)\n-    }\n-\n-    // This function also doesn't exist on Android or ARM/Linux, so make it\n-    // a no-op\n-    #[cfg(any(target_os = \"android\",\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-        -> *mut libc::c_void\n-    {\n-        pc\n-    }\n-}"}, {"sha": "2acf6485eb3dad6bf9252a609020ede0945706fb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -277,21 +277,6 @@ pub const CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n-                                    EXCEPTION_EXIT_UNWIND |\n-                                    EXCEPTION_TARGET_UNWIND |\n-                                    EXCEPTION_COLLIDED_UNWIND;\n \n pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n@@ -813,31 +798,6 @@ pub struct in6_addr {\n     pub s6_addr: [u8; 16],\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub enum UNWIND_HISTORY_TABLE {}\n-\n-#[repr(C)]\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub struct RUNTIME_FUNCTION {\n-    pub BeginAddress: DWORD,\n-    pub EndAddress: DWORD,\n-    pub UnwindData: DWORD,\n-}\n-\n-#[repr(C)]\n-#[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-pub struct DISPATCHER_CONTEXT {\n-    pub ControlPc: LPVOID,\n-    pub ImageBase: LPVOID,\n-    pub FunctionEntry: *const RUNTIME_FUNCTION,\n-    pub EstablisherFrame: LPVOID,\n-    pub TargetIp: LPVOID,\n-    pub ContextRecord: *const CONTEXT,\n-    pub LanguageHandler: LPVOID,\n-    pub HandlerData: *const u8,\n-    pub HistoryTable: *const UNWIND_HISTORY_TABLE,\n-}\n-\n #[repr(C)]\n #[derive(Copy, Clone)]\n #[allow(dead_code)] // we only use some variants\n@@ -1113,19 +1073,6 @@ extern \"system\" {\n                           pbBuffer: *mut BYTE) -> BOOL;\n     pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n \n-    #[unwind]\n-    #[cfg(any(target_arch = \"x86_64\", target_env = \"msvc\"))]\n-    pub fn RaiseException(dwExceptionCode: DWORD,\n-                          dwExceptionFlags: DWORD,\n-                          nNumberOfArguments: DWORD,\n-                          lpArguments: *const ULONG_PTR);\n-    #[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n-    pub fn RtlUnwindEx(TargetFrame: LPVOID,\n-                       TargetIp: LPVOID,\n-                       ExceptionRecord: *const EXCEPTION_RECORD,\n-                       ReturnValue: LPVOID,\n-                       OriginalContext: *const CONTEXT,\n-                       HistoryTable: *const UNWIND_HISTORY_TABLE);\n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n \n     pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,"}, {"sha": "99e6ba8c770b92b3bc68a499de4cb92fdf971418", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -163,14 +163,15 @@ use prelude::v1::*;\n \n use any::Any;\n use cell::UnsafeCell;\n+use ffi::{CStr, CString};\n use fmt;\n use io;\n+use panic;\n+use panicking;\n use str;\n-use ffi::{CStr, CString};\n use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n use sys_common::thread_info;\n-use sys_common::unwind;\n use sys_common::util;\n use sys_common::{AsInner, IntoInner};\n use time::Duration;\n@@ -273,14 +274,8 @@ impl Builder {\n             }\n             unsafe {\n                 thread_info::set(imp::guard::current(), their_thread);\n-                let mut output = None;\n-                let try_result = {\n-                    let ptr = &mut output;\n-                    unwind::try(move || *ptr = Some(f()))\n-                };\n-                *their_packet.get() = Some(try_result.map(|()| {\n-                    output.unwrap()\n-                }));\n+                let try_result = panic::catch_unwind(panic::AssertUnwindSafe(f));\n+                *their_packet.get() = Some(try_result);\n             }\n         };\n \n@@ -337,7 +332,7 @@ pub fn yield_now() {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn panicking() -> bool {\n-    unwind::panicking()\n+    panicking::panicking()\n }\n \n /// Puts the current thread to sleep for the specified amount of time."}, {"sha": "7958162986cfc558f2fbd7ddf0daaf829d7ec6b0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -755,7 +755,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[\"rt\", \"begin_unwind\"]),\n+            self.std_path(&[\"rt\", \"begin_panic\"]),\n             vec!(\n                 self.expr_str(span, msg),\n                 expr_file_line_ptr))"}, {"sha": "acef98f2afc1bc3b724480e556dd66109623001d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -141,6 +141,8 @@ declare_features! (\n     (active, simd_ffi, \"1.0.0\", Some(27731)),\n     (active, start, \"1.0.0\", Some(29633)),\n     (active, structural_match, \"1.8.0\", Some(31434)),\n+    (active, panic_runtime, \"1.10.0\", Some(32837)),\n+    (active, needs_panic_runtime, \"1.10.0\", Some(32837)),\n \n     // OIBIT specific features\n     (active, optin_builtin_traits, \"1.0.0\", Some(13231)),\n@@ -438,6 +440,15 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        attribute is an experimental \\\n                                        feature\",\n                                       cfg_fn!(needs_allocator))),\n+    (\"panic_runtime\", Whitelisted, Gated(\"panic_runtime\",\n+                                         \"the `#[panic_runtime]` attribute is \\\n+                                          an experimental feature\",\n+                                         cfg_fn!(panic_runtime))),\n+    (\"needs_panic_runtime\", Whitelisted, Gated(\"needs_panic_runtime\",\n+                                               \"the `#[needs_panic_runtime]` \\\n+                                                attribute is an experimental \\\n+                                                feature\",\n+                                               cfg_fn!(needs_panic_runtime))),\n     (\"rustc_variance\", Normal, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_variance]` attribute \\\n                                       is just used for rustc unit tests \\"}, {"sha": "88be3ade83922b399abb116253c386c8dcc58d1b", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -41,10 +41,12 @@\n #![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(panic_unwind)]\n \n extern crate getopts;\n extern crate term;\n extern crate libc;\n+extern crate panic_unwind;\n \n pub use self::TestFn::*;\n pub use self::ColorConfig::*;"}, {"sha": "dca222c49d0a11107c43e4779bd850d100154e73", "filename": "src/libunwind/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"unwind\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"unwind\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }"}, {"sha": "ebe6fd54799ee47f4245b8cf6a6749a8615da27e", "filename": "src/libunwind/build.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+\n+    let target = env::var(\"TARGET\").unwrap();\n+\n+    if target.contains(\"linux\") {\n+        if target.contains(\"musl\") && (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n+            println!(\"cargo:rustc-link-lib=static=unwind\");\n+        } else if !target.contains(\"android\") {\n+            println!(\"cargo:rustc-link-lib=gcc_s\");\n+        }\n+    } else if target.contains(\"freebsd\") {\n+        println!(\"cargo:rustc-link-lib=gcc_s\");\n+    } else if target.contains(\"rumprun\") {\n+        println!(\"cargo:rustc-link-lib=unwind\");\n+    } else if target.contains(\"netbsd\") {\n+        println!(\"cargo:rustc-link-lib=gcc_s\");\n+    } else if target.contains(\"openbsd\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if target.contains(\"bitrig\") {\n+        println!(\"cargo:rustc-link-lib=c++abi\");\n+    } else if target.contains(\"dragonfly\") {\n+        println!(\"cargo:rustc-link-lib=gcc_pic\");\n+    } else if target.contains(\"windows-gnu\") {\n+        println!(\"cargo:rustc-link-lib=gcc_eh\");\n+    }\n+}"}, {"sha": "3ff61fd93d758df3b30bbe69173a26107b8e65e2", "filename": "src/libunwind/lib.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![no_std]\n+#![crate_name = \"unwind\"]\n+#![crate_type = \"rlib\"]\n+#![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(cfg_target_vendor)]\n+#![feature(staged_api)]\n+#![feature(unwind_attributes)]\n+\n+#![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n+\n+#[cfg(not(target_env = \"msvc\"))]\n+extern crate libc;\n+\n+#[cfg(not(target_env = \"msvc\"))]\n+mod libunwind;\n+#[cfg(not(target_env = \"msvc\"))]\n+pub use libunwind::*;\n+"}, {"sha": "ce74e5de3d4600473f4f8fa857286c2f0316029d", "filename": "src/libunwind/libunwind.rs", "status": "renamed", "additions": 103, "deletions": 14, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,24 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unwind library interface\n+#![allow(bad_style)]\n \n-#![allow(non_upper_case_globals)]\n-#![allow(non_camel_case_types)]\n-#![allow(non_snake_case)]\n-#![allow(dead_code)] // these are just bindings\n+use libc;\n \n #[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n pub use self::_Unwind_Action::*;\n #[cfg(target_arch = \"arm\")]\n pub use self::_Unwind_State::*;\n pub use self::_Unwind_Reason_Code::*;\n \n-use libc;\n-\n #[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n #[repr(C)]\n-#[derive(Copy, Clone)]\n+#[derive(Clone, Copy)]\n pub enum _Unwind_Action {\n     _UA_SEARCH_PHASE = 1,\n     _UA_CLEANUP_PHASE = 2,\n@@ -36,7 +31,7 @@ pub enum _Unwind_Action {\n \n #[cfg(target_arch = \"arm\")]\n #[repr(C)]\n-#[derive(Copy, Clone)]\n+#[derive(Clone, Copy)]\n pub enum _Unwind_State {\n     _US_VIRTUAL_UNWIND_FRAME = 0,\n     _US_UNWIND_FRAME_STARTING = 1,\n@@ -47,7 +42,6 @@ pub enum _Unwind_State {\n }\n \n #[repr(C)]\n-#[derive(Copy, Clone)]\n pub enum _Unwind_Reason_Code {\n     _URC_NO_REASON = 0,\n     _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n@@ -65,6 +59,10 @@ pub type _Unwind_Exception_Class = u64;\n \n pub type _Unwind_Word = libc::uintptr_t;\n \n+pub type _Unwind_Trace_Fn =\n+        extern fn(ctx: *mut _Unwind_Context,\n+                  arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n+\n #[cfg(target_arch = \"x86\")]\n pub const unwinder_private_data_size: usize = 5;\n \n@@ -126,9 +124,12 @@ pub type _Unwind_Exception_Cleanup_Fn =\n            link(name = \"gcc_pic\"))]\n #[cfg_attr(target_os = \"bitrig\",\n            link(name = \"c++abi\"))]\n-#[cfg_attr(all(target_os = \"windows\", target_env=\"gnu\"),\n+#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"),\n            link(name = \"gcc_eh\"))]\n-extern \"C\" {\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+extern {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n     // against corresponding routine (..._SjLj_...)\n     #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n@@ -145,14 +146,102 @@ extern \"C\" {\n \n     #[unwind]\n     pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n+\n+    // No native _Unwind_Backtrace on iOS\n+    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                             trace_argument: *mut libc::c_void)\n+                -> _Unwind_Reason_Code;\n+\n+    // available since GCC 4.2.0, should be fine for our purpose\n+    #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n+              not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+    pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                             ip_before_insn: *mut libc::c_int)\n+                -> libc::uintptr_t;\n+\n+    #[cfg(all(not(target_os = \"android\"),\n+              not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+    pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+        -> *mut libc::c_void;\n }\n \n // ... and now we just providing access to SjLj counterspart\n // through a standard name to hide those details from others\n // (see also comment above regarding _Unwind_RaiseException)\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)\n                                      -> _Unwind_Reason_Code {\n     _Unwind_SjLj_RaiseException(exc)\n }\n+\n+// On android, the function _Unwind_GetIP is a macro, and this is the\n+// expansion of the macro. This is all copy/pasted directly from the\n+// header file with the definition of _Unwind_GetIP.\n+#[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n+          all(target_os = \"linux\", target_arch = \"arm\")))]\n+pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n+    #[repr(C)]\n+    enum _Unwind_VRS_Result {\n+        _UVRSR_OK = 0,\n+        _UVRSR_NOT_IMPLEMENTED = 1,\n+        _UVRSR_FAILED = 2,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_RegClass {\n+        _UVRSC_CORE = 0,\n+        _UVRSC_VFP = 1,\n+        _UVRSC_FPA = 2,\n+        _UVRSC_WMMXD = 3,\n+        _UVRSC_WMMXC = 4,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_DataRepresentation {\n+        _UVRSD_UINT32 = 0,\n+        _UVRSD_VFPX = 1,\n+        _UVRSD_FPAX = 2,\n+        _UVRSD_UINT64 = 3,\n+        _UVRSD_FLOAT = 4,\n+        _UVRSD_DOUBLE = 5,\n+    }\n+\n+    type _Unwind_Word = libc::c_uint;\n+    extern {\n+        fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n+                           klass: _Unwind_VRS_RegClass,\n+                           word: _Unwind_Word,\n+                           repr: _Unwind_VRS_DataRepresentation,\n+                           data: *mut libc::c_void)\n+            -> _Unwind_VRS_Result;\n+    }\n+\n+    let mut val: _Unwind_Word = 0;\n+    let ptr = &mut val as *mut _Unwind_Word;\n+    let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n+                            _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n+                            ptr as *mut libc::c_void);\n+    (val & !1) as libc::uintptr_t\n+}\n+\n+// This function doesn't exist on Android or ARM/Linux, so make it same\n+// to _Unwind_GetIP\n+#[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n+          all(target_os = \"linux\", target_arch = \"arm\")))]\n+pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                ip_before_insn: *mut libc::c_int)\n+    -> libc::uintptr_t\n+{\n+    *ip_before_insn = 0;\n+    _Unwind_GetIP(ctx)\n+}\n+\n+// This function also doesn't exist on Android or ARM/Linux, so make it\n+// a no-op\n+#[cfg(any(target_os = \"android\",\n+          all(target_os = \"linux\", target_arch = \"arm\")))]\n+pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+    -> *mut libc::c_void\n+{\n+    pc\n+}", "previous_filename": "src/libstd/sys/common/libunwind.rs"}, {"sha": "a73c41e7f1c85cd814e9792fc6a6a8f8e31b8dd4", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -1 +1 @@\n-Subproject commit 751345228a0ef03fd147394bb5104359b7a808be\n+Subproject commit a73c41e7f1c85cd814e9792fc6a6a8f8e31b8dd4"}, {"sha": "bad46966ffa6bef5eed035363137dcc75c097e14", "filename": "src/rustc/std_shim/Cargo.lock", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Frustc%2Fstd_shim%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Frustc%2Fstd_shim%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.lock?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -5,15 +5,6 @@ dependencies = [\n  \"std 0.0.0\",\n ]\n \n-[[package]]\n-name = \"advapi32-sys\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"alloc\"\n version = \"0.0.0\"\n@@ -27,7 +18,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -58,18 +49,32 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.17\"\n+version = \"0.3.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.0.0\"\n dependencies = [\n- \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"core 0.0.0\",\n ]\n \n [[package]]\n-name = \"libc\"\n+name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"panic_unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+ \"unwind 0.0.0\",\n ]\n \n [[package]]\n@@ -96,19 +101,20 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"collections 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n+ \"panic_abort 0.0.0\",\n+ \"panic_unwind 0.0.0\",\n  \"rand 0.0.0\",\n  \"rustc_unicode 0.0.0\",\n+ \"unwind 0.0.0\",\n ]\n \n [[package]]\n-name = \"winapi\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+name = \"unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n "}, {"sha": "4017c3856c465a77672945d4f81420dd80f53ad9", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-04-26\n+2016-04-28"}, {"sha": "b2f43489523d1859ce824bcea7cf953d64bf841c", "filename": "src/test/codegen/lto-removes-invokes.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcodegen%2Flto-removes-invokes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcodegen%2Flto-removes-invokes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flto-removes-invokes.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C lto -C panic=abort -O\n+// no-prefer-dynamic\n+\n+fn main() {\n+    foo();\n+}\n+\n+#[no_mangle]\n+#[inline(never)]\n+fn foo() {\n+    let _a = Box::new(3);\n+    bar();\n+// CHECK-LABEL: foo\n+// CHECK: call {{.*}} void @bar\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn bar() {\n+    println!(\"hello!\");\n+}"}, {"sha": "c3242a5082b627050c257504380907f53c7a6470", "filename": "src/test/compile-fail/panic-runtime/abort-link-to-unwind-dylib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fabort-link-to-unwind-dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fabort-link-to-unwind-dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fabort-link-to-unwind-dylib.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort -C prefer-dynamic\n+// ignore-musl - no dylibs here\n+// error-pattern:`panic_unwind` is not compiled with this crate's panic strategy\n+\n+// This is a test where the local crate, compiled with `panic=abort`, links to\n+// the standard library **dynamically** which is already linked against\n+// `panic=unwind`. We should fail because the linked panic runtime does not\n+// correspond with our `-C panic` option.\n+//\n+// Note that this test assumes that the dynamic version of the standard library\n+// is linked to `panic_unwind`, which is currently the case.\n+\n+fn main() {\n+}"}, {"sha": "d6c21fecf6b5689b6094d6e51404575248d85d6a", "filename": "src/test/compile-fail/panic-runtime/auxiliary/needs-panic-runtime.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fneeds-panic-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fneeds-panic-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fneeds-panic-runtime.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(needs_panic_runtime)]\n+#![crate_type = \"rlib\"]\n+#![needs_panic_runtime]\n+#![no_std]"}, {"sha": "3b74156b6b01712b5e582be8ce6b67c6c9accf33", "filename": "src/test/compile-fail/panic-runtime/auxiliary/panic-runtime-abort.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-abort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort\n+// no-prefer-dynamic\n+\n+#![feature(panic_runtime)]\n+#![crate_type = \"rlib\"]\n+\n+#![no_std]\n+#![panic_runtime]\n+\n+#[no_mangle]\n+pub extern fn __rust_maybe_catch_panic() {}\n+\n+#[no_mangle]\n+pub extern fn __rust_start_panic() {}\n+\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}"}, {"sha": "fbf70b3d3fefe166c727a195f60a9f02d75afd89", "filename": "src/test/compile-fail/panic-runtime/auxiliary/panic-runtime-lang-items.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+#![no_std]\n+#![feature(lang_items)]\n+\n+#[lang = \"panic_fmt\"]\n+fn panic_fmt() {}\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {}\n+#[lang = \"eh_unwind_resume\"]\n+fn eh_unwind_resume() {}"}, {"sha": "4bb36839d988bc0cc61ceeef925e36347c2540ff", "filename": "src/test/compile-fail/panic-runtime/auxiliary/panic-runtime-unwind.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=unwind\n+// no-prefer-dynamic\n+\n+#![feature(panic_runtime)]\n+#![crate_type = \"rlib\"]\n+\n+#![no_std]\n+#![panic_runtime]\n+\n+#[no_mangle]\n+pub extern fn __rust_maybe_catch_panic() {}\n+\n+#[no_mangle]\n+pub extern fn __rust_start_panic() {}\n+\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}"}, {"sha": "4bb36839d988bc0cc61ceeef925e36347c2540ff", "filename": "src/test/compile-fail/panic-runtime/auxiliary/panic-runtime-unwind2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-unwind2.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=unwind\n+// no-prefer-dynamic\n+\n+#![feature(panic_runtime)]\n+#![crate_type = \"rlib\"]\n+\n+#![no_std]\n+#![panic_runtime]\n+\n+#[no_mangle]\n+pub extern fn __rust_maybe_catch_panic() {}\n+\n+#[no_mangle]\n+pub extern fn __rust_start_panic() {}\n+\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}"}, {"sha": "b90dec9281bc1f2fec3a86ac5e029876bd5e35ab", "filename": "src/test/compile-fail/panic-runtime/auxiliary/runtime-depending-on-panic-runtime.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fruntime-depending-on-panic-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fruntime-depending-on-panic-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fruntime-depending-on-panic-runtime.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(panic_runtime)]\n+#![crate_type = \"rlib\"]\n+#![panic_runtime]\n+#![no_std]\n+\n+extern crate needs_panic_runtime;"}, {"sha": "e1902e44a60e27fae2c40af81349ccb42ff0ebfb", "filename": "src/test/compile-fail/panic-runtime/auxiliary/wants-panic-runtime-abort.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-abort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+#![no_std]\n+\n+extern crate panic_runtime_abort;"}, {"sha": "2183338b24985870edaadd89342620c19080efda", "filename": "src/test/compile-fail/panic-runtime/auxiliary/wants-panic-runtime-unwind.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fauxiliary%2Fwants-panic-runtime-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+#![no_std]\n+\n+extern crate panic_runtime_unwind;"}, {"sha": "f067b6b8349b67b746ca270fab40f252d484495a", "filename": "src/test/compile-fail/panic-runtime/bad-panic-flag1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag1.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=foo\n+// error-pattern:either `panic` or `abort` was expected\n+\n+fn main() {}"}, {"sha": "0ecf65f080fa9e19ebd8a20fba0b68151262fe3b", "filename": "src/test/compile-fail/panic-runtime/bad-panic-flag2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fbad-panic-flag2.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic\n+// error-pattern:requires either `panic` or `abort`\n+\n+fn main() {}"}, {"sha": "5f6f4ecbd6f6e4f22b46990677a25f3870f33f3e", "filename": "src/test/compile-fail/panic-runtime/libtest-unwinds.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Flibtest-unwinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Flibtest-unwinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Flibtest-unwinds.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:is not compiled with this crate's panic strategy `abort`\n+// compile-flags:-C panic=abort\n+\n+#![feature(test)]\n+\n+extern crate test;\n+\n+fn main() {\n+}\n+"}, {"sha": "02f3da58f1da8cd03c454a5acb787692dd4ae718", "filename": "src/test/compile-fail/panic-runtime/needs-gate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fneeds-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fneeds-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fneeds-gate.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![panic_runtime] //~ ERROR: is an experimental feature\n+#![needs_panic_runtime] //~ ERROR: is an experimental feature\n+\n+fn main() {}"}, {"sha": "0681f991067b1c239ae6792fc9157fac16964751", "filename": "src/test/compile-fail/panic-runtime/runtime-depend-on-needs-runtime.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fruntime-depend-on-needs-runtime.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:needs-panic-runtime.rs\n+// aux-build:runtime-depending-on-panic-runtime.rs\n+// error-pattern:cannot depend on a crate that needs a panic runtime\n+\n+extern crate runtime_depending_on_panic_runtime;"}, {"sha": "885b3e6dbb94148848f9c3d7c7d7d3dfcdc17b35", "filename": "src/test/compile-fail/panic-runtime/transitive-link-a-bunch.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:panic-runtime-unwind.rs\n+// aux-build:panic-runtime-abort.rs\n+// aux-build:wants-panic-runtime-unwind.rs\n+// aux-build:wants-panic-runtime-abort.rs\n+// aux-build:panic-runtime-lang-items.rs\n+// error-pattern: is not compiled with this crate's panic strategy `unwind`\n+\n+#![no_std]\n+\n+extern crate wants_panic_runtime_unwind;\n+extern crate wants_panic_runtime_abort;\n+extern crate panic_runtime_lang_items;\n+\n+fn main() {}"}, {"sha": "0fe0da2fa2c5774bdd28967bd0d9c6f093546c99", "filename": "src/test/compile-fail/panic-runtime/two-panic-runtimes.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftwo-panic-runtimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftwo-panic-runtimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Ftwo-panic-runtimes.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:cannot link together two panic runtimes: panic_runtime_unwind and panic_runtime_unwind2\n+// ignore-tidy-linelength\n+// aux-build:panic-runtime-unwind.rs\n+// aux-build:panic-runtime-unwind2.rs\n+// aux-build:panic-runtime-lang-items.rs\n+\n+#![no_std]\n+\n+extern crate panic_runtime_unwind;\n+extern crate panic_runtime_unwind2;\n+extern crate panic_runtime_lang_items;\n+\n+fn main() {}"}, {"sha": "b178006411ba05d963edee9f628641e1a48e46cc", "filename": "src/test/compile-fail/panic-runtime/want-abort-got-unwind.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:is not compiled with this crate's panic strategy `abort`\n+// aux-build:panic-runtime-unwind.rs\n+// compile-flags:-C panic=abort\n+\n+extern crate panic_runtime_unwind;\n+\n+fn main() {}"}, {"sha": "de8e010c3cb48471f64f7bab8ad039bc4b6cd225", "filename": "src/test/compile-fail/panic-runtime/want-abort-got-unwind2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-abort-got-unwind2.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:is not compiled with this crate's panic strategy `abort`\n+// aux-build:panic-runtime-unwind.rs\n+// aux-build:wants-panic-runtime-unwind.rs\n+// compile-flags:-C panic=abort\n+\n+extern crate wants_panic_runtime_unwind;\n+\n+fn main() {}"}, {"sha": "88ad36f310eb5fcc8649cefef1e82469b454332e", "filename": "src/test/compile-fail/panic-runtime/want-unwind-got-abort.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:is incompatible with this crate's strategy of `unwind`\n+// aux-build:panic-runtime-abort.rs\n+// aux-build:panic-runtime-lang-items.rs\n+\n+#![no_std]\n+\n+extern crate panic_runtime_abort;\n+extern crate panic_runtime_lang_items;\n+\n+fn main() {}"}, {"sha": "c42a25a553a7f4fd4a677dc86cb7b25d55761c9d", "filename": "src/test/compile-fail/panic-runtime/want-unwind-got-abort2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:is incompatible with this crate's strategy of `unwind`\n+// aux-build:panic-runtime-abort.rs\n+// aux-build:wants-panic-runtime-abort.rs\n+// aux-build:panic-runtime-lang-items.rs\n+\n+#![no_std]\n+\n+extern crate wants_panic_runtime_abort;\n+extern crate panic_runtime_lang_items;\n+\n+fn main() {}"}, {"sha": "71c1a61062d1085a24bb2e02a065a68731bb07af", "filename": "src/test/run-pass/panic-runtime/abort-link-to-unwinding-crates.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort-link-to-unwinding-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort-link-to-unwinding-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort-link-to-unwinding-crates.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort\n+// aux-build:exit-success-if-unwind.rs\n+// no-prefer-dynamic\n+\n+extern crate exit_success_if_unwind;\n+\n+use std::process::Command;\n+use std::env;\n+\n+fn main() {\n+    let mut args = env::args_os();\n+    let me = args.next().unwrap();\n+\n+    if let Some(s) = args.next() {\n+        if &*s == \"foo\" {\n+            exit_success_if_unwind::bar(do_panic);\n+        }\n+    }\n+    let s = Command::new(env::args_os().next().unwrap()).arg(\"foo\").status();\n+    assert!(s.unwrap().code() != Some(0));\n+}\n+\n+fn do_panic() {\n+    panic!(\"try to catch me\");\n+}"}, {"sha": "2fc9d6cfd04a13ead3a726200646f7ff118650e9", "filename": "src/test/run-pass/panic-runtime/abort.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fabort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort\n+// no-prefer-dynamic\n+\n+use std::process::Command;\n+use std::env;\n+\n+struct Bomb;\n+\n+impl Drop for Bomb {\n+    fn drop(&mut self) {\n+        std::process::exit(0);\n+    }\n+}\n+\n+fn main() {\n+    let mut args = env::args_os();\n+    let me = args.next().unwrap();\n+\n+    if let Some(s) = args.next() {\n+        if &*s == \"foo\" {\n+\n+            let _bomb = Bomb;\n+\n+            panic!(\"try to catch me\");\n+        }\n+    }\n+    let s = Command::new(env::args_os().next().unwrap()).arg(\"foo\").status();\n+    assert!(s.unwrap().code() != Some(0));\n+}"}, {"sha": "9e5fc592b1a33f37e505334b00c02e9002c777f2", "filename": "src/test/run-pass/panic-runtime/auxiliary/exit-success-if-unwind.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fauxiliary%2Fexit-success-if-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fauxiliary%2Fexit-success-if-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Fauxiliary%2Fexit-success-if-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+struct Bomb;\n+\n+impl Drop for Bomb {\n+    fn drop(&mut self) {\n+        std::process::exit(0);\n+    }\n+}\n+\n+pub fn bar(f: fn()) {\n+    let _bomb = Bomb;\n+    f();\n+}"}, {"sha": "71e35e41fc04668f2f0f18c837b1cc8dd26bc11e", "filename": "src/test/run-pass/panic-runtime/link-to-abort.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-abort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C panic=abort\n+// no-prefer-dynamic\n+\n+#![feature(panic_abort)]\n+\n+extern crate panic_abort;\n+\n+fn main() {\n+}"}, {"sha": "dec8f738d32948d7e4fe78f12002db3abcef1cc4", "filename": "src/test/run-pass/panic-runtime/link-to-unwind.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flink-to-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(panic_unwind)]\n+\n+extern crate panic_unwind;\n+\n+fn main() {\n+}"}, {"sha": "09e33b88189fe8fb691ed1934bea768f41733016", "filename": "src/test/run-pass/panic-runtime/lto-abort.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-abort.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C lto -C panic=abort\n+// no-prefer-dynamic\n+\n+use std::process::Command;\n+use std::env;\n+\n+struct Bomb;\n+\n+impl Drop for Bomb {\n+    fn drop(&mut self) {\n+        std::process::exit(0);\n+    }\n+}\n+\n+fn main() {\n+    let mut args = env::args_os();\n+    let me = args.next().unwrap();\n+\n+    if let Some(s) = args.next() {\n+        if &*s == \"foo\" {\n+\n+            let _bomb = Bomb;\n+\n+            panic!(\"try to catch me\");\n+        }\n+    }\n+    let s = Command::new(env::args_os().next().unwrap()).arg(\"foo\").status();\n+    assert!(s.unwrap().code() != Some(0));\n+}"}, {"sha": "10e633b3775b3530f88d325a4ed703bca6f148fa", "filename": "src/test/run-pass/panic-runtime/lto-unwind.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-runtime%2Flto-unwind.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-C lto -C panic=unwind\n+// no-prefer-dynamic\n+\n+use std::process::Command;\n+use std::env;\n+\n+struct Bomb;\n+\n+impl Drop for Bomb {\n+    fn drop(&mut self) {\n+        println!(\"hurray you ran me\");\n+    }\n+}\n+\n+fn main() {\n+    let mut args = env::args_os();\n+    let me = args.next().unwrap();\n+\n+    if let Some(s) = args.next() {\n+        if &*s == \"foo\" {\n+\n+            let _bomb = Bomb;\n+\n+            panic!(\"try to catch me\");\n+        }\n+    }\n+    let s = Command::new(env::args_os().next().unwrap()).arg(\"foo\").output();\n+    let s = s.unwrap();\n+    assert!(!s.status.success());\n+    assert!(String::from_utf8_lossy(&s.stdout).contains(\"hurray you ran me\"));\n+}"}, {"sha": "6a9d52cb0048f17eb913378a525f80e6c966b2fb", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed7e78942e8d68f87cc7299625fb236f442ef1/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=72ed7e78942e8d68f87cc7299625fb236f442ef1", "patch": "@@ -85,6 +85,9 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n         if krate == \"alloc_jemalloc\" && toml.contains(\"name = \\\"std\\\"\") {\n             continue\n         }\n+        if krate == \"panic_abort\" && toml.contains(\"name = \\\"std\\\"\") {\n+            continue\n+        }\n \n         if !librs.contains(&format!(\"extern crate {}\", krate)) {\n             println!(\"{} doesn't have `extern crate {}`, but Cargo.toml \\"}]}