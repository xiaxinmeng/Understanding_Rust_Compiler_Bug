{"sha": "f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MTFkODdiM2I2ZWUzZTQ4NGNhOGRkN2RhNGJlODU5NzBkOTIzMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-16T23:09:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-16T23:09:45Z"}, "message": "Auto merge of #34272 - jseyfried:simplify_gated_cfg_checking, r=nrc\n\nSimplify gated cfg checking\n\nr? @nrc", "tree": {"sha": "3979cf9470b27f76fb236391cca8e06c31ddd07d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3979cf9470b27f76fb236391cca8e06c31ddd07d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "html_url": "https://github.com/rust-lang/rust/commit/f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f28719efd4268bcd8747b65810646e86901155", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f28719efd4268bcd8747b65810646e86901155", "html_url": "https://github.com/rust-lang/rust/commit/18f28719efd4268bcd8747b65810646e86901155"}, {"sha": "2cd6ccf0b14818cd1093a4618de2a854fb43f78b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd6ccf0b14818cd1093a4618de2a854fb43f78b", "html_url": "https://github.com/rust-lang/rust/commit/2cd6ccf0b14818cd1093a4618de2a854fb43f78b"}], "stats": {"total": 331, "additions": 113, "deletions": 218}, "files": [{"sha": "e31a1f1624fe109f59a09f9d158448a075b8c010", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -577,15 +577,13 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n-    let mut feature_gated_cfgs = vec![];\n-    krate = time(time_passes, \"configuration 1\", || {\n-        sess.track_errors(|| {\n-            syntax::config::strip_unconfigured_items(sess.diagnostic(),\n-                                                     krate,\n-                                                     sess.opts.test,\n-                                                     &mut feature_gated_cfgs)\n-        })\n-    })?;\n+    krate = time(time_passes, \"configuration\", || {\n+        let (krate, features) =\n+            syntax::config::strip_unconfigured_items(krate, &sess.parse_sess, sess.opts.test);\n+        // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+        *sess.features.borrow_mut() = features;\n+        krate\n+    });\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n     sess.crate_disambiguator.set(token::intern(&compute_crate_disambiguator(sess)));\n@@ -594,13 +592,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-    sess.track_errors(|| {\n-        *sess.features.borrow_mut() =\n-            syntax::feature_gate::get_features(&sess.parse_sess.span_diagnostic,\n-                                               &krate);\n-    })?;\n-\n     krate = time(time_passes, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.clone();\n         syntax::std_inject::maybe_inject_crates_ref(&sess.parse_sess, krate, alt_std_name)\n@@ -699,7 +690,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n         let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n                                                       krate.config.clone(),\n                                                       cfg,\n-                                                      &mut feature_gated_cfgs,\n                                                       &mut loader);\n         syntax_ext::register_builtins(&mut ecx.syntax_env);\n         let (ret, macro_names) = syntax::ext::expand::expand_crate(ecx,\n@@ -712,19 +702,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n         ret\n     });\n \n-    krate = sess.track_errors(|| {\n-        time(time_passes, \"gated configuration checking\", || {\n-            let features = sess.features.borrow();\n-            feature_gated_cfgs.sort();\n-            feature_gated_cfgs.dedup();\n-            for cfg in &feature_gated_cfgs {\n-                cfg.check_and_emit(sess.diagnostic(), &features, sess.codemap());\n-            }\n-        });\n-\n-        krate\n-    })?;\n-\n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n                                          sess.opts.test,\n@@ -739,12 +716,11 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(time_passes, \"complete gated feature checking\", || {\n         sess.track_errors(|| {\n-            let features = syntax::feature_gate::check_crate(sess.codemap(),\n-                                                             &sess.parse_sess.span_diagnostic,\n-                                                             &krate,\n-                                                             &attributes,\n-                                                             sess.opts.unstable_features);\n-            *sess.features.borrow_mut() = features;\n+            syntax::feature_gate::check_crate(&krate,\n+                                              &sess.parse_sess,\n+                                              &sess.features.borrow(),\n+                                              &attributes,\n+                                              sess.opts.unstable_features);\n         })\n     })?;\n "}, {"sha": "e36e15802f0ae1609af5bf7e86faf37510fd7f34", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -20,12 +20,11 @@ use ast::{Stmt, StmtKind, DeclKind};\n use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n-use config::CfgDiag;\n use errors::Handler;\n-use feature_gate::{GatedCfg, GatedCfgAttr};\n+use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n-use parse::token;\n+use parse::{ParseSess, token};\n use ptr::P;\n \n use std::cell::{RefCell, Cell};\n@@ -365,35 +364,29 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n-                           cfg: &ast::MetaItem,\n-                           diag: &mut T) -> bool {\n+pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n+                   sess: &ParseSess, features: Option<&Features>)\n+                   -> bool {\n     match cfg.node {\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(cfgs, &mi, diag)),\n+            mis.iter().any(|mi| cfg_matches(cfgs, &mi, sess, features)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(cfgs, &mi, diag)),\n+            mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                diag.emit_error(|diagnostic| {\n-                    diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n-                });\n+                sess.span_diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n-            !cfg_matches(cfgs, &mis[0], diag)\n+            !cfg_matches(cfgs, &mis[0], sess, features)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n-            diag.emit_error(|diagnostic| {\n-                diagnostic.span_err(cfg.span,\n-                    &format!(\"invalid predicate `{}`\", pred));\n-            });\n+            sess.span_diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n             false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n-            diag.flag_gated(|feature_gated_cfgs| {\n-                feature_gated_cfgs.extend(\n-                    GatedCfg::gate(cfg).map(GatedCfgAttr::GatedCfg));\n-            });\n+            if let (Some(features), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+                gated_cfg.check_and_emit(sess, features);\n+            }\n             contains(cfgs, cfg)\n         }\n     }"}, {"sha": "0e5d6841c82582830c9bff41dd4233d4eb72f659", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -9,36 +9,24 @@\n // except according to those terms.\n \n use attr::{AttrMetaMethods, HasAttrs};\n-use errors::Handler;\n-use feature_gate::GatedCfgAttr;\n+use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use fold::Folder;\n use {ast, fold, attr};\n use codemap::{Spanned, respan};\n-use parse::token;\n+use parse::{ParseSess, token};\n use ptr::P;\n \n use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    diag: CfgDiagReal<'a, 'a>,\n-    should_test: bool,\n-    config: &'a ast::CrateConfig,\n+    pub config: &'a ast::CrateConfig,\n+    pub should_test: bool,\n+    pub sess: &'a ParseSess,\n+    pub features: Option<&'a Features>,\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn new(config: &'a ast::CrateConfig,\n-               should_test: bool,\n-               diagnostic: &'a Handler,\n-               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>)\n-               -> Self {\n-        StripUnconfigured {\n-            config: config,\n-            should_test: should_test,\n-            diag: CfgDiagReal { diag: diagnostic, feature_gated_cfgs: feature_gated_cfgs },\n-        }\n-    }\n-\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         let node = self.process_cfg_attrs(node);\n         if self.in_cfg(node.attrs()) { Some(node) } else { None }\n@@ -59,20 +47,20 @@ impl<'a> StripUnconfigured<'a> {\n             Some(attr_list) => attr_list,\n             None => {\n                 let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.diag.diag.span_err(attr.span, msg);\n+                self.sess.span_diagnostic.span_err(attr.span, msg);\n                 return None;\n             }\n         };\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n                 let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.diag.diag.span_err(attr.span, msg);\n+                self.sess.span_diagnostic.span_err(attr.span, msg);\n                 return None;\n             }\n         };\n \n-        if attr::cfg_matches(self.config, &cfg, &mut self.diag) {\n+        if attr::cfg_matches(self.config, &cfg, self.sess, self.features) {\n             self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,\n@@ -98,41 +86,55 @@ impl<'a> StripUnconfigured<'a> {\n             };\n \n             if mis.len() != 1 {\n-                self.diag.emit_error(|diagnostic| {\n-                    diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n-                });\n+                self.sess.span_diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n                 return true;\n             }\n \n-            attr::cfg_matches(self.config, &mis[0], &mut self.diag)\n+            attr::cfg_matches(self.config, &mis[0], self.sess, self.features)\n         })\n     }\n \n     // Visit attributes on expression and statements (but not attributes on items in blocks).\n     fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n-            self.diag.feature_gated_cfgs.push(GatedCfgAttr::GatedAttr(attr.span));\n-        }\n-    }\n-\n-    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n-    fn visit_unremovable_expr(&mut self, expr: &ast::Expr) {\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n-            let msg = \"removing an expression is not supported in this position\";\n-            self.diag.diag.span_err(attr.span, msg);\n+            if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n+                emit_feature_err(&self.sess.span_diagnostic,\n+                                 \"stmt_expr_attributes\",\n+                                 attr.span,\n+                                 GateIssue::Language,\n+                                 EXPLAIN_STMT_ATTR_SYNTAX);\n+            }\n         }\n     }\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate, should_test: bool,\n-                                feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n-                                -> ast::Crate\n-{\n-    let config = &krate.config.clone();\n-    StripUnconfigured::new(config, should_test, diagnostic, feature_gated_cfgs).fold_crate(krate)\n+pub fn strip_unconfigured_items(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n+                                -> (ast::Crate, Features) {\n+    let features;\n+    {\n+        let mut strip_unconfigured = StripUnconfigured {\n+            config: &krate.config.clone(),\n+            should_test: should_test,\n+            sess: sess,\n+            features: None,\n+        };\n+\n+        let err_count = sess.span_diagnostic.err_count();\n+        let krate_attrs = strip_unconfigured.process_cfg_attrs(krate.attrs.clone());\n+        features = get_features(&sess.span_diagnostic, &krate_attrs);\n+        if err_count < sess.span_diagnostic.err_count() {\n+            krate.attrs = krate_attrs.clone(); // Avoid reconfiguring malformed `cfg_attr`s\n+        }\n+\n+        strip_unconfigured.features = Some(&features);\n+        krate = strip_unconfigured.fold_crate(krate);\n+        krate.attrs = krate_attrs;\n+    }\n+\n+    (krate, features)\n }\n \n impl<'a> fold::Folder for StripUnconfigured<'a> {\n@@ -188,14 +190,19 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n \n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.visit_stmt_or_expr_attrs(expr.attrs());\n+\n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n         // Anything else is always required, and thus has to error out\n         // in case of a cfg attr.\n         //\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n-        self.visit_unremovable_expr(&expr);\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n+            let msg = \"removing an expression is not supported in this position\";\n+            self.sess.span_diagnostic.span_err(attr.span, msg);\n+        }\n+\n         let expr = self.process_cfg_attrs(expr);\n         fold_expr(self, expr)\n     }\n@@ -273,22 +280,3 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"test\") || attr.check_name(\"bench\")\n }\n-\n-pub trait CfgDiag {\n-    fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n-    fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n-}\n-\n-pub struct CfgDiagReal<'a, 'b> {\n-    pub diag: &'a Handler,\n-    pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n-}\n-\n-impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n-    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&Handler) {\n-        f(self.diag)\n-    }\n-    fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n-        f(self.feature_gated_cfgs)\n-    }\n-}"}, {"sha": "4f700e9170fc8ff45c4313836c04945b88c6c73f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -18,7 +18,6 @@ use errors::DiagnosticBuilder;\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n-use feature_gate::GatedCfgAttr;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -556,7 +555,6 @@ pub struct ExtCtxt<'a> {\n     pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n-    pub feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n     pub loader: &'a mut MacroLoader,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -573,7 +571,6 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n                loader: &'a mut MacroLoader)\n                -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n@@ -584,7 +581,6 @@ impl<'a> ExtCtxt<'a> {\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             crate_root: None,\n-            feature_gated_cfgs: feature_gated_cfgs,\n             exported_macros: Vec::new(),\n             loader: loader,\n             syntax_env: env,"}, {"sha": "ed419d94ee43deff044b8ab14d9d33e6283969b6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -998,10 +998,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn strip_unconfigured(&mut self) -> StripUnconfigured {\n-        StripUnconfigured::new(&self.cx.cfg,\n-                               self.cx.ecfg.should_test,\n-                               &self.cx.parse_sess.span_diagnostic,\n-                               self.cx.feature_gated_cfgs)\n+        StripUnconfigured {\n+            config: &self.cx.cfg,\n+            should_test: self.cx.ecfg.should_test,\n+            sess: self.cx.parse_sess,\n+            features: self.cx.ecfg.features,\n+        }\n     }\n \n     fn load_macros<T: MacroGenerable>(&mut self, node: &T) {\n@@ -1331,8 +1333,8 @@ mod tests {\n             src,\n             Vec::new(), &sess).unwrap();\n         // should fail:\n-        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        let mut loader = DummyMacroLoader;\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n         expand_crate(ecx, vec![], crate_ast);\n     }\n \n@@ -1346,8 +1348,8 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess).unwrap();\n-        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        let mut loader = DummyMacroLoader;\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n         expand_crate(ecx, vec![], crate_ast);\n     }\n \n@@ -1360,17 +1362,17 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess).unwrap();\n-        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        let mut loader = DummyMacroLoader;\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n         expand_crate(ecx, vec![], crate_ast);\n     }\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n-        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n-        let ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        let mut loader = DummyMacroLoader;\n+        let ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut loader);\n         expand_crate(ecx, vec![], crate_ast).0\n     }\n "}, {"sha": "550eb0a56d98c799daf28f31afce3da6f1cb73a0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 71, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -34,10 +34,10 @@ use codemap::{CodeMap, Span};\n use errors::Handler;\n use visit;\n use visit::{FnKind, Visitor};\n+use parse::ParseSess;\n use parse::token::InternedString;\n \n use std::ascii::AsciiExt;\n-use std::cmp;\n \n macro_rules! setter {\n     ($field: ident) => {{\n@@ -603,60 +603,12 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n ];\n \n-#[derive(Debug, Eq, PartialEq)]\n-pub enum GatedCfgAttr {\n-    GatedCfg(GatedCfg),\n-    GatedAttr(Span),\n-}\n-\n #[derive(Debug, Eq, PartialEq)]\n pub struct GatedCfg {\n     span: Span,\n     index: usize,\n }\n \n-impl Ord for GatedCfgAttr {\n-    fn cmp(&self, other: &GatedCfgAttr) -> cmp::Ordering {\n-        let to_tup = |s: &GatedCfgAttr| match *s {\n-            GatedCfgAttr::GatedCfg(ref gated_cfg) => {\n-                (gated_cfg.span.lo.0, gated_cfg.span.hi.0, gated_cfg.index)\n-            }\n-            GatedCfgAttr::GatedAttr(ref span) => {\n-                (span.lo.0, span.hi.0, GATED_CFGS.len())\n-            }\n-        };\n-        to_tup(self).cmp(&to_tup(other))\n-    }\n-}\n-\n-impl PartialOrd for GatedCfgAttr {\n-    fn partial_cmp(&self, other: &GatedCfgAttr) -> Option<cmp::Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl GatedCfgAttr {\n-    pub fn check_and_emit(&self,\n-                          diagnostic: &Handler,\n-                          features: &Features,\n-                          codemap: &CodeMap) {\n-        match *self {\n-            GatedCfgAttr::GatedCfg(ref cfg) => {\n-                cfg.check_and_emit(diagnostic, features, codemap);\n-            }\n-            GatedCfgAttr::GatedAttr(span) => {\n-                if !features.stmt_expr_attributes {\n-                    emit_feature_err(diagnostic,\n-                                     \"stmt_expr_attributes\",\n-                                     span,\n-                                     GateIssue::Language,\n-                                     EXPLAIN_STMT_ATTR_SYNTAX);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n         let name = cfg.name();\n@@ -669,12 +621,11 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    fn check_and_emit(&self,\n-                      diagnostic: &Handler,\n-                      features: &Features,\n-                      codemap: &CodeMap) {\n+\n+    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) && !codemap.span_allows_unstable(self.span) {\n+        if !has_feature(features) && !sess.codemap().span_allows_unstable(self.span) {\n+            let diagnostic = &sess.span_diagnostic;\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n             emit_feature_err(diagnostic, feature, self.span, GateIssue::Language, &explain);\n         }\n@@ -810,7 +761,7 @@ pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIs\n const EXPLAIN_BOX_SYNTAX: &'static str =\n     \"box expression syntax is experimental; you can call `Box::new` instead.\";\n \n-const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n+pub const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n     \"attributes on non-item statements and expressions are experimental.\";\n \n pub const EXPLAIN_ASM: &'static str =\n@@ -1142,10 +1093,10 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n }\n \n-pub fn get_features(span_handler: &Handler, krate: &ast::Crate) -> Features {\n+pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> Features {\n     let mut features = Features::new();\n \n-    for attr in &krate.attrs {\n+    for attr in krate_attrs {\n         if !attr.check_name(\"feature\") {\n             continue\n         }\n@@ -1188,21 +1139,19 @@ pub fn get_features(span_handler: &Handler, krate: &ast::Crate) -> Features {\n     features\n }\n \n-pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n+pub fn check_crate(krate: &ast::Crate,\n+                   sess: &ParseSess,\n+                   features: &Features,\n                    plugin_attributes: &[(String, AttributeType)],\n-                   unstable: UnstableFeatures) -> Features {\n-    maybe_stage_features(span_handler, krate, unstable);\n-    let features = get_features(span_handler, krate);\n-    {\n-        let ctx = Context {\n-            features: &features,\n-            span_handler: span_handler,\n-            cm: cm,\n-            plugin_attributes: plugin_attributes,\n-        };\n-        visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n-    }\n-    features\n+                   unstable: UnstableFeatures) {\n+    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n+    let ctx = Context {\n+        features: features,\n+        span_handler: &sess.span_diagnostic,\n+        cm: sess.codemap(),\n+        plugin_attributes: plugin_attributes,\n+    };\n+    visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "ca6ed76d5499bddc9bb476e80f82871b9132629a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -270,14 +270,12 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n-    let mut feature_gated_cfgs = vec![];\n     let mut loader = DummyMacroLoader;\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, vec![],\n                              ExpansionConfig::default(\"test\".to_string()),\n-                             &mut feature_gated_cfgs,\n                              &mut loader),\n         path: Vec::new(),\n         testfns: Vec::new(),"}, {"sha": "593bf14a0182f69afc575a0d79a4bdc538e56964", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -19,7 +19,6 @@ use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::config::CfgDiagReal;\n \n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n@@ -33,12 +32,6 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = {\n-        let mut diag = CfgDiagReal {\n-            diag: &cx.parse_sess.span_diagnostic,\n-            feature_gated_cfgs: cx.feature_gated_cfgs,\n-        };\n-        attr::cfg_matches(&cx.cfg, &cfg, &mut diag)\n-    };\n+    let matches_cfg = attr::cfg_matches(&cx.cfg, &cfg, cx.parse_sess, cx.ecfg.features);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "89a4869bd6975b76cd3329b2666c56b0c81fa3b5", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut Vec::new(), &mut loader);\n+        &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "560b742f8a6c72914cff88bf32284526d8fadbb8", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -23,11 +23,11 @@ use syntax::print::pprust;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let (mut feature_gated_cfgs, mut loader) = (vec![], syntax::ext::base::DummyMacroLoader);\n+    let mut loader = syntax::ext::base::DummyMacroLoader;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut feature_gated_cfgs, &mut loader);\n+        &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "65c642a1eca592c20a7fc91f1a2b4e2c46fd6f6b", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f911d87b3b6ee3e484ca8dd7da4be85970d9230d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "patch": "@@ -20,11 +20,11 @@ use syntax::parse::token::intern;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let (mut feature_gated_cfgs, mut loader) = (vec![], syntax::ext::base::DummyMacroLoader);\n+    let mut loader = syntax::ext::base::DummyMacroLoader;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut feature_gated_cfgs, &mut loader);\n+        &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}]}