{"sha": "0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OThkYTlhM2RjMDYxZjYwNGZjZmI5YjU2YmQ4ODllMDdmMmI3ZTI=", "commit": {"author": {"name": "Jeremy Soller", "email": "jeremy@system76.com", "date": "2019-04-07T14:39:54Z"}, "committer": {"name": "Jeremy Soller", "email": "jeremy@system76.com", "date": "2019-08-06T22:18:23Z"}, "message": "redox: convert to target_family unix", "tree": {"sha": "c297dc9d51cd63c0a1297426ae3633e3921dcb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c297dc9d51cd63c0a1297426ae3633e3921dcb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFIBAABCgAyFiEE2gh4/PgGCJ7U/d9Y6Yi0nueKf7EFAl1J/LAUHGplcmVteUBz\neXN0ZW03Ni5jb20ACgkQ6Yi0nueKf7FrUgf9FQwoUm1gPEQ+CLePTkIRVPXaMF2S\nSm4fPkQI6MpNvS9IwzozXlpwzIcoRwLO8C83uU/A3X/3KhUrumwH9bGL1+3K/wgQ\ndSLnf7jdWNIXizeYlunt7462m0icGMtHj9EMA8a2FbCcW41ZZAbe//YEbmKJiLrI\n4wrPUf2cnT5VRTkW1HjkF49gLIxmI3nQBKRErJUZ+DR95T5yWn6KMh51pWJ1vvEl\nhrDAoYxbGFkJB4P37E0/J/Dr4LxShLVfIHq/NSV4sZXrSqXrdjwxtXwqt2s1eabH\n0uPqyFNcFHZ9VhPiW9m7ux7GzgmbAaRujR7kOpLVizidvfEgCGL1QfQR+A==\n=gWj1\n-----END PGP SIGNATURE-----", "payload": "tree c297dc9d51cd63c0a1297426ae3633e3921dcb44\nparent 6a91782b72fca586b15ba68364bc7baab837af86\nauthor Jeremy Soller <jeremy@system76.com> 1554647994 -0600\ncommitter Jeremy Soller <jeremy@system76.com> 1565129903 -0600\n\nredox: convert to target_family unix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "html_url": "https://github.com/rust-lang/rust/commit/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a91782b72fca586b15ba68364bc7baab837af86", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a91782b72fca586b15ba68364bc7baab837af86", "html_url": "https://github.com/rust-lang/rust/commit/6a91782b72fca586b15ba68364bc7baab837af86"}], "stats": {"total": 7030, "additions": 590, "deletions": 6440}, "files": [{"sha": "e556adaa13ea738db2fdb9b30069fa8ac06583ea", "filename": "src/doc/unstable-book/src/library-features/n16.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,5 +0,0 @@\n-# `n16`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "fd144d6b67e759594093cc481450a63005b1c5b2", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -48,8 +48,7 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n         libc::abort();\n     }\n \n-    #[cfg(any(target_os = \"redox\",\n-              windows,\n+    #[cfg(any(windows,\n               all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();"}, {"sha": "f347a2dba53f39ca9bca39d99053a0c8c7b7487c", "filename": "src/librustc_target/spec/aarch64_unknown_redox.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_redox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_redox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_redox.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -0,0 +1,20 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::redox_base::opts();\n+    base.max_atomic_width = Some(128);\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-redox\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"redox\".to_string(),\n+        target_env: \"relibc\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "ec72c00c28f61a19476725c1cdb755504218249e", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -417,6 +417,7 @@ supported_targets! {\n \n     (\"x86_64-unknown-l4re-uclibc\", x86_64_unknown_l4re_uclibc),\n \n+    (\"aarch64-unknown-redox\", aarch64_unknown_redox),\n     (\"x86_64-unknown-redox\", x86_64_unknown_redox),\n \n     (\"i386-apple-ios\", i386_apple_ios),"}, {"sha": "7226ad15828197f5c1e2b9b6545b57e04bcddb4e", "filename": "src/librustc_target/spec/redox_base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fredox_base.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions, RelroLevel};\n use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n@@ -18,14 +18,17 @@ pub fn opts() -> TargetOptions {\n     ]);\n \n     TargetOptions {\n-        pre_link_args: args,\n+        dynamic_linking: true,\n         executables: true,\n-        relocation_model: \"static\".to_string(),\n-        disable_redzone: true,\n-        eliminate_frame_pointer: false,\n-        target_family: None,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n+        has_rpath: true,\n+        pre_link_args: args,\n+        position_independent_executables: true,\n+        relro_level: RelroLevel::Full,\n         has_elf_tls: true,\n+        crt_static_default: true,\n+        crt_static_respected: true,\n         .. Default::default()\n     }\n }"}, {"sha": "8a5af27f13aacab8d7b25c25dc819ffb35b1d73e", "filename": "src/librustc_target/spec/x86_64_unknown_redox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_redox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_redox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_redox.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"redox\".to_string(),\n-        target_env: String::new(),\n+        target_env: \"relibc\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,"}, {"sha": "fcd81f0a1b2deceb5828e5ec4210531e9c10c85b", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -50,6 +50,7 @@ cfg_if::cfg_if! {\n #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n #[cfg(target_os = \"hermit\")]     pub mod hermit;\n+#[cfg(target_os = \"redox\")]      pub mod redox;\n #[cfg(target_os = \"wasi\")]       pub mod wasi;\n #[cfg(target_os = \"vxworks\")]    pub mod vxworks;\n #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] pub mod fortanix_sgx;"}, {"sha": "80a1290761984e9f6abe3e0729407867a9334f39", "filename": "src/libstd/os/redox/fs.rs", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Ffs.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -0,0 +1,383 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use crate::os::redox::raw;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    /// Gain a reference to the underlying `stat` structure which contains\n+    /// the raw information returned by the OS.\n+    ///\n+    /// The contents of the returned [`stat`] are **not** consistent across\n+    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n+    /// cross-Unix abstractions contained within the raw stat.\n+    ///\n+    /// [`stat`]: ../../../../std/os/redox/raw/struct.stat.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let stat = meta.as_raw_stat();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(since = \"1.8.0\",\n+                       reason = \"deprecated in favor of the accessor \\\n+                                 methods of this trait\")]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    /// Returns the device ID on which this file resides.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_dev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    /// Returns the inode number.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ino());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    /// Returns the file type and mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mode());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    /// Returns the number of hard links to file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_nlink());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    /// Returns the user ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_uid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    /// Returns the group ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_gid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    /// Returns the device ID that this file represents. Only relevant for special file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_rdev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n+    ///\n+    /// The size of a symbolic link is the length of the pathname it contains,\n+    /// without a terminating null byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_size());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    /// Returns the last access time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    /// Returns the last access time of the file, in nanoseconds since [`st_atime`].\n+    ///\n+    /// [`st_atime`]: #tymethod.st_atime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    /// Returns the last modification time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    /// Returns the last modification time of the file, in nanoseconds since [`st_mtime`].\n+    ///\n+    /// [`st_mtime`]: #tymethod.st_mtime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    /// Returns the last status change time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    /// Returns the last status change time of the file, in nanoseconds since [`st_ctime`].\n+    ///\n+    /// [`st_ctime`]: #tymethod.st_ctime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blksize());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    /// Returns the number of blocks allocated to the file, 512-byte units.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::redox::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blocks());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe {\n+            &*(self.as_inner().as_inner() as *const libc::stat\n+                                          as *const raw::stat)\n+        }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "c60da5926da6e1ee1b601c0485420520d63ce70e", "filename": "src/libstd/os/redox/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -0,0 +1,6 @@\n+//! Redox-specific definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod raw;\n+pub mod fs;"}, {"sha": "23d8ff7694bc5678eef7a94ec6f91e62f51dc9c0", "filename": "src/libstd/os/redox/raw.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fos%2Fredox%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Fraw.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -0,0 +1,67 @@\n+//! Redox-specific raw type definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(since = \"1.8.0\",\n+                    reason = \"these type aliases are no longer supported by \\\n+                              the standard library, the `libc` crate on \\\n+                              crates.io should be used instead for the correct \\\n+                              definitions\")]\n+#![allow(deprecated)]\n+#![allow(missing_debug_implementations)]\n+\n+use crate::os::raw::{c_char, c_int, c_long, c_ulong, c_void};\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type gid_t = c_int;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = c_int;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type uid_t = c_int;\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = *mut c_void;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = c_long;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub struct stat {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_dev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ino: ino_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_nlink: nlink_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mode: mode_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_uid: uid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_gid: gid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_rdev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_size: off_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blksize: blksize_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blocks: blkcnt_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub _pad: [c_char; 24],\n+}"}, {"sha": "87c071b512ac7327f0dc68b65aba54f1bc183a08", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -317,7 +317,7 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n \n // Detect scheme on Redox\n fn has_redox_scheme(s: &[u8]) -> bool {\n-    cfg!(target_os = \"redox\") && s.split(|b| *b == b'/').next().unwrap_or(b\"\").contains(&b':')\n+    cfg!(target_os = \"redox\") && s.contains(&b':')\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "5a5859a6ad8730962f4eef893465fd8afa53c6b6", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -35,9 +35,6 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"cloudabi\")] {\n         mod cloudabi;\n         pub use self::cloudabi::*;\n-    } else if #[cfg(target_os = \"redox\")] {\n-        mod redox;\n-        pub use self::redox::*;\n     } else if #[cfg(target_os = \"wasi\")] {\n         mod wasi;\n         pub use self::wasi::*;\n@@ -58,7 +55,7 @@ cfg_if::cfg_if! {\n \n #[cfg(rustdoc)]\n cfg_if::cfg_if! {\n-    if #[cfg(any(unix, target_os = \"redox\"))] {\n+    if #[cfg(unix)] {\n         // On unix we'll document what's already available\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as unix_ext;"}, {"sha": "f9e2f5ba311a090da85d043e45aba6ae539b0e3a", "filename": "src/libstd/sys/redox/args.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,96 +0,0 @@\n-//! Global initialization and retrieval of command line arguments.\n-//!\n-//! On some platforms these are stored during runtime startup,\n-//! and on some they are retrieved from the system on demand.\n-\n-#![allow(dead_code)] // runtime init functions not used during testing\n-\n-use crate::ffi::OsString;\n-use crate::marker::PhantomData;\n-use crate::vec;\n-\n-/// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n-\n-/// Returns the command line arguments\n-pub fn args() -> Args {\n-    imp::args()\n-}\n-\n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n-    }\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n-}\n-\n-mod imp {\n-    use crate::os::unix::prelude::*;\n-    use crate::mem;\n-    use crate::ffi::{CStr, OsString};\n-    use crate::marker::PhantomData;\n-    use super::Args;\n-\n-    use crate::sys_common::mutex::Mutex;\n-\n-    static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: Mutex = Mutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let args = (0..argc).map(|i| {\n-            CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n-        }).collect();\n-\n-        let _guard = LOCK.lock();\n-        let ptr = get_global_ptr();\n-        assert!((*ptr).is_none());\n-        (*ptr) = Some(box args);\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        let _guard = LOCK.lock();\n-        *get_global_ptr() = None;\n-    }\n-\n-    pub fn args() -> Args {\n-        let bytes = clone().unwrap_or_default();\n-        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n-            OsStringExt::from_vec(v)\n-        }).collect();\n-        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n-    }\n-\n-    fn clone() -> Option<Vec<Vec<u8>>> {\n-        unsafe {\n-            let _guard = LOCK.lock();\n-            let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s| (**s).clone())\n-        }\n-    }\n-\n-    unsafe fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n-        mem::transmute(&GLOBAL_ARGS_PTR)\n-    }\n-\n-}"}, {"sha": "f6bb58934fc050727800194bb82f89cf1020433d", "filename": "src/libstd/sys/redox/cmath.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcmath.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,33 +0,0 @@\n-#![cfg(not(test))]\n-\n-use libc::{c_float, c_double};\n-\n-#[link_name = \"m\"]\n-extern {\n-    pub fn acos(n: c_double) -> c_double;\n-    pub fn acosf(n: c_float) -> c_float;\n-    pub fn asin(n: c_double) -> c_double;\n-    pub fn asinf(n: c_float) -> c_float;\n-    pub fn atan(n: c_double) -> c_double;\n-    pub fn atan2(a: c_double, b: c_double) -> c_double;\n-    pub fn atan2f(a: c_float, b: c_float) -> c_float;\n-    pub fn atanf(n: c_float) -> c_float;\n-    pub fn cbrt(n: c_double) -> c_double;\n-    pub fn cbrtf(n: c_float) -> c_float;\n-    pub fn cosh(n: c_double) -> c_double;\n-    pub fn coshf(n: c_float) -> c_float;\n-    pub fn expm1(n: c_double) -> c_double;\n-    pub fn expm1f(n: c_float) -> c_float;\n-    pub fn fdim(a: c_double, b: c_double) -> c_double;\n-    pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-    pub fn hypot(x: c_double, y: c_double) -> c_double;\n-    pub fn hypotf(x: c_float, y: c_float) -> c_float;\n-    pub fn log1p(n: c_double) -> c_double;\n-    pub fn log1pf(n: c_float) -> c_float;\n-    pub fn sinh(n: c_double) -> c_double;\n-    pub fn sinhf(n: c_float) -> c_float;\n-    pub fn tan(n: c_double) -> c_double;\n-    pub fn tanf(n: c_float) -> c_float;\n-    pub fn tanh(n: c_double) -> c_double;\n-    pub fn tanhf(n: c_float) -> c_float;\n-}"}, {"sha": "a6365cac23ea740f5ef7f74a61b05068f5bdffa4", "filename": "src/libstd/sys/redox/condvar.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,111 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::intrinsics::{atomic_cxchg, atomic_load, atomic_xadd, atomic_xchg};\n-use crate::ptr;\n-use crate::time::Duration;\n-\n-use crate::sys::mutex::{mutex_unlock, Mutex};\n-use crate::sys::syscall::{futex, TimeSpec, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n-\n-pub struct Condvar {\n-    lock: UnsafeCell<*mut i32>,\n-    seq: UnsafeCell<i32>\n-}\n-\n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        Condvar {\n-            lock: UnsafeCell::new(ptr::null_mut()),\n-            seq: UnsafeCell::new(0)\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&self) {\n-        *self.lock.get() = ptr::null_mut();\n-        *self.seq.get() = 0;\n-    }\n-\n-    #[inline]\n-    pub fn notify_one(&self) {\n-        unsafe {\n-            let seq = self.seq.get();\n-\n-            atomic_xadd(seq, 1);\n-\n-            let _ = futex(seq, FUTEX_WAKE, 1, 0, ptr::null_mut());\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn notify_all(&self) {\n-        unsafe {\n-            let lock = self.lock.get();\n-            let seq = self.seq.get();\n-\n-            if *lock == ptr::null_mut() {\n-                return;\n-            }\n-\n-            atomic_xadd(seq, 1);\n-\n-            let _ = futex(seq, FUTEX_REQUEUE, 1, crate::usize::MAX, *lock);\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn wait_inner(&self, mutex: &Mutex, timeout_ptr: *const TimeSpec) -> bool {\n-        let lock = self.lock.get();\n-        let seq = self.seq.get();\n-\n-        if *lock != mutex.lock.get() {\n-            if *lock != ptr::null_mut() {\n-                panic!(\"Condvar used with more than one Mutex\");\n-            }\n-\n-            atomic_cxchg(lock as *mut usize, 0, mutex.lock.get() as usize);\n-        }\n-\n-        mutex_unlock(*lock);\n-\n-        let seq_before = atomic_load(seq);\n-\n-        let _ = futex(seq, FUTEX_WAIT, seq_before, timeout_ptr as usize, ptr::null_mut());\n-\n-        let seq_after = atomic_load(seq);\n-\n-        while atomic_xchg(*lock, 2) != 0 {\n-            let _ = futex(*lock, FUTEX_WAIT, 2, 0, ptr::null_mut());\n-        }\n-\n-        seq_before != seq_after\n-    }\n-\n-    #[inline]\n-    pub fn wait(&self, mutex: &Mutex) {\n-        unsafe {\n-            assert!(self.wait_inner(mutex, ptr::null()));\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        unsafe {\n-            let timeout = TimeSpec {\n-                tv_sec: dur.as_secs() as i64,\n-                tv_nsec: dur.subsec_nanos() as i32\n-            };\n-\n-            self.wait_inner(mutex, &timeout as *const TimeSpec)\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        *self.lock.get() = ptr::null_mut();\n-        *self.seq.get() = 0;\n-    }\n-}\n-\n-unsafe impl Send for Condvar {}\n-\n-unsafe impl Sync for Condvar {}"}, {"sha": "bcc0e126b9dd3d8a9aaf5cec8f24c6959613b520", "filename": "src/libstd/sys/redox/env.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,9 +0,0 @@\n-pub mod os {\n-    pub const FAMILY: &str = \"redox\";\n-    pub const OS: &str = \"redox\";\n-    pub const DLL_PREFIX: &str = \"lib\";\n-    pub const DLL_SUFFIX: &str = \".so\";\n-    pub const DLL_EXTENSION: &str = \"so\";\n-    pub const EXE_SUFFIX: &str = \"\";\n-    pub const EXE_EXTENSION: &str = \"\";\n-}"}, {"sha": "974d7b82c125fd1293b76c468449e01a07c22abe", "filename": "src/libstd/sys/redox/ext/ffi.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,38 +0,0 @@\n-//! Redox-specific extension to the primitives in the `std::ffi` module.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! use std::ffi::OsString;\n-//! use std::os::redox::ffi::OsStringExt;\n-//!\n-//! let bytes = b\"foo\".to_vec();\n-//!\n-//! // OsStringExt::from_vec\n-//! let os_string = OsString::from_vec(bytes);\n-//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStringExt::into_vec\n-//! let bytes = os_string.into_vec();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-//!\n-//! ```\n-//! use std::ffi::OsStr;\n-//! use std::os::redox::ffi::OsStrExt;\n-//!\n-//! let bytes = b\"foo\";\n-//!\n-//! // OsStrExt::from_bytes\n-//! let os_str = OsStr::from_bytes(bytes);\n-//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStrExt::as_bytes\n-//! let bytes = os_str.as_bytes();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "4ddc1f09a319bab3c02a2ce518a6e6b3e6d00d55", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "removed", "additions": 0, "deletions": 339, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,339 +0,0 @@\n-//! Redox-specific extensions to primitives in the `std::fs` module.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs::{self, Permissions, OpenOptions};\n-use crate::io;\n-use crate::path::Path;\n-use crate::sys;\n-use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n-\n-/// Redox-specific extensions to [`fs::Permissions`].\n-///\n-/// [`fs::Permissions`]: ../../../../std/fs/struct.Permissions.html\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait PermissionsExt {\n-    /// Returns the underlying raw `mode_t` bits that are the standard Redox\n-    /// permissions for this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::redox::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let permissions = metadata.permissions();\n-    ///\n-    ///     println!(\"permissions: {:o}\", permissions.mode());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-\n-    /// Sets the underlying raw bits for this set of permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::redox::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let mut permissions = metadata.permissions();\n-    ///\n-    ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n-    ///     assert_eq!(permissions.mode(), 0o644);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn set_mode(&mut self, mode: u32);\n-\n-    /// Creates a new instance of `Permissions` from the given set of Redox\n-    /// permission bits.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fs::Permissions;\n-    /// use std::os::redox::fs::PermissionsExt;\n-    ///\n-    /// // Read/write for owner and read for others.\n-    /// let permissions = Permissions::from_mode(0o644);\n-    /// assert_eq!(permissions.mode(), 0o644);\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn from_mode(mode: u32) -> Self;\n-}\n-\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl PermissionsExt for Permissions {\n-    fn mode(&self) -> u32 {\n-        self.as_inner().mode()\n-    }\n-\n-    fn set_mode(&mut self, mode: u32) {\n-        *self = Permissions::from_inner(FromInner::from_inner(mode));\n-    }\n-\n-    fn from_mode(mode: u32) -> Permissions {\n-        Permissions::from_inner(FromInner::from_inner(mode))\n-    }\n-}\n-\n-/// Redox-specific extensions to [`fs::OpenOptions`].\n-///\n-/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait OpenOptionsExt {\n-    /// Sets the mode bits that a new file will be created with.\n-    ///\n-    /// If a new file is created as part of a `File::open_opts` call then this\n-    /// specified `mode` will be used as the permission bits for the new file.\n-    /// If no `mode` is set, the default of `0o666` will be used.\n-    /// The operating system masks out bits with the systems `umask`, to produce\n-    /// the final permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::redox::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.mode(0o644); // Give read/write for owner and read for others.\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-\n-    /// Passes custom flags to the `flags` argument of `open`.\n-    ///\n-    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n-    /// ensure they do not interfere with the access mode set by Rusts options.\n-    ///\n-    /// Custom flags can only set flags, not remove flags set by Rusts options.\n-    /// This options overwrites any previously set custom flags.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::redox::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.write(true);\n-    /// if cfg!(target_os = \"redox\") {\n-    ///     options.custom_flags(libc::O_NOFOLLOW);\n-    /// }\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n-    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n-}\n-\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl OpenOptionsExt for OpenOptions {\n-    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().mode(mode); self\n-    }\n-\n-    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n-    }\n-}\n-\n-/// Redox-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn dev(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ino(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn nlink(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn uid(&self) -> u32;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn gid(&self) -> u32;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn size(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn atime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn atime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mtime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mtime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ctime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ctime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blksize(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blocks(&self) -> u64;\n-}\n-\n-// Hm, why are there casts here to the returned type, shouldn't the types always\n-// be the same? Right you are! Turns out, however, on android at least the types\n-// in the raw `stat` structure are not the same as the types being returned. Who\n-// knew!\n-//\n-// As a result to make sure this compiles for all platforms we do the manual\n-// casts and rely on manual lowering to `stat` if the raw type is desired.\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 {\n-        self.as_inner().as_inner().st_dev as u64\n-    }\n-    fn ino(&self) -> u64 {\n-        self.as_inner().as_inner().st_ino as u64\n-    }\n-    fn mode(&self) -> u32 {\n-        self.as_inner().as_inner().st_mode as u32\n-    }\n-    fn nlink(&self) -> u64 {\n-        self.as_inner().as_inner().st_nlink as u64\n-    }\n-    fn uid(&self) -> u32 {\n-        self.as_inner().as_inner().st_uid as u32\n-    }\n-    fn gid(&self) -> u32 {\n-        self.as_inner().as_inner().st_gid as u32\n-    }\n-    fn size(&self) -> u64 {\n-        self.as_inner().as_inner().st_size as u64\n-    }\n-    fn atime(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime as i64\n-    }\n-    fn atime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime_nsec as i64\n-    }\n-    fn mtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime as i64\n-    }\n-    fn mtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime_nsec as i64\n-    }\n-    fn ctime(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime as i64\n-    }\n-    fn ctime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime_nsec as i64\n-    }\n-    fn blksize(&self) -> u64 {\n-        self.as_inner().as_inner().st_blksize as u64\n-    }\n-    fn blocks(&self) -> u64 {\n-        self.as_inner().as_inner().st_blocks as u64\n-    }\n-}\n-\n-/// Redox-specific extensions for [`FileType`].\n-///\n-/// Adds support for special Unix file types such as block/character devices,\n-/// pipes, and sockets.\n-///\n-/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-pub trait FileTypeExt {\n-    /// Returns whether this file type is a block device.\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_block_device(&self) -> bool;\n-    /// Returns whether this file type is a char device.\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_char_device(&self) -> bool;\n-    /// Returns whether this file type is a fifo.\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_fifo(&self) -> bool;\n-    /// Returns whether this file type is a socket.\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_socket(&self) -> bool;\n-}\n-\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { false /*FIXME: Implement block device mode*/ }\n-    fn is_char_device(&self) -> bool { false /*FIXME: Implement char device mode*/ }\n-    fn is_fifo(&self) -> bool { false /*FIXME: Implement fifo mode*/ }\n-    fn is_socket(&self) -> bool { false /*FIXME: Implement socket mode*/ }\n-}\n-\n-/// Creates a new symbolic link on the filesystem.\n-///\n-/// The `dst` path will be a symbolic link pointing to the `src` path.\n-///\n-/// # Note\n-///\n-/// On Windows, you must specify whether a symbolic link points to a file\n-/// or directory. Use `os::windows::fs::symlink_file` to create a\n-/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n-/// symbolic link to a directory. Additionally, the process must have\n-/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n-/// symbolic link.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::redox::fs;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     fs::symlink(\"a.txt\", \"b.txt\")?;\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-{\n-    sys::fs::symlink(src.as_ref(), dst.as_ref())\n-}\n-\n-/// Redox-specific extensions to [`fs::DirBuilder`].\n-///\n-/// [`fs::DirBuilder`]: ../../../../std/fs/struct.DirBuilder.html\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-pub trait DirBuilderExt {\n-    /// Sets the mode to create new directories with. This option defaults to\n-    /// 0o777.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::DirBuilder;\n-    /// use std::os::redox::fs::DirBuilderExt;\n-    ///\n-    /// let mut builder = DirBuilder::new();\n-    /// builder.mode(0o755);\n-    /// ```\n-    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-}\n-\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-impl DirBuilderExt for fs::DirBuilder {\n-    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n-        self.as_inner_mut().set_mode(mode);\n-        self\n-    }\n-}"}, {"sha": "c21d216478fb7a2c8e3d8482fb2d2556cc742725", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,172 +0,0 @@\n-//! Unix-specific extensions to general I/O primitives\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs;\n-use crate::net;\n-use crate::sys;\n-use crate::io;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-\n-/// Raw file descriptors.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type RawFd = usize;\n-\n-/// A trait to extract the raw unix file descriptor from an underlying\n-/// object.\n-///\n-/// This is only available on unix platforms and must be imported in order\n-/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-/// and `AsRawSocket` set of traits.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait AsRawFd {\n-    /// Extracts the raw file descriptor.\n-    ///\n-    /// This method does **not** pass ownership of the raw file descriptor\n-    /// to the caller. The descriptor is only guaranteed to be valid while\n-    /// the original object has not yet been destroyed.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_raw_fd(&self) -> RawFd;\n-}\n-\n-/// A trait to express the ability to construct an object from a raw file\n-/// descriptor.\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-pub trait FromRawFd {\n-    /// Constructs a new instances of `Self` from the given raw file\n-    /// descriptor.\n-    ///\n-    /// This function **consumes ownership** of the specified file\n-    /// descriptor. The returned object will take responsibility for closing\n-    /// it when the object goes out of scope.\n-    ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n-    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-}\n-\n-/// A trait to express the ability to consume an object and acquire ownership of\n-/// its raw file descriptor.\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-pub trait IntoRawFd {\n-    /// Consumes this object, returning the raw underlying file descriptor.\n-    ///\n-    /// This function **transfers ownership** of the underlying file descriptor\n-    /// to the caller. Callers are then the unique owners of the file descriptor\n-    /// and must close the descriptor once it's no longer needed.\n-    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-    fn into_raw_fd(self) -> RawFd;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for fs::File {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for fs::File {\n-    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs::File::from_inner(fd))\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for fs::File {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().as_inner().fd().raw()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().as_inner().fd().raw()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd { 0 }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd { 1 }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd { 2 }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { 0 }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { 1 }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { 2 }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let file = sys::fs::File::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(file))\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let file = sys::fs::File::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(file))\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let file = sys::fs::File::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(file))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_inner().into_fd().into_raw()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_inner().into_fd().into_raw()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_inner().into_fd().into_raw()\n-    }\n-}"}, {"sha": "8a2d243c7ff6204d2239b96c6120ea0faee50647", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,45 +0,0 @@\n-//! Experimental extensions to `std` for Unix platforms.\n-//!\n-//! For now, this module is limited to extracting file descriptors,\n-//! but its functionality will grow over time.\n-//!\n-//! # Examples\n-//!\n-//! ```no_run\n-//! use std::fs::File;\n-//! use std::os::unix::prelude::*;\n-//!\n-//! fn main() {\n-//!     let f = File::create(\"foo.txt\").unwrap();\n-//!     let fd = f.as_raw_fd();\n-//!\n-//!     // use fd with native unix bindings\n-//! }\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(cfg(target_os = \"redox\"))]\n-\n-pub mod ffi;\n-pub mod fs;\n-pub mod io;\n-pub mod net;\n-pub mod process;\n-pub mod thread;\n-\n-/// A prelude for conveniently writing platform-specific code.\n-///\n-/// Includes all extension traits, and some important type definitions.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{FileTypeExt, PermissionsExt, OpenOptionsExt, MetadataExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::thread::JoinHandleExt;\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::process::{CommandExt, ExitStatusExt};\n-}"}, {"sha": "1f5c785f419075b56ff415827f3778b358d5eac0", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "removed", "additions": 0, "deletions": 759, "changes": 759, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,759 +0,0 @@\n-#![stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-\n-//! Unix-specific networking functionality\n-\n-use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, Initializer};\n-use crate::net::Shutdown;\n-use crate::os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use crate::path::Path;\n-use crate::time::Duration;\n-use crate::sys::{cvt, fd::FileDesc, syscall};\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-pub struct SocketAddr(());\n-\n-impl SocketAddr {\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        None\n-    }\n-\n-    /// Returns `true` if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), false);\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), true);\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        false\n-    }\n-}\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"SocketAddr\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-pub struct UnixStream(FileDesc);\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        if let Some(s) = path.as_ref().to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixStream)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixStream::connect: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n-            .map(FileDesc::new)?;\n-        let client = server.duplicate_path(b\"connect\")?;\n-        let stream = server.duplicate_path(b\"listen\")?;\n-        Ok((UnixStream(client), UnixStream(stream)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(FileDesc::new(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-pub struct UnixListener(FileDesc);\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        if let Some(s) = path.as_ref().to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixListener)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixListener::bind: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-    pub fn incoming(&self) -> Incoming<'_> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(FileDesc::new(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}"}, {"sha": "e981cb93d441fd987c09adbbcd838ecb75b2af52", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,197 +0,0 @@\n-//! Redox-specific extensions to primitives in the `std::process` module.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::io;\n-use crate::os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n-use crate::process;\n-use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n-\n-/// Redox-specific extensions to the [`process::Command`] builder,\n-///\n-/// [`process::Command`]: ../../../../std/process/struct.Command.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait CommandExt {\n-    /// Sets the child process's user ID. This translates to a\n-    /// `setuid` call in the child process. Failure in the `setuid`\n-    /// call will cause the spawn to fail.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u32) -> &mut process::Command;\n-\n-    /// Similar to `uid`, but sets the group ID of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u32) -> &mut process::Command;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// The closure is allowed to return an I/O error whose OS error code will\n-    /// be communicated back to the parent and returned as an error from when\n-    /// the spawn was requested.\n-    ///\n-    /// Multiple closures can be registered and they will be called in order of\n-    /// their registration. If a closure returns `Err` then no further closures\n-    /// will be called and the spawn operation will immediately return with a\n-    /// failure.\n-    ///\n-    /// # Notes and Safety\n-    ///\n-    /// This closure will be run in the context of the child process after a\n-    /// `fork`. This primarily means that any modifications made to memory on\n-    /// behalf of this closure will **not** be visible to the parent process.\n-    /// This is often a very constrained environment where normal operations\n-    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n-    /// other threads perhaps still running when the `fork` was run).\n-    ///\n-    /// This also means that all resources such as file descriptors and\n-    /// memory-mapped regions got duplicated. It is your responsibility to make\n-    /// sure that the closure does not violate library invariants by making\n-    /// invalid use of these duplicates.\n-    ///\n-    /// When this closure is run, aspects such as the stdio file descriptors and\n-    /// working directory have successfully been changed, so output to these\n-    /// locations may not appear where intended.\n-    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// This method is stable and usable, but it should be unsafe. To fix\n-    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n-    ///\n-    /// [`pre_exec`]: #tymethod.pre_exec\n-    #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n-    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n-    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n-    {\n-        unsafe { self.pre_exec(f) }\n-    }\n-\n-    /// Performs all the required setup by this `Command`, followed by calling\n-    /// the `execvp` syscall.\n-    ///\n-    /// On success this function will not return, and otherwise it will return\n-    /// an error indicating why the exec (or another part of the setup of the\n-    /// `Command`) failed.\n-    ///\n-    /// This function, unlike `spawn`, will **not** `fork` the process to create\n-    /// a new child. Like spawn, however, the default behavior for the stdio\n-    /// descriptors will be to inherited from the current process.\n-    ///\n-    /// # Notes\n-    ///\n-    /// The process may be in a \"broken state\" if this function returns in\n-    /// error. For example the working directory, environment variables, signal\n-    /// handling settings, various user/group information, or aspects of stdio\n-    /// file descriptors may have changed. If a \"transactional spawn\" is\n-    /// required to gracefully handle errors it is recommended to use the\n-    /// cross-platform `spawn` instead.\n-    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n-    fn exec(&mut self) -> io::Error;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u32) -> &mut process::Command {\n-        self.as_inner_mut().uid(id);\n-        self\n-    }\n-\n-    fn gid(&mut self, id: u32) -> &mut process::Command {\n-        self.as_inner_mut().gid(id);\n-        self\n-    }\n-\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n-    {\n-        self.as_inner_mut().pre_exec(Box::new(f));\n-        self\n-    }\n-\n-    fn exec(&mut self) -> io::Error {\n-        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n-    }\n-}\n-\n-/// Redox-specific extensions to [`process::ExitStatus`].\n-///\n-/// [`process::ExitStatus`]: ../../../../std/process/struct.ExitStatus.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ExitStatusExt {\n-    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n-    /// a process.\n-    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n-    fn from_raw(raw: i32) -> Self;\n-\n-    /// If the process was terminated by a signal, returns that signal.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signal(&self) -> Option<i32>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExitStatusExt for process::ExitStatus {\n-    fn from_raw(raw: i32) -> Self {\n-        process::ExitStatus::from_inner(From::from(raw))\n-    }\n-\n-    fn signal(&self) -> Option<i32> {\n-        self.as_inner().signal()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl FromRawFd for process::Stdio {\n-    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        let fd = sys::fd::FileDesc::new(fd);\n-        let io = sys::process::Stdio::Fd(fd);\n-        process::Stdio::from_inner(io)\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdin {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdout {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStderr {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdin {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdout {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStderr {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}"}, {"sha": "629eaef04ce36fcf0636e533358cc7c6f3319408", "filename": "src/libstd/sys/redox/ext/thread.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,39 +0,0 @@\n-//! Redox-specific extensions to primitives in the `std::thread` module.\n-\n-#![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-\n-use crate::sys_common::{AsInner, IntoInner};\n-use crate::thread::JoinHandle;\n-\n-#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-#[allow(deprecated)]\n-pub type RawPthread = usize;\n-\n-/// Redox-specific extensions to [`thread::JoinHandle`].\n-///\n-/// [`thread::JoinHandle`]: ../../../../std/thread/struct.JoinHandle.html\n-#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-pub trait JoinHandleExt {\n-    /// Extracts the raw pthread_t without taking ownership\n-    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-    fn as_pthread_t(&self) -> RawPthread;\n-\n-    /// Consumes the thread, returning the raw pthread_t\n-    ///\n-    /// This function **transfers ownership** of the underlying pthread_t to\n-    /// the caller. Callers are then the unique owners of the pthread_t and\n-    /// must either detach or join the pthread_t once it's no longer needed.\n-    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-    fn into_pthread_t(self) -> RawPthread;\n-}\n-\n-#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-impl<T> JoinHandleExt for JoinHandle<T> {\n-    fn as_pthread_t(&self) -> RawPthread {\n-        self.as_inner().id() as RawPthread\n-    }\n-\n-    fn into_pthread_t(self) -> RawPthread {\n-        self.into_inner().into_id() as RawPthread\n-    }\n-}"}, {"sha": "05464787a05d3c594f5bdd203715bff88b460d47", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,4 +0,0 @@\n-#![cfg(target_thread_local)]\n-#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n-\n-pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;"}, {"sha": "a42e486db2239b54a39052881e9a7e274af11e91", "filename": "src/libstd/sys/redox/fd.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,88 +0,0 @@\n-#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n-\n-use crate::io::{self, Read};\n-use crate::mem;\n-use crate::sys::{cvt, syscall};\n-use crate::sys_common::AsInner;\n-\n-pub struct FileDesc {\n-    fd: usize,\n-}\n-\n-impl FileDesc {\n-    pub fn new(fd: usize) -> FileDesc {\n-        FileDesc { fd }\n-    }\n-\n-    pub fn raw(&self) -> usize { self.fd }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> usize {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        cvt(syscall::read(self.fd, buf))\n-    }\n-\n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        cvt(syscall::write(self.fd, buf))\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        self.duplicate_path(&[])\n-    }\n-    pub fn duplicate_path(&self, path: &[u8]) -> io::Result<FileDesc> {\n-        let new_fd = cvt(syscall::dup(self.fd, path))?;\n-        Ok(FileDesc::new(new_fd))\n-    }\n-\n-    pub fn nonblocking(&self) -> io::Result<bool> {\n-        let flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n-        Ok(flags & syscall::O_NONBLOCK == syscall::O_NONBLOCK)\n-    }\n-\n-    pub fn set_cloexec(&self) -> io::Result<()> {\n-        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFD, 0))?;\n-        flags |= syscall::O_CLOEXEC;\n-        cvt(syscall::fcntl(self.fd, syscall::F_SETFD, flags)).and(Ok(()))\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n-        if nonblocking {\n-            flags |= syscall::O_NONBLOCK;\n-        } else {\n-            flags &= !syscall::O_NONBLOCK;\n-        }\n-        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n-    }\n-}\n-\n-impl<'a> Read for &'a FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        (**self).read(buf)\n-    }\n-}\n-\n-impl AsInner<usize> for FileDesc {\n-    fn as_inner(&self) -> &usize { &self.fd }\n-}\n-\n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // (opened after we closed ours.\n-        let _ = syscall::close(self.fd);\n-    }\n-}"}, {"sha": "b80a1a349e3386835908176ae9e6ff1756befa6d", "filename": "src/libstd/sys/redox/fs.rs", "status": "removed", "additions": 0, "deletions": 447, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,447 +0,0 @@\n-use crate::os::unix::prelude::*;\n-\n-use crate::ffi::{OsString, OsStr};\n-use crate::fmt;\n-use crate::io::{self, Error, SeekFrom, IoSlice, IoSliceMut};\n-use crate::path::{Path, PathBuf};\n-use crate::sync::Arc;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::time::SystemTime;\n-use crate::sys::{cvt, syscall};\n-use crate::sys_common::{AsInner, FromInner};\n-\n-pub use crate::sys_common::fs::copy;\n-pub use crate::sys_common::fs::remove_dir_all;\n-\n-pub struct File(FileDesc);\n-\n-#[derive(Clone)]\n-pub struct FileAttr {\n-    stat: syscall::Stat,\n-}\n-\n-pub struct ReadDir {\n-    data: Vec<u8>,\n-    i: usize,\n-    root: Arc<PathBuf>,\n-}\n-\n-struct Dir(FileDesc);\n-\n-unsafe impl Send for Dir {}\n-unsafe impl Sync for Dir {}\n-\n-pub struct DirEntry {\n-    root: Arc<PathBuf>,\n-    name: Box<[u8]>\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct OpenOptions {\n-    // generic\n-    read: bool,\n-    write: bool,\n-    append: bool,\n-    truncate: bool,\n-    create: bool,\n-    create_new: bool,\n-    // system-specific\n-    custom_flags: i32,\n-    mode: u16,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { mode: u16 }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType { mode: u16 }\n-\n-#[derive(Debug)]\n-pub struct DirBuilder { mode: u16 }\n-\n-impl FileAttr {\n-    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n-    pub fn perm(&self) -> FilePermissions {\n-        FilePermissions { mode: (self.stat.st_mode as u16) & 0o777 }\n-    }\n-\n-    pub fn file_type(&self) -> FileType {\n-        FileType { mode: self.stat.st_mode as u16 }\n-    }\n-}\n-\n-impl FileAttr {\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(syscall::TimeSpec {\n-            tv_sec: self.stat.st_mtime as i64,\n-            tv_nsec: self.stat.st_mtime_nsec as i32,\n-        }))\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(syscall::TimeSpec {\n-            tv_sec: self.stat.st_atime as i64,\n-            tv_nsec: self.stat.st_atime_nsec as i32,\n-        }))\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(syscall::TimeSpec {\n-            tv_sec: self.stat.st_ctime as i64,\n-            tv_nsec: self.stat.st_ctime_nsec as i32,\n-        }))\n-    }\n-}\n-\n-impl AsInner<syscall::Stat> for FileAttr {\n-    fn as_inner(&self) -> &syscall::Stat { &self.stat }\n-}\n-\n-impl FilePermissions {\n-    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n-    pub fn set_readonly(&mut self, readonly: bool) {\n-        if readonly {\n-            self.mode &= !0o222;\n-        } else {\n-            self.mode |= 0o222;\n-        }\n-    }\n-    pub fn mode(&self) -> u32 { self.mode as u32 }\n-}\n-\n-impl FileType {\n-    pub fn is_dir(&self) -> bool { self.is(syscall::MODE_DIR) }\n-    pub fn is_file(&self) -> bool { self.is(syscall::MODE_FILE) }\n-    pub fn is_symlink(&self) -> bool { self.is(syscall::MODE_SYMLINK) }\n-\n-    pub fn is(&self, mode: u16) -> bool {\n-        self.mode & syscall::MODE_TYPE == mode\n-    }\n-}\n-\n-impl FromInner<u32> for FilePermissions {\n-    fn from_inner(mode: u32) -> FilePermissions {\n-        FilePermissions { mode: mode as u16 }\n-    }\n-}\n-\n-impl fmt::Debug for ReadDir {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n-        // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.root, f)\n-    }\n-}\n-\n-impl Iterator for ReadDir {\n-    type Item = io::Result<DirEntry>;\n-\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        loop {\n-            let start = self.i;\n-            let mut i = self.i;\n-            while i < self.data.len() {\n-                self.i += 1;\n-                if self.data[i] == b'\\n' {\n-                    break;\n-                }\n-                i += 1;\n-            }\n-            if start < self.i {\n-                let ret = DirEntry {\n-                    name: self.data[start .. i].to_owned().into_boxed_slice(),\n-                    root: self.root.clone()\n-                };\n-                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret))\n-                }\n-            } else {\n-                return None;\n-            }\n-        }\n-    }\n-}\n-\n-impl DirEntry {\n-    pub fn path(&self) -> PathBuf {\n-        self.root.join(OsStr::from_bytes(self.name_bytes()))\n-    }\n-\n-    pub fn file_name(&self) -> OsString {\n-        OsStr::from_bytes(self.name_bytes()).to_os_string()\n-    }\n-\n-    pub fn metadata(&self) -> io::Result<FileAttr> {\n-        lstat(&self.path())\n-    }\n-\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        lstat(&self.path()).map(|m| m.file_type())\n-    }\n-\n-    fn name_bytes(&self) -> &[u8] {\n-        &*self.name\n-    }\n-}\n-\n-impl OpenOptions {\n-    pub fn new() -> OpenOptions {\n-        OpenOptions {\n-            // generic\n-            read: false,\n-            write: false,\n-            append: false,\n-            truncate: false,\n-            create: false,\n-            create_new: false,\n-            // system-specific\n-            custom_flags: 0,\n-            mode: 0o666,\n-        }\n-    }\n-\n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n-\n-    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }\n-    pub fn mode(&mut self, mode: u32) { self.mode = mode as u16; }\n-\n-    fn get_access_mode(&self) -> io::Result<usize> {\n-        match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(syscall::O_RDONLY),\n-            (false, true,  false) => Ok(syscall::O_WRONLY),\n-            (true,  true,  false) => Ok(syscall::O_RDWR),\n-            (false, _,     true)  => Ok(syscall::O_WRONLY | syscall::O_APPEND),\n-            (true,  _,     true)  => Ok(syscall::O_RDWR | syscall::O_APPEND),\n-            (false, false, false) => Err(Error::from_raw_os_error(syscall::EINVAL)),\n-        }\n-    }\n-\n-    fn get_creation_mode(&self) -> io::Result<usize> {\n-        match (self.write, self.append) {\n-            (true, false) => {}\n-            (false, false) =>\n-                if self.truncate || self.create || self.create_new {\n-                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n-                },\n-            (_, true) =>\n-                if self.truncate && !self.create_new {\n-                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n-                },\n-        }\n-\n-        Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => 0,\n-                (true,  false, false) => syscall::O_CREAT,\n-                (false, true,  false) => syscall::O_TRUNC,\n-                (true,  true,  false) => syscall::O_CREAT | syscall::O_TRUNC,\n-                (_,      _,    true)  => syscall::O_CREAT | syscall::O_EXCL,\n-           })\n-    }\n-}\n-\n-impl File {\n-    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = syscall::O_CLOEXEC |\n-                    opts.get_access_mode()? as usize |\n-                    opts.get_creation_mode()? as usize |\n-                    (opts.custom_flags as usize & !syscall::O_ACCMODE);\n-        let fd = cvt(syscall::open(path.to_str().unwrap(), flags | opts.mode as usize))?;\n-        Ok(File(FileDesc::new(fd)))\n-    }\n-\n-    pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat = syscall::Stat::default();\n-        cvt(syscall::fstat(self.0.raw(), &mut stat))?;\n-        Ok(FileAttr { stat })\n-    }\n-\n-    pub fn fsync(&self) -> io::Result<()> {\n-        cvt(syscall::fsync(self.0.raw()))?;\n-        Ok(())\n-    }\n-\n-    pub fn datasync(&self) -> io::Result<()> {\n-        self.fsync()\n-    }\n-\n-    pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        cvt(syscall::ftruncate(self.0.raw(), size as usize))?;\n-        Ok(())\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n-\n-    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n-        let (whence, pos) = match pos {\n-            // Casting to `i64` is fine, too large values will end up as\n-            // negative which will cause an error in `lseek64`.\n-            SeekFrom::Start(off) => (syscall::SEEK_SET, off as i64),\n-            SeekFrom::End(off) => (syscall::SEEK_END, off),\n-            SeekFrom::Current(off) => (syscall::SEEK_CUR, off),\n-        };\n-        let n = cvt(syscall::lseek(self.0.raw(), pos as isize, whence))?;\n-        Ok(n as u64)\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<File> {\n-        self.0.duplicate().map(File)\n-    }\n-\n-    pub fn dup(&self, buf: &[u8]) -> io::Result<File> {\n-        let fd = cvt(syscall::dup(*self.fd().as_inner() as usize, buf))?;\n-        Ok(File(FileDesc::new(fd)))\n-    }\n-\n-    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n-        set_perm(&self.path()?, perm)\n-    }\n-\n-    pub fn path(&self) -> io::Result<PathBuf> {\n-        let mut buf: [u8; 4096] = [0; 4096];\n-        let count = cvt(syscall::fpath(*self.fd().as_inner() as usize, &mut buf))?;\n-        Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[..count])) }))\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n-}\n-\n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder { mode: 0o777 }\n-    }\n-\n-    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let flags = syscall::O_CREAT | syscall::O_CLOEXEC | syscall::O_DIRECTORY | syscall::O_EXCL;\n-        let fd = cvt(syscall::open(p.to_str().unwrap(), flags | (self.mode as usize & 0o777)))?;\n-        let _ = syscall::close(fd);\n-        Ok(())\n-    }\n-\n-    pub fn set_mode(&mut self, mode: u32) {\n-        self.mode = mode as u16;\n-    }\n-}\n-\n-impl FromInner<usize> for File {\n-    fn from_inner(fd: usize) -> File {\n-        File(FileDesc::new(fd))\n-    }\n-}\n-\n-impl fmt::Debug for File {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut b = f.debug_struct(\"File\");\n-        b.field(\"fd\", &self.0.raw());\n-        if let Ok(path) = self.path() {\n-            b.field(\"path\", &path);\n-        }\n-        /*\n-        if let Some((read, write)) = get_mode(fd) {\n-            b.field(\"read\", &read).field(\"write\", &write);\n-        }\n-        */\n-        b.finish()\n-    }\n-}\n-\n-pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = Arc::new(p.to_path_buf());\n-\n-    let flags = syscall::O_CLOEXEC | syscall::O_RDONLY | syscall::O_DIRECTORY;\n-    let fd = cvt(syscall::open(p.to_str().unwrap(), flags))?;\n-    let file = FileDesc::new(fd);\n-    let mut data = Vec::new();\n-    file.read_to_end(&mut data)?;\n-\n-    Ok(ReadDir { data: data, i: 0, root: root })\n-}\n-\n-pub fn unlink(p: &Path) -> io::Result<()> {\n-    cvt(syscall::unlink(p.to_str().unwrap()))?;\n-    Ok(())\n-}\n-\n-pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let fd = cvt(syscall::open(old.to_str().unwrap(),\n-                               syscall::O_CLOEXEC | syscall::O_STAT | syscall::O_NOFOLLOW))?;\n-    let res = cvt(syscall::frename(fd, new.to_str().unwrap()));\n-    cvt(syscall::close(fd))?;\n-    res?;\n-    Ok(())\n-}\n-\n-pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    cvt(syscall::chmod(p.to_str().unwrap(), perm.mode as usize))?;\n-    Ok(())\n-}\n-\n-pub fn rmdir(p: &Path) -> io::Result<()> {\n-    cvt(syscall::rmdir(p.to_str().unwrap()))?;\n-    Ok(())\n-}\n-\n-pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let fd = cvt(syscall::open(p.to_str().unwrap(),\n-                               syscall::O_CLOEXEC | syscall::O_SYMLINK | syscall::O_RDONLY))?;\n-    let mut buf: [u8; 4096] = [0; 4096];\n-    let res = cvt(syscall::read(fd, &mut buf));\n-    cvt(syscall::close(fd))?;\n-    let count = res?;\n-    Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[..count])) }))\n-}\n-\n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let fd = cvt(syscall::open(dst.to_str().unwrap(),\n-                               syscall::O_CLOEXEC | syscall::O_SYMLINK |\n-                               syscall::O_CREAT | syscall::O_WRONLY | 0o777))?;\n-    let res = cvt(syscall::write(fd, src.to_str().unwrap().as_bytes()));\n-    cvt(syscall::close(fd))?;\n-    res?;\n-    Ok(())\n-}\n-\n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    Err(Error::from_raw_os_error(syscall::ENOSYS))\n-}\n-\n-pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n-    let file = File(FileDesc::new(fd));\n-    file.file_attr()\n-}\n-\n-pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let fd = cvt(syscall::open(p.to_str().unwrap(),\n-                               syscall::O_CLOEXEC | syscall::O_STAT | syscall::O_NOFOLLOW))?;\n-    let file = File(FileDesc::new(fd));\n-    file.file_attr()\n-}\n-\n-pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n-    let file = File(FileDesc::new(fd));\n-    file.path()\n-}"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/redox/io.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fio.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,46 +0,0 @@\n-use crate::mem;\n-\n-pub struct IoSlice<'a>(&'a [u8]);\n-\n-impl<'a> IoSlice<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        IoSlice(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        self.0 = &self.0[n..]\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-}\n-\n-pub struct IoSliceMut<'a>(&'a mut [u8]);\n-\n-impl<'a> IoSliceMut<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        IoSliceMut(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        let slice = mem::replace(&mut self.0, &mut []);\n-        let (_, remaining) = slice.split_at_mut(n);\n-        self.0 = remaining;\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-\n-    #[inline]\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        self.0\n-    }\n-}"}, {"sha": "d2bfcce86f414bca0c93bad4a80f22bcaf354ca9", "filename": "src/libstd/sys/redox/memchr.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,4 +0,0 @@\n-// Original implementation taken from rust-memchr.\n-// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n-\n-pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "354184f8af6e71dda54c0b3e9e6a19425ccc89c0", "filename": "src/libstd/sys/redox/mod.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,96 +0,0 @@\n-#![allow(dead_code, missing_docs, nonstandard_style)]\n-\n-use crate::io::ErrorKind;\n-\n-pub use libc::strlen;\n-pub use self::rand::hashmap_random_keys;\n-\n-#[path = \"../unix/alloc.rs\"]\n-pub mod alloc;\n-pub mod args;\n-pub mod cmath;\n-pub mod condvar;\n-pub mod env;\n-pub mod ext;\n-pub mod fast_thread_local;\n-pub mod fd;\n-pub mod fs;\n-pub mod io;\n-pub mod memchr;\n-pub mod mutex;\n-pub mod net;\n-pub mod os;\n-pub mod path;\n-pub mod pipe;\n-pub mod process;\n-pub mod rand;\n-pub mod rwlock;\n-pub mod stack_overflow;\n-pub mod stdio;\n-pub mod syscall;\n-pub mod thread;\n-pub mod thread_local;\n-pub mod time;\n-\n-pub use crate::sys_common::os_str_bytes as os_str;\n-\n-#[cfg(not(test))]\n-pub fn init() {}\n-\n-pub fn decode_error_kind(errno: i32) -> ErrorKind {\n-    match errno {\n-        syscall::ECONNREFUSED => ErrorKind::ConnectionRefused,\n-        syscall::ECONNRESET => ErrorKind::ConnectionReset,\n-        syscall::EPERM | syscall::EACCES => ErrorKind::PermissionDenied,\n-        syscall::EPIPE => ErrorKind::BrokenPipe,\n-        syscall::ENOTCONN => ErrorKind::NotConnected,\n-        syscall::ECONNABORTED => ErrorKind::ConnectionAborted,\n-        syscall::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n-        syscall::EADDRINUSE => ErrorKind::AddrInUse,\n-        syscall::ENOENT => ErrorKind::NotFound,\n-        syscall::EINTR => ErrorKind::Interrupted,\n-        syscall::EINVAL => ErrorKind::InvalidInput,\n-        syscall::ETIMEDOUT => ErrorKind::TimedOut,\n-        syscall::EEXIST => ErrorKind::AlreadyExists,\n-\n-        // These two constants can have the same value on some systems,\n-        // but different values on others, so we can't use a match\n-        // clause\n-        x if x == syscall::EAGAIN || x == syscall::EWOULDBLOCK =>\n-            ErrorKind::WouldBlock,\n-\n-        _ => ErrorKind::Other,\n-    }\n-}\n-\n-pub fn cvt(result: Result<usize, syscall::Error>) -> crate::io::Result<usize> {\n-    result.map_err(|err| crate::io::Error::from_raw_os_error(err.errno))\n-}\n-\n-#[doc(hidden)]\n-pub trait IsMinusOne {\n-    fn is_minus_one(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_minus_one {\n-    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n-        fn is_minus_one(&self) -> bool {\n-            *self == -1\n-        }\n-    })*)\n-}\n-\n-impl_is_minus_one! { i8 i16 i32 i64 isize }\n-\n-pub fn cvt_libc<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(crate::io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n-}\n-\n-/// On Redox, use an illegal instruction to abort\n-pub unsafe fn abort_internal() -> ! {\n-    core::intrinsics::abort();\n-}"}, {"sha": "59399df0294c8b0e3b5036bc497d276ed81577ae", "filename": "src/libstd/sys/redox/mutex.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,169 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::intrinsics::{atomic_cxchg, atomic_xchg};\n-use crate::ptr;\n-\n-use crate::sys::syscall::{futex, getpid, FUTEX_WAIT, FUTEX_WAKE};\n-\n-pub unsafe fn mutex_try_lock(m: *mut i32) -> bool {\n-    atomic_cxchg(m, 0, 1).0 == 0\n-}\n-\n-pub unsafe fn mutex_lock(m: *mut i32) {\n-    let mut c = 0;\n-    //Set to larger value for longer spin test\n-    for _i in 0..100 {\n-        c = atomic_cxchg(m, 0, 1).0;\n-        if c == 0 {\n-            break;\n-        }\n-        //cpu_relax()\n-    }\n-    if c == 1 {\n-        c = atomic_xchg(m, 2);\n-    }\n-    while c != 0 {\n-        let _ = futex(m, FUTEX_WAIT, 2, 0, ptr::null_mut());\n-        c = atomic_xchg(m, 2);\n-    }\n-}\n-\n-pub unsafe fn mutex_unlock(m: *mut i32) {\n-    if *m == 2 {\n-        *m = 0;\n-    } else if atomic_xchg(m, 0) == 1 {\n-        return;\n-    }\n-    //Set to larger value for longer spin test\n-    for _i in 0..100 {\n-        if *m != 0 {\n-            if atomic_cxchg(m, 1, 2).0 != 0 {\n-                return;\n-            }\n-        }\n-        //cpu_relax()\n-    }\n-    let _ = futex(m, FUTEX_WAKE, 1, 0, ptr::null_mut());\n-}\n-\n-pub struct Mutex {\n-    pub lock: UnsafeCell<i32>,\n-}\n-\n-impl Mutex {\n-    /// Creates a new mutex.\n-    pub const fn new() -> Self {\n-        Mutex {\n-            lock: UnsafeCell::new(0),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&self) {\n-        *self.lock.get() = 0;\n-    }\n-\n-    /// Try to lock the mutex\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        mutex_try_lock(self.lock.get())\n-    }\n-\n-    /// Lock the mutex\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        mutex_lock(self.lock.get());\n-    }\n-\n-    /// Unlock the mutex\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        mutex_unlock(self.lock.get());\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        *self.lock.get() = 0;\n-    }\n-}\n-\n-unsafe impl Send for Mutex {}\n-\n-unsafe impl Sync for Mutex {}\n-\n-pub struct ReentrantMutex {\n-    pub lock: UnsafeCell<i32>,\n-    pub owner: UnsafeCell<usize>,\n-    pub own_count: UnsafeCell<usize>,\n-}\n-\n-impl ReentrantMutex {\n-    pub const fn uninitialized() -> Self {\n-        ReentrantMutex {\n-            lock: UnsafeCell::new(0),\n-            owner: UnsafeCell::new(0),\n-            own_count: UnsafeCell::new(0),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        *self.lock.get() = 0;\n-        *self.owner.get() = 0;\n-        *self.own_count.get() = 0;\n-    }\n-\n-    /// Try to lock the mutex\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let pid = getpid().unwrap();\n-        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n-            *self.own_count.get() += 1;\n-            true\n-        } else {\n-            if mutex_try_lock(self.lock.get()) {\n-                *self.owner.get() = pid;\n-                *self.own_count.get() = 1;\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Lock the mutex\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let pid = getpid().unwrap();\n-        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n-            *self.own_count.get() += 1;\n-        } else {\n-            mutex_lock(self.lock.get());\n-            *self.owner.get() = pid;\n-            *self.own_count.get() = 1;\n-        }\n-    }\n-\n-    /// Unlock the mutex\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let pid = getpid().unwrap();\n-        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n-            *self.own_count.get() -= 1;\n-            if *self.own_count.get() == 0 {\n-                *self.owner.get() = 0;\n-                mutex_unlock(self.lock.get());\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        *self.lock.get() = 0;\n-        *self.owner.get() = 0;\n-        *self.own_count.get() = 0;\n-    }\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-\n-unsafe impl Sync for ReentrantMutex {}"}, {"sha": "e9b406bc685a1c01f7df1d846f9e37f17984ae39", "filename": "src/libstd/sys/redox/net/dns/answer.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,12 +0,0 @@\n-use crate::string::String;\n-use crate::vec::Vec;\n-\n-#[derive(Clone, Debug)]\n-pub struct DnsAnswer {\n-    pub name: String,\n-    pub a_type: u16,\n-    pub a_class: u16,\n-    pub ttl_a: u16,\n-    pub ttl_b: u16,\n-    pub data: Vec<u8>\n-}"}, {"sha": "6533e0d5efb77b90b932b5fe631c70a34e3dfc42", "filename": "src/libstd/sys/redox/net/dns/mod.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,205 +0,0 @@\n-pub use self::answer::DnsAnswer;\n-pub use self::query::DnsQuery;\n-\n-use crate::slice;\n-use crate::u16;\n-use crate::string::String;\n-use crate::vec::Vec;\n-\n-mod answer;\n-mod query;\n-\n-#[unstable(feature = \"n16\", issue=\"0\")]\n-#[allow(non_camel_case_types)]\n-#[derive(Copy, Clone, Debug, Default)]\n-#[repr(packed)]\n-pub struct n16 {\n-    inner: u16\n-}\n-\n-impl n16 {\n-    #[unstable(feature = \"n16\", issue=\"0\")]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts((&self.inner as *const u16) as *const u8, 2) }\n-    }\n-\n-    #[unstable(feature = \"n16\", issue=\"0\")]\n-    pub fn from_bytes(bytes: &[u8]) -> Self {\n-        n16 {\n-            inner: unsafe { slice::from_raw_parts(bytes.as_ptr() as *const u16, bytes.len()/2)[0] }\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"n16\", issue=\"0\")]\n-impl From<u16> for n16 {\n-    fn from(value: u16) -> Self {\n-        n16 {\n-            inner: value.to_be()\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"n16\", issue=\"0\")]\n-impl From<n16> for u16 {\n-    fn from(value: n16) -> Self {\n-        u16::from_be(value.inner)\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Dns {\n-    pub transaction_id: u16,\n-    pub flags: u16,\n-    pub queries: Vec<DnsQuery>,\n-    pub answers: Vec<DnsAnswer>\n-}\n-\n-impl Dns {\n-    pub fn compile(&self) -> Vec<u8> {\n-        let mut data = Vec::new();\n-\n-        macro_rules! push_u8 {\n-            ($value:expr) => {\n-                data.push($value);\n-            };\n-        };\n-\n-        macro_rules! push_n16 {\n-            ($value:expr) => {\n-                data.extend_from_slice(n16::from($value).as_bytes());\n-            };\n-        };\n-\n-        push_n16!(self.transaction_id);\n-        push_n16!(self.flags);\n-        push_n16!(self.queries.len() as u16);\n-        push_n16!(self.answers.len() as u16);\n-        push_n16!(0);\n-        push_n16!(0);\n-\n-        for query in self.queries.iter() {\n-            for part in query.name.split('.') {\n-                push_u8!(part.len() as u8);\n-                data.extend_from_slice(part.as_bytes());\n-            }\n-            push_u8!(0);\n-            push_n16!(query.q_type);\n-            push_n16!(query.q_class);\n-        }\n-\n-        data\n-    }\n-\n-    pub fn parse(data: &[u8]) -> Result<Self, String> {\n-        let name_ind = 0b11000000;\n-        let mut i = 0;\n-\n-        macro_rules! pop_u8 {\n-            () => {\n-                {\n-                    i += 1;\n-                    if i > data.len() {\n-                        return Err(format!(\"{}: {}: pop_u8\", file!(), line!()));\n-                    }\n-                    data[i - 1]\n-                }\n-            };\n-        };\n-\n-        macro_rules! pop_n16 {\n-            () => {\n-                {\n-                    i += 2;\n-                    if i > data.len() {\n-                        return Err(format!(\"{}: {}: pop_n16\", file!(), line!()));\n-                    }\n-                    u16::from(n16::from_bytes(&data[i - 2 .. i]))\n-                }\n-            };\n-        };\n-\n-        macro_rules! pop_data {\n-            () => {\n-                {\n-                    let mut data = Vec::new();\n-\n-                    let data_len = pop_n16!();\n-                    for _data_i in 0..data_len {\n-                        data.push(pop_u8!());\n-                    }\n-\n-                    data\n-                }\n-            };\n-        };\n-\n-        macro_rules! pop_name {\n-            () => {\n-                {\n-                    let mut name = String::new();\n-                    let old_i = i;\n-\n-                    loop {\n-                        let name_len = pop_u8!();\n-                        if name_len & name_ind == name_ind {\n-                            i -= 1;\n-                            i = (pop_n16!() - ((name_ind as u16) << 8)) as usize;\n-                            continue;\n-                        }\n-                        if name_len == 0 {\n-                            break;\n-                        }\n-                        if ! name.is_empty() {\n-                            name.push('.');\n-                        }\n-                        for _name_i in 0..name_len {\n-                            name.push(pop_u8!() as char);\n-                        }\n-                    }\n-\n-                    if i <= old_i {\n-                        i = old_i + 2;\n-                    }\n-\n-                    name\n-                }\n-            };\n-        };\n-\n-        let transaction_id = pop_n16!();\n-        let flags = pop_n16!();\n-        let queries_len = pop_n16!();\n-        let answers_len = pop_n16!();\n-        pop_n16!();\n-        pop_n16!();\n-\n-        let mut queries = Vec::new();\n-        for _query_i in 0..queries_len {\n-            queries.push(DnsQuery {\n-                name: pop_name!(),\n-                q_type: pop_n16!(),\n-                q_class: pop_n16!()\n-            });\n-        }\n-\n-        let mut answers = Vec::new();\n-        for _answer_i in 0..answers_len {\n-            answers.push(DnsAnswer {\n-                name: pop_name!(),\n-                a_type: pop_n16!(),\n-                a_class: pop_n16!(),\n-                ttl_a: pop_n16!(),\n-                ttl_b: pop_n16!(),\n-                data: pop_data!()\n-            });\n-        }\n-\n-        Ok(Dns {\n-            transaction_id,\n-            flags,\n-            queries,\n-            answers,\n-        })\n-    }\n-}"}, {"sha": "65fb241b03737d3f62c2424ffd7c001e844b5fd8", "filename": "src/libstd/sys/redox/net/dns/query.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,8 +0,0 @@\n-use crate::string::String;\n-\n-#[derive(Clone, Debug)]\n-pub struct DnsQuery {\n-    pub name: String,\n-    pub q_type: u16,\n-    pub q_class: u16\n-}"}, {"sha": "dbaa140ed8a0f9c39a1aa940b6cb0c5367999ced", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,140 +0,0 @@\n-use crate::fs::File;\n-use crate::io::{Error, Read, self};\n-use crate::iter::Iterator;\n-use crate::net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n-use crate::str::FromStr;\n-use crate::string::{String, ToString};\n-use crate::sys::syscall::EINVAL;\n-use crate::time::{self, Duration};\n-use crate::vec::{IntoIter, Vec};\n-use crate::convert::{TryFrom, TryInto};\n-\n-use self::dns::{Dns, DnsQuery};\n-\n-pub use self::tcp::{TcpStream, TcpListener};\n-pub use self::udp::UdpSocket;\n-\n-pub mod netc;\n-\n-mod dns;\n-mod tcp;\n-mod udp;\n-\n-pub struct LookupHost(IntoIter<SocketAddr>, u16);\n-\n-impl LookupHost {\n-    pub fn port(&self) -> u16 {\n-        self.1\n-    }\n-}\n-\n-impl Iterator for LookupHost {\n-    type Item = SocketAddr;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.0.next()\n-    }\n-}\n-\n-impl TryFrom<&str> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from(s: &str) -> io::Result<LookupHost> {\n-        macro_rules! try_opt {\n-            ($e:expr, $msg:expr) => (\n-                match $e {\n-                    Some(r) => r,\n-                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                                      $msg)),\n-                }\n-            )\n-        }\n-\n-        // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = s.rsplitn(2, ':');\n-        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-\n-        (host, port).try_into()\n-    }\n-}\n-\n-impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n-        let mut ip_string = String::new();\n-        File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n-        let ip: Vec<u8> = ip_string.trim().split('.').map(|part| part.parse::<u8>()\n-                                   .unwrap_or(0)).collect();\n-\n-        let mut dns_string = String::new();\n-        File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n-        let dns: Vec<u8> = dns_string.trim().split('.').map(|part| part.parse::<u8>()\n-                                     .unwrap_or(0)).collect();\n-\n-        if ip.len() == 4 && dns.len() == 4 {\n-            let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n-            let tid = (time.subsec_nanos() >> 16) as u16;\n-\n-            let packet = Dns {\n-                transaction_id: tid,\n-                flags: 0x0100,\n-                queries: vec![DnsQuery {\n-                    name: host.to_string(),\n-                    q_type: 0x0001,\n-                    q_class: 0x0001,\n-                }],\n-                answers: vec![]\n-            };\n-\n-            let packet_data = packet.compile();\n-\n-            let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n-            let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n-            let socket = UdpSocket::bind(Ok(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0))))?;\n-            socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n-            socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n-            socket.connect(Ok(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53))))?;\n-            socket.send(&packet_data)?;\n-\n-            let mut buf = [0; 65536];\n-            let count = socket.recv(&mut buf)?;\n-\n-            match Dns::parse(&buf[.. count]) {\n-                Ok(response) => {\n-                    let mut addrs = vec![];\n-                    for answer in response.answers.iter() {\n-                        if answer.a_type == 0x0001 && answer.a_class == 0x0001\n-                           && answer.data.len() == 4\n-                        {\n-                            let answer_ip = Ipv4Addr::new(answer.data[0],\n-                                                          answer.data[1],\n-                                                          answer.data[2],\n-                                                          answer.data[3]);\n-                            addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n-                        }\n-                    }\n-                    Ok(LookupHost(addrs.into_iter(), port))\n-                },\n-                Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n-            }\n-        } else {\n-            Err(Error::from_raw_os_error(EINVAL))\n-        }\n-    }\n-}\n-\n-fn path_to_peer_addr(path_str: &str) -> SocketAddr {\n-    let mut parts = path_str.split('/').next().unwrap_or(\"\").split(':').skip(1);\n-    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n-    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n-    SocketAddr::V4(SocketAddrV4::new(host, port))\n-}\n-\n-fn path_to_local_addr(path_str: &str) -> SocketAddr {\n-    let mut parts = path_str.split('/').nth(1).unwrap_or(\"\").split(':');\n-    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n-    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n-    SocketAddr::V4(SocketAddrV4::new(host, port))\n-}"}, {"sha": "420a15a4063f388ea4cd0dd3465aa5e1f01e4b8c", "filename": "src/libstd/sys/redox/net/netc.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,47 +0,0 @@\n-pub type in_addr_t = u32;\n-pub type in_port_t = u16;\n-\n-pub type socklen_t = u32;\n-pub type sa_family_t = u16;\n-\n-pub const AF_INET: sa_family_t = 2;\n-pub const AF_INET6: sa_family_t = 23;\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub struct in_addr {\n-    pub s_addr: in_addr_t,\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(align(4))]\n-#[repr(C)]\n-pub struct in6_addr {\n-    pub s6_addr: [u8; 16],\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub struct sockaddr {\n-    pub sa_family: sa_family_t,\n-    pub sa_data: [u8; 14],\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub struct sockaddr_in {\n-    pub sin_family: sa_family_t,\n-    pub sin_port: in_port_t,\n-    pub sin_addr: in_addr,\n-    pub sin_zero: [u8; 8],\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub struct sockaddr_in6 {\n-    pub sin6_family: sa_family_t,\n-    pub sin6_port: in_port_t,\n-    pub sin6_flowinfo: u32,\n-    pub sin6_addr: in6_addr,\n-    pub sin6_scope_id: u32,\n-}"}, {"sha": "494f943c96b53f92ec30c484d9009148a34e0ffb", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,251 +0,0 @@\n-use crate::cmp;\n-use crate::io::{self, Error, ErrorKind, Result, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{SocketAddr, Shutdown};\n-use crate::path::Path;\n-use crate::sys::fs::{File, OpenOptions};\n-use crate::sys::syscall::TimeSpec;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-use crate::time::Duration;\n-\n-use super::{path_to_peer_addr, path_to_local_addr};\n-\n-#[derive(Debug)]\n-pub struct TcpStream(File);\n-\n-impl TcpStream {\n-    pub fn connect(addr: Result<&SocketAddr>) -> Result<TcpStream> {\n-        let path = format!(\"tcp:{}\", addr?);\n-        let mut options = OpenOptions::new();\n-        options.read(true);\n-        options.write(true);\n-        Ok(TcpStream(File::open(Path::new(path.as_str()), &options)?))\n-    }\n-\n-    pub fn connect_timeout(_addr: &SocketAddr, _timeout: Duration) -> Result<TcpStream> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::connect_timeout not implemented\"))\n-    }\n-\n-    pub fn duplicate(&self) -> Result<TcpStream> {\n-        Ok(TcpStream(self.0.dup(&[])?))\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::default_read_vectored(|b| self.read(b), bufs)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::default_write_vectored(|b| self.write(b), bufs)\n-    }\n-\n-    pub fn take_error(&self) -> Result<Option<Error>> {\n-        Ok(None)\n-    }\n-\n-    pub fn peer_addr(&self) -> Result<SocketAddr> {\n-        let path = self.0.path()?;\n-        Ok(path_to_peer_addr(path.to_str().unwrap_or(\"\")))\n-    }\n-\n-    pub fn socket_addr(&self) -> Result<SocketAddr> {\n-        let path = self.0.path()?;\n-        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n-    }\n-\n-    pub fn peek(&self, _buf: &mut [u8]) -> Result<usize> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::peek not implemented\"))\n-    }\n-\n-    pub fn shutdown(&self, _how: Shutdown) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::shutdown not implemented\"))\n-    }\n-\n-    pub fn nodelay(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::nodelay not implemented\"))\n-    }\n-\n-    pub fn nonblocking(&self) -> Result<bool> {\n-        self.0.fd().nonblocking()\n-    }\n-\n-    pub fn only_v6(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::only_v6 not implemented\"))\n-    }\n-\n-    pub fn ttl(&self) -> Result<u32> {\n-        let mut ttl = [0];\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.read(&mut ttl)?;\n-        Ok(ttl[0] as u32)\n-    }\n-\n-    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        let mut time = TimeSpec::default();\n-        let file = self.0.dup(b\"read_timeout\")?;\n-        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n-            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        let mut time = TimeSpec::default();\n-        let file = self.0.dup(b\"write_timeout\")?;\n-        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n-            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_nodelay not implemented\"))\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> {\n-        self.0.fd().set_nonblocking(nonblocking)\n-    }\n-\n-    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_only_v6 not implemented\"))\n-    }\n-\n-    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.write(&[cmp::min(ttl, 255) as u8])?;\n-        Ok(())\n-    }\n-\n-    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n-        let file = self.0.dup(b\"read_timeout\")?;\n-        if let Some(duration) = duration_option {\n-            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n-            }\n-            file.write(&TimeSpec {\n-                tv_sec: duration.as_secs() as i64,\n-                tv_nsec: duration.subsec_nanos() as i32\n-            })?;\n-        } else {\n-            file.write(&[])?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n-        let file = self.0.dup(b\"write_timeout\")?;\n-        if let Some(duration) = duration_option {\n-            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n-            }\n-            file.write(&TimeSpec {\n-                tv_sec: duration.as_secs() as i64,\n-                tv_nsec: duration.subsec_nanos() as i32\n-            })?;\n-        } else {\n-            file.write(&[])?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl AsInner<File> for TcpStream {\n-    fn as_inner(&self) -> &File { &self.0 }\n-}\n-\n-impl FromInner<File> for TcpStream {\n-    fn from_inner(file: File) -> TcpStream {\n-        TcpStream(file)\n-    }\n-}\n-\n-impl IntoInner<File> for TcpStream {\n-    fn into_inner(self) -> File { self.0 }\n-}\n-\n-#[derive(Debug)]\n-pub struct TcpListener(File);\n-\n-impl TcpListener {\n-    pub fn bind(addr: Result<&SocketAddr>) -> Result<TcpListener> {\n-        let path = format!(\"tcp:/{}\", addr?);\n-        let mut options = OpenOptions::new();\n-        options.read(true);\n-        options.write(true);\n-        Ok(TcpListener(File::open(Path::new(path.as_str()), &options)?))\n-    }\n-\n-    pub fn accept(&self) -> Result<(TcpStream, SocketAddr)> {\n-        let file = self.0.dup(b\"listen\")?;\n-        let path = file.path()?;\n-        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n-        Ok((TcpStream(file), peer_addr))\n-    }\n-\n-    pub fn duplicate(&self) -> Result<TcpListener> {\n-        Ok(TcpListener(self.0.dup(&[])?))\n-    }\n-\n-    pub fn take_error(&self) -> Result<Option<Error>> {\n-        Ok(None)\n-    }\n-\n-    pub fn socket_addr(&self) -> Result<SocketAddr> {\n-        let path = self.0.path()?;\n-        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n-    }\n-\n-    pub fn nonblocking(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::nonblocking not implemented\"))\n-    }\n-\n-    pub fn only_v6(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::only_v6 not implemented\"))\n-    }\n-\n-    pub fn ttl(&self) -> Result<u32> {\n-        let mut ttl = [0];\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.read(&mut ttl)?;\n-        Ok(ttl[0] as u32)\n-    }\n-\n-    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::set_nonblocking not implemented\"))\n-    }\n-\n-    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::set_only_v6 not implemented\"))\n-    }\n-\n-    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.write(&[cmp::min(ttl, 255) as u8])?;\n-        Ok(())\n-    }\n-}\n-\n-impl AsInner<File> for TcpListener {\n-    fn as_inner(&self) -> &File { &self.0 }\n-}\n-\n-impl FromInner<File> for TcpListener {\n-    fn from_inner(file: File) -> TcpListener {\n-        TcpListener(file)\n-    }\n-}\n-\n-impl IntoInner<File> for TcpListener {\n-    fn into_inner(self) -> File { self.0 }\n-}"}, {"sha": "274123dce4b5846110be17196db5433ebebd726d", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,237 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::cmp;\n-use crate::io::{self, Error, ErrorKind, Result};\n-use crate::mem;\n-use crate::net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-use crate::path::Path;\n-use crate::sys::fs::{File, OpenOptions};\n-use crate::sys::syscall::TimeSpec;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-use crate::time::Duration;\n-\n-use super::{path_to_peer_addr, path_to_local_addr};\n-\n-#[derive(Debug)]\n-pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);\n-\n-impl UdpSocket {\n-    pub fn bind(addr: Result<&SocketAddr>) -> Result<UdpSocket> {\n-        let path = format!(\"udp:/{}\", addr?);\n-        let mut options = OpenOptions::new();\n-        options.read(true);\n-        options.write(true);\n-        Ok(UdpSocket(File::open(Path::new(path.as_str()), &options)?, UnsafeCell::new(None)))\n-    }\n-\n-    fn get_conn(&self) -> &mut Option<SocketAddr> {\n-        unsafe { &mut *(self.1.get()) }\n-    }\n-\n-    pub fn connect(&self, addr: Result<&SocketAddr>) -> Result<()> {\n-        unsafe { *self.1.get() = Some(*addr?) };\n-        Ok(())\n-    }\n-\n-    pub fn duplicate(&self) -> Result<UdpSocket> {\n-        let new_bind = self.0.dup(&[])?;\n-        let new_conn = *self.get_conn();\n-        Ok(UdpSocket(new_bind, UnsafeCell::new(new_conn)))\n-    }\n-\n-    pub fn recv_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)> {\n-        let from = self.0.dup(b\"listen\")?;\n-        let path = from.path()?;\n-        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n-        let count = from.read(buf)?;\n-        Ok((count, peer_addr))\n-    }\n-\n-    pub fn recv(&self, buf: &mut [u8]) -> Result<usize> {\n-        if let Some(addr) = *self.get_conn() {\n-            let from = self.0.dup(addr.to_string().as_bytes())?;\n-            from.read(buf)\n-        } else {\n-            Err(Error::new(ErrorKind::Other, \"UdpSocket::recv not connected\"))\n-        }\n-    }\n-\n-    pub fn send_to(&self, buf: &[u8], addr: &SocketAddr) -> Result<usize> {\n-        let to = self.0.dup(format!(\"{}\", addr).as_bytes())?;\n-        to.write(buf)\n-    }\n-\n-    pub fn send(&self, buf: &[u8]) -> Result<usize> {\n-        if let Some(addr) = *self.get_conn() {\n-            self.send_to(buf, &addr)\n-        } else {\n-            Err(Error::new(ErrorKind::Other, \"UdpSocket::send not connected\"))\n-        }\n-    }\n-\n-    pub fn take_error(&self) -> Result<Option<Error>> {\n-        Ok(None)\n-    }\n-\n-    pub fn peer_addr(&self) -> Result<SocketAddr> {\n-        let path = self.0.path()?;\n-        Ok(path_to_peer_addr(path.to_str().unwrap_or(\"\")))\n-    }\n-\n-    pub fn socket_addr(&self) -> Result<SocketAddr> {\n-        let path = self.0.path()?;\n-        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n-    }\n-\n-    pub fn peek(&self, _buf: &mut [u8]) -> Result<usize> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::peek not implemented\"))\n-    }\n-\n-    pub fn peek_from(&self, _buf: &mut [u8]) -> Result<(usize, SocketAddr)> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::peek_from not implemented\"))\n-    }\n-\n-    pub fn broadcast(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::broadcast not implemented\"))\n-    }\n-\n-    pub fn multicast_loop_v4(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v4 not implemented\"))\n-    }\n-\n-    pub fn multicast_loop_v6(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v6 not implemented\"))\n-    }\n-\n-    pub fn multicast_ttl_v4(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_ttl_v4 not implemented\"))\n-    }\n-\n-    pub fn nonblocking(&self) -> Result<bool> {\n-        self.0.fd().nonblocking()\n-    }\n-\n-    pub fn only_v6(&self) -> Result<bool> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::only_v6 not implemented\"))\n-    }\n-\n-    pub fn ttl(&self) -> Result<u32> {\n-        let mut ttl = [0];\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.read(&mut ttl)?;\n-        Ok(ttl[0] as u32)\n-    }\n-\n-    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        let mut time = TimeSpec::default();\n-        let file = self.0.dup(b\"read_timeout\")?;\n-        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n-            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        let mut time = TimeSpec::default();\n-        let file = self.0.dup(b\"write_timeout\")?;\n-        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n-            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_broadcast not implemented\"))\n-    }\n-\n-    pub fn set_multicast_loop_v4(&self, _multicast_loop_v4: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v4 not implemented\"))\n-    }\n-\n-    pub fn set_multicast_loop_v6(&self, _multicast_loop_v6: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v6 not implemented\"))\n-    }\n-\n-    pub fn set_multicast_ttl_v4(&self, _multicast_ttl_v4: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_ttl_v4 not implemented\"))\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> {\n-        self.0.fd().set_nonblocking(nonblocking)\n-    }\n-\n-    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_only_v6 not implemented\"))\n-    }\n-\n-    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n-        let file = self.0.dup(b\"ttl\")?;\n-        file.write(&[cmp::min(ttl, 255) as u8])?;\n-        Ok(())\n-    }\n-\n-    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n-        let file = self.0.dup(b\"read_timeout\")?;\n-        if let Some(duration) = duration_option {\n-            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n-            }\n-            file.write(&TimeSpec {\n-                tv_sec: duration.as_secs() as i64,\n-                tv_nsec: duration.subsec_nanos() as i32\n-            })?;\n-        } else {\n-            file.write(&[])?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n-        let file = self.0.dup(b\"write_timeout\")?;\n-        if let Some(duration) = duration_option {\n-            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n-            }\n-            file.write(&TimeSpec {\n-                tv_sec: duration.as_secs() as i64,\n-                tv_nsec: duration.subsec_nanos() as i32\n-            })?;\n-        } else {\n-            file.write(&[])?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v4 not implemented\"))\n-    }\n-\n-    pub fn join_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v6 not implemented\"))\n-    }\n-\n-    pub fn leave_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v4 not implemented\"))\n-    }\n-\n-    pub fn leave_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v6 not implemented\"))\n-    }\n-}\n-\n-impl AsInner<File> for UdpSocket {\n-    fn as_inner(&self) -> &File { &self.0 }\n-}\n-\n-impl FromInner<File> for UdpSocket {\n-    fn from_inner(file: File) -> UdpSocket {\n-        UdpSocket(file, UnsafeCell::new(None))\n-    }\n-}\n-\n-impl IntoInner<File> for UdpSocket {\n-    fn into_inner(self) -> File { self.0 }\n-}"}, {"sha": "3ae201f698c2b0cb38f112cfdba33fcb37a98fdb", "filename": "src/libstd/sys/redox/os.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,241 +0,0 @@\n-//! Implementation of `std::os` functionality for unix systems\n-\n-#![allow(unused_imports)] // lots of cfg code here\n-\n-use libc::c_char;\n-\n-use crate::os::unix::prelude::*;\n-\n-use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io::{self, Read, Write};\n-use crate::iter;\n-use crate::marker::PhantomData;\n-use crate::mem;\n-use crate::memchr;\n-use crate::path::{self, PathBuf};\n-use crate::ptr;\n-use crate::slice;\n-use crate::str;\n-use crate::sys_common::mutex::Mutex;\n-use crate::sys::{cvt, cvt_libc, fd, syscall};\n-use crate::vec;\n-\n-extern {\n-    #[link_name = \"__errno_location\"]\n-    fn errno_location() -> *mut i32;\n-}\n-\n-/// Returns the platform-specific value of errno\n-pub fn errno() -> i32 {\n-    unsafe {\n-        (*errno_location())\n-    }\n-}\n-\n-/// Gets a detailed string description for the given error number.\n-pub fn error_string(errno: i32) -> String {\n-    if let Some(string) = syscall::STR_ERROR.get(errno as usize) {\n-        string.to_string()\n-    } else {\n-        \"unknown error\".to_string()\n-    }\n-}\n-\n-pub fn getcwd() -> io::Result<PathBuf> {\n-    let mut buf = [0; 4096];\n-    let count = cvt(syscall::getcwd(&mut buf))?;\n-    Ok(PathBuf::from(OsString::from_vec(buf[.. count].to_vec())))\n-}\n-\n-pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    cvt(syscall::chdir(p.to_str().unwrap())).and(Ok(()))\n-}\n-\n-pub struct SplitPaths<'a> {\n-    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n-                    fn(&'a [u8]) -> PathBuf>,\n-}\n-\n-pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n-    fn bytes_to_path(b: &[u8]) -> PathBuf {\n-        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n-    }\n-    fn is_semicolon(b: &u8) -> bool { *b == b';' }\n-    let unparsed = unparsed.as_bytes();\n-    SplitPaths {\n-        iter: unparsed.split(is_semicolon as fn(&u8) -> bool)\n-                      .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n-    }\n-}\n-\n-impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = PathBuf;\n-    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[derive(Debug)]\n-pub struct JoinPathsError;\n-\n-pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n-{\n-    let mut joined = Vec::new();\n-    let sep = b';';\n-\n-    for (i, path) in paths.enumerate() {\n-        let path = path.as_ref().as_bytes();\n-        if i > 0 { joined.push(sep) }\n-        if path.contains(&sep) {\n-            return Err(JoinPathsError)\n-        }\n-        joined.extend_from_slice(path);\n-    }\n-    Ok(OsStringExt::from_vec(joined))\n-}\n-\n-impl fmt::Display for JoinPathsError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"path segment contains separator `:`\".fmt(f)\n-    }\n-}\n-\n-impl StdError for JoinPathsError {\n-    fn description(&self) -> &str { \"failed to join paths\" }\n-}\n-\n-pub fn current_exe() -> io::Result<PathBuf> {\n-    use crate::fs::File;\n-\n-    let mut file = File::open(\"sys:exe\")?;\n-\n-    let mut path = String::new();\n-    file.read_to_string(&mut path)?;\n-\n-    if path.ends_with('\\n') {\n-        path.pop();\n-    }\n-\n-    Ok(PathBuf::from(path))\n-}\n-\n-pub static ENV_LOCK: Mutex = Mutex::new();\n-\n-pub struct Env {\n-    iter: vec::IntoIter<(OsString, OsString)>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Iterator for Env {\n-    type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-pub unsafe fn environ() -> *mut *const *const c_char {\n-    extern { static mut environ: *const *const c_char; }\n-    &mut environ\n-}\n-\n-/// Returns a vector of (variable, value) byte-vector pairs for all the\n-/// environment variables of the current process.\n-pub fn env() -> Env {\n-    unsafe {\n-        let _guard = ENV_LOCK.lock();\n-        let mut environ = *environ();\n-        if environ == ptr::null() {\n-            panic!(\"os::env() failure getting env string from OS: {}\",\n-                   io::Error::last_os_error());\n-        }\n-        let mut result = Vec::new();\n-        while *environ != ptr::null() {\n-            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n-                result.push(key_value);\n-            }\n-            environ = environ.offset(1);\n-        }\n-        return Env {\n-            iter: result.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n-    }\n-\n-    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n-        // Strategy (copied from glibc): Variable name and value are separated\n-        // by an ASCII equals sign '='. Since a variable name must not be\n-        // empty, allow variable names starting with an equals sign. Skip all\n-        // malformed lines.\n-        if input.is_empty() {\n-            return None;\n-        }\n-        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| (\n-            OsStringExt::from_vec(input[..p].to_vec()),\n-            OsStringExt::from_vec(input[p+1..].to_vec()),\n-        ))\n-    }\n-}\n-\n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    // environment variables with a nul byte can't be set, so their value is\n-    // always None as well\n-    let k = CString::new(k.as_bytes())?;\n-    unsafe {\n-        let _guard = ENV_LOCK.lock();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        let ret = if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        };\n-        Ok(ret)\n-    }\n-}\n-\n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = ENV_LOCK.lock();\n-        cvt_libc(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n-    }\n-}\n-\n-pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = ENV_LOCK.lock();\n-        cvt_libc(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n-    }\n-}\n-\n-pub fn page_size() -> usize {\n-    4096\n-}\n-\n-pub fn temp_dir() -> PathBuf {\n-    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n-        PathBuf::from(\"/tmp\")\n-    })\n-}\n-\n-pub fn home_dir() -> Option<PathBuf> {\n-    return crate::env::var_os(\"HOME\").map(PathBuf::from);\n-}\n-\n-pub fn exit(code: i32) -> ! {\n-    let _ = syscall::exit(code as usize);\n-    unreachable!();\n-}\n-\n-pub fn getpid() -> u32 {\n-    syscall::getpid().unwrap() as u32\n-}\n-\n-pub fn getppid() -> u32 {\n-    syscall::getppid().unwrap() as u32\n-}"}, {"sha": "b62d6c9878211ae95b7dee1a2a9b705bfa0beb3d", "filename": "src/libstd/sys/redox/path.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,29 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n-    if let Some(path_str) = path.to_str() {\n-        if let Some(_i) = path_str.find(':') {\n-            // FIXME: Redox specific prefix\n-            // Some(Prefix::Verbatim(OsStr::new(&path_str[..i])))\n-            None\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "29cacb6d562f285e29f16aa61ac0209dd09f9c39", "filename": "src/libstd/sys/redox/pipe.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,101 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::{cvt, syscall};\n-use crate::sys::fd::FileDesc;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Anonymous pipes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct AnonPipe(FileDesc);\n-\n-pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    let mut fds = [0; 2];\n-    cvt(syscall::pipe2(&mut fds, syscall::O_CLOEXEC))?;\n-    Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n-}\n-\n-impl AnonPipe {\n-    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> {\n-        fd.set_cloexec()?;\n-        Ok(AnonPipe(fd))\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n-}\n-\n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n-    //FIXME: Use event based I/O multiplexing\n-    //unimplemented!()\n-\n-    p1.0.read_to_end(v1)?;\n-    p2.0.read_to_end(v2)?;\n-\n-    Ok(())\n-\n-    /*\n-    // Set both pipes into nonblocking mode as we're gonna be reading from both\n-    // in the `select` loop below, and we wouldn't want one to block the other!\n-    let p1 = p1.into_fd();\n-    let p2 = p2.into_fd();\n-    p1.set_nonblocking(true)?;\n-    p2.set_nonblocking(true)?;\n-\n-    loop {\n-        // wait for either pipe to become readable using `select`\n-        cvt_r(|| unsafe {\n-            let mut read: libc::fd_set = mem::zeroed();\n-            libc::FD_SET(p1.raw(), &mut read);\n-            libc::FD_SET(p2.raw(), &mut read);\n-            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n-                         ptr::null_mut())\n-        })?;\n-\n-        // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n-        // EAGAIN. If we hit EOF, then this will happen because the underlying\n-        // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n-        // this case we flip the other fd back into blocking mode and read\n-        // whatever's leftover on that file descriptor.\n-        let read = |fd: &FileDesc, dst: &mut Vec<u8>| {\n-            match fd.read_to_end(dst) {\n-                Ok(_) => Ok(true),\n-                Err(e) => {\n-                    if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n-                       e.raw_os_error() == Some(libc::EAGAIN) {\n-                        Ok(false)\n-                    } else {\n-                        Err(e)\n-                    }\n-                }\n-            }\n-        };\n-        if read(&p1, v1)? {\n-            p2.set_nonblocking(false)?;\n-            return p2.read_to_end(v2).map(|_| ());\n-        }\n-        if read(&p2, v2)? {\n-            p1.set_nonblocking(false)?;\n-            return p1.read_to_end(v1).map(|_| ());\n-        }\n-    }\n-    */\n-}"}, {"sha": "2a553b2c93bd3939b0b270d534a85555de7783a3", "filename": "src/libstd/sys/redox/process.rs", "status": "removed", "additions": 0, "deletions": 609, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,609 +0,0 @@\n-use crate::env::{self, split_paths};\n-use crate::ffi::{CStr, OsStr};\n-use crate::fmt;\n-use crate::fs::File;\n-use crate::io::{self, prelude::*, BufReader, Error, ErrorKind, SeekFrom};\n-use crate::os::unix::ffi::OsStrExt;\n-use crate::path::{Path, PathBuf};\n-use crate::ptr;\n-use crate::sys::ext::fs::MetadataExt;\n-use crate::sys::ext::io::AsRawFd;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::fs::{File as SysFile, OpenOptions};\n-use crate::sys::os::{ENV_LOCK, environ};\n-use crate::sys::pipe::{self, AnonPipe};\n-use crate::sys::{cvt, syscall};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n-\n-use libc::{EXIT_SUCCESS, EXIT_FAILURE};\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    // Currently we try hard to ensure that the call to `.exec()` doesn't\n-    // actually allocate any memory. While many platforms try to ensure that\n-    // memory allocation works after a fork in a multithreaded process, it's\n-    // been observed to be buggy and somewhat unreliable, so we do our best to\n-    // just not do it at all!\n-    //\n-    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n-    // what's gonna get passed to `execvp`. The `argv` array starts with the\n-    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n-    // also null-terminated.\n-    //\n-    // Right now we don't support removing arguments, so there's no much fancy\n-    // support there, but we support adding and removing environment variables,\n-    // so a side table is used to track where in the `envp` array each key is\n-    // located. Whenever we add a key we update it in place if it's already\n-    // present, and whenever we remove a key we update the locations of all\n-    // other keys.\n-    program: String,\n-    args: Vec<String>,\n-    env: CommandEnv<DefaultEnvKey>,\n-\n-    cwd: Option<String>,\n-    uid: Option<u32>,\n-    gid: Option<u32>,\n-    saw_nul: bool,\n-    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-// passed to do_exec() with configuration of what the child stdio should look\n-// like\n-struct ChildPipes {\n-    stdin: ChildStdio,\n-    stdout: ChildStdio,\n-    stderr: ChildStdio,\n-}\n-\n-enum ChildStdio {\n-    Inherit,\n-    Explicit(usize),\n-    Owned(FileDesc),\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-    Fd(FileDesc),\n-}\n-\n-impl Command {\n-    pub fn new(program: &OsStr) -> Command {\n-        Command {\n-            program: program.to_str().unwrap().to_owned(),\n-            args: Vec::new(),\n-            env: Default::default(),\n-            cwd: None,\n-            uid: None,\n-            gid: None,\n-            saw_nul: false,\n-            closures: Vec::new(),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n-    }\n-\n-    pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(arg.to_str().unwrap().to_owned());\n-    }\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(dir.to_str().unwrap().to_owned());\n-    }\n-    pub fn uid(&mut self, id: u32) {\n-        self.uid = Some(id);\n-    }\n-    pub fn gid(&mut self, id: u32) {\n-        self.gid = Some(id);\n-    }\n-\n-    pub unsafe fn pre_exec(\n-        &mut self,\n-        f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n-    ) {\n-        self.closures.push(f);\n-    }\n-\n-    pub fn stdin(&mut self, stdin: Stdio) {\n-        self.stdin = Some(stdin);\n-    }\n-    pub fn stdout(&mut self, stdout: Stdio) {\n-        self.stdout = Some(stdout);\n-    }\n-    pub fn stderr(&mut self, stderr: Stdio) {\n-        self.stderr = Some(stderr);\n-    }\n-\n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n-         const CLOEXEC_MSG_FOOTER: &[u8] = b\"NOEX\";\n-\n-         if self.saw_nul {\n-             return Err(io::Error::new(ErrorKind::InvalidInput,\n-                                       \"nul byte found in provided data\"));\n-         }\n-\n-         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-         let (input, output) = pipe::anon_pipe()?;\n-\n-         let pid = unsafe {\n-             match cvt(syscall::clone(0))? {\n-                 0 => {\n-                     drop(input);\n-                     let Err(err) = self.do_exec(theirs);\n-                     let errno = err.raw_os_error().unwrap_or(syscall::EINVAL) as u32;\n-                     let bytes = [\n-                         (errno >> 24) as u8,\n-                         (errno >> 16) as u8,\n-                         (errno >>  8) as u8,\n-                         (errno >>  0) as u8,\n-                         CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                         CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                     ];\n-                     // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n-                     // we want to be sure we *don't* run at_exit destructors as\n-                     // we're being torn down regardless\n-                     assert!(output.write(&bytes).is_ok());\n-                     let _ = syscall::exit(1);\n-                     panic!(\"failed to exit\");\n-                 }\n-                 n => n,\n-             }\n-         };\n-\n-         let mut p = Process { pid: pid, status: None };\n-         drop(output);\n-         let mut bytes = [0; 8];\n-\n-         // loop to handle EINTR\n-         loop {\n-             match input.read(&mut bytes) {\n-                 Ok(0) => return Ok((p, ours)),\n-                 Ok(8) => {\n-                     assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                             \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                     let errno = combine(&bytes[0.. 4]);\n-                     assert!(p.wait().is_ok(),\n-                             \"wait() should either return Ok or panic\");\n-                     return Err(Error::from_raw_os_error(errno))\n-                 }\n-                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                 Err(e) => {\n-                     assert!(p.wait().is_ok(),\n-                             \"wait() should either return Ok or panic\");\n-                     panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                 },\n-                 Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                     assert!(p.wait().is_ok(),\n-                             \"wait() should either return Ok or panic\");\n-                     panic!(\"short read on the CLOEXEC pipe\")\n-                 }\n-             }\n-         }\n-\n-         fn combine(arr: &[u8]) -> i32 {\n-             let a = arr[0] as u32;\n-             let b = arr[1] as u32;\n-             let c = arr[2] as u32;\n-             let d = arr[3] as u32;\n-\n-             ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-         }\n-    }\n-\n-    pub fn exec(&mut self, default: Stdio) -> io::Error {\n-        if self.saw_nul {\n-            return io::Error::new(ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n-        }\n-\n-        match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe {\n-                let Err(e) = self.do_exec(theirs);\n-                e\n-            },\n-            Err(e) => e,\n-        }\n-    }\n-\n-    // And at this point we've reached a special time in the life of the\n-    // child. The child must now be considered hamstrung and unable to\n-    // do anything other than syscalls really. Consider the following\n-    // scenario:\n-    //\n-    //      1. Thread A of process 1 grabs the malloc() mutex\n-    //      2. Thread B of process 1 forks(), creating thread C\n-    //      3. Thread C of process 2 then attempts to malloc()\n-    //      4. The memory of process 2 is the same as the memory of\n-    //         process 1, so the mutex is locked.\n-    //\n-    // This situation looks a lot like deadlock, right? It turns out\n-    // that this is what pthread_atfork() takes care of, which is\n-    // presumably implemented across platforms. The first thing that\n-    // threads to *before* forking is to do things like grab the malloc\n-    // mutex, and then after the fork they unlock it.\n-    //\n-    // Despite this information, libnative's spawn has been witnessed to\n-    // deadlock on both macOS and FreeBSD. I'm not entirely sure why, but\n-    // all collected backtraces point at malloc/free traffic in the\n-    // child spawned process.\n-    //\n-    // For this reason, the block of code below should contain 0\n-    // invocations of either malloc of free (or their related friends).\n-    //\n-    // As an example of not having malloc/free traffic, we don't close\n-    // this file descriptor by dropping the FileDesc (which contains an\n-    // allocation). Instead we just close it manually. This will never\n-    // have the drop glue anyway because this code never returns (the\n-    // child will either exec() or invoke syscall::exit)\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> Result<!, io::Error> {\n-        if let Some(fd) = stdio.stderr.fd() {\n-            cvt(syscall::dup2(fd, 2, &[]))?;\n-            let mut flags = cvt(syscall::fcntl(2, syscall::F_GETFD, 0))?;\n-            flags &= ! syscall::O_CLOEXEC;\n-            cvt(syscall::fcntl(2, syscall::F_SETFD, flags))?;\n-        }\n-        if let Some(fd) = stdio.stdout.fd() {\n-            cvt(syscall::dup2(fd, 1, &[]))?;\n-            let mut flags = cvt(syscall::fcntl(1, syscall::F_GETFD, 0))?;\n-            flags &= ! syscall::O_CLOEXEC;\n-            cvt(syscall::fcntl(1, syscall::F_SETFD, flags))?;\n-        }\n-        if let Some(fd) = stdio.stdin.fd() {\n-            cvt(syscall::dup2(fd, 0, &[]))?;\n-            let mut flags = cvt(syscall::fcntl(0, syscall::F_GETFD, 0))?;\n-            flags &= ! syscall::O_CLOEXEC;\n-            cvt(syscall::fcntl(0, syscall::F_SETFD, flags))?;\n-        }\n-\n-        if let Some(g) = self.gid {\n-            cvt(syscall::setregid(g as usize, g as usize))?;\n-        }\n-        if let Some(u) = self.uid {\n-            cvt(syscall::setreuid(u as usize, u as usize))?;\n-        }\n-        if let Some(ref cwd) = self.cwd {\n-            cvt(syscall::chdir(cwd))?;\n-        }\n-\n-        for callback in self.closures.iter_mut() {\n-            callback()?;\n-        }\n-\n-        self.env.apply();\n-\n-        let program = if self.program.contains(':') || self.program.contains('/') {\n-            Some(PathBuf::from(&self.program))\n-        } else if let Ok(path_env) = env::var(\"PATH\") {\n-            let mut program = None;\n-            for mut path in split_paths(&path_env) {\n-                path.push(&self.program);\n-                if path.exists() {\n-                    program = Some(path);\n-                    break;\n-                }\n-            }\n-            program\n-        } else {\n-            None\n-        };\n-\n-        let mut file = if let Some(program) = program {\n-            File::open(program.as_os_str())?\n-        } else {\n-            return Err(io::Error::from_raw_os_error(syscall::ENOENT));\n-        };\n-\n-        // Push all the arguments\n-        let mut args: Vec<[usize; 2]> = Vec::with_capacity(1 + self.args.len());\n-\n-        let interpreter = {\n-            let mut reader = BufReader::new(&file);\n-\n-            let mut shebang = [0; 2];\n-            let mut read = 0;\n-            loop {\n-                match reader.read(&mut shebang[read..])? {\n-                    0 => break,\n-                    n => read += n,\n-                }\n-            }\n-\n-            if &shebang == b\"#!\" {\n-                // This is an interpreted script.\n-                // First of all, since we'll be passing another file to\n-                // fexec(), we need to manually check that we have permission\n-                // to execute this file:\n-                let uid = cvt(syscall::getuid())?;\n-                let gid = cvt(syscall::getgid())?;\n-                let meta = file.metadata()?;\n-\n-                let mode = if uid == meta.uid() as usize {\n-                    meta.mode() >> 3*2 & 0o7\n-                } else if gid == meta.gid() as usize {\n-                    meta.mode() >> 3*1 & 0o7\n-                } else {\n-                    meta.mode() & 0o7\n-                };\n-                if mode & 1 == 0 {\n-                    return Err(io::Error::from_raw_os_error(syscall::EPERM));\n-                }\n-\n-                // Second of all, we need to actually read which interpreter it wants\n-                let mut interpreter = Vec::new();\n-                reader.read_until(b'\\n', &mut interpreter)?;\n-                // Pop one trailing newline, if any\n-                if interpreter.ends_with(&[b'\\n']) {\n-                    interpreter.pop().unwrap();\n-                }\n-\n-                // FIXME: Here we could just reassign `file` directly, if it\n-                // wasn't for lexical lifetimes. Remove the whole `let\n-                // interpreter = { ... };` hack once NLL lands.\n-                // NOTE: Although DO REMEMBER to make sure the interpreter path\n-                // still lives long enough to reach fexec.\n-                Some(interpreter)\n-            } else {\n-                None\n-            }\n-        };\n-        if let Some(ref interpreter) = interpreter {\n-            let path: &OsStr = OsStr::from_bytes(&interpreter);\n-            file = File::open(path)?;\n-\n-            args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n-        } else {\n-            file.seek(SeekFrom::Start(0))?;\n-        }\n-\n-        args.push([self.program.as_ptr() as usize, self.program.len()]);\n-        args.extend(self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()]));\n-\n-        // Push all the variables\n-        let mut vars: Vec<[usize; 2]> = Vec::new();\n-        {\n-            let _guard = ENV_LOCK.lock();\n-            let mut environ = *environ();\n-            while *environ != ptr::null() {\n-                let var = CStr::from_ptr(*environ).to_bytes();\n-                vars.push([var.as_ptr() as usize, var.len()]);\n-                environ = environ.offset(1);\n-            }\n-        }\n-\n-        if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n-            Err(io::Error::from_raw_os_error(err.errno as i32))\n-        } else {\n-            panic!(\"return from exec without err\");\n-        }\n-    }\n-\n-    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n-        let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n-        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n-        let stdout = self.stdout.as_ref().unwrap_or(&default);\n-        let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n-        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n-        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n-        Ok((ours, theirs))\n-    }\n-}\n-\n-impl Stdio {\n-    fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n-        match *self {\n-            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n-\n-            // Make sure that the source descriptors are not an stdio\n-            // descriptor, otherwise the order which we set the child's\n-            // descriptors may blow away a descriptor which we are hoping to\n-            // save. For example, suppose we want the child's stderr to be the\n-            // parent's stdout, and the child's stdout to be the parent's\n-            // stderr. No matter which we dup first, the second will get\n-            // overwritten prematurely.\n-            Stdio::Fd(ref fd) => {\n-                if fd.raw() <= 2 {\n-                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n-                } else {\n-                    Ok((ChildStdio::Explicit(fd.raw()), None))\n-                }\n-            }\n-\n-            Stdio::MakePipe => {\n-                let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n-                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n-            }\n-\n-            Stdio::Null => {\n-                let mut opts = OpenOptions::new();\n-                opts.read(readable);\n-                opts.write(!readable);\n-                let fd = SysFile::open(Path::new(\"null:\"), &opts)?;\n-                Ok((ChildStdio::Owned(fd.into_fd()), None))\n-            }\n-        }\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Fd(pipe.into_fd())\n-    }\n-}\n-\n-impl From<SysFile> for Stdio {\n-    fn from(file: SysFile) -> Stdio {\n-        Stdio::Fd(file.into_fd())\n-    }\n-}\n-\n-impl ChildStdio {\n-    fn fd(&self) -> Option<usize> {\n-        match *self {\n-            ChildStdio::Inherit => None,\n-            ChildStdio::Explicit(fd) => Some(fd),\n-            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.program)?;\n-        for arg in &self.args {\n-            write!(f, \" {:?}\", arg)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(i32);\n-\n-impl ExitStatus {\n-    fn exited(&self) -> bool {\n-        self.0 & 0x7F == 0\n-    }\n-\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() {\n-            Some((self.0 >> 8) & 0xFF)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() {\n-            Some(self.0 & 0x7F)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl From<i32> for ExitStatus {\n-    fn from(a: i32) -> ExitStatus {\n-        ExitStatus(a)\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(u8);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n-    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-/// The unique ID of the process (this should never be negative).\n-pub struct Process {\n-    pid: usize,\n-    status: Option<ExitStatus>,\n-}\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        self.pid as u32\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        // If we've already waited on this process then the pid can be recycled\n-        // and used for another process, and we probably shouldn't be killing\n-        // random processes, so just return an error.\n-        if self.status.is_some() {\n-            Err(Error::new(ErrorKind::InvalidInput,\n-                           \"invalid argument: can't kill an exited process\"))\n-        } else {\n-            cvt(syscall::kill(self.pid, syscall::SIGKILL))?;\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        if let Some(status) = self.status {\n-            return Ok(status)\n-        }\n-        let mut status = 0;\n-        cvt(syscall::waitpid(self.pid, &mut status, 0))?;\n-        self.status = Some(ExitStatus(status as i32));\n-        Ok(ExitStatus(status as i32))\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        if let Some(status) = self.status {\n-            return Ok(Some(status))\n-        }\n-        let mut status = 0;\n-        let pid = cvt(syscall::waitpid(self.pid, &mut status, syscall::WNOHANG))?;\n-        if pid == 0 {\n-            Ok(None)\n-        } else {\n-            self.status = Some(ExitStatus(status as i32));\n-            Ok(Some(ExitStatus(status as i32)))\n-        }\n-    }\n-}"}, {"sha": "5b58d1782bf0a88c036f955b4c4b0f8b4c2f219e", "filename": "src/libstd/sys/redox/rand.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,3 +0,0 @@\n-pub fn hashmap_random_keys() -> (u64, u64) {\n-    (0, 0)\n-}"}, {"sha": "990e7551114bbfff2611f89d42063197112ffbf7", "filename": "src/libstd/sys/redox/rwlock.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,51 +0,0 @@\n-use super::mutex::Mutex;\n-\n-pub struct RWLock {\n-    mutex: Mutex\n-}\n-\n-unsafe impl Send for RWLock {}\n-unsafe impl Sync for RWLock {}\n-\n-impl RWLock {\n-    pub const fn new() -> RWLock {\n-        RWLock {\n-            mutex: Mutex::new()\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        self.mutex.lock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        self.mutex.try_lock()\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        self.mutex.lock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        self.mutex.try_lock()\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        self.mutex.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        self.mutex.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.mutex.destroy();\n-    }\n-}"}, {"sha": "cf01d323d45db0a4fc4ddb51e7ecf235ef21fc51", "filename": "src/libstd/sys/redox/stack_overflow.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,17 +0,0 @@\n-#![cfg_attr(test, allow(dead_code))]\n-\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n-pub unsafe fn init() {\n-\n-}\n-\n-pub unsafe fn cleanup() {\n-\n-}"}, {"sha": "33f5bdbb5d358e908d8a01b689d0bb933648850b", "filename": "src/libstd/sys/redox/stdio.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,64 +0,0 @@\n-use crate::io;\n-use crate::sys::{cvt, syscall};\n-use crate::sys::fd::FileDesc;\n-\n-pub struct Stdin(());\n-pub struct Stdout(());\n-pub struct Stderr(());\n-\n-impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n-}\n-\n-impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(0);\n-        let ret = fd.read(buf);\n-        fd.into_raw();\n-        ret\n-    }\n-}\n-\n-impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n-}\n-\n-impl io::Write for Stdout {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(1);\n-        let ret = fd.write(buf);\n-        fd.into_raw();\n-        ret\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        cvt(syscall::fsync(1)).and(Ok(()))\n-    }\n-}\n-\n-impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n-}\n-\n-impl io::Write for Stderr {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(2);\n-        let ret = fd.write(buf);\n-        fd.into_raw();\n-        ret\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        cvt(syscall::fsync(2)).and(Ok(()))\n-    }\n-}\n-\n-pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(crate::sys::syscall::EBADF as i32)\n-}\n-\n-pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n-\n-pub fn panic_output() -> Option<impl io::Write> {\n-    Stderr::new().ok()\n-}"}, {"sha": "e640f7ed376316631b3baed0c583d79e0161b205", "filename": "src/libstd/sys/redox/syscall/arch/arm.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,73 +0,0 @@\n-use super::error::{Error, Result};\n-\n-pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-// Clobbers all registers - special for clone\n-pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b)\n-        : \"memory\", \"r0\", \"r1\", \"r2\", \"r3\", \"r4\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d), \"{r3}\"(e)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n-                       -> Result<usize> {\n-    asm!(\"swi $$0\"\n-        : \"={r0}\"(a)\n-        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d), \"{r3}\"(e), \"{r4}\"(f)\n-        : \"memory\"\n-        : \"volatile\");\n-\n-    Error::demux(a)\n-}"}, {"sha": "0cd6409bb06f85052cf07c163da7031e97ef8999", "filename": "src/libstd/sys/redox/syscall/arch/x86.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,73 +0,0 @@\n-use super::error::{Error, Result};\n-\n-pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-// Clobbers all registers - special for clone\n-pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b)\n-        : \"memory\", \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n-                       -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={eax}\"(a)\n-        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e), \"{edi}\"(f)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}"}, {"sha": "52ad01bd4a8cfd06ae47d81e65a4a7af46e6f60c", "filename": "src/libstd/sys/redox/syscall/arch/x86_64.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,74 +0,0 @@\n-use super::error::{Error, Result};\n-\n-pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-// Clobbers all registers - special for clone\n-pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b)\n-        : \"memory\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\",\n-          \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}\n-\n-pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n-                       -> Result<usize> {\n-    asm!(\"int 0x80\"\n-        : \"={rax}\"(a)\n-        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e), \"{rdi}\"(f)\n-        : \"memory\"\n-        : \"intel\", \"volatile\");\n-\n-    Error::demux(a)\n-}"}, {"sha": "b9abb48a8d3680b5dc6ffde2a4a9c29c3146a3de", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "removed", "additions": 0, "deletions": 348, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,348 +0,0 @@\n-use super::arch::*;\n-use super::data::{SigAction, Stat, StatVfs, TimeSpec};\n-use super::error::Result;\n-use super::number::*;\n-\n-use core::{mem, ptr};\n-\n-// Signal restorer\n-extern \"C\" fn restorer() -> ! {\n-    sigreturn().unwrap();\n-    unreachable!();\n-}\n-\n-/// Set the end of the process's heap\n-///\n-/// When `addr` is `0`, this function will return the current break.\n-///\n-/// When `addr` is nonzero, this function will attempt to set the end of the process's\n-/// heap to `addr` and return the new program break. The new program break should be\n-/// checked by the allocator, it may not be exactly `addr`, as it may be aligned to a page\n-/// boundary.\n-///\n-/// On error, `Err(ENOMEM)` will be returned indicating that no memory is available\n-pub unsafe fn brk(addr: usize) -> Result<usize> {\n-    syscall1(SYS_BRK, addr)\n-}\n-\n-/// Changes the process's working directory.\n-///\n-/// This function will attempt to set the process's working directory to `path`, which can be\n-/// either a relative, scheme relative, or absolute path.\n-///\n-/// On success, `Ok(0)` will be returned. On error, one of the following errors will be returned.\n-///\n-/// # Errors\n-///\n-/// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n-/// * `EFAULT` - `path` does not point to the process's addressable memory\n-/// * `EIO` - an I/O error occurred\n-/// * `ENOENT` - `path` does not exit\n-/// * `ENOTDIR` - `path` is not a directory\n-pub fn chdir<T: AsRef<[u8]>>(path: T) -> Result<usize> {\n-    unsafe { syscall2(SYS_CHDIR, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n-}\n-\n-pub fn chmod<T: AsRef<[u8]>>(path: T, mode: usize) -> Result<usize> {\n-    unsafe { syscall3(SYS_CHMOD, path.as_ref().as_ptr() as usize, path.as_ref().len(), mode) }\n-}\n-\n-/// Produces a fork of the current process, or a new process thread.\n-pub unsafe fn clone(flags: usize) -> Result<usize> {\n-    syscall1_clobber(SYS_CLONE, flags)\n-}\n-\n-/// Closes a file.\n-pub fn close(fd: usize) -> Result<usize> {\n-    unsafe { syscall1(SYS_CLOSE, fd) }\n-}\n-\n-/// Gets the current system time.\n-pub fn clock_gettime(clock: usize, tp: &mut TimeSpec) -> Result<usize> {\n-    unsafe { syscall2(SYS_CLOCK_GETTIME, clock, tp as *mut TimeSpec as usize) }\n-}\n-\n-/// Copies and transforms a file descriptor.\n-pub fn dup(fd: usize, buf: &[u8]) -> Result<usize> {\n-    unsafe { syscall3(SYS_DUP, fd, buf.as_ptr() as usize, buf.len()) }\n-}\n-\n-/// Copies and transforms a file descriptor.\n-pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> Result<usize> {\n-    unsafe { syscall4(SYS_DUP2, fd, newfd, buf.as_ptr() as usize, buf.len()) }\n-}\n-\n-/// Exits the current process.\n-pub fn exit(status: usize) -> Result<usize> {\n-    unsafe { syscall1(SYS_EXIT, status) }\n-}\n-\n-/// Changes file permissions.\n-pub fn fchmod(fd: usize, mode: u16) -> Result<usize> {\n-    unsafe { syscall2(SYS_FCHMOD, fd, mode as usize) }\n-\n-}\n-\n-/// Changes file ownership.\n-pub fn fchown(fd: usize, uid: u32, gid: u32) -> Result<usize> {\n-    unsafe { syscall3(SYS_FCHOWN, fd, uid as usize, gid as usize) }\n-\n-}\n-\n-/// Changes file descriptor flags.\n-pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n-    unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n-}\n-\n-/// Replaces the current process with a new executable.\n-pub fn fexec(fd: usize, args: &[[usize; 2]], vars: &[[usize; 2]]) -> Result<usize> {\n-    unsafe { syscall5(SYS_FEXEC, fd, args.as_ptr() as usize, args.len(),\n-                      vars.as_ptr() as usize, vars.len()) }\n-}\n-\n-/// Maps a file into memory.\n-pub unsafe fn fmap(fd: usize, offset: usize, size: usize) -> Result<usize> {\n-    syscall3(SYS_FMAP, fd, offset, size)\n-}\n-\n-/// Unmaps a memory-mapped file.\n-pub unsafe fn funmap(addr: usize) -> Result<usize> {\n-    syscall1(SYS_FUNMAP, addr)\n-}\n-\n-/// Retrieves the canonical path of a file.\n-pub fn fpath(fd: usize, buf: &mut [u8]) -> Result<usize> {\n-    unsafe { syscall3(SYS_FPATH, fd, buf.as_mut_ptr() as usize, buf.len()) }\n-}\n-\n-/// Renames a file.\n-pub fn frename<T: AsRef<[u8]>>(fd: usize, path: T) -> Result<usize> {\n-    unsafe { syscall3(SYS_FRENAME, fd, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n-}\n-\n-/// Gets metadata about a file.\n-pub fn fstat(fd: usize, stat: &mut Stat) -> Result<usize> {\n-    unsafe { syscall3(SYS_FSTAT, fd, stat as *mut Stat as usize, mem::size_of::<Stat>()) }\n-}\n-\n-/// Gets metadata about a filesystem.\n-pub fn fstatvfs(fd: usize, stat: &mut StatVfs) -> Result<usize> {\n-    unsafe { syscall3(SYS_FSTATVFS, fd, stat as *mut StatVfs as usize, mem::size_of::<StatVfs>()) }\n-}\n-\n-/// Syncs a file descriptor to its underlying medium.\n-pub fn fsync(fd: usize) -> Result<usize> {\n-    unsafe { syscall1(SYS_FSYNC, fd) }\n-}\n-\n-/// Truncate or extend a file to a specified length\n-pub fn ftruncate(fd: usize, len: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_FTRUNCATE, fd, len) }\n-}\n-\n-// Change modify and/or access times\n-pub fn futimens(fd: usize, times: &[TimeSpec]) -> Result<usize> {\n-    unsafe { syscall3(SYS_FUTIMENS, fd, times.as_ptr() as usize,\n-                      times.len() * mem::size_of::<TimeSpec>()) }\n-}\n-\n-/// Fast userspace mutex\n-pub unsafe fn futex(addr: *mut i32, op: usize, val: i32, val2: usize, addr2: *mut i32)\n-                    -> Result<usize> {\n-    syscall5(SYS_FUTEX, addr as usize, op, (val as isize) as usize, val2, addr2 as usize)\n-}\n-\n-/// Gets the current working directory.\n-pub fn getcwd(buf: &mut [u8]) -> Result<usize> {\n-    unsafe { syscall2(SYS_GETCWD, buf.as_mut_ptr() as usize, buf.len()) }\n-}\n-\n-/// Gets the effective group ID.\n-pub fn getegid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETEGID) }\n-}\n-\n-/// Gets the effective namespace.\n-pub fn getens() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETENS) }\n-}\n-\n-/// Gets the effective user ID.\n-pub fn geteuid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETEUID) }\n-}\n-\n-/// Gets the current group ID.\n-pub fn getgid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETGID) }\n-}\n-\n-/// Gets the current namespace.\n-pub fn getns() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETNS) }\n-}\n-\n-/// Gets the current process ID.\n-pub fn getpid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETPID) }\n-}\n-\n-/// Gets the process group ID.\n-pub fn getpgid(pid: usize) -> Result<usize> {\n-    unsafe { syscall1(SYS_GETPGID, pid) }\n-}\n-\n-/// Gets the parent process ID.\n-pub fn getppid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETPPID) }\n-}\n-\n-/// Gets the current user ID.\n-pub fn getuid() -> Result<usize> {\n-    unsafe { syscall0(SYS_GETUID) }\n-}\n-\n-/// Sets the I/O privilege level\n-pub unsafe fn iopl(level: usize) -> Result<usize> {\n-    syscall1(SYS_IOPL, level)\n-}\n-\n-/// Sends a signal `sig` to the process identified by `pid`.\n-pub fn kill(pid: usize, sig: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_KILL, pid, sig) }\n-}\n-\n-/// Creates a link to a file.\n-pub unsafe fn link(old: *const u8, new: *const u8) -> Result<usize> {\n-    syscall2(SYS_LINK, old as usize, new as usize)\n-}\n-\n-/// Seeks to `offset` bytes in a file descriptor.\n-pub fn lseek(fd: usize, offset: isize, whence: usize) -> Result<usize> {\n-    unsafe { syscall3(SYS_LSEEK, fd, offset as usize, whence) }\n-}\n-\n-/// Makes a new scheme namespace.\n-pub fn mkns(schemes: &[[usize; 2]]) -> Result<usize> {\n-    unsafe { syscall2(SYS_MKNS, schemes.as_ptr() as usize, schemes.len()) }\n-}\n-\n-/// Sleeps for the time specified in `req`.\n-pub fn nanosleep(req: &TimeSpec, rem: &mut TimeSpec) -> Result<usize> {\n-    unsafe { syscall2(SYS_NANOSLEEP, req as *const TimeSpec as usize,\n-                                     rem as *mut TimeSpec as usize) }\n-}\n-\n-/// Opens a file.\n-pub fn open<T: AsRef<[u8]>>(path: T, flags: usize) -> Result<usize> {\n-    unsafe { syscall3(SYS_OPEN, path.as_ref().as_ptr() as usize, path.as_ref().len(), flags) }\n-}\n-\n-/// Allocates pages, linearly in physical memory.\n-pub unsafe fn physalloc(size: usize) -> Result<usize> {\n-    syscall1(SYS_PHYSALLOC, size)\n-}\n-\n-/// Frees physically allocated pages.\n-pub unsafe fn physfree(physical_address: usize, size: usize) -> Result<usize> {\n-    syscall2(SYS_PHYSFREE, physical_address, size)\n-}\n-\n-/// Maps physical memory to virtual memory.\n-pub unsafe fn physmap(physical_address: usize, size: usize, flags: usize) -> Result<usize> {\n-    syscall3(SYS_PHYSMAP, physical_address, size, flags)\n-}\n-\n-/// Unmaps previously mapped physical memory.\n-pub unsafe fn physunmap(virtual_address: usize) -> Result<usize> {\n-    syscall1(SYS_PHYSUNMAP, virtual_address)\n-}\n-\n-/// Creates a pair of file descriptors referencing the read and write ends of a pipe.\n-pub fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_PIPE2, fds.as_ptr() as usize, flags) }\n-}\n-\n-/// Read from a file descriptor into a buffer\n-pub fn read(fd: usize, buf: &mut [u8]) -> Result<usize> {\n-    unsafe { syscall3(SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }\n-}\n-\n-/// Removes a directory.\n-pub fn rmdir<T: AsRef<[u8]>>(path: T) -> Result<usize> {\n-    unsafe { syscall2(SYS_RMDIR, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n-}\n-\n-/// Sets the process group ID.\n-pub fn setpgid(pid: usize, pgid: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_SETPGID, pid, pgid) }\n-}\n-\n-/// Sets the current process group IDs.\n-pub fn setregid(rgid: usize, egid: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_SETREGID, rgid, egid) }\n-}\n-\n-/// Makes a new scheme namespace.\n-pub fn setrens(rns: usize, ens: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_SETRENS, rns, ens) }\n-}\n-\n-/// Sets the current process user IDs.\n-pub fn setreuid(ruid: usize, euid: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_SETREUID, ruid, euid) }\n-}\n-\n-/// Sets up a signal handler.\n-pub fn sigaction(sig: usize, act: Option<&SigAction>, oldact: Option<&mut SigAction>)\n--> Result<usize> {\n-    unsafe { syscall4(SYS_SIGACTION, sig,\n-                      act.map(|x| x as *const _).unwrap_or_else(ptr::null) as usize,\n-                      oldact.map(|x| x as *mut _).unwrap_or_else(ptr::null_mut) as usize,\n-                      restorer as usize) }\n-}\n-\n-/// Returns from signal handler.\n-pub fn sigreturn() -> Result<usize> {\n-    unsafe { syscall0(SYS_SIGRETURN) }\n-}\n-\n-/// Removes a file.\n-pub fn unlink<T: AsRef<[u8]>>(path: T) -> Result<usize> {\n-    unsafe { syscall2(SYS_UNLINK, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n-}\n-\n-/// Converts a virtual address to a physical one.\n-pub unsafe fn virttophys(virtual_address: usize) -> Result<usize> {\n-    syscall1(SYS_VIRTTOPHYS, virtual_address)\n-}\n-\n-/// Checks if a child process has exited or received a signal.\n-pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize> {\n-    unsafe { syscall3(SYS_WAITPID, pid, status as *mut usize as usize, options) }\n-}\n-\n-/// Writes a buffer to a file descriptor.\n-///\n-/// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning\n-/// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which\n-/// were written.\n-///\n-/// # Errors\n-///\n-/// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n-/// * `EBADF` - the file descriptor is not valid or is not open for writing\n-/// * `EFAULT` - `buf` does not point to the process's addressable memory\n-/// * `EIO` - an I/O error occurred\n-/// * `ENOSPC` - the device containing the file descriptor has no room for data\n-/// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed\n-pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {\n-    unsafe { syscall3(SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }\n-}\n-\n-/// Yields the process's time slice to the kernel.\n-///\n-/// This function will return Ok(0) on success\n-pub fn sched_yield() -> Result<usize> {\n-    unsafe { syscall0(SYS_YIELD) }\n-}"}, {"sha": "0b458ea89b87f972fa347235a58283d309248bd1", "filename": "src/libstd/sys/redox/syscall/data.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,191 +0,0 @@\n-use core::ops::{Deref, DerefMut};\n-use core::{mem, slice};\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-pub struct Event {\n-    pub id: usize,\n-    pub flags: usize,\n-    pub data: usize\n-}\n-\n-impl Deref for Event {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self as *const Event as *const u8,\n-                mem::size_of::<Event>()\n-            ) as &[u8]\n-        }\n-    }\n-}\n-\n-impl DerefMut for Event {\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                self as *mut Event as *mut u8,\n-                mem::size_of::<Event>()\n-            ) as &mut [u8]\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-#[repr(C)]\n-pub struct Packet {\n-    pub id: u64,\n-    pub pid: usize,\n-    pub uid: u32,\n-    pub gid: u32,\n-    pub a: usize,\n-    pub b: usize,\n-    pub c: usize,\n-    pub d: usize\n-}\n-\n-impl Deref for Packet {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self as *const Packet as *const u8,\n-                mem::size_of::<Packet>()\n-            ) as &[u8]\n-        }\n-    }\n-}\n-\n-impl DerefMut for Packet {\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                self as *mut Packet as *mut u8,\n-                mem::size_of::<Packet>()\n-            ) as &mut [u8]\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct SigAction {\n-    pub sa_handler: extern \"C\" fn(usize),\n-    pub sa_mask: [u64; 2],\n-    pub sa_flags: usize,\n-}\n-\n-impl Default for SigAction {\n-    fn default() -> Self {\n-        Self {\n-            sa_handler: unsafe { mem::transmute(0usize) },\n-            sa_mask: [0; 2],\n-            sa_flags: 0,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-#[repr(C)]\n-pub struct Stat {\n-    pub st_dev: u64,\n-    pub st_ino: u64,\n-    pub st_mode: u16,\n-    pub st_nlink: u32,\n-    pub st_uid: u32,\n-    pub st_gid: u32,\n-    pub st_size: u64,\n-    pub st_blksize: u32,\n-    pub st_blocks: u64,\n-    pub st_mtime: u64,\n-    pub st_mtime_nsec: u32,\n-    pub st_atime: u64,\n-    pub st_atime_nsec: u32,\n-    pub st_ctime: u64,\n-    pub st_ctime_nsec: u32,\n-}\n-\n-impl Deref for Stat {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self as *const Stat as *const u8,\n-                mem::size_of::<Stat>()\n-            ) as &[u8]\n-        }\n-    }\n-}\n-\n-impl DerefMut for Stat {\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                self as *mut Stat as *mut u8,\n-                mem::size_of::<Stat>()\n-            ) as &mut [u8]\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-#[repr(C)]\n-pub struct StatVfs {\n-    pub f_bsize: u32,\n-    pub f_blocks: u64,\n-    pub f_bfree: u64,\n-    pub f_bavail: u64,\n-}\n-\n-impl Deref for StatVfs {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self as *const StatVfs as *const u8,\n-                mem::size_of::<StatVfs>()\n-            ) as &[u8]\n-        }\n-    }\n-}\n-\n-impl DerefMut for StatVfs {\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                self as *mut StatVfs as *mut u8,\n-                mem::size_of::<StatVfs>()\n-            ) as &mut [u8]\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-#[repr(C)]\n-pub struct TimeSpec {\n-    pub tv_sec: i64,\n-    pub tv_nsec: i32,\n-}\n-\n-impl Deref for TimeSpec {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self as *const TimeSpec as *const u8,\n-                mem::size_of::<TimeSpec>()\n-            ) as &[u8]\n-        }\n-    }\n-}\n-\n-impl DerefMut for TimeSpec {\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                self as *mut TimeSpec as *mut u8,\n-                mem::size_of::<TimeSpec>()\n-            ) as &mut [u8]\n-        }\n-    }\n-}"}, {"sha": "da84ffb0423597494d15cf8ad318520c9a59474b", "filename": "src/libstd/sys/redox/syscall/error.rs", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,315 +0,0 @@\n-use core::{fmt, result};\n-\n-#[derive(Eq, PartialEq)]\n-pub struct Error {\n-    pub errno: i32,\n-}\n-\n-pub type Result<T> = result::Result<T, Error>;\n-\n-impl Error {\n-    pub fn new(errno: i32) -> Error {\n-        Error { errno }\n-    }\n-\n-    pub fn mux(result: Result<usize>) -> usize {\n-        match result {\n-            Ok(value) => value,\n-            Err(error) => -error.errno as usize,\n-        }\n-    }\n-\n-    pub fn demux(value: usize) -> Result<usize> {\n-        let errno = -(value as i32);\n-        if errno >= 1 && errno < STR_ERROR.len() as i32 {\n-            Err(Error::new(errno))\n-        } else {\n-            Ok(value)\n-        }\n-    }\n-\n-    pub fn text(&self) -> &str {\n-        if let Some(description) = STR_ERROR.get(self.errno as usize) {\n-            description\n-        } else {\n-            \"Unknown Error\"\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.text())\n-    }\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.text())\n-    }\n-}\n-\n-pub const EPERM: i32 = 1;  /* Operation not permitted */\n-pub const ENOENT: i32 = 2;  /* No such file or directory */\n-pub const ESRCH: i32 = 3;  /* No such process */\n-pub const EINTR: i32 = 4;  /* Interrupted system call */\n-pub const EIO: i32 = 5;  /* I/O error */\n-pub const ENXIO: i32 = 6;  /* No such device or address */\n-pub const E2BIG: i32 = 7;  /* Argument list too long */\n-pub const ENOEXEC: i32 = 8;  /* Exec format error */\n-pub const EBADF: i32 = 9;  /* Bad file number */\n-pub const ECHILD: i32 = 10;  /* No child processes */\n-pub const EAGAIN: i32 = 11;  /* Try again */\n-pub const ENOMEM: i32 = 12;  /* Out of memory */\n-pub const EACCES: i32 = 13;  /* Permission denied */\n-pub const EFAULT: i32 = 14;  /* Bad address */\n-pub const ENOTBLK: i32 = 15;  /* Block device required */\n-pub const EBUSY: i32 = 16;  /* Device or resource busy */\n-pub const EEXIST: i32 = 17;  /* File exists */\n-pub const EXDEV: i32 = 18;  /* Cross-device link */\n-pub const ENODEV: i32 = 19;  /* No such device */\n-pub const ENOTDIR: i32 = 20;  /* Not a directory */\n-pub const EISDIR: i32 = 21;  /* Is a directory */\n-pub const EINVAL: i32 = 22;  /* Invalid argument */\n-pub const ENFILE: i32 = 23;  /* File table overflow */\n-pub const EMFILE: i32 = 24;  /* Too many open files */\n-pub const ENOTTY: i32 = 25;  /* Not a typewriter */\n-pub const ETXTBSY: i32 = 26;  /* Text file busy */\n-pub const EFBIG: i32 = 27;  /* File too large */\n-pub const ENOSPC: i32 = 28;  /* No space left on device */\n-pub const ESPIPE: i32 = 29;  /* Illegal seek */\n-pub const EROFS: i32 = 30;  /* Read-only file system */\n-pub const EMLINK: i32 = 31;  /* Too many links */\n-pub const EPIPE: i32 = 32;  /* Broken pipe */\n-pub const EDOM: i32 = 33;  /* Math argument out of domain of func */\n-pub const ERANGE: i32 = 34;  /* Math result not representable */\n-pub const EDEADLK: i32 = 35;  /* Resource deadlock would occur */\n-pub const ENAMETOOLONG: i32 = 36;  /* File name too long */\n-pub const ENOLCK: i32 = 37;  /* No record locks available */\n-pub const ENOSYS: i32 = 38;  /* Function not implemented */\n-pub const ENOTEMPTY: i32 = 39;  /* Directory not empty */\n-pub const ELOOP: i32 = 40;  /* Too many symbolic links encountered */\n-pub const EWOULDBLOCK: i32 = 41;  /* Operation would block */\n-pub const ENOMSG: i32 = 42;  /* No message of desired type */\n-pub const EIDRM: i32 = 43;  /* Identifier removed */\n-pub const ECHRNG: i32 = 44;  /* Channel number out of range */\n-pub const EL2NSYNC: i32 = 45;  /* Level 2 not synchronized */\n-pub const EL3HLT: i32 = 46;  /* Level 3 halted */\n-pub const EL3RST: i32 = 47;  /* Level 3 reset */\n-pub const ELNRNG: i32 = 48;  /* Link number out of range */\n-pub const EUNATCH: i32 = 49;  /* Protocol driver not attached */\n-pub const ENOCSI: i32 = 50;  /* No CSI structure available */\n-pub const EL2HLT: i32 = 51;  /* Level 2 halted */\n-pub const EBADE: i32 = 52;  /* Invalid exchange */\n-pub const EBADR: i32 = 53;  /* Invalid request descriptor */\n-pub const EXFULL: i32 = 54;  /* Exchange full */\n-pub const ENOANO: i32 = 55;  /* No anode */\n-pub const EBADRQC: i32 = 56;  /* Invalid request code */\n-pub const EBADSLT: i32 = 57;  /* Invalid slot */\n-pub const EDEADLOCK: i32 = 58; /* Resource deadlock would occur */\n-pub const EBFONT: i32 = 59;  /* Bad font file format */\n-pub const ENOSTR: i32 = 60;  /* Device not a stream */\n-pub const ENODATA: i32 = 61;  /* No data available */\n-pub const ETIME: i32 = 62;  /* Timer expired */\n-pub const ENOSR: i32 = 63;  /* Out of streams resources */\n-pub const ENONET: i32 = 64;  /* Machine is not on the network */\n-pub const ENOPKG: i32 = 65;  /* Package not installed */\n-pub const EREMOTE: i32 = 66;  /* Object is remote */\n-pub const ENOLINK: i32 = 67;  /* Link has been severed */\n-pub const EADV: i32 = 68;  /* Advertise error */\n-pub const ESRMNT: i32 = 69;  /* Srmount error */\n-pub const ECOMM: i32 = 70;  /* Communication error on send */\n-pub const EPROTO: i32 = 71;  /* Protocol error */\n-pub const EMULTIHOP: i32 = 72;  /* Multihop attempted */\n-pub const EDOTDOT: i32 = 73;  /* RFS specific error */\n-pub const EBADMSG: i32 = 74;  /* Not a data message */\n-pub const EOVERFLOW: i32 = 75;  /* Value too large for defined data type */\n-pub const ENOTUNIQ: i32 = 76;  /* Name not unique on network */\n-pub const EBADFD: i32 = 77;  /* File descriptor in bad state */\n-pub const EREMCHG: i32 = 78;  /* Remote address changed */\n-pub const ELIBACC: i32 = 79;  /* Can not access a needed shared library */\n-pub const ELIBBAD: i32 = 80;  /* Accessing a corrupted shared library */\n-pub const ELIBSCN: i32 = 81;  /* .lib section in a.out corrupted */\n-pub const ELIBMAX: i32 = 82;  /* Attempting to link in too many shared libraries */\n-pub const ELIBEXEC: i32 = 83;  /* Cannot exec a shared library directly */\n-pub const EILSEQ: i32 = 84;  /* Illegal byte sequence */\n-pub const ERESTART: i32 = 85;  /* Interrupted system call should be restarted */\n-pub const ESTRPIPE: i32 = 86;  /* Streams pipe error */\n-pub const EUSERS: i32 = 87;  /* Too many users */\n-pub const ENOTSOCK: i32 = 88;  /* Socket operation on non-socket */\n-pub const EDESTADDRREQ: i32 = 89;  /* Destination address required */\n-pub const EMSGSIZE: i32 = 90;  /* Message too long */\n-pub const EPROTOTYPE: i32 = 91;  /* Protocol wrong type for socket */\n-pub const ENOPROTOOPT: i32 = 92;  /* Protocol not available */\n-pub const EPROTONOSUPPORT: i32 = 93;  /* Protocol not supported */\n-pub const ESOCKTNOSUPPORT: i32 = 94;  /* Socket type not supported */\n-pub const EOPNOTSUPP: i32 = 95;  /* Operation not supported on transport endpoint */\n-pub const EPFNOSUPPORT: i32 = 96;  /* Protocol family not supported */\n-pub const EAFNOSUPPORT: i32 = 97;  /* Address family not supported by protocol */\n-pub const EADDRINUSE: i32 = 98;  /* Address already in use */\n-pub const EADDRNOTAVAIL: i32 = 99;  /* Cannot assign requested address */\n-pub const ENETDOWN: i32 = 100; /* Network is down */\n-pub const ENETUNREACH: i32 = 101; /* Network is unreachable */\n-pub const ENETRESET: i32 = 102; /* Network dropped connection because of reset */\n-pub const ECONNABORTED: i32 = 103; /* Software caused connection abort */\n-pub const ECONNRESET: i32 = 104; /* Connection reset by peer */\n-pub const ENOBUFS: i32 = 105; /* No buffer space available */\n-pub const EISCONN: i32 = 106; /* Transport endpoint is already connected */\n-pub const ENOTCONN: i32 = 107; /* Transport endpoint is not connected */\n-pub const ESHUTDOWN: i32 = 108; /* Cannot send after transport endpoint shutdown */\n-pub const ETOOMANYREFS: i32 = 109; /* Too many references: cannot splice */\n-pub const ETIMEDOUT: i32 = 110; /* Connection timed out */\n-pub const ECONNREFUSED: i32 = 111; /* Connection refused */\n-pub const EHOSTDOWN: i32 = 112; /* Host is down */\n-pub const EHOSTUNREACH: i32 = 113; /* No route to host */\n-pub const EALREADY: i32 = 114; /* Operation already in progress */\n-pub const EINPROGRESS: i32 = 115; /* Operation now in progress */\n-pub const ESTALE: i32 = 116; /* Stale NFS file handle */\n-pub const EUCLEAN: i32 = 117; /* Structure needs cleaning */\n-pub const ENOTNAM: i32 = 118; /* Not a XENIX named type file */\n-pub const ENAVAIL: i32 = 119; /* No XENIX semaphores available */\n-pub const EISNAM: i32 = 120; /* Is a named type file */\n-pub const EREMOTEIO: i32 = 121; /* Remote I/O error */\n-pub const EDQUOT: i32 = 122; /* Quota exceeded */\n-pub const ENOMEDIUM: i32 = 123; /* No medium found */\n-pub const EMEDIUMTYPE: i32 = 124; /* Wrong medium type */\n-pub const ECANCELED: i32 = 125; /* Operation Canceled */\n-pub const ENOKEY: i32 = 126; /* Required key not available */\n-pub const EKEYEXPIRED: i32 = 127; /* Key has expired */\n-pub const EKEYREVOKED: i32 = 128; /* Key has been revoked */\n-pub const EKEYREJECTED: i32 = 129; /* Key was rejected by service */\n-pub const EOWNERDEAD: i32 = 130; /* Owner died */\n-pub const ENOTRECOVERABLE: i32 = 131; /* State not recoverable */\n-\n-pub static STR_ERROR: [&'static str; 132] = [\"Success\",\n-                                             \"Operation not permitted\",\n-                                             \"No such file or directory\",\n-                                             \"No such process\",\n-                                             \"Interrupted system call\",\n-                                             \"I/O error\",\n-                                             \"No such device or address\",\n-                                             \"Argument list too long\",\n-                                             \"Exec format error\",\n-                                             \"Bad file number\",\n-                                             \"No child processes\",\n-                                             \"Try again\",\n-                                             \"Out of memory\",\n-                                             \"Permission denied\",\n-                                             \"Bad address\",\n-                                             \"Block device required\",\n-                                             \"Device or resource busy\",\n-                                             \"File exists\",\n-                                             \"Cross-device link\",\n-                                             \"No such device\",\n-                                             \"Not a directory\",\n-                                             \"Is a directory\",\n-                                             \"Invalid argument\",\n-                                             \"File table overflow\",\n-                                             \"Too many open files\",\n-                                             \"Not a typewriter\",\n-                                             \"Text file busy\",\n-                                             \"File too large\",\n-                                             \"No space left on device\",\n-                                             \"Illegal seek\",\n-                                             \"Read-only file system\",\n-                                             \"Too many links\",\n-                                             \"Broken pipe\",\n-                                             \"Math argument out of domain of func\",\n-                                             \"Math result not representable\",\n-                                             \"Resource deadlock would occur\",\n-                                             \"File name too long\",\n-                                             \"No record locks available\",\n-                                             \"Function not implemented\",\n-                                             \"Directory not empty\",\n-                                             \"Too many symbolic links encountered\",\n-                                             \"Operation would block\",\n-                                             \"No message of desired type\",\n-                                             \"Identifier removed\",\n-                                             \"Channel number out of range\",\n-                                             \"Level 2 not synchronized\",\n-                                             \"Level 3 halted\",\n-                                             \"Level 3 reset\",\n-                                             \"Link number out of range\",\n-                                             \"Protocol driver not attached\",\n-                                             \"No CSI structure available\",\n-                                             \"Level 2 halted\",\n-                                             \"Invalid exchange\",\n-                                             \"Invalid request descriptor\",\n-                                             \"Exchange full\",\n-                                             \"No anode\",\n-                                             \"Invalid request code\",\n-                                             \"Invalid slot\",\n-                                             \"Resource deadlock would occur\",\n-                                             \"Bad font file format\",\n-                                             \"Device not a stream\",\n-                                             \"No data available\",\n-                                             \"Timer expired\",\n-                                             \"Out of streams resources\",\n-                                             \"Machine is not on the network\",\n-                                             \"Package not installed\",\n-                                             \"Object is remote\",\n-                                             \"Link has been severed\",\n-                                             \"Advertise error\",\n-                                             \"Srmount error\",\n-                                             \"Communication error on send\",\n-                                             \"Protocol error\",\n-                                             \"Multihop attempted\",\n-                                             \"RFS specific error\",\n-                                             \"Not a data message\",\n-                                             \"Value too large for defined data type\",\n-                                             \"Name not unique on network\",\n-                                             \"File descriptor in bad state\",\n-                                             \"Remote address changed\",\n-                                             \"Can not access a needed shared library\",\n-                                             \"Accessing a corrupted shared library\",\n-                                             \".lib section in a.out corrupted\",\n-                                             \"Attempting to link in too many shared libraries\",\n-                                             \"Cannot exec a shared library directly\",\n-                                             \"Illegal byte sequence\",\n-                                             \"Interrupted system call should be restarted\",\n-                                             \"Streams pipe error\",\n-                                             \"Too many users\",\n-                                             \"Socket operation on non-socket\",\n-                                             \"Destination address required\",\n-                                             \"Message too long\",\n-                                             \"Protocol wrong type for socket\",\n-                                             \"Protocol not available\",\n-                                             \"Protocol not supported\",\n-                                             \"Socket type not supported\",\n-                                             \"Operation not supported on transport endpoint\",\n-                                             \"Protocol family not supported\",\n-                                             \"Address family not supported by protocol\",\n-                                             \"Address already in use\",\n-                                             \"Cannot assign requested address\",\n-                                             \"Network is down\",\n-                                             \"Network is unreachable\",\n-                                             \"Network dropped connection because of reset\",\n-                                             \"Software caused connection abort\",\n-                                             \"Connection reset by peer\",\n-                                             \"No buffer space available\",\n-                                             \"Transport endpoint is already connected\",\n-                                             \"Transport endpoint is not connected\",\n-                                             \"Cannot send after transport endpoint shutdown\",\n-                                             \"Too many references: cannot splice\",\n-                                             \"Connection timed out\",\n-                                             \"Connection refused\",\n-                                             \"Host is down\",\n-                                             \"No route to host\",\n-                                             \"Operation already in progress\",\n-                                             \"Operation now in progress\",\n-                                             \"Stale NFS file handle\",\n-                                             \"Structure needs cleaning\",\n-                                             \"Not a XENIX named type file\",\n-                                             \"No XENIX semaphores available\",\n-                                             \"Is a named type file\",\n-                                             \"Remote I/O error\",\n-                                             \"Quota exceeded\",\n-                                             \"No medium found\",\n-                                             \"Wrong medium type\",\n-                                             \"Operation Canceled\",\n-                                             \"Required key not available\",\n-                                             \"Key has expired\",\n-                                             \"Key has been revoked\",\n-                                             \"Key was rejected by service\",\n-                                             \"Owner died\",\n-                                             \"State not recoverable\"];"}, {"sha": "5820f1ad03a314bbacd2614688f3b483c6f1d0a9", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,148 +0,0 @@\n-pub const CLONE_VM: usize = 0x100;\n-pub const CLONE_FS: usize = 0x200;\n-pub const CLONE_FILES: usize = 0x400;\n-pub const CLONE_SIGHAND: usize = 0x800;\n-pub const CLONE_VFORK: usize = 0x4000;\n-pub const CLONE_THREAD: usize = 0x10000;\n-\n-pub const CLOCK_REALTIME: usize = 1;\n-pub const CLOCK_MONOTONIC: usize = 4;\n-\n-pub const EVENT_NONE: usize = 0;\n-pub const EVENT_READ: usize = 1;\n-pub const EVENT_WRITE: usize = 2;\n-\n-pub const F_DUPFD: usize = 0;\n-pub const F_GETFD: usize = 1;\n-pub const F_SETFD: usize = 2;\n-pub const F_GETFL: usize = 3;\n-pub const F_SETFL: usize = 4;\n-\n-pub const FUTEX_WAIT: usize = 0;\n-pub const FUTEX_WAKE: usize = 1;\n-pub const FUTEX_REQUEUE: usize = 2;\n-\n-pub const MAP_WRITE: usize = 1;\n-pub const MAP_WRITE_COMBINE: usize = 2;\n-\n-pub const MODE_TYPE: u16 = 0xF000;\n-pub const MODE_DIR: u16 = 0x4000;\n-pub const MODE_FILE: u16 = 0x8000;\n-pub const MODE_SYMLINK: u16 = 0xA000;\n-pub const MODE_FIFO: u16 = 0x1000;\n-pub const MODE_CHR: u16 = 0x2000;\n-\n-pub const MODE_PERM: u16 = 0x0FFF;\n-pub const MODE_SETUID: u16 = 0o4000;\n-pub const MODE_SETGID: u16 = 0o2000;\n-\n-pub const O_RDONLY: usize =     0x0001_0000;\n-pub const O_WRONLY: usize =     0x0002_0000;\n-pub const O_RDWR: usize =       0x0003_0000;\n-pub const O_NONBLOCK: usize =   0x0004_0000;\n-pub const O_APPEND: usize =     0x0008_0000;\n-pub const O_SHLOCK: usize =     0x0010_0000;\n-pub const O_EXLOCK: usize =     0x0020_0000;\n-pub const O_ASYNC: usize =      0x0040_0000;\n-pub const O_FSYNC: usize =      0x0080_0000;\n-pub const O_CLOEXEC: usize =    0x0100_0000;\n-pub const O_CREAT: usize =      0x0200_0000;\n-pub const O_TRUNC: usize =      0x0400_0000;\n-pub const O_EXCL: usize =       0x0800_0000;\n-pub const O_DIRECTORY: usize =  0x1000_0000;\n-pub const O_STAT: usize =       0x2000_0000;\n-pub const O_SYMLINK: usize =    0x4000_0000;\n-pub const O_NOFOLLOW: usize =   0x8000_0000;\n-pub const O_ACCMODE: usize =    O_RDONLY | O_WRONLY | O_RDWR;\n-\n-pub const SEEK_SET: usize = 0;\n-pub const SEEK_CUR: usize = 1;\n-pub const SEEK_END: usize = 2;\n-\n-pub const SIGHUP: usize =   1;\n-pub const SIGINT: usize =   2;\n-pub const SIGQUIT: usize =  3;\n-pub const SIGILL: usize =   4;\n-pub const SIGTRAP: usize =  5;\n-pub const SIGABRT: usize =  6;\n-pub const SIGBUS: usize =   7;\n-pub const SIGFPE: usize =   8;\n-pub const SIGKILL: usize =  9;\n-pub const SIGUSR1: usize =  10;\n-pub const SIGSEGV: usize =  11;\n-pub const SIGUSR2: usize =  12;\n-pub const SIGPIPE: usize =  13;\n-pub const SIGALRM: usize =  14;\n-pub const SIGTERM: usize =  15;\n-pub const SIGSTKFLT: usize= 16;\n-pub const SIGCHLD: usize =  17;\n-pub const SIGCONT: usize =  18;\n-pub const SIGSTOP: usize =  19;\n-pub const SIGTSTP: usize =  20;\n-pub const SIGTTIN: usize =  21;\n-pub const SIGTTOU: usize =  22;\n-pub const SIGURG: usize =   23;\n-pub const SIGXCPU: usize =  24;\n-pub const SIGXFSZ: usize =  25;\n-pub const SIGVTALRM: usize= 26;\n-pub const SIGPROF: usize =  27;\n-pub const SIGWINCH: usize = 28;\n-pub const SIGIO: usize =    29;\n-pub const SIGPWR: usize =   30;\n-pub const SIGSYS: usize =   31;\n-\n-pub const SIG_DFL: usize = 0;\n-pub const SIG_IGN: usize = 1;\n-\n-pub const SA_NOCLDSTOP: usize = 0x00000001;\n-pub const SA_NOCLDWAIT: usize = 0x00000002;\n-pub const SA_SIGINFO: usize =   0x00000004;\n-pub const SA_RESTORER: usize =  0x04000000;\n-pub const SA_ONSTACK: usize =   0x08000000;\n-pub const SA_RESTART: usize =   0x10000000;\n-pub const SA_NODEFER: usize =   0x40000000;\n-pub const SA_RESETHAND: usize = 0x80000000;\n-\n-pub const WNOHANG: usize =    0x01;\n-pub const WUNTRACED: usize =  0x02;\n-pub const WCONTINUED: usize = 0x08;\n-\n-/// Returns `true` if status indicates the child is stopped.\n-pub fn wifstopped(status: usize) -> bool {\n-    (status & 0xff) == 0x7f\n-}\n-\n-/// If wifstopped(status), returns the signal that stopped the child.\n-pub fn wstopsig(status: usize) -> usize {\n-    (status >> 8) & 0xff\n-}\n-\n-/// Returns `true` if status indicates the child continued after a stop.\n-pub fn wifcontinued(status: usize) -> bool {\n-    status == 0xffff\n-}\n-\n-/// Returns `true` if status indicates termination by a signal.\n-pub fn wifsignaled(status: usize) -> bool {\n-    ((status & 0x7f) + 1) as i8 >= 2\n-}\n-\n-/// If wifsignaled(status), returns the terminating signal.\n-pub fn wtermsig(status: usize) -> usize {\n-    status & 0x7f\n-}\n-\n-/// Returns `true` if status indicates normal termination.\n-pub fn wifexited(status: usize) -> bool {\n-    wtermsig(status) == 0\n-}\n-\n-/// If wifexited(status), returns the exit status.\n-pub fn wexitstatus(status: usize) -> usize {\n-    (status >> 8) & 0xff\n-}\n-\n-/// Returns `true` if status indicates a core dump was created.\n-pub fn wcoredump(status: usize) -> bool {\n-    (status & 0x80) != 0\n-}"}, {"sha": "b16f5dbd918e8a918da65695076257cfb143e651", "filename": "src/libstd/sys/redox/syscall/mod.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,33 +0,0 @@\n-pub use self::arch::*;\n-pub use self::call::*;\n-pub use self::data::*;\n-pub use self::error::*;\n-pub use self::flag::*;\n-pub use self::number::*;\n-\n-#[cfg(target_arch = \"arm\")]\n-#[path=\"arch/arm.rs\"]\n-mod arch;\n-\n-#[cfg(target_arch = \"x86\")]\n-#[path=\"arch/x86.rs\"]\n-mod arch;\n-\n-#[cfg(target_arch = \"x86_64\")]\n-#[path=\"arch/x86_64.rs\"]\n-mod arch;\n-\n-/// Function definitions\n-pub mod call;\n-\n-/// Complex structures that are used for some system calls\n-pub mod data;\n-\n-/// All errors that can be generated by a system call\n-pub mod error;\n-\n-/// Flags used as an argument to many system calls\n-pub mod flag;\n-\n-/// Call numbers used by each system call\n-pub mod number;"}, {"sha": "f8884aa2ed805507b3590450d7e86a2a5f9ed03a", "filename": "src/libstd/sys/redox/syscall/number.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,73 +0,0 @@\n-pub const SYS_CLASS: usize =    0xF000_0000;\n-pub const SYS_CLASS_PATH: usize=0x1000_0000;\n-pub const SYS_CLASS_FILE: usize=0x2000_0000;\n-\n-pub const SYS_ARG: usize =      0x0F00_0000;\n-pub const SYS_ARG_SLICE: usize =0x0100_0000;\n-pub const SYS_ARG_MSLICE: usize=0x0200_0000;\n-pub const SYS_ARG_PATH: usize = 0x0300_0000;\n-\n-pub const SYS_RET: usize =      0x00F0_0000;\n-pub const SYS_RET_FILE: usize = 0x0010_0000;\n-\n-pub const SYS_LINK: usize =     SYS_CLASS_PATH | SYS_ARG_PATH | 9;\n-pub const SYS_OPEN: usize =     SYS_CLASS_PATH | SYS_RET_FILE | 5;\n-pub const SYS_CHMOD: usize =    SYS_CLASS_PATH | 15;\n-pub const SYS_RMDIR: usize =    SYS_CLASS_PATH | 84;\n-pub const SYS_UNLINK: usize =   SYS_CLASS_PATH | 10;\n-\n-pub const SYS_CLOSE: usize =    SYS_CLASS_FILE | 6;\n-pub const SYS_DUP: usize =      SYS_CLASS_FILE | SYS_RET_FILE | 41;\n-pub const SYS_DUP2: usize =     SYS_CLASS_FILE | SYS_RET_FILE | 63;\n-pub const SYS_READ: usize =     SYS_CLASS_FILE | SYS_ARG_MSLICE | 3;\n-pub const SYS_WRITE: usize =    SYS_CLASS_FILE | SYS_ARG_SLICE | 4;\n-pub const SYS_LSEEK: usize =    SYS_CLASS_FILE | 19;\n-pub const SYS_FCHMOD: usize =   SYS_CLASS_FILE | 94;\n-pub const SYS_FCHOWN: usize =   SYS_CLASS_FILE | 207;\n-pub const SYS_FCNTL: usize =    SYS_CLASS_FILE | 55;\n-pub const SYS_FEVENT: usize =   SYS_CLASS_FILE | 927;\n-pub const SYS_FEXEC: usize =    SYS_CLASS_FILE | 11;\n-pub const SYS_FMAP: usize =     SYS_CLASS_FILE | 90;\n-pub const SYS_FUNMAP: usize =   SYS_CLASS_FILE | 91;\n-pub const SYS_FPATH: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 928;\n-pub const SYS_FRENAME: usize =  SYS_CLASS_FILE | SYS_ARG_PATH | 38;\n-pub const SYS_FSTAT: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 28;\n-pub const SYS_FSTATVFS: usize = SYS_CLASS_FILE | SYS_ARG_MSLICE | 100;\n-pub const SYS_FSYNC: usize =    SYS_CLASS_FILE | 118;\n-pub const SYS_FTRUNCATE: usize =SYS_CLASS_FILE | 93;\n-pub const SYS_FUTIMENS: usize = SYS_CLASS_FILE | SYS_ARG_SLICE | 320;\n-\n-pub const SYS_BRK: usize =      45;\n-pub const SYS_CHDIR: usize =    12;\n-pub const SYS_CLOCK_GETTIME: usize = 265;\n-pub const SYS_CLONE: usize =    120;\n-pub const SYS_EXIT: usize =     1;\n-pub const SYS_FUTEX: usize =    240;\n-pub const SYS_GETCWD: usize =   183;\n-pub const SYS_GETEGID: usize =  202;\n-pub const SYS_GETENS: usize =   951;\n-pub const SYS_GETEUID: usize =  201;\n-pub const SYS_GETGID: usize =   200;\n-pub const SYS_GETNS: usize =    950;\n-pub const SYS_GETPID: usize =   20;\n-pub const SYS_GETPGID: usize =  132;\n-pub const SYS_GETPPID: usize =  64;\n-pub const SYS_GETUID: usize =   199;\n-pub const SYS_IOPL: usize =     110;\n-pub const SYS_KILL: usize =     37;\n-pub const SYS_MKNS: usize =     984;\n-pub const SYS_NANOSLEEP: usize =162;\n-pub const SYS_PHYSALLOC: usize =945;\n-pub const SYS_PHYSFREE: usize = 946;\n-pub const SYS_PHYSMAP: usize =  947;\n-pub const SYS_PHYSUNMAP: usize =948;\n-pub const SYS_VIRTTOPHYS: usize=949;\n-pub const SYS_PIPE2: usize =    331;\n-pub const SYS_SETPGID: usize =  57;\n-pub const SYS_SETREGID: usize = 204;\n-pub const SYS_SETRENS: usize =  952;\n-pub const SYS_SETREUID: usize = 203;\n-pub const SYS_SIGACTION: usize =67;\n-pub const SYS_SIGRETURN: usize =119;\n-pub const SYS_WAITPID: usize =  7;\n-pub const SYS_YIELD: usize =    158;"}, {"sha": "9d40a7e8bb8b35d30d098822d6c595e165dc18d1", "filename": "src/libstd/sys/redox/thread.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,84 +0,0 @@\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::mem;\n-use crate::sys_common::thread::start_thread;\n-use crate::sys::{cvt, syscall};\n-use crate::time::Duration;\n-\n-pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n-\n-pub struct Thread {\n-    id: usize,\n-}\n-\n-// Some platforms may have pthread_t as a pointer in which case we still want\n-// a thread to be Send/Sync\n-unsafe impl Send for Thread {}\n-unsafe impl Sync for Thread {}\n-\n-impl Thread {\n-    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n-\n-        let id = cvt(syscall::clone(syscall::CLONE_VM | syscall::CLONE_FS | syscall::CLONE_FILES))?;\n-        if id == 0 {\n-            start_thread(&*p as *const _ as *mut _);\n-            let _ = syscall::exit(0);\n-            panic!(\"thread failed to exit\");\n-        } else {\n-            mem::forget(p);\n-            Ok(Thread { id })\n-        }\n-    }\n-\n-    pub fn yield_now() {\n-        let ret = syscall::sched_yield().expect(\"failed to sched_yield\");\n-        debug_assert_eq!(ret, 0);\n-    }\n-\n-    pub fn set_name(_name: &CStr) {\n-\n-    }\n-\n-    pub fn sleep(dur: Duration) {\n-        let mut secs = dur.as_secs();\n-        let mut nsecs = dur.subsec_nanos() as i32;\n-\n-        // If we're awoken with a signal then the return value will be -1 and\n-        // nanosleep will fill in `ts` with the remaining time.\n-        while secs > 0 || nsecs > 0 {\n-            let req = syscall::TimeSpec {\n-                tv_sec: secs as i64,\n-                tv_nsec: nsecs,\n-            };\n-            secs -= req.tv_sec as u64;\n-            let mut rem = syscall::TimeSpec::default();\n-            if syscall::nanosleep(&req, &mut rem).is_err() {\n-                secs += rem.tv_sec as u64;\n-                nsecs = rem.tv_nsec;\n-            } else {\n-                nsecs = 0;\n-            }\n-        }\n-    }\n-\n-    pub fn join(self) {\n-        let mut status = 0;\n-        syscall::waitpid(self.id, &mut status, 0).unwrap();\n-    }\n-\n-    pub fn id(&self) -> usize { self.id }\n-\n-    pub fn into_id(self) -> usize {\n-        let id = self.id;\n-        mem::forget(self);\n-        id\n-    }\n-}\n-\n-pub mod guard {\n-    pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n-}"}, {"sha": "4bc8c4d5883da0a8e41340be42e55e9c063166f6", "filename": "src/libstd/sys/redox/thread_local.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,61 +0,0 @@\n-#![allow(dead_code)] // not used on all platforms\n-\n-use crate::collections::BTreeMap;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub type Key = usize;\n-\n-type Dtor = unsafe extern fn(*mut u8);\n-\n-static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n-\n-static mut KEYS: *mut BTreeMap<Key, Option<Dtor>> = ptr::null_mut();\n-\n-#[thread_local]\n-static mut LOCALS: *mut BTreeMap<Key, *mut u8> = ptr::null_mut();\n-\n-unsafe fn keys() -> &'static mut BTreeMap<Key, Option<Dtor>> {\n-    if KEYS == ptr::null_mut() {\n-        KEYS = Box::into_raw(Box::new(BTreeMap::new()));\n-    }\n-    &mut *KEYS\n-}\n-\n-unsafe fn locals() -> &'static mut BTreeMap<Key, *mut u8> {\n-    if LOCALS == ptr::null_mut() {\n-        LOCALS = Box::into_raw(Box::new(BTreeMap::new()));\n-    }\n-    &mut *LOCALS\n-}\n-\n-#[inline]\n-pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n-    let key = NEXT_KEY.fetch_add(1, Ordering::SeqCst);\n-    keys().insert(key, dtor);\n-    key\n-}\n-\n-#[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    if let Some(&entry) = locals().get(&key) {\n-        entry\n-    } else {\n-        ptr::null_mut()\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    locals().insert(key, value);\n-}\n-\n-#[inline]\n-pub unsafe fn destroy(key: Key) {\n-    keys().remove(&key);\n-}\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "081437459cc40d0ea32b736f03edca563308d224", "filename": "src/libstd/sys/redox/time.rs", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a91782b72fca586b15ba68364bc7baab837af86/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=6a91782b72fca586b15ba68364bc7baab837af86", "patch": "@@ -1,207 +0,0 @@\n-use crate::cmp::Ordering;\n-use crate::fmt;\n-use crate::sys::{cvt, syscall};\n-use crate::time::Duration;\n-use crate::convert::TryInto;\n-\n-use core::hash::{Hash, Hasher};\n-\n-const NSEC_PER_SEC: u64 = 1_000_000_000;\n-\n-#[derive(Copy, Clone)]\n-struct Timespec {\n-    t: syscall::TimeSpec,\n-}\n-\n-impl Timespec {\n-    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n-        if self >= other {\n-            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n-            } else {\n-                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                              other.t.tv_nsec as u32)\n-            })\n-        } else {\n-            match other.sub_timespec(self) {\n-                Ok(d) => Err(d),\n-                Err(d) => Ok(d),\n-            }\n-        }\n-    }\n-\n-    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n-\n-        // Nano calculations can't overflow because nanos are <1B which fit\n-        // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n-        if nsec >= NSEC_PER_SEC as u32 {\n-            nsec -= NSEC_PER_SEC as u32;\n-            secs = secs.checked_add(1)?;\n-        }\n-        Some(Timespec {\n-            t: syscall::TimeSpec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as i32,\n-            },\n-        })\n-    }\n-\n-    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n-\n-        // Similar to above, nanos can't overflow.\n-        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n-        if nsec < 0 {\n-            nsec += NSEC_PER_SEC as i32;\n-            secs = secs.checked_sub(1)?;\n-        }\n-        Some(Timespec {\n-            t: syscall::TimeSpec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as i32,\n-            },\n-        })\n-    }\n-}\n-\n-impl PartialEq for Timespec {\n-    fn eq(&self, other: &Timespec) -> bool {\n-        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-    }\n-}\n-\n-impl Eq for Timespec {}\n-\n-impl PartialOrd for Timespec {\n-    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Timespec {\n-    fn cmp(&self, other: &Timespec) -> Ordering {\n-        let me = (self.t.tv_sec, self.t.tv_nsec);\n-        let other = (other.t.tv_sec, other.t.tv_nsec);\n-        me.cmp(&other)\n-    }\n-}\n-\n-impl Hash for Timespec {\n-    fn hash<H : Hasher>(&self, state: &mut H) {\n-        self.t.tv_sec.hash(state);\n-        self.t.tv_nsec.hash(state);\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Instant {\n-    t: Timespec,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SystemTime {\n-    t: Timespec,\n-}\n-\n-pub const UNIX_EPOCH: SystemTime = SystemTime {\n-    t: Timespec {\n-        t: syscall::TimeSpec {\n-            tv_sec: 0,\n-            tv_nsec: 0,\n-        },\n-    },\n-};\n-\n-impl Instant {\n-    pub fn now() -> Instant {\n-        Instant { t: now(syscall::CLOCK_MONOTONIC) }\n-    }\n-\n-    pub const fn zero() -> Instant {\n-        Instant { t: Timespec { t: syscall::TimeSpec { tv_sec: 0, tv_nsec: 0 } } }\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n-    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n-        self.t.sub_timespec(&other.t).ok()\n-    }\n-\n-    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_add_duration(other)? })\n-    }\n-\n-    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_sub_duration(other)? })\n-    }\n-}\n-\n-impl fmt::Debug for Instant {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Instant\")\n-         .field(\"tv_sec\", &self.t.t.tv_sec)\n-         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-         .finish()\n-    }\n-}\n-\n-impl SystemTime {\n-    pub fn now() -> SystemTime {\n-        SystemTime { t: now(syscall::CLOCK_REALTIME) }\n-    }\n-\n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n-        self.t.sub_timespec(&other.t)\n-    }\n-\n-    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n-    }\n-\n-    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n-    }\n-}\n-\n-impl From<syscall::TimeSpec> for SystemTime {\n-    fn from(t: syscall::TimeSpec) -> SystemTime {\n-        SystemTime { t: Timespec { t } }\n-    }\n-}\n-\n-impl fmt::Debug for SystemTime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SystemTime\")\n-         .field(\"tv_sec\", &self.t.t.tv_sec)\n-         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-         .finish()\n-    }\n-}\n-\n-pub type clock_t = usize;\n-\n-fn now(clock: clock_t) -> Timespec {\n-    let mut t = Timespec {\n-        t: syscall::TimeSpec {\n-            tv_sec: 0,\n-            tv_nsec: 0,\n-        }\n-    };\n-    cvt(syscall::clock_gettime(clock, &mut t.t)).unwrap();\n-    t\n-}"}, {"sha": "288e9b5c12620a8bfbff7758aa768ff8c53548ff", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -56,7 +56,8 @@ impl DoubleEndedIterator for Args {\n           target_os = \"haiku\",\n           target_os = \"l4re\",\n           target_os = \"fuchsia\",\n-          target_os = \"hermit\"))]\n+          target_os = \"hermit\",\n+          target_os = \"redox\"))]\n mod imp {\n     use crate::os::unix::prelude::*;\n     use crate::ptr;"}, {"sha": "0a93fbf8ea7793d6d7021ebb78488b82d1b55ce5", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -31,14 +31,16 @@ impl Condvar {\n               target_os = \"ios\",\n               target_os = \"l4re\",\n               target_os = \"android\",\n-              target_os = \"hermit\"))]\n+              target_os = \"hermit\",\n+              target_os = \"redox\"))]\n     pub unsafe fn init(&mut self) {}\n \n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"l4re\",\n                   target_os = \"android\",\n-                  target_os = \"hermit\")))]\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\")))]\n     pub unsafe fn init(&mut self) {\n         use crate::mem::MaybeUninit;\n         let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();"}, {"sha": "d724eeb8b3fde73ffdf2e321143aadc7e6ce4531", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -162,3 +162,14 @@ pub mod os {\n     pub const EXE_SUFFIX: &str = \"\";\n     pub const EXE_EXTENSION: &str = \"\";\n }\n+\n+#[cfg(target_os = \"redox\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"redox\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "952ba40ee87a9d786a2762d1d6546f26a150edc4", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -10,7 +10,7 @@\n // fallback implementation to use as well.\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"hermit\"))]\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"hermit\", target_os = \"redox\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local::register_dtor_fallback;"}, {"sha": "ac43526b50f2c9217983546d03e94cc027f2dd11", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -176,7 +176,8 @@ impl FileDesc {\n                   target_os = \"fuchsia\",\n                   target_os = \"l4re\",\n                   target_os = \"linux\",\n-                  target_os = \"haiku\")))]\n+                  target_os = \"haiku\",\n+                  target_os = \"redox\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n@@ -189,7 +190,8 @@ impl FileDesc {\n               target_os = \"fuchsia\",\n               target_os = \"l4re\",\n               target_os = \"linux\",\n-              target_os = \"haiku\"))]\n+              target_os = \"haiku\",\n+              target_os = \"redox\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;"}, {"sha": "822feacea627462fef906a67d9b5cfc6f3298bc5", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -33,7 +33,8 @@ use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n               target_os = \"emscripten\",\n               target_os = \"solaris\",\n               target_os = \"l4re\",\n-              target_os = \"fuchsia\")))]\n+              target_os = \"fuchsia\",\n+              target_os = \"redox\")))]\n use libc::{readdir_r as readdir64_r};\n \n pub use crate::sys_common::fs::remove_dir_all;\n@@ -69,7 +70,7 @@ pub struct DirEntry {\n     // on Solaris and Fuchsia because a) it uses a zero-length\n     // array to store the name, b) its lifetime between readdir\n     // calls is not guaranteed.\n-    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\", target_os = \"redox\"))]\n     name: Box<[u8]>\n }\n \n@@ -216,7 +217,7 @@ impl fmt::Debug for ReadDir {\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\", target_os = \"redox\"))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         use crate::slice;\n \n@@ -253,7 +254,7 @@ impl Iterator for ReadDir {\n         }\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"fuchsia\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"fuchsia\", target_os = \"redox\")))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         if self.end_of_stream {\n             return None;\n@@ -346,7 +347,8 @@ impl DirEntry {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"fuchsia\",\n-              target_os = \"hermit\"))]\n+              target_os = \"hermit\",\n+              target_os = \"redox\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n     }\n@@ -384,7 +386,8 @@ impl DirEntry {\n         }\n     }\n     #[cfg(any(target_os = \"solaris\",\n-              target_os = \"fuchsia\"))]\n+              target_os = \"fuchsia\",\n+              target_os = \"redox\"))]\n     fn name_bytes(&self) -> &[u8] {\n         &*self.name\n     }"}, {"sha": "b1f7aac8b4b4021abd025ddbdfffbff4f3b6b488", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -17,6 +17,7 @@ use crate::io::ErrorKind;\n #[cfg(all(not(rustdoc), target_os = \"fuchsia\"))]   pub use crate::os::fuchsia as platform;\n #[cfg(all(not(rustdoc), target_os = \"l4re\"))]      pub use crate::os::linux as platform;\n #[cfg(all(not(rustdoc), target_os = \"hermit\"))]    pub use crate::os::hermit as platform;\n+#[cfg(all(not(rustdoc), target_os = \"redox\"))]      pub use crate::os::redox as platform;\n \n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;"}, {"sha": "bc8562a0a7be21229b24d7ea6eb220f273a05322", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -25,6 +25,13 @@ use libc::{c_int, c_char, c_void};\n \n const TMPBUF_SZ: usize = 128;\n \n+cfg_if! {\n+    if #[cfg(target_os = \"redox\")] {\n+        const PATH_SEPARATOR: u8 = b';';\n+    } else {\n+        const PATH_SEPARATOR: u8 = b':';\n+    }\n+}\n \n extern {\n     #[cfg(not(target_os = \"dragonfly\"))]\n@@ -37,6 +44,7 @@ extern {\n                    target_os = \"openbsd\",\n                    target_os = \"android\",\n                    target_os = \"hermit\",\n+                   target_os = \"redox\",\n                    target_env = \"newlib\"),\n                link_name = \"__errno\")]\n     #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n@@ -155,10 +163,10 @@ pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n     fn bytes_to_path(b: &[u8]) -> PathBuf {\n         PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n     }\n-    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    fn is_separator(b: &u8) -> bool { *b == PATH_SEPARATOR }\n     let unparsed = unparsed.as_bytes();\n     SplitPaths {\n-        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+        iter: unparsed.split(is_separator as fn(&u8) -> bool)\n                       .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n     }\n }\n@@ -176,12 +184,11 @@ pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n     where I: Iterator<Item=T>, T: AsRef<OsStr>\n {\n     let mut joined = Vec::new();\n-    let sep = b':';\n \n     for (i, path) in paths.enumerate() {\n         let path = path.as_ref().as_bytes();\n-        if i > 0 { joined.push(sep) }\n-        if path.contains(&sep) {\n+        if i > 0 { joined.push(PATH_SEPARATOR) }\n+        if path.contains(&PATH_SEPARATOR) {\n             return Err(JoinPathsError)\n         }\n         joined.extend_from_slice(path);\n@@ -191,7 +198,7 @@ pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n \n impl fmt::Display for JoinPathsError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"path segment contains separator `:`\".fmt(f)\n+        write!(f, \"path segment contains separator `{}`\", PATH_SEPARATOR)\n     }\n }\n \n@@ -382,6 +389,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n+#[cfg(target_os = \"redox\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    crate::fs::read_to_string(\"sys:exe\").map(PathBuf::from)\n+}\n+\n #[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\", target_os = \"hermit\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n@@ -511,11 +523,13 @@ pub fn home_dir() -> Option<PathBuf> {\n \n     #[cfg(any(target_os = \"android\",\n               target_os = \"ios\",\n-              target_os = \"emscripten\"))]\n+              target_os = \"emscripten\",\n+              target_os = \"redox\"))]\n     unsafe fn fallback() -> Option<OsString> { None }\n     #[cfg(not(any(target_os = \"android\",\n                   target_os = \"ios\",\n-                  target_os = \"emscripten\")))]\n+                  target_os = \"emscripten\",\n+                  target_os = \"redox\")))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n             n if n < 0 => 512 as usize,"}, {"sha": "029f4216b7e57a8bcc562f5777f7d3123ed9232a", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -26,7 +26,8 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                 target_os = \"freebsd\",\n                 target_os = \"linux\",\n                 target_os = \"netbsd\",\n-                target_os = \"openbsd\")) &&\n+                target_os = \"openbsd\",\n+                target_os = \"redox\")) &&\n        !INVALID.load(Ordering::SeqCst)\n     {\n "}, {"sha": "9f81c67b47745416113903d85b5b5d3ec1e48bde", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -12,6 +12,14 @@ use crate::collections::BTreeMap;\n \n use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n \n+cfg_if! {\n+    if #[cfg(target_os = \"redox\")] {\n+        const DEV_NULL: &'static str = \"null:\\0\";\n+    } else {\n+        const DEV_NULL: &'static str = \"/dev/null\\0\";\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -298,7 +306,7 @@ impl Stdio {\n                 opts.read(readable);\n                 opts.write(!readable);\n                 let path = unsafe {\n-                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n+                    CStr::from_ptr(DEV_NULL.as_ptr() as *const _)\n                 };\n                 let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))"}, {"sha": "327d82e60cff3f45e3471548b5ddd4ad6ebead5a", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -183,14 +183,17 @@ impl Command {\n                 cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n-                // When dropping privileges from root, the `setgroups` call\n-                // will remove any extraneous groups. If we don't call this,\n-                // then even though our uid has dropped, we may still have\n-                // groups that enable us to do super-user things. This will\n-                // fail if we aren't root, so don't bother checking the\n-                // return value, this is just done as an optimistic\n-                // privilege dropping function.\n-                let _ = libc::setgroups(0, ptr::null());\n+                //FIXME: Redox kernel does not support setgroups yet\n+                if cfg!(not(target_os = \"redox\")) {\n+                    // When dropping privileges from root, the `setgroups` call\n+                    // will remove any extraneous groups. If we don't call this,\n+                    // then even though our uid has dropped, we may still have\n+                    // groups that enable us to do super-user things. This will\n+                    // fail if we aren't root, so don't bother checking the\n+                    // return value, this is just done as an optimistic\n+                    // privilege dropping function.\n+                    let _ = libc::setgroups(0, ptr::null());\n+                }\n \n                 cvt(libc::setuid(u as uid_t))?;\n             }"}, {"sha": "c5be17633025f09ba0bd94c7e5438b14d84b2517", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -15,7 +15,8 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n           not(target_os = \"ios\"),\n           not(target_os = \"openbsd\"),\n           not(target_os = \"freebsd\"),\n-          not(target_os = \"fuchsia\")))]\n+          not(target_os = \"fuchsia\"),\n+          not(target_os = \"redox\")))]\n mod imp {\n     use crate::fs::File;\n     use crate::io::Read;\n@@ -174,3 +175,15 @@ mod imp {\n         unsafe { zx_cprng_draw(v.as_mut_ptr(), v.len()) }\n     }\n }\n+\n+#[cfg(target_os = \"redox\")]\n+mod imp {\n+    use crate::fs::File;\n+    use crate::io::Read;\n+\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        // Open rand:, read from it, and close it again.\n+        let mut file = File::open(\"rand:\").expect(\"failed to open rand:\");\n+        file.read_exact(v).expect(\"failed to read rand:\")\n+    }\n+}"}, {"sha": "988881e35966f40cdc6ca2130240174e3ef9a106", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -140,7 +140,8 @@ impl Thread {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"emscripten\",\n-              target_os = \"hermit\"))]\n+              target_os = \"hermit\",\n+              target_os = \"redox\"))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n     }"}, {"sha": "9190a3b0d5fc7c2fb410f70b7c9a73293ed6f2c9", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -68,7 +68,6 @@ pub mod fs;\n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n-                 target_os = \"redox\",\n                  all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         pub use crate::sys::net;"}, {"sha": "da31a49ddf21f2cbace462f25d9d3c14cbde6621", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -40,7 +40,7 @@ fn main() {\n     } else if target.contains(\"haiku\") {\n         println!(\"cargo:rustc-link-lib=gcc_s\");\n     } else if target.contains(\"redox\") {\n-        println!(\"cargo:rustc-link-lib=gcc\");\n+        // redox is handled in lib.rs\n     } else if target.contains(\"cloudabi\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     }"}, {"sha": "8d916447128fc6b164d43c75ee204b61807e427d", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -24,3 +24,8 @@ cfg_if::cfg_if! {\n #[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]\n #[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n extern {}\n+\n+#[cfg(target_os = \"redox\")]\n+#[link(name = \"gcc_eh\", kind = \"static-nobundle\", cfg(target_feature = \"crt-static\"))]\n+#[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n+extern {}"}, {"sha": "9ffa9391c820bd6fcfacda2178c78016278cc779", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0498da9a3dc061f604fcfb9b56bd889e07f2b7e2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=0498da9a3dc061f604fcfb9b56bd889e07f2b7e2", "patch": "@@ -46,6 +46,7 @@ static TARGETS: &[&str] = &[\n     \"aarch64-unknown-cloudabi\",\n     \"aarch64-unknown-linux-gnu\",\n     \"aarch64-unknown-linux-musl\",\n+    \"aarch64-unknown-redox\",\n     \"arm-linux-androideabi\",\n     \"arm-unknown-linux-gnueabi\",\n     \"arm-unknown-linux-gnueabihf\","}]}