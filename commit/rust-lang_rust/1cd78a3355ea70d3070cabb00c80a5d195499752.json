{"sha": "1cd78a3355ea70d3070cabb00c80a5d195499752", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZDc4YTMzNTVlYTcwZDMwNzBjYWJiMDBjODBhNWQxOTU0OTk3NTI=", "commit": {"author": {"name": "robojumper", "email": "robojumper@gmail.com", "date": "2020-05-31T08:59:40Z"}, "committer": {"name": "robojumper", "email": "robojumper@gmail.com", "date": "2020-05-31T09:40:18Z"}, "message": "correctly infer labelled breaks", "tree": {"sha": "91b2b70dbf3ac73a2fe430fd92a26d41df2a60cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91b2b70dbf3ac73a2fe430fd92a26d41df2a60cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cd78a3355ea70d3070cabb00c80a5d195499752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd78a3355ea70d3070cabb00c80a5d195499752", "html_url": "https://github.com/rust-lang/rust/commit/1cd78a3355ea70d3070cabb00c80a5d195499752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cd78a3355ea70d3070cabb00c80a5d195499752/comments", "author": {"login": "robojumper", "id": 14299449, "node_id": "MDQ6VXNlcjE0Mjk5NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/14299449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robojumper", "html_url": "https://github.com/robojumper", "followers_url": "https://api.github.com/users/robojumper/followers", "following_url": "https://api.github.com/users/robojumper/following{/other_user}", "gists_url": "https://api.github.com/users/robojumper/gists{/gist_id}", "starred_url": "https://api.github.com/users/robojumper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robojumper/subscriptions", "organizations_url": "https://api.github.com/users/robojumper/orgs", "repos_url": "https://api.github.com/users/robojumper/repos", "events_url": "https://api.github.com/users/robojumper/events{/privacy}", "received_events_url": "https://api.github.com/users/robojumper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "robojumper", "id": 14299449, "node_id": "MDQ6VXNlcjE0Mjk5NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/14299449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robojumper", "html_url": "https://github.com/robojumper", "followers_url": "https://api.github.com/users/robojumper/followers", "following_url": "https://api.github.com/users/robojumper/following{/other_user}", "gists_url": "https://api.github.com/users/robojumper/gists{/gist_id}", "starred_url": "https://api.github.com/users/robojumper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robojumper/subscriptions", "organizations_url": "https://api.github.com/users/robojumper/orgs", "repos_url": "https://api.github.com/users/robojumper/repos", "events_url": "https://api.github.com/users/robojumper/events{/privacy}", "received_events_url": "https://api.github.com/users/robojumper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb469c3b31e7da962e91269b53b2f53d672cc4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb469c3b31e7da962e91269b53b2f53d672cc4ba", "html_url": "https://github.com/rust-lang/rust/commit/fb469c3b31e7da962e91269b53b2f53d672cc4ba"}], "stats": {"total": 163, "additions": 117, "deletions": 46}, "files": [{"sha": "dc52c6bd968731f7b8884f5234af6a443c2b90cd", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -134,7 +134,7 @@ impl ExprCollector<'_> {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n     fn empty_block(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None })\n+        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None, label: None })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -215,7 +215,13 @@ impl ExprCollector<'_> {\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Loop {\n+                        body,\n+                        label: e.label().and_then(|l| l.lifetime_token()).map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -230,25 +236,47 @@ impl ExprCollector<'_> {\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n-                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n+                            let break_ =\n+                                self.alloc_expr_desugared(Expr::Break { expr: None, label: None });\n                             let arms = vec![\n                                 MatchArm { pat, expr: body, guard: None },\n                                 MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                            return self.alloc_expr(\n+                                Expr::Loop {\n+                                    body: match_expr,\n+                                    label: e.label().and_then(|l| l.lifetime_token()).map(|l| Name::new_lifetime(&l)),\n+                                },\n+                                syntax_ptr,\n+                            );\n                         }\n                     },\n                 };\n \n-                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::While {\n+                        condition,\n+                        body,\n+                        label: e.label().and_then(|l| l.lifetime_token()).map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                        label: e.label().and_then(|l| l.lifetime_token()).map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -301,13 +329,18 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(_e) => {\n-                // FIXME: labels\n-                self.alloc_expr(Expr::Continue, syntax_ptr)\n+            ast::Expr::ContinueExpr(e) => {\n+                self.alloc_expr(\n+                    Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -529,7 +562,8 @@ impl ExprCollector<'_> {\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n+        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n+        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "e48ff38f96048c18ebe88ae6401c566f55a929b8", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -138,10 +138,10 @@ fn compute_block_scopes(\n fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n     scopes.set_scope(expr, scope);\n     match &body[expr] {\n-        Expr::Block { statements, tail } => {\n+        Expr::Block { statements, tail, .. } => {\n             compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n-        Expr::For { iterable, pat, body: body_expr } => {\n+        Expr::For { iterable, pat, body: body_expr, .. } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let scope = scopes.new_scope(scope);\n             scopes.add_bindings(body, scope, *pat);"}, {"sha": "8683f6c7f6476d72fda779feec1d6558e5942152", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -52,18 +52,22 @@ pub enum Expr {\n     Block {\n         statements: Vec<Statement>,\n         tail: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Loop {\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     While {\n         condition: ExprId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     For {\n         iterable: ExprId,\n         pat: PatId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     Call {\n         callee: ExprId,\n@@ -79,9 +83,12 @@ pub enum Expr {\n         expr: ExprId,\n         arms: Vec<MatchArm>,\n     },\n-    Continue,\n+    Continue {\n+        label: Option<Name>,\n+    },\n     Break {\n         expr: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Return {\n         expr: Option<ExprId>,\n@@ -225,7 +232,7 @@ impl Expr {\n                     f(*else_branch);\n                 }\n             }\n-            Expr::Block { statements, tail } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n@@ -241,8 +248,8 @@ impl Expr {\n                 }\n             }\n             Expr::TryBlock { body } => f(*body),\n-            Expr::Loop { body } => f(*body),\n-            Expr::While { condition, body } => {\n+            Expr::Loop { body, .. } => f(*body),\n+            Expr::While { condition, body, .. } => {\n                 f(*condition);\n                 f(*body);\n             }\n@@ -268,8 +275,8 @@ impl Expr {\n                     f(arm.expr);\n                 }\n             }\n-            Expr::Continue => {}\n-            Expr::Break { expr } | Expr::Return { expr } => {\n+            Expr::Continue { .. } => {},\n+            Expr::Break { expr, .. } | Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     f(*expr);\n                 }"}, {"sha": "ea495cb11a2ba736e759a054fd79112bbf20deb6", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -37,6 +37,11 @@ impl Name {\n         Name(Repr::TupleField(idx))\n     }\n \n+    pub fn new_lifetime(lt: &ra_syntax::SyntaxToken) -> Name {\n+        assert!(lt.kind() == ra_syntax::SyntaxKind::LIFETIME);\n+        Name(Repr::Text(lt.text().clone()))\n+    }\n+\n     /// Shortcut to create inline plain text name\n     const fn new_inline_ascii(text: &[u8]) -> Name {\n         Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))"}, {"sha": "dc77e88e50b2a25af823373efc19bc55e23f59f2", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -219,6 +219,17 @@ struct InferenceContext<'a> {\n struct BreakableContext {\n     pub may_break: bool,\n     pub break_ty: Ty,\n+    pub label: Option<name::Name>,\n+}\n+\n+fn find_breakable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    match label {\n+        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.last_mut(),\n+    }\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "4a98e2debff5f2d3b9345ac62338979f020d1e1c", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -22,8 +22,8 @@ use crate::{\n };\n \n use super::{\n-    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n-    TypeMismatch,\n+    find_breakable, BindingMode, BreakableContext, Diverges, Expectation, InferenceContext,\n+    InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -86,16 +86,20 @@ impl<'a> InferenceContext<'a> {\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::Block { statements, tail, .. } => {\n+                // FIXME: Breakable block inference\n+                self.infer_block(statements, *tail, expected)\n+            }\n             Expr::TryBlock { body } => {\n                 let _inner = self.infer_expr(*body, expected);\n                 // FIXME should be std::result::Result<{inner}, _>\n                 Ty::Unknown\n             }\n-            Expr::Loop { body } => {\n+            Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n                     break_ty: self.table.new_type_var(),\n+                    label: label.clone(),\n                 });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n@@ -110,8 +114,12 @@ impl<'a> InferenceContext<'a> {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n-            Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+            Expr::While { condition, body, label } => {\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,10 +128,14 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n-            Expr::For { iterable, body, pat } => {\n+            Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -236,23 +248,24 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue => Ty::simple(TypeCtor::Never),\n-            Expr::Break { expr } => {\n+            Expr::Continue { .. } => Ty::simple(TypeCtor::Never),\n+            Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n                 } else {\n                     Ty::unit()\n                 };\n \n-                let last_ty = if let Some(ctxt) = self.breakables.last() {\n-                    ctxt.break_ty.clone()\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let last_ty =\n+                    if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n+                        ctxt.break_ty.clone()\n+                    } else {\n+                        Ty::Unknown\n+                    };\n \n                 let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n \n-                if let Some(ctxt) = self.breakables.last_mut() {\n+                if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                     ctxt.break_ty = merged_type;\n                     ctxt.may_break = true;\n                 } else {"}, {"sha": "88309157b78c08711f39197498c4a4aceda60d65", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -1969,31 +1969,31 @@ fn foo() {\n     25..333 '|| 'ou...     }': || -> bool\n     28..333 ''outer...     }': bool\n     41..333 '{     ...     }': ()\n-    55..60 'inner': i32\n-    63..301 ''inner...     }': i32\n+    55..60 'inner': i8\n+    63..301 ''inner...     }': i8\n     76..301 '{     ...     }': ()\n-    94..95 'i': i32\n+    94..95 'i': bool\n     98..114 'Defaul...efault': {unknown}\n-    98..116 'Defaul...ault()': i32\n+    98..116 'Defaul...ault()': bool\n     130..270 'if (br...     }': ()\n     134..148 'break 'outer i': !\n-    147..148 'i': i32\n+    147..148 'i': bool\n     150..209 '{     ...     }': ()\n-    168..194 'loop {...5i8; }': i8\n+    168..194 'loop {...5i8; }': !\n     173..194 '{ brea...5i8; }': ()\n     175..191 'break ...er 5i8': !\n     188..191 '5i8': i8\n     215..270 'if tru...     }': ()\n     218..222 'true': bool\n     223..270 '{     ...     }': ()\n     241..255 'break 'inner 6': !\n-    254..255 '6': i32\n+    254..255 '6': i8\n     283..290 'break 7': !\n-    289..290 '7': i32\n+    289..290 '7': i8\n     311..326 'break inner < 8': !\n-    317..322 'inner': i32\n+    317..322 'inner': i8\n     317..326 'inner < 8': bool\n-    325..326 '8': i32\n+    325..326 '8': i8\n     \"###\n     );\n }"}, {"sha": "cb430ca013528d1833e1349d321d76605b7efb38", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -1081,6 +1081,7 @@ pub struct BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl ast::ModuleItemOwner for BlockExpr {}\n impl BlockExpr {\n+    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }"}, {"sha": "f60f0fb16ce1ad92f3bfc67138cbcfd6922207d1", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd78a3355ea70d3070cabb00c80a5d195499752/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd78a3355ea70d3070cabb00c80a5d195499752/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=1cd78a3355ea70d3070cabb00c80a5d195499752", "patch": "@@ -1058,7 +1058,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n         /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct BlockExpr: AttrsOwner, ModuleItemOwner {\n-            T!['{'], statements: [Stmt], Expr, T!['}'],\n+            Label, T!['{'], statements: [Stmt], Expr, T!['}'],\n         }\n \n         /// Return expression."}]}