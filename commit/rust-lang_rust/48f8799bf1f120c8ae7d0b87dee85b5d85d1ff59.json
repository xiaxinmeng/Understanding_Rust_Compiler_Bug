{"sha": "48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "node_id": "C_kwDOAAsO6NoAKDQ4Zjg3OTliZjFmMTIwYzhhZTdkMGI4N2RlZTg1YjVkODVkMWZmNTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T07:30:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T07:30:54Z"}, "message": "Auto merge of #14967 - rust-lang:revert-14965-panic-ctx, r=Veykril\n\nRevert \"Add mandatory panic contexts to all threadpool tasks\"\n\nReverts rust-lang/rust-analyzer#14965\n\nThis won't quite work actually given the use of `catch_unwind` in some of these", "tree": {"sha": "686b76b14676c81922a2cfe503c05fed22670ab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/686b76b14676c81922a2cfe503c05fed22670ab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "html_url": "https://github.com/rust-lang/rust/commit/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de2320e461719277cf2b86ea4315f8cc5d2bf96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/de2320e461719277cf2b86ea4315f8cc5d2bf96c", "html_url": "https://github.com/rust-lang/rust/commit/de2320e461719277cf2b86ea4315f8cc5d2bf96c"}, {"sha": "a1af9eb1f840f9425dce19d661c7bb34c61e1854", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1af9eb1f840f9425dce19d661c7bb34c61e1854", "html_url": "https://github.com/rust-lang/rust/commit/a1af9eb1f840f9425dce19d661c7bb34c61e1854"}], "stats": {"total": 312, "additions": 138, "deletions": 174}, "files": [{"sha": "ebe77b8dfe72186690fe3ac4c7915dd960521c74", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "patch": "@@ -104,10 +104,13 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(ThreadIntent::Worker, panic_context, {\n+        self.global_state.task_pool.handle.spawn(ThreadIntent::Worker, {\n             let world = self.global_state.snapshot();\n             move || {\n-                let result = panic::catch_unwind(move || f(world, params));\n+                let result = panic::catch_unwind(move || {\n+                    let _pctx = stdx::panic_context::enter(panic_context);\n+                    f(world, params)\n+                });\n                 match thread_result_to_response::<R>(req.id.clone(), result) {\n                     Ok(response) => Task::Response(response),\n                     Err(_) => Task::Response(lsp_server::Response::new_err(\n@@ -175,10 +178,13 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(intent, panic_context, {\n+        self.global_state.task_pool.handle.spawn(intent, {\n             let world = self.global_state.snapshot();\n             move || {\n-                let result = panic::catch_unwind(move || f(world, params));\n+                let result = panic::catch_unwind(move || {\n+                    let _pctx = stdx::panic_context::enter(panic_context);\n+                    f(world, params)\n+                });\n                 match thread_result_to_response::<R>(req.id.clone(), result) {\n                     Ok(response) => Task::Response(response),\n                     Err(_) => Task::Retry(req),"}, {"sha": "09de6900c8fb5b1b4b766e645ad20bdf6da50dc4", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "patch": "@@ -291,15 +291,11 @@ fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {\n             }\n             Ok(())\n         };\n-        state.task_pool.handle.spawn_with_sender(\n-            stdx::thread::ThreadIntent::Worker,\n-            \"flycheck\",\n-            move |_| {\n-                if let Err(e) = std::panic::catch_unwind(task) {\n-                    tracing::error!(\"flycheck task panicked: {e:?}\")\n-                }\n-            },\n-        );\n+        state.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, move |_| {\n+            if let Err(e) = std::panic::catch_unwind(task) {\n+                tracing::error!(\"flycheck task panicked: {e:?}\")\n+            }\n+        });\n         true\n     } else {\n         false"}, {"sha": "19c49a23000ea57e085c0b04a8eb95ca2aa87ea0", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 64, "deletions": 76, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "patch": "@@ -397,25 +397,19 @@ impl GlobalState {\n         tracing::debug!(%cause, \"will prime caches\");\n         let num_worker_threads = self.config.prime_caches_num_threads();\n \n-        self.task_pool.handle.spawn_with_sender(\n-            stdx::thread::ThreadIntent::Worker,\n-            \"prime_caches\",\n-            {\n-                let analysis = self.snapshot().analysis;\n-                move |sender| {\n-                    sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                    let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n-                        let report = PrimeCachesProgress::Report(progress);\n-                        sender.send(Task::PrimeCaches(report)).unwrap();\n-                    });\n-                    sender\n-                        .send(Task::PrimeCaches(PrimeCachesProgress::End {\n-                            cancelled: res.is_err(),\n-                        }))\n-                        .unwrap();\n-                }\n-            },\n-        );\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, {\n+            let analysis = self.snapshot().analysis;\n+            move |sender| {\n+                sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n+                let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n+                    let report = PrimeCachesProgress::Report(progress);\n+                    sender.send(Task::PrimeCaches(report)).unwrap();\n+                });\n+                sender\n+                    .send(Task::PrimeCaches(PrimeCachesProgress::End { cancelled: res.is_err() }))\n+                    .unwrap();\n+            }\n+        });\n     }\n \n     fn update_status_or_notify(&mut self) {\n@@ -802,62 +796,56 @@ impl GlobalState {\n \n         // Diagnostics are triggered by the user typing\n         // so we run them on a latency sensitive thread.\n-        self.task_pool.handle.spawn(\n-            stdx::thread::ThreadIntent::LatencySensitive,\n-            \"publish_diagnostics\",\n-            move || {\n-                let _p = profile::span(\"publish_diagnostics\");\n-                let diagnostics = subscriptions\n-                    .into_iter()\n-                    .filter_map(|file_id| {\n-                        let line_index = snapshot.file_line_index(file_id).ok()?;\n-                        Some((\n-                            file_id,\n-                            line_index,\n-                            snapshot\n-                                .analysis\n-                                .diagnostics(\n-                                    &snapshot.config.diagnostics(),\n-                                    ide::AssistResolveStrategy::None,\n-                                    file_id,\n-                                )\n-                                .ok()?,\n-                        ))\n-                    })\n-                    .map(|(file_id, line_index, it)| {\n-                        (\n-                            file_id,\n-                            it.into_iter()\n-                                .map(move |d| lsp_types::Diagnostic {\n-                                    range: crate::to_proto::range(&line_index, d.range),\n-                                    severity: Some(crate::to_proto::diagnostic_severity(\n-                                        d.severity,\n-                                    )),\n-                                    code: Some(lsp_types::NumberOrString::String(\n-                                        d.code.as_str().to_string(),\n-                                    )),\n-                                    code_description: Some(lsp_types::CodeDescription {\n-                                        href: lsp_types::Url::parse(&format!(\n-                                            \"https://rust-analyzer.github.io/manual.html#{}\",\n-                                            d.code.as_str()\n-                                        ))\n-                                        .unwrap(),\n-                                    }),\n-                                    source: Some(\"rust-analyzer\".to_string()),\n-                                    message: d.message,\n-                                    related_information: None,\n-                                    tags: if d.unused {\n-                                        Some(vec![lsp_types::DiagnosticTag::UNNECESSARY])\n-                                    } else {\n-                                        None\n-                                    },\n-                                    data: None,\n-                                })\n-                                .collect::<Vec<_>>(),\n-                        )\n-                    });\n-                Task::Diagnostics(diagnostics.collect())\n-            },\n-        );\n+        self.task_pool.handle.spawn(stdx::thread::ThreadIntent::LatencySensitive, move || {\n+            let _p = profile::span(\"publish_diagnostics\");\n+            let diagnostics = subscriptions\n+                .into_iter()\n+                .filter_map(|file_id| {\n+                    let line_index = snapshot.file_line_index(file_id).ok()?;\n+                    Some((\n+                        file_id,\n+                        line_index,\n+                        snapshot\n+                            .analysis\n+                            .diagnostics(\n+                                &snapshot.config.diagnostics(),\n+                                ide::AssistResolveStrategy::None,\n+                                file_id,\n+                            )\n+                            .ok()?,\n+                    ))\n+                })\n+                .map(|(file_id, line_index, it)| {\n+                    (\n+                        file_id,\n+                        it.into_iter()\n+                            .map(move |d| lsp_types::Diagnostic {\n+                                range: crate::to_proto::range(&line_index, d.range),\n+                                severity: Some(crate::to_proto::diagnostic_severity(d.severity)),\n+                                code: Some(lsp_types::NumberOrString::String(\n+                                    d.code.as_str().to_string(),\n+                                )),\n+                                code_description: Some(lsp_types::CodeDescription {\n+                                    href: lsp_types::Url::parse(&format!(\n+                                        \"https://rust-analyzer.github.io/manual.html#{}\",\n+                                        d.code.as_str()\n+                                    ))\n+                                    .unwrap(),\n+                                }),\n+                                source: Some(\"rust-analyzer\".to_string()),\n+                                message: d.message,\n+                                related_information: None,\n+                                tags: if d.unused {\n+                                    Some(vec![lsp_types::DiagnosticTag::UNNECESSARY])\n+                                } else {\n+                                    None\n+                                },\n+                                data: None,\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    )\n+                });\n+            Task::Diagnostics(diagnostics.collect())\n+        });\n     }\n }"}, {"sha": "6e8c8ea91a1b35b5ec6e3685d41480bff58df06e", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 53, "deletions": 63, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "patch": "@@ -185,7 +185,7 @@ impl GlobalState {\n     pub(crate) fn fetch_workspaces(&mut self, cause: Cause) {\n         tracing::info!(%cause, \"will fetch workspaces\");\n \n-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, \"fetch_workspaces\", {\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, {\n             let linked_projects = self.config.linked_projects();\n             let detached_files = self.config.detached_files().to_vec();\n             let cargo_config = self.config.cargo();\n@@ -260,80 +260,70 @@ impl GlobalState {\n         tracing::info!(%cause, \"will fetch build data\");\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n-        self.task_pool.handle.spawn_with_sender(\n-            ThreadIntent::Worker,\n-            \"fetch_build_data\",\n-            move |sender| {\n-                sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n+            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n \n-                let progress = {\n-                    let sender = sender.clone();\n-                    move |msg| {\n-                        sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n-                    }\n-                };\n-                let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n+            let progress = {\n+                let sender = sender.clone();\n+                move |msg| {\n+                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n+                }\n+            };\n+            let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n \n-                sender\n-                    .send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res))))\n-                    .unwrap();\n-            },\n-        );\n+            sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n+        });\n     }\n \n     pub(crate) fn fetch_proc_macros(&mut self, cause: Cause, paths: Vec<ProcMacroPaths>) {\n         tracing::info!(%cause, \"will load proc macros\");\n         let dummy_replacements = self.config.dummy_replacements().clone();\n         let proc_macro_clients = self.proc_macro_clients.clone();\n \n-        self.task_pool.handle.spawn_with_sender(\n-            ThreadIntent::Worker,\n-            \"fetch_proc_macros\",\n-            move |sender| {\n-                sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n-\n-                let dummy_replacements = &dummy_replacements;\n-                let progress = {\n-                    let sender = sender.clone();\n-                    &move |msg| {\n-                        sender.send(Task::LoadProcMacros(ProcMacroProgress::Report(msg))).unwrap()\n-                    }\n-                };\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n+            sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n \n-                let mut res = FxHashMap::default();\n-                let chain = proc_macro_clients\n-                    .iter()\n-                    .map(|res| res.as_ref().map_err(|e| e.to_string()))\n-                    .chain(iter::repeat_with(|| Err(\"Proc macros servers are not running\".into())));\n-                for (client, paths) in chain.zip(paths) {\n-                    res.extend(paths.into_iter().map(move |(crate_id, res)| {\n-                        (\n-                            crate_id,\n-                            res.map_or_else(\n-                                |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n-                                |(crate_name, path)| {\n-                                    progress(path.display().to_string());\n-                                    client.as_ref().map_err(Clone::clone).and_then(|client| {\n-                                        load_proc_macro(\n-                                            client,\n-                                            &path,\n-                                            crate_name\n-                                                .as_deref()\n-                                                .and_then(|crate_name| {\n-                                                    dummy_replacements.get(crate_name).map(|v| &**v)\n-                                                })\n-                                                .unwrap_or_default(),\n-                                        )\n-                                    })\n-                                },\n-                            ),\n-                        )\n-                    }));\n+            let dummy_replacements = &dummy_replacements;\n+            let progress = {\n+                let sender = sender.clone();\n+                &move |msg| {\n+                    sender.send(Task::LoadProcMacros(ProcMacroProgress::Report(msg))).unwrap()\n                 }\n+            };\n+\n+            let mut res = FxHashMap::default();\n+            let chain = proc_macro_clients\n+                .iter()\n+                .map(|res| res.as_ref().map_err(|e| e.to_string()))\n+                .chain(iter::repeat_with(|| Err(\"Proc macros servers are not running\".into())));\n+            for (client, paths) in chain.zip(paths) {\n+                res.extend(paths.into_iter().map(move |(crate_id, res)| {\n+                    (\n+                        crate_id,\n+                        res.map_or_else(\n+                            |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n+                            |(crate_name, path)| {\n+                                progress(path.display().to_string());\n+                                client.as_ref().map_err(Clone::clone).and_then(|client| {\n+                                    load_proc_macro(\n+                                        client,\n+                                        &path,\n+                                        crate_name\n+                                            .as_deref()\n+                                            .and_then(|crate_name| {\n+                                                dummy_replacements.get(crate_name).map(|v| &**v)\n+                                            })\n+                                            .unwrap_or_default(),\n+                                    )\n+                                })\n+                            },\n+                        ),\n+                    )\n+                }));\n+            }\n \n-                sender.send(Task::LoadProcMacros(ProcMacroProgress::End(res))).unwrap();\n-            },\n-        );\n+            sender.send(Task::LoadProcMacros(ProcMacroProgress::End(res))).unwrap();\n+        });\n     }\n \n     pub(crate) fn set_proc_macros(&mut self, proc_macros: ProcMacros) {"}, {"sha": "a5a10e86914e0fbcab3f96dbfee7984bccebf914", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=48f8799bf1f120c8ae7d0b87dee85b5d85d1ff59", "patch": "@@ -14,41 +14,25 @@ impl<T> TaskPool<T> {\n         TaskPool { sender, pool: Pool::new(threads) }\n     }\n \n-    pub(crate) fn spawn<F>(\n-        &mut self,\n-        intent: ThreadIntent,\n-        panic_context: impl Into<String>,\n-        task: F,\n-    ) where\n+    pub(crate) fn spawn<F>(&mut self, intent: ThreadIntent, task: F)\n+    where\n         F: FnOnce() -> T + Send + 'static,\n         T: Send + 'static,\n     {\n-        let panic_context = panic_context.into();\n         self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n-            move || {\n-                let _pctx = stdx::panic_context::enter(panic_context);\n-                sender.send(task()).unwrap()\n-            }\n+            move || sender.send(task()).unwrap()\n         })\n     }\n \n-    pub(crate) fn spawn_with_sender<F>(\n-        &mut self,\n-        intent: ThreadIntent,\n-        panic_context: impl Into<String>,\n-        task: F,\n-    ) where\n+    pub(crate) fn spawn_with_sender<F>(&mut self, intent: ThreadIntent, task: F)\n+    where\n         F: FnOnce(Sender<T>) + Send + 'static,\n         T: Send + 'static,\n     {\n-        let panic_context = panic_context.into();\n         self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n-            move || {\n-                let _pctx = stdx::panic_context::enter(panic_context);\n-                task(sender)\n-            }\n+            move || task(sender)\n         })\n     }\n "}]}