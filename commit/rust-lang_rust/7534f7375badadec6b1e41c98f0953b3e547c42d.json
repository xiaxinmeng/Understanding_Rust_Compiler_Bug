{"sha": "7534f7375badadec6b1e41c98f0953b3e547c42d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MzRmNzM3NWJhZGFkZWM2YjFlNDFjOThmMDk1M2IzZTU0N2M0MmQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-20T16:16:36Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-27T15:13:23Z"}, "message": "clear out projection subobligations after they are processed\n\nAfter a projection was processed, its derived subobligations no longer\nneed any processing when encountered, and can be removed. This improves\nthe status of #43787.\n\nThis is actually complementary to #43938 - that PR fixes selection\ncaching (and @remram44's example, which \"accidentally\" worked because of\nthe buggy projection caching) while this PR fixes projection caching", "tree": {"sha": "f6accb2dc2f2c304b7d5dd95549dca0638f9c3db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6accb2dc2f2c304b7d5dd95549dca0638f9c3db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7534f7375badadec6b1e41c98f0953b3e547c42d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7534f7375badadec6b1e41c98f0953b3e547c42d", "html_url": "https://github.com/rust-lang/rust/commit/7534f7375badadec6b1e41c98f0953b3e547c42d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7534f7375badadec6b1e41c98f0953b3e547c42d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e95bb7ac92f8f92654705a47cef652b6a0b259", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e95bb7ac92f8f92654705a47cef652b6a0b259", "html_url": "https://github.com/rust-lang/rust/commit/78e95bb7ac92f8f92654705a47cef652b6a0b259"}], "stats": {"total": 131, "additions": 112, "deletions": 19}, "files": [{"sha": "fbc393cbd96f27f6d1022d94ca0dff8976b31715", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=7534f7375badadec6b1e41c98f0953b3e547c42d", "patch": "@@ -251,6 +251,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n+            // FIXME: if we kept the original cache key, we could mark projection\n+            // obligations as complete for the projection cache here.\n+\n             errors.extend(\n                 outcome.errors.into_iter()\n                               .map(|e| to_fulfillment_error(e)));"}, {"sha": "dbf04d72439e0dd8ab9fb496b97acce03812a6a4", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 100, "deletions": 16, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7534f7375badadec6b1e41c98f0953b3e547c42d", "patch": "@@ -121,11 +121,13 @@ struct ProjectionTyCandidateSet<'tcx> {\n ///\n ///     for<...> <T as Trait>::U == V\n ///\n-/// If successful, this may result in additional obligations.\n+/// If successful, this may result in additional obligations. Also returns\n+/// the projection cache key used to track these additional obligations.\n pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+              MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"poly_project_and_unify_type(obligation={:?})\",\n            obligation);\n@@ -161,7 +163,8 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+              MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n@@ -396,6 +399,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     let infcx = selcx.infcx();\n \n     let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+    let cache_key = ProjectionCacheKey { ty: projection_ty };\n \n     debug!(\"opt_normalize_projection_type(\\\n            projection_ty={:?}, \\\n@@ -411,7 +415,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    match infcx.projection_cache.borrow_mut().try_start(projection_ty) {\n+    match infcx.projection_cache.borrow_mut().try_start(cache_key) {\n         Ok(()) => { }\n         Err(ProjectionCacheEntry::Ambiguous) => {\n             // If we found ambiguity the last time, that generally\n@@ -522,7 +526,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -533,14 +537,14 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     too many candidates\");\n             infcx.projection_cache.borrow_mut()\n-                                  .ambiguous(projection_ty);\n+                                  .ambiguous(cache_key);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -551,7 +555,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // reported later\n \n             infcx.projection_cache.borrow_mut()\n-                                  .error(projection_ty);\n+                                  .error(cache_key);\n             Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n         }\n     }\n@@ -1323,8 +1327,62 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n \n // # Cache\n \n+/// The projection cache. Unlike the standard caches, this can\n+/// include infcx-dependent type variables - therefore, we have to roll\n+/// the cache back each time we roll a snapshot back, to avoid assumptions\n+/// on yet-unresolved inference variables. Types with skolemized regions\n+/// also have to be removed when the respective snapshot ends.\n+///\n+/// Because of that, projection cache entries can be \"stranded\" and left\n+/// inaccessible when type variables inside the key are resolved. We make no\n+/// attempt to recover or remove \"stranded\" entries, but rather let them be\n+/// (for the lifetime of the infcx).\n+///\n+/// Entries in the projection cache might contain inference variables\n+/// that will be resolved by obligations on the projection cache entry - e.g.\n+/// when a type parameter in the associated type is constrained through\n+/// an \"RFC 447\" projection on the impl.\n+///\n+/// When working with a fulfillment context, the derived obligations of each\n+/// projection cache entry will be registered on the fulfillcx, so any users\n+/// that can wait for a fulfillcx fixed point need not care about this. However,\n+/// users that don't wait for a fixed point (e.g. trait evaluation) have to\n+/// resolve the obligations themselves to make sure the projected result is\n+/// ok and avoid issues like #43132.\n+///\n+/// If that is done, after evaluation the obligations, it is a good idea to\n+/// call `ProjectionCache::complete` to make sure the obligations won't be\n+/// re-evaluated and avoid an exponential worst-case.\n+///\n+/// FIXME: we probably also want some sort of cross-infcx cache here to\n+/// reduce the amount of duplication. Let's see what we get with the Chalk\n+/// reforms.\n pub struct ProjectionCache<'tcx> {\n-    map: SnapshotMap<ty::ProjectionTy<'tcx>, ProjectionCacheEntry<'tcx>>,\n+    map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct ProjectionCacheKey<'tcx> {\n+    ty: ty::ProjectionTy<'tcx>\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n+    pub fn from_poly_projection_predicate(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+                                          predicate: &ty::PolyProjectionPredicate<'tcx>)\n+                                          -> Option<Self>\n+    {\n+        let infcx = selcx.infcx();\n+        // We don't do cross-snapshot caching of obligations with escaping regions,\n+        // so there's no cache key to use\n+        infcx.tcx.no_late_bound_regions(&predicate)\n+            .map(|predicate| ProjectionCacheKey {\n+                // We don't attempt to match up with a specific type-variable state\n+                // from a specific call to `opt_normalize_projection_type` - if\n+                // there's no precise match, the original cache entry is \"stranded\"\n+                // anyway.\n+                ty: infcx.resolve_type_vars_if_possible(&predicate.projection_ty)\n+            })\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1337,7 +1395,7 @@ enum ProjectionCacheEntry<'tcx> {\n \n // NB: intentionally not Clone\n pub struct ProjectionCacheSnapshot {\n-    snapshot: Snapshot\n+    snapshot: Snapshot,\n }\n \n impl<'tcx> ProjectionCache<'tcx> {\n@@ -1356,7 +1414,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     pub fn rollback_skolemized(&mut self, snapshot: &ProjectionCacheSnapshot) {\n-        self.map.partial_rollback(&snapshot.snapshot, &|k| k.has_re_skol());\n+        self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_skol());\n     }\n \n     pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n@@ -1366,7 +1424,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// Try to start normalize `key`; returns an error if\n     /// normalization already occurred (this error corresponds to a\n     /// cache hit, so it's actually a good thing).\n-    fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n+    fn try_start(&mut self, key: ProjectionCacheKey<'tcx>)\n                  -> Result<(), ProjectionCacheEntry<'tcx>> {\n         if let Some(entry) = self.map.get(&key) {\n             return Err(entry.clone());\n@@ -1377,25 +1435,51 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    fn complete(&mut self, key: ty::ProjectionTy<'tcx>, value: &NormalizedTy<'tcx>) {\n-        debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n+    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: &NormalizedTy<'tcx>) {\n+        debug!(\"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n                key, value);\n         let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n+    /// Mark the relevant projection cache key as having its derived obligations\n+    /// complete, so they won't have to be re-computed (this is OK to do in a\n+    /// snapshot - if the snapshot is rolled back, the obligations will be\n+    /// marked as incomplete again).\n+    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n+        let ty = match self.map.get(&key) {\n+            Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n+                debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\",\n+                       key, ty);\n+                ty.value\n+            }\n+            ref value => {\n+                // Type inference could \"strand behind\" old cache entries. Leave\n+                // them alone for now.\n+                debug!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\",\n+                       key, value);\n+                return\n+            }\n+        };\n+\n+        self.map.insert(key, ProjectionCacheEntry::NormalizedTy(Normalized {\n+            value: ty,\n+            obligations: vec![]\n+        }));\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will\n     /// be different).\n-    fn ambiguous(&mut self, key: ty::ProjectionTy<'tcx>) {\n+    fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n         let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n \n     /// Indicates that trying to normalize `key` resulted in\n     /// error.\n-    fn error(&mut self, key: ty::ProjectionTy<'tcx>) {\n+    fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n         let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }"}, {"sha": "7d555f1d0be49f9210d5f80308936b01e219856e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7534f7375badadec6b1e41c98f0953b3e547c42d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7534f7375badadec6b1e41c98f0953b3e547c42d", "patch": "@@ -16,7 +16,7 @@ use self::EvaluationResult::*;\n use super::coherence;\n use super::DerivedObligationCause;\n use super::project;\n-use super::project::{normalize_with_depth, Normalized};\n+use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n@@ -655,8 +655,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let project_obligation = obligation.with(data.clone());\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(subobligations)) => {\n-                        self.evaluate_predicates_recursively(previous_stack,\n-                                                             subobligations.iter())\n+                        let result = self.evaluate_predicates_recursively(previous_stack,\n+                                                                          subobligations.iter());\n+                        if let Some(key) =\n+                            ProjectionCacheKey::from_poly_projection_predicate(self, data)\n+                        {\n+                            self.infcx.projection_cache.borrow_mut().complete(key);\n+                        }\n+                        result\n                     }\n                     Ok(None) => {\n                         EvaluatedToAmbig"}]}