{"sha": "d07ee255d0587f696155f6095f263b53237c0dca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwN2VlMjU1ZDA1ODdmNjk2MTU1ZjYwOTVmMjYzYjUzMjM3YzBkY2E=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-25T17:50:30Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-25T17:50:30Z"}, "message": "handle dtors having generics in an order different from their ADT\n\nFixes #27997.", "tree": {"sha": "a944dcf1d5cb052bc6c02a054cbaf0511c0be31f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a944dcf1d5cb052bc6c02a054cbaf0511c0be31f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d07ee255d0587f696155f6095f263b53237c0dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d07ee255d0587f696155f6095f263b53237c0dca", "html_url": "https://github.com/rust-lang/rust/commit/d07ee255d0587f696155f6095f263b53237c0dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d07ee255d0587f696155f6095f263b53237c0dca/comments", "author": null, "committer": null, "parents": [{"sha": "2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "html_url": "https://github.com/rust-lang/rust/commit/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4"}], "stats": {"total": 168, "additions": 92, "deletions": 76}, "files": [{"sha": "99495317c2086799fce38cbf887b4f26df9f4d07", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 44, "deletions": 68, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d07ee255d0587f696155f6095f263b53237c0dca/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07ee255d0587f696155f6095f263b53237c0dca/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d07ee255d0587f696155f6095f263b53237c0dca", "patch": "@@ -16,11 +16,9 @@\n use back::link::*;\n use llvm;\n use llvm::{ValueRef, get_param};\n-use metadata::csearch;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::ExchangeFreeFnLangItem;\n-use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n+use middle::traits;\n use middle::ty::{self, Ty};\n use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n@@ -33,16 +31,15 @@ use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n-use trans::foreign;\n-use trans::inline;\n use trans::machine::*;\n use trans::monomorphize;\n-use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n+use trans::type_of::{type_of, sizing_type_of, align_of};\n use trans::type_::Type;\n \n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n@@ -287,10 +284,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n-                                      struct_data: ValueRef,\n-                                      dtor_did: DefId,\n-                                      class_did: DefId,\n-                                      substs: &subst::Substs<'tcx>)\n+                                      struct_data: ValueRef)\n                                       -> Block<'blk, 'tcx> {\n     assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n \n@@ -318,59 +312,19 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n     with_cond(bcx, drop_flag_dtor_needed, |cx| {\n-        trans_struct_drop(cx, t, struct_data, dtor_did, class_did, substs)\n+        trans_struct_drop(cx, t, struct_data)\n     })\n }\n-\n-pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              did: DefId,\n-                              parent_id: DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> ValueRef {\n-    let _icx = push_ctxt(\"trans_res_dtor\");\n-    let did = inline::maybe_instantiate_inline(ccx, did);\n-\n-    if !substs.types.is_empty() {\n-        assert_eq!(did.krate, LOCAL_CRATE);\n-\n-        // Since we're in trans we don't care for any region parameters\n-        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n-\n-        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n-\n-        val\n-    } else if did.is_local() {\n-        get_item_val(ccx, did.node)\n-    } else {\n-        let tcx = ccx.tcx();\n-        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = tcx.lookup_item_type(parent_id).ty.subst(tcx, substs);\n-        let llty = type_of_dtor(ccx, class_ty);\n-        foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n-                               llty, ccx.tcx().mk_nil())\n-    }\n-}\n-\n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n-                                 v0: ValueRef,\n-                                 dtor_did: DefId,\n-                                 class_did: DefId,\n-                                 substs: &subst::Substs<'tcx>)\n+                                 v0: ValueRef)\n                                  -> Block<'blk, 'tcx>\n {\n     debug!(\"trans_struct_drop t: {}\", t);\n+    let tcx = bcx.tcx();\n+    let mut bcx = bcx;\n \n-    // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, class_did, substs);\n-\n-    // Class dtors have no explicit args, so the params should\n-    // just consist of the environment (self).\n-    let params = unsafe {\n-        let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n-        ty.element_type().func_params()\n-    };\n-    assert_eq!(params.len(), if type_is_sized(bcx.tcx(), t) { 1 } else { 2 });\n+    let def = t.ty_adt_def().unwrap();\n \n     // Be sure to put the contents into a scope so we can use an invoke\n     // instruction to call the user destructor but still call the field\n@@ -384,15 +338,37 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // discriminant (if any) in case of variant swap in drop code.\n     bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n-    let glue_type = get_drop_glue_type(bcx.ccx(), t);\n-    let dtor_ty = bcx.tcx().mk_ctor_fn(class_did, &[glue_type], bcx.tcx().mk_nil());\n-    let (_, bcx) = if type_is_sized(bcx.tcx(), t) {\n-        invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None)\n+    let (sized_args, unsized_args);\n+    let args: &[ValueRef] = if type_is_sized(tcx, t) {\n+        sized_args = [v0];\n+        &sized_args\n     } else {\n-        let args = [Load(bcx, expr::get_dataptr(bcx, v0)), Load(bcx, expr::get_meta(bcx, v0))];\n-        invoke(bcx, dtor_addr, &args, dtor_ty, DebugLoc::None)\n+        unsized_args = [Load(bcx, expr::get_dataptr(bcx, v0)), Load(bcx, expr::get_meta(bcx, v0))];\n+        &unsized_args\n     };\n \n+    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        let trait_ref = ty::Binder(ty::TraitRef {\n+            def_id: tcx.lang_items.drop_trait().unwrap(),\n+            substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n+        });\n+        let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(data) => data,\n+            _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+        };\n+        let dtor_did = tcx.destructor_for_type.borrow()[&def.did];\n+        let datum = callee::trans_fn_ref_with_substs(bcx.ccx(),\n+                                                     dtor_did,\n+                                                     ExprId(0),\n+                                                     bcx.fcx.param_substs,\n+                                                     vtbl.substs);\n+        callee::Callee {\n+            bcx: bcx,\n+            data: callee::Fn(datum.val),\n+            ty: datum.ty\n+        }\n+    }, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n@@ -557,27 +533,27 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 })\n             }\n         }\n-        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+        ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n             let tcx = bcx.tcx();\n             match (tcx.ty_dtor(def.did), skip_dtor) {\n-                (ty::TraitDtor(dtor, true), false) => {\n+                (ty::TraitDtor(_, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n                     if type_is_sized(bcx.tcx(), t) {\n-                        trans_struct_drop_flag(bcx, t, v0, dtor, def.did, substs)\n+                        trans_struct_drop_flag(bcx, t, v0)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\", t));\n-                        trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n+                        trans_struct_drop(bcx, t, v0)\n                     }\n                 }\n-                (ty::TraitDtor(dtor, false), false) => {\n-                    trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n+                (ty::TraitDtor(_, false), false) => {\n+                    trans_struct_drop(bcx, t, v0)\n                 }\n                 (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case"}, {"sha": "171d6961470bf48c9a3a9fb2f4ef7a42ba01fe65", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d07ee255d0587f696155f6095f263b53237c0dca/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07ee255d0587f696155f6095f263b53237c0dca/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=d07ee255d0587f696155f6095f263b53237c0dca", "patch": "@@ -487,11 +487,3 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         format!(\"{}.{}\", did.krate, tstr)\n     }\n }\n-\n-pub fn type_of_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, self_ty: Ty<'tcx>) -> Type {\n-    if type_is_sized(ccx.tcx(), self_ty) {\n-        Type::func(&[type_of(ccx, self_ty).ptr_to()], &Type::void(ccx))\n-    } else {\n-        Type::func(&type_of(ccx, self_ty).field_types(), &Type::void(ccx))\n-    }\n-}"}, {"sha": "cd81f68969377d60d8a794a3866d208e5565daca", "filename": "src/test/run-pass/issue-27997.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d07ee255d0587f696155f6095f263b53237c0dca/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07ee255d0587f696155f6095f263b53237c0dca/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27997.rs?ref=d07ee255d0587f696155f6095f263b53237c0dca", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+use std::sync::atomic::{Ordering, AtomicUsize};\n+\n+use std::mem;\n+struct S<U,V> {\n+    _u: U,\n+    size_of_u: usize,\n+    _v: V,\n+    size_of_v: usize\n+}\n+\n+impl<U, V> S<U, V> {\n+    fn new(u: U, v: V) -> Self {\n+        S {\n+            _u: u,\n+            size_of_u: mem::size_of::<U>(),\n+            _v: v,\n+            size_of_v: mem::size_of::<V>()\n+        }\n+    }\n+}\n+\n+static COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+impl<V, U> Drop for S<U, V> {\n+    fn drop(&mut self) {\n+        assert_eq!(mem::size_of::<U>(), self.size_of_u);\n+        assert_eq!(mem::size_of::<V>(), self.size_of_v);\n+        COUNT.store(COUNT.load(Ordering::SeqCst)+1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(COUNT.load(Ordering::SeqCst), 0);\n+    { S::new(0u8, 1u16); }\n+    assert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}"}]}