{"sha": "d2b9b1de0529efe839a9fa8440d9f0aceed60661", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYjliMWRlMDUyOWVmZTgzOWE5ZmE4NDQwZDlmMGFjZWVkNjA2NjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-02T18:20:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T11:08:00Z"}, "message": "add machine option to validate things on every copy", "tree": {"sha": "9096fe1b7a9926c159cd26acd323aa94a459ce87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9096fe1b7a9926c159cd26acd323aa94a459ce87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b9b1de0529efe839a9fa8440d9f0aceed60661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b9b1de0529efe839a9fa8440d9f0aceed60661", "html_url": "https://github.com/rust-lang/rust/commit/d2b9b1de0529efe839a9fa8440d9f0aceed60661", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b9b1de0529efe839a9fa8440d9f0aceed60661/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13bdc1673dbd6e0d67e2a238f56aafcffd0285b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/13bdc1673dbd6e0d67e2a238f56aafcffd0285b7", "html_url": "https://github.com/rust-lang/rust/commit/13bdc1673dbd6e0d67e2a238f56aafcffd0285b7"}], "stats": {"total": 48, "additions": 39, "deletions": 9}, "files": [{"sha": "d18edf22dc10c29c3a1902a088134497c6a5063d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d2b9b1de0529efe839a9fa8440d9f0aceed60661", "patch": "@@ -1564,6 +1564,7 @@ fn validate_const<'a, 'tcx>(\n                 op,\n                 &mut path,\n                 Some(&mut ref_tracking),\n+                /* const_mode */ true,\n             )?;\n         }\n         Ok(())"}, {"sha": "0c669b9ec31a798012e8ac2790ebf7d03686ac47", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=d2b9b1de0529efe839a9fa8440d9f0aceed60661", "patch": "@@ -274,6 +274,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryKinds = !;\n \n     const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+    const ENFORCE_VALIDITY: bool = false; // for now, we don't\n \n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "f90a7efce47b373fb4250397d673fdbaf5dd4ac1", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=d2b9b1de0529efe839a9fa8440d9f0aceed60661", "patch": "@@ -33,6 +33,9 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The memory kind to use for mutated statics -- or None if those are not supported.\n     const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// Whether to enforce the validity invariant\n+    const ENFORCE_VALIDITY: bool;\n+\n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n     fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;"}, {"sha": "b75ceb61febb7c41337f29adb1ded33e3664745f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d2b9b1de0529efe839a9fa8440d9f0aceed60661", "patch": "@@ -567,6 +567,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n+        // Check that the value actually is okay for that type\n+        if M::ENFORCE_VALIDITY {\n+            // Something changed somewhere, better make sure it matches the type!\n+            let op = OpTy { op: Operand::Immediate(src_val), layout: dest.layout };\n+            self.validate_operand(op, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n         // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n@@ -588,7 +595,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         self.write_value_to_mplace(src_val, dest)\n     }\n \n-    /// Write a value to memory\n+    /// Write a value to memory. This does NOT do validation, so you better had already\n+    /// done that before calling this!\n     fn write_value_to_mplace(\n         &mut self,\n         value: Value,\n@@ -652,12 +660,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n-        let (dest_ptr, dest_align) = self.force_allocation(dest)?.to_scalar_ptr_align();\n+        let dest = self.force_allocation(dest)?;\n+        let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n         self.memory.copy(\n             src_ptr, src_align,\n             dest_ptr, dest_align,\n             src.layout.size, false\n-        )\n+        )?;\n+        if M::ENFORCE_VALIDITY {\n+            // Something changed somewhere, better make sure it matches the type!\n+            self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n+        }\n+        Ok(())\n     }\n \n     /// Make sure that a place is in memory, and return where it is.\n@@ -680,6 +694,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // that has different alignment than the outer field.\n                         let local_layout = self.layout_of_local(frame, local)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        // We don't have to validate as we can assume the local\n+                        // was already valid for its type.\n                         self.write_value_to_mplace(value, ptr)?;\n                         let mplace = ptr.mplace;\n                         // Update the local"}, {"sha": "5c8aeb2d82ae62b2b5c45941d247649f86017b9e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b9b1de0529efe839a9fa8440d9f0aceed60661/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d2b9b1de0529efe839a9fa8440d9f0aceed60661", "patch": "@@ -147,6 +147,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         size: Size,\n         path: &Vec<PathElem>,\n         ty: Ty,\n+        const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate scalar by type: {:#?}, {:#?}, {}\", value, size, ty);\n \n@@ -160,12 +161,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 try_validation!(value.to_char(),\n                     scalar_format(value), path, \"a valid unicode codepoint\");\n             },\n-            ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n-                // Must be scalar bits\n+            ty::Float(_) | ty::Int(_) | ty::Uint(_) if const_mode => {\n+                // Integers/floats in CTFE: Must be scalar bits\n                 try_validation!(value.to_bits(size),\n                     scalar_format(value), path, \"initialized plain bits\");\n             }\n-            ty::RawPtr(_) => {\n+            ty::Float(_) | ty::Int(_) | ty::Uint(_) | ty::RawPtr(_) => {\n                 // Anything but undef goes\n                 try_validation!(value.not_undef(),\n                     scalar_format(value), path, \"a raw pointer\");\n@@ -303,6 +304,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         dest: OpTy<'tcx>,\n         path: &mut Vec<PathElem>,\n         mut ref_tracking: Option<&mut RefTracking<'tcx>>,\n+        const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n \n@@ -387,7 +389,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             value.to_scalar_or_undef(),\n                             dest.layout.size,\n                             &path,\n-                            dest.layout.ty\n+                            dest.layout.ty,\n+                            const_mode,\n                         )?;\n                         // Recursively check *safe* references\n                         if dest.layout.ty.builtin_deref(true).is_some() &&\n@@ -506,7 +509,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             self.validate_operand(\n                                 field.into(),\n                                 path,\n-                                ref_tracking.as_mut().map(|r| &mut **r)\n+                                ref_tracking.as_mut().map(|r| &mut **r),\n+                                const_mode,\n                             )?;\n                             path.truncate(path_len);\n                         }\n@@ -517,7 +521,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 for i in 0..offsets.len() {\n                     let field = self.operand_field(dest, i as u64)?;\n                     path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                    self.validate_operand(field, path, ref_tracking.as_mut().map(|r| &mut **r))?;\n+                    self.validate_operand(\n+                        field,\n+                        path,\n+                        ref_tracking.as_mut().map(|r| &mut **r),\n+                        const_mode,\n+                    )?;\n                     path.truncate(path_len);\n                 }\n             }"}]}