{"sha": "48504507d1811ec8b480c09bc7ac76ede39feaa3", "node_id": "C_kwDOAAsO6NoAKDQ4NTA0NTA3ZDE4MTFlYzhiNDgwYzA5YmM3YWM3NmVkZTM5ZmVhYTM", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-10T13:04:09Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-10T13:04:09Z"}, "message": "Clean up lifetimes in rustdoc syntax highlighting\n\nRemoves a few lifetimes and renames some.", "tree": {"sha": "a86a4710bd59f35cc1f88efdc06b91a09041e43d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a86a4710bd59f35cc1f88efdc06b91a09041e43d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48504507d1811ec8b480c09bc7ac76ede39feaa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48504507d1811ec8b480c09bc7ac76ede39feaa3", "html_url": "https://github.com/rust-lang/rust/commit/48504507d1811ec8b480c09bc7ac76ede39feaa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48504507d1811ec8b480c09bc7ac76ede39feaa3/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc70ff277dda8b7f227208eff789f1f68b6de5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70ff277dda8b7f227208eff789f1f68b6de5a", "html_url": "https://github.com/rust-lang/rust/commit/cbc70ff277dda8b7f227208eff789f1f68b6de5a"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "8a9e6caf611bad111308874cd8bd3d7685cb130d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/48504507d1811ec8b480c09bc7ac76ede39feaa3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48504507d1811ec8b480c09bc7ac76ede39feaa3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=48504507d1811ec8b480c09bc7ac76ede39feaa3", "patch": "@@ -21,15 +21,15 @@ use rustc_span::{BytePos, Span, DUMMY_SP};\n use super::format::{self, Buffer};\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-pub(crate) struct HrefContext<'a, 'b, 'c> {\n-    pub(crate) context: &'a Context<'b>,\n+pub(crate) struct HrefContext<'a, 'tcx> {\n+    pub(crate) context: &'a Context<'tcx>,\n     /// This span contains the current file we're going through.\n     pub(crate) file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n-    pub(crate) root_path: &'c str,\n+    pub(crate) root_path: &'a str,\n     /// This field is used to calculate precise local URLs.\n-    pub(crate) current_href: &'c str,\n+    pub(crate) current_href: String,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n@@ -70,7 +70,7 @@ pub(crate) fn render_source_with_highlighting(\n     src: &str,\n     out: &mut Buffer,\n     line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_, '_>,\n+    href_context: HrefContext<'_, '_>,\n     decoration_info: DecorationInfo,\n     extra: Option<&str>,\n ) {\n@@ -137,7 +137,7 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+struct TokenHandler<'a, 'tcx> {\n     out: &'a mut Buffer,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n@@ -149,11 +149,11 @@ struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     current_class: Option<Class>,\n     /// We need to keep the `Class` for each element because it could contain a `Span` which is\n     /// used to generate links.\n-    pending_elems: Vec<(&'b str, Option<Class>)>,\n-    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+    pending_elems: Vec<(&'a str, Option<Class>)>,\n+    href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -205,7 +205,7 @@ impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     }\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -230,7 +230,7 @@ impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n-    href_context: Option<HrefContext<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n@@ -514,18 +514,18 @@ impl Decorations {\n \n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n-struct Classifier<'a> {\n-    tokens: PeekIter<'a>,\n+struct Classifier<'src> {\n+    tokens: PeekIter<'src>,\n     in_attribute: bool,\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n     byte_pos: u32,\n     file_span: Span,\n-    src: &'a str,\n+    src: &'src str,\n     decorations: Option<Decorations>,\n }\n \n-impl<'a> Classifier<'a> {\n+impl<'src> Classifier<'src> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n     fn new(src: &str, file_span: Span, decoration_info: Option<DecorationInfo>) -> Classifier<'_> {\n@@ -603,7 +603,7 @@ impl<'a> Classifier<'a> {\n     ///\n     /// It returns the token's kind, the token as a string and its byte position in the source\n     /// string.\n-    fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n+    fn next(&mut self) -> Option<(TokenKind, &'src str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n             let before = self.byte_pos;\n             self.byte_pos += text.len() as u32;\n@@ -618,7 +618,7 @@ impl<'a> Classifier<'a> {\n     /// The general structure for this method is to iterate over each token,\n     /// possibly giving it an HTML span with a class specifying what flavor of\n     /// token is used.\n-    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n+    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'src>)) {\n         loop {\n             if let Some(decs) = self.decorations.as_mut() {\n                 let byte_pos = self.byte_pos;\n@@ -666,8 +666,8 @@ impl<'a> Classifier<'a> {\n     fn advance(\n         &mut self,\n         token: TokenKind,\n-        text: &'a str,\n-        sink: &mut dyn FnMut(Highlight<'a>),\n+        text: &'src str,\n+        sink: &mut dyn FnMut(Highlight<'src>),\n         before: u32,\n     ) {\n         let lookahead = self.peek();\n@@ -881,7 +881,7 @@ impl<'a> Classifier<'a> {\n fn enter_span(\n     out: &mut Buffer,\n     klass: Class,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n     string_without_closing_tag(out, \"\", Some(klass), href_context, true).expect(\n         \"internal error: enter_span was called with Some(klass) but did not return a \\\n@@ -914,7 +914,7 @@ fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n@@ -936,7 +936,7 @@ fn string_without_closing_tag<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n@@ -985,7 +985,7 @@ fn string_without_closing_tag<T: Display>(\n                 // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338\n                 match href {\n                     LinkFromSrc::Local(span) => {\n-                        context.href_from_span_relative(*span, href_context.current_href)\n+                        context.href_from_span_relative(*span, &href_context.current_href)\n                     }\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(href_context.root_path))"}, {"sha": "e639fadeb96733ddb5848e6ef9c677614eaaa5b0", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48504507d1811ec8b480c09bc7ac76ede39feaa3/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48504507d1811ec8b480c09bc7ac76ede39feaa3/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=48504507d1811ec8b480c09bc7ac76ede39feaa3", "patch": "@@ -276,7 +276,7 @@ pub(crate) fn print_src(\n     let mut line_numbers = Buffer::empty_from(buf);\n     let extra;\n     line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n-    let current_href = &context\n+    let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n     match source_context {"}]}