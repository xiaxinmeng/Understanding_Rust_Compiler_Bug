{"sha": "97085f9fb0736b322dc216db3655da780b4d8041", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MDg1ZjlmYjA3MzZiMzIyZGMyMTZkYjM2NTVkYTc4MGI0ZDgwNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-01T19:54:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-01T19:54:06Z"}, "message": "Auto merge of #52958 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #52793 (Add test for NLL: unexpected \"free region `` does not outlive\" error )\n - #52799 (Use BitVector for global sets of AttrId)\n - #52809 (Add test for unexpected region for local data ReStatic)\n - #52834 ([NLL] Allow conflicting borrows of promoted length zero arrays)\n - #52835 (Fix Alias intra doc ICE)\n - #52854 (fix memrchr in miri)\n - #52899 (tests/ui: Add missing mips{64} ignores)\n - #52908 (Use SetLenOnDrop in Vec::truncate())\n - #52915 (Don't count MIR locals as borrowed after StorageDead when finding locals live across a yield terminator)\n - #52926 (rustc: Trim down the `rust_2018_idioms` lint group)\n - #52930 (rustc_resolve: record single-segment extern crate import resolutions.)\n - #52939 (Make io::Read::read_to_end consider io::Take::limit)\n - #52942 (Another SmallVec.extend optimization)\n - #52947 (1.27 actually added the `armv5te-unknown-linux-musleabi` target)\n - #52954 (async can begin expressions)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "51ff3c45c1fdf154e186cb1c494a7ac93b94b5bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51ff3c45c1fdf154e186cb1c494a7ac93b94b5bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97085f9fb0736b322dc216db3655da780b4d8041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97085f9fb0736b322dc216db3655da780b4d8041", "html_url": "https://github.com/rust-lang/rust/commit/97085f9fb0736b322dc216db3655da780b4d8041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97085f9fb0736b322dc216db3655da780b4d8041/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4156768aa1f23117903e6954f3e9ba946f49295", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4156768aa1f23117903e6954f3e9ba946f49295", "html_url": "https://github.com/rust-lang/rust/commit/c4156768aa1f23117903e6954f3e9ba946f49295"}, {"sha": "3e7897f773f48ce982cbee6fbfd3118e5648e352", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7897f773f48ce982cbee6fbfd3118e5648e352", "html_url": "https://github.com/rust-lang/rust/commit/3e7897f773f48ce982cbee6fbfd3118e5648e352"}], "stats": {"total": 723, "additions": 512, "deletions": 211}, "files": [{"sha": "e969b91b2b6435dcbc1003bbdc173de9c5912719", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -216,7 +216,7 @@ Language\n \n Compiler\n --------\n-- [Added the `armv5te-unknown-linux-musl` target.][50423]\n+- [Added the `armv5te-unknown-linux-musleabi` target.][50423]\n \n Libraries\n ---------"}, {"sha": "cc913dfbb4b01e140abb47403998f7a65c224f3a", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -690,14 +690,20 @@ impl<T> Vec<T> {\n     /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n+        let current_len = self.len;\n         unsafe {\n+            let mut ptr = self.as_mut_ptr().offset(self.len as isize);\n+            // Set the final length at the end, keeping in mind that\n+            // dropping an element might panic. Works around a missed\n+            // optimization, as seen in the following issue:\n+            // https://github.com/rust-lang/rust/issues/51802\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n             // drop any extra elements\n-            while len < self.len {\n-                // decrement len before the drop_in_place(), so a panic on Drop\n-                // doesn't re-drop the just-failed value.\n-                self.len -= 1;\n-                let len = self.len;\n-                ptr::drop_in_place(self.get_unchecked_mut(len));\n+            for _ in len..current_len {\n+                local_len.decrement_len(1);\n+                ptr = ptr.offset(-1);\n+                ptr::drop_in_place(ptr);\n             }\n         }\n     }\n@@ -1512,6 +1518,11 @@ impl<'a> SetLenOnDrop<'a> {\n     fn increment_len(&mut self, increment: usize) {\n         self.local_len += increment;\n     }\n+\n+    #[inline]\n+    fn decrement_len(&mut self, decrement: usize) {\n+        self.local_len -= decrement;\n+    }\n }\n \n impl<'a> Drop for SetLenOnDrop<'a> {"}, {"sha": "c9d3c7fea9839e1ed3da89ae8b61971ff69c493f", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -100,24 +100,30 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n     // - the first remaining bytes, < 2 word size\n     let len = text.len();\n     let ptr = text.as_ptr();\n-    let usize_bytes = mem::size_of::<usize>();\n+    type Chunk = usize;\n \n-    let mut offset = {\n-        // We call this just to obtain the length of the suffix\n-        let (_, _, suffix) = unsafe { text.align_to::<usize>() };\n-        len - suffix.len()\n+    let (min_aligned_offset, max_aligned_offset) = {\n+        // We call this just to obtain the length of the prefix and suffix.\n+        // In the middle we always process two chunks at once.\n+        let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };\n+        (prefix.len(), len - suffix.len())\n     };\n+\n+    let mut offset = max_aligned_offset;\n     if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n         return Some(offset + index);\n     }\n \n-    // search the body of the text\n+    // search the body of the text, make sure we don't cross min_aligned_offset.\n+    // offset is always aligned, so just testing `>` is sufficient and avoids possible\n+    // overflow.\n     let repeated_x = repeat_byte(x);\n+    let chunk_bytes = mem::size_of::<Chunk>();\n \n-    while offset >= 2 * usize_bytes {\n+    while offset > min_aligned_offset {\n         unsafe {\n-            let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n-            let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n+            let u = *(ptr.offset(offset as isize - 2 * chunk_bytes as isize) as *const Chunk);\n+            let v = *(ptr.offset(offset as isize - chunk_bytes as isize) as *const Chunk);\n \n             // break if there is a matching byte\n             let zu = contains_zero_byte(u ^ repeated_x);\n@@ -126,7 +132,7 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n                 break;\n             }\n         }\n-        offset -= 2 * usize_bytes;\n+        offset -= 2 * chunk_bytes;\n     }\n \n     // find the byte before the point the body loop stopped"}, {"sha": "c178a9063c9acd09fa1131c52e44831ed6e6ed33", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n \n use super::*;\n \n@@ -32,7 +32,7 @@ use super::*;\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector<BasicBlock>,\n+    visited: BitArray<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n }\n \n@@ -42,7 +42,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             mir,\n-            visited: BitVector::new(mir.basic_blocks().len()),\n+            visited: BitArray::new(mir.basic_blocks().len()),\n             worklist,\n         }\n     }\n@@ -104,15 +104,15 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector<BasicBlock>,\n+    visited: BitArray<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir,\n-            visited: BitVector::new(mir.basic_blocks().len()),\n+            visited: BitArray::new(mir.basic_blocks().len()),\n             visit_stack: Vec::new()\n         };\n "}, {"sha": "35184ca6a2559cc3c3f2527db555a3addb414fc3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -45,7 +45,7 @@ use middle::lang_items;\n use mir::interpret::{GlobalId};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use std::iter;\n use std::cmp;\n use std::fmt;\n@@ -3056,7 +3056,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitVector::new(substs_a.types().count());\n+                let mut ty_params = BitArray::new(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {"}, {"sha": "a76f1d50fa7bf89551717ec1eb9164b44837c1f8", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -21,7 +21,7 @@ use libc::c_uint;\n \n use syntax_pos::Pos;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n@@ -64,7 +64,7 @@ pub fn create_mir_scopes(\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitVector::new(mir.source_scopes.len());\n+    let mut has_variables = BitArray::new(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.visibility_scope);\n@@ -81,7 +81,7 @@ pub fn create_mir_scopes(\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n-                  has_variables: &BitVector<SourceScope>,\n+                  has_variables: &BitArray<SourceScope>,\n                   debug_context: &FunctionDebugContextData<'ll>,\n                   scope: SourceScope,\n                   scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {"}, {"sha": "993138aee1cec90e9560c9a5859baec62c96f3bf", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -11,7 +11,7 @@\n //! An analysis to determine which locals require allocas and\n //! which do not.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n+pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitArray<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -54,7 +54,7 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n     fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitVector<mir::Local>,\n+    non_ssa_locals: BitArray<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n@@ -67,7 +67,7 @@ impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n             fx,\n             dominators: fx.mir.dominators(),\n-            non_ssa_locals: BitVector::new(fx.mir.local_decls.len()),\n+            non_ssa_locals: BitArray::new(fx.mir.local_decls.len()),\n             first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n "}, {"sha": "a099cb5c64b211fcf1087717dfe5325db1e15099", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -31,7 +31,7 @@ use syntax::symbol::keywords;\n \n use std::iter;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::codegen_static_initializer;\n@@ -323,7 +323,7 @@ pub fn codegen_mir(\n     debuginfo::start_emitting_source_locations(&fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitVector::new(mir.basic_blocks().len());\n+    let mut visited = BitArray::new(mir.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -417,7 +417,7 @@ fn arg_local_refs(\n     bx: &Builder<'a, 'll, 'tcx>,\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n     scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n-    memory_locals: &BitVector<mir::Local>,\n+    memory_locals: &BitArray<mir::Local>,\n ) -> Vec<LocalRef<'ll, 'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();"}, {"sha": "6e8a45d034250e2d4f7b195aa45c11d564c1561d", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 73, "deletions": 55, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -9,24 +9,74 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n-use std::iter::FromIterator;\n use std::marker::PhantomData;\n \n type Word = u128;\n const WORD_BITS: usize = 128;\n \n-/// A very simple BitVector type.\n+/// A very simple BitArray type.\n+///\n+/// It does not support resizing after creation; use `BitVector` for that.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector<C: Idx> {\n+pub struct BitArray<C: Idx> {\n     data: Vec<Word>,\n     marker: PhantomData<C>,\n }\n \n+#[derive(Clone, Debug, PartialEq)]\n+pub struct BitVector<C: Idx> {\n+    data: BitArray<C>,\n+}\n+\n impl<C: Idx> BitVector<C> {\n+    pub fn grow(&mut self, num_bits: C) {\n+        self.data.grow(num_bits)\n+    }\n+\n+    pub fn new() -> BitVector<C> {\n+        BitVector {\n+            data: BitArray::new(0),\n+        }\n+    }\n+\n+    pub fn with_capacity(bits: usize) -> BitVector<C> {\n+        BitVector {\n+            data: BitArray::new(bits),\n+        }\n+    }\n+\n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn insert(&mut self, bit: C) -> bool {\n+        self.grow(bit);\n+        self.data.insert(bit)\n+    }\n+\n     #[inline]\n-    pub fn new(num_bits: usize) -> BitVector<C> {\n+    pub fn contains(&self, bit: C) -> bool {\n+        let (word, mask) = word_mask(bit);\n+        if let Some(word) = self.data.data.get(word) {\n+            (word & mask) != 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<C: Idx> BitArray<C> {\n+    // Do not make this method public, instead switch your use case to BitVector.\n+    #[inline]\n+    fn grow(&mut self, num_bits: C) {\n         let num_words = words(num_bits);\n-        BitVector {\n+        if self.data.len() <= num_words {\n+            self.data.resize(num_words + 1, 0)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new(num_bits: usize) -> BitArray<C> {\n+        let num_words = words(num_bits);\n+        BitArray {\n             data: vec![0; num_words],\n             marker: PhantomData,\n         }\n@@ -54,7 +104,7 @@ impl<C: Idx> BitVector<C> {\n     ///\n     /// The two vectors must have the same length.\n     #[inline]\n-    pub fn contains_all(&self, other: &BitVector<C>) -> bool {\n+    pub fn contains_all(&self, other: &BitArray<C>) -> bool {\n         assert_eq!(self.data.len(), other.data.len());\n         self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n     }\n@@ -94,7 +144,7 @@ impl<C: Idx> BitVector<C> {\n     }\n \n     #[inline]\n-    pub fn merge(&mut self, all: &BitVector<C>) -> bool {\n+    pub fn merge(&mut self, all: &BitArray<C>) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n@@ -107,18 +157,10 @@ impl<C: Idx> BitVector<C> {\n         changed\n     }\n \n-    #[inline]\n-    pub fn grow(&mut self, num_bits: C) {\n-        let num_words = words(num_bits);\n-        if self.data.len() < num_words {\n-            self.data.resize(num_words, 0)\n-        }\n-    }\n-\n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitVectorIter<'a, C> {\n-        BitVectorIter {\n+    pub fn iter<'a>(&'a self) -> BitIter<'a, C> {\n+        BitIter {\n             iter: self.data.iter(),\n             current: 0,\n             idx: 0,\n@@ -127,14 +169,14 @@ impl<C: Idx> BitVector<C> {\n     }\n }\n \n-pub struct BitVectorIter<'a, C: Idx> {\n+pub struct BitIter<'a, C: Idx> {\n     iter: ::std::slice::Iter<'a, Word>,\n     current: Word,\n     idx: usize,\n     marker: PhantomData<C>\n }\n \n-impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n+impl<'a, C: Idx> Iterator for BitIter<'a, C> {\n     type Item = C;\n     fn next(&mut self) -> Option<C> {\n         while self.current == 0 {\n@@ -163,30 +205,6 @@ impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n     }\n }\n \n-impl<C: Idx> FromIterator<bool> for BitVector<C> {\n-    fn from_iter<I>(iter: I) -> BitVector<C>\n-    where\n-        I: IntoIterator<Item = bool>,\n-    {\n-        let iter = iter.into_iter();\n-        let (len, _) = iter.size_hint();\n-        // Make the minimum length for the bitvector WORD_BITS bits since that's\n-        // the smallest non-zero size anyway.\n-        let len = if len < WORD_BITS { WORD_BITS } else { len };\n-        let mut bv = BitVector::new(len);\n-        for (idx, val) in iter.enumerate() {\n-            if idx > len {\n-                bv.grow(C::new(idx));\n-            }\n-            if val {\n-                bv.insert(C::new(idx));\n-            }\n-        }\n-\n-        bv\n-    }\n-}\n-\n /// A \"bit matrix\" is basically a matrix of booleans represented as\n /// one gigantic bitvector. In other words, it is as if you have\n /// `rows` bitvectors, each of length `columns`.\n@@ -288,9 +306,9 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> BitVectorIter<'a, C> {\n+    pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n         let (start, end) = self.range(row);\n-        BitVectorIter {\n+        BitIter {\n             iter: self.vector[start..end].iter(),\n             current: 0,\n             idx: 0,\n@@ -308,7 +326,7 @@ where\n     C: Idx,\n {\n     columns: usize,\n-    vector: IndexVec<R, BitVector<C>>,\n+    vector: IndexVec<R, BitArray<C>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -323,7 +341,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     fn ensure_row(&mut self, row: R) {\n         let columns = self.columns;\n         self.vector\n-            .ensure_contains_elem(row, || BitVector::new(columns));\n+            .ensure_contains_elem(row, || BitArray::new(columns));\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n@@ -361,7 +379,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &BitVector<C>) -> bool {\n+    pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n         self.ensure_row(into);\n         self.vector[into].merge(from)\n     }\n@@ -388,11 +406,11 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector<C>)> + 'a {\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitArray<C>)> + 'a {\n         self.vector.iter_enumerated()\n     }\n \n-    pub fn row(&self, row: R) -> Option<&BitVector<C>> {\n+    pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n         self.vector.get(row)\n     }\n }\n@@ -412,7 +430,7 @@ fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n \n #[test]\n fn bitvec_iter_works() {\n-    let mut bitvec: BitVector<usize> = BitVector::new(100);\n+    let mut bitvec: BitArray<usize> = BitArray::new(100);\n     bitvec.insert(1);\n     bitvec.insert(10);\n     bitvec.insert(19);\n@@ -430,7 +448,7 @@ fn bitvec_iter_works() {\n \n #[test]\n fn bitvec_iter_works_2() {\n-    let mut bitvec: BitVector<usize> = BitVector::new(319);\n+    let mut bitvec: BitArray<usize> = BitArray::new(319);\n     bitvec.insert(0);\n     bitvec.insert(127);\n     bitvec.insert(191);\n@@ -441,8 +459,8 @@ fn bitvec_iter_works_2() {\n \n #[test]\n fn union_two_vecs() {\n-    let mut vec1: BitVector<usize> = BitVector::new(65);\n-    let mut vec2: BitVector<usize> = BitVector::new(65);\n+    let mut vec1: BitArray<usize> = BitArray::new(65);\n+    let mut vec2: BitArray<usize> = BitArray::new(65);\n     assert!(vec1.insert(3));\n     assert!(!vec1.insert(3));\n     assert!(vec2.insert(5));\n@@ -458,7 +476,7 @@ fn union_two_vecs() {\n \n #[test]\n fn grow() {\n-    let mut vec1: BitVector<usize> = BitVector::new(65);\n+    let mut vec1: BitVector<usize> = BitVector::with_capacity(65);\n     for index in 0..65 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));"}, {"sha": "cf9403db658f4fa9fcb5a6dcb4cec900de1b5b76", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -30,7 +30,7 @@\n //! the field `next_edge`). Each of those fields is an array that should\n //! be indexed by the direction (see the type `Direction`).\n \n-use bitvec::BitVector;\n+use bitvec::BitArray;\n use std::fmt::Debug;\n use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n@@ -266,7 +266,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         direction: Direction,\n         entry_node: NodeIndex,\n     ) -> Vec<NodeIndex> {\n-        let mut visited = BitVector::new(self.len_nodes());\n+        let mut visited = BitArray::new(self.len_nodes());\n         let mut stack = vec![];\n         let mut result = Vec::with_capacity(self.len_nodes());\n         let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n@@ -348,7 +348,7 @@ where\n {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitVector<usize>,\n+    visited: BitArray<usize>,\n     direction: Direction,\n }\n \n@@ -358,7 +358,7 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n         start_node: NodeIndex,\n         direction: Direction,\n     ) -> Self {\n-        let mut visited = BitVector::new(graph.len_nodes());\n+        let mut visited = BitArray::new(graph.len_nodes());\n         visited.insert(start_node.node_id());\n         DepthFirstTraversal {\n             graph,"}, {"sha": "76b01beb4bad3dbcd524fb2c07bee6ccb210f434", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -169,18 +169,11 @@ impl<A: Array> FromIterator<A::Element> for SmallVec<A> {\n \n impl<A: Array> Extend<A::Element> for SmallVec<A> {\n     fn extend<I: IntoIterator<Item=A::Element>>(&mut self, iter: I) {\n-        if self.is_array() {\n-            let iter = iter.into_iter();\n-            self.reserve(iter.size_hint().0);\n-\n-            for el in iter {\n-                self.push(el);\n-            }\n-        } else {\n-            match self.0 {\n-                AccumulateVec::Heap(ref mut vec) => vec.extend(iter),\n-                _ => unreachable!()\n-            }\n+        let iter = iter.into_iter();\n+        self.reserve(iter.size_hint().0);\n+        match self.0 {\n+            AccumulateVec::Heap(ref mut vec) => vec.extend(iter),\n+            _ => iter.for_each(|el| self.push(el))\n         }\n     }\n }"}, {"sha": "b92ac0ff57bd88478b5fb40c95520c55e884173a", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -45,7 +45,6 @@ use rustc::lint::{LateContext, LateLintPass, LintPass, LintArray};\n use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n     ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-    MACRO_USE_EXTERN_CRATE,\n     ELIDED_LIFETIMES_IN_PATHS,\n     parser::QUESTION_MARK_MACRO_SEP\n };\n@@ -195,11 +194,18 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     add_lint_group!(sess,\n                     \"rust_2018_idioms\",\n                     BARE_TRAIT_OBJECTS,\n-                    UNREACHABLE_PUB,\n                     UNUSED_EXTERN_CRATES,\n-                    MACRO_USE_EXTERN_CRATE,\n-                    ELIDED_LIFETIMES_IN_PATHS,\n-                    ELLIPSIS_INCLUSIVE_RANGE_PATTERNS);\n+                    ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                    ELIDED_LIFETIMES_IN_PATHS\n+\n+                    // FIXME(#52665, #47816) not always applicable and not all\n+                    // macros are ready for this yet.\n+                    // UNREACHABLE_PUB,\n+\n+                    // FIXME macro crates are not up for this yet, too much\n+                    // breakage is seen if we try to encourage this lint.\n+                    // MACRO_USE_EXTERN_CRATE,\n+                    );\n \n     // Guidelines for creating a future incompatibility lint:\n     //"}, {"sha": "640ae31d45b349db89028614c438daca19eca80e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -329,6 +329,13 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n         }\n         (Place::Promoted(p1), Place::Promoted(p2)) => {\n             if p1.0 == p2.0 {\n+                if let ty::TyArray(_, size) = p1.1.sty {\n+                    if size.unwrap_usize(tcx) == 0 {\n+                        // Ignore conflicts with promoted [T; 0].\n+                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                        return Overlap::Disjoint;\n+                    }\n+                }\n                 // the same promoted - base case, equal\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n                 Overlap::EqualOrDisjoint"}, {"sha": "6b6ec749bcbe6efd1124d6f529264564a4aab661", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -18,7 +18,7 @@ use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::scope::{CachedBlock, DropKind};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::hir;\n@@ -496,7 +496,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitVector<usize>,\n+        variants: BitArray<usize>,\n     },\n \n     // test the branches of enum"}, {"sha": "7106e02284da3888cd219b61d17fe23ce5076bb6", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -19,7 +19,7 @@ use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n                         adt_def: adt_def.clone(),\n-                        variants: BitVector::new(adt_def.variants.len()),\n+                        variants: BitArray::new(adt_def.variants.len()),\n                     },\n                 }\n             }\n@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitVector<usize>)\n+                                        variants: &mut BitArray<usize>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {"}, {"sha": "c8c41c13b0fbb684fbaa8967689f6fb12f9a3508", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -15,9 +15,9 @@ use rustc::mir::visit::Visitor;\n use dataflow::BitDenotation;\n \n /// This calculates if any part of a MIR local could have previously been borrowed.\n-/// This means that once a local has been borrowed, its bit will always be set\n-/// from that point and onwards, even if the borrow ends. You could also think of this\n-/// as computing the lifetimes of infinite borrows.\n+/// This means that once a local has been borrowed, its bit will be set\n+/// from that point and onwards, until we see a StorageDead statement for the local,\n+/// at which points there is no memory associated with the local, so it cannot be borrowed.\n /// This is used to compute which locals are live during a yield expression for\n /// immovable generators.\n #[derive(Copy, Clone)]\n@@ -50,9 +50,17 @@ impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<Local>,\n                         loc: Location) {\n+        let stmt = &self.mir[loc.block].statements[loc.statement_index];\n+\n         BorrowedLocalsVisitor {\n             sets,\n-        }.visit_statement(loc.block, &self.mir[loc.block].statements[loc.statement_index], loc);\n+        }.visit_statement(loc.block, stmt, loc);\n+\n+        // StorageDead invalidates all borrows and raw pointers to a local\n+        match stmt.kind {\n+            StatementKind::StorageDead(l) => sets.kill(&l),\n+            _ => (),\n+        }\n     }\n \n     fn terminator_effect(&self,"}, {"sha": "6283ee9cfe648ed9f60ac54bad1df188722ba6c8", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> InliningMap<'tcx> {\n         InliningMap {\n             index: FxHashMap(),\n             targets: Vec::new(),\n-            inlines: BitVector::new(1024),\n+            inlines: BitVector::with_capacity(1024),\n         }\n     }\n "}, {"sha": "a3647edd155d3d71b105891b4e16b16d7400a683", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -433,7 +433,8 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n                 // suspension points. However for immovable generators we need to account for\n-                // borrows, so we conseratively assume that all borrowed locals live forever.\n+                // borrows, so we conseratively assume that all borrowed locals are live until\n+                // we find a StorageDead statement referencing the locals.\n                 // To do this we just union our `liveness` result with `borrowed_locals`, which\n                 // contains all the locals which has been borrowed before this suspension point.\n                 // If a borrow is converted to a raw reference, we must also assume that it lives"}, {"sha": "85115427edae9dc00d0cfd7bf8e4f90f3ad79eb5", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -14,7 +14,7 @@ use rustc::hir;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Traverse the MIR manually so we can account for the effects of\n         // inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n-        let mut visited = BitVector::new(callee_mir.basic_blocks().len());\n+        let mut visited = BitArray::new(callee_mir.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) { continue; }\n             let blk = &callee_mir.basic_blocks()[bb];"}, {"sha": "208679d2aa08adf3aa50a4c66c13b475c27ed8ea", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -14,7 +14,7 @@\n //! The Qualif flags below can be used to also provide better\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::FxHashSet;\n@@ -116,7 +116,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     local_qualif: IndexVec<Local, Option<Qualif>>,\n     qualif: Qualif,\n-    const_fn_arg_vars: BitVector<Local>,\n+    const_fn_arg_vars: BitArray<Local>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env,\n             local_qualif,\n             qualif: Qualif::empty(),\n-            const_fn_arg_vars: BitVector::new(mir.local_decls.len()),\n+            const_fn_arg_vars: BitArray::new(mir.local_decls.len()),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -284,7 +284,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n         let mir = self.mir;\n \n-        let mut seen_blocks = BitVector::new(mir.basic_blocks().len());\n+        let mut seen_blocks = BitArray::new(mir.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());"}, {"sha": "04a7a81eb126fc7f6e492ec6887e613fc678818c", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n \n@@ -45,7 +45,7 @@ impl RemoveNoopLandingPads {\n         &self,\n         bb: BasicBlock,\n         mir: &Mir,\n-        nop_landing_pads: &BitVector<BasicBlock>,\n+        nop_landing_pads: &BitArray<BasicBlock>,\n     ) -> bool {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n@@ -111,7 +111,7 @@ impl RemoveNoopLandingPads {\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitVector::new(mir.basic_blocks().len());\n+        let mut nop_landing_pads = BitArray::new(mir.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B."}, {"sha": "6e8471c672934e127bac884eeefcc7066bd9d584", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -37,7 +37,7 @@\n //! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n //! return.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n@@ -249,7 +249,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n }\n \n pub fn remove_dead_blocks(mir: &mut Mir) {\n-    let mut seen = BitVector::new(mir.basic_blocks().len());\n+    let mut seen = BitArray::new(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());\n     }\n@@ -285,7 +285,7 @@ impl MirPass for SimplifyLocals {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n+        let mut marker = DeclMarker { locals: BitArray::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n         marker.locals.insert(RETURN_PLACE);\n@@ -310,7 +310,7 @@ impl MirPass for SimplifyLocals {\n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n fn make_local_map<'tcx, V>(\n     vec: &mut IndexVec<Local, V>,\n-    mask: BitVector<Local>,\n+    mask: BitArray<Local>,\n ) -> IndexVec<Local, Option<Local>> {\n     let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n     let mut used = Local::new(0);\n@@ -326,7 +326,7 @@ fn make_local_map<'tcx, V>(\n }\n \n struct DeclMarker {\n-    pub locals: BitVector<Local>,\n+    pub locals: BitArray<Local>,\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {"}, {"sha": "b6ad2f316a0a257fe8c45114cc153ff486611274", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -691,6 +691,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             expansion: directive.expansion,\n                         });\n                         let _ = self.try_define(directive.parent, target, TypeNS, binding);\n+                        let import = self.import_map.entry(directive.id).or_default();\n+                        import[TypeNS] = Some(PathResolution::new(binding.def()));\n                         return None;\n                     }\n                 }"}, {"sha": "45566230fdaae29cdcb5f88a40f229779756bab8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -1194,7 +1194,8 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n         })?;\n         match ty.def {\n             Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n-                let item = cx.tcx.inherent_impls(did).iter()\n+                let item = cx.tcx.inherent_impls(did)\n+                                 .iter()\n                                  .flat_map(|imp| cx.tcx.associated_items(*imp))\n                                  .find(|item| item.ident.name == item_name);\n                 if let Some(item) = item {\n@@ -1205,26 +1206,29 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n                     };\n                     Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n                 } else {\n-                    let is_enum = match ty.def {\n-                        Def::Enum(_) => true,\n-                        _ => false,\n-                    };\n-                    let elem = if is_enum {\n-                        cx.tcx.adt_def(did).all_fields().find(|item| item.ident.name == item_name)\n-                    } else {\n-                        cx.tcx.adt_def(did)\n-                              .non_enum_variant()\n-                              .fields\n-                              .iter()\n-                              .find(|item| item.ident.name == item_name)\n-                    };\n-                    if let Some(item) = elem {\n-                        Ok((ty.def,\n-                            Some(format!(\"{}.{}\",\n-                                         if is_enum { \"variant\" } else { \"structfield\" },\n-                                         item.ident))))\n-                    } else {\n-                        Err(())\n+                    match cx.tcx.type_of(did).sty {\n+                        ty::TyAdt(def, _) => {\n+                            if let Some(item) = if def.is_enum() {\n+                                def.all_fields().find(|item| item.ident.name == item_name)\n+                            } else {\n+                                def.non_enum_variant()\n+                                   .fields\n+                                   .iter()\n+                                   .find(|item| item.ident.name == item_name)\n+                            } {\n+                                Ok((ty.def,\n+                                    Some(format!(\"{}.{}\",\n+                                                 if def.is_enum() {\n+                                                     \"variant\"\n+                                                 } else {\n+                                                     \"structfield\"\n+                                                 },\n+                                                 item.ident))))\n+                            } else {\n+                                Err(())\n+                            }\n+                        }\n+                        _ => Err(()),\n                     }\n                 }\n             }"}, {"sha": "287913d2cc9b88f7e06ac25b0eaa6173949c725d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -105,8 +105,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n     }\n \n     pub fn visit_variant_data(&mut self, item: &hir::Item,\n-                            name: ast::Name, sd: &hir::VariantData,\n-                            generics: &hir::Generics) -> Struct {\n+                              name: ast::Name, sd: &hir::VariantData,\n+                              generics: &hir::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {"}, {"sha": "b83f3fbe7a59cd94673791f7d3af7ec2bd3836fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -354,19 +354,26 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // avoid paying to allocate and zero a huge chunk of memory if the reader only\n // has 4 bytes while still making large reads if the reader does have a ton\n // of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n-// time is 4,500 times (!) slower than this if the reader has a very small\n-// amount of data to return.\n+// time is 4,500 times (!) slower than a default reservation size of 32 if the\n+// reader has a very small amount of data to return.\n //\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n+    read_to_end_with_reservation(r, buf, 32)\n+}\n+\n+fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n+                                                  buf: &mut Vec<u8>,\n+                                                  reservation_size: usize) -> Result<usize>\n+{\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(32);\n+                g.buf.reserve(reservation_size);\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -1899,6 +1906,12 @@ impl<T: Read> Read for Take<T> {\n     unsafe fn initializer(&self) -> Initializer {\n         self.inner.initializer()\n     }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n+        let reservation_size = cmp::min(self.limit, 32) as usize;\n+\n+        read_to_end_with_reservation(self, buf, reservation_size)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "28c1e4324de7a3070c90f2c4cce5a694dc3ce2e8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -23,6 +23,7 @@ use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n use rustc_data_structures::indexed_vec;\n+use rustc_data_structures::indexed_vec::Idx;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n@@ -1910,9 +1911,18 @@ pub enum AttrStyle {\n     Inner,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialOrd, Ord, Copy)]\n pub struct AttrId(pub usize);\n \n+impl Idx for AttrId {\n+    fn new(idx: usize) -> Self {\n+        AttrId(idx)\n+    }\n+    fn index(self) -> usize {\n+        self.0\n+    }\n+}\n+\n /// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "7fbc5d4c41a50929331da18fe4a386efb7c49cb5", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -41,51 +41,27 @@ use std::iter;\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let mut slot = globals.used_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        if slot.len() <= idx {\n-            slot.resize(idx + 1, 0);\n-        }\n-        slot[idx] |= 1 << shift;\n+        globals.used_attrs.lock().insert(attr.id);\n     });\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let slot = globals.used_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        slot.get(idx).map(|bits| bits & (1 << shift) != 0)\n-            .unwrap_or(false)\n+        globals.used_attrs.lock().contains(attr.id)\n     })\n }\n \n pub fn mark_known(attr: &Attribute) {\n     debug!(\"Marking {:?} as known.\", attr);\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let mut slot = globals.known_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        if slot.len() <= idx {\n-            slot.resize(idx + 1, 0);\n-        }\n-        slot[idx] |= 1 << shift;\n+        globals.known_attrs.lock().insert(attr.id);\n     });\n }\n \n pub fn is_known(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let slot = globals.known_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        slot.get(idx).map(|bits| bits & (1 << shift) != 0)\n-            .unwrap_or(false)\n+        globals.known_attrs.lock().contains(attr.id)\n     })\n }\n "}, {"sha": "0c105865e0c2e13e3c916d8c1a7f0b9af7d55d8f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -43,6 +43,8 @@ extern crate rustc_target;\n extern crate serialize as rustc_serialize; // used by deriving\n \n use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::bitvec::BitVector;\n+use ast::AttrId;\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n@@ -75,16 +77,18 @@ macro_rules! unwrap_or {\n }\n \n pub struct Globals {\n-    used_attrs: Lock<Vec<u64>>,\n-    known_attrs: Lock<Vec<u64>>,\n+    used_attrs: Lock<BitVector<AttrId>>,\n+    known_attrs: Lock<BitVector<AttrId>>,\n     syntax_pos_globals: syntax_pos::Globals,\n }\n \n impl Globals {\n     fn new() -> Globals {\n         Globals {\n-            used_attrs: Lock::new(Vec::new()),\n-            known_attrs: Lock::new(Vec::new()),\n+            // We have no idea how many attributes their will be, so just\n+            // initiate the vectors with 0 bits. We'll grow them as necessary.\n+            used_attrs: Lock::new(BitVector::new()),\n+            known_attrs: Lock::new(BitVector::new()),\n             syntax_pos_globals: syntax_pos::Globals::new(),\n         }\n     }"}, {"sha": "c449cc0a6525a9bdcb41136908f536706311a421", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -104,6 +104,7 @@ pub(crate) fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n+        keywords::Async.name(),\n         keywords::Do.name(),\n         keywords::Box.name(),\n         keywords::Break.name(),"}, {"sha": "a73dd077cea11cb3fec6062864f98f8eb6958ddf", "filename": "src/test/codegen/vec-clear.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-clear.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @vec_clear\n+#[no_mangle]\n+pub fn vec_clear(x: &mut Vec<u32>) {\n+    // CHECK-NOT: load\n+    // CHECK-NOT: icmp\n+    x.clear()\n+}"}, {"sha": "68d1ef8d776aabf13d5fa8723b6c5716539e85a9", "filename": "src/test/compile-fail/auxiliary/issue-52489.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-52489.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-52489.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-52489.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+#![unstable(feature = \"issue_52489_unstable\", issue = \"0\")]\n+#![feature(staged_api)]"}, {"sha": "c43cc12ca0229d187c51a91061a8189e8b9c6d54", "filename": "src/test/compile-fail/issue-52489.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcompile-fail%2Fissue-52489.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fcompile-fail%2Fissue-52489.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52489.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+// aux-build:issue-52489.rs\n+\n+use issue_52489;\n+//~^ ERROR use of unstable library feature 'issue_52489_unstable'\n+\n+fn main() {}"}, {"sha": "3042061226b39c6677c3e9a23c4d2e2c7228bb98", "filename": "src/test/run-pass/generator/yield-in-initializer.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-initializer.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    static || {\n+        loop {\n+            // Test that `opt` is not live across the yield, even when borrowed in a loop\n+            // See https://github.com/rust-lang/rust/issues/52792\n+            let opt = {\n+                yield;\n+                true\n+            };\n+            &opt;\n+        }\n+    };\n+}"}, {"sha": "a459ab5dd2bea058b2079b2100caf526f97c59db", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub type TypeAlias = usize;\n+\n+/// [broken cross-reference](TypeAlias::hoge) //~ ERROR\n+pub fn some_public_item() {}"}, {"sha": "231963976ea75958bb59f9d2b9801c0f07b738fb", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,13 @@\n+error: `[TypeAlias::hoge]` cannot be resolved, ignoring it...\n+  --> $DIR/intra-doc-alias-ice.rs:15:30\n+   |\n+15 | /// [broken cross-reference](TypeAlias::hoge) //~ ERROR\n+   |                              ^^^^^^^^^^^^^^^ cannot be resolved, ignoring\n+   |\n+note: lint level defined here\n+  --> $DIR/intra-doc-alias-ice.rs:11:9\n+   |\n+11 | #![deny(intra_doc_link_resolution_failure)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n+"}, {"sha": "45b0c84275be46ef203595a015511bd35870a775", "filename": "src/test/ui/asm-out-assign-imm.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -1,5 +1,5 @@\n error[E0384]: cannot assign twice to immutable variable `x`\n-  --> $DIR/asm-out-assign-imm.rs:33:9\n+  --> $DIR/asm-out-assign-imm.rs:34:9\n    |\n LL |     let x: isize;\n    |         - consider changing this to `mut x`"}, {"sha": "73143f1154631be50106dbf82ee28d79e985a0f7", "filename": "src/test/ui/asm-out-assign-imm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm-out-assign-imm.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -16,6 +16,7 @@\n // ignore-sparc\n // ignore-sparc64\n // ignore-mips\n+// ignore-mips64\n \n #![feature(asm)]\n "}, {"sha": "83cb8092e16a29e7174f5e24a616e8bbfa610ba6", "filename": "src/test/ui/asm-out-assign-imm.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasm-out-assign-imm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm-out-assign-imm.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -1,5 +1,5 @@\n error[E0384]: cannot assign twice to immutable variable `x`\n-  --> $DIR/asm-out-assign-imm.rs:33:9\n+  --> $DIR/asm-out-assign-imm.rs:34:9\n    |\n LL |     x = 1;\n    |     ----- first assignment to `x`"}, {"sha": "d6959f9ddd805e9b7491fffb79d5e48f3e58383c", "filename": "src/test/ui/async-matches-expr.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasync-matches-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fasync-matches-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-matches-expr.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro)]\n+\n+macro_rules! match_expr {\n+    ($x:expr) => {}\n+}\n+\n+fn main() {\n+    match_expr!(async {});\n+    match_expr!(async || {});\n+}"}, {"sha": "e4e97c58d8aa3f1703bcfd3e8015123b5b180bfd", "filename": "src/test/ui/issue-49579.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49579.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// compile-pass\n+\n+#![feature(nll)]\n+\n+fn fibs(n: u32) -> impl Iterator<Item=u128> {\n+    (0 .. n)\n+    .scan((0, 1), |st, _| {\n+        *st = (st.1, st.0 + st.1);\n+        Some(*st)\n+    })\n+    .map(&|(f, _)| f)\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", fibs(10).collect::<Vec<_>>());\n+}"}, {"sha": "59345754e9f59284539b4eba2d035a803ea50807", "filename": "src/test/ui/issue-49824.nll.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49824.nll.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,20 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-49824.rs:22:9\n+   |\n+LL |         || {\n+   |    _____-\n+   |   |_____|\n+   |  ||\n+LL |  ||         || {\n+   |  ||_________^\n+LL | |||             let _y = &mut x;\n+LL | |||         }\n+   | |||_________^ requires that `'1` must outlive `'2`\n+LL |  ||     };\n+   |  ||     -\n+   |  ||_____|\n+   |  |______lifetime `'1` represents the closure body\n+   |         lifetime `'2` appears in return type\n+\n+error: aborting due to previous error\n+"}, {"sha": "1f3e575288427ed8b53fc963a75e1676b8951399", "filename": "src/test/ui/issue-49824.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49824.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// This test checks that a failure occurs with NLL but does not fail with the\n+// legacy AST output. Check issue-49824.nll.stderr for expected compilation error\n+// output under NLL and #49824 for more information.\n+\n+#[rustc_error]\n+fn main() {\n+    //~^ compilation successful\n+    let mut x = 0;\n+    || {\n+        || {\n+            let _y = &mut x;\n+        }\n+    };\n+}"}, {"sha": "b6cafe5e9e9941bbd187579b426413cbd89eb0cc", "filename": "src/test/ui/issue-49824.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fissue-49824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49824.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,14 @@\n+error: compilation successful\n+  --> $DIR/issue-49824.rs:18:1\n+   |\n+LL | / fn main() {\n+LL | |     //~^ compilation successful\n+LL | |     let mut x = 0;\n+LL | |     || {\n+...  |\n+LL | |     };\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "be3855696127158d2ed259e7b81218661693e801", "filename": "src/test/ui/nll/promotable-mutable-zst-doesnt-conflict.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fnll%2Fpromotable-mutable-zst-doesnt-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Fnll%2Fpromotable-mutable-zst-doesnt-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromotable-mutable-zst-doesnt-conflict.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that mutable promoted length zero arrays don't check for conflicting\n+// access\n+\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub fn main() {\n+    let mut x: Vec<&[i32; 0]> = Vec::new();\n+    for i in 0..10 {\n+        x.push(&[]);\n+    }\n+}"}, {"sha": "f50419434ae1ddfa518d5ef64f49bad26d7ad865", "filename": "src/test/ui/rust-2018/macro-use-warned-against.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -12,7 +12,7 @@\n // aux-build:macro-use-warned-against2.rs\n // compile-pass\n \n-#![warn(rust_2018_idioms, unused)]\n+#![warn(macro_use_extern_crate, unused)]\n #![feature(use_extern_macros)]\n \n #[macro_use] //~ WARN should be replaced at use sites with a `use` statement"}, {"sha": "7af404fab790e432ac20cee4d7e1637fe92a9124", "filename": "src/test/ui/rust-2018/macro-use-warned-against.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -7,9 +7,8 @@ LL | #[macro_use] //~ WARN should be replaced at use sites with a `use` statemen\n note: lint level defined here\n   --> $DIR/macro-use-warned-against.rs:15:9\n    |\n-LL | #![warn(rust_2018_idioms, unused)]\n-   |         ^^^^^^^^^^^^^^^^\n-   = note: #[warn(macro_use_extern_crate)] implied by #[warn(rust_2018_idioms)]\n+LL | #![warn(macro_use_extern_crate, unused)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused `#[macro_use]` import\n   --> $DIR/macro-use-warned-against.rs:20:1\n@@ -18,9 +17,9 @@ LL | #[macro_use] //~ WARN unused `#[macro_use]`\n    | ^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/macro-use-warned-against.rs:15:27\n+  --> $DIR/macro-use-warned-against.rs:15:33\n    |\n-LL | #![warn(rust_2018_idioms, unused)]\n-   |                           ^^^^^^\n+LL | #![warn(macro_use_extern_crate, unused)]\n+   |                                 ^^^^^^\n    = note: #[warn(unused_imports)] implied by #[warn(unused)]\n "}, {"sha": "c2dc927c4b52461eb9e13af807b00bb5f2ed036d", "filename": "src/test/ui/target-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -12,6 +12,8 @@\n // ignore-aarch64\n // ignore-wasm\n // ignore-emscripten\n+// ignore-mips\n+// ignore-mips64\n // gate-test-sse4a_target_feature\n // gate-test-powerpc_target_feature\n // gate-test-avx512_target_feature"}, {"sha": "24141d0064fb0f2c0cf92dd52a710ad22bb54785", "filename": "src/test/ui/target-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable (see issue #44839)\n-  --> $DIR/target-feature-gate.rs:26:18\n+  --> $DIR/target-feature-gate.rs:28:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}, {"sha": "fe611141379c49f746cd368bc4a6af9389c51d1b", "filename": "src/test/ui/target-feature-wrong.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.rs?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -13,6 +13,7 @@\n // ignore-wasm\n // ignore-emscripten\n // ignore-mips\n+// ignore-mips64\n // ignore-powerpc\n // ignore-powerpc64\n // ignore-powerpc64le"}, {"sha": "21c73b7ddbff0ed31faf0a6cdf786abed298332c", "filename": "src/test/ui/target-feature-wrong.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97085f9fb0736b322dc216db3655da780b4d8041/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr?ref=97085f9fb0736b322dc216db3655da780b4d8041", "patch": "@@ -1,35 +1,35 @@\n error: #[target_feature] attribute must be of the form #[target_feature(..)]\n-  --> $DIR/target-feature-wrong.rs:25:1\n+  --> $DIR/target-feature-wrong.rs:26:1\n    |\n LL | #[target_feature = \"+sse2\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the feature named `foo` is not valid for this target\n-  --> $DIR/target-feature-wrong.rs:27:18\n+  --> $DIR/target-feature-wrong.rs:28:18\n    |\n LL | #[target_feature(enable = \"foo\")]\n    |                  ^^^^^^^^^^^^^^\n \n error: #[target_feature(..)] only accepts sub-keys of `enable` currently\n-  --> $DIR/target-feature-wrong.rs:29:18\n+  --> $DIR/target-feature-wrong.rs:30:18\n    |\n LL | #[target_feature(bar)]\n    |                  ^^^\n \n error: #[target_feature(..)] only accepts sub-keys of `enable` currently\n-  --> $DIR/target-feature-wrong.rs:31:18\n+  --> $DIR/target-feature-wrong.rs:32:18\n    |\n LL | #[target_feature(disable = \"baz\")]\n    |                  ^^^^^^^^^^^^^^^\n \n error: #[target_feature(..)] can only be applied to `unsafe` function\n-  --> $DIR/target-feature-wrong.rs:35:1\n+  --> $DIR/target-feature-wrong.rs:36:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: attribute should be applied to a function\n-  --> $DIR/target-feature-wrong.rs:39:1\n+  --> $DIR/target-feature-wrong.rs:40:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -38,7 +38,7 @@ LL | mod another {}\n    | -------------- not a function\n \n error: cannot use #[inline(always)] with #[target_feature]\n-  --> $DIR/target-feature-wrong.rs:43:1\n+  --> $DIR/target-feature-wrong.rs:44:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^"}]}