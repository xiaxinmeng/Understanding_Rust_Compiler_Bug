{"sha": "73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "node_id": "C_kwDOAAsO6NoAKDczZTlmMzdlYWEwNWZiZjJiYjc2NTdkNmI4MGZlMWFmZDBhNmQ0NDU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-08T18:32:51Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-30T17:04:37Z"}, "message": "Encode consts in metadata main loop.", "tree": {"sha": "1bace7157de29c0a21fa4a78bd0a1ea9980d368d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bace7157de29c0a21fa4a78bd0a1ea9980d368d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "html_url": "https://github.com/rust-lang/rust/commit/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45ad22be8f11dba54d1239d2cf25b71e71177b28", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ad22be8f11dba54d1239d2cf25b71e71177b28", "html_url": "https://github.com/rust-lang/rust/commit/45ad22be8f11dba54d1239d2cf25b71e71177b28"}], "stats": {"total": 83, "additions": 51, "deletions": 32}, "files": [{"sha": "b4a30245b5ecf5c02ddd0df93ed49192efe36ecf", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "patch": "@@ -1068,6 +1068,41 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n     }\n }\n \n+fn should_encode_const(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Const | DefKind::AssocConst | DefKind::AnonConst => true,\n+\n+        DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Ctor(..)\n+        | DefKind::Field\n+        | DefKind::Fn\n+        | DefKind::Static(..)\n+        | DefKind::TyAlias\n+        | DefKind::OpaqueTy\n+        | DefKind::ForeignTy\n+        | DefKind::Impl\n+        | DefKind::AssocFn\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ConstParam\n+        | DefKind::InlineConst\n+        | DefKind::AssocTy\n+        | DefKind::TyParam\n+        | DefKind::Trait\n+        | DefKind::TraitAlias\n+        | DefKind::Mod\n+        | DefKind::ForeignMod\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let mut attrs = self\n@@ -1093,7 +1128,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set(def_id.index, def_kind);\n-            record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n+            let def_span = tcx.def_span(local_id);\n+            record!(self.tables.def_span[def_id] <- def_span);\n             self.encode_attrs(local_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if let Some(ident_span) = tcx.def_ident_span(def_id) {\n@@ -1127,6 +1163,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if should_encode_type(tcx, local_id, def_kind) {\n                 record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n             }\n+            if should_encode_const(def_kind) && tcx.is_mir_available(def_id) {\n+                let qualifs = tcx.at(def_span).mir_const_qualif(def_id);\n+                record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n+                let body_id = tcx.hir().maybe_body_owned_by(local_id);\n+                if let Some(body_id) = body_id {\n+                    let const_data = self.encode_rendered_const_for_body(body_id);\n+                    record!(self.tables.rendered_const[def_id] <- const_data);\n+                }\n+            }\n             if let DefKind::TyParam | DefKind::ConstParam = def_kind {\n                 if let Some(default) = self.tcx.object_lifetime_default(def_id) {\n                     record!(self.tables.object_lifetime_default[def_id] <- default);\n@@ -1296,14 +1341,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match trait_item.kind {\n             ty::AssocKind::Const => {\n-                let rendered = rustc_hir_pretty::to_string(\n-                    &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n-                    |s| s.print_trait_item(ast_item),\n-                );\n-\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(ty::AssocItemContainer::TraitContainer));\n-                record!(self.tables.mir_const_qualif[def_id] <- mir::ConstQualifs::default());\n-                record!(self.tables.rendered_const[def_id] <- rendered);\n+                let container = trait_item.container;\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(container));\n             }\n             ty::AssocKind::Fn => {\n                 let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n@@ -1342,16 +1381,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match impl_item.kind {\n             ty::AssocKind::Const => {\n-                if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n-                    let const_data = self.encode_rendered_const_for_body(body_id);\n-\n-                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(ty::AssocItemContainer::ImplContainer));\n-                    record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n-                    record!(self.tables.rendered_const[def_id] <- const_data);\n-                } else {\n-                    bug!()\n-                }\n+                let container = impl_item.container;\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(container));\n             }\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n@@ -1487,13 +1518,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let entry_kind = match item.kind {\n             hir::ItemKind::Static(..) => EntryKind::Static,\n-            hir::ItemKind::Const(_, body_id) => {\n-                let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n-                let const_data = self.encode_rendered_const_for_body(body_id);\n-                record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n-                record!(self.tables.rendered_const[def_id] <- const_data);\n-                EntryKind::Const\n-            }\n+            hir::ItemKind::Const(..) => EntryKind::Const,\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n@@ -1662,13 +1687,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n         let def_id = self.tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let body_id = self.tcx.hir().body_owned_by(def_id);\n-        let const_data = self.encode_rendered_const_for_body(body_id);\n-        let qualifs = self.tcx.mir_const_qualif(def_id);\n-\n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst);\n-        record!(self.tables.mir_const_qualif[def_id.to_def_id()] <- qualifs);\n-        record!(self.tables.rendered_const[def_id.to_def_id()] <- const_data);\n     }\n \n     fn encode_native_libraries(&mut self) -> LazyArray<NativeLib> {"}]}