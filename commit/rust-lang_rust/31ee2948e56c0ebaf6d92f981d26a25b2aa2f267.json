{"sha": "31ee2948e56c0ebaf6d92f981d26a25b2aa2f267", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZWUyOTQ4ZTU2YzBlYmFmNmQ5MmY5ODFkMjZhMjViMmFhMmYyNjc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:44Z"}, "message": "Rollup merge of #37716 - GuillaumeGomez:mem_urls, r=@frewsxcv\n\nMem urls\n\nr? @steveklabnik", "tree": {"sha": "d94752d6ac1980aec5cdde4d5caafb49a430bbcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d94752d6ac1980aec5cdde4d5caafb49a430bbcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267", "html_url": "https://github.com/rust-lang/rust/commit/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e436be91730880449ae8bed0740b8d009fd1f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e436be91730880449ae8bed0740b8d009fd1f78", "html_url": "https://github.com/rust-lang/rust/commit/6e436be91730880449ae8bed0740b8d009fd1f78"}, {"sha": "bfdf652f535475542adcd14dcd84b316fc888034", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfdf652f535475542adcd14dcd84b316fc888034", "html_url": "https://github.com/rust-lang/rust/commit/bfdf652f535475542adcd14dcd84b316fc888034"}], "stats": {"total": 39, "additions": 23, "deletions": 16}, "files": [{"sha": "209107ef92ceb824f67ae3dea053c3f2503b3922", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ee2948e56c0ebaf6d92f981d26a25b2aa2f267/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=31ee2948e56c0ebaf6d92f981d26a25b2aa2f267", "patch": "@@ -337,7 +337,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous, and should not be done lightly. Deeply\n+/// **This is incredibly dangerous and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n /// This is useful for [FFI] functions and initializing arrays sometimes,\n@@ -352,24 +352,18 @@ pub unsafe fn zeroed<T>() -> T {\n /// a boolean, your program may take one, both, or neither of the branches.\n ///\n /// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n /// value and its fields if you try to overwrite it in a normal manner. The only way\n /// to safely initialize an uninitialized value is with [`ptr::write`][write],\n /// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If the value does implement `Drop`, it must be initialized before\n+/// If the value does implement [`Drop`], it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n-/// [write]: ../ptr/fn.write.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [drop]: ../ops/trait.Drop.html\n-///\n /// # Examples\n ///\n-/// Here's how to safely initialize an array of `Vec`s.\n+/// Here's how to safely initialize an array of [`Vec`]s.\n ///\n /// ```\n /// use std::mem;\n@@ -410,15 +404,24 @@ pub unsafe fn zeroed<T>() -> T {\n /// ```\n ///\n /// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n-/// value that is only `Clone`, so the following is semantically equivalent and\n+/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n+/// value that is only [`Clone`], so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n ///\n /// ```\n /// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n /// println!(\"{:?}\", &data[0]);\n /// ```\n+///\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n@@ -492,7 +495,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n /// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n /// `self`, allowing it to be returned:\n ///\n@@ -507,6 +510,8 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///     }\n /// }\n /// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n@@ -571,8 +576,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n-/// release a `RefCell` borrow:\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -588,7 +593,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop`.\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -602,6 +607,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"x: {}, y: {}\", x, y.0); // still available\n /// ```\n ///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }"}]}