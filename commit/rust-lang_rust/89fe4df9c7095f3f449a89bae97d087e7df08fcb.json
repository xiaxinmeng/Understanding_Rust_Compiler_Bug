{"sha": "89fe4df9c7095f3f449a89bae97d087e7df08fcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZmU0ZGY5YzcwOTVmM2Y0NDlhODliYWU5N2QwODdlN2RmMDhmY2I=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-03-05T17:15:58Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-03-06T14:04:04Z"}, "message": "Unify both conflicting default searches into one.", "tree": {"sha": "5fc513788de68b4c7883acfefa54fc5c43db1116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fc513788de68b4c7883acfefa54fc5c43db1116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89fe4df9c7095f3f449a89bae97d087e7df08fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89fe4df9c7095f3f449a89bae97d087e7df08fcb", "html_url": "https://github.com/rust-lang/rust/commit/89fe4df9c7095f3f449a89bae97d087e7df08fcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89fe4df9c7095f3f449a89bae97d087e7df08fcb/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "155ef41c8483277d4de106ea372b94da6b786539", "url": "https://api.github.com/repos/rust-lang/rust/commits/155ef41c8483277d4de106ea372b94da6b786539", "html_url": "https://github.com/rust-lang/rust/commit/155ef41c8483277d4de106ea372b94da6b786539"}], "stats": {"total": 133, "additions": 50, "deletions": 83}, "files": [{"sha": "ae4cb48b7c60e8018200573984cf1d1c63b4b443", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 83, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/89fe4df9c7095f3f449a89bae97d087e7df08fcb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fe4df9c7095f3f449a89bae97d087e7df08fcb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=89fe4df9c7095f3f449a89bae97d087e7df08fcb", "patch": "@@ -2007,37 +2007,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // we will rollback the inference context to its prior state so we can probe\n             // for conflicts and correctly report them.\n \n-\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n-                for ty in &unbound_tyvars {\n-                    if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                           self.tcx.mk_diverging_default());\n-                    } else {\n-                        match self.type_is_unconstrained_numeric(ty) {\n-                            UnconstrainedInt => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                            },\n-                            UnconstrainedFloat => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                            }\n-                            Neither => {\n-                                if let Some(default) = default_map.get(ty) {\n-                                    let default = default.clone();\n-                                    let default_ty = self.normalize_associated_types_in(\n-                                        default.origin_span, &default.ty);\n-                                    match self.eq_types(false,\n-                                                        &self.misc(default.origin_span),\n-                                                        ty,\n-                                                        default_ty) {\n-                                        Ok(ok) => self.register_infer_ok_obligations(ok),\n-                                        Err(_) => conflicts.push((*ty, default)),\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                conflicts.extend(\n+                    self.apply_defaults_and_return_conflicts(&unbound_tyvars, &default_map, None)\n+                );\n \n                 // If there are conflicts we rollback, otherwise commit\n                 if conflicts.len() > 0 {\n@@ -2047,37 +2020,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            if conflicts.len() > 0 {\n-                // Loop through each conflicting default, figuring out the default that caused\n-                // a unification failure and then report an error for each.\n-                for (conflict, default) in conflicts {\n-                    let conflicting_default =\n-                        self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n-                            .unwrap_or(type_variable::Default {\n-                                ty: self.next_ty_var(\n-                                    TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n-                                origin_span: syntax_pos::DUMMY_SP,\n-                                // what do I put here?\n-                                def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n-                            });\n-\n-                    // This is to ensure that we elimnate any non-determinism from the error\n-                    // reporting by fixing an order, it doesn't matter what order we choose\n-                    // just that it is consistent.\n-                    let (first_default, second_default) =\n-                        if default.def_id < conflicting_default.def_id {\n-                            (default, conflicting_default)\n-                        } else {\n-                            (conflicting_default, default)\n-                        };\n+            // Loop through each conflicting default, figuring out the default that caused\n+            // a unification failure and then report an error for each.\n+            for (conflict, default) in conflicts {\n+                let conflicting_default =\n+                    self.apply_defaults_and_return_conflicts(\n+                            &unbound_tyvars,\n+                            &default_map,\n+                            Some(conflict)\n+                        )\n+                        .last()\n+                        .map(|(_, tv)| tv)\n+                        .unwrap_or(type_variable::Default {\n+                            ty: self.next_ty_var(\n+                                TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n+                            origin_span: syntax_pos::DUMMY_SP,\n+                            // what do I put here?\n+                            def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n+                        });\n+\n+                // This is to ensure that we elimnate any non-determinism from the error\n+                // reporting by fixing an order, it doesn't matter what order we choose\n+                // just that it is consistent.\n+                let (first_default, second_default) =\n+                    if default.def_id < conflicting_default.def_id {\n+                        (default, conflicting_default)\n+                    } else {\n+                        (conflicting_default, default)\n+                    };\n \n \n-                    self.report_conflicting_default_types(\n-                        first_default.origin_span,\n-                        self.body_id,\n-                        first_default,\n-                        second_default)\n-                }\n+                self.report_conflicting_default_types(\n+                    first_default.origin_span,\n+                    self.body_id,\n+                    first_default,\n+                    second_default)\n             }\n         }\n \n@@ -2088,39 +2065,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // apply the default that caused conflict first to a local version of the type variable\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n-    fn find_conflicting_default(&self,\n-                                unbound_vars: &FxHashSet<Ty<'tcx>>,\n-                                default_map: &FxHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n-                                conflict: Ty<'tcx>)\n-                                -> Option<type_variable::Default<'tcx>> {\n+    fn apply_defaults_and_return_conflicts<'b>(\n+        &'b self,\n+        unbound_vars: &'b FxHashSet<Ty<'tcx>>,\n+        default_map: &'b FxHashMap<&'b Ty<'tcx>, type_variable::Default<'tcx>>,\n+        conflict: Option<Ty<'tcx>>,\n+    ) -> impl Iterator<Item=(Ty<'tcx>, type_variable::Default<'tcx>)> + 'b {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-        // Ensure that we apply the conflicting default first\n-        let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n-        unbound_tyvars.push(conflict);\n-        unbound_tyvars.extend(unbound_vars.iter());\n-\n-        let mut result = None;\n-        // We run the same code as above applying defaults in order, this time when\n-        // we find the conflict we just return it for error reporting above.\n-\n-        // We also run this inside snapshot that never commits so we can do error\n-        // reporting for more then one conflict.\n-        for ty in &unbound_tyvars {\n+        conflict.into_iter().chain(unbound_vars.iter().cloned()).flat_map(move |ty| {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, ty,\n                                    self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.f64)\n                     },\n                     Neither => {\n-                        if let Some(default) = default_map.get(ty) {\n+                        if let Some(default) = default_map.get(&ty) {\n                             let default = default.clone();\n                             let default_ty = self.normalize_associated_types_in(\n                                 default.origin_span, &default.ty);\n@@ -2130,16 +2097,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 default_ty) {\n                                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                                 Err(_) => {\n-                                    result = Some(default);\n+                                    return Some((ty, default));\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        return result;\n+            None\n+        })\n     }\n \n     fn select_all_obligations_or_error(&self) {"}]}