{"sha": "53a3bfc82bb962b4b604d489646567714fe4e2a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYTNiZmM4MmJiOTYyYjRiNjA0ZDQ4OTY0NjU2NzcxNGZlNGUyYTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-19T14:00:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-19T14:00:50Z"}, "message": "Rollup merge of #64007 - estebank:overlapping-patterns, r=matthewjasper\n\nAdd check for overlapping ranges to unreachable patterns lint\n\nFix #63987.", "tree": {"sha": "4d3c121896136152458a30d3bbf95b063c799d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3c121896136152458a30d3bbf95b063c799d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53a3bfc82bb962b4b604d489646567714fe4e2a2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqxcSCRBK7hj4Ov3rIwAAdHIIABOnYYlxAl6JeV0uj1gJs8gV\nglPxb8qrss5jsHBevzTrEkqDqKZLBc3MCN1kh1f3LQV8m1fM5qCuvSgHoo5pM/Ko\nc03WBjdd3+za0VMr/exexqzW+rnhVEynZ+Afts9l1PMLLYTFV9+ih9zB4h2jw+bZ\n0RQNAiMmil778uoPRsJRGricw/9H00LOKfHsMeZ2v7fJnLxDKKSuyw+It8bCdiIg\nHYiSJ7XH82jKqQVxImFyQZ8fMbrORXjKkG+CN3GdITCdoUEPnwhMNrnoiqaVRwws\nfZS3goVkCCz4O2VxU/QivNvAFwb4qo6mmk64Wo8JW4NoExCuvvfJl7E9Qk8GG/w=\n=RIov\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d3c121896136152458a30d3bbf95b063c799d80\nparent e5b8c118a38e8f3319813de56386bf43751582d7\nparent 593cdcccf28361df155c37916dcfcbe1bf19d9a5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571493650 +0200\ncommitter GitHub <noreply@github.com> 1571493650 +0200\n\nRollup merge of #64007 - estebank:overlapping-patterns, r=matthewjasper\n\nAdd check for overlapping ranges to unreachable patterns lint\n\nFix #63987.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53a3bfc82bb962b4b604d489646567714fe4e2a2", "html_url": "https://github.com/rust-lang/rust/commit/53a3bfc82bb962b4b604d489646567714fe4e2a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53a3bfc82bb962b4b604d489646567714fe4e2a2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5b8c118a38e8f3319813de56386bf43751582d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5b8c118a38e8f3319813de56386bf43751582d7", "html_url": "https://github.com/rust-lang/rust/commit/e5b8c118a38e8f3319813de56386bf43751582d7"}, {"sha": "593cdcccf28361df155c37916dcfcbe1bf19d9a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/593cdcccf28361df155c37916dcfcbe1bf19d9a5", "html_url": "https://github.com/rust-lang/rust/commit/593cdcccf28361df155c37916dcfcbe1bf19d9a5"}], "stats": {"total": 432, "additions": 317, "deletions": 115}, "files": [{"sha": "02b391615b621f2f2fdc04edcb97ce03748732cf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -989,6 +989,15 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n+impl fmt::Display for RangeEnd {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            RangeEnd::Included => \"..=\",\n+            RangeEnd::Excluded => \"..\",\n+        })\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`)."}, {"sha": "4c28f6372fe2c6db543819ea21a7d9324e4b39ba", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -80,6 +80,12 @@ declare_lint! {\n     \"detects unreachable patterns\"\n }\n \n+declare_lint! {\n+    pub OVERLAPPING_PATTERNS,\n+    Warn,\n+    \"detects overlapping patterns\"\n+}\n+\n declare_lint! {\n     pub UNUSED_MACROS,\n     Warn,\n@@ -423,6 +429,7 @@ declare_lint_pass! {\n         DEAD_CODE,\n         UNREACHABLE_CODE,\n         UNREACHABLE_PATTERNS,\n+        OVERLAPPING_PATTERNS,\n         UNUSED_MACROS,\n         WARNINGS,\n         UNUSED_FEATURES,"}, {"sha": "e3860e229d6b5d4b89960a3e0fc87160baf372e4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -255,6 +255,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_MUT,\n                     UNREACHABLE_CODE,\n                     UNREACHABLE_PATTERNS,\n+                    OVERLAPPING_PATTERNS,\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,"}, {"sha": "1d83b104177e23ead5bbcc9df2439ef66970f0aa", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 194, "deletions": 60, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -167,13 +167,14 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::RangeEnd;\n+use rustc::hir::{RangeEnd, HirId};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n+use rustc::lint;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -418,21 +419,38 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of literal values (`2..=5` and `2..5`).\n-    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n+    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length n.\n     Slice(u64),\n }\n \n+// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n+impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Constructor::Single, Constructor::Single) => true,\n+            (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n+            (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n+            (\n+                Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n+                Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n+            ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n+            (Constructor::Slice(a), Constructor::Slice(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n@@ -447,15 +465,33 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(id) => adt.variant_index_with_id(id),\n-            &Single => {\n+            Variant(id) => adt.variant_index_with_id(*id),\n+            Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            &ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n+            ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n+\n+    fn display(&self, tcx: TyCtxt<'tcx>) -> String {\n+        match self {\n+            Constructor::ConstantValue(val, _) => format!(\"{}\", val),\n+            Constructor::ConstantRange(lo, hi, ty, range_end, _) => {\n+                // Get the right sign on the output:\n+                let ty = ty::ParamEnv::empty().and(*ty);\n+                format!(\n+                    \"{}{}{}\",\n+                    ty::Const::from_bits(tcx, *lo, ty),\n+                    range_end,\n+                    ty::Const::from_bits(tcx, *hi, ty),\n+                )\n+            }\n+            Constructor::Slice(val) => format!(\"[{}]\", val),\n+            _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -484,6 +520,7 @@ pub enum WitnessPreference {\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n     max_slice_length: u64,\n+    span: Span,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -610,8 +647,8 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(value) => PatKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatKind::Range(PatRange {\n+                        ConstantValue(value, _) => PatKind::Constant { value },\n+                        ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             end,\n@@ -647,7 +684,7 @@ fn all_constructors<'a, 'tcx>(\n     let ctors = match pcx.ty.kind {\n         ty::Bool => {\n             [true, false].iter().map(|&b| {\n-                ConstantValue(ty::Const::from_bool(cx.tcx, b))\n+                ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span)\n             }).collect()\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n@@ -679,28 +716,32 @@ fn all_constructors<'a, 'tcx>(\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange('\\u{0000}' as u128,\n-                              '\\u{D7FF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{0000}' as u128,\n+                    '\\u{D7FF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n-                ConstantRange('\\u{E000}' as u128,\n-                              '\\u{10FFFF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{E000}' as u128,\n+                    '\\u{10FFFF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n             ]\n         }\n         ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n-            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = truncate(u128::max_value(), size);\n-            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -827,10 +868,11 @@ where\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n+    pub span: Span,\n }\n \n impl<'tcx> IntRange<'tcx> {\n@@ -860,6 +902,7 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n@@ -877,7 +920,7 @@ impl<'tcx> IntRange<'tcx> {\n                 return None\n             };\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val, ty })\n+            Some(IntRange { range: val..=val, ty, span })\n         } else {\n             None\n         }\n@@ -890,6 +933,7 @@ impl<'tcx> IntRange<'tcx> {\n         hi: u128,\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if Self::is_integral(ty) {\n             // Perform a shift if the underlying types are signed,\n@@ -901,7 +945,7 @@ impl<'tcx> IntRange<'tcx> {\n                 None\n             } else {\n                 let offset = (*end == RangeEnd::Excluded) as u128;\n-                Some(IntRange { range: lo..=(hi - offset), ty })\n+                Some(IntRange { range: lo..=(hi - offset), ty, span })\n             }\n         } else {\n             None\n@@ -916,8 +960,8 @@ impl<'tcx> IntRange<'tcx> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) => Self::from_range(tcx, *lo, *hi, ty, end),\n-            ConstantValue(val) => Self::from_const(tcx, param_env, val),\n+            ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n+            ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n             _ => None,\n         }\n     }\n@@ -930,7 +974,7 @@ impl<'tcx> IntRange<'tcx> {\n         loop {\n             match pat.kind {\n                 box PatKind::Constant { value } => {\n-                    return Self::from_const(tcx, param_env, value);\n+                    return Self::from_const(tcx, param_env, value, pat.span);\n                 }\n                 box PatKind::Range(PatRange { lo, hi, end }) => {\n                     return Self::from_range(\n@@ -939,6 +983,7 @@ impl<'tcx> IntRange<'tcx> {\n                         hi.eval_bits(tcx, param_env, hi.ty),\n                         &lo.ty,\n                         &end,\n+                        pat.span,\n                     );\n                 }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n@@ -965,14 +1010,15 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n+        span: Span,\n     ) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, ty);\n         let (lo, hi) = r.into_inner();\n         if lo == hi {\n             let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), span)\n         } else {\n-            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included)\n+            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included, span)\n         }\n     }\n \n@@ -995,17 +1041,23 @@ impl<'tcx> IntRange<'tcx> {\n             if lo > subrange_hi || subrange_lo > hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi));\n+                remaining_ranges.push(\n+                    Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi, self.span),\n+                );\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1)));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1), self.span),\n+                    );\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi, self.span),\n+                    );\n                 }\n             }\n         }\n@@ -1017,11 +1069,29 @@ impl<'tcx> IntRange<'tcx> {\n         let (lo, hi) = (*self.range.start(), *self.range.end());\n         let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n         if lo <= other_hi && other_lo <= hi {\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty })\n+            let span = other.span;\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n         } else {\n             None\n         }\n     }\n+\n+    fn suspicious_intersection(&self, other: &Self) -> bool {\n+        // `false` in the following cases:\n+        // 1     ----      // 1  ----------   // 1 ----        // 1       ----\n+        // 2  ----------   // 2     ----      // 2       ----  // 2 ----\n+        //\n+        // The following are currently `false`, but could be `true` in the future (#64007):\n+        // 1 ---------       // 1     ---------\n+        // 2     ----------  // 2 ----------\n+        //\n+        // `true` in the following cases:\n+        // 1 -------          // 1       -------\n+        // 2       --------   // 2 -------\n+        let (lo, hi) = (*self.range.start(), *self.range.end());\n+        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n+        (lo == other_hi || hi == other_lo)\n+    }\n }\n \n // A request for missing constructor data in terms of either:\n@@ -1127,6 +1197,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     matrix: &Matrix<'p, 'tcx>,\n     v: &[&Pat<'tcx>],\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n@@ -1149,6 +1220,10 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    let (ty, span) = rows.iter()\n+        .map(|r| (r[0].ty, r[0].span))\n+        .find(|(ty, _)| !ty.references_error())\n+        .unwrap_or((v[0].ty, v[0].span));\n     let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n@@ -1169,8 +1244,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n-        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error()).unwrap_or(v[0].ty),\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n+        ty,\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0]))),\n+        span,\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n@@ -1184,9 +1260,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             Useful\n         } else {\n             split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty,\n+                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n             ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n             ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         }\n     } else {\n@@ -1239,8 +1315,11 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n-            split_grouped_constructors(cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty)\n-                .into_iter().map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness))\n+            split_grouped_constructors(\n+                cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty, DUMMY_SP, None,\n+            )\n+                .into_iter()\n+                .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n@@ -1251,7 +1330,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     None\n                 }\n             }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness) {\n+            match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n@@ -1344,6 +1423,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n@@ -1361,7 +1441,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n             .collect()\n     );\n     match specialize(cx, v, &ctor, &wild_patterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v, witness) {\n+        Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n                     .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n@@ -1381,11 +1461,11 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-                          pat: &Pat<'tcx>,\n-                          pcx: PatCtxt<'tcx>)\n-                          -> Option<Vec<Constructor<'tcx>>>\n-{\n+fn pat_constructors<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    pat: &Pat<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n+) -> Option<Vec<Constructor<'tcx>>> {\n     match *pat.kind {\n         PatKind::AscribeUserType { ref subpattern, .. } =>\n             pat_constructors(cx, subpattern, pcx),\n@@ -1394,13 +1474,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n-        PatKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n         PatKind::Range(PatRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n                 lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n                 hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 lo.ty,\n                 end,\n+                pat.span,\n             )]),\n         PatKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n@@ -1433,7 +1514,7 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n         ty::Tuple(ref fs) => fs.len() as u64,\n         ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n-            ConstantValue(_) => 0,\n+            ConstantValue(..) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(..) => 1,\n@@ -1458,7 +1539,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n-            ConstantValue(_) => vec![],\n+            ConstantValue(..) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(_, rty, _) => vec![rty],\n@@ -1556,8 +1637,8 @@ fn slice_pat_covered_by_const<'tcx>(\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n-        ConstantValue(value) => value.ty,\n-        ConstantRange(_, _, ty, _) => ty,\n+        ConstantValue(value, _) => value.ty,\n+        ConstantRange(_, _, ty, _, _) => ty,\n         _ => return false,\n     };\n     if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.kind {\n@@ -1599,12 +1680,17 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n /// boundaries for each interval range, sort them, then create constructors for each new interval\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n+///\n+/// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n+/// ranges that case.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n+    span: Span,\n+    hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n@@ -1621,7 +1707,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent\n                 /// 2^128 + 1 such borders.\n-                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n                 enum Border {\n                     JustBefore(u128),\n                     AfterMax,\n@@ -1638,35 +1724,57 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     vec![from, to].into_iter()\n                 }\n \n+                // Collect the span and range of all the intersecting ranges to lint on likely\n+                // incorrect range patterns. (#63987)\n+                let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = m.iter()\n-                    .flat_map(|row| IntRange::from_pat(tcx, param_env, row[0]))\n-                    .flat_map(|range| ctor_range.intersection(&range))\n+                    .flat_map(|row| {\n+                        IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n+                    })\n+                    .flat_map(|(range, row_len)| {\n+                        let intersection = ctor_range.intersection(&range);\n+                        let should_lint = ctor_range.suspicious_intersection(&range);\n+                        if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n+                            // FIXME: for now, only check for overlapping ranges on simple range\n+                            // patterns. Otherwise with the current logic the following is detected\n+                            // as overlapping:\n+                            //   match (10u8, true) {\n+                            //    (0 ..= 125, false) => {}\n+                            //    (126 ..= 255, false) => {}\n+                            //    (0 ..= 255, true) => {}\n+                            //  }\n+                            overlaps.push(range.clone());\n+                        }\n+                        intersection\n+                    })\n                     .flat_map(|range| range_borders(range));\n                 let ctor_borders = range_borders(ctor_range.clone());\n                 let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n                 borders.sort_unstable();\n \n+                lint_overlapping_patterns(tcx, hir_id, ctor_range, ty, overlaps);\n+\n                 // We're going to iterate through every pair of borders, making sure that each\n                 // represents an interval of nonnegative length, and convert each such interval\n                 // into a constructor.\n                 for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n                     match (window[0], window[1]) {\n                         (Border::JustBefore(n), Border::JustBefore(m)) => {\n                             if n < m {\n-                                Some(IntRange { range: n..=(m - 1), ty })\n+                                Some(IntRange { range: n..=(m - 1), ty, span })\n                             } else {\n                                 None\n                             }\n                         }\n                         (Border::JustBefore(n), Border::AfterMax) => {\n-                            Some(IntRange { range: n..=u128::MAX, ty })\n+                            Some(IntRange { range: n..=u128::MAX, ty, span })\n                         }\n                         (Border::AfterMax, _) => None,\n                     }\n                 }) {\n-                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range));\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n             // Any other constructor can be used unchanged.\n@@ -1677,6 +1785,32 @@ fn split_grouped_constructors<'p, 'tcx>(\n     split_ctors\n }\n \n+fn lint_overlapping_patterns(\n+    tcx: TyCtxt<'tcx>,\n+    hir_id: Option<HirId>,\n+    ctor_range: IntRange<'tcx>,\n+    ty: Ty<'tcx>,\n+    overlaps: Vec<IntRange<'tcx>>,\n+) {\n+    if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+        let mut err = tcx.struct_span_lint_hir(\n+            lint::builtin::OVERLAPPING_PATTERNS,\n+            hir_id,\n+            ctor_range.span,\n+            \"multiple patterns covering the same range\",\n+        );\n+        err.span_label(ctor_range.span, \"overlapping patterns\");\n+        for int_range in overlaps {\n+            // Use the real type for user display of the ranges:\n+            err.span_label(int_range.span, &format!(\n+                \"this range overlaps on `{}`\",\n+                IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+            ));\n+        }\n+        err.emit();\n+    }\n+}\n+\n fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -1701,13 +1835,13 @@ fn constructor_covered_by_range<'tcx>(\n         };\n     }\n     match *ctor {\n-        ConstantValue(value) => {\n+        ConstantValue(value, _) => {\n             let to = some_or_ok!(cmp_to(value));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Included) => {\n+        ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1721,7 +1855,7 @@ fn constructor_covered_by_range<'tcx>(\n                 ty::ParamEnv::empty().and(ty),\n             ))) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Excluded) => {\n+        ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1915,7 +2049,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                         None\n                     }\n                 }\n-                ConstantValue(cv) => {\n+                ConstantValue(cv, _) => {\n                     match slice_pat_covered_by_const(\n                         cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n                     ) {"}, {"sha": "7bc4bf291ee488f5b61543b5b90ec71c197749f2", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -10,6 +10,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::lint;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n+use rustc::hir::HirId;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -239,7 +240,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 .map(|pat| smallvec![pat.0])\n                 .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n     }\n \n@@ -256,7 +257,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats) {\n+            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n                 Err(err) => err,\n             };\n@@ -389,7 +390,7 @@ fn check_arms<'tcx>(\n         for &(pat, hir_pat) in pats {\n             let v = smallvec![pat];\n \n-            match is_useful(cx, &seen, &v, LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n                     match source {\n                         hir::MatchSource::IfDesugar { .. } |\n@@ -465,9 +466,10 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             vec![wild_pattern]\n@@ -483,8 +485,9 @@ fn check_exhaustive<'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) {\n-    let witnesses = match check_not_useful(cx, scrut_ty, matrix) {\n+    let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,\n     };"}, {"sha": "7e17162dfb3ef0df1d79afabee9e8d98707b5ec4", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -312,10 +312,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n             }\n             PatKind::Range(PatRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n-                match end {\n-                    RangeEnd::Included => write!(f, \"..=\")?,\n-                    RangeEnd::Excluded => write!(f, \"..\")?,\n-                }\n+                write!(f, \"{}\", end)?;\n                 write!(f, \"{}\", hi)\n             }\n             PatKind::Slice { ref prefix, ref slice, ref suffix } |"}, {"sha": "5c6834459f0d4021538bb4f5f6ca5d4b5f9fe80f", "filename": "src/test/ui/check_match/issue-43253.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,7 +1,7 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-\n+// check-pass\n #![feature(exclusive_range_pattern)]\n #![warn(unreachable_patterns)]\n+#![warn(overlapping_patterns)]\n \n fn main() {\n     // These cases should generate no warning.\n@@ -13,7 +13,7 @@ fn main() {\n \n     match 10 {\n         1..10 => {},\n-        9..=10 => {},\n+        9..=10 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n@@ -23,22 +23,25 @@ fn main() {\n         _ => {},\n     }\n \n-    // These cases should generate an \"unreachable pattern\" warning.\n+    // These cases should generate \"unreachable pattern\" warnings.\n     match 10 {\n         1..10 => {},\n-        9 => {},\n+        9 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n \n     match 10 {\n         1..10 => {},\n-        8..=9 => {},\n+        8..=9 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n     match 10 {\n-        1..10 => {},\n-        9..=9 => {},\n+        5..7 => {},\n+        6 => {}, //~ WARNING unreachable pattern\n+        1..10 => {}, //~ WARNING multiple patterns covering the same range\n+        9..=9 => {}, //~ WARNING unreachable pattern\n+        6 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n }"}, {"sha": "cb4a0486eef9ab244f6884659a7dc1a2982a649d", "filename": "src/test/ui/check_match/issue-43253.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,11 +1,25 @@\n+warning: multiple patterns covering the same range\n+  --> $DIR/issue-43253.rs:16:9\n+   |\n+LL |         1..10 => {},\n+   |         ----- this range overlaps on `9i32`\n+LL |         9..=10 => {},\n+   |         ^^^^^^ overlapping patterns\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-43253.rs:4:9\n+   |\n+LL | #![warn(overlapping_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n warning: unreachable pattern\n   --> $DIR/issue-43253.rs:29:9\n    |\n LL |         9 => {},\n    |         ^\n    |\n note: lint level defined here\n-  --> $DIR/issue-43253.rs:4:9\n+  --> $DIR/issue-43253.rs:3:9\n    |\n LL | #![warn(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n@@ -19,6 +33,18 @@ LL |         8..=9 => {},\n warning: unreachable pattern\n   --> $DIR/issue-43253.rs:41:9\n    |\n+LL |         6 => {},\n+   |         ^\n+\n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:43:9\n+   |\n LL |         9..=9 => {},\n    |         ^^^^^\n \n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:44:9\n+   |\n+LL |         6 => {},\n+   |         ^\n+"}, {"sha": "59f749198971b5a1931817cdc9a91e48380d1476", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,7 +1,7 @@\n #![feature(precise_pointer_size_matching)]\n #![feature(exclusive_range_pattern)]\n-\n #![deny(unreachable_patterns)]\n+#![deny(overlapping_patterns)]\n \n use std::{char, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128};\n \n@@ -41,7 +41,8 @@ fn main() {\n     match x { //~ ERROR non-exhaustive patterns\n         -7 => {}\n         -5..=120 => {}\n-        -2..=20 => {} //~ ERROR unreachable pattern\n+        -2..=20 => {}\n+        //~^ ERROR unreachable pattern\n         125 => {}\n     }\n \n@@ -135,9 +136,9 @@ fn main() {\n         (125 .. 128, false) => {}\n     }\n \n-    match 0u8 { // ok\n+    match 0u8 {\n         0 .. 2 => {}\n-        1 ..= 2 => {}\n+        1 ..= 2 => {} //~ ERROR multiple patterns covering the same range\n         _ => {}\n     }\n "}, {"sha": "7a3a36a820c65cfc1540aae208b095030f99d11c", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -5,7 +5,7 @@ LL |         200 => {}\n    |         ^^^\n    |\n note: lint level defined here\n-  --> $DIR/exhaustive_integer_patterns.rs:4:9\n+  --> $DIR/exhaustive_integer_patterns.rs:3:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n@@ -41,69 +41,83 @@ LL |     match x {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:82:11\n+  --> $DIR/exhaustive_integer_patterns.rs:83:11\n    |\n LL |     match 0i8 {\n    |           ^^^ pattern `std::i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `0i16` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:90:11\n+  --> $DIR/exhaustive_integer_patterns.rs:91:11\n    |\n LL |     match 0i16 {\n    |           ^^^^ pattern `0i16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:108:11\n+  --> $DIR/exhaustive_integer_patterns.rs:109:11\n    |\n LL |     match 0u8 {\n    |           ^^^ pattern `128u8..=std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:120:11\n+  --> $DIR/exhaustive_integer_patterns.rs:121:11\n    |\n LL |     match (0u8, Some(())) {\n    |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(126u8..=127u8, false)` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:125:11\n+  --> $DIR/exhaustive_integer_patterns.rs:126:11\n    |\n LL |     match (0u8, true) {\n    |           ^^^^^^^^^^^ pattern `(126u8..=127u8, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n+error: multiple patterns covering the same range\n+  --> $DIR/exhaustive_integer_patterns.rs:141:9\n+   |\n+LL |         0 .. 2 => {}\n+   |         ------ this range overlaps on `1u8`\n+LL |         1 ..= 2 => {}\n+   |         ^^^^^^^ overlapping patterns\n+   |\n+note: lint level defined here\n+  --> $DIR/exhaustive_integer_patterns.rs:4:9\n+   |\n+LL | #![deny(overlapping_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:145:11\n+  --> $DIR/exhaustive_integer_patterns.rs:146:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `5u128..=std::u128::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:149:11\n+  --> $DIR/exhaustive_integer_patterns.rs:150:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `5u128..=std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `0u128..=3u128` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:153:11\n+  --> $DIR/exhaustive_integer_patterns.rs:154:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `0u128..=3u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "9510aae77534158245da2265c6bf2d22fae18340", "filename": "src/test/ui/issues/issue-13867.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -2,7 +2,6 @@\n // Test that codegen works correctly when there are multiple refutable\n // patterns in match expression.\n \n-\n enum Foo {\n     FooUint(usize),\n     FooNullary,"}, {"sha": "ab0a18869632a986e9253cba7c7e506b9163506a", "filename": "src/test/ui/issues/issue-21475.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(unused_imports)]\n+#![allow(unused_imports, overlapping_patterns)]\n // pretty-expanded FIXME #23616\n \n use m::{START, END};"}, {"sha": "edb06fea8ad5333db9322141654ee1cbd24ca6e5", "filename": "src/test/ui/issues/issue-26251.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+#![allow(overlapping_patterns)]\n+\n fn main() {\n     let x = 'a';\n "}, {"sha": "7de7b7e79be44faf85c4b75fe98ff73dd672e40b", "filename": "src/test/ui/match/match-range-fail-dominate.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,39 +1,45 @@\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-\n-#![deny(unreachable_patterns)]\n+#![deny(unreachable_patterns, overlapping_patterns)]\n \n fn main() {\n     match 5 {\n       1 ..= 10 => { }\n       5 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 5 {\n       3 ..= 6 => { }\n       4 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 5 {\n       4 ..= 6 => { }\n       4 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 'c' {\n       'A' ..= 'z' => {}\n       'a' ..= 'z' => {}\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 1.0f64 {\n       0.01f64 ..= 6.5f64 => {}\n-      0.02f64 => {}\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      0.02f64 => {} //~ ERROR unreachable pattern\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n       _ => {}\n     };\n }"}, {"sha": "c15186d2558f24402c0746132a7f3fbf4c3b1783", "filename": "src/test/ui/match/match-range-fail-dominate.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -1,35 +1,35 @@\n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:12:7\n+  --> $DIR/match-range-fail-dominate.rs:6:7\n    |\n LL |       5 ..= 6 => { }\n    |       ^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/match-range-fail-dominate.rs:7:9\n+  --> $DIR/match-range-fail-dominate.rs:1:9\n    |\n-LL | #![deny(unreachable_patterns)]\n+LL | #![deny(unreachable_patterns, overlapping_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:18:7\n+  --> $DIR/match-range-fail-dominate.rs:13:7\n    |\n LL |       4 ..= 6 => { }\n    |       ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:24:7\n+  --> $DIR/match-range-fail-dominate.rs:20:7\n    |\n LL |       4 ..= 6 => { }\n    |       ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:30:7\n+  --> $DIR/match-range-fail-dominate.rs:27:7\n    |\n LL |       'a' ..= 'z' => {}\n    |       ^^^^^^^^^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:33:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^\n@@ -39,7 +39,7 @@ LL |       0.01f64 ..= 6.5f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:19\n+  --> $DIR/match-range-fail-dominate.rs:33:19\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |                   ^^^^^^\n@@ -48,7 +48,7 @@ LL |       0.01f64 ..= 6.5f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:36:7\n+  --> $DIR/match-range-fail-dominate.rs:40:7\n    |\n LL |       0.02f64 => {}\n    |       ^^^^^^^\n@@ -57,13 +57,13 @@ LL |       0.02f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:36:7\n+  --> $DIR/match-range-fail-dominate.rs:40:7\n    |\n LL |       0.02f64 => {}\n    |       ^^^^^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:33:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^"}, {"sha": "54aeb8616d959f4bb02f601e13627cab2e808304", "filename": "src/test/ui/precise_pointer_size_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -8,7 +8,7 @@\n #![feature(precise_pointer_size_matching)]\n #![feature(exclusive_range_pattern)]\n \n-#![deny(unreachable_patterns)]\n+#![deny(unreachable_patterns, overlapping_patterns)]\n \n use std::{usize, isize};\n "}, {"sha": "f8abd1b96d80e85ff959146c4f895107b28bae3b", "filename": "src/test/ui/rfcs/rfc-2005-default-binding-mode/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a3bfc82bb962b4b604d489646567714fe4e2a2/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs?ref=53a3bfc82bb962b4b604d489646567714fe4e2a2", "patch": "@@ -3,7 +3,7 @@ pub fn main() {\n     let i = 5;\n     match &&&&i {\n         1 ..= 3 => panic!(),\n-        3 ..= 8 => {},\n+        4 ..= 8 => {},\n         _ => panic!(),\n     }\n }"}]}