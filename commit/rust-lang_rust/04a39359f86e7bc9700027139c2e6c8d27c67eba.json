{"sha": "04a39359f86e7bc9700027139c2e6c8d27c67eba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YTM5MzU5Zjg2ZTdiYzk3MDAwMjcxMzljMmU2YzhkMjdjNjdlYmE=", "commit": {"author": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-14T21:47:30Z"}, "committer": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-27T12:50:33Z"}, "message": "Rename unwrap_input/unwrap_output as suggested by\n@brson. Also fix a few documentation bugs.", "tree": {"sha": "e5cbab0dbb721a41b68e3879d21efb0ee8b8a236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5cbab0dbb721a41b68e3879d21efb0ee8b8a236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04a39359f86e7bc9700027139c2e6c8d27c67eba", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04a39359f86e7bc9700027139c2e6c8d27c67eba", "html_url": "https://github.com/rust-lang/rust/commit/04a39359f86e7bc9700027139c2e6c8d27c67eba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04a39359f86e7bc9700027139c2e6c8d27c67eba/comments", "author": null, "committer": null, "parents": [{"sha": "49a1ab8745338e6ac6da65c3fc4e541761f6c760", "url": "https://api.github.com/repos/rust-lang/rust/commits/49a1ab8745338e6ac6da65c3fc4e541761f6c760", "html_url": "https://github.com/rust-lang/rust/commit/49a1ab8745338e6ac6da65c3fc4e541761f6c760"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "3cdc5dcca072348e9322abe68bae1282cbeaace1", "filename": "src/libstd/run.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04a39359f86e7bc9700027139c2e6c8d27c67eba/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a39359f86e7bc9700027139c2e6c8d27c67eba/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=04a39359f86e7bc9700027139c2e6c8d27c67eba", "patch": "@@ -45,10 +45,10 @@ pub struct Process {\n     /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n     priv input: Option<c_int>,\n \n-    /// Some(fd), or None when stdout is being redirected to a fd not created by Process::new.\n+    /// Some(file), or None when stdout is being redirected to a fd not created by Process::new.\n     priv output: Option<*libc::FILE>,\n \n-    /// Some(fd), or None when stderr is being redirected to a fd not created by Process::new.\n+    /// Some(file), or None when stderr is being redirected to a fd not created by Process::new.\n     priv error: Option<*libc::FILE>,\n \n     /// None until finish() is called.\n@@ -191,23 +191,23 @@ pub impl Process {\n     /// Returns the unique id of the process\n     fn get_id(&self) -> pid_t { self.pid }\n \n-    priv fn unwrap_input(&mut self) -> c_int {\n+    priv fn input_fd(&mut self) -> c_int {\n         match self.input {\n             Some(fd) => fd,\n             None => fail!(\"This Process's stdin was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n-    priv fn unwrap_output(&mut self) -> *libc::FILE {\n+    priv fn output_file(&mut self) -> *libc::FILE {\n         match self.output {\n             Some(file) => file,\n             None => fail!(\"This Process's stdout was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n-    priv fn unwrap_error(&mut self) -> *libc::FILE {\n+    priv fn error_file(&mut self) -> *libc::FILE {\n         match self.error {\n             Some(file) => file,\n             None => fail!(\"This Process's stderr was redirected to an \\\n@@ -255,7 +255,7 @@ pub impl Process {\n      */\n     fn input(&mut self) -> @io::Writer {\n         // FIXME: the Writer can still be used after self is destroyed: #2625\n-       io::fd_writer(self.unwrap_input(), false)\n+       io::fd_writer(self.input_fd(), false)\n     }\n \n     /**\n@@ -265,7 +265,7 @@ pub impl Process {\n      */\n     fn output(&mut self) -> @io::Reader {\n         // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.unwrap_output(), false)\n+        io::FILE_reader(self.output_file(), false)\n     }\n \n     /**\n@@ -275,7 +275,7 @@ pub impl Process {\n      */\n     fn error(&mut self) -> @io::Reader {\n         // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.unwrap_error(), false)\n+        io::FILE_reader(self.error_file(), false)\n     }\n \n     /**\n@@ -341,8 +341,8 @@ pub impl Process {\n      */\n     fn finish_with_output(&mut self) -> ProcessOutput {\n \n-        let output_file = self.unwrap_output();\n-        let error_file = self.unwrap_error();\n+        let output_file = self.output_file();\n+        let error_file = self.error_file();\n \n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n@@ -814,7 +814,7 @@ pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n  *\n  * Note that this is private to avoid race conditions on unix where if\n  * a user calls waitpid(some_process.get_id()) then some_process.finish()\n- * and some_process.destroy() and some_process.drop() will then either\n+ * and some_process.destroy() and some_process.finalize() will then either\n  * operate on a none-existant process or, even worse, on a newer process\n  * with the same id.\n  */"}]}