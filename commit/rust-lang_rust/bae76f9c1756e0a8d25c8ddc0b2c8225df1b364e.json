{"sha": "bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZTc2ZjljMTc1NmUwYThkMjVjOGRkYzBiMmM4MjI1ZGYxYjM2NGU=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-06-16T17:14:23Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-06-29T13:17:23Z"}, "message": "Remove a visitor from use_self", "tree": {"sha": "81e26e12c69a997ed2e2122f7e13e71b4f6ab87f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e26e12c69a997ed2e2122f7e13e71b4f6ab87f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e", "html_url": "https://github.com/rust-lang/rust/commit/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e801e251fb6de6dc9563b0203ea3dab14e3d3ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e801e251fb6de6dc9563b0203ea3dab14e3d3ec", "html_url": "https://github.com/rust-lang/rust/commit/6e801e251fb6de6dc9563b0203ea3dab14e3d3ec"}], "stats": {"total": 97, "additions": 22, "deletions": 75}, "files": [{"sha": "906ac10f4610b92f0c548f2445064dde896b6a87", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 22, "deletions": 75, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=bae76f9c1756e0a8d25c8ddc0b2c8225df1b364e", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{AssocKind, Ty};\n+use rustc_middle::ty::AssocKind;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -75,8 +75,8 @@ impl UseSelf {\n enum StackItem {\n     Check {\n         impl_id: LocalDefId,\n+        in_body: u32,\n         types_to_skip: FxHashSet<HirId>,\n-        types_to_lint: Vec<HirId>,\n     },\n     NoCheck,\n }\n@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             then {\n                 StackItem::Check {\n                     impl_id: item.def_id,\n-                    types_to_lint: Vec::new(),\n+                    in_body: 0,\n                     types_to_skip: std::iter::once(self_ty.hir_id).collect(),\n                 }\n             } else {\n@@ -182,51 +182,39 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n         }\n     }\n \n-    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) {\n+    fn check_body(&mut self, _: &LateContext<'_>, _: &hir::Body<'_>) {\n         // `hir_ty_to_ty` cannot be called in `Body`s or it will panic (sometimes). But in bodies\n         // we can use `cx.typeck_results.node_type(..)` to get the `ty::Ty` from a `hir::Ty`.\n         // However the `node_type()` method can *only* be called in bodies.\n-        //\n-        // This method implementation determines which types should get linted in a `Body` and\n-        // which shouldn't, with a visitor. We could directly lint in the visitor, but then we\n-        // could only allow this lint on item scope. And we would have to check if those types are\n-        // already dealt with in `check_ty` anyway.\n-        if let Some(StackItem::Check {\n-            impl_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last_mut()\n-        {\n-            let self_ty = cx.tcx.type_of(*impl_id);\n+        if let Some(&mut StackItem::Check { ref mut in_body, .. }) = self.stack.last_mut() {\n+            *in_body = in_body.saturating_add(1);\n+        }\n+    }\n \n-            let mut visitor = LintTyCollector {\n-                cx,\n-                self_ty,\n-                types_to_lint: vec![],\n-                types_to_skip: vec![],\n-            };\n-            visitor.visit_expr(&body.value);\n-            types_to_lint.extend(visitor.types_to_lint);\n-            types_to_skip.extend(visitor.types_to_skip);\n+    fn check_body_post(&mut self, _: &LateContext<'_>, _: &hir::Body<'_>) {\n+        if let Some(&mut StackItem::Check { ref mut in_body, .. }) = self.stack.last_mut() {\n+            *in_body = in_body.saturating_sub(1);\n         }\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n         if_chain! {\n             if !in_macro(hir_ty.span);\n             if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n-            if let Some(StackItem::Check {\n+            if let Some(&StackItem::Check {\n                 impl_id,\n-                types_to_lint,\n-                types_to_skip,\n+                in_body,\n+                ref types_to_skip,\n             }) = self.stack.last();\n+            if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+            if !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _));\n             if !types_to_skip.contains(&hir_ty.hir_id);\n-            if types_to_lint.contains(&hir_ty.hir_id)\n-                || {\n-                    let self_ty = cx.tcx.type_of(*impl_id);\n-                    should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n-                };\n+            let ty = if in_body > 0 {\n+                cx.typeck_results().node_type(hir_ty.hir_id)\n+            } else {\n+                hir_ty_to_ty(cx.tcx, hir_ty)\n+            };\n+            if same_type_and_consts(ty, cx.tcx.type_of(impl_id));\n             let hir = cx.tcx.hir();\n             let id = hir.get_parent_node(hir_ty.hir_id);\n             if !hir.opt_span(id).map_or(false, in_macro);\n@@ -289,35 +277,6 @@ impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n     }\n }\n \n-struct LintTyCollector<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n-    types_to_lint: Vec<HirId>,\n-    types_to_skip: Vec<HirId>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n-        if_chain! {\n-            if let Some(ty) = self.cx.typeck_results().node_type_opt(hir_ty.hir_id);\n-            if should_lint_ty(hir_ty, ty, self.self_ty);\n-            then {\n-                self.types_to_lint.push(hir_ty.hir_id);\n-            } else {\n-                self.types_to_skip.push(hir_ty.hir_id);\n-            }\n-        }\n-\n-        walk_ty(self, hir_ty);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n fn span_lint(cx: &LateContext<'_>, span: Span) {\n     span_lint_and_sugg(\n         cx,\n@@ -346,15 +305,3 @@ fn is_item_interesting(item: &Item<'_>) -> bool {\n         Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..)\n     )\n }\n-\n-fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n-    if_chain! {\n-        if same_type_and_consts(ty, self_ty);\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-        then {\n-            !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _))\n-        } else {\n-            false\n-        }\n-    }\n-}"}]}