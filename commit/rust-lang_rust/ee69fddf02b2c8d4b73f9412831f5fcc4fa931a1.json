{"sha": "ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNjlmZGRmMDJiMmM4ZDRiNzNmOTQxMjgzMWY1ZmNjNGZhOTMxYTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-15T18:56:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-15T18:56:01Z"}, "message": "Drop dead code", "tree": {"sha": "c5694c8b25580219237764d5e8d852dacfcaea84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5694c8b25580219237764d5e8d852dacfcaea84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "html_url": "https://github.com/rust-lang/rust/commit/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7503c5528f20f7404bac6f70bcf2120edb54dc52", "url": "https://api.github.com/repos/rust-lang/rust/commits/7503c5528f20f7404bac6f70bcf2120edb54dc52", "html_url": "https://github.com/rust-lang/rust/commit/7503c5528f20f7404bac6f70bcf2120edb54dc52"}], "stats": {"total": 401, "additions": 0, "deletions": 401}, "files": [{"sha": "0773edcc12024276b330d0f1984a9190cb573e3b", "filename": "crates/ra_analysis/src/db.rs", "status": "renamed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "patch": "@@ -101,89 +101,3 @@ fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<SymbolIndex> {\n     let syntax = db.file_syntax(file_id);\n     Arc::new(SymbolIndex::for_file(file_id, syntax))\n }\n-\n-// mod imp;\n-\n-// use std::{\n-//     sync::Arc,\n-// };\n-// use im;\n-// use salsa;\n-// use {FileId, imp::FileResolverImp};\n-\n-// #[derive(Debug, Default, Clone)]\n-// pub(crate) struct State {\n-//     pub(crate) file_map: im::HashMap<FileId, Arc<String>>,\n-//     pub(crate) file_resolver: FileResolverImp\n-// }\n-\n-// #[derive(Debug)]\n-// pub(crate) struct Db {\n-//     imp: imp::Db,\n-// }\n-\n-// #[derive(Clone, Copy)]\n-// pub(crate) struct QueryCtx<'a> {\n-//     imp: &'a salsa::QueryCtx<State, imp::Data>,\n-// }\n-\n-// pub(crate) struct Query<T, R>(pub(crate) u16, pub(crate) fn(QueryCtx, &T) -> R);\n-\n-// pub(crate) struct QueryRegistry {\n-//     imp: imp::QueryRegistry,\n-// }\n-\n-// impl Default for Db {\n-//     fn default() -> Db {\n-//         Db::new()\n-//     }\n-// }\n-\n-// impl Db {\n-//     pub(crate) fn new() -> Db {\n-//         let reg = QueryRegistry::new();\n-//         Db { imp: imp::Db::new(reg.imp) }\n-//     }\n-//     pub(crate) fn state(&self) -> &State {\n-//         self.imp.imp.ground_data()\n-//     }\n-//     pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n-//         Db { imp: self.imp.with_changes(new_state, changed_files, resolver_changed) }\n-//     }\n-//     pub(crate) fn make_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> R {\n-//         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n-//         f(ctx)\n-//     }\n-//     #[allow(unused)]\n-//     pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n-//         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n-//         let res = f(ctx);\n-//         let trace = self.imp.extract_trace(ctx.imp);\n-//         (res, trace)\n-//     }\n-// }\n-\n-// impl<'a> QueryCtx<'a> {\n-//     pub(crate) fn get<Q: imp::EvalQuery>(&self, q: Q, params: Q::Params) -> Arc<Q::Output> {\n-//         q.get(self, params)\n-//     }\n-// }\n-\n-// pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n-//     imp::file_text(ctx, file_id)\n-// }\n-\n-// pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n-//     imp::file_set(ctx)\n-// }\n-// impl QueryRegistry {\n-//     fn new() -> QueryRegistry {\n-//         let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n-//         ::queries::register_queries(&mut reg);\n-//         ::module_map::register_queries(&mut reg);\n-//         reg\n-//     }\n-//     pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {\n-//         self.imp.add(q, name)\n-//     }\n-// }", "previous_filename": "crates/ra_analysis/src/db/mod.rs"}, {"sha": "7669b6184550c61efd33315987dd8964765cb47d", "filename": "crates/ra_analysis/src/db/imp.rs", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7503c5528f20f7404bac6f70bcf2120edb54dc52/crates%2Fra_analysis%2Fsrc%2Fdb%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7503c5528f20f7404bac6f70bcf2120edb54dc52/crates%2Fra_analysis%2Fsrc%2Fdb%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb%2Fimp.rs?ref=7503c5528f20f7404bac6f70bcf2120edb54dc52", "patch": "@@ -1,153 +0,0 @@\n-use std::{\n-    sync::Arc,\n-    any::Any,\n-    hash::{Hash, Hasher},\n-    collections::hash_map::{DefaultHasher},\n-    iter,\n-};\n-use rustc_hash::FxHashMap;\n-use salsa;\n-use crate::{FileId, imp::FileResolverImp};\n-use super::{State, Query, QueryCtx};\n-\n-pub(super) type Data = Arc<Any + Send + Sync + 'static>;\n-\n-#[derive(Debug)]\n-pub(super) struct Db {\n-    names: Arc<FxHashMap<salsa::QueryTypeId, &'static str>>,\n-    pub(super) imp: salsa::Db<State, Data>,\n-}\n-\n-impl Db {\n-    pub(super) fn new(mut reg: QueryRegistry) -> Db {\n-        let config = reg.config.take().unwrap();\n-        Db {\n-            names: Arc::new(reg.names),\n-            imp: salsa::Db::new(config, State::default())\n-        }\n-    }\n-    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n-        let names = self.names.clone();\n-        let mut invalidations = salsa::Invalidations::new();\n-        invalidations.invalidate(FILE_TEXT, changed_files.iter().map(hash).map(salsa::InputFingerprint));\n-        if resolver_changed {\n-            invalidations.invalidate(FILE_SET, iter::once(salsa::InputFingerprint(hash(&()))));\n-        } else {\n-            invalidations.invalidate(FILE_SET, iter::empty());\n-        }\n-        let imp = self.imp.with_ground_data(\n-            new_state,\n-            invalidations,\n-        );\n-        Db { names, imp }\n-    }\n-    pub(super) fn extract_trace(&self, ctx: &salsa::QueryCtx<State, Data>) -> Vec<&'static str> {\n-        ctx.trace().into_iter().map(|it| self.names[&it]).collect()\n-    }\n-}\n-\n-pub(crate) trait EvalQuery {\n-    type Params;\n-    type Output;\n-    fn query_type(&self) -> salsa::QueryTypeId;\n-    fn f(&self) -> salsa::QueryFn<State, Data>;\n-    fn get(&self, ctx: &QueryCtx, params: Self::Params) -> Arc<Self::Output>;\n-}\n-\n-impl<T, R> EvalQuery for Query<T, R>\n-where\n-    T: Hash + Send + Sync + 'static,\n-    R: Hash + Send + Sync + 'static,\n-{\n-    type Params = T;\n-    type Output = R;\n-    fn query_type(&self) -> salsa::QueryTypeId {\n-        salsa::QueryTypeId(self.0)\n-    }\n-    fn f(&self) -> salsa::QueryFn<State, Data> {\n-        let f = self.1;\n-        Box::new(move |ctx, data| {\n-            let ctx = QueryCtx { imp: ctx };\n-            let data: &T = data.downcast_ref().unwrap();\n-            let res = f(ctx, data);\n-            let h = hash(&res);\n-            (Arc::new(res), salsa::OutputFingerprint(h))\n-        })\n-    }\n-    fn get(&self, ctx: &QueryCtx, params: Self::Params) -> Arc<Self::Output> {\n-        let query_id = salsa::QueryId(\n-            self.query_type(),\n-            salsa::InputFingerprint(hash(&params)),\n-        );\n-        let res = ctx.imp.get(query_id, Arc::new(params));\n-        res.downcast().unwrap()\n-    }\n-}\n-\n-pub(super) struct QueryRegistry {\n-    config: Option<salsa::QueryConfig<State, Data>>,\n-    names: FxHashMap<salsa::QueryTypeId, &'static str>,\n-}\n-\n-impl QueryRegistry {\n-    pub(super) fn new() -> QueryRegistry {\n-        let mut config = salsa::QueryConfig::<State, Data>::new();\n-        config = config.with_ground_query(\n-            FILE_TEXT, Box::new(|state, params| {\n-                let file_id: &FileId = params.downcast_ref().unwrap();\n-                let res = state.file_map[file_id].clone();\n-                let fingerprint = salsa::OutputFingerprint(hash(&res));\n-                (res, fingerprint)\n-            })\n-        );\n-        config = config.with_ground_query(\n-            FILE_SET, Box::new(|state, _params| {\n-                let file_ids: Vec<FileId> = state.file_map.keys().cloned().collect();\n-                let hash = hash(&file_ids);\n-                let file_resolver = state.file_resolver.clone();\n-                let res = (file_ids, file_resolver);\n-                let fingerprint = salsa::OutputFingerprint(hash);\n-                (Arc::new(res), fingerprint)\n-            })\n-        );\n-        let mut names = FxHashMap::default();\n-        names.insert(FILE_TEXT, \"FILE_TEXT\");\n-        names.insert(FILE_SET, \"FILE_SET\");\n-        QueryRegistry { config: Some(config), names }\n-    }\n-    pub(super) fn add<Q: EvalQuery>(&mut self, q: Q, name: &'static str) {\n-        let id = q.query_type();\n-        let prev = self.names.insert(id, name);\n-        assert!(prev.is_none(), \"duplicate query: {:?}\", id);\n-        let config = self.config.take().unwrap();\n-        let config = config.with_query(id, q.f());\n-        self.config= Some(config);\n-    }\n-}\n-\n-fn hash<T: Hash>(x: &T) -> u64 {\n-    let mut hasher = DefaultHasher::new();\n-    x.hash(&mut hasher);\n-    hasher.finish()\n-}\n-\n-const FILE_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(0);\n-pub(super) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n-    let query_id = salsa::QueryId(\n-        FILE_TEXT,\n-        salsa::InputFingerprint(hash(&file_id)),\n-    );\n-    let res = ctx.imp.get(query_id, Arc::new(file_id));\n-    res.downcast().unwrap()\n-}\n-\n-const FILE_SET: salsa::QueryTypeId = salsa::QueryTypeId(1);\n-pub(super) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n-    let query_id = salsa::QueryId(\n-        FILE_SET,\n-        salsa::InputFingerprint(hash(&())),\n-    );\n-    let res = ctx.imp.get(query_id, Arc::new(()));\n-    res.downcast().unwrap()\n-}\n-"}, {"sha": "c1799e3d4a81b2fc09c8f2a1013d49c8ea114b9a", "filename": "crates/ra_analysis/src/module_map.rs", "status": "modified", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs?ref=ee69fddf02b2c8d4b73f9412831f5fcc4fa931a1", "patch": "@@ -32,126 +32,3 @@ fn module_tree(db: &impl ModulesDatabase, (): ()) -> Arc<ModuleTreeDescriptor> {\n     let res = ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.resolver);\n     Arc::new(res)\n }\n-\n-// #[cfg(test)]\n-// mod tests {\n-//     use std::collections::HashMap;\n-//     use im;\n-//     use relative_path::{RelativePath, RelativePathBuf};\n-//     use {\n-//         db::{Db},\n-//         imp::FileResolverImp,\n-//         FileId, FileResolver,\n-//     };\n-//     use super::*;\n-\n-//     #[derive(Debug)]\n-//     struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n-\n-//     impl FileResolver for FileMap {\n-//         fn file_stem(&self, file_id: FileId) -> String {\n-//             self.0[&file_id].file_stem().unwrap().to_string()\n-//         }\n-//         fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n-//             let path = self.0[&file_id].join(rel).normalize();\n-//             self.0.iter()\n-//                 .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n-//                 .next()\n-//         }\n-//     }\n-\n-//     struct Fixture {\n-//         next_file_id: u32,\n-//         fm: im::HashMap<FileId, RelativePathBuf>,\n-//         db: Db,\n-//     }\n-\n-//     impl Fixture {\n-//         fn new() -> Fixture {\n-//             Fixture {\n-//                 next_file_id: 1,\n-//                 fm: im::HashMap::new(),\n-//                 db: Db::new(),\n-//             }\n-//         }\n-//         fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-//             assert!(path.starts_with(\"/\"));\n-//             let file_id = FileId(self.next_file_id);\n-//             self.next_file_id += 1;\n-//             self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n-//             let mut new_state = self.db.state().clone();\n-//             new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n-//             new_state.file_resolver = FileResolverImp::new(\n-//                 Arc::new(FileMap(self.fm.clone()))\n-//             );\n-//             self.db = self.db.with_changes(new_state, &[file_id], true);\n-//             file_id\n-//         }\n-//         fn remove_file(&mut self, file_id: FileId) {\n-//             self.fm.remove(&file_id);\n-//             let mut new_state = self.db.state().clone();\n-//             new_state.file_map.remove(&file_id);\n-//             new_state.file_resolver = FileResolverImp::new(\n-//                 Arc::new(FileMap(self.fm.clone()))\n-//             );\n-//             self.db = self.db.with_changes(new_state, &[file_id], true);\n-//         }\n-//         fn change_file(&mut self, file_id: FileId, new_text: &str) {\n-//             let mut new_state = self.db.state().clone();\n-//             new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n-//             self.db = self.db.with_changes(new_state, &[file_id], false);\n-//         }\n-//         fn check_parent_modules(\n-//             &self,\n-//             file_id: FileId,\n-//             expected: &[FileId],\n-//             queries: &[(&'static str, u64)]\n-//         ) {\n-//             let (tree, events) = self.db.trace_query(|ctx| module_tree(ctx));\n-//             let actual = tree.parent_modules(file_id)\n-//                 .into_iter()\n-//                 .map(|link| link.owner(&tree))\n-//                 .collect::<Vec<_>>();\n-//             assert_eq!(actual.as_slice(), expected);\n-//             let mut counts = HashMap::new();\n-//             events.into_iter()\n-//                .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n-//             for &(query_id, expected_count) in queries.iter() {\n-//                 let actual_count = *counts.get(&query_id).unwrap_or(&0);\n-//                 assert_eq!(\n-//                     actual_count,\n-//                     expected_count,\n-//                     \"counts for {} differ\",\n-//                     query_id,\n-//                 )\n-//             }\n-\n-//         }\n-//     }\n-\n-//     #[test]\n-//     fn test_parent_module() {\n-//         let mut f = Fixture::new();\n-//         let foo = f.add_file(\"/foo.rs\", \"\");\n-//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-//         let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n-\n-//         f.change_file(lib, \"\");\n-//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-//         f.change_file(lib, \"mod foo;\");\n-//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-\n-//         f.change_file(lib, \"mod bar;\");\n-//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-//         f.change_file(lib, \"mod foo;\");\n-//         f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-\n-//         f.remove_file(lib);\n-//         f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n-//     }\n-// }"}, {"sha": "613bf1e61031f40fd28eba72fd39396808150d5e", "filename": "crates/ra_analysis/src/queries.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7503c5528f20f7404bac6f70bcf2120edb54dc52/crates%2Fra_analysis%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7503c5528f20f7404bac6f70bcf2120edb54dc52/crates%2Fra_analysis%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fqueries.rs?ref=7503c5528f20f7404bac6f70bcf2120edb54dc52", "patch": "@@ -1,39 +0,0 @@\n-use std::sync::Arc;\n-use ra_syntax::File;\n-use ra_editor::LineIndex;\n-use crate::{\n-    FileId,\n-    db::{Query, QueryCtx, QueryRegistry},\n-    symbol_index::SymbolIndex,\n-};\n-\n-pub(crate) use crate::db::{file_text, file_set};\n-\n-pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n-    (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n-}\n-pub(crate) fn file_lines(ctx: QueryCtx, file_id: FileId) -> Arc<LineIndex> {\n-    ctx.get(FILE_LINES, file_id)\n-}\n-pub(crate) fn file_symbols(ctx: QueryCtx, file_id: FileId) -> Arc<SymbolIndex> {\n-    ctx.get(FILE_SYMBOLS, file_id)\n-}\n-\n-const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n-    let text = file_text(ctx, *file_id);\n-    File::parse(&*text)\n-});\n-const FILE_LINES: Query<FileId, LineIndex> = Query(17, |ctx, file_id: &FileId| {\n-    let text = file_text(ctx, *file_id);\n-    LineIndex::new(&*text)\n-});\n-const FILE_SYMBOLS: Query<FileId, SymbolIndex> = Query(18, |ctx, file_id: &FileId| {\n-    let syntax = file_syntax(ctx, *file_id);\n-    SymbolIndex::for_file(*file_id, syntax)\n-});\n-\n-pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n-    reg.add(FILE_SYNTAX, \"FILE_SYNTAX\");\n-    reg.add(FILE_LINES, \"FILE_LINES\");\n-    reg.add(FILE_SYMBOLS, \"FILE_SYMBOLS\");\n-}"}]}