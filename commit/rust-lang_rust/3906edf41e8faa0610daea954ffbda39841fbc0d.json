{"sha": "3906edf41e8faa0610daea954ffbda39841fbc0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MDZlZGY0MWU4ZmFhMDYxMGRhZWE5NTRmZmJkYTM5ODQxZmJjMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-09T09:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-09T09:20:43Z"}, "message": "Auto merge of #25212 - pnkfelix:dropck-box-trait, r=nikomatsakis\n\ndropck: must assume `Box<Trait + 'a>` has a destructor of interest.\r\n\r\nFix #25199.\r\n\r\nThis detail was documented in [RFC 769]; the implementation was just missing.\r\n\r\n[breaking-change]\r\n\r\nThe breakage here falls into both obvious and non-obvious cases.\r\n\r\nThe obvious case: if you were relying on the unsoundness this exposes (namely being able to reference dead storage from a destructor, by doing it via a boxed trait object bounded by the lifetime of the dead storage), then this change disallows that.\r\n\r\nThe non-obvious cases: The way dropck works, it causes lifetimes to be extended to longer extents than they covered before. I.e.  lifetimes that are attached as trait-bounds may become longer than they were previously.\r\n\r\n* This includes lifetimes that are only *implicitly* attached as trait-bounds (due to [RFC 599]). So you may have code that was e.g. taking a parameter of type `&'a Box<Trait>` (which expands to `&'a Box<Trait+'a>`), that now may need to be assigned type `&'a Box<Trait+'static>` to ensure that `'a` is not inadvertantly inferred to a region that is actually too long.  (See commit ee06263 for an example of this.)\r\n\r\n[RFC 769]: https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#the-drop-check-rule\r\n\r\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md", "tree": {"sha": "2bca2356418aa51281315baa1fff9b7cf5a3c453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bca2356418aa51281315baa1fff9b7cf5a3c453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3906edf41e8faa0610daea954ffbda39841fbc0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3906edf41e8faa0610daea954ffbda39841fbc0d", "html_url": "https://github.com/rust-lang/rust/commit/3906edf41e8faa0610daea954ffbda39841fbc0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3906edf41e8faa0610daea954ffbda39841fbc0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95400c51c31877ea4699adc051477edccb5cfbca", "url": "https://api.github.com/repos/rust-lang/rust/commits/95400c51c31877ea4699adc051477edccb5cfbca", "html_url": "https://github.com/rust-lang/rust/commit/95400c51c31877ea4699adc051477edccb5cfbca"}, {"sha": "8654dfbc2f4c1a6da7c9b8f9cce3cfa9f4bc46bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8654dfbc2f4c1a6da7c9b8f9cce3cfa9f4bc46bb", "html_url": "https://github.com/rust-lang/rust/commit/8654dfbc2f4c1a6da7c9b8f9cce3cfa9f4bc46bb"}], "stats": {"total": 508, "additions": 393, "deletions": 115}, "files": [{"sha": "fd90d662bd141d5eb4e9343adc455e8757f39b9a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 153, "deletions": 106, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -396,19 +396,24 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             }\n         };\n \n-        let opt_type_did = match typ.sty {\n-            ty::ty_struct(struct_did, _) => Some(struct_did),\n-            ty::ty_enum(enum_did, _) => Some(enum_did),\n-            _ => None,\n+        let dtor_kind = match typ.sty {\n+            ty::ty_enum(def_id, _) |\n+            ty::ty_struct(def_id, _) => {\n+                match destructor_for_type.get(&def_id) {\n+                    Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n+                    None => DtorKind::PureRecur,\n+                }\n+            }\n+            ty::ty_trait(ref ty_trait) => {\n+                DtorKind::Unknown(ty_trait.bounds.clone())\n+            }\n+            _ => DtorKind::PureRecur,\n         };\n \n-        let opt_dtor =\n-            opt_type_did.and_then(|did| destructor_for_type.get(&did));\n-\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} opt_dtor: {:?} xref: {}\",\n+                {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, opt_dtor, xref_depth);\n+               typ.repr(rcx.tcx()), scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -439,102 +444,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         // simply skip the `type_must_outlive` call entirely (but\n         // resume the recursive checking of the type-substructure).\n \n-        let has_dtor_of_interest;\n-\n-        if let Some(&dtor_method_did) = opt_dtor {\n-            let impl_did = ty::impl_of_method(rcx.tcx(), dtor_method_did)\n-                .unwrap_or_else(|| {\n-                    rcx.tcx().sess.span_bug(\n-                        span, \"no Drop impl found for drop method\")\n-                });\n-\n-            let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n-            let dtor_generics = dtor_typescheme.generics;\n-\n-            let mut has_pred_of_interest = false;\n-\n-            let mut seen_items = Vec::new();\n-            let mut items_to_inspect = vec![impl_did];\n-            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n-                if seen_items.contains(&item_def_id) {\n-                    continue;\n-                }\n-\n-                for pred in ty::lookup_predicates(rcx.tcx(), item_def_id).predicates {\n-                    let result = match pred {\n-                        ty::Predicate::Equate(..) |\n-                        ty::Predicate::RegionOutlives(..) |\n-                        ty::Predicate::TypeOutlives(..) |\n-                        ty::Predicate::Projection(..) => {\n-                            // For now, assume all these where-clauses\n-                            // may give drop implementation capabilty\n-                            // to access borrowed data.\n-                            true\n-                        }\n-\n-                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                            let def_id = t_pred.trait_ref.def_id;\n-                            if ty::trait_items(rcx.tcx(), def_id).len() != 0 {\n-                                // If trait has items, assume it adds\n-                                // capability to access borrowed data.\n-                                true\n-                            } else {\n-                                // Trait without items is itself\n-                                // uninteresting from POV of dropck.\n-                                //\n-                                // However, may have parent w/ items;\n-                                // so schedule checking of predicates,\n-                                items_to_inspect.push(def_id);\n-                                // and say \"no capability found\" for now.\n-                                false\n-                            }\n-                        }\n-                    };\n-\n-                    if result {\n-                        has_pred_of_interest = true;\n-                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                               typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n-                        break 'items;\n-                    }\n-                }\n-\n-                seen_items.push(item_def_id);\n-            }\n-\n-            // In `impl<'a> Drop ...`, we automatically assume\n-            // `'a` is meaningful and thus represents a bound\n-            // through which we could reach borrowed data.\n-            //\n-            // FIXME (pnkfelix): In the future it would be good to\n-            // extend the language to allow the user to express,\n-            // in the impl signature, that a lifetime is not\n-            // actually used (something like `where 'a: ?Live`).\n-            let has_region_param_of_interest =\n-                dtor_generics.has_region_params(subst::TypeSpace);\n-\n-            has_dtor_of_interest =\n-                has_region_param_of_interest ||\n-                has_pred_of_interest;\n-\n-            if has_dtor_of_interest {\n-                debug!(\"typ: {} has interesting dtor, due to \\\n-                        region params: {} or pred: {}\",\n-                       typ.repr(rcx.tcx()),\n-                       has_region_param_of_interest,\n-                       has_pred_of_interest);\n-            } else {\n-                debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr(rcx.tcx()));\n-            }\n-\n-        } else {\n-            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr(rcx.tcx()));\n-            has_dtor_of_interest = false;\n-        }\n-\n-        if has_dtor_of_interest {\n+        if has_dtor_of_interest(rcx.tcx(), dtor_kind, typ, span) {\n             // If `typ` has a destructor, then we must ensure that all\n             // borrowed data reachable via `typ` must outlive the\n             // parent of `scope`. (It does not suffice for it to\n@@ -620,7 +530,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n                 ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n                     // Don't recurse, since references, pointers,\n-                    // boxes, and bare functions don't own instances\n+                    // and bare functions don't own instances\n                     // of the types appearing within them.\n                     walker.skip_current_subtree();\n                 }\n@@ -639,3 +549,140 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n     return Ok(());\n }\n+\n+enum DtorKind<'tcx> {\n+    // Type has an associated drop method with this def id\n+    KnownDropMethod(ast::DefId),\n+\n+    // Type has no destructor (or its dtor is known to be pure\n+    // with respect to lifetimes), though its *substructure*\n+    // may carry a destructor.\n+    PureRecur,\n+\n+    // Type may have impure destructor that is unknown;\n+    // e.g. `Box<Trait+'a>`\n+    Unknown(ty::ExistentialBounds<'tcx>),\n+}\n+\n+fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              dtor_kind: DtorKind,\n+                              typ: ty::Ty<'tcx>,\n+                              span: Span) -> bool {\n+    let has_dtor_of_interest: bool;\n+\n+    match dtor_kind {\n+        DtorKind::PureRecur => {\n+            has_dtor_of_interest = false;\n+            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n+                   typ.repr(tcx));\n+        }\n+        DtorKind::Unknown(bounds) => {\n+            match bounds.region_bound {\n+                ty::ReStatic => {\n+                    debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                ty::ReEmpty => {\n+                    debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                r => {\n+                    debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n+                           typ.repr(tcx), r.repr(tcx));\n+                    has_dtor_of_interest = true;\n+                }\n+            }\n+        }\n+        DtorKind::KnownDropMethod(dtor_method_did) => {\n+            let impl_did = ty::impl_of_method(tcx, dtor_method_did)\n+                .unwrap_or_else(|| {\n+                    tcx.sess.span_bug(\n+                        span, \"no Drop impl found for drop method\")\n+                });\n+\n+            let dtor_typescheme = ty::lookup_item_type(tcx, impl_did);\n+            let dtor_generics = dtor_typescheme.generics;\n+\n+            let mut has_pred_of_interest = false;\n+\n+            let mut seen_items = Vec::new();\n+            let mut items_to_inspect = vec![impl_did];\n+            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n+                if seen_items.contains(&item_def_id) {\n+                    continue;\n+                }\n+\n+                for pred in ty::lookup_predicates(tcx, item_def_id).predicates {\n+                    let result = match pred {\n+                        ty::Predicate::Equate(..) |\n+                        ty::Predicate::RegionOutlives(..) |\n+                        ty::Predicate::TypeOutlives(..) |\n+                        ty::Predicate::Projection(..) => {\n+                            // For now, assume all these where-clauses\n+                            // may give drop implementation capabilty\n+                            // to access borrowed data.\n+                            true\n+                        }\n+\n+                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                            let def_id = t_pred.trait_ref.def_id;\n+                            if ty::trait_items(tcx, def_id).len() != 0 {\n+                                // If trait has items, assume it adds\n+                                // capability to access borrowed data.\n+                                true\n+                            } else {\n+                                // Trait without items is itself\n+                                // uninteresting from POV of dropck.\n+                                //\n+                                // However, may have parent w/ items;\n+                                // so schedule checking of predicates,\n+                                items_to_inspect.push(def_id);\n+                                // and say \"no capability found\" for now.\n+                                false\n+                            }\n+                        }\n+                    };\n+\n+                    if result {\n+                        has_pred_of_interest = true;\n+                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                               typ.repr(tcx), pred.repr(tcx));\n+                        break 'items;\n+                    }\n+                }\n+\n+                seen_items.push(item_def_id);\n+            }\n+\n+            // In `impl<'a> Drop ...`, we automatically assume\n+            // `'a` is meaningful and thus represents a bound\n+            // through which we could reach borrowed data.\n+            //\n+            // FIXME (pnkfelix): In the future it would be good to\n+            // extend the language to allow the user to express,\n+            // in the impl signature, that a lifetime is not\n+            // actually used (something like `where 'a: ?Live`).\n+            let has_region_param_of_interest =\n+                dtor_generics.has_region_params(subst::TypeSpace);\n+\n+            has_dtor_of_interest =\n+                has_region_param_of_interest ||\n+                has_pred_of_interest;\n+\n+            if has_dtor_of_interest {\n+                debug!(\"typ: {} has interesting dtor, due to \\\n+                        region params: {} or pred: {}\",\n+                       typ.repr(tcx),\n+                       has_region_param_of_interest,\n+                       has_pred_of_interest);\n+            } else {\n+                debug!(\"typ: {} has dtor, but it is uninteresting\",\n+                       typ.repr(tcx));\n+            }\n+        }\n+    }\n+\n+    return has_dtor_of_interest;\n+}"}, {"sha": "69f40d7e7befe2b8850b252c946b9fa9e9da159a", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -61,7 +61,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n+    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])\n                -> Option<T> {\n         for pf in parsers.iter_mut() {\n             match self.read_atomically(|p: &mut Parser| pf(p)) {"}, {"sha": "c3f1b9748155fd4a4edbf9fb3fd7fd5de3482721", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -986,9 +986,10 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     let fm = fresh_mark();\n                     let marked_before = mark_tts(&tts[..], fm);\n                     let mac_span = fld.cx.original_span();\n-                    let expanded = match expander.expand(fld.cx,\n-                                        mac_span,\n-                                        &marked_before[..]).make_pat() {\n+                    let pat = expander.expand(fld.cx,\n+                                              mac_span,\n+                                              &marked_before[..]).make_pat();\n+                    let expanded = match pat {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err("}, {"sha": "929f2a6abd6b8c5adde72337394d39eebcda3702", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -73,7 +73,11 @@ pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    string_to_parser(&new_parse_sess(), source_str).parse_pat()\n+    // Binding `sess` and `parser` works around dropck-injected\n+    // region-inference issues; see #25212, #22323, #22321.\n+    let sess = new_parse_sess();\n+    let mut parser = string_to_parser(&sess, source_str);\n+    parser.parse_pat()\n }\n \n /// Convert a vector of strings to a vector of ast::Ident's"}, {"sha": "6e543d017f26045b10177d560f656d0531d499bc", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using trait\n+// objects to hide the the cross-references.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+trait Obj<'a> : HasId {\n+    fn set0(&self, b: &'a Box<Obj<'a>>);\n+    fn set1(&self, b: &'a Box<Obj<'a>>);\n+}\n+\n+struct O<'a> {\n+    id: Id,\n+    obj0: CheckId<Cell<Option<&'a Box<Obj<'a>>>>>,\n+    obj1: CheckId<Cell<Option<&'a Box<Obj<'a>>>>>,\n+}\n+\n+impl<'a> HasId for O<'a> {\n+    fn count(&self) -> usize { self.id.count() }\n+}\n+\n+impl<'a> O<'a> {\n+    fn new() -> Box<O<'a>> {\n+        Box::new(O {\n+            id: Id::new(),\n+            obj0: CheckId(Cell::new(None)),\n+            obj1: CheckId(Cell::new(None)),\n+        })\n+    }\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a Box<Obj<'a>>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> Obj<'a> for O<'a> {\n+    fn set0(&self, b: &'a Box<Obj<'a>>) {\n+        self.obj0.v.set(Some(b))\n+    }\n+    fn set1(&self, b: &'a Box<Obj<'a>>) {\n+        self.obj1.v.set(Some(b))\n+    }\n+}\n+\n+\n+fn f() {\n+    let (o1, o2, o3): (Box<Obj>, Box<Obj>, Box<Obj>) = (O::new(), O::new(), O::new());\n+    o1.set0(&o2); //~ ERROR `o2` does not live long enough\n+    o1.set1(&o3); //~ ERROR `o3` does not live long enough\n+    o2.set0(&o2); //~ ERROR `o2` does not live long enough\n+    o2.set1(&o3); //~ ERROR `o3` does not live long enough\n+    o3.set0(&o1); //~ ERROR `o1` does not live long enough\n+    o3.set1(&o2); //~ ERROR `o2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "74ea1ca2947f2a699ce80abe460b12067ad2ee84", "filename": "src/test/compile-fail/issue-25199.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25199.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue 25199: Check that one cannot hide a\n+// destructor's access to borrowed data behind a boxed trait object.\n+//\n+// Prior to fixing Issue 25199, this example was able to be compiled\n+// with rustc, and thus when you ran it, you would see the `Drop` impl\n+// for `Test` accessing state that had already been dropping (which is\n+// marked explicitly here with checking code within the `Drop` impl\n+// for `VecHolder`, but in the general case could just do unsound\n+// things like accessing memory that has been freed).\n+//\n+// Note that I would have liked to encode my go-to example of cyclic\n+// structure that accesses its neighbors in drop (and thus is\n+// fundamentally unsound) via this trick, but the closest I was able\n+// to come was dropck_trait_cycle_checked.rs, which is not quite as\n+// \"good\" as this regression test because the encoding of that example\n+// was forced to attach a lifetime to the trait definition itself\n+// (`trait Obj<'a>`) while *this* example is solely\n+\n+use std::cell::RefCell;\n+\n+trait Obj { }\n+\n+struct VecHolder {\n+    v: Vec<(bool, &'static str)>,\n+}\n+\n+impl Drop for VecHolder {\n+    fn drop(&mut self) {\n+        println!(\"Dropping Vec\");\n+        self.v[30].0 = false;\n+        self.v[30].1 = \"invalid access: VecHolder dropped already\";\n+    }\n+}\n+\n+struct Container<'a> {\n+    v: VecHolder,\n+    d: RefCell<Vec<Box<Obj+'a>>>,\n+}\n+\n+impl<'a> Container<'a> {\n+    fn new() -> Container<'a> {\n+        Container {\n+            d: RefCell::new(Vec::new()),\n+            v: VecHolder {\n+                v: vec![(true, \"valid\"); 100]\n+            }\n+        }\n+    }\n+\n+    fn store<T: Obj+'a>(&'a self, val: T) {\n+        self.d.borrow_mut().push(Box::new(val));\n+    }\n+}\n+\n+struct Test<'a> {\n+    test: &'a Container<'a>,\n+}\n+\n+impl<'a> Obj for Test<'a> { }\n+impl<'a> Drop for Test<'a> {\n+    fn drop(&mut self) {\n+        for e in &self.test.v.v {\n+            assert!(e.0, e.1);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let container = Container::new();\n+    let test = Test{test: &container}; //~ ERROR `container` does not live long enough\n+    println!(\"container.v[30]: {:?}\", container.v.v[30]);\n+    container.store(test); //~ ERROR `container` does not live long enough\n+}"}, {"sha": "f73b06653012afd294d024861c13acbc9ca49975", "filename": "src/test/compile-fail/unboxed-closures-failed-recursive-fn-1.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -22,12 +22,24 @@ fn a() {\n     let mut factorial: Option<Box<Fn(u32) -> u32>> = None;\n \n     let f = |x: u32| -> u32 {\n+        //~^ ERROR `factorial` does not live long enough\n+        let g = factorial.as_ref().unwrap();\n+        if x == 0 {1} else {x * g(x-1)}\n+    };\n+\n+    factorial = Some(Box::new(f));\n+}\n+\n+fn b() {\n+    let mut factorial: Option<Box<Fn(u32) -> u32 + 'static>> = None;\n+\n+    let f = |x: u32| -> u32 {\n+        //~^ ERROR closure may outlive the current function, but it borrows `factorial`\n         let g = factorial.as_ref().unwrap();\n         if x == 0 {1} else {x * g(x-1)}\n     };\n \n     factorial = Some(Box::new(f));\n-    //~^ ERROR cannot assign to `factorial` because it is borrowed\n }\n \n fn main() { }"}, {"sha": "679d494a4730203115475882fd05fc8f18aee8ba", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3906edf41e8faa0610daea954ffbda39841fbc0d/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=3906edf41e8faa0610daea954ffbda39841fbc0d", "patch": "@@ -21,7 +21,7 @@ fn foos(_: &[&Foo]) {}\n fn foog<T>(_: &[T], _: &[T]) {}\n \n fn bar(_: [Box<Foo>; 2]) {}\n-fn bars(_: &[Box<Foo>]) {}\n+fn bars(_: &[Box<Foo+'static>]) {}\n \n fn main() {\n     let x: [&Foo; 2] = [&1, &2];\n@@ -45,11 +45,11 @@ fn main() {\n     bar(x);\n     bar([Box::new(1), Box::new(2)]);\n \n-    let x: &[Box<Foo>] = &[Box::new(1), Box::new(2)];\n+    let x: &[Box<Foo+'static>] = &[Box::new(1), Box::new(2)];\n     bars(x);\n     bars(&[Box::new(1), Box::new(2)]);\n \n-    let x: &[Box<Foo>] = &[Box::new(1), Box::new(2)];\n+    let x: &[Box<Foo+'static>] = &[Box::new(1), Box::new(2)];\n     foog(x, &[Box::new(1)]);\n \n     struct T<'a> {"}]}