{"sha": "a1d94d43ac876975e15b5069da1f9b7a81e29733", "node_id": "C_kwDOAAsO6NoAKGExZDk0ZDQzYWM4NzY5NzVlMTViNTA2OWRhMWY5YjdhODFlMjk3MzM", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-30T05:58:34Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-11-05T21:47:51Z"}, "message": "impl condvars for windows", "tree": {"sha": "06c4bb216eb53b00e323ff72203497eba0d747d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06c4bb216eb53b00e323ff72203497eba0d747d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1d94d43ac876975e15b5069da1f9b7a81e29733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d94d43ac876975e15b5069da1f9b7a81e29733", "html_url": "https://github.com/rust-lang/rust/commit/a1d94d43ac876975e15b5069da1f9b7a81e29733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1d94d43ac876975e15b5069da1f9b7a81e29733/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4492c029eff7b42e91e759576ab0c7ca88f873dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4492c029eff7b42e91e759576ab0c7ca88f873dc", "html_url": "https://github.com/rust-lang/rust/commit/4492c029eff7b42e91e759576ab0c7ca88f873dc"}], "stats": {"total": 215, "additions": 185, "deletions": 30}, "files": [{"sha": "48f9e605276e9c20f56801c9fb9cb77ee7d1075f", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -121,8 +121,10 @@ declare_id!(CondvarId);\n struct CondvarWaiter {\n     /// The thread that is waiting on this variable.\n     thread: ThreadId,\n-    /// The mutex on which the thread is waiting.\n-    mutex: MutexId,\n+    /// The mutex or rwlock on which the thread is waiting.\n+    lock: u32,\n+    /// If the lock is shared or exclusive\n+    shared: bool,\n }\n \n /// The conditional variable state.\n@@ -569,16 +571,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark that the thread is waiting on the conditional variable.\n-    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, mutex: MutexId) {\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: u32, shared: bool) {\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, mutex });\n+        waiters.push_back(CondvarWaiter { thread, lock, shared });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional\n     /// variable.\n-    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, MutexId)> {\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, u32, bool)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n@@ -592,7 +594,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n-            (waiter.thread, waiter.mutex)\n+            (waiter.thread, waiter.lock, waiter.shared)\n         })\n     }\n "}, {"sha": "d24e1a56bd527f0b9ac31a222c4972e040a2b1a4", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -696,8 +696,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        if let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        if let Some((thread, mutex, shared)) = this.condvar_signal(id) {\n+            assert!(!shared);\n+            post_cond_signal(this, thread, MutexId::from_u32(mutex))?;\n         }\n \n         Ok(0)\n@@ -710,8 +711,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        while let Some((thread, mutex, shared)) = this.condvar_signal(id) {\n+            assert!(!shared);\n+            post_cond_signal(this, thread, MutexId::from_u32(mutex))?;\n         }\n \n         Ok(0)\n@@ -729,7 +731,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, mutex_id.to_u32(), false);\n \n         Ok(0)\n     }\n@@ -768,7 +770,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, mutex_id.to_u32(), false);\n \n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;"}, {"sha": "e16749c986b168cfb6f77a350e69783271126d12", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -273,6 +273,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.InitOnceComplete(ptr, flags, context)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"SleepConditionVariableSRW\" => {\n+                let [condvar, lock, timeout, flags] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                let result = this.SleepConditionVariableSRW(condvar, lock, timeout, flags, dest)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"WakeConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeConditionVariable(condvar)?;\n+            }\n+            \"WakeAllConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeAllConditionVariable(condvar)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "2eab1794c4f44c227ec646865d4c893ecc02aaf8", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -8,6 +8,38 @@ use crate::*;\n \n const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n+const CONDVAR_ID_OFFSET: u64 = 0;\n+\n+impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Try to reacquire the lock associated with the condition variable after we\n+    /// were signaled.\n+    fn reacquire_cond_lock(\n+        &mut self,\n+        thread: ThreadId,\n+        lock: RwLockId,\n+        shared: bool,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.unblock_thread(thread);\n+\n+        if shared {\n+            if this.rwlock_is_locked(lock) {\n+                this.rwlock_enqueue_and_block_reader(lock, thread);\n+            } else {\n+                this.rwlock_reader_lock(lock, thread);\n+            }\n+        } else {\n+            if this.rwlock_is_write_locked(lock) {\n+                this.rwlock_enqueue_and_block_writer(lock, thread);\n+            } else {\n+                this.rwlock_writer_lock(lock, thread);\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n #[allow(non_snake_case)]\n@@ -327,4 +359,118 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn SleepConditionVariableSRW(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+        let lock_id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(this.machine.clock.now().checked_add(duration).unwrap())\n+        };\n+\n+        let shared_mode = 0x1; // CONDITION_VARIABLE_LOCKMODE_SHARED is not in std\n+        let shared = flags == shared_mode;\n+\n+        let active_thread = this.get_active_thread();\n+\n+        let was_locked = if shared {\n+            this.rwlock_reader_unlock(lock_id, active_thread)\n+        } else {\n+            this.rwlock_writer_unlock(lock_id, active_thread)\n+        };\n+\n+        if !was_locked {\n+            throw_ub_format!(\n+                \"calling SleepConditionVariableSRW with an SRWLock that is not locked by the current thread\"\n+            );\n+        }\n+\n+        this.block_thread(active_thread);\n+        this.condvar_wait(condvar_id, active_thread, lock_id.to_u32(), shared);\n+\n+        if let Some(timeout_time) = timeout_time {\n+            struct Callback<'tcx> {\n+                thread: ThreadId,\n+                condvar_id: CondvarId,\n+                lock_id: RwLockId,\n+                shared: bool,\n+                dest: PlaceTy<'tcx, Provenance>,\n+            }\n+\n+            impl<'tcx> VisitTags for Callback<'tcx> {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    let Callback { thread: _, condvar_id: _, lock_id: _, shared: _, dest } = self;\n+                    dest.visit_tags(visit);\n+                }\n+            }\n+\n+            impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                    this.reacquire_cond_lock(self.thread, self.lock_id, self.shared)?;\n+\n+                    this.condvar_remove_waiter(self.condvar_id, self.thread);\n+\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    this.set_last_error(error_timeout)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    Ok(())\n+                }\n+            }\n+\n+            this.register_timeout_callback(\n+                active_thread,\n+                Time::Monotonic(timeout_time),\n+                Box::new(Callback {\n+                    thread: active_thread,\n+                    condvar_id,\n+                    lock_id,\n+                    shared,\n+                    dest: dest.clone(),\n+                }),\n+            );\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        if let Some((thread, lock, shared)) = this.condvar_signal(condvar_id) {\n+            this.reacquire_cond_lock(thread, RwLockId::from_u32(lock), shared)?;\n+            this.unregister_timeout_callback_if_exists(thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn WakeAllConditionVariable(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        while let Some((thread, lock, shared)) = this.condvar_signal(condvar_id) {\n+            this.reacquire_cond_lock(thread, RwLockId::from_u32(lock), shared)?;\n+            this.unregister_timeout_callback_if_exists(thread);\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "19ea6c130bdd8ceb980076b42b5d45736a4c4a20", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -230,20 +230,8 @@ fn main() {\n     check_once();\n     park_timeout();\n     park_unpark();\n-\n-    if !cfg!(windows) {\n-        // ignore-target-windows: Condvars on Windows are not supported yet\n-        check_barriers();\n-        check_conditional_variables_notify_one();\n-        check_conditional_variables_timed_wait_timeout();\n-        check_conditional_variables_timed_wait_notimeout();\n-    } else {\n-        // We need to fake the same output...\n-        for _ in 0..10 {\n-            println!(\"before wait\");\n-        }\n-        for _ in 0..10 {\n-            println!(\"after wait\");\n-        }\n-    }\n+    check_barriers();\n+    check_conditional_variables_notify_one();\n+    check_conditional_variables_timed_wait_timeout();\n+    check_conditional_variables_timed_wait_notimeout();\n }"}, {"sha": "c6cff038f81e0eafa5b993d0d0ab84ddc132f9e4", "filename": "src/tools/miri/tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n "}, {"sha": "776bc2057f3501fd9d1773b717bce1e426b8407b", "filename": "src/tools/miri/tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d94d43ac876975e15b5069da1f9b7a81e29733/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=a1d94d43ac876975e15b5069da1f9b7a81e29733", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}]}