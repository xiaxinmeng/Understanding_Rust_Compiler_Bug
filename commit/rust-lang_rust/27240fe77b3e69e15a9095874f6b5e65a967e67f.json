{"sha": "27240fe77b3e69e15a9095874f6b5e65a967e67f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MjQwZmU3N2IzZTY5ZTE1YTkwOTU4NzRmNmI1ZTY1YTk2N2U2N2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-09T03:31:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-09T03:31:33Z"}, "message": "Rollup merge of #64656 - passcod:map-entry-insert, r=Amanieu\n\nImplement (HashMap) Entry::insert as per #60142\n\nImplementation of `Entry::insert` as per @SimonSapin's comment on #60142. This requires a patch to hashbrown:\n\n```diff\ndiff --git a/src/rustc_entry.rs b/src/rustc_entry.rs\nindex fefa5c3..7de8300 100644\n--- a/src/rustc_entry.rs\n+++ b/src/rustc_entry.rs\n@@ -546,6 +546,32 @@ impl<'a, K, V> RustcVacantEntry<'a, K, V> {\n         let bucket = self.table.insert_no_grow(self.hash, (self.key, value));\n         unsafe { &mut bucket.as_mut().1 }\n     }\n+\n+    /// Sets the value of the entry with the RustcVacantEntry's key,\n+    /// and returns a RustcOccupiedEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use hashbrown::HashMap;\n+    /// use hashbrown::hash_map::RustcEntry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let RustcEntry::Vacant(v) = map.rustc_entry(\"poneyland\") {\n+    ///     let o = v.insert_and_return(37);\n+    ///     assert_eq!(o.get(), &37);\n+    /// }\n+    /// ```\n+     #[inline]\n+    pub fn insert_and_return(self, value: V) -> RustcOccupiedEntry<'a, K, V> {\n+        let bucket = self.table.insert_no_grow(self.hash, (self.key, value));\n+        RustcOccupiedEntry {\n+            key: None,\n+            elem: bucket,\n+            table: self.table\n+        }\n+    }\n }\n\n impl<K, V> IterMut<'_, K, V> {\n```\n\nThis is also only an implementation for HashMap. I tried implementing for BTreeMap, but I don't really understand BTreeMap's internals and require more guidance on implementing the equivalent `VacantEntry::insert_and_return` such that it returns an `OccupiedEntry`. Notably, following the original PR's modifications I end up needing a `Handle<NodeRef<marker::Mut<'_>, _, _, marker::LeafOrInternal>, _>` while I only have a `Handle<NodeRef<marker::Mut<'_>, _, _, marker::Internal>, _>` and don't know how to proceed.\n\n(To be clear, I'm not asking for guidance right now; I'd be happy getting only the HashMap implementation \u2014 the subject of this PR \u2014 reviewed and ready, and leave the BTreeMap implementation for a latter PR.)", "tree": {"sha": "c88608970c28f9a69b87ce40bebc324535560d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c88608970c28f9a69b87ce40bebc324535560d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27240fe77b3e69e15a9095874f6b5e65a967e67f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdnVSVCRBK7hj4Ov3rIwAAdHIIADrxJKyPVv45tfGiXJkbuZQO\n2DvcSwtHexiJwjCJWI10sR3OgaVVzBBBOSNKC4g+IzjADAxB7SA/m87O/P0aILds\nBmqpquw84Lg1HnVQTQFgR0a7qrSM7gjyJjYB4n6yQIX7uDIkko9qVpvnEG+a56ig\n8K3+xkXB6MP1zjL58OV1T9gUFHGhCttZ47sVgzX6rN5UMXPKEcMGYUeotI8WWiKZ\ns8iGOUPgSc7ZM64wSUuawlabJ8VIz1ALFPzf2IupdkwhveRSK7xZ7EwNxoOFlQJ4\nKjBeSBjc8+dBM71lDcrVVsyUQ39SgZTpa3InllCO1FjHdgRSmnSOqes7YkUgEJA=\n=RABd\n-----END PGP SIGNATURE-----\n", "payload": "tree c88608970c28f9a69b87ce40bebc324535560d44\nparent b5bd31ec6db6a249311888a93fc176f06dcb6aa6\nparent bdcc21cbc4dabe73662634ffada8d0f353bc1ce9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570591893 +0200\ncommitter GitHub <noreply@github.com> 1570591893 +0200\n\nRollup merge of #64656 - passcod:map-entry-insert, r=Amanieu\n\nImplement (HashMap) Entry::insert as per #60142\n\nImplementation of `Entry::insert` as per @SimonSapin's comment on #60142. This requires a patch to hashbrown:\n\n```diff\ndiff --git a/src/rustc_entry.rs b/src/rustc_entry.rs\nindex fefa5c3..7de8300 100644\n--- a/src/rustc_entry.rs\n+++ b/src/rustc_entry.rs\n@@ -546,6 +546,32 @@ impl<'a, K, V> RustcVacantEntry<'a, K, V> {\n         let bucket = self.table.insert_no_grow(self.hash, (self.key, value));\n         unsafe { &mut bucket.as_mut().1 }\n     }\n+\n+    /// Sets the value of the entry with the RustcVacantEntry's key,\n+    /// and returns a RustcOccupiedEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use hashbrown::HashMap;\n+    /// use hashbrown::hash_map::RustcEntry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let RustcEntry::Vacant(v) = map.rustc_entry(\"poneyland\") {\n+    ///     let o = v.insert_and_return(37);\n+    ///     assert_eq!(o.get(), &37);\n+    /// }\n+    /// ```\n+     #[inline]\n+    pub fn insert_and_return(self, value: V) -> RustcOccupiedEntry<'a, K, V> {\n+        let bucket = self.table.insert_no_grow(self.hash, (self.key, value));\n+        RustcOccupiedEntry {\n+            key: None,\n+            elem: bucket,\n+            table: self.table\n+        }\n+    }\n }\n\n impl<K, V> IterMut<'_, K, V> {\n```\n\nThis is also only an implementation for HashMap. I tried implementing for BTreeMap, but I don't really understand BTreeMap's internals and require more guidance on implementing the equivalent `VacantEntry::insert_and_return` such that it returns an `OccupiedEntry`. Notably, following the original PR's modifications I end up needing a `Handle<NodeRef<marker::Mut<'_>, _, _, marker::LeafOrInternal>, _>` while I only have a `Handle<NodeRef<marker::Mut<'_>, _, _, marker::Internal>, _>` and don't know how to proceed.\n\n(To be clear, I'm not asking for guidance right now; I'd be happy getting only the HashMap implementation \u2014 the subject of this PR \u2014 reviewed and ready, and leave the BTreeMap implementation for a latter PR.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27240fe77b3e69e15a9095874f6b5e65a967e67f", "html_url": "https://github.com/rust-lang/rust/commit/27240fe77b3e69e15a9095874f6b5e65a967e67f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27240fe77b3e69e15a9095874f6b5e65a967e67f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "html_url": "https://github.com/rust-lang/rust/commit/b5bd31ec6db6a249311888a93fc176f06dcb6aa6"}, {"sha": "bdcc21cbc4dabe73662634ffada8d0f353bc1ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcc21cbc4dabe73662634ffada8d0f353bc1ce9", "html_url": "https://github.com/rust-lang/rust/commit/bdcc21cbc4dabe73662634ffada8d0f353bc1ce9"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "217ce65c1963cfdfdc1e792bffe8df9f7f21ef6c", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27240fe77b3e69e15a9095874f6b5e65a967e67f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/27240fe77b3e69e15a9095874f6b5e65a967e67f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=27240fe77b3e69e15a9095874f6b5e65a967e67f", "patch": "@@ -107,6 +107,12 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b671c8fb71b457dd4ae18c4ba1e59aa81793daacc361d82fcd410cef0d491875\"\n+\n [[package]]\n name = \"backtrace\"\n version = \"0.3.37\"\n@@ -1269,7 +1275,7 @@ version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n dependencies = [\n- \"hashbrown\",\n+ \"hashbrown 0.5.0\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"pest\",\n@@ -1286,10 +1292,19 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6587d09be37fb98a11cb08b9000a3f592451c1b1b613ca69d949160e313a430a\"\n+dependencies = [\n+ \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n- \"serde\",\n ]\n \n [[package]]\n@@ -4109,7 +4124,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown\",\n+ \"hashbrown 0.6.1\",\n  \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\","}, {"sha": "5309af6f4c342eb9e99f67b4135506ff750bd18f", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27240fe77b3e69e15a9095874f6b5e65a967e67f/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27240fe77b3e69e15a9095874f6b5e65a967e67f/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=27240fe77b3e69e15a9095874f6b5e65a967e67f", "patch": "@@ -23,7 +23,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.6.1\", default-features = false, features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace_rs]\n package = \"backtrace\""}, {"sha": "fcca112563d2da04ae415174cc2d888b8b4404b7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27240fe77b3e69e15a9095874f6b5e65a967e67f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27240fe77b3e69e15a9095874f6b5e65a967e67f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=27240fe77b3e69e15a9095874f6b5e65a967e67f", "patch": "@@ -2030,6 +2030,31 @@ impl<'a, K, V> Entry<'a, K, V> {\n             Vacant(entry) => Vacant(entry),\n         }\n     }\n+\n+    /// Sets the value of the entry, and returns an OccupiedEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(entry_insert)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, String> = HashMap::new();\n+    /// let entry = map.entry(\"poneyland\").insert(\"hoho\".to_string());\n+    ///\n+    /// assert_eq!(entry.key(), &\"poneyland\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"entry_insert\", issue = \"65225\")]\n+    pub fn insert(self, value: V) -> OccupiedEntry<'a, K, V> {\n+        match self {\n+            Occupied(mut entry) => {\n+                entry.insert(value);\n+                entry\n+            },\n+            Vacant(entry) => entry.insert_entry(value),\n+        }\n+    }\n }\n \n impl<'a, K, V: Default> Entry<'a, K, V> {\n@@ -2347,6 +2372,28 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.base.insert(value)\n     }\n+\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns an OccupiedEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n+    #[inline]\n+    fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n+        let base = self.base.insert_entry(value);\n+        OccupiedEntry { base }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}