{"sha": "05e2c131c46a835f0de2cd03208cddb310877ed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZTJjMTMxYzQ2YTgzNWYwZGUyY2QwMzIwOGNkZGIzMTA4NzdlZDI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-22T13:44:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:48Z"}, "message": "changing ctypes:: to libc:: and impl of uv::direct::write()", "tree": {"sha": "e7b1229b8967e585865a5ec562b23af3adf0d6fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7b1229b8967e585865a5ec562b23af3adf0d6fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05e2c131c46a835f0de2cd03208cddb310877ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05e2c131c46a835f0de2cd03208cddb310877ed2", "html_url": "https://github.com/rust-lang/rust/commit/05e2c131c46a835f0de2cd03208cddb310877ed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05e2c131c46a835f0de2cd03208cddb310877ed2/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af08aba5736aacae6662a2ac586bb559f0704cdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/af08aba5736aacae6662a2ac586bb559f0704cdc", "html_url": "https://github.com/rust-lang/rust/commit/af08aba5736aacae6662a2ac586bb559f0704cdc"}], "stats": {"total": 139, "additions": 73, "deletions": 66}, "files": [{"sha": "96e8b10c5f21838ebfa7b8df8ad6625829cda956", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/05e2c131c46a835f0de2cd03208cddb310877ed2/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e2c131c46a835f0de2cd03208cddb310877ed2/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=05e2c131c46a835f0de2cd03208cddb310877ed2", "patch": "@@ -76,19 +76,19 @@ enum uv_handle_type {\n     UV_FS_EVENT\n }\n \n-type handle_type = ctypes::enum;\n+type handle_type = libc::c_uint;\n \n type uv_handle_fields = {\n-   loop_handle: *ctypes::void,\n+   loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n-   mutable data: *ctypes::void,\n+   mutable data: *libc::c_void,\n };\n \n // unix size: 8\n type uv_err_t = {\n-    code: ctypes::c_int,\n-    sys_errno_: ctypes::c_int\n+    code: libc::c_int,\n+    sys_errno_: libc::c_int\n };\n \n // don't create one of these directly. instead,\n@@ -138,7 +138,7 @@ fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n \n #[cfg(target_os = \"win32\")]\n type uv_tcp_t = {\n-    loop_handle: *ctypes::void\n+    loop_handle: *libc::c_void\n };\n #[cfg(target_os = \"win32\")]\n fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n@@ -170,14 +170,14 @@ fn gen_stub_uv_connect_t() -> uv_connect_t {\n #[cfg(target_os = \"freebsd\")]\n type uv_buf_t = {\n     base: *u8,\n-    len: ctypes::size_t\n+    len: libc::size_t\n };\n // no gen stub method.. should create\n // it via uv::direct::buf_init()\n \n #[cfg(target_os = \"win32\")]\n type uv_connect_t = {\n-    loop_handle: *ctypes::void\n+    loop_handle: *libc::c_void\n };\n #[cfg(target_os = \"win32\")]\n fn gen_stub_uv_connect_t() -> uv_connect_t {\n@@ -210,7 +210,7 @@ fn gen_stub_uv_write_t() -> uv_write_t {\n }\n #[cfg(target_os = \"win32\")]\n type uv_write_t = {\n-    loop_handle: *ctypes::void\n+    loop_handle: *libc::c_void\n };\n #[cfg(target_os = \"win32\")]\n fn gen_stub_uv_write_t() -> uv_write_t {\n@@ -268,77 +268,82 @@ native mod rustrt {\n     ////////////\n     // NOT IN rustrt.def.in\n     ////////////\n-    fn rust_uv_free(ptr: *ctypes::void);\n+    fn rust_uv_free(ptr: *libc::c_void);\n     fn rust_uv_tcp_init(\n-        loop_handle: *ctypes::void,\n-        handle_ptr: *uv_tcp_t) -> ctypes::c_int;\n-    fn rust_uv_buf_init(base: *u8, len: ctypes::size_t)\n-        -> *ctypes::void;\n-    fn rust_uv_last_error(loop_handle: *ctypes::void) -> uv_err_t;\n-    fn rust_uv_ip4_addr(ip: *u8, port: ctypes::c_int)\n-        -> *ctypes::void;\n+        loop_handle: *libc::c_void,\n+        handle_ptr: *uv_tcp_t) -> libc::c_int;\n+    fn rust_uv_buf_init(base: *u8, len: libc::size_t)\n+        -> *libc::c_void;\n+    fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n+    fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n+        -> *libc::c_void;\n     fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                            tcp_handle_ptr: *uv_tcp_t,\n-                           addr: *ctypes::void,\n-                           after_cb: *u8) -> ctypes::c_int;\n+                           addr: *libc::c_void,\n+                           after_cb: *u8) -> libc::c_int;\n+    fn rust_uv_write(req: *libc::c_void, stream: *libc::c_void,\n+             buf_in: *uv_buf_t, buf_cnt: libc::c_int,\n+             cb: *u8) -> libc::c_int;\n \n     // sizeof testing helpers\n-    fn rust_uv_helper_uv_tcp_t_size() -> ctypes::c_uint;\n-    fn rust_uv_helper_uv_connect_t_size() -> ctypes::c_uint;\n-    fn rust_uv_helper_uv_buf_t_size() -> ctypes::c_uint;\n-    fn rust_uv_helper_uv_write_t_size() -> ctypes::c_uint;\n-    fn rust_uv_helper_uv_err_t_size() -> ctypes::c_uint;\n-    fn rust_uv_helper_sockaddr_in_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n \n     // data accessors for rust-mapped uv structs\n     fn rust_uv_get_stream_handle_for_connect(connect: *uv_connect_t)\n         -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *ctypes::void)\n-        -> *ctypes::void;\n-    fn rust_uv_get_data_for_uv_handle(handle: *ctypes::void)\n-        -> *ctypes::void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *ctypes::void,\n-                                      data: *ctypes::void);\n-    fn rust_uv_get_data_for_req(req: *ctypes::void) -> *ctypes::void;\n-    fn rust_uv_set_data_for_req(req: *ctypes::void,\n-                                data: *ctypes::void);\n+    fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n+                                      data: *libc::c_void);\n+    fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n+    fn rust_uv_set_data_for_req(req: *libc::c_void,\n+                                data: *libc::c_void);\n }\n \n // this module is structured around functions that directly\n // expose libuv functionality and data structures. for use\n // in higher level mappings\n mod direct {\n-    unsafe fn loop_new() -> *ctypes::void {\n+    unsafe fn loop_new() -> *libc::c_void {\n         ret rustrt::rust_uv_loop_new();\n     }\n \n-    unsafe fn loop_delete(loop_handle: *ctypes::void) {\n+    unsafe fn loop_delete(loop_handle: *libc::c_void) {\n         rustrt::rust_uv_loop_delete(loop_handle);\n     }\n \n-    unsafe fn run(loop_handle: *ctypes::void) {\n+    unsafe fn run(loop_handle: *libc::c_void) {\n         rustrt::rust_uv_run(loop_handle);\n     }\n \n-    unsafe fn tcp_init(loop_handle: *ctypes::void, handle: *uv_tcp_t)\n-        -> ctypes::c_int {\n+    unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n+        -> libc::c_int {\n         ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n     }\n     unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                           tcp_handle_ptr: *uv_tcp_t,\n-                          address: *ctypes::void,\n+                          address: *libc::c_void,\n                           after_connect_cb: *u8)\n-    -> ctypes::c_int {\n+    -> libc::c_int {\n         ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     address, after_connect_cb);\n     }\n \n-    unsafe fn write(req: *ctypes::void, stream: *ctypes::void,\n-             buf: *[uv_buf_t], cb: *u8) -> ctypes::c_int {\n-        ret rustrt::rust_uv_write(\n+    unsafe fn write(req: *libc::c_void, stream: *libc::c_void,\n+             buf_in: *[uv_buf_t], cb: *u8) -> libc::c_int {\n+        let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n+        let buf_cnt = vec::len(*buf_in) as i32;\n+        ret rustrt::rust_uv_write(req, stream, buf_ptr, buf_cnt, cb);\n     }\n \n-    unsafe fn uv_last_error(loop_handle: *ctypes::void) -> uv_err_t {\n+    unsafe fn uv_last_error(loop_handle: *libc::c_void) -> uv_err_t {\n         ret rustrt::rust_uv_last_error(loop_handle);\n     }\n \n@@ -352,29 +357,29 @@ mod direct {\n     unsafe fn write_t() -> uv_write_t {\n         ret gen_stub_uv_write_t();\n     }\n-    unsafe fn get_loop_for_uv_handle(handle: *ctypes::void)\n-        -> *ctypes::void {\n+    unsafe fn get_loop_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void {\n         ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n     }\n     unsafe fn get_stream_handle_for_connect(connect: *uv_connect_t)\n         -> *uv_stream_t {\n         ret rustrt::rust_uv_get_stream_handle_for_connect(connect);\n     }\n \n-    unsafe fn get_data_for_req(req: *ctypes::void) -> *ctypes::void {\n+    unsafe fn get_data_for_req(req: *libc::c_void) -> *libc::c_void {\n         ret rustrt::rust_uv_get_data_for_req(req);\n     }\n-    unsafe fn set_data_for_req(req: *ctypes::void,\n-                        data: *ctypes::void) {\n+    unsafe fn set_data_for_req(req: *libc::c_void,\n+                        data: *libc::c_void) {\n         rustrt::rust_uv_set_data_for_req(req, data);\n     }\n     // FIXME: see github issue #1402\n-    unsafe fn buf_init(input: *u8, len: uint) -> *ctypes::void {\n+    unsafe fn buf_init(input: *u8, len: uint) -> *libc::c_void {\n         ret rustrt::rust_uv_buf_init(input, len);\n     }\n     // FIXME: see github issue #1402\n-    unsafe fn ip4_addr(ip: str, port: ctypes::c_int)\n-    -> *ctypes::void {\n+    unsafe fn ip4_addr(ip: str, port: libc::c_int)\n+    -> *libc::c_void {\n         let addr_vec = str::bytes(ip);\n         addr_vec += [0u8]; // add null terminator\n         let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n@@ -384,7 +389,7 @@ mod direct {\n     }\n     // this is lame.\n     // FIXME: see github issue #1402\n-    unsafe fn free_1402(ptr: *ctypes::void) {\n+    unsafe fn free_1402(ptr: *libc::c_void) {\n         rustrt::rust_uv_free(ptr);\n     }\n }\n@@ -943,44 +948,46 @@ type request_wrapper = {\n     req_buf: *[uv_buf_t]\n };\n \n-crust fn on_alloc(handle: *ctypes::void,\n-                  suggested_size: ctypes::size_t) -> uv_buf_t\n+crust fn on_alloc(handle: *libc::c_void,\n+                  suggested_size: libc::size_t) -> uv_buf_t\n     unsafe {\n     io::println(\"beginning on_alloc...\");\n     io::println(\"ending on_alloc...\");\n     let new_vec: @[u8] = @[];\n     let ptr = vec::unsafe::to_ptr(*new_vec);\n-    ret direct::buf_init(ptr, vec::len(*new_vec));\n+    let buf = direct::buf_init(ptr, vec::len(*new_vec));\n+    ret *(buf as *uv_buf_t);\n+    \n }\n \n crust fn on_write_complete_cb(write_handle: *uv_write_t,\n-                              status: ctypes::c_int) unsafe {\n+                              status: libc::c_int) unsafe {\n     io::println(\"beginning on_write_complete_cb\");\n     io::println(\"ending on_write_complete_cb\");\n }\n \n crust fn on_connect_cb(connect_handle_ptr: *uv_connect_t,\n-                             status: ctypes::c_int) unsafe {\n+                             status: libc::c_int) unsafe {\n     io::println(#fmt(\"beginning on_connect_cb .. status: %d\",\n                      status as int));\n     let stream = direct::get_stream_handle_for_connect(connect_handle_ptr);\n     if (status == 0i32) {\n         io::println(\"on_connect_cb: in status=0 if..\");\n         let data = direct::get_data_for_req(\n-            connect_handle_ptr as *ctypes::void)\n+            connect_handle_ptr as *libc::c_void)\n             as *request_wrapper;\n-        let write_handle = (*data).write_req as *ctypes::void;\n+        let write_handle = (*data).write_req as *libc::c_void;\n         io::println(#fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n                         stream as int, write_handle as int));\n         direct::write(write_handle,\n-                          stream as *ctypes::void,\n+                          stream as *libc::c_void,\n                           (*data).req_buf,\n                           on_write_complete_cb);\n         io::println(\"on_connect_cb: after direct::write()\");\n     }\n     else {\n         let loop_handle = direct::get_loop_for_uv_handle(\n-            stream as *ctypes::void);\n+            stream as *libc::c_void);\n         let err = direct::uv_last_error(loop_handle);\n     }\n     io::println(\"finishing on_connect_cb\");\n@@ -1016,7 +1023,7 @@ fn impl_uv_tcp_request() unsafe {\n     let addr = direct::ip4_addr(\"173.194.33.40\", 80i32);\n     \n     let tcp_init_result = direct::tcp_init(\n-        test_loop as *ctypes::void, tcp_handle_ptr);\n+        test_loop as *libc::c_void, tcp_handle_ptr);\n     if (tcp_init_result == 0i32) {\n         io::println(\"sucessful tcp_init_result\");\n         // this should set up the connection request..\n@@ -1026,8 +1033,8 @@ fn impl_uv_tcp_request() unsafe {\n         if (tcp_connect_result == 0i32) {\n             // not set the data on the connect_req until its initialized\n             direct::set_data_for_req(\n-                connect_handle_ptr as *ctypes::void,\n-                ptr::addr_of(req) as *ctypes::void);\n+                connect_handle_ptr as *libc::c_void,\n+                ptr::addr_of(req) as *libc::c_void);\n             io::println(\"before run tcp req loop\");\n             direct::run(test_loop);\n             io::println(\"after run tcp req loop\");"}]}