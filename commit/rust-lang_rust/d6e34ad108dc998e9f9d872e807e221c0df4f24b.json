{"sha": "d6e34ad108dc998e9f9d872e807e221c0df4f24b", "node_id": "C_kwDOAAsO6NoAKGQ2ZTM0YWQxMDhkYzk5OGU5ZjlkODcyZTgwN2UyMjFjMGRmNGYyNGI", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-07-15T15:36:19Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-25T18:40:29Z"}, "message": "When recovering from a `:` in a pattern, use adequate AST pattern", "tree": {"sha": "ad1affc39595f4532c89addb5a00b34579999d1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad1affc39595f4532c89addb5a00b34579999d1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6e34ad108dc998e9f9d872e807e221c0df4f24b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e34ad108dc998e9f9d872e807e221c0df4f24b", "html_url": "https://github.com/rust-lang/rust/commit/d6e34ad108dc998e9f9d872e807e221c0df4f24b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6e34ad108dc998e9f9d872e807e221c0df4f24b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "862962b90e59c5c1e217df74de80d3a81eee42f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/862962b90e59c5c1e217df74de80d3a81eee42f4", "html_url": "https://github.com/rust-lang/rust/commit/862962b90e59c5c1e217df74de80d3a81eee42f4"}], "stats": {"total": 194, "additions": 150, "deletions": 44}, "files": [{"sha": "c1f5c569cf09f965f7efb0548828c84e965909aa", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 87, "deletions": 16, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d6e34ad108dc998e9f9d872e807e221c0df4f24b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e34ad108dc998e9f9d872e807e221c0df4f24b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=d6e34ad108dc998e9f9d872e807e221c0df4f24b", "patch": "@@ -3,13 +3,17 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::{self as ast, AttrVec, Attribute, MacCall, Pat, PatField, PatKind, RangeEnd};\n-use rustc_ast::{BindingMode, Expr, ExprKind, Mutability, Path, QSelf, RangeSyntax};\n+use rustc_ast::{\n+    self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n+    PatField, PatKind, Path, PathSegment, QSelf, RangeEnd, RangeSyntax,\n+};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n+use std::mem::take;\n+\n type Expected = Option<&'static str>;\n \n /// `Expected` for function and lambda parameter patterns.\n@@ -101,11 +105,8 @@ impl<'a> Parser<'a> {\n             let mut first_pat = first_pat;\n \n             if let (RecoverColon::Yes, token::Colon) = (ra, &self.token.kind) {\n-                if matches!(\n-                    first_pat.kind,\n-                    PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None)\n-                        | PatKind::Path(..)\n-                ) && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+                if matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n+                    && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n                 {\n                     // The pattern looks like it might be a path with a `::` -> `:` typo:\n                     // `match foo { bar:baz => {} }`\n@@ -126,17 +127,87 @@ impl<'a> Parser<'a> {\n                                     err.cancel();\n                                     *self = snapshot;\n                                 }\n-                                Ok(pat) => {\n+                                Ok(mut pat) => {\n                                     // We've parsed the rest of the pattern.\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"maybe write a path separator here\",\n-                                        \"::\".to_string(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n+                                    let new_span = first_pat.span.to(pat.span);\n+                                    let mut show_sugg = false;\n+                                    match &mut pat.kind {\n+                                        PatKind::Struct(qself @ None, path, ..)\n+                                        | PatKind::TupleStruct(qself @ None, path, _)\n+                                        | PatKind::Path(qself @ None, path) => {\n+                                            match &first_pat.kind {\n+                                                PatKind::Ident(_, ident, _) => {\n+                                                    path.segments.insert(\n+                                                        0,\n+                                                        PathSegment::from_ident(ident.clone()),\n+                                                    );\n+                                                    path.span = new_span;\n+                                                    show_sugg = true;\n+                                                    first_pat = pat;\n+                                                }\n+                                                PatKind::Path(old_qself, old_path) => {\n+                                                    path.segments = old_path\n+                                                        .segments\n+                                                        .iter()\n+                                                        .cloned()\n+                                                        .chain(take(&mut path.segments))\n+                                                        .collect();\n+                                                    path.span = new_span;\n+                                                    *qself = old_qself.clone();\n+                                                    first_pat = pat;\n+                                                    show_sugg = true;\n+                                                }\n+                                                _ => {}\n+                                            }\n+                                        }\n+                                        PatKind::Ident(\n+                                            BindingMode::ByValue(Mutability::Not),\n+                                            ident,\n+                                            None,\n+                                        ) => match &first_pat.kind {\n+                                            PatKind::Ident(_, old_ident, _) => {\n+                                                let path = PatKind::Path(\n+                                                    None,\n+                                                    Path {\n+                                                        span: new_span,\n+                                                        segments: vec![\n+                                                            PathSegment::from_ident(\n+                                                                old_ident.clone(),\n+                                                            ),\n+                                                            PathSegment::from_ident(ident.clone()),\n+                                                        ],\n+                                                        tokens: None,\n+                                                    },\n+                                                );\n+                                                first_pat = self.mk_pat(new_span, path);\n+                                                show_sugg = true;\n+                                            }\n+                                            PatKind::Path(old_qself, old_path) => {\n+                                                let mut segments = old_path.segments.clone();\n+                                                segments\n+                                                    .push(PathSegment::from_ident(ident.clone()));\n+                                                let path = PatKind::Path(\n+                                                    old_qself.clone(),\n+                                                    Path { span: new_span, segments, tokens: None },\n+                                                );\n+                                                first_pat = self.mk_pat(new_span, path);\n+                                                show_sugg = true;\n+                                            }\n+                                            _ => {}\n+                                        },\n+                                        _ => {}\n+                                    }\n+                                    if show_sugg {\n+                                        err.span_suggestion(\n+                                            span,\n+                                            \"maybe write a path separator here\",\n+                                            \"::\".to_string(),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                    } else {\n+                                        first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                                    }\n                                     err.emit();\n-                                    first_pat =\n-                                        self.mk_pat(first_pat.span.to(pat.span), PatKind::Wild);\n                                 }\n                             }\n                         }"}, {"sha": "0b7b67496d6f32df39107feb43e1c957a029ae21", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6e34ad108dc998e9f9d872e807e221c0df4f24b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e34ad108dc998e9f9d872e807e221c0df4f24b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=d6e34ad108dc998e9f9d872e807e221c0df4f24b", "patch": "@@ -1,11 +1,15 @@\n // Tests that a suggestion is issued if the user wrote a colon instead of\n // a path separator in a match arm.\n \n-enum Foo {\n-    Bar,\n-    Baz,\n+mod qux {\n+    pub enum Foo {\n+        Bar,\n+        Baz,\n+    }\n }\n \n+use qux::Foo;\n+\n fn f() -> Foo { Foo::Bar }\n \n fn g1() {\n@@ -16,41 +20,43 @@ fn g1() {\n         _ => {}\n     }\n     match f() {\n-        Foo::Bar:Baz => {}\n+        qux::Foo:Bar => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo:Bar::Baz => {}\n+        qux:Foo::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo: Bar::Baz if true => {}\n+        qux: Foo::Baz if true => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n-    if let Bar:Baz = f() {\n+    if let Foo:Bar = f() {\n     //~^ ERROR: expected one of\n     //~| HELP: maybe write a path separator here\n     }\n }\n \n fn g1_neg() {\n     match f() {\n-        ref Foo: Bar::Baz => {}\n+        ref qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n \n fn g2_neg() {\n     match f() {\n-        mut Foo: Bar::Baz => {}\n+        mut qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n@@ -62,5 +68,12 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n+        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n+    }\n+    match myfoo {\n+        Foo::Bar => {}\n+        Foo:Bar => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n     }\n }"}, {"sha": "2050a16beb34983c63e96f847a82c1d23f3f16d5", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d6e34ad108dc998e9f9d872e807e221c0df4f24b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6e34ad108dc998e9f9d872e807e221c0df4f24b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=d6e34ad108dc998e9f9d872e807e221c0df4f24b", "patch": "@@ -1,5 +1,5 @@\n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:13:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n    |            ^\n@@ -8,61 +8,83 @@ LL |         Foo:Bar => {}\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:19:17\n+  --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n-LL |         Foo::Bar:Baz => {}\n+LL |         qux::Foo:Bar => {}\n    |                 ^\n    |                 |\n    |                 expected one of 8 possible tokens\n    |                 help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:25:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n-LL |         Foo:Bar::Baz => {}\n+LL |         qux:Foo::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:31:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n-LL |         Foo: Bar::Baz if true => {}\n+LL |         qux: Foo::Baz if true => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:36:15\n+  --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n-LL |     if let Bar:Baz = f() {\n+LL |     if let Foo:Bar = f() {\n    |               ^\n    |               |\n    |               expected one of `@` or `|`\n    |               help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:44:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n-LL |         ref Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         ref qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:52:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n-LL |         mut Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         mut qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:62:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n-error: aborting due to 8 previous errors\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n+   |\n+LL |         Foo:Bar => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error[E0433]: failed to resolve: `Bar` is a variant, not a module\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n+   |\n+LL |         Foo:Bar::Baz => {}\n+   |             ^^^ `Bar` is a variant, not a module\n+\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}]}