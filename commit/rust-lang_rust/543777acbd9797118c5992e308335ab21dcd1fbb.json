{"sha": "543777acbd9797118c5992e308335ab21dcd1fbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0Mzc3N2FjYmQ5Nzk3MTE4YzU5OTJlMzA4MzM1YWIyMWRjZDFmYmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-23T08:47:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-23T16:04:13Z"}, "message": "avoid unnecessary RefCell calls in Stacked Borrows", "tree": {"sha": "bcdeef58f06bf7137d79f7efa75e763db82fa70d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcdeef58f06bf7137d79f7efa75e763db82fa70d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/543777acbd9797118c5992e308335ab21dcd1fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/543777acbd9797118c5992e308335ab21dcd1fbb", "html_url": "https://github.com/rust-lang/rust/commit/543777acbd9797118c5992e308335ab21dcd1fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/543777acbd9797118c5992e308335ab21dcd1fbb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf7e4b9df68c8b72e556667927c50574eeaac4cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7e4b9df68c8b72e556667927c50574eeaac4cc", "html_url": "https://github.com/rust-lang/rust/commit/cf7e4b9df68c8b72e556667927c50574eeaac4cc"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "b1ab34b1f346b5a0753b8d82323fb7b61e71f647", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/543777acbd9797118c5992e308335ab21dcd1fbb/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543777acbd9797118c5992e308335ab21dcd1fbb/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=543777acbd9797118c5992e308335ab21dcd1fbb", "patch": "@@ -457,14 +457,29 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        global: &GlobalState,\n-        f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n+        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n             let mut cur_ptr = ptr;\n             cur_ptr.offset = offset;\n-            f(cur_ptr, stack, &*global)?;\n+            f(cur_ptr, stack)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Call `f` on every stack in the range.\n+    fn for_each_mut(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let stacks = self.stacks.get_mut();\n+        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n+            let mut cur_ptr = ptr;\n+            cur_ptr.offset = offset;\n+            f(cur_ptr, stack)?;\n         }\n         Ok(())\n     }\n@@ -516,9 +531,8 @@ impl Stacks {\n         extra: &MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| {\n-            stack.access(AccessKind::Read, ptr, global)\n-        })\n+        let global = &*extra.borrow();\n+        self.for_each(ptr, size, move |ptr, stack| stack.access(AccessKind::Read, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -529,9 +543,8 @@ impl Stacks {\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| {\n-            stack.access(AccessKind::Write, ptr, global)\n-        })\n+        let global = extra.get_mut();\n+        self.for_each_mut(ptr, size, move |ptr, stack| stack.access(AccessKind::Write, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -542,7 +555,8 @@ impl Stacks {\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.dealloc(ptr, global))\n+        let global = extra.get_mut();\n+        self.for_each_mut(ptr, size, move |ptr, stack| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -571,12 +585,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n-        // Get the allocation. We need both the allocation and the MemoryExtra, so we cannot use `&mut`.\n-        // FIXME: make `get_alloc_extra_mut` also return `&mut MemoryExtra`.\n-        let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n-        let stacked_borrows =\n-            extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-        let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -588,6 +596,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n+                // We have to use shared references to alloc/memory_extra here since\n+                // `visit_freeze_sensitive` needs to access the global state.\n+                let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n+                let stacked_borrows =\n+                    extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+                let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen {\n@@ -596,15 +610,19 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, &*global, |cur_ptr, stack, global| {\n-                        stack.grant(cur_ptr, item, global)\n+                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack| {\n+                        stack.grant(cur_ptr, item, &*global)\n                     })\n                 });\n             }\n         };\n+        // Here we can avoid `borrow()` calls because we have mutable references.\n+        let (alloc_extra, memory_extra) = this.memory.get_alloc_extra_mut(ptr.alloc_id)?;\n+        let stacked_borrows =\n+            alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n+        let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows\n-            .for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n+        stacked_borrows.for_each_mut(ptr, size, |ptr, stack| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -640,7 +658,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Compute new borrow.\n         let new_tag = {\n-            let mut mem_extra = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow_mut();\n+            let mem_extra = this.memory.extra.stacked_borrows.as_mut().unwrap().get_mut();\n             match kind {\n                 // Give up tracking for raw pointers.\n                 RefKind::Raw { .. } if !mem_extra.track_raw => Tag::Untagged,"}]}