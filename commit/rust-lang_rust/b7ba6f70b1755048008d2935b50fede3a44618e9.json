{"sha": "b7ba6f70b1755048008d2935b50fede3a44618e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YmE2ZjcwYjE3NTUwNDgwMDhkMjkzNWI1MGZlZGUzYTQ0NjE4ZTk=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-04-05T05:39:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-05T05:39:22Z"}, "message": "Merge pull request #2576 from topecongiro/merge-imports\n\nUse normalized form to format use items", "tree": {"sha": "9ee746521cd0afe11eedf772b3ec721a8843ebf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee746521cd0afe11eedf772b3ec721a8843ebf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7ba6f70b1755048008d2935b50fede3a44618e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaxbaKCRBK7hj4Ov3rIwAAdHIIAID1ZHe+VSCg2k+SfyfQFyCL\ndKHnLhrP00zpQV8K4pzVCredEnrbk8bCo5cKHpmxmz+qfsmaQUUZrFkSs0sOReYE\n7w5j/2yTHh6A8G8x8CD6qqx2YSRmyDfhpbfT350imrkQy9+8iGmOAnm4NkHFXK4W\nZVMtzw17GbUJ+5oWBa3LifoeGp/+mDmGwVa3ueD8BJtoyTUJhH2sUt8mvyyg0SwS\nszzeJnhH1YUO8teQH4o6o96tEPRVbNngagsB0XOP8LUDbVPqw7fiI3Uh7svs991U\ntXt5H+nVSAuZAw6lAUWKB2SOWljU7pHr7IBmuRm4Bofp+KQkKSA/eFHEiXCsPAw=\n=vAOC\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ee746521cd0afe11eedf772b3ec721a8843ebf3\nparent 0156fe07acff053428c66acf020aa9270689b057\nparent 78e09bd05cff61edbee139eda3c8bc57d00f68ff\nauthor Nick Cameron <nrc@ncameron.org> 1522906762 +1200\ncommitter GitHub <noreply@github.com> 1522906762 +1200\n\nMerge pull request #2576 from topecongiro/merge-imports\n\nUse normalized form to format use items"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ba6f70b1755048008d2935b50fede3a44618e9", "html_url": "https://github.com/rust-lang/rust/commit/b7ba6f70b1755048008d2935b50fede3a44618e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7ba6f70b1755048008d2935b50fede3a44618e9/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0156fe07acff053428c66acf020aa9270689b057", "url": "https://api.github.com/repos/rust-lang/rust/commits/0156fe07acff053428c66acf020aa9270689b057", "html_url": "https://github.com/rust-lang/rust/commit/0156fe07acff053428c66acf020aa9270689b057"}, {"sha": "78e09bd05cff61edbee139eda3c8bc57d00f68ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e09bd05cff61edbee139eda3c8bc57d00f68ff", "html_url": "https://github.com/rust-lang/rust/commit/78e09bd05cff61edbee139eda3c8bc57d00f68ff"}], "stats": {"total": 1523, "additions": 755, "deletions": 768}, "files": [{"sha": "68d6a2888967d77d959f2b0f6d76b38f44d15b38", "filename": "src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -10,8 +10,8 @@\n \n //! Format attributes and meta items.\n \n-use config::IndentStyle;\n use config::lists::*;\n+use config::IndentStyle;\n use syntax::ast;\n use syntax::codemap::Span;\n "}, {"sha": "378fe40d569890a30aad1289f055f2a75e274daa", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -10,7 +10,7 @@\n \n // Formatting and tools for comments.\n \n-use std::{self, iter, borrow::Cow};\n+use std::{self, borrow::Cow, iter};\n \n use itertools::{multipeek, MultiPeek};\n use syntax::codemap::Span;"}, {"sha": "04406e8d5669636ea40955ed0b654297a3a8e8ab", "filename": "src/config/lists.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fconfig%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fconfig%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flists.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -10,8 +10,8 @@\n \n //! Configuration options related to rewriting a list.\n \n-use config::IndentStyle;\n use config::config_type::ConfigType;\n+use config::IndentStyle;\n \n /// The definitive formatting tactic for lists.\n #[derive(Eq, PartialEq, Debug, Copy, Clone)]"}, {"sha": "8054fbdd4517de210d23183ba49fb659e37aa7c6", "filename": "src/imports.rs", "status": "modified", "additions": 628, "deletions": 273, "changes": 901, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -11,120 +11,38 @@\n use std::cmp::Ordering;\n \n use config::lists::*;\n-use syntax::ast;\n+use syntax::ast::{self, UseTreeKind};\n use syntax::codemap::{BytePos, Span};\n \n use codemap::SpanUtils;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n-use types::{rewrite_path, PathContext};\n-use utils::{format_visibility, mk_sp};\n+use spanned::Spanned;\n+use utils::mk_sp;\n use visitor::FmtVisitor;\n \n+use std::borrow::Cow;\n+\n /// Returns a name imported by a `use` declaration. e.g. returns `Ordering`\n /// for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n pub fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n     path.segments.last().unwrap().identifier\n }\n \n-pub fn same_rename(opt_ident: &Option<ast::Ident>, path: &ast::Path) -> bool {\n-    opt_ident.map_or(true, |ident| path_to_imported_ident(path) == ident)\n-}\n-\n-fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    if path.segments.len() > 1 && path_to_imported_ident(path).to_string() == \"self\" {\n-        let path = &ast::Path {\n-            span: path.span,\n-            segments: path.segments[..path.segments.len() - 1].to_owned(),\n-        };\n-        rewrite_path(context, PathContext::Import, None, path, shape)\n-    } else {\n-        rewrite_path(context, PathContext::Import, None, path, shape)\n-    }\n-}\n-\n-impl Rewrite for ast::UseTree {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match self.kind {\n-            ast::UseTreeKind::Nested(ref items) => {\n-                rewrite_nested_use_tree(shape, &self.prefix, items, self.span, context)\n-            }\n-            ast::UseTreeKind::Glob => {\n-                let prefix_shape = shape.sub_width(3)?;\n-\n-                if !self.prefix.segments.is_empty() {\n-                    let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)?;\n-                    Some(format!(\"{}::*\", path_str))\n-                } else {\n-                    Some(\"*\".to_owned())\n-                }\n-            }\n-            ast::UseTreeKind::Simple(opt_ident) => {\n-                if same_rename(&opt_ident, &self.prefix) {\n-                    rewrite_prefix(&self.prefix, context, shape)\n-                        .or_else(|| Some(context.snippet(self.prefix.span).to_owned()))\n-                } else {\n-                    let ident_str = opt_ident?.to_string();\n-                    // 4 = \" as \".len()\n-                    let prefix_shape = shape.sub_width(ident_str.len() + 4)?;\n-                    let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)\n-                        .unwrap_or_else(|| context.snippet(self.prefix.span).to_owned());\n-                    Some(format!(\"{} as {}\", path_str, ident_str))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unused_import(tree: &ast::UseTree, attrs: &[ast::Attribute]) -> bool {\n-    attrs.is_empty() && is_unused_import_inner(tree)\n-}\n-\n-fn is_unused_import_inner(tree: &ast::UseTree) -> bool {\n-    match tree.kind {\n-        ast::UseTreeKind::Nested(ref items) => match items.len() {\n-            0 => true,\n-            1 => is_unused_import_inner(&items[0].0),\n-            _ => false,\n-        },\n-        _ => false,\n-    }\n-}\n-\n-// Rewrite `use foo;` WITHOUT attributes.\n-pub fn rewrite_import(\n-    context: &RewriteContext,\n-    vis: &ast::Visibility,\n-    tree: &ast::UseTree,\n-    attrs: &[ast::Attribute],\n-    shape: Shape,\n-) -> Option<String> {\n-    let vis = format_visibility(vis);\n-    // 4 = `use `, 1 = `;`\n-    let rw = shape\n-        .offset_left(vis.len() + 4)\n-        .and_then(|shape| shape.sub_width(1))\n-        .and_then(|shape| {\n-            // If we have an empty nested group with no attributes, we erase it\n-            if is_unused_import(tree, attrs) {\n-                Some(\"\".to_owned())\n-            } else {\n-                tree.rewrite(context, shape)\n-            }\n-        });\n-    match rw {\n-        Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n-        _ => rw,\n-    }\n-}\n-\n impl<'a> FmtVisitor<'a> {\n     pub fn format_import(&mut self, item: &ast::Item, tree: &ast::UseTree) {\n         let span = item.span;\n         let shape = self.shape();\n-        let rw = rewrite_import(&self.get_context(), &item.vis, tree, &item.attrs, shape);\n+        let rw = UseTree::from_ast(\n+            &self.get_context(),\n+            tree,\n+            None,\n+            Some(item.vis.clone()),\n+            Some(item.span.lo()),\n+            Some(item.attrs.clone()),\n+        ).rewrite_top_level(&self.get_context(), shape);\n         match rw {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n@@ -152,204 +70,416 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-fn rewrite_nested_use_tree_single(\n-    context: &RewriteContext,\n-    path_str: &str,\n-    tree: &ast::UseTree,\n-    shape: Shape,\n-) -> Option<String> {\n-    match tree.kind {\n-        ast::UseTreeKind::Simple(opt_rename) => {\n-            let mut item_str = rewrite_prefix(&tree.prefix, context, shape)?;\n-            if item_str == \"self\" {\n-                item_str = \"\".to_owned();\n-            }\n+// Ordering of imports\n \n-            let path_item_str = if path_str.is_empty() {\n-                if item_str.is_empty() {\n-                    \"self\".to_owned()\n-                } else {\n-                    item_str\n-                }\n-            } else if item_str.is_empty() {\n-                path_str.to_owned()\n-            } else {\n-                format!(\"{}::{}\", path_str, item_str)\n-            };\n-\n-            Some(if same_rename(&opt_rename, &tree.prefix) {\n-                path_item_str\n-            } else {\n-                format!(\"{} as {}\", path_item_str, opt_rename?)\n-            })\n-        }\n-        ast::UseTreeKind::Glob | ast::UseTreeKind::Nested(..) => {\n-            // 2 = \"::\"\n-            let nested_shape = shape.offset_left(path_str.len() + 2)?;\n-            tree.rewrite(context, nested_shape)\n-                .map(|item| format!(\"{}::{}\", path_str, item))\n-        }\n-    }\n+// We order imports by translating to our own representation and then sorting.\n+// The Rust AST data structures are really bad for this. Rustfmt applies a bunch\n+// of normalisations to imports and since we want to sort based on the result\n+// of these (and to maintain idempotence) we must apply the same normalisations\n+// to the data structures for sorting.\n+//\n+// We sort `self` and `super` before other imports, then identifier imports,\n+// then glob imports, then lists of imports. We do not take aliases into account\n+// when ordering unless the imports are identical except for the alias (rare in\n+// practice).\n+\n+// FIXME(#2531) - we should unify the comparison code here with the formatting\n+// code elsewhere since we are essentially string-ifying twice. Furthermore, by\n+// parsing to our own format on comparison, we repeat a lot of work when\n+// sorting.\n+\n+// FIXME we do a lot of allocation to make our own representation.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum UseSegment {\n+    Ident(String, Option<String>),\n+    Slf(Option<String>),\n+    Super(Option<String>),\n+    Glob,\n+    List(Vec<UseTree>),\n }\n \n-#[derive(Eq, PartialEq)]\n-enum ImportItem<'a> {\n-    // `self` or `self as a`\n-    SelfImport(&'a str),\n-    // name_one, name_two, ...\n-    SnakeCase(&'a str),\n-    // NameOne, NameTwo, ...\n-    CamelCase(&'a str),\n-    // NAME_ONE, NAME_TWO, ...\n-    AllCaps(&'a str),\n-    // Failed to format the import item\n-    Invalid,\n+#[derive(Debug, Clone)]\n+pub struct UseTree {\n+    pub path: Vec<UseSegment>,\n+    pub span: Span,\n+    // Comment information within nested use tree.\n+    list_item: Option<ListItem>,\n+    // Additional fields for top level use items.\n+    // Should we have another struct for top-level use items rather than reusing this?\n+    visibility: Option<ast::Visibility>,\n+    attrs: Option<Vec<ast::Attribute>>,\n+}\n+\n+impl PartialEq for UseTree {\n+    fn eq(&self, other: &UseTree) -> bool {\n+        self.path == other.path\n+    }\n }\n+impl Eq for UseTree {}\n \n-impl<'a> ImportItem<'a> {\n-    fn from_str(s: &str) -> ImportItem {\n-        if s == \"self\" || s.starts_with(\"self as\") {\n-            ImportItem::SelfImport(s)\n-        } else if s.chars().all(|c| c.is_lowercase() || c == '_' || c == ' ') {\n-            ImportItem::SnakeCase(s)\n-        } else if s.chars().all(|c| c.is_uppercase() || c == '_' || c == ' ') {\n-            ImportItem::AllCaps(s)\n+impl UseSegment {\n+    // Clone a version of self with any top-level alias removed.\n+    fn remove_alias(&self) -> UseSegment {\n+        match *self {\n+            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n+            UseSegment::Slf(_) => UseSegment::Slf(None),\n+            UseSegment::Super(_) => UseSegment::Super(None),\n+            _ => self.clone(),\n+        }\n+    }\n+\n+    fn from_path_segment(path_seg: &ast::PathSegment) -> Option<UseSegment> {\n+        let name = path_seg.identifier.name.as_str();\n+        if name == \"{{root}}\" {\n+            return None;\n+        }\n+        Some(if name == \"self\" {\n+            UseSegment::Slf(None)\n+        } else if name == \"super\" {\n+            UseSegment::Super(None)\n         } else {\n-            ImportItem::CamelCase(s)\n+            UseSegment::Ident((*name).to_owned(), None)\n+        })\n+    }\n+}\n+\n+impl UseTree {\n+    // Rewrite use tree with `use ` and a trailing `;`.\n+    pub fn rewrite_top_level(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let mut result = String::with_capacity(256);\n+        if let Some(ref attrs) = self.attrs {\n+            result.push_str(&attrs.rewrite(context, shape)?);\n+            if !result.is_empty() {\n+                result.push_str(&shape.indent.to_string_with_newline(context.config));\n+            }\n         }\n+\n+        let vis = self.visibility\n+            .as_ref()\n+            .map_or(Cow::from(\"\"), |vis| ::utils::format_visibility(&vis));\n+        result.push_str(&self.rewrite(context, shape.offset_left(vis.len())?)\n+            .map(|s| {\n+                if s.is_empty() {\n+                    s.to_owned()\n+                } else {\n+                    format!(\"{}use {};\", vis, s)\n+                }\n+            })?);\n+        Some(result)\n     }\n \n-    fn from_opt_str(s: Option<&String>) -> ImportItem {\n-        s.map_or(ImportItem::Invalid, |s| ImportItem::from_str(s))\n+    pub fn from_ast_with_normalization(\n+        context: &RewriteContext,\n+        item: &ast::Item,\n+    ) -> Option<UseTree> {\n+        match item.node {\n+            ast::ItemKind::Use(ref use_tree) => Some(\n+                UseTree::from_ast(\n+                    context,\n+                    use_tree,\n+                    None,\n+                    Some(item.vis.clone()),\n+                    Some(item.span().lo()),\n+                    if item.attrs.is_empty() {\n+                        None\n+                    } else {\n+                        Some(item.attrs.clone())\n+                    },\n+                ).normalize(context.config.reorder_imported_names()),\n+            ),\n+            _ => None,\n+        }\n     }\n \n-    fn to_str(&self) -> Option<&str> {\n-        match *self {\n-            ImportItem::SelfImport(s)\n-            | ImportItem::SnakeCase(s)\n-            | ImportItem::CamelCase(s)\n-            | ImportItem::AllCaps(s) => Some(s),\n-            ImportItem::Invalid => None,\n+    fn from_ast(\n+        context: &RewriteContext,\n+        a: &ast::UseTree,\n+        list_item: Option<ListItem>,\n+        visibility: Option<ast::Visibility>,\n+        opt_lo: Option<BytePos>,\n+        attrs: Option<Vec<ast::Attribute>>,\n+    ) -> UseTree {\n+        let span = if let Some(lo) = opt_lo {\n+            mk_sp(lo, a.span.hi())\n+        } else {\n+            a.span\n+        };\n+        let mut result = UseTree {\n+            path: vec![],\n+            span,\n+            list_item,\n+            visibility,\n+            attrs,\n+        };\n+        for p in &a.prefix.segments {\n+            if let Some(use_segment) = UseSegment::from_path_segment(p) {\n+                result.path.push(use_segment);\n+            }\n+        }\n+        match a.kind {\n+            UseTreeKind::Glob => {\n+                result.path.push(UseSegment::Glob);\n+            }\n+            UseTreeKind::Nested(ref list) => {\n+                // Extract comments between nested use items.\n+                // This needs to be done before sorting use items.\n+                let items: Vec<_> = itemize_list(\n+                    context.snippet_provider,\n+                    list.iter().map(|(tree, _)| tree),\n+                    \"}\",\n+                    \",\",\n+                    |tree| tree.span.lo(),\n+                    |tree| tree.span.hi(),\n+                    |_| Some(\"\".to_owned()), // We only need comments for now.\n+                    context.snippet_provider.span_after(a.span, \"{\"),\n+                    a.span.hi(),\n+                    false,\n+                ).collect();\n+                result.path.push(UseSegment::List(\n+                    list.iter()\n+                        .zip(items.into_iter())\n+                        .map(|(t, list_item)| {\n+                            Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n+                        })\n+                        .collect(),\n+                ));\n+            }\n+            UseTreeKind::Simple(ref rename) => {\n+                let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n+                let alias = rename.and_then(|ident| {\n+                    if ident == path_to_imported_ident(&a.prefix) {\n+                        None\n+                    } else {\n+                        Some(ident.to_string())\n+                    }\n+                });\n+\n+                let segment = if &name == \"self\" {\n+                    UseSegment::Slf(alias)\n+                } else if &name == \"super\" {\n+                    UseSegment::Super(alias)\n+                } else {\n+                    UseSegment::Ident(name, alias)\n+                };\n+\n+                // `name` is already in result.\n+                result.path.pop();\n+                result.path.push(segment);\n+            }\n         }\n+        result\n     }\n \n-    fn to_u32(&self) -> u32 {\n-        match *self {\n-            ImportItem::SelfImport(..) => 0,\n-            ImportItem::SnakeCase(..) => 1,\n-            ImportItem::CamelCase(..) => 2,\n-            ImportItem::AllCaps(..) => 3,\n-            ImportItem::Invalid => 4,\n+    // Do the adjustments that rustfmt does elsewhere to use paths.\n+    pub fn normalize(mut self, do_sort: bool) -> UseTree {\n+        let mut last = self.path.pop().expect(\"Empty use tree?\");\n+        // Hack around borrow checker.\n+        let mut normalize_sole_list = false;\n+        let mut aliased_self = false;\n+\n+        // Remove foo::{} or self without attributes.\n+        match last {\n+            _ if self.attrs.is_some() => (),\n+            UseSegment::List(ref list) if list.is_empty() => {\n+                self.path = vec![];\n+                return self;\n+            }\n+            UseSegment::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n+                self.path = vec![];\n+                return self;\n+            }\n+            _ => (),\n+        }\n+\n+        // Normalise foo::self -> foo.\n+        if let UseSegment::Slf(None) = last {\n+            if self.path.len() > 0 {\n+                return self;\n+            }\n+        }\n+\n+        // Normalise foo::self as bar -> foo as bar.\n+        if let UseSegment::Slf(_) = last {\n+            match self.path.last() {\n+                None => {}\n+                Some(UseSegment::Ident(_, None)) => {\n+                    aliased_self = true;\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        if aliased_self {\n+            match self.path.last() {\n+                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                    assert!(old_rename.is_none());\n+                    if let UseSegment::Slf(Some(rename)) = last {\n+                        *old_rename = Some(rename);\n+                        return self;\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Normalise foo::{bar} -> foo::bar\n+        if let UseSegment::List(ref list) = last {\n+            if list.len() == 1 {\n+                normalize_sole_list = true;\n+            }\n+        }\n+\n+        if normalize_sole_list {\n+            match last {\n+                UseSegment::List(list) => {\n+                    for seg in &list[0].path {\n+                        self.path.push(seg.clone());\n+                    }\n+                    return self.normalize(do_sort);\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Recursively normalize elements of a list use (including sorting the list).\n+        if let UseSegment::List(list) = last {\n+            let mut list = list.into_iter()\n+                .map(|ut| ut.normalize(do_sort))\n+                .collect::<Vec<_>>();\n+            if do_sort {\n+                list.sort();\n+            }\n+            last = UseSegment::List(list);\n         }\n+\n+        self.path.push(last);\n+        self\n     }\n }\n \n-impl<'a> PartialOrd for ImportItem<'a> {\n-    fn partial_cmp(&self, other: &ImportItem<'a>) -> Option<Ordering> {\n+impl PartialOrd for UseSegment {\n+    fn partial_cmp(&self, other: &UseSegment) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n-\n-impl<'a> Ord for ImportItem<'a> {\n-    fn cmp(&self, other: &ImportItem<'a>) -> Ordering {\n-        let res = self.to_u32().cmp(&other.to_u32());\n-        if res != Ordering::Equal {\n-            return res;\n-        }\n-        self.to_str().map_or(Ordering::Greater, |self_str| {\n-            other\n-                .to_str()\n-                .map_or(Ordering::Less, |other_str| self_str.cmp(other_str))\n-        })\n+impl PartialOrd for UseTree {\n+    fn partial_cmp(&self, other: &UseTree) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n+impl Ord for UseSegment {\n+    fn cmp(&self, other: &UseSegment) -> Ordering {\n+        use self::UseSegment::*;\n \n-// Pretty prints a multi-item import.\n-// If the path list is empty, it leaves the braces empty.\n-fn rewrite_nested_use_tree(\n-    shape: Shape,\n-    path: &ast::Path,\n-    trees: &[(ast::UseTree, ast::NodeId)],\n-    span: Span,\n-    context: &RewriteContext,\n-) -> Option<String> {\n-    // Returns a different option to distinguish `::foo` and `foo`\n-    let path_str = rewrite_path(context, PathContext::Import, None, path, shape)?;\n-\n-    match trees.len() {\n-        0 => {\n-            let shape = shape.offset_left(path_str.len() + 3)?;\n-            return rewrite_path(context, PathContext::Import, None, path, shape)\n-                .map(|path_str| format!(\"{}::{{}}\", path_str));\n+        fn is_upper_snake_case(s: &str) -> bool {\n+            s.chars().all(|c| c.is_uppercase() || c == '_')\n         }\n-        1 => {\n-            return rewrite_nested_use_tree_single(context, &path_str, &trees[0].0, shape);\n+\n+        match (self, other) {\n+            (&Slf(ref a), &Slf(ref b)) | (&Super(ref a), &Super(ref b)) => a.cmp(b),\n+            (&Glob, &Glob) => Ordering::Equal,\n+            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n+                // snake_case < CamelCase < UPPER_SNAKE_CASE\n+                if ia.starts_with(char::is_uppercase) && ib.starts_with(char::is_lowercase) {\n+                    return Ordering::Greater;\n+                }\n+                if ia.starts_with(char::is_lowercase) && ib.starts_with(char::is_uppercase) {\n+                    return Ordering::Less;\n+                }\n+                if is_upper_snake_case(ia) && !is_upper_snake_case(ib) {\n+                    return Ordering::Greater;\n+                }\n+                if !is_upper_snake_case(ia) && is_upper_snake_case(ib) {\n+                    return Ordering::Less;\n+                }\n+                let ident_ord = ia.cmp(ib);\n+                if ident_ord != Ordering::Equal {\n+                    return ident_ord;\n+                }\n+                if aa.is_none() && ab.is_some() {\n+                    return Ordering::Less;\n+                }\n+                if aa.is_some() && ab.is_none() {\n+                    return Ordering::Greater;\n+                }\n+                aa.cmp(ab)\n+            }\n+            (&List(ref a), &List(ref b)) => {\n+                for (a, b) in a.iter().zip(b.iter()) {\n+                    let ord = a.cmp(b);\n+                    if ord != Ordering::Equal {\n+                        return ord;\n+                    }\n+                }\n+\n+                a.len().cmp(&b.len())\n+            }\n+            (&Slf(_), _) => Ordering::Less,\n+            (_, &Slf(_)) => Ordering::Greater,\n+            (&Super(_), _) => Ordering::Less,\n+            (_, &Super(_)) => Ordering::Greater,\n+            (&Ident(..), _) => Ordering::Less,\n+            (_, &Ident(..)) => Ordering::Greater,\n+            (&Glob, _) => Ordering::Less,\n+            (_, &Glob) => Ordering::Greater,\n         }\n-        _ => (),\n     }\n+}\n+impl Ord for UseTree {\n+    fn cmp(&self, other: &UseTree) -> Ordering {\n+        for (a, b) in self.path.iter().zip(other.path.iter()) {\n+            let ord = a.cmp(b);\n+            // The comparison without aliases is a hack to avoid situations like\n+            // comparing `a::b` to `a as c` - where the latter should be ordered\n+            // first since it is shorter.\n+            if ord != Ordering::Equal && a.remove_alias().cmp(&b.remove_alias()) != Ordering::Equal\n+            {\n+                return ord;\n+            }\n+        }\n \n-    let path_str = if path_str.is_empty() {\n-        path_str\n-    } else {\n-        format!(\"{}::\", path_str)\n-    };\n-\n-    // 2 = \"{}\"\n-    let remaining_width = shape.width.checked_sub(path_str.len() + 2).unwrap_or(0);\n-    let nested_indent = match context.config.imports_indent() {\n-        IndentStyle::Block => shape.indent.block_indent(context.config),\n-        // 1 = `{`\n-        IndentStyle::Visual => shape.visual_indent(path_str.len() + 1).indent,\n-    };\n+        self.path.len().cmp(&other.path.len())\n+    }\n+}\n \n+fn rewrite_nested_use_tree(\n+    context: &RewriteContext,\n+    use_tree_list: &[UseTree],\n+    shape: Shape,\n+) -> Option<String> {\n+    let mut list_items = Vec::with_capacity(use_tree_list.len());\n     let nested_shape = match context.config.imports_indent() {\n-        IndentStyle::Block => Shape::indented(nested_indent, context.config).sub_width(1)?,\n-        IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n-    };\n-\n-    let mut items = {\n-        // Dummy value, see explanation below.\n-        let mut items = vec![ListItem::from_str(\"\")];\n-        let iter = itemize_list(\n-            context.snippet_provider,\n-            trees.iter().map(|tree| &tree.0),\n-            \"}\",\n-            \",\",\n-            |tree| tree.span.lo(),\n-            |tree| tree.span.hi(),\n-            |tree| tree.rewrite(context, nested_shape),\n-            context.snippet_provider.span_after(span, \"{\"),\n-            span.hi(),\n-            false,\n-        );\n-        items.extend(iter);\n-        items\n+        IndentStyle::Block => shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+            .sub_width(1)?,\n+        IndentStyle::Visual => shape.visual_indent(0),\n     };\n-\n-    // We prefixed the item list with a dummy value so that we can\n-    // potentially move \"self\" to the front of the vector without touching\n-    // the rest of the items.\n-    let has_self = move_self_to_front(&mut items);\n-    let first_index = if has_self { 0 } else { 1 };\n-\n-    if context.config.reorder_imported_names() {\n-        items[1..].sort_by(|a, b| {\n-            let a = ImportItem::from_opt_str(a.item.as_ref());\n-            let b = ImportItem::from_opt_str(b.item.as_ref());\n-            a.cmp(&b)\n-        });\n+    for use_tree in use_tree_list {\n+        let mut list_item = use_tree.list_item.clone()?;\n+        list_item.item = use_tree.rewrite(context, nested_shape);\n+        list_items.push(list_item);\n     }\n-\n-    let tactic = definitive_tactic(\n-        &items[first_index..],\n-        context.config.imports_layout(),\n-        Separator::Comma,\n-        remaining_width,\n-    );\n-\n+    let tactic = if use_tree_list.iter().any(|use_segment| {\n+        use_segment\n+            .path\n+            .last()\n+            .map_or(false, |last_segment| match last_segment {\n+                UseSegment::List(..) => true,\n+                _ => false,\n+            })\n+    }) {\n+        DefinitiveListTactic::Vertical\n+    } else {\n+        definitive_tactic(\n+            &list_items,\n+            context.config.imports_layout(),\n+            Separator::Comma,\n+            shape.width.checked_sub(2).unwrap_or(0),\n+        )\n+    };\n     let ends_with_newline = context.config.imports_indent() == IndentStyle::Block\n         && tactic != DefinitiveListTactic::Horizontal;\n-\n     let fmt = ListFormatting {\n         tactic,\n         separator: \",\",\n@@ -364,33 +494,258 @@ fn rewrite_nested_use_tree(\n         preserve_newline: true,\n         config: context.config,\n     };\n-    let list_str = write_list(&items[first_index..], &fmt)?;\n+\n+    let list_str = write_list(&list_items, &fmt)?;\n \n     let result = if list_str.contains('\\n') && context.config.imports_indent() == IndentStyle::Block\n     {\n         format!(\n-            \"{}{{\\n{}{}\\n{}}}\",\n-            path_str,\n+            \"{{\\n{}{}\\n{}}}\",\n             nested_shape.indent.to_string(context.config),\n             list_str,\n             shape.indent.to_string(context.config)\n         )\n     } else {\n-        format!(\"{}{{{}}}\", path_str, list_str)\n+        format!(\"{{{}}}\", list_str)\n     };\n+\n     Some(result)\n }\n \n-// Returns true when self item was found.\n-fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n-    match items\n-        .iter()\n-        .position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\"))\n-    {\n-        Some(pos) => {\n-            items[0] = items.remove(pos);\n-            true\n+impl Rewrite for UseSegment {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        Some(match *self {\n+            UseSegment::Ident(ref ident, Some(ref rename)) => format!(\"{} as {}\", ident, rename),\n+            UseSegment::Ident(ref ident, None) => ident.clone(),\n+            UseSegment::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n+            UseSegment::Slf(None) => \"self\".to_owned(),\n+            UseSegment::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n+            UseSegment::Super(None) => \"super\".to_owned(),\n+            UseSegment::Glob => \"*\".to_owned(),\n+            UseSegment::List(ref use_tree_list) => rewrite_nested_use_tree(\n+                context,\n+                use_tree_list,\n+                // 1 = \"{\" and \"}\"\n+                shape.offset_left(1)?.sub_width(1)?,\n+            )?,\n+        })\n+    }\n+}\n+\n+impl Rewrite for UseTree {\n+    // This does NOT format attributes and visibility or add a trailing `;`.\n+    fn rewrite(&self, context: &RewriteContext, mut shape: Shape) -> Option<String> {\n+        let mut result = String::with_capacity(256);\n+        let mut iter = self.path.iter().peekable();\n+        while let Some(ref segment) = iter.next() {\n+            let segment_str = segment.rewrite(context, shape)?;\n+            result.push_str(&segment_str);\n+            if iter.peek().is_some() {\n+                result.push_str(\"::\");\n+                // 2 = \"::\"\n+                shape = shape.offset_left(2 + segment_str.len())?;\n+            }\n+        }\n+        Some(result)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use syntax::codemap::DUMMY_SP;\n+\n+    // Parse the path part of an import. This parser is not robust and is only\n+    // suitable for use in a test harness.\n+    fn parse_use_tree(s: &str) -> UseTree {\n+        use std::iter::Peekable;\n+        use std::mem::swap;\n+        use std::str::Chars;\n+\n+        struct Parser<'a> {\n+            input: Peekable<Chars<'a>>,\n+        }\n+\n+        impl<'a> Parser<'a> {\n+            fn bump(&mut self) {\n+                self.input.next().unwrap();\n+            }\n+            fn eat(&mut self, c: char) {\n+                assert!(self.input.next().unwrap() == c);\n+            }\n+            fn push_segment(\n+                result: &mut Vec<UseSegment>,\n+                buf: &mut String,\n+                alias_buf: &mut Option<String>,\n+            ) {\n+                if !buf.is_empty() {\n+                    let mut alias = None;\n+                    swap(alias_buf, &mut alias);\n+                    if buf == \"self\" {\n+                        result.push(UseSegment::Slf(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else if buf == \"super\" {\n+                        result.push(UseSegment::Super(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else {\n+                        let mut name = String::new();\n+                        swap(buf, &mut name);\n+                        result.push(UseSegment::Ident(name, alias));\n+                    }\n+                }\n+            }\n+            fn parse_in_list(&mut self) -> UseTree {\n+                let mut result = vec![];\n+                let mut buf = String::new();\n+                let mut alias_buf = None;\n+                while let Some(&c) = self.input.peek() {\n+                    match c {\n+                        '{' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::List(self.parse_list()));\n+                            self.eat('}');\n+                        }\n+                        '*' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::Glob);\n+                        }\n+                        ':' => {\n+                            self.bump();\n+                            self.eat(':');\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                        }\n+                        '}' | ',' => {\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            return UseTree {\n+                                path: result,\n+                                span: DUMMY_SP,\n+                                list_item: None,\n+                                visibility: None,\n+                                attrs: None,\n+                            };\n+                        }\n+                        ' ' => {\n+                            self.bump();\n+                            self.eat('a');\n+                            self.eat('s');\n+                            self.eat(' ');\n+                            alias_buf = Some(String::new());\n+                        }\n+                        c => {\n+                            self.bump();\n+                            if let Some(ref mut buf) = alias_buf {\n+                                buf.push(c);\n+                            } else {\n+                                buf.push(c);\n+                            }\n+                        }\n+                    }\n+                }\n+                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                UseTree {\n+                    path: result,\n+                    span: DUMMY_SP,\n+                    list_item: None,\n+                    visibility: None,\n+                    attrs: None,\n+                }\n+            }\n+\n+            fn parse_list(&mut self) -> Vec<UseTree> {\n+                let mut result = vec![];\n+                loop {\n+                    match self.input.peek().unwrap() {\n+                        ',' | ' ' => self.bump(),\n+                        '}' => {\n+                            return result;\n+                        }\n+                        _ => result.push(self.parse_in_list()),\n+                    }\n+                }\n+            }\n         }\n-        None => false,\n+\n+        let mut parser = Parser {\n+            input: s.chars().peekable(),\n+        };\n+        parser.parse_in_list()\n+    }\n+\n+    #[test]\n+    fn test_use_tree_normalize() {\n+        assert_eq!(\n+            parse_use_tree(\"a::self\").normalize(true),\n+            parse_use_tree(\"a\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::self as foo\").normalize(true),\n+            parse_use_tree(\"a as foo\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{self}\").normalize(true),\n+            parse_use_tree(\"a\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{b}\").normalize(true),\n+            parse_use_tree(\"a::b\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{b, c::self}\").normalize(true),\n+            parse_use_tree(\"a::{b, c}\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{b as bar, c::self}\").normalize(true),\n+            parse_use_tree(\"a::{b as bar, c}\")\n+        );\n+    }\n+\n+    #[test]\n+    fn test_use_tree_ord() {\n+        assert!(parse_use_tree(\"a\").normalize(true) < parse_use_tree(\"aa\").normalize(true));\n+        assert!(parse_use_tree(\"a\").normalize(true) < parse_use_tree(\"a::a\").normalize(true));\n+        assert!(parse_use_tree(\"a\").normalize(true) < parse_use_tree(\"*\").normalize(true));\n+        assert!(parse_use_tree(\"a\").normalize(true) < parse_use_tree(\"{a, b}\").normalize(true));\n+        assert!(parse_use_tree(\"*\").normalize(true) < parse_use_tree(\"{a, b}\").normalize(true));\n+\n+        assert!(\n+            parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, dddddddd}\").normalize(true)\n+                < parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, ddddddddd}\").normalize(true)\n+        );\n+        assert!(\n+            parse_use_tree(\"serde::de::{Deserialize}\").normalize(true)\n+                < parse_use_tree(\"serde_json\").normalize(true)\n+        );\n+        assert!(\n+            parse_use_tree(\"a::b::c\").normalize(true) < parse_use_tree(\"a::b::*\").normalize(true)\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{Bar, Baz}\").normalize(true)\n+                < parse_use_tree(\"{Bar, Baz}\").normalize(true)\n+        );\n+\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar}\").normalize(true)\n+                < parse_use_tree(\"foo::{qux as bar}\").normalize(true)\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{qux as bar}\").normalize(true)\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize(true)\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar, baz}\").normalize(true)\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize(true)\n+        );\n+\n+        assert!(parse_use_tree(\"foo\").normalize(true) < parse_use_tree(\"Foo\").normalize(true));\n+        assert!(parse_use_tree(\"foo\").normalize(true) < parse_use_tree(\"foo::Bar\").normalize(true));\n+\n+        assert!(\n+            parse_use_tree(\"std::cmp::{d, c, b, a}\").normalize(true)\n+                < parse_use_tree(\"std::cmp::{b, e, g, f}\").normalize(true)\n+        );\n     }\n }"}, {"sha": "6129dd494b93784343734b0a22e4012dd7412b0b", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -53,8 +53,8 @@ use shape::Indent;\n use utils::use_colored_tty;\n use visitor::{FmtVisitor, SnippetProvider};\n \n-pub use config::Config;\n pub use config::summary::Summary;\n+pub use config::Config;\n \n #[macro_use]\n mod utils;"}, {"sha": "43ba7f9d673dd6f33c251efe498bad378cd85cb1", "filename": "src/lists.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -56,7 +56,7 @@ impl AsRef<ListItem> for ListItem {\n     }\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n pub enum ListItemCommentStyle {\n     // Try to keep the comment on the same line with the item.\n     SameLine,\n@@ -66,7 +66,7 @@ pub enum ListItemCommentStyle {\n     None,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct ListItem {\n     // None for comments mean that they are not present.\n     pub pre_comment: Option<String>,\n@@ -257,7 +257,9 @@ where\n                     result.push(' ');\n                 }\n             }\n-            DefinitiveListTactic::Vertical if !first => {\n+            DefinitiveListTactic::Vertical\n+                if !first && !inner_item.is_empty() && !result.is_empty() =>\n+            {\n                 result.push('\\n');\n                 result.push_str(indent_str);\n             }\n@@ -617,6 +619,8 @@ where\n \n             let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n                 post_snippet[1..].trim_matches(white_space)\n+            } else if post_snippet.starts_with(self.separator) {\n+                post_snippet[self.separator.len()..].trim_matches(white_space)\n             } else if post_snippet.ends_with(',') {\n                 post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n             } else {"}, {"sha": "15191995d024d3af46af20717ebefd4fb830b844", "filename": "src/reorder.rs", "status": "modified", "additions": 90, "deletions": 470, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -16,39 +16,29 @@\n \n // TODO(#2455): Reorder trait items.\n \n-use config::{Config, lists::*};\n-use syntax::ast::UseTreeKind;\n+use config::{lists::*, Config};\n use syntax::{ast, attr, codemap::Span};\n \n use attr::filter_inline_attrs;\n use codemap::LineRangeUtils;\n use comment::combine_strs_with_missing_comments;\n-use imports::{path_to_imported_ident, rewrite_import};\n+use imports::UseTree;\n use items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n-use lists::{itemize_list, write_list, ListFormatting};\n+use lists::{itemize_list, write_list, ListFormatting, ListItem};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use utils::mk_sp;\n use visitor::FmtVisitor;\n \n-use std::cmp::{Ord, Ordering, PartialOrd};\n-\n-fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree) -> Ordering {\n-    let aa = UseTree::from_ast(a).normalize();\n-    let bb = UseTree::from_ast(b).normalize();\n-    aa.cmp(&bb)\n-}\n+use std::cmp::{Ord, Ordering};\n \n /// Choose the ordering between the given two items.\n fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n     match (&a.node, &b.node) {\n         (&ast::ItemKind::Mod(..), &ast::ItemKind::Mod(..)) => {\n             a.ident.name.as_str().cmp(&b.ident.name.as_str())\n         }\n-        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n-            compare_use_trees(a_tree, b_tree)\n-        }\n         (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n             // `extern crate foo as bar;`\n             //               ^^^ Comparing this.\n@@ -74,58 +64,11 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n     }\n }\n \n-/// Rewrite a list of items with reordering. Every item in `items` must have\n-/// the same `ast::ItemKind`.\n-fn rewrite_reorderable_items(\n+fn wrap_reorderable_items(\n     context: &RewriteContext,\n-    reorderable_items: &[&ast::Item],\n+    list_items: &[ListItem],\n     shape: Shape,\n-    span: Span,\n ) -> Option<String> {\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        reorderable_items.iter(),\n-        \"\",\n-        \";\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| {\n-            let attrs = filter_inline_attrs(&item.attrs, item.span());\n-            let attrs_str = attrs.rewrite(context, shape)?;\n-\n-            let missed_span = if attrs.is_empty() {\n-                mk_sp(item.span.lo(), item.span.lo())\n-            } else {\n-                mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n-            };\n-\n-            let item_str = match item.node {\n-                ast::ItemKind::Use(ref tree) => {\n-                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n-                }\n-                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n-                ast::ItemKind::Mod(..) => rewrite_mod(item),\n-                _ => return None,\n-            };\n-\n-            combine_strs_with_missing_comments(\n-                context,\n-                &attrs_str,\n-                &item_str,\n-                missed_span,\n-                shape,\n-                false,\n-            )\n-        },\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    );\n-\n-    let mut item_pair_vec: Vec<_> = items.zip(reorderable_items.iter()).collect();\n-    item_pair_vec.sort_by(|a, b| compare_items(a.1, b.1));\n-    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n-\n     let fmt = ListFormatting {\n         tactic: DefinitiveListTactic::Vertical,\n         separator: \"\",\n@@ -137,7 +80,90 @@ fn rewrite_reorderable_items(\n         config: context.config,\n     };\n \n-    write_list(&item_vec, &fmt)\n+    write_list(list_items, &fmt)\n+}\n+\n+fn rewrite_reorderable_item(\n+    context: &RewriteContext,\n+    item: &ast::Item,\n+    shape: Shape,\n+) -> Option<String> {\n+    let attrs = filter_inline_attrs(&item.attrs, item.span());\n+    let attrs_str = attrs.rewrite(context, shape)?;\n+\n+    let missed_span = if attrs.is_empty() {\n+        mk_sp(item.span.lo(), item.span.lo())\n+    } else {\n+        mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n+    };\n+\n+    let item_str = match item.node {\n+        ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n+        ast::ItemKind::Mod(..) => rewrite_mod(item),\n+        _ => return None,\n+    };\n+\n+    combine_strs_with_missing_comments(context, &attrs_str, &item_str, missed_span, shape, false)\n+}\n+\n+/// Rewrite a list of items with reordering. Every item in `items` must have\n+/// the same `ast::ItemKind`.\n+fn rewrite_reorderable_items(\n+    context: &RewriteContext,\n+    reorderable_items: &[&ast::Item],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n+    match reorderable_items[0].node {\n+        // FIXME: Remove duplicated code.\n+        ast::ItemKind::Use(..) => {\n+            let normalized_items: Vec<_> = reorderable_items\n+                .iter()\n+                .filter_map(|item| UseTree::from_ast_with_normalization(context, item))\n+                .collect();\n+\n+            // 4 = \"use \", 1 = \";\"\n+            let nested_shape = shape.offset_left(4)?.sub_width(1)?;\n+            let list_items = itemize_list(\n+                context.snippet_provider,\n+                normalized_items.iter(),\n+                \"\",\n+                \";\",\n+                |item| item.span.lo(),\n+                |item| item.span.hi(),\n+                |item| item.rewrite_top_level(context, nested_shape),\n+                span.lo(),\n+                span.hi(),\n+                false,\n+            );\n+\n+            let mut item_pair_vec: Vec<_> = list_items.zip(&normalized_items).collect();\n+            item_pair_vec.sort_by(|a, b| a.1.cmp(b.1));\n+            let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+            wrap_reorderable_items(context, &item_vec, nested_shape)\n+        }\n+        _ => {\n+            let list_items = itemize_list(\n+                context.snippet_provider,\n+                reorderable_items.iter(),\n+                \"\",\n+                \";\",\n+                |item| item.span().lo(),\n+                |item| item.span().hi(),\n+                |item| rewrite_reorderable_item(context, item, shape),\n+                span.lo(),\n+                span.hi(),\n+                false,\n+            );\n+\n+            let mut item_pair_vec: Vec<_> = list_items.zip(reorderable_items.iter()).collect();\n+            item_pair_vec.sort_by(|a, b| compare_items(a.1, b.1));\n+            let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+            wrap_reorderable_items(context, &item_vec, shape)\n+        }\n+    }\n }\n \n fn contains_macro_use_attr(item: &ast::Item) -> bool {\n@@ -255,409 +281,3 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n }\n-\n-// Ordering of imports\n-\n-// We order imports by translating to our own representation and then sorting.\n-// The Rust AST data structures are really bad for this. Rustfmt applies a bunch\n-// of normalisations to imports and since we want to sort based on the result\n-// of these (and to maintain idempotence) we must apply the same normalisations\n-// to the data structures for sorting.\n-//\n-// We sort `self` and `super` before other imports, then identifier imports,\n-// then glob imports, then lists of imports. We do not take aliases into account\n-// when ordering unless the imports are identical except for the alias (rare in\n-// practice).\n-\n-// FIXME(#2531) - we should unify the comparison code here with the formatting\n-// code elsewhere since we are essentially string-ifying twice. Furthermore, by\n-// parsing to our own format on comparison, we repeat a lot of work when\n-// sorting.\n-\n-// FIXME we do a lot of allocation to make our own representation.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-enum UseSegment {\n-    Ident(String, Option<String>),\n-    Slf(Option<String>),\n-    Super(Option<String>),\n-    Glob,\n-    List(Vec<UseTree>),\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-struct UseTree {\n-    path: Vec<UseSegment>,\n-}\n-\n-impl UseSegment {\n-    // Clone a version of self with any top-level alias removed.\n-    fn remove_alias(&self) -> UseSegment {\n-        match *self {\n-            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n-            UseSegment::Slf(_) => UseSegment::Slf(None),\n-            UseSegment::Super(_) => UseSegment::Super(None),\n-            _ => self.clone(),\n-        }\n-    }\n-\n-    fn from_path_segment(path_seg: &ast::PathSegment) -> UseSegment {\n-        let name = path_seg.identifier.name.as_str();\n-        if name == \"self\" {\n-            UseSegment::Slf(None)\n-        } else if name == \"super\" {\n-            UseSegment::Super(None)\n-        } else {\n-            UseSegment::Ident((*name).to_owned(), None)\n-        }\n-    }\n-}\n-\n-impl UseTree {\n-    fn from_ast(a: &ast::UseTree) -> UseTree {\n-        let mut result = UseTree { path: vec![] };\n-        for p in &a.prefix.segments {\n-            result.path.push(UseSegment::from_path_segment(p));\n-        }\n-        match a.kind {\n-            UseTreeKind::Glob => {\n-                result.path.push(UseSegment::Glob);\n-            }\n-            UseTreeKind::Nested(ref list) => {\n-                result.path.push(UseSegment::List(\n-                    list.iter().map(|t| Self::from_ast(&t.0)).collect(),\n-                ));\n-            }\n-            UseTreeKind::Simple(ref rename) => {\n-                let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n-                let alias = rename.and_then(|ident| {\n-                    if ident == path_to_imported_ident(&a.prefix) {\n-                        None\n-                    } else {\n-                        Some(ident.to_string())\n-                    }\n-                });\n-\n-                let segment = if &name == \"self\" {\n-                    UseSegment::Slf(alias)\n-                } else if &name == \"super\" {\n-                    UseSegment::Super(alias)\n-                } else {\n-                    UseSegment::Ident(name, alias)\n-                };\n-\n-                // `name` is already in result.\n-                result.path.pop();\n-                result.path.push(segment);\n-            }\n-        }\n-        result\n-    }\n-\n-    // Do the adjustments that rustfmt does elsewhere to use paths.\n-    fn normalize(mut self) -> UseTree {\n-        let mut last = self.path.pop().expect(\"Empty use tree?\");\n-        // Hack around borrow checker.\n-        let mut normalize_sole_list = false;\n-        let mut aliased_self = false;\n-\n-        // Normalise foo::self -> foo.\n-        if let UseSegment::Slf(None) = last {\n-            return self;\n-        }\n-\n-        // Normalise foo::self as bar -> foo as bar.\n-        if let UseSegment::Slf(_) = last {\n-            match self.path.last() {\n-                None => {}\n-                Some(UseSegment::Ident(_, None)) => {\n-                    aliased_self = true;\n-                }\n-                _ => unreachable!(),\n-            }\n-        }\n-\n-        if aliased_self {\n-            match self.path.last() {\n-                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n-                    assert!(old_rename.is_none());\n-                    if let UseSegment::Slf(Some(rename)) = last {\n-                        *old_rename = Some(rename);\n-                        return self;\n-                    }\n-                }\n-                _ => unreachable!(),\n-            }\n-        }\n-\n-        // Normalise foo::{bar} -> foo::bar\n-        if let UseSegment::List(ref list) = last {\n-            if list.len() == 1 && list[0].path.len() == 1 {\n-                normalize_sole_list = true;\n-            }\n-        }\n-\n-        if normalize_sole_list {\n-            match last {\n-                UseSegment::List(list) => {\n-                    self.path.push(list[0].path[0].clone());\n-                    return self.normalize();\n-                }\n-                _ => unreachable!(),\n-            }\n-        }\n-\n-        // Recursively normalize elements of a list use (including sorting the list).\n-        if let UseSegment::List(list) = last {\n-            let mut list: Vec<_> = list.into_iter().map(|ut| ut.normalize()).collect();\n-            list.sort();\n-            last = UseSegment::List(list);\n-        }\n-\n-        self.path.push(last);\n-        self\n-    }\n-}\n-\n-impl PartialOrd for UseSegment {\n-    fn partial_cmp(&self, other: &UseSegment) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-impl PartialOrd for UseTree {\n-    fn partial_cmp(&self, other: &UseTree) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-impl Ord for UseSegment {\n-    fn cmp(&self, other: &UseSegment) -> Ordering {\n-        use self::UseSegment::*;\n-\n-        match (self, other) {\n-            (&Slf(ref a), &Slf(ref b)) | (&Super(ref a), &Super(ref b)) => a.cmp(b),\n-            (&Glob, &Glob) => Ordering::Equal,\n-            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n-                let ident_ord = ia.cmp(ib);\n-                if ident_ord != Ordering::Equal {\n-                    return ident_ord;\n-                }\n-                if aa.is_none() && ab.is_some() {\n-                    return Ordering::Less;\n-                }\n-                if aa.is_some() && ab.is_none() {\n-                    return Ordering::Greater;\n-                }\n-                aa.cmp(ab)\n-            }\n-            (&List(ref a), &List(ref b)) => {\n-                for (a, b) in a.iter().zip(b.iter()) {\n-                    let ord = a.cmp(b);\n-                    if ord != Ordering::Equal {\n-                        return ord;\n-                    }\n-                }\n-\n-                a.len().cmp(&b.len())\n-            }\n-            (&Slf(_), _) => Ordering::Less,\n-            (_, &Slf(_)) => Ordering::Greater,\n-            (&Super(_), _) => Ordering::Less,\n-            (_, &Super(_)) => Ordering::Greater,\n-            (&Ident(..), _) => Ordering::Less,\n-            (_, &Ident(..)) => Ordering::Greater,\n-            (&Glob, _) => Ordering::Less,\n-            (_, &Glob) => Ordering::Greater,\n-        }\n-    }\n-}\n-impl Ord for UseTree {\n-    fn cmp(&self, other: &UseTree) -> Ordering {\n-        for (a, b) in self.path.iter().zip(other.path.iter()) {\n-            let ord = a.cmp(b);\n-            // The comparison without aliases is a hack to avoid situations like\n-            // comparing `a::b` to `a as c` - where the latter should be ordered\n-            // first since it is shorter.\n-            if ord != Ordering::Equal && a.remove_alias().cmp(&b.remove_alias()) != Ordering::Equal\n-            {\n-                return ord;\n-            }\n-        }\n-\n-        self.path.len().cmp(&other.path.len())\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    // Parse the path part of an import. This parser is not robust and is only\n-    // suitable for use in a test harness.\n-    fn parse_use_tree(s: &str) -> UseTree {\n-        use std::iter::Peekable;\n-        use std::mem::swap;\n-        use std::str::Chars;\n-\n-        struct Parser<'a> {\n-            input: Peekable<Chars<'a>>,\n-        }\n-\n-        impl<'a> Parser<'a> {\n-            fn bump(&mut self) {\n-                self.input.next().unwrap();\n-            }\n-            fn eat(&mut self, c: char) {\n-                assert!(self.input.next().unwrap() == c);\n-            }\n-            fn push_segment(\n-                result: &mut Vec<UseSegment>,\n-                buf: &mut String,\n-                alias_buf: &mut Option<String>,\n-            ) {\n-                if !buf.is_empty() {\n-                    let mut alias = None;\n-                    swap(alias_buf, &mut alias);\n-                    if buf == \"self\" {\n-                        result.push(UseSegment::Slf(alias));\n-                        *buf = String::new();\n-                        *alias_buf = None;\n-                    } else if buf == \"super\" {\n-                        result.push(UseSegment::Super(alias));\n-                        *buf = String::new();\n-                        *alias_buf = None;\n-                    } else {\n-                        let mut name = String::new();\n-                        swap(buf, &mut name);\n-                        result.push(UseSegment::Ident(name, alias));\n-                    }\n-                }\n-            }\n-            fn parse_in_list(&mut self) -> UseTree {\n-                let mut result = vec![];\n-                let mut buf = String::new();\n-                let mut alias_buf = None;\n-                while let Some(&c) = self.input.peek() {\n-                    match c {\n-                        '{' => {\n-                            assert!(buf.is_empty());\n-                            self.bump();\n-                            result.push(UseSegment::List(self.parse_list()));\n-                            self.eat('}');\n-                        }\n-                        '*' => {\n-                            assert!(buf.is_empty());\n-                            self.bump();\n-                            result.push(UseSegment::Glob);\n-                        }\n-                        ':' => {\n-                            self.bump();\n-                            self.eat(':');\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n-                        }\n-                        '}' | ',' => {\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n-                            return UseTree { path: result };\n-                        }\n-                        ' ' => {\n-                            self.bump();\n-                            self.eat('a');\n-                            self.eat('s');\n-                            self.eat(' ');\n-                            alias_buf = Some(String::new());\n-                        }\n-                        c => {\n-                            self.bump();\n-                            if let Some(ref mut buf) = alias_buf {\n-                                buf.push(c);\n-                            } else {\n-                                buf.push(c);\n-                            }\n-                        }\n-                    }\n-                }\n-                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n-                UseTree { path: result }\n-            }\n-\n-            fn parse_list(&mut self) -> Vec<UseTree> {\n-                let mut result = vec![];\n-                loop {\n-                    match self.input.peek().unwrap() {\n-                        ',' | ' ' => self.bump(),\n-                        '}' => {\n-                            return result;\n-                        }\n-                        _ => result.push(self.parse_in_list()),\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut parser = Parser {\n-            input: s.chars().peekable(),\n-        };\n-        parser.parse_in_list()\n-    }\n-\n-    #[test]\n-    fn test_use_tree_normalize() {\n-        assert_eq!(parse_use_tree(\"a::self\").normalize(), parse_use_tree(\"a\"));\n-        assert_eq!(\n-            parse_use_tree(\"a::self as foo\").normalize(),\n-            parse_use_tree(\"a as foo\")\n-        );\n-        assert_eq!(parse_use_tree(\"a::{self}\").normalize(), parse_use_tree(\"a\"));\n-        assert_eq!(parse_use_tree(\"a::{b}\").normalize(), parse_use_tree(\"a::b\"));\n-        assert_eq!(\n-            parse_use_tree(\"a::{b, c::self}\").normalize(),\n-            parse_use_tree(\"a::{b, c}\")\n-        );\n-        assert_eq!(\n-            parse_use_tree(\"a::{b as bar, c::self}\").normalize(),\n-            parse_use_tree(\"a::{b as bar, c}\")\n-        );\n-    }\n-\n-    #[test]\n-    fn test_use_tree_ord() {\n-        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"aa\").normalize());\n-        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"a::a\").normalize());\n-        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"*\").normalize());\n-        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n-        assert!(parse_use_tree(\"*\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n-\n-        assert!(\n-            parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, dddddddd}\").normalize()\n-                < parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, ddddddddd}\").normalize()\n-        );\n-        assert!(\n-            parse_use_tree(\"serde::de::{Deserialize}\").normalize()\n-                < parse_use_tree(\"serde_json\").normalize()\n-        );\n-        assert!(parse_use_tree(\"a::b::c\").normalize() < parse_use_tree(\"a::b::*\").normalize());\n-        assert!(\n-            parse_use_tree(\"foo::{Bar, Baz}\").normalize()\n-                < parse_use_tree(\"{Bar, Baz}\").normalize()\n-        );\n-\n-        assert!(\n-            parse_use_tree(\"foo::{self as bar}\").normalize()\n-                < parse_use_tree(\"foo::{qux as bar}\").normalize()\n-        );\n-        assert!(\n-            parse_use_tree(\"foo::{qux as bar}\").normalize()\n-                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n-        );\n-        assert!(\n-            parse_use_tree(\"foo::{self as bar, baz}\").normalize()\n-                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n-        );\n-\n-        assert!(parse_use_tree(\"Foo\").normalize() < parse_use_tree(\"foo\").normalize());\n-        assert!(parse_use_tree(\"foo\").normalize() < parse_use_tree(\"foo::Bar\").normalize());\n-\n-        assert!(\n-            parse_use_tree(\"std::cmp::{d, c, b, a}\").normalize()\n-                < parse_use_tree(\"std::cmp::{b, e, g, f}\").normalize()\n-        );\n-    }\n-}"}, {"sha": "a206e8db6cf4d74c6b8ad85bebc5f7561146d2c4", "filename": "tests/source/issue-2256.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Fsource%2Fissue-2256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Fsource%2Fissue-2256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-2256.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -2,11 +2,11 @@\n use std::{};\n use std::borrow::Cow;\n \n-/* comment */ use std::{};\n-/* comment */ use std::{};\n+/* comment 1 */ use std::{};\n+/* comment 2 */ use std::{};\n \n \n \n \n \n-/* comment */ use std::{};\n+/* comment 3 */ use std::{};"}, {"sha": "236fee95e82befce8a8cd55cf50f18c86ccb96d9", "filename": "tests/target/imports.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -19,12 +19,11 @@ use list::{// Another item\n \n use test::{/* A */ self /* B */, Other /* C */};\n \n-use Foo::{Bar, Baz};\n use syntax;\n pub use syntax::ast::{Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath, Expr_};\n+use Foo::{Bar, Baz};\n use {Bar /* comment */, /* Pre-comment! */ Foo};\n \n-use self;\n use std::io;\n use std::io;\n \n@@ -54,14 +53,14 @@ use foo::{self as bar, baz};\n use foo::{baz, qux as bar};\n \n // With absolute paths\n-use Foo;\n use foo;\n use foo::Bar;\n use foo::{Bar, Baz};\n+use Foo;\n use {Bar, Baz};\n \n // Root globs\n-use ::*;\n+use *;\n use *;\n \n // spaces used to cause glob imports to disappear (#1356)\n@@ -73,14 +72,24 @@ use foo::issue_1356::*;\n use self::unix::{};\n \n // nested imports\n-use foo::{a, b, boo, c,\n-          bar::{baz, qux, xxxxxxxxxxx, yyyyyyyyyyyyy, zzzzzzzzzzzzzzzz,\n-                foo::{a, b, cxxxxxxxxxxxxx, yyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz}}};\n-\n-use fooo::{bar, x, y, z,\n-           baar::foobar::{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+use foo::{a,\n+          b,\n+          bar::{baz,\n+                foo::{a, b, cxxxxxxxxxxxxx, yyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz},\n+                qux,\n+                xxxxxxxxxxx,\n+                yyyyyyyyyyyyy,\n+                zzzzzzzzzzzzzzzz},\n+          boo,\n+          c};\n+\n+use fooo::{baar::foobar::{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n                           zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz},\n-           bar::*};\n+           bar,\n+           bar::*,\n+           x,\n+           y,\n+           z};\n \n // nested imports with a single sub-tree.\n use a::b::c::d;"}, {"sha": "0a59c308394e30f944b379697be23c69fb17b149", "filename": "tests/target/issue-2256.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Ftarget%2Fissue-2256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ba6f70b1755048008d2935b50fede3a44618e9/tests%2Ftarget%2Fissue-2256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2256.rs?ref=b7ba6f70b1755048008d2935b50fede3a44618e9", "patch": "@@ -1,8 +1,7 @@\n // \u3053\u3093\u306b\u3061\u306f\n use std::borrow::Cow;\n \n-/* comment */\n+/* comment 1 */\n+/* comment 2 */\n \n-/* comment */\n-\n-/* comment */\n+/* comment 3 */"}]}