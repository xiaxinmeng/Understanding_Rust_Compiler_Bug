{"sha": "04a6d16c7b68587f8e9fa8a1e6715f80408b023b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YTZkMTZjN2I2ODU4N2Y4ZTlmYThhMWU2NzE1ZjgwNDA4YjAyM2I=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-07T06:17:35Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-09T07:36:41Z"}, "message": "Avoid trial and error in rewrite_chain whenever possible", "tree": {"sha": "979a87ad4cd97bfee84b7c7c380c9de64fd119c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/979a87ad4cd97bfee84b7c7c380c9de64fd119c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04a6d16c7b68587f8e9fa8a1e6715f80408b023b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04a6d16c7b68587f8e9fa8a1e6715f80408b023b", "html_url": "https://github.com/rust-lang/rust/commit/04a6d16c7b68587f8e9fa8a1e6715f80408b023b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04a6d16c7b68587f8e9fa8a1e6715f80408b023b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7268a50e36033b4f3026a142b69b1fca82130e88", "url": "https://api.github.com/repos/rust-lang/rust/commits/7268a50e36033b4f3026a142b69b1fca82130e88", "html_url": "https://github.com/rust-lang/rust/commit/7268a50e36033b4f3026a142b69b1fca82130e88"}], "stats": {"total": 202, "additions": 48, "deletions": 154}, "files": [{"sha": "75dac5b322762c8405f0559e0b6cad1c109b1ff8", "filename": "src/chains.rs", "status": "modified", "additions": 48, "deletions": 154, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/04a6d16c7b68587f8e9fa8a1e6715f80408b023b/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a6d16c7b68587f8e9fa8a1e6715f80408b023b/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=04a6d16c7b68587f8e9fa8a1e6715f80408b023b", "patch": "@@ -105,7 +105,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n         match context.config.chain_indent() {\n             IndentStyle::Visual => shape.visual_indent(0),\n-            IndentStyle::Block => shape.block(),\n+            IndentStyle::Block => shape,\n         }\n     } else {\n         shape\n@@ -133,13 +133,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             // brace.\n             IndentStyle::Visual => (parent_shape, false),\n         }\n-    } else if parent_rewrite_contains_newline {\n-        (chain_indent(context, parent_shape), false)\n     } else {\n         (\n-            shape\n-                .block_indent(context.config.tab_spaces())\n-                .with_max_width(context.config),\n+            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n             false,\n         )\n     };\n@@ -166,94 +162,56 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         .into_iter()\n         .chain(iter::repeat(other_child_shape));\n     let subexpr_num = subexpr_list.len();\n+    let last_subexpr = &subexpr_list[suffix_try_num];\n     let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n-    let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n+    let iter = subexpr_list.iter().skip(1).rev().zip(child_shape_iter);\n     let mut rewrites = try_opt!(\n         iter.map(|(e, shape)| {\n             rewrite_chain_subexpr(e, total_span, context, shape)\n         }).collect::<Option<Vec<_>>>()\n     );\n \n     // Total of all items excluding the last.\n-    let rewrites_len = rewrites.len();\n-    let almost_total = rewrites[0..(rewrites_len - 1)]\n-        .iter()\n-        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n-    let one_line_len =\n-        rewrites.iter().fold(0, |a, r| a + first_line_width(r)) + parent_rewrite.len();\n-\n-    let one_line_budget = min(shape.width, context.config.chain_one_line_max());\n-    let veto_single_line = if one_line_len > one_line_budget {\n-        if rewrites.len() > 1 {\n-            true\n-        } else if rewrites.len() == 1 {\n-            context.config.chain_split_single_child() || one_line_len > shape.width\n-        } else {\n-            false\n-        }\n-    } else if context.config.take_source_hints() && rewrites.len() > 1 {\n-        // Look at the source code. Unless all chain elements start on the same\n-        // line, we won't consider putting them on a single line either.\n-        let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n-        let first_span = context.snippet(subexpr_list[1].span);\n-        let last_iter = last_span.chars().take_while(|c| c.is_whitespace());\n-\n-        first_span.chars().chain(last_iter).any(|c| c == '\\n')\n+    let extend_last_subexr = last_line_extendable(&parent_rewrite) && rewrites.is_empty();\n+    let almost_total = if extend_last_subexr {\n+        last_line_width(&parent_rewrite)\n     } else {\n-        false\n+        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n     };\n-\n-    let mut fits_single_line = !veto_single_line && almost_total <= shape.width;\n-    if fits_single_line {\n-        let len = rewrites.len();\n-        let (init, last) = rewrites.split_at_mut(len - 1);\n-        fits_single_line = init.iter().all(|s| !s.contains('\\n'));\n-\n-        if fits_single_line {\n-            fits_single_line = match expr.node {\n-                ref e @ ast::ExprKind::MethodCall(..) => {\n-                    if rewrite_method_call_with_overflow(\n-                        e,\n-                        &mut last[0],\n-                        almost_total,\n-                        total_span,\n-                        context,\n-                        shape,\n-                    ) {\n-                        // If the first line of the last method does not fit into a single line\n-                        // after the others, allow new lines.\n-                        almost_total + first_line_width(&last[0]) < context.config.max_width()\n-                    } else {\n-                        false\n+    let one_line_budget = if rewrites.is_empty() && !context.config.chain_split_single_child() {\n+        shape.width\n+    } else {\n+        min(shape.width, context.config.chain_one_line_max())\n+    };\n+    let all_in_one_line = !parent_rewrite_contains_newline &&\n+        rewrites.iter().all(|s| !s.contains('\\n')) &&\n+        almost_total < one_line_budget;\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n+    let (last_subexpr_str, fits_single_line) = try_opt!(if all_in_one_line || extend_last_subexr {\n+        parent_shape.offset_left(almost_total).map(|shape| {\n+            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n+                let line_count = rw.lines().count();\n+                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                if (line_count >= 5 && fits_single_line) || extend_last_subexr {\n+                    (Some(rw), true)\n+                } else {\n+                    match rewrite_last() {\n+                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n+                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                            (Some(rw), fits_single_line)\n+                        }\n+                        new_rw @ Some(..) => (new_rw, false),\n+                        _ => (Some(rw), fits_single_line),\n                     }\n                 }\n-                _ => !last[0].contains('\\n'),\n+            } else {\n+                (rewrite_last(), false)\n             }\n-        }\n-    }\n-\n-    // Try overflowing the last element if we are using block indent and it goes multi line\n-    // or it fits in a single line but goes over the max width.\n-    if !fits_single_line && context.use_block_indent() {\n-        let last_expr_index = rewrites.len() - 1;\n-        let (init, last) = rewrites.split_at_mut(last_expr_index);\n-        let almost_single_line = init.iter().all(|s| !s.contains('\\n'));\n-        if almost_single_line && last[0].contains('\\n') {\n-            let overflow_shape = Shape {\n-                width: one_line_budget,\n-                ..parent_shape\n-            };\n-            fits_single_line = rewrite_last_child_with_overflow(\n-                context,\n-                &subexpr_list[0],\n-                overflow_shape,\n-                total_span,\n-                almost_total,\n-                one_line_budget,\n-                &mut last[0],\n-            );\n-        }\n-    }\n+        })\n+    } else {\n+        Some((rewrite_last(), false))\n+    });\n+    rewrites.push(try_opt!(last_subexpr_str));\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n@@ -266,14 +224,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = choose_first_connector(\n-        context,\n-        &parent_rewrite,\n-        &rewrites[0],\n-        &connector,\n-        &subexpr_list,\n-        extend,\n-    );\n+    let first_connector = if is_small_parent || fits_single_line ||\n+        last_line_extendable(&parent_rewrite) ||\n+        context.config.chain_indent() == IndentStyle::Visual\n+    {\n+        \"\"\n+    } else {\n+        connector.as_str()\n+    };\n \n     let result = if is_small_parent && rewrites.len() > 1 {\n         let second_connector = choose_first_connector(\n@@ -301,11 +259,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         )\n     };\n     let result = format!(\"{}{}\", result, repeat_try(suffix_try_num));\n-    if context.config.chain_indent() == IndentStyle::Block {\n-        Some(result)\n-    } else {\n-        wrap_str(result, context.config.max_width(), shape)\n-    }\n+    wrap_str(result, context.config.max_width(), shape)\n }\n \n fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n@@ -323,26 +277,6 @@ fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n \n // Try to rewrite and replace the last non-try child. Return `true` if\n // replacing succeeds.\n-fn rewrite_last_child_with_overflow(\n-    context: &RewriteContext,\n-    expr: &ast::Expr,\n-    shape: Shape,\n-    span: Span,\n-    almost_total: usize,\n-    one_line_budget: usize,\n-    last_child: &mut String,\n-) -> bool {\n-    if let Some(shape) = shape.shrink_left(almost_total) {\n-        if let Some(ref mut rw) = rewrite_chain_subexpr(expr, span, context, shape) {\n-            if almost_total + first_line_width(rw) <= one_line_budget && rw.lines().count() > 3 {\n-                ::std::mem::swap(last_child, rw);\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n fn repeat_try(try_count: usize) -> String {\n     iter::repeat(\"?\").take(try_count).collect::<String>()\n }\n@@ -420,46 +354,6 @@ fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     }\n }\n \n-fn rewrite_method_call_with_overflow(\n-    expr_kind: &ast::ExprKind,\n-    last: &mut String,\n-    almost_total: usize,\n-    total_span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> bool {\n-    if let &ast::ExprKind::MethodCall(ref segment, ref expressions) = expr_kind {\n-        let shape = match shape.shrink_left(almost_total) {\n-            Some(b) => b,\n-            None => return false,\n-        };\n-        let types = match segment.parameters {\n-            Some(ref params) => match **params {\n-                ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                _ => &[],\n-            },\n-            _ => &[],\n-        };\n-        let mut last_rewrite = rewrite_method_call(\n-            segment.identifier,\n-            types,\n-            expressions,\n-            total_span,\n-            context,\n-            shape,\n-        );\n-\n-        if let Some(ref mut s) = last_rewrite {\n-            ::std::mem::swap(s, last);\n-            true\n-        } else {\n-            false\n-        }\n-    } else {\n-        unreachable!();\n-    }\n-}\n-\n // Returns the expression's subexpression, if it exists. When the subexpr\n // is a try! macro, we'll convert it to shorthand when the option is set.\n fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {"}]}