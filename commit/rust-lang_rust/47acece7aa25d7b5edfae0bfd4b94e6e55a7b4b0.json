{"sha": "47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YWNlY2U3YWEyNWQ3YjVlZGZhZTBiZmQ0Yjk0ZTZlNTVhN2I0YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-30T11:40:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-30T11:40:43Z"}, "message": "Auto merge of #1636 - RalfJung:rustup, r=oli-obk\n\nremove miri-rustc-tests\n\n`@oli-obk` I am not sure if anyone used this program in the last few years. There are no instructions for how to use it. So I think keeping it working is just a waste of time. It now fails to build:\n```\nerror[E0046]: not all trait items implemented, missing: `visit_foreign_item`\n  --> src/bin/miri-rustc-tests.rs:36:17\n   |\n36 |                 impl<'tcx, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'tcx> {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `visit_foreign_item` in implementation\n```\nSo I propose instead of me trying to figure out how to fix this, we just drop this ancient code.", "tree": {"sha": "a7bf449d14dbb5fbcda5df755defec4ad35ae496", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7bf449d14dbb5fbcda5df755defec4ad35ae496"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "html_url": "https://github.com/rust-lang/rust/commit/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c53d4518a993d83359fd483fade5eeaaf4b4f90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53d4518a993d83359fd483fade5eeaaf4b4f90c", "html_url": "https://github.com/rust-lang/rust/commit/c53d4518a993d83359fd483fade5eeaaf4b4f90c"}, {"sha": "6145709bfc5b0a298d957a7f705a3c64d63421a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6145709bfc5b0a298d957a7f705a3c64d63421a5", "html_url": "https://github.com/rust-lang/rust/commit/6145709bfc5b0a298d957a7f705a3c64d63421a5"}], "stats": {"total": 271, "additions": 1, "deletions": 270}, "files": [{"sha": "7580d140b55f7f403e3e1cbf2f3ae64cd380d774", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "patch": "@@ -17,12 +17,6 @@ name = \"miri\"\n test = false # we have no unit tests\n doctest = false # and no doc tests\n \n-[[bin]]\n-name = \"miri-rustc-tests\"\n-test = false # we have no unit tests\n-doctest = false # and no doc tests\n-required-features = [\"rustc_tests\"]\n-\n [dependencies]\n getrandom = { version = \"0.2\", features = [\"std\"] }\n env_logger = \"0.7.1\"\n@@ -46,6 +40,3 @@ libc = \"0.2\"\n compiletest_rs = { version = \"0.5\", features = [\"tmp\"] }\n rustc_version = \"0.2.3\"\n colored = \"2\"\n-\n-[features]\n-rustc_tests = []"}, {"sha": "485cc2dd4b9f7418402fdad0cd8e625cf7e2dbc5", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=47acece7aa25d7b5edfae0bfd4b94e6e55a7b4b0", "patch": "@@ -1 +1 @@\n-828461b4b27c4a955587887936e54057efc5e2c1\n+88b81970ba7a989a728b32039dd075dc206f1360"}, {"sha": "cef71a9889f128cebeb6674e2001467e34d0b145", "filename": "src/bin/miri-rustc-tests.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/c53d4518a993d83359fd483fade5eeaaf4b4f90c/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d4518a993d83359fd483fade5eeaaf4b4f90c/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=c53d4518a993d83359fd483fade5eeaaf4b4f90c", "patch": "@@ -1,260 +0,0 @@\n-#![feature(rustc_private)]\n-\n-extern crate rustc_middle;\n-extern crate rustc_driver;\n-extern crate rustc_hir;\n-extern crate rustc_interface;\n-extern crate rustc_span;\n-\n-use std::io;\n-use std::io::Write;\n-use std::path::Path;\n-use std::sync::{Arc, Mutex};\n-\n-use rustc_middle::ty::TyCtxt;\n-use rustc_driver::Compilation;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::itemlikevisit;\n-use rustc_interface::{interface, Queries};\n-\n-struct MiriCompilerCalls {\n-    /// whether we are building for the host\n-    host_target: bool,\n-}\n-\n-impl rustc_driver::Callbacks for MiriCompilerCalls {\n-    fn after_analysis<'tcx>(\n-        &mut self,\n-        compiler: &interface::Compiler,\n-        queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        compiler.session().abort_if_errors();\n-        queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n-            if std::env::args().any(|arg| arg == \"--test\") {\n-                struct Visitor<'tcx>(TyCtxt<'tcx>);\n-                impl<'tcx, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'tcx> {\n-                    fn visit_item(&mut self, i: &'hir hir::Item) {\n-                        if let hir::ItemKind::Fn(.., body_id) = i.kind {\n-                            if i.attrs\n-                                .iter()\n-                                .any(|attr| self.0.sess.check_name(attr, rustc_span::symbol::sym::test))\n-                            {\n-                                let config = miri::MiriConfig::default();\n-                                let did = self.0.hir().body_owner_def_id(body_id).to_def_id();\n-                                println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                                miri::eval_main(self.0, did, config);\n-                                self.0.sess.abort_if_errors();\n-                            }\n-                        }\n-                    }\n-                    fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-                    fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-                }\n-                tcx.hir().krate().visit_all_item_likes(&mut Visitor(tcx));\n-            } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-                let config = miri::MiriConfig::default();\n-                miri::eval_main(tcx, entry_def_id.to_def_id(), config);\n-\n-                compiler.session().abort_if_errors();\n-            } else {\n-                println!(\"no main function found, assuming auxiliary build\");\n-            }\n-        });\n-\n-        // Continue execution on host target\n-        if self.host_target { Compilation::Continue } else { Compilation::Stop }\n-    }\n-}\n-\n-fn main() {\n-    let path = option_env!(\"MIRI_RUSTC_TEST\").map(String::from).unwrap_or_else(|| {\n-        std::env::var(\"MIRI_RUSTC_TEST\")\n-            .expect(\"need to set MIRI_RUSTC_TEST to path of rustc tests\")\n-    });\n-\n-    let mut mir_not_found = Vec::new();\n-    let mut crate_not_found = Vec::new();\n-    let mut success = 0;\n-    let mut failed = Vec::new();\n-    let mut c_abi_fns = Vec::new();\n-    let mut abi = Vec::new();\n-    let mut unsupported = Vec::new();\n-    let mut unimplemented_intrinsic = Vec::new();\n-    let mut limits = Vec::new();\n-    let mut files: Vec<_> = std::fs::read_dir(path).unwrap().collect();\n-    while let Some(file) = files.pop() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if file.metadata().unwrap().is_dir() {\n-            if !path.to_str().unwrap().ends_with(\"auxiliary\") {\n-                // add subdirs recursively\n-                files.extend(std::fs::read_dir(path).unwrap());\n-            }\n-            continue;\n-        }\n-        if !file.metadata().unwrap().is_file() || !path.to_str().unwrap().ends_with(\".rs\") {\n-            continue;\n-        }\n-        let stderr = std::io::stderr();\n-        write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n-        let mut host_target = false;\n-        let mut args: Vec<String> = std::env::args()\n-            .filter(|arg| {\n-                if arg == \"--miri_host_target\" {\n-                    host_target = true;\n-                    false // remove the flag, rustc doesn't know it\n-                } else {\n-                    true\n-                }\n-            })\n-            .collect();\n-        args.splice(1..1, miri::MIRI_DEFAULT_ARGS.iter().map(ToString::to_string));\n-        // file to process\n-        args.push(path.display().to_string());\n-\n-        let sysroot_flag = String::from(\"--sysroot\");\n-        if !args.contains(&sysroot_flag) {\n-            args.push(sysroot_flag);\n-            args.push(\n-                Path::new(&std::env::var(\"HOME\").unwrap())\n-                    .join(\".xargo\")\n-                    .join(\"HOST\")\n-                    .display()\n-                    .to_string(),\n-            );\n-        }\n-\n-        // A threadsafe buffer for writing.\n-        #[derive(Default, Clone)]\n-        struct BufWriter(Arc<Mutex<Vec<u8>>>);\n-\n-        impl Write for BufWriter {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-                self.0.lock().unwrap().write(buf)\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                self.0.lock().unwrap().flush()\n-            }\n-        }\n-        let buf = BufWriter::default();\n-        let output = buf.clone();\n-        let result = std::panic::catch_unwind(|| {\n-            let mut callbacks = MiriCompilerCalls { host_target };\n-            let mut run = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n-            run.set_emitter(Some(Box::new(buf)));\n-            let _ = run.run();\n-        });\n-\n-        match result {\n-            Ok(()) => {\n-                success += 1;\n-                writeln!(stderr.lock(), \"ok\").unwrap()\n-            }\n-            Err(_) => {\n-                let output = output.0.lock().unwrap();\n-                let output_err = std::str::from_utf8(&output).unwrap();\n-                if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n-                    let end = text.find('`').unwrap();\n-                    mir_not_found.push(text[..end].to_string());\n-                    writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n-                } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n-                    let end = text.find('`').unwrap();\n-                    crate_not_found.push(text[..end].to_string());\n-                    writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n-                } else {\n-                    for text in output_err.split(\"error: \").skip(1) {\n-                        let end = text.find('\\n').unwrap_or(text.len());\n-                        let c_abi = \"can't call C ABI function: \";\n-                        let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n-                        let unsupported_s = \"miri does not support \";\n-                        let abi_s = \"can't handle function with \";\n-                        let limit_s = \"reached the configured maximum \";\n-                        if text.starts_with(c_abi) {\n-                            c_abi_fns.push(text[c_abi.len()..end].to_string());\n-                        } else if text.starts_with(unimplemented_intrinsic_s) {\n-                            unimplemented_intrinsic\n-                                .push(text[unimplemented_intrinsic_s.len()..end].to_string());\n-                        } else if text.starts_with(unsupported_s) {\n-                            unsupported.push(text[unsupported_s.len()..end].to_string());\n-                        } else if text.starts_with(abi_s) {\n-                            abi.push(text[abi_s.len()..end].to_string());\n-                        } else if text.starts_with(limit_s) {\n-                            limits.push(text[limit_s.len()..end].to_string());\n-                        } else if text.find(\"aborting\").is_none() {\n-                            failed.push(text[..end].to_string());\n-                        }\n-                    }\n-                    writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n-                }\n-            }\n-        }\n-    }\n-    let stderr = std::io::stderr();\n-    let mut stderr = stderr.lock();\n-    writeln!(\n-        stderr,\n-        \"{} success, {} no mir, {} crate not found, {} failed, {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n-        success,\n-        mir_not_found.len(),\n-        crate_not_found.len(),\n-        failed.len(),\n-        c_abi_fns.len(),\n-        abi.len(),\n-        unsupported.len(),\n-        unimplemented_intrinsic.len()\n-    )\n-    .unwrap();\n-    writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n-    writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n-    print_vec(&mut stderr, failed);\n-\n-    writeln!(stderr, \"# can't call C ABI function\").unwrap();\n-    print_vec(&mut stderr, c_abi_fns);\n-\n-    writeln!(stderr, \"# unsupported ABI\").unwrap();\n-    print_vec(&mut stderr, abi);\n-\n-    writeln!(stderr, \"# unsupported\").unwrap();\n-    print_vec(&mut stderr, unsupported);\n-\n-    writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n-    print_vec(&mut stderr, unimplemented_intrinsic);\n-\n-    writeln!(stderr, \"# mir not found\").unwrap();\n-    print_vec(&mut stderr, mir_not_found);\n-\n-    writeln!(stderr, \"# crate not found\").unwrap();\n-    print_vec(&mut stderr, crate_not_found);\n-}\n-\n-fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n-    writeln!(stderr, \"```\").unwrap();\n-    for (n, s) in vec_to_hist(v).into_iter().rev() {\n-        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n-    }\n-    writeln!(stderr, \"```\").unwrap();\n-}\n-\n-fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n-    v.sort();\n-    let mut v = v.into_iter();\n-    let mut result = Vec::new();\n-    let mut current = v.next();\n-    'outer: while let Some(current_val) = current {\n-        let mut n = 1;\n-        for next in &mut v {\n-            if next == current_val {\n-                n += 1;\n-            } else {\n-                result.push((n, current_val));\n-                current = Some(next);\n-                continue 'outer;\n-            }\n-        }\n-        result.push((n, current_val));\n-        break;\n-    }\n-    result.sort();\n-    result\n-}"}]}