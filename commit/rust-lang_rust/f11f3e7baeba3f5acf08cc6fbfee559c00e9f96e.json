{"sha": "f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMWYzZTdiYWViYTNmNWFjZjA4Y2M2ZmJmZWU1NTljMDBlOWY5NmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-05T20:02:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-05T20:02:14Z"}, "message": "auto merge of #20572 : nikomatsakis/rust/assoc-supertrait-stuff, r=brson\n\nThe first few commits in the PR are just general refactoring. I was intending them for some other code I didn't get around to writing yet, but might as well land them now. \r\n\r\ncc @japaric\r\n\r\nFixes #19541", "tree": {"sha": "c9b0bef9c9c3decbc85aa64f04eaaf28ec99f972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9b0bef9c9c3decbc85aa64f04eaaf28ec99f972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "html_url": "https://github.com/rust-lang/rust/commit/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03268bbf35d3ff2350d987fe7b60375839abdf2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/03268bbf35d3ff2350d987fe7b60375839abdf2e", "html_url": "https://github.com/rust-lang/rust/commit/03268bbf35d3ff2350d987fe7b60375839abdf2e"}, {"sha": "928bb2be8fee3600db086cfa94775ac9110937e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/928bb2be8fee3600db086cfa94775ac9110937e2", "html_url": "https://github.com/rust-lang/rust/commit/928bb2be8fee3600db086cfa94775ac9110937e2"}], "stats": {"total": 739, "additions": 504, "deletions": 235}, "files": [{"sha": "c616f4feaff02fa9946f7d4e05d539f4c56752bb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 184, "deletions": 134, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -53,7 +53,8 @@ use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n-use middle::ty::{self, RegionEscape, Ty};\n+use middle::traits;\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n@@ -70,7 +71,9 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n+\n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n+\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n@@ -162,9 +165,9 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn opt_ast_region_to_region<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     default_span: Span,\n     opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n@@ -241,13 +244,12 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n-fn ast_path_substs_for_ty<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn ast_path_substs_for_ty<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     decl_generics: &ty::Generics<'tcx>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n \n@@ -285,16 +287,15 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n                                regions)\n }\n \n-fn create_substs_for_ast_path<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn create_substs_for_ast_path<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n     regions: Vec<ty::Region>)\n- -> Substs<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+    -> Substs<'tcx>\n {\n     let tcx = this.tcx();\n \n@@ -408,13 +409,12 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n-                                                    rscope: &RS,\n-                                                    data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>,\n-                                                        Vec<Ty<'tcx>>,\n-                                                        Vec<ConvertedBinding<'tcx>>)\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n+                                            rscope: &RegionScope,\n+                                            data: &ast::AngleBracketedParameterData)\n+                                            -> (Vec<ty::Region>,\n+                                                Vec<Ty<'tcx>>,\n+                                                Vec<ConvertedBinding<'tcx>>)\n {\n     let regions: Vec<_> =\n         data.lifetimes.iter()\n@@ -468,12 +468,11 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n     (implied_output_region, lifetimes_for_params)\n }\n \n-fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n-                                             implied_output_region: Option<ty::Region>,\n-                                             param_lifetimes: Vec<(String, uint)>,\n-                                             ty: &ast::Ty)\n-                                             -> Ty<'tcx>\n-    where AC: AstConv<'tcx>\n+fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n+                                          implied_output_region: Option<ty::Region>,\n+                                          param_lifetimes: Vec<(String, uint)>,\n+                                          ty: &ast::Ty)\n+                                          -> Ty<'tcx>\n {\n     match implied_output_region {\n         Some(implied_output_region) => {\n@@ -490,10 +489,9 @@ fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n     }\n }\n \n-fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n-                                             data: &ast::ParenthesizedParameterData)\n-                                             -> Vec<Ty<'tcx>>\n-    where AC: AstConv<'tcx>\n+fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n+                                          data: &ast::ParenthesizedParameterData)\n+                                          -> Vec<Ty<'tcx>>\n {\n     let binding_rscope = BindingRscope::new();\n     let inputs = data.inputs.iter()\n@@ -517,14 +515,13 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n-pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn instantiate_poly_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     ast_trait_ref: &ast::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let mut projections = Vec::new();\n \n@@ -545,14 +542,13 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn instantiate_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     ast_trait_ref: &ast::TraitRef,\n     self_ty: Option<Ty<'tcx>>,\n     projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n@@ -573,15 +569,14 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(\n     }\n }\n \n-fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn ast_path_to_trait_ref<'a,'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path,\n     mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"ast_path_to_trait_ref {}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n@@ -632,7 +627,8 @@ fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n         }\n         Some(ref mut v) => {\n             for binding in assoc_bindings.iter() {\n-                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(), binding) {\n+                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n+                                                               self_ty, binding) {\n                     Ok(pp) => { v.push(pp); }\n                     Err(ErrorReported) => { }\n                 }\n@@ -643,13 +639,15 @@ fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n     trait_ref\n }\n \n-pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n-    this: &AC,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+fn ast_type_binding_to_projection_predicate<'tcx>(\n+    this: &AstConv<'tcx>,\n+    mut trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n     -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n-    where AC : AstConv<'tcx>\n {\n+    let tcx = this.tcx();\n+\n     // Given something like `U : SomeTrait<T=X>`, we want to produce a\n     // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n     // subtle in the event that `T` is defined in a supertrait of\n@@ -666,29 +664,93 @@ pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n     //\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n-    // FIXME(#19541): supertrait upcasting not actually impl'd :)\n+    // Simple case: X is defined in the current trait.\n+    if trait_defines_associated_type_named(this, trait_ref.def_id, binding.item_name) {\n+        return Ok(ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                trait_ref: trait_ref,\n+                item_name: binding.item_name,\n+            },\n+            ty: binding.ty,\n+        });\n+    }\n \n-    if !trait_defines_associated_type_named(this, trait_ref.def_id, binding.item_name) {\n-        this.tcx().sess.span_err(\n+    // Otherwise, we have to walk through the supertraits to find\n+    // those that do.  This is complicated by the fact that, for an\n+    // object type, the `Self` type is not present in the\n+    // substitutions (after all, it's being constructed right now),\n+    // but the `supertraits` iterator really wants one. To handle\n+    // this, we currently insert a dummy type and then remove it\n+    // later. Yuck.\n+\n+    let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    if self_ty.is_none() { // if converting for an object type\n+        let mut dummy_substs = trait_ref.substs.clone();\n+        assert!(dummy_substs.self_ty().is_none());\n+        dummy_substs.types.push(SelfSpace, dummy_self_ty);\n+        trait_ref = Rc::new(ty::TraitRef::new(trait_ref.def_id,\n+                                              tcx.mk_substs(dummy_substs)));\n+    }\n+\n+    let mut candidates: Vec<ty::PolyTraitRef> =\n+        traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n+        .filter(|r| trait_defines_associated_type_named(this, r.def_id(), binding.item_name))\n+        .collect();\n+\n+    // If converting for an object type, then remove the dummy-ty from `Self` now.\n+    // Yuckety yuck.\n+    if self_ty.is_none() {\n+        for candidate in candidates.iter_mut() {\n+            let mut dummy_substs = candidate.0.substs.clone();\n+            assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n+            dummy_substs.types.pop(SelfSpace);\n+            *candidate = ty::Binder(Rc::new(ty::TraitRef::new(candidate.def_id(),\n+                                                              tcx.mk_substs(dummy_substs))));\n+        }\n+    }\n+\n+    if candidates.len() > 1 {\n+        tcx.sess.span_err(\n             binding.span,\n-            format!(\"no associated type `{}` defined in `{}`\",\n+            format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    trait_ref.user_string(this.tcx())).as_slice());\n+                    candidates.user_string(tcx)).as_slice());\n+        return Err(ErrorReported);\n+    }\n+\n+    let candidate = match candidates.pop() {\n+        Some(c) => c,\n+        None => {\n+            tcx.sess.span_err(\n+                binding.span,\n+                format!(\"no associated type `{}` defined in `{}`\",\n+                        token::get_name(binding.item_name),\n+                        trait_ref.user_string(tcx)).as_slice());\n+            return Err(ErrorReported);\n+        }\n+    };\n+\n+    if ty::binds_late_bound_regions(tcx, &candidate) {\n+        tcx.sess.span_err(\n+            binding.span,\n+            format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n+                    token::get_name(binding.item_name),\n+                    candidate.user_string(tcx)).as_slice());\n         return Err(ErrorReported);\n     }\n \n     Ok(ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy {\n-            trait_ref: trait_ref,\n+            trait_ref: candidate.0,\n             item_name: binding.item_name,\n         },\n         ty: binding.ty,\n     })\n }\n \n-pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn ast_path_to_ty<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     did: ast::DefId,\n     path: &ast::Path)\n     -> TypeAndSubsts<'tcx>\n@@ -712,13 +774,12 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn ast_path_to_ty_relaxed<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     did: ast::DefId,\n     path: &ast::Path)\n     -> TypeAndSubsts<'tcx>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n     let ty::TypeScheme {\n@@ -754,9 +815,9 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n \n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n+pub fn ast_ty_to_builtin_ty<'tcx>(\n+        this: &AstConv<'tcx>,\n+        rscope: &RegionScope,\n         ast_ty: &ast::Ty)\n         -> Option<Ty<'tcx>> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n@@ -807,12 +868,11 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n-fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                   rscope: &RS,\n-                                   ty: &ast::Ty,\n-                                   bounds: &[ast::TyParamBound])\n-                                   -> Result<TraitAndProjections<'tcx>, ErrorReported>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n+fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n+                             rscope: &RegionScope,\n+                             ty: &ast::Ty,\n+                             bounds: &[ast::TyParamBound])\n+                             -> Result<TraitAndProjections<'tcx>, ErrorReported>\n {\n     /*!\n      * In a type like `Foo + Send`, we want to wait to collect the\n@@ -878,14 +938,13 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n-                                        rscope: &RS,\n-                                        span: Span,\n-                                        trait_ref: ty::PolyTraitRef<'tcx>,\n-                                        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                                        bounds: &[ast::TyParamBound])\n-                                        -> Ty<'tcx>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n+fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n+                                  rscope: &RegionScope,\n+                                  span: Span,\n+                                  trait_ref: ty::PolyTraitRef<'tcx>,\n+                                  projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                                  bounds: &[ast::TyParamBound])\n+                                  -> Ty<'tcx>\n {\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n@@ -909,20 +968,17 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n {\n     let tcx = this.tcx();\n     let ty_param_def_id = provenance.def_id();\n+\n     let mut suitable_bounds: Vec<_>;\n     let ty_param_name: ast::Name;\n     { // contain scope of refcell:\n         let ty_param_defs = tcx.ty_param_defs.borrow();\n         let ty_param_def = &ty_param_defs[ty_param_def_id.node];\n         ty_param_name = ty_param_def.name;\n \n-        // FIXME(#19541): we should consider associated types in\n-        // super-traits. Probably by elaborating the bounds.\n-\n+        // FIXME(#20300) -- search where clauses, not bounds\n         suitable_bounds =\n-            ty_param_def.bounds.trait_bounds // FIXME(#20300) -- search where clauses, not bounds\n-            .iter()\n-            .cloned()\n+            traits::transitive_bounds(tcx, ty_param_def.bounds.trait_bounds.as_slice())\n             .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n             .collect();\n     }\n@@ -963,12 +1019,11 @@ fn trait_defines_associated_type_named(this: &AstConv,\n     trait_def.associated_type_names.contains(&assoc_name)\n }\n \n-fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n-                           rscope: &RS,\n-                           ast_ty: &ast::Ty, // the TyQPath\n-                           qpath: &ast::QPath)\n-                           -> Ty<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                     rscope: &RegionScope,\n+                     ast_ty: &ast::Ty, // the TyQPath\n+                     qpath: &ast::QPath)\n+                     -> Ty<'tcx>\n {\n     debug!(\"qpath_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -992,8 +1047,8 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n \n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n-pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>\n+pub fn ast_ty_to_ty<'tcx>(\n+        this: &AstConv<'tcx>, rscope: &RegionScope, ast_ty: &ast::Ty) -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1205,10 +1260,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     return typ;\n }\n \n-pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n-                                                           a: &ast::Arg,\n-                                                           expected_ty: Option<Ty<'tcx>>)\n-                                                           -> Ty<'tcx> {\n+pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n+                       rscope: &RegionScope,\n+                       a: &ast::Arg,\n+                       expected_ty: Option<Ty<'tcx>>)\n+                       -> Ty<'tcx>\n+{\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -1221,14 +1278,13 @@ struct SelfInfo<'a, 'tcx> {\n     explicit_self: &'a ast::ExplicitSelf,\n }\n \n-pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n-                    this: &AC,\n-                    unsafety: ast::Unsafety,\n-                    untransformed_self_ty: Ty<'tcx>,\n-                    explicit_self: &ast::ExplicitSelf,\n-                    decl: &ast::FnDecl,\n-                    abi: abi::Abi)\n-                    -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n+                          unsafety: ast::Unsafety,\n+                          untransformed_self_ty: Ty<'tcx>,\n+                          explicit_self: &ast::ExplicitSelf,\n+                          decl: &ast::FnDecl,\n+                          abi: abi::Abi)\n+                          -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self,\n@@ -1242,20 +1298,18 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, unsafety: ast::Unsafety, abi: abi::Abi,\n+pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx>, unsafety: ast::Unsafety, abi: abi::Abi,\n                                               decl: &ast::FnDecl) -> ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, unsafety, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n-                           this: &AC,\n-                           unsafety: ast::Unsafety,\n-                           abi: abi::Abi,\n-                           opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n-                           decl: &ast::FnDecl)\n-                           -> (ty::BareFnTy<'tcx>,\n-                               Option<ty::ExplicitSelfCategory>)\n+fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n+                                     unsafety: ast::Unsafety,\n+                                     abi: abi::Abi,\n+                                     opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n+                                     decl: &ast::FnDecl)\n+                                     -> (ty::BareFnTy<'tcx>, Option<ty::ExplicitSelfCategory>)\n {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1357,12 +1411,10 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n-                                    RS:RegionScope>(\n-                                    this: &AC,\n-                                    rscope: &RS,\n-                                    self_info: &SelfInfo<'a, 'tcx>)\n-                                    -> ty::ExplicitSelfCategory\n+fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n+                                              rscope: &RegionScope,\n+                                              self_info: &SelfInfo<'a, 'tcx>)\n+                                              -> ty::ExplicitSelfCategory\n {\n     return match self_info.explicit_self.node {\n         ast::SelfStatic => ty::StaticExplicitSelfCategory,\n@@ -1439,8 +1491,8 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n     }\n }\n \n-pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n-    this: &AC,\n+pub fn ty_of_closure<'tcx>(\n+    this: &AstConv<'tcx>,\n     unsafety: ast::Unsafety,\n     onceness: ast::Onceness,\n     bounds: ty::ExistentialBounds<'tcx>,\n@@ -1501,9 +1553,9 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n /// `ExistentialBounds` struct. The `main_trait_refs` argument specifies the `Foo` -- it is absent\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n-pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn conv_existential_bounds<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -1517,13 +1569,12 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         this, rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n }\n \n-fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn conv_ty_poly_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n-    where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n@@ -1556,15 +1607,14 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     }\n }\n \n-pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds<'tcx>\n-    where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let PartitionedBounds { builtin_bounds,\n                             trait_bounds,\n@@ -1657,9 +1707,9 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// A version of `compute_opt_region_bound` for use where some region bound is required\n /// (existential types, basically). Reports an error if no region bound can be derived and we are\n /// in an `rscope` that does not provide a default.\n-fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+fn compute_region_bound<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for closures"}, {"sha": "8b62c55ba31eb31a7e8899618fbdadd50d7dcbed", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -4939,7 +4939,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx().map.span(variants[i].id.node),\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].id.node),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}"}, {"sha": "bbafcdae1bba104b27a4ad05f95b2f03834fd224", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 107, "deletions": 98, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -40,11 +40,12 @@ use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitCont\n use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n+use no_params;\n use rscope::*;\n-use {CrateCtxt, no_params, write_ty_to_tcx};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n+use write_ty_to_tcx;\n \n use std::rc::Rc;\n \n@@ -61,13 +62,8 @@ use syntax::visit;\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types(ccx: &CrateCtxt) {\n-    fn collect_intrinsic_type(ccx: &CrateCtxt,\n-                              lang_item: ast::DefId) {\n-        let ty::TypeScheme { ty, .. } =\n-            ccx.get_item_type_scheme(lang_item);\n-        ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n-    }\n+pub fn collect_item_types(tcx: &ty::ctxt) {\n+    let ccx = &CollectCtxt { tcx: tcx };\n \n     match ccx.tcx.lang_items.ty_desc() {\n         Some(id) => { collect_intrinsic_type(ccx, id); }\n@@ -85,13 +81,29 @@ pub fn collect_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+\n+struct CollectCtxt<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Zeroth phase: collect types of intrinsics\n+\n+fn collect_intrinsic_type(ccx: &CollectCtxt,\n+                          lang_item: ast::DefId) {\n+    let ty::TypeScheme { ty, .. } =\n+        ccx.get_item_type_scheme(lang_item);\n+    ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // First phase: just collect *trait definitions* -- basically, the set\n // of type parameters and supertraits. This is information we need to\n // know later when parsing field defs.\n \n struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n+    ccx: &'a CollectCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n@@ -112,7 +124,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n // Second phase: collection proper.\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n+    ccx: &'a CollectCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n@@ -133,13 +145,13 @@ pub trait ToTy<'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n+impl<'a,'tcx> ToTy<'tcx> for CollectCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n@@ -148,7 +160,9 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n         }\n \n         match self.tcx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => ty_of_item(self, &*item),\n+            Some(ast_map::NodeItem(item)) => {\n+                ty_of_item(self, &*item)\n+            }\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n                 ty_of_foreign_item(self, &*foreign_item, abi)\n@@ -181,7 +195,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                         enum_ty: Ty<'tcx>,\n                                         variants: &[P<ast::Variant>],\n                                         generics: &ast::Generics) {\n@@ -226,7 +240,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n@@ -322,15 +336,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             TypeScheme {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n     }\n \n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            _trait_items: &[ast::TraitItem],\n@@ -372,7 +386,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_generics: &ty::Generics<'tcx>,\n                                 v: &ast::StructField,\n                                 origin: ast::DefId) -> ty::field_ty {\n@@ -405,7 +419,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n {\n@@ -422,7 +436,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                ty::TypeTraitItem(associated_type));\n }\n \n-fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n                                  mut ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n@@ -469,7 +483,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n@@ -506,7 +520,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n+fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n@@ -535,7 +549,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n+fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n@@ -636,7 +650,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             debug!(\"trait_def: ident={} trait_def={}\",\n                    it.ident.repr(ccx.tcx),\n-                   trait_def.repr(ccx.tcx()));\n+                   trait_def.repr(ccx.tcx));\n \n             for trait_method in trait_methods.iter() {\n                 let self_type = ty::mk_self_type(tcx);\n@@ -706,7 +720,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_def: &ast::StructDef,\n                                 scheme: ty::TypeScheme<'tcx>,\n                                 id: ast::NodeId) {\n@@ -773,7 +787,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n+fn convert_foreign(ccx: &CollectCtxt, i: &ast::ForeignItem) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -790,7 +804,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n@@ -806,9 +820,9 @@ fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                   it: &ast::Item)\n-                                   -> Rc<ty::TraitDef<'tcx>>\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                               it: &ast::Item)\n+                               -> Rc<ty::TraitDef<'tcx>>\n {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -872,7 +886,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     return trait_def;\n \n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n@@ -903,7 +917,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n+fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n                             -> ty::TypeScheme<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -985,7 +999,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     }\n }\n \n-pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_of_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     it: &ast::ForeignItem,\n                                     abi: abi::Abi) -> ty::TypeScheme<'tcx>\n {\n@@ -1006,7 +1020,7 @@ pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n@@ -1017,7 +1031,7 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 &generics.where_clause)\n }\n \n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n@@ -1077,7 +1091,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     return generics;\n \n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n                                                  trait_items: &[ast::TraitItem])\n                                                  -> Vec<ty::Predicate<'tcx>>\n@@ -1108,14 +1122,13 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_fn_or_method<'tcx,AC>(\n-        this: &AC,\n-        generics: &ast::Generics,\n-        base_generics: ty::Generics<'tcx>)\n-        -> ty::Generics<'tcx>\n-        where AC: AstConv<'tcx> {\n+fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                         generics: &ast::Generics,\n+                                         base_generics: ty::Generics<'tcx>)\n+                                         -> ty::Generics<'tcx>\n+{\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(this,\n+    ty_generics(ccx,\n                 subst::FnSpace,\n                 early_lifetimes[],\n                 generics.ty_params[],\n@@ -1124,11 +1137,11 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'tcx,AC>(this: &AC,\n+fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               bounds: &mut ty::BuiltinBounds,\n                               ast_bounds: &[ast::TyParamBound],\n                               span: Span)\n-                              where AC: AstConv<'tcx> {\n+{\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds.iter() {\n@@ -1137,52 +1150,51 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                this.tcx().sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n     }\n \n-    let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n+    let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n+            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n-                    this.tcx().sess.span_warn(span,\n+                    ccx.tcx.sess.span_warn(span,\n                                               \"default bound relaxed for a type parameter, but \\\n                                                this does nothing because the given bound is not \\\n                                                a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(this.tcx(),\n+                    ty::try_add_builtin_trait(ccx.tcx,\n                                               kind_id,\n                                               bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n+            ty::try_add_builtin_trait(ccx.tcx, kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n }\n \n-fn ty_generics<'tcx,AC>(this: &AC,\n+fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics<'tcx>,\n                         where_clause: &ast::WhereClause)\n                         -> ty::Generics<'tcx>\n-                        where AC: AstConv<'tcx>\n {\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n         let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(this.tcx(), l))\n+                             .map(|l| ast_region_to_region(ccx.tcx, l))\n                              .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n@@ -1197,33 +1209,33 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     // Now create the real type parameters.\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(this,\n+        let def = get_or_create_type_parameter_def(ccx,\n                                                    space,\n                                                    param,\n                                                    i as u32);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n-               def.repr(this.tcx()),\n+               def.repr(ccx.tcx),\n                space);\n         result.types.push(space, def);\n     }\n \n     // Just for fun, also push the bounds from the type parameters\n     // into the predicates list. This is currently kind of non-DRY.\n-    create_predicates(this.tcx(), &mut result, space);\n+    create_predicates(ccx.tcx, &mut result, space);\n \n     // Add the bounds not associated with a type parameter\n     for predicate in where_clause.predicates.iter() {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(this, &ExplicitRscope, &*bound_pred.bounded_ty);\n+                let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n-                                this,\n+                                ccx,\n                                 &ExplicitRscope,\n                                 poly_trait_ref,\n                                 Some(ty),\n@@ -1238,7 +1250,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(this.tcx(), lifetime);\n+                            let region = ast_region_to_region(ccx.tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1247,17 +1259,17 @@ fn ty_generics<'tcx,AC>(this: &AC,\n             }\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(this.tcx(), &region_pred.lifetime);\n+                let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n                 for bound in region_pred.bounds.iter() {\n-                    let r2 = ast_region_to_region(this.tcx(), bound);\n+                    let r2 = ast_region_to_region(ccx.tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n             &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                this.tcx().sess.span_bug(eq_pred.span,\n+                ccx.tcx.sess.span_bug(eq_pred.span,\n                                          \"Equality constraints are not yet \\\n                                             implemented (#20041)\")\n             }\n@@ -1292,34 +1304,33 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     }\n }\n \n-fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n+fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n                                              index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n-    where AC: AstConv<'tcx>\n {\n-    match this.tcx().ty_param_defs.borrow().get(&param.id) {\n+    match ccx.tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return (*d).clone(); }\n         None => { }\n     }\n \n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n-    let bounds = compute_bounds(this,\n-                                param_ty.to_ty(this.tcx()),\n+    let bounds = compute_bounds(ccx,\n+                                param_ty.to_ty(ccx.tcx),\n                                 param.bounds[],\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n-            let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n+            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n                 match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n-                        span_err!(this.tcx().sess, path.span, E0128,\n+                        span_err!(ccx.tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n                         },\n@@ -1340,7 +1351,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n         default: default\n     };\n \n-    this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     def\n }\n@@ -1350,26 +1361,25 @@ enum SizedByDefault { Yes, No }\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'tcx,AC>(this: &AC,\n+fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            sized_by_default: SizedByDefault,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n-                           where AC: AstConv<'tcx>\n {\n-    let mut param_bounds = conv_param_bounds(this,\n+    let mut param_bounds = conv_param_bounds(ccx,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(this,\n+        add_unsized_bound(ccx,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(this.tcx(),\n+        check_bounds_compatible(ccx.tcx,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1404,24 +1414,23 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn conv_param_bounds<'tcx,AC>(this: &AC,\n+fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n-                              where AC: AstConv<'tcx>\n {\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n                                      region_bounds } =\n-        astconv::partition_bounds(this.tcx(), span, ast_bounds.as_slice());\n+        astconv::partition_bounds(ccx.tcx, span, ast_bounds.as_slice());\n \n     let mut projection_bounds = Vec::new();\n \n     let trait_bounds: Vec<ty::PolyTraitRef> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(this,\n+            astconv::instantiate_poly_trait_ref(ccx,\n                                                 &ExplicitRscope,\n                                                 bound,\n                                                 Some(param_ty),\n@@ -1430,7 +1439,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-        .map(|r| ast_region_to_region(this.tcx(), r))\n+        .map(|r| ast_region_to_region(ccx.tcx, r))\n         .collect();\n     ty::ParamBounds {\n         region_bounds: region_bounds,\n@@ -1440,7 +1449,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     }\n }\n \n-pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        decl: &ast::FnDecl,\n                                        def_id: ast::DefId,\n                                        ast_generics: &ast::Generics,\n@@ -1492,9 +1501,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     return scheme;\n }\n \n-pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                ty_generics: &ty::Generics<'tcx>)\n-                                -> subst::Substs<'tcx>\n+fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                            ty_generics: &ty::Generics<'tcx>)\n+                            -> subst::Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -1514,14 +1523,14 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// comes back to check after the fact that explicit type the user\n /// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n-    crate_context: &CrateCtxt<'a, 'tcx>,\n+    ccx: &CollectCtxt<'a, 'tcx>,\n     rs: &RS,\n     required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = crate_context.to_ty(rs, &**ast_type);\n+        let typ = ccx.to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n             ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n             ty::ty_uniq(typ) => typ,\n@@ -1537,35 +1546,35 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n             liberate_early_bound_regions(\n-                crate_context.tcx, body_scope,\n+                ccx.tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::Binder(required_type)));\n+                    ccx.tcx, body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n-                crate_context.tcx, body_scope,\n+                ccx.tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::Binder(base_type)));\n+                    ccx.tcx, body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n-               required_type.repr(crate_context.tcx),\n-               required_type_free.repr(crate_context.tcx),\n-               base_type.repr(crate_context.tcx),\n-               base_type_free.repr(crate_context.tcx));\n-        let infcx = infer::new_infer_ctxt(crate_context.tcx);\n-        drop(::require_same_types(crate_context.tcx,\n+               required_type.repr(ccx.tcx),\n+               required_type_free.repr(ccx.tcx),\n+               base_type.repr(ccx.tcx),\n+               base_type_free.repr(ccx.tcx));\n+        let infcx = infer::new_infer_ctxt(ccx.tcx);\n+        drop(::require_same_types(ccx.tcx,\n                                   Some(&infcx),\n                                   false,\n                                   explicit_self.span,\n                                   base_type_free,\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                        ppaux::ty_to_string(crate_context.tcx, required_type))\n+                        ppaux::ty_to_string(ccx.tcx, required_type))\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }"}, {"sha": "3146a1181396b439ca00885e59d85d340940d110", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -119,7 +119,7 @@ struct TypeAndSubsts<'tcx> {\n struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: ty::TraitMap,\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n // Functions that write types into the node type table\n@@ -320,7 +320,7 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(&ccx));\n+         collect::collect_item_types(tcx));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error"}, {"sha": "6555aa32027797cc32d91d78b4eebecf5f57b2a3", "filename": "src/test/compile-fail/associated-type-projection-from-multiple-supertraits.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints in a where clause where the type being\n+// equated appears in a supertrait.\n+\n+#![feature(associated_types)]\n+\n+pub trait Vehicle {\n+    type Color;\n+\n+    fn go(&self) {  }\n+}\n+\n+pub trait Box {\n+    type Color;\n+\n+    fn mail(&self) {  }\n+}\n+\n+pub trait BoxCar : Box + Vehicle {\n+}\n+\n+fn dent<C:BoxCar>(c: C, color: C::Color) {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+    //~| NOTE could derive from `Vehicle`\n+    //~| NOTE could derive from `Box`\n+}\n+\n+fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n+    //~^ ERROR ambiguous associated type\n+}\n+\n+fn paint<C:BoxCar>(c: C, d: C::Color) {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+    //~| NOTE could derive from `Vehicle`\n+    //~| NOTE could derive from `Box`\n+}\n+\n+pub fn main() { }"}, {"sha": "01f9bd3541fc58f53315ad95d7e87ecd619afe7f", "filename": "src/test/compile-fail/associated-type-projection-from-supertrait.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints in a where clause where the type being\n+// equated appears in a supertrait.\n+\n+#![feature(associated_types)]\n+\n+pub trait Vehicle {\n+    type Color;\n+\n+    fn go(&self) {  }\n+}\n+\n+pub trait Car : Vehicle {\n+    fn honk(&self) { }\n+    fn chip_paint(&self, c: Self::Color) { }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct Black;\n+struct ModelT;\n+impl Vehicle for ModelT { type Color = Black; }\n+impl Car for ModelT { }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct Blue;\n+struct ModelU;\n+impl Vehicle for ModelU { type Color = Blue; }\n+impl Car for ModelU { }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+fn dent<C:Car>(c: C, color: C::Color) { c.chip_paint(color) }\n+fn a() { dent(ModelT, Black); }\n+fn b() { dent(ModelT, Blue); } //~ ERROR type mismatch\n+fn c() { dent(ModelU, Black); } //~ ERROR type mismatch\n+fn d() { dent(ModelU, Blue); }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+fn e() { ModelT.chip_paint(Black); }\n+fn f() { ModelT.chip_paint(Blue); } //~ ERROR mismatched types\n+fn g() { ModelU.chip_paint(Black); } //~ ERROR mismatched types\n+fn h() { ModelU.chip_paint(Blue); }\n+\n+pub fn main() { }"}, {"sha": "a362529bee8e423f963af38915dd061958ab2985", "filename": "src/test/compile-fail/associated-types-binding-to-type-defined-in-supertrait.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Fcompile-fail%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-binding-to-type-defined-in-supertrait.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints in a where clause where the type being\n+// equated appears in a supertrait.\n+\n+#![feature(associated_types)]\n+\n+pub trait Vehicle {\n+    type Color;\n+\n+    fn go(&self) {  }\n+}\n+\n+pub trait Car : Vehicle {\n+    fn honk(&self) { }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct Black;\n+struct ModelT;\n+impl Vehicle for ModelT { type Color = Black; }\n+impl Car for ModelT { }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct Blue;\n+struct ModelU;\n+impl Vehicle for ModelU { type Color = Blue; }\n+impl Car for ModelU { }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+fn black_car<C:Car<Color=Black>>(c: C) {\n+}\n+\n+fn blue_car<C:Car<Color=Blue>>(c: C) {\n+}\n+\n+fn a() { black_car(ModelT); }\n+fn b() { blue_car(ModelT); } //~ ERROR type mismatch\n+fn c() { black_car(ModelU); } //~ ERROR type mismatch\n+fn d() { blue_car(ModelU); }\n+\n+pub fn main() { }"}, {"sha": "429027cbf304dc219ecd3b23c3ea9cb018edf3d2", "filename": "src/test/run-pass/associated-type-doubleendediterator-object.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn pairwise_sub(mut t: Box<DoubleEndedIterator<Item=int>>) -> int {\n+    let mut result = 0;\n+    loop {\n+        let front = t.next();\n+        let back = t.next_back();\n+        match (front, back) {\n+            (Some(f), Some(b)) => { result += b - f; }\n+            _ => { return result; }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = vec!(1, 2, 3, 4, 5, 6);\n+    let r = pairwise_sub(box v.into_iter());\n+    assert_eq!(r, 9);\n+}"}, {"sha": "f8258466a7d43d529d534b89e42c0297e67789a3", "filename": "src/test/run-pass/associated-types-iterator-binding.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs?ref=f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn pairwise_sub<T:DoubleEndedIterator<Item=int>>(mut t: T) -> int {\n+    let mut result = 0;\n+    loop {\n+        let front = t.next();\n+        let back = t.next_back();\n+        match (front, back) {\n+            (Some(f), Some(b)) => { result += b - f; }\n+            _ => { return result; }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = vec!(1, 2, 3, 4, 5, 6);\n+    let r =pairwise_sub(v.into_iter());\n+    assert_eq!(r, 9);\n+}"}]}