{"sha": "6323a012bd1417451cd81f00679039d630dc1695", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMjNhMDEyYmQxNDE3NDUxY2Q4MWYwMDY3OTAzOWQ2MzBkYzE2OTU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-20T09:42:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-20T11:15:21Z"}, "message": "Remove taskptr argument from upcalls\n\nIssue #466", "tree": {"sha": "0398fcc0e52e8cc0dd62668704c1889263f69a3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0398fcc0e52e8cc0dd62668704c1889263f69a3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6323a012bd1417451cd81f00679039d630dc1695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6323a012bd1417451cd81f00679039d630dc1695", "html_url": "https://github.com/rust-lang/rust/commit/6323a012bd1417451cd81f00679039d630dc1695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6323a012bd1417451cd81f00679039d630dc1695/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e927df17f7f9c150fcbfd566927ad29ff5eb6f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/e927df17f7f9c150fcbfd566927ad29ff5eb6f15", "html_url": "https://github.com/rust-lang/rust/commit/e927df17f7f9c150fcbfd566927ad29ff5eb6f15"}], "stats": {"total": 117, "additions": 54, "deletions": 63}, "files": [{"sha": "693212bfb8921fe883e4f1527a233489e2d4b8a0", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=6323a012bd1417451cd81f00679039d630dc1695", "patch": "@@ -39,13 +39,8 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef, name: str,\n-                         tys: [TypeRef], rv: TypeRef) -> ValueRef {\n-        ret decl(llmod, name, [taskptr_type] + tys, rv);\n-    }\n-    let dv = bind decl_with_taskptr(taskptr_type, llmod, _, _, T_void());\n-    let d = bind decl_with_taskptr(taskptr_type, llmod, _, _, _);\n-    let dr = bind decl(llmod, _, _, _);\n+    let d = bind decl(llmod, _, _, _);\n+    let dv = bind decl(llmod, _, _, T_void());\n \n     ret @{_fail: dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n           malloc:\n@@ -61,31 +56,28 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n                 [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n                  T_ptr(T_ptr(tydesc_type)), T_int()], T_ptr(tydesc_type)),\n           vec_grow:\n-              d(\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()],\n-                T_void()),\n+              dv(\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()]),\n           vec_push:\n-              d(\"vec_push\",\n-                [T_ptr(T_ptr(T_opaque_vec())), T_ptr(tydesc_type),\n-                 T_ptr(T_i8())], T_void()),\n+              dv(\"vec_push\",\n+                 [T_ptr(T_ptr(T_opaque_vec())), T_ptr(tydesc_type),\n+                  T_ptr(T_i8())]),\n           cmp_type:\n-              dr(\"cmp_type\",\n+              dv(\"cmp_type\",\n                  [T_ptr(T_i1()), taskptr_type, T_ptr(tydesc_type),\n                   T_ptr(T_ptr(tydesc_type)), T_ptr(T_i8()), T_ptr(T_i8()),\n-                  T_i8()], T_void()),\n+                  T_i8()]),\n           log_type:\n-              dr(\"log_type\",\n-                 [taskptr_type, T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()],\n-                 T_void()),\n+              dv(\"log_type\", [T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()]),\n           dynastack_mark: d(\"dynastack_mark\", [], T_ptr(T_i8())),\n           dynastack_alloc:\n               d(\"dynastack_alloc_2\", [T_size_t(), T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          dynastack_free: d(\"dynastack_free\", [T_ptr(T_i8())], T_void()),\n-          alloc_c_stack: dr(\"alloc_c_stack\", [T_size_t()], T_ptr(T_i8())),\n-          call_c_stack: dr(\"call_c_stack\",\n-                           [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n-                           T_int()),\n-          rust_personality: dr(\"rust_personality\", [], T_i32())\n+          dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n+          alloc_c_stack: d(\"alloc_c_stack\", [T_size_t()], T_ptr(T_i8())),\n+          call_c_stack: d(\"call_c_stack\",\n+                          [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n+                          T_int()),\n+          rust_personality: d(\"rust_personality\", [], T_i32())\n          };\n }\n //"}, {"sha": "2e63306ee01e8e5d0543da50635563a78e0eb59b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6323a012bd1417451cd81f00679039d630dc1695", "patch": "@@ -389,13 +389,13 @@ fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n \n fn trans_non_gc_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n     Call(cx, bcx_ccx(cx).upcalls.free,\n-         [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8())), C_int(0)]);\n+         [PointerCast(cx, v, T_ptr(T_i8())), C_int(0)]);\n     ret cx;\n }\n \n fn trans_shared_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n     Call(cx, bcx_ccx(cx).upcalls.shared_free,\n-         [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8()))]);\n+         [PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n }\n \n@@ -462,11 +462,10 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n     let bcx = cx;\n     let dy_cx = new_raw_block_ctxt(cx.fcx, cx.fcx.lldynamicallocas);\n-    let lltaskptr = bcx_fcx(bcx).lltaskptr;\n     alt bcx_fcx(cx).llobstacktoken {\n       none. {\n         bcx_fcx(cx).llobstacktoken =\n-            some(mk_obstack_token(bcx_ccx(cx), cx.fcx, lltaskptr));\n+            some(mk_obstack_token(bcx_ccx(cx), cx.fcx));\n       }\n       some(_) {/* no-op */ }\n     }\n@@ -477,14 +476,14 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     let ti = none;\n     let lltydesc = get_tydesc(cx, ty, false, tps_normal, ti).result.val;\n \n-    let llresult = Call(dy_cx, dynastack_alloc, [lltaskptr, llsz, lltydesc]);\n+    let llresult = Call(dy_cx, dynastack_alloc, [llsz, lltydesc]);\n     ret PointerCast(dy_cx, llresult, T_ptr(t));\n }\n \n-fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt, lltaskptr: ValueRef) ->\n+fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n    ValueRef {\n     let cx = new_raw_block_ctxt(fcx, fcx.lldynamicallocas);\n-    ret Call(cx, ccx.upcalls.dynastack_mark, [lltaskptr]);\n+    ret Call(cx, ccx.upcalls.dynastack_mark, []);\n }\n \n \n@@ -836,7 +835,7 @@ fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n     let tydesc = C_null(T_ptr(bcx_ccx(cx).tydesc_type));\n     let rval =\n         Call(cx, bcx_ccx(cx).upcalls.shared_malloc,\n-             [cx.fcx.lltaskptr, llsize, tydesc]);\n+             [llsize, tydesc]);\n     ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n \n@@ -875,7 +874,7 @@ fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n     let lltydesc = tydesc_result.result.val; bcx = tydesc_result.result.bcx;\n \n     let rval = Call(cx, ccx.upcalls.malloc,\n-                    [cx.fcx.lltaskptr, llsz, lltydesc]);\n+                    [llsz, lltydesc]);\n     ret rslt(cx, PointerCast(cx, rval, llty));\n }\n \n@@ -1034,7 +1033,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     if escapes {\n         let td_val =\n             Call(bcx, bcx_ccx(bcx).upcalls.get_type_desc,\n-                 [bcx.fcx.lltaskptr, C_null(T_ptr(T_nil())), sz.val,\n+                 [C_null(T_ptr(T_nil())), sz.val,\n                   align.val, C_uint(1u + n_params), llfirstparam,\n                   C_uint(obj_params)]);\n         v = td_val;\n@@ -1938,10 +1937,8 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     }\n \n     let llcmpresultptr = alloca(bcx, T_i1());\n-    let llargs: [ValueRef] =\n-        [llcmpresultptr, bcx.fcx.lltaskptr, lltydesc, lltydescs, llrawlhsptr,\n-         llrawrhsptr, llop];\n-    Call(bcx, llfn, llargs);\n+    Call(bcx, llfn, [llcmpresultptr, bcx.fcx.lltaskptr, lltydesc, lltydescs,\n+                     llrawlhsptr, llrawrhsptr, llop]);\n     ret rslt(bcx, Load(bcx, llcmpresultptr));\n }\n \n@@ -4556,7 +4553,7 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n \n     Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n-         [log_bcx.fcx.lltaskptr, lltydesc, llval_i8, C_int(lvl)]);\n+         [lltydesc, llval_i8, C_int(lvl)]);\n \n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     Br(log_bcx, after_cx.llbb);\n@@ -4619,7 +4616,7 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n     }\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n     V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n-    let args = [bcx.fcx.lltaskptr, V_str, V_filename, C_int(V_line)];\n+    let args = [V_str, V_filename, C_int(V_line)];\n     let bcx = invoke(bcx, bcx_ccx(bcx).upcalls._fail, args);\n     Unreachable(bcx);\n     ret bcx;\n@@ -4932,8 +4929,7 @@ fn trans_fn_cleanups(fcx: @fn_ctxt, cx: @block_ctxt) {\n     alt fcx.llobstacktoken {\n       some(lltoken_) {\n         let lltoken = lltoken_; // satisfy alias checker\n-        Call(cx, fcx_ccx(fcx).upcalls.dynastack_free,\n-             [fcx.lltaskptr, lltoken]);\n+        Call(cx, fcx_ccx(fcx).upcalls.dynastack_free, [lltoken]);\n       }\n       none. {/* nothing to do */ }\n     }"}, {"sha": "124c109692709a98de88604a48c0a08358441041", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6323a012bd1417451cd81f00679039d630dc1695/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=6323a012bd1417451cd81f00679039d630dc1695", "patch": "@@ -163,7 +163,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n     Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n-         [cx.fcx.lltaskptr, opaque_lhs, new_fill]);\n+         [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n     rhs = Select(bcx, self_append, lhs, rhs);\n@@ -204,8 +204,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n         let spilled = r.val;\n         bcx = r.bcx;\n         Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n-             [bcx.fcx.lltaskptr, opaque_v, td,\n-              PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n+             [opaque_v, td, PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n     ret bcx;\n }"}, {"sha": "8fa82b754814a8fb1f02ccbecf2e8a02edddfeee", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6323a012bd1417451cd81f00679039d630dc1695/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6323a012bd1417451cd81f00679039d630dc1695/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=6323a012bd1417451cd81f00679039d630dc1695", "patch": "@@ -552,8 +552,8 @@ upcall_cmp_type(int8_t *result, rust_task *task, const type_desc *tydesc,\n }\n \n extern \"C\" void\n-upcall_log_type(rust_task *task, const type_desc *tydesc, uint8_t *data,\n-                uint32_t level) {\n+upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n+    rust_task *task = rust_scheduler::get_task();\n     if (task->sched->log_lvl < level)\n         return;     // TODO: Don't evaluate at all?\n "}, {"sha": "aaa738c2fd4f32c63d82a0aab907563427c70bc5", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6323a012bd1417451cd81f00679039d630dc1695/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6323a012bd1417451cd81f00679039d630dc1695/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=6323a012bd1417451cd81f00679039d630dc1695", "patch": "@@ -55,7 +55,7 @@ upcall_fail(rust_task *task,\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_malloc(rust_task *unused_task, size_t nbytes, type_desc *td) {\n+upcall_malloc(size_t nbytes, type_desc *td) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n@@ -85,7 +85,8 @@ upcall_malloc(rust_task *unused_task, size_t nbytes, type_desc *td) {\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n+upcall_free(void* ptr, uintptr_t is_gc) {\n+    rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n@@ -100,7 +101,8 @@ upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_shared_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n+upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+    rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n@@ -119,7 +121,8 @@ upcall_shared_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_shared_free(rust_task *task, void* ptr) {\n+upcall_shared_free(void* ptr) {\n+    rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n@@ -130,13 +133,13 @@ upcall_shared_free(rust_task *task, void* ptr) {\n }\n \n extern \"C\" CDECL type_desc *\n-upcall_get_type_desc(rust_task *task,\n-                     void *curr_crate, // ignored, legacy compat.\n+upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n                      size_t size,\n                      size_t align,\n                      size_t n_descs,\n                      type_desc const **descs,\n                      uintptr_t n_obj_params) {\n+    rust_task *task = rust_scheduler::get_task();\n     check_stack(task);\n     LOG_UPCALL_ENTRY(task);\n \n@@ -151,15 +154,16 @@ upcall_get_type_desc(rust_task *task,\n }\n \n extern \"C\" CDECL void\n-upcall_vec_grow(rust_task* task, rust_vec** vp, size_t new_sz) {\n+upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+    rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, vp, new_sz);\n     (*vp)->fill = new_sz;\n }\n \n extern \"C\" CDECL void\n-upcall_vec_push(rust_task* task, rust_vec** vp, type_desc* elt_ty,\n-                void* elt) {\n+upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+    rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n     size_t new_sz = (*vp)->fill + elt_ty->size;\n     reserve_vec(task, vp, new_sz);\n@@ -173,8 +177,8 @@ upcall_vec_push(rust_task* task, rust_vec** vp, type_desc* elt_ty,\n  * space in the dynamic stack.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_mark(rust_task *task) {\n-    return task->dynastack.mark();\n+upcall_dynastack_mark() {\n+    return rust_scheduler::get_task()->dynastack.mark();\n }\n \n /**\n@@ -183,23 +187,23 @@ upcall_dynastack_mark(rust_task *task) {\n  * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc(rust_task *task, size_t sz) {\n-    return sz ? task->dynastack.alloc(sz, NULL) : NULL;\n+upcall_dynastack_alloc(size_t sz) {\n+    return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n /**\n  * Allocates space associated with a type descriptor in the dynamic stack and\n  * returns it.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc_2(rust_task *task, size_t sz, type_desc *ty) {\n-    return sz ? task->dynastack.alloc(sz, ty) : NULL;\n+upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+    return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n /** Frees space in the dynamic stack. */\n extern \"C\" CDECL void\n-upcall_dynastack_free(rust_task *task, void *ptr) {\n-    return task->dynastack.free(ptr);\n+upcall_dynastack_free(void *ptr) {\n+    return rust_scheduler::get_task()->dynastack.free(ptr);\n }\n \n /**"}]}