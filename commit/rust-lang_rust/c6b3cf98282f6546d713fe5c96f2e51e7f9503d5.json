{"sha": "c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YjNjZjk4MjgyZjY1NDZkNzEzZmU1Yzk2ZjJlNTFlN2Y5NTAzZDU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-09-19T05:08:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-19T05:08:17Z"}, "message": "Merge pull request #1983 from topecongiro/cleanup\n\nRefactoring: clean up source code", "tree": {"sha": "ae75656285d371ecb17dafa7a7f2c149f3fb5b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae75656285d371ecb17dafa7a7f2c149f3fb5b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "html_url": "https://github.com/rust-lang/rust/commit/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2c9e923b06153f6b31759be2a47ef7a7145cfd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c9e923b06153f6b31759be2a47ef7a7145cfd6", "html_url": "https://github.com/rust-lang/rust/commit/e2c9e923b06153f6b31759be2a47ef7a7145cfd6"}, {"sha": "0779962a6e36015662bec821be7752228a293322", "url": "https://api.github.com/repos/rust-lang/rust/commits/0779962a6e36015662bec821be7752228a293322", "html_url": "https://github.com/rust-lang/rust/commit/0779962a6e36015662bec821be7752228a293322"}], "stats": {"total": 1242, "additions": 627, "deletions": 615}, "files": [{"sha": "23c311b95897e2e2144c45bdc4f044ce71234f87", "filename": "src/chains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -76,7 +76,7 @@\n ///     .qux\n /// ```\n \n-use Shape;\n+use shape::Shape;\n use config::IndentStyle;\n use expr::rewrite_call;\n use macros::convert_try_mac;"}, {"sha": "f74684e58625d9f90769297dc69accf15e4ba155", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -14,9 +14,9 @@ use std::{self, iter};\n \n use syntax::codemap::Span;\n \n-use {Indent, Shape};\n use config::Config;\n use rewrite::RewriteContext;\n+use shape::{Indent, Shape};\n use string::{rewrite_string, StringFormat};\n use utils::{first_line_width, last_line_width};\n \n@@ -928,7 +928,7 @@ fn remove_comment_header(comment: &str) -> &str {\n mod test {\n     use super::{contains_comment, rewrite_comment, CharClasses, CodeCharKind, CommentCodeSlices,\n                 FindUncommented, FullCodeCharKind};\n-    use {Indent, Shape};\n+    use shape::{Indent, Shape};\n \n     #[test]\n     fn char_classes() {"}, {"sha": "dc6504de0b1146affb13268a8a45eb1b308683d2", "filename": "src/expr.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -17,7 +17,7 @@ use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, CodeMap, Span};\n use syntax::parse::classify;\n \n-use {Indent, Shape, Spanned};\n+use spanned::Spanned;\n use chains::rewrite_chain;\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n@@ -30,12 +30,13 @@ use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_format\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::{Indent, Shape};\n use string::{rewrite_string, StringFormat};\n use types::{can_be_overflowed_type, rewrite_path, PathContext};\n use utils::{colon_spaces, contains_skip, extra_offset, first_line_width, inner_attributes,\n             last_line_extendable, last_line_width, left_most_sub_expr, mk_sp, outer_attributes,\n             paren_overhead, ptr_vec_to_ref_vec, semicolon_for_stmt, stmt_expr,\n-            trimmed_last_line_width, wrap_str};\n+            trimmed_last_line_width};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -75,11 +76,7 @@ pub fn format_expr(\n             ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                 rewrite_string_lit(context, l.span, shape)\n             }\n-            _ => wrap_str(\n-                context.snippet(expr.span),\n-                context.config.max_width(),\n-                shape,\n-            ),\n+            _ => Some(context.snippet(expr.span)),\n         },\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi(), expr.span.hi());\n@@ -152,11 +149,7 @@ pub fn format_expr(\n                 Some(ident) => format!(\" {}\", ident.node),\n                 None => String::new(),\n             };\n-            wrap_str(\n-                format!(\"continue{}\", id_str),\n-                context.config.max_width(),\n-                shape,\n-            )\n+            Some(format!(\"continue{}\", id_str))\n         }\n         ast::ExprKind::Break(ref opt_ident, ref opt_expr) => {\n             let id_str = match *opt_ident {\n@@ -167,17 +160,13 @@ pub fn format_expr(\n             if let Some(ref expr) = *opt_expr {\n                 rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n             } else {\n-                wrap_str(\n-                    format!(\"break{}\", id_str),\n-                    context.config.max_width(),\n-                    shape,\n-                )\n+                Some(format!(\"break{}\", id_str))\n             }\n         }\n         ast::ExprKind::Yield(ref opt_expr) => if let Some(ref expr) = *opt_expr {\n             rewrite_unary_prefix(context, \"yield \", &**expr, shape)\n         } else {\n-            wrap_str(\"yield\".to_string(), context.config.max_width(), shape)\n+            Some(\"yield\".to_string())\n         },\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n             rewrite_closure(capture, fn_decl, body, expr.span, context, shape)\n@@ -189,17 +178,10 @@ pub fn format_expr(\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n-                wrap_str(\n-                    context.snippet(expr.span),\n-                    context.config.max_width(),\n-                    shape,\n-                )\n-            })\n-        }\n-        ast::ExprKind::Ret(None) => {\n-            wrap_str(\"return\".to_owned(), context.config.max_width(), shape)\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n+                .or_else(|| Some(context.snippet(expr.span)))\n         }\n+        ast::ExprKind::Ret(None) => Some(\"return\".to_owned()),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n             rewrite_unary_prefix(context, \"return \", &**expr, shape)\n         }\n@@ -301,16 +283,14 @@ pub fn format_expr(\n                     };\n                     rewrite_unary_suffix(context, &sp_delim, &*lhs, shape)\n                 }\n-                (None, None) => wrap_str(delim.into(), context.config.max_width(), shape),\n+                (None, None) => Some(delim.into()),\n             }\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n-        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => wrap_str(\n-            context.snippet(expr.span),\n-            context.config.max_width(),\n-            shape,\n-        ),\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => {\n+            Some(context.snippet(expr.span))\n+        }\n         ast::ExprKind::Catch(ref block) => {\n             if let rw @ Some(_) = rewrite_single_line_block(context, \"do catch \", block, shape) {\n                 rw\n@@ -382,7 +362,11 @@ where\n             .map(|first_line| first_line.ends_with('{'))\n             .unwrap_or(false);\n         if !rhs_result.contains('\\n') || allow_same_line {\n-            return Some(format!(\"{}{}{}{}\", lhs_result, infix, rhs_result, suffix));\n+            let one_line_width = last_line_width(&lhs_result) + infix.len()\n+                + first_line_width(&rhs_result) + suffix.len();\n+            if one_line_width <= shape.width {\n+                return Some(format!(\"{}{}{}{}\", lhs_result, infix, rhs_result, suffix));\n+            }\n         }\n     }\n \n@@ -2231,12 +2215,23 @@ where\n         _ if args.len() >= 1 => {\n             item_vec[args.len() - 1].item = args.last()\n                 .and_then(|last_arg| last_arg.rewrite(context, shape));\n-            tactic = definitive_tactic(\n-                &*item_vec,\n-                ListTactic::LimitedHorizontalVertical(args_max_width),\n-                Separator::Comma,\n-                one_line_width,\n-            );\n+            // Use horizontal layout for a function with a single argument as long as\n+            // everything fits in a single line.\n+            if args.len() == 1\n+                && args_max_width != 0 // Vertical layout is forced.\n+                && !item_vec[0].has_comment()\n+                && !item_vec[0].inner_as_ref().contains('\\n')\n+                && ::lists::total_item_width(&item_vec[0]) <= one_line_width\n+            {\n+                tactic = DefinitiveListTactic::Horizontal;\n+            } else {\n+                tactic = definitive_tactic(\n+                    &*item_vec,\n+                    ListTactic::LimitedHorizontalVertical(args_max_width),\n+                    Separator::Comma,\n+                    one_line_width,\n+                );\n+            }\n         }\n         _ => (),\n     }\n@@ -2664,11 +2659,7 @@ pub fn rewrite_field(\n     prefix_max_width: usize,\n ) -> Option<String> {\n     if contains_skip(&field.attrs) {\n-        return wrap_str(\n-            context.snippet(field.span()),\n-            context.config.max_width(),\n-            shape,\n-        );\n+        return Some(context.snippet(field.span()));\n     }\n     let name = &field.ident.node.to_string();\n     if field.is_shorthand {"}, {"sha": "a131038eb4e1d7dea9db5f8f4296460479576d6b", "filename": "src/file_lines.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -167,9 +167,7 @@ impl FileLines {\n }\n \n /// `FileLines` files iterator.\n-pub struct Files<'a>(\n-    Option<::std::collections::hash_map::Keys<'a, String, Vec<Range>>>,\n-);\n+pub struct Files<'a>(Option<::std::collections::hash_map::Keys<'a, String, Vec<Range>>>);\n \n impl<'a> iter::Iterator for Files<'a> {\n     type Item = &'a String;"}, {"sha": "4331ea84bc539405597947fbfc7df9e53e648022", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -13,13 +13,14 @@ use std::cmp::Ordering;\n use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n \n-use {Shape, Spanned};\n+use spanned::Spanned;\n use codemap::SpanUtils;\n use comment::combine_strs_with_missing_comments;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n use types::{rewrite_path, PathContext};\n use utils::{format_visibility, mk_sp};\n use visitor::{rewrite_extern_crate, FmtVisitor};"}, {"sha": "9d35c83501f00100016f08e0bd571ee536581eee", "filename": "src/items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -16,7 +16,7 @@ use syntax::{abi, ast, ptr, symbol};\n use syntax::ast::ImplItem;\n use syntax::codemap::{BytePos, Span};\n \n-use {Indent, Shape, Spanned};\n+use spanned::Spanned;\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n@@ -26,12 +26,13 @@ use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::{Indent, Shape};\n use types::join_bounds;\n use utils::{colon_spaces, contains_skip, end_typaram, first_line_width, format_abi,\n             format_constness, format_defaultness, format_mutability, format_unsafety,\n             format_visibility, is_attributes_extendable, last_line_contains_single_line_comment,\n             last_line_used_width, last_line_width, mk_sp, semicolon_for_expr, stmt_expr,\n-            trim_newlines, trimmed_last_line_width, wrap_str};\n+            trim_newlines, trimmed_last_line_width};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -1360,8 +1361,7 @@ pub fn rewrite_struct_field(\n     lhs_max_width: usize,\n ) -> Option<String> {\n     if contains_skip(&field.attrs) {\n-        let span = context.snippet(mk_sp(field.attrs[0].span.lo(), field.span.hi()));\n-        return wrap_str(span, context.config.max_width(), shape);\n+        return Some(context.snippet(mk_sp(field.attrs[0].span.lo(), field.span.hi())));\n     }\n \n     let type_annotation_spacing = type_annotation_spacing(context.config);"}, {"sha": "14c50563baa6b149a5b941dddb1e58470eda840c", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 507, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -24,34 +24,33 @@ extern crate syntax;\n extern crate term;\n extern crate unicode_segmentation;\n \n-use std::borrow::Cow;\n use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, stdout, Write};\n use std::iter::repeat;\n-use std::ops::{Add, Sub};\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n use errors::{DiagnosticBuilder, Handler};\n use errors::emitter::{ColorConfig, EmitterWriter};\n-use macros::MacroArg;\n use strings::string_buffer::StringBuffer;\n use syntax::ast;\n-use syntax::codemap::{CodeMap, FilePathMapping, Span};\n+use syntax::codemap::{CodeMap, FilePathMapping};\n use syntax::parse::{self, ParseSess};\n \n use checkstyle::{output_footer, output_header};\n use config::Config;\n use filemap::FileMap;\n use issues::{BadIssueSeeker, Issue};\n-use utils::{isatty, mk_sp, outer_attributes};\n+use utils::isatty;\n use visitor::FmtVisitor;\n \n pub use self::summary::Summary;\n \n #[macro_use]\n mod utils;\n+mod shape;\n+mod spanned;\n pub mod config;\n pub mod codemap;\n pub mod filemap;\n@@ -76,423 +75,6 @@ mod patterns;\n mod summary;\n mod vertical;\n \n-/// Spanned returns a span including attributes, if available.\n-pub trait Spanned {\n-    fn span(&self) -> Span;\n-}\n-\n-macro_rules! span_with_attrs_lo_hi {\n-    ($this:ident, $lo:expr, $hi:expr) => {\n-        {\n-            let attrs = outer_attributes(&$this.attrs);\n-            if attrs.is_empty() {\n-                mk_sp($lo, $hi)\n-            } else {\n-                mk_sp(attrs[0].span.lo(), $hi)\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! span_with_attrs {\n-    ($this:ident) => {\n-        span_with_attrs_lo_hi!($this, $this.span.lo(), $this.span.hi())\n-    }\n-}\n-\n-macro_rules! implement_spanned {\n-    ($this:ty) => {\n-        impl Spanned for $this {\n-            fn span(&self) -> Span {\n-                span_with_attrs!(self)\n-            }\n-        }\n-    }\n-}\n-\n-// Implement `Spanned` for structs with `attrs` field.\n-implement_spanned!(ast::Expr);\n-implement_spanned!(ast::Field);\n-implement_spanned!(ast::ForeignItem);\n-implement_spanned!(ast::Item);\n-implement_spanned!(ast::Local);\n-\n-impl Spanned for ast::Stmt {\n-    fn span(&self) -> Span {\n-        match self.node {\n-            ast::StmtKind::Local(ref local) => mk_sp(local.span().lo(), self.span.hi()),\n-            ast::StmtKind::Item(ref item) => mk_sp(item.span().lo(), self.span.hi()),\n-            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                mk_sp(expr.span().lo(), self.span.hi())\n-            }\n-            ast::StmtKind::Mac(ref mac) => {\n-                let (_, _, ref attrs) = **mac;\n-                if attrs.is_empty() {\n-                    self.span\n-                } else {\n-                    mk_sp(attrs[0].span.lo(), self.span.hi())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl Spanned for ast::Pat {\n-    fn span(&self) -> Span {\n-        self.span\n-    }\n-}\n-\n-impl Spanned for ast::Ty {\n-    fn span(&self) -> Span {\n-        self.span\n-    }\n-}\n-\n-impl Spanned for ast::Arm {\n-    fn span(&self) -> Span {\n-        span_with_attrs_lo_hi!(self, self.pats[0].span.lo(), self.body.span.hi())\n-    }\n-}\n-\n-impl Spanned for ast::Arg {\n-    fn span(&self) -> Span {\n-        if items::is_named_arg(self) {\n-            utils::mk_sp(self.pat.span.lo(), self.ty.span.hi())\n-        } else {\n-            self.ty.span\n-        }\n-    }\n-}\n-\n-impl Spanned for ast::StructField {\n-    fn span(&self) -> Span {\n-        span_with_attrs_lo_hi!(self, self.span.lo(), self.ty.span.hi())\n-    }\n-}\n-\n-impl Spanned for ast::WherePredicate {\n-    fn span(&self) -> Span {\n-        match *self {\n-            ast::WherePredicate::BoundPredicate(ref p) => p.span,\n-            ast::WherePredicate::RegionPredicate(ref p) => p.span,\n-            ast::WherePredicate::EqPredicate(ref p) => p.span,\n-        }\n-    }\n-}\n-\n-impl Spanned for ast::FunctionRetTy {\n-    fn span(&self) -> Span {\n-        match *self {\n-            ast::FunctionRetTy::Default(span) => span,\n-            ast::FunctionRetTy::Ty(ref ty) => ty.span,\n-        }\n-    }\n-}\n-\n-impl Spanned for ast::TyParam {\n-    fn span(&self) -> Span {\n-        // Note that ty.span is the span for ty.ident, not the whole item.\n-        let lo = if self.attrs.is_empty() {\n-            self.span.lo()\n-        } else {\n-            self.attrs[0].span.lo()\n-        };\n-        if let Some(ref def) = self.default {\n-            return mk_sp(lo, def.span.hi());\n-        }\n-        if self.bounds.is_empty() {\n-            return mk_sp(lo, self.span.hi());\n-        }\n-        let hi = self.bounds[self.bounds.len() - 1].span().hi();\n-        mk_sp(lo, hi)\n-    }\n-}\n-\n-impl Spanned for ast::TyParamBound {\n-    fn span(&self) -> Span {\n-        match *self {\n-            ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span,\n-            ast::TyParamBound::RegionTyParamBound(ref l) => l.span,\n-        }\n-    }\n-}\n-\n-impl Spanned for ast::LifetimeDef {\n-    fn span(&self) -> Span {\n-        let hi = if self.bounds.is_empty() {\n-            self.lifetime.span.hi()\n-        } else {\n-            self.bounds[self.bounds.len() - 1].span.hi()\n-        };\n-        mk_sp(self.lifetime.span.lo(), hi)\n-    }\n-}\n-\n-impl Spanned for MacroArg {\n-    fn span(&self) -> Span {\n-        match *self {\n-            MacroArg::Expr(ref expr) => expr.span(),\n-            MacroArg::Ty(ref ty) => ty.span(),\n-            MacroArg::Pat(ref pat) => pat.span(),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Indent {\n-    // Width of the block indent, in characters. Must be a multiple of\n-    // Config::tab_spaces.\n-    pub block_indent: usize,\n-    // Alignment in characters.\n-    pub alignment: usize,\n-}\n-\n-// INDENT_BUFFER.len() == 60\n-const INDENT_BUFFER: &str = \"                                                            \";\n-const INDENT_BUFFER_LEN: usize = 60;\n-\n-impl Indent {\n-    pub fn new(block_indent: usize, alignment: usize) -> Indent {\n-        Indent {\n-            block_indent: block_indent,\n-            alignment: alignment,\n-        }\n-    }\n-\n-    pub fn from_width(config: &Config, width: usize) -> Indent {\n-        if config.hard_tabs() {\n-            let tab_num = width / config.tab_spaces();\n-            let alignment = width % config.tab_spaces();\n-            Indent::new(config.tab_spaces() * tab_num, alignment)\n-        } else {\n-            Indent::new(width, 0)\n-        }\n-    }\n-\n-    pub fn empty() -> Indent {\n-        Indent::new(0, 0)\n-    }\n-\n-    pub fn block_only(&self) -> Indent {\n-        Indent {\n-            block_indent: self.block_indent,\n-            alignment: 0,\n-        }\n-    }\n-\n-    pub fn block_indent(mut self, config: &Config) -> Indent {\n-        self.block_indent += config.tab_spaces();\n-        self\n-    }\n-\n-    pub fn block_unindent(mut self, config: &Config) -> Indent {\n-        if self.block_indent < config.tab_spaces() {\n-            Indent::new(self.block_indent, 0)\n-        } else {\n-            self.block_indent -= config.tab_spaces();\n-            self\n-        }\n-    }\n-\n-    pub fn width(&self) -> usize {\n-        self.block_indent + self.alignment\n-    }\n-\n-    pub fn to_string(&self, config: &Config) -> Cow<'static, str> {\n-        let (num_tabs, num_spaces) = if config.hard_tabs() {\n-            (self.block_indent / config.tab_spaces(), self.alignment)\n-        } else {\n-            (0, self.width())\n-        };\n-        let num_chars = num_tabs + num_spaces;\n-        if num_tabs == 0 && num_chars <= INDENT_BUFFER_LEN {\n-            Cow::from(&INDENT_BUFFER[..num_chars])\n-        } else {\n-            let mut indent = String::with_capacity(num_chars);\n-            for _ in 0..num_tabs {\n-                indent.push('\\t')\n-            }\n-            for _ in 0..num_spaces {\n-                indent.push(' ')\n-            }\n-            Cow::from(indent)\n-        }\n-    }\n-}\n-\n-impl Add for Indent {\n-    type Output = Indent;\n-\n-    fn add(self, rhs: Indent) -> Indent {\n-        Indent {\n-            block_indent: self.block_indent + rhs.block_indent,\n-            alignment: self.alignment + rhs.alignment,\n-        }\n-    }\n-}\n-\n-impl Sub for Indent {\n-    type Output = Indent;\n-\n-    fn sub(self, rhs: Indent) -> Indent {\n-        Indent::new(\n-            self.block_indent - rhs.block_indent,\n-            self.alignment - rhs.alignment,\n-        )\n-    }\n-}\n-\n-impl Add<usize> for Indent {\n-    type Output = Indent;\n-\n-    fn add(self, rhs: usize) -> Indent {\n-        Indent::new(self.block_indent, self.alignment + rhs)\n-    }\n-}\n-\n-impl Sub<usize> for Indent {\n-    type Output = Indent;\n-\n-    fn sub(self, rhs: usize) -> Indent {\n-        Indent::new(self.block_indent, self.alignment - rhs)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Shape {\n-    pub width: usize,\n-    // The current indentation of code.\n-    pub indent: Indent,\n-    // Indentation + any already emitted text on the first line of the current\n-    // statement.\n-    pub offset: usize,\n-}\n-\n-impl Shape {\n-    /// `indent` is the indentation of the first line. The next lines\n-    /// should begin with at least `indent` spaces (except backwards\n-    /// indentation). The first line should not begin with indentation.\n-    /// `width` is the maximum number of characters on the last line\n-    /// (excluding `indent`). The width of other lines is not limited by\n-    /// `width`.\n-    /// Note that in reality, we sometimes use width for lines other than the\n-    /// last (i.e., we are conservative).\n-    // .......*-------*\n-    //        |       |\n-    //        |     *-*\n-    //        *-----|\n-    // |<------------>|  max width\n-    // |<---->|          indent\n-    //        |<--->|    width\n-    pub fn legacy(width: usize, indent: Indent) -> Shape {\n-        Shape {\n-            width: width,\n-            indent: indent,\n-            offset: indent.alignment,\n-        }\n-    }\n-\n-    pub fn indented(indent: Indent, config: &Config) -> Shape {\n-        Shape {\n-            width: config.max_width().checked_sub(indent.width()).unwrap_or(0),\n-            indent: indent,\n-            offset: indent.alignment,\n-        }\n-    }\n-\n-    pub fn with_max_width(&self, config: &Config) -> Shape {\n-        Shape {\n-            width: config\n-                .max_width()\n-                .checked_sub(self.indent.width())\n-                .unwrap_or(0),\n-            ..*self\n-        }\n-    }\n-\n-    pub fn offset(width: usize, indent: Indent, offset: usize) -> Shape {\n-        Shape {\n-            width: width,\n-            indent: indent,\n-            offset: offset,\n-        }\n-    }\n-\n-    pub fn visual_indent(&self, extra_width: usize) -> Shape {\n-        let alignment = self.offset + extra_width;\n-        Shape {\n-            width: self.width,\n-            indent: Indent::new(self.indent.block_indent, alignment),\n-            offset: alignment,\n-        }\n-    }\n-\n-    pub fn block_indent(&self, extra_width: usize) -> Shape {\n-        if self.indent.alignment == 0 {\n-            Shape {\n-                width: self.width,\n-                indent: Indent::new(self.indent.block_indent + extra_width, 0),\n-                offset: 0,\n-            }\n-        } else {\n-            Shape {\n-                width: self.width,\n-                indent: self.indent + extra_width,\n-                offset: self.indent.alignment + extra_width,\n-            }\n-        }\n-    }\n-\n-    pub fn block_left(&self, width: usize) -> Option<Shape> {\n-        self.block_indent(width).sub_width(width)\n-    }\n-\n-    pub fn add_offset(&self, extra_width: usize) -> Shape {\n-        Shape {\n-            offset: self.offset + extra_width,\n-            ..*self\n-        }\n-    }\n-\n-    pub fn block(&self) -> Shape {\n-        Shape {\n-            indent: self.indent.block_only(),\n-            ..*self\n-        }\n-    }\n-\n-    pub fn sub_width(&self, width: usize) -> Option<Shape> {\n-        Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n-            ..*self\n-        })\n-    }\n-\n-    pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n-        Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n-            indent: self.indent + width,\n-            offset: self.offset + width,\n-        })\n-    }\n-\n-    pub fn offset_left(&self, width: usize) -> Option<Shape> {\n-        self.add_offset(width).sub_width(width)\n-    }\n-\n-    pub fn used_width(&self) -> usize {\n-        self.indent.block_indent + self.offset\n-    }\n-\n-    pub fn rhs_overhead(&self, config: &Config) -> usize {\n-        config\n-            .max_width()\n-            .checked_sub(self.used_width() + self.width)\n-            .unwrap_or(0)\n-    }\n-}\n-\n pub enum ErrorKind {\n     // Line has exceeded character limit (found, maximum)\n     LineOverflow(usize, usize),\n@@ -1000,88 +582,3 @@ pub fn run(input: Input, config: &Config) -> Summary {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn indent_add_sub() {\n-        let indent = Indent::new(4, 8) + Indent::new(8, 12);\n-        assert_eq!(12, indent.block_indent);\n-        assert_eq!(20, indent.alignment);\n-\n-        let indent = indent - Indent::new(4, 4);\n-        assert_eq!(8, indent.block_indent);\n-        assert_eq!(16, indent.alignment);\n-    }\n-\n-    #[test]\n-    fn indent_add_sub_alignment() {\n-        let indent = Indent::new(4, 8) + 4;\n-        assert_eq!(4, indent.block_indent);\n-        assert_eq!(12, indent.alignment);\n-\n-        let indent = indent - 4;\n-        assert_eq!(4, indent.block_indent);\n-        assert_eq!(8, indent.alignment);\n-    }\n-\n-    #[test]\n-    fn indent_to_string_spaces() {\n-        let config = Config::default();\n-        let indent = Indent::new(4, 8);\n-\n-        // 12 spaces\n-        assert_eq!(\"            \", indent.to_string(&config));\n-    }\n-\n-    #[test]\n-    fn indent_to_string_hard_tabs() {\n-        let mut config = Config::default();\n-        config.set().hard_tabs(true);\n-        let indent = Indent::new(8, 4);\n-\n-        // 2 tabs + 4 spaces\n-        assert_eq!(\"\\t\\t    \", indent.to_string(&config));\n-    }\n-\n-    #[test]\n-    fn shape_visual_indent() {\n-        let config = Config::default();\n-        let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width(), indent);\n-        let shape = shape.visual_indent(20);\n-\n-        assert_eq!(config.max_width(), shape.width);\n-        assert_eq!(4, shape.indent.block_indent);\n-        assert_eq!(28, shape.indent.alignment);\n-        assert_eq!(28, shape.offset);\n-    }\n-\n-    #[test]\n-    fn shape_block_indent_without_alignment() {\n-        let config = Config::default();\n-        let indent = Indent::new(4, 0);\n-        let shape = Shape::legacy(config.max_width(), indent);\n-        let shape = shape.block_indent(20);\n-\n-        assert_eq!(config.max_width(), shape.width);\n-        assert_eq!(24, shape.indent.block_indent);\n-        assert_eq!(0, shape.indent.alignment);\n-        assert_eq!(0, shape.offset);\n-    }\n-\n-    #[test]\n-    fn shape_block_indent_with_alignment() {\n-        let config = Config::default();\n-        let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width(), indent);\n-        let shape = shape.block_indent(20);\n-\n-        assert_eq!(config.max_width(), shape.width);\n-        assert_eq!(4, shape.indent.block_indent);\n-        assert_eq!(28, shape.indent.alignment);\n-        assert_eq!(28, shape.offset);\n-    }\n-}"}, {"sha": "e499377e48a4073d7f71f5850dd17bde82ccd9d1", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -13,10 +13,10 @@ use std::iter::Peekable;\n \n use syntax::codemap::{BytePos, CodeMap};\n \n-use {Indent, Shape};\n use comment::{find_comment_end, rewrite_comment, FindUncommented};\n use config::{Config, IndentStyle};\n use rewrite::RewriteContext;\n+use shape::{Indent, Shape};\n use utils::{first_line_width, last_line_width, mk_sp};\n \n /// Formatting tactic for lists. This will be cast down to a\n@@ -713,7 +713,7 @@ where\n         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n-fn total_item_width(item: &ListItem) -> usize {\n+pub fn total_item_width(item: &ListItem) -> usize {\n     comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..]))\n         + comment_len(item.post_comment.as_ref().map(|x| &(*x)[..]))\n         + item.item.as_ref().map_or(0, |str| str.len())"}, {"sha": "5b52567087ec311ab68d3ecc9f7bd3f184100b35", "filename": "src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -28,11 +28,11 @@ use syntax::symbol;\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n \n-use {Indent, Shape};\n use codemap::SpanUtils;\n use comment::{contains_comment, FindUncommented};\n use expr::{rewrite_array, rewrite_call_inner};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::{Indent, Shape};\n use utils::mk_sp;\n \n const FORCED_BRACKET_MACROS: &'static [&'static str] = &[\"vec!\"];"}, {"sha": "9d20e6c6e55f6e35d7fb3b640fcfed784654e12d", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -10,10 +10,11 @@\n \n use std::borrow::Cow;\n \n-use {Indent, Shape};\n+use syntax::codemap::{BytePos, Pos, Span};\n+\n use comment::{rewrite_comment, CodeCharKind, CommentCodeSlices};\n use config::WriteMode;\n-use syntax::codemap::{BytePos, Pos, Span};\n+use shape::{Indent, Shape};\n use utils::mk_sp;\n use visitor::FmtVisitor;\n "}, {"sha": "c58a98627ff51b5fc0c6a162ec51c2984ac26745", "filename": "src/patterns.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -12,16 +12,17 @@ use syntax::ast::{self, BindingMode, FieldPat, Pat, PatKind, RangeEnd};\n use syntax::codemap::{self, BytePos, Span};\n use syntax::ptr;\n \n-use {Shape, Spanned};\n+use spanned::Spanned;\n use codemap::SpanUtils;\n use comment::FindUncommented;\n use expr::{can_be_overflowed_expr, rewrite_call_inner, rewrite_pair, rewrite_unary_prefix,\n            wrap_struct_field};\n use lists::{itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n             struct_lit_tactic, write_list, DefinitiveListTactic, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n use types::{rewrite_path, PathContext};\n-use utils::{format_mutability, mk_sp, wrap_str};\n+use utils::{format_mutability, mk_sp};\n \n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n@@ -50,8 +51,7 @@ impl Rewrite for Pat {\n                     None => \"\".to_owned(),\n                 };\n \n-                let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n-                wrap_str(result, context.config.max_width(), shape)\n+                Some(format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat))\n             }\n             PatKind::Wild => if 1 <= shape.width {\n                 Some(\"_\".to_owned())\n@@ -124,17 +124,13 @@ impl Rewrite for Pat {\n                 } else {\n                     format!(\"[{}]\", pats.join(\", \"))\n                 };\n-                wrap_str(result, context.config.max_width(), shape)\n+                Some(result)\n             }\n             PatKind::Struct(ref path, ref fields, elipses) => {\n                 rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n-            PatKind::Mac(..) => wrap_str(\n-                context.snippet(self.span),\n-                context.config.max_width(),\n-                shape,\n-            ),\n+            PatKind::Mac(..) => Some(context.snippet(self.span)),\n         }\n     }\n }\n@@ -224,11 +220,21 @@ impl Rewrite for FieldPat {\n         if self.is_shorthand {\n             pat\n         } else {\n-            wrap_str(\n-                format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n-                context.config.max_width(),\n-                shape,\n-            )\n+            let pat_str = try_opt!(pat);\n+            let id_str = self.ident.to_string();\n+            let one_line_width = id_str.len() + 2 + pat_str.len();\n+            if one_line_width <= shape.width {\n+                Some(format!(\"{}: {}\", id_str, pat_str))\n+            } else {\n+                let nested_shape = shape.block_indent(context.config.tab_spaces());\n+                let pat_str = try_opt!(self.pat.rewrite(context, nested_shape));\n+                Some(format!(\n+                    \"{}:\\n{}{}\",\n+                    id_str,\n+                    nested_shape.indent.to_string(context.config),\n+                    pat_str,\n+                ))\n+            }\n         }\n     }\n }"}, {"sha": "e2be8ef086cd9cdecee0825afa4e659b780bbba0", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -13,8 +13,8 @@\n use syntax::codemap::{CodeMap, Span};\n use syntax::parse::ParseSess;\n \n-use Shape;\n use config::{Config, IndentStyle};\n+use shape::Shape;\n \n pub trait Rewrite {\n     /// Rewrite self into shape."}, {"sha": "63910c29707341c89084ed64233ec050c83b1322", "filename": "src/shape.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -0,0 +1,344 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::{Add, Sub};\n+\n+use Config;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Indent {\n+    // Width of the block indent, in characters. Must be a multiple of\n+    // Config::tab_spaces.\n+    pub block_indent: usize,\n+    // Alignment in characters.\n+    pub alignment: usize,\n+}\n+\n+impl Indent {\n+    pub fn new(block_indent: usize, alignment: usize) -> Indent {\n+        Indent {\n+            block_indent: block_indent,\n+            alignment: alignment,\n+        }\n+    }\n+\n+    pub fn from_width(config: &Config, width: usize) -> Indent {\n+        if config.hard_tabs() {\n+            let tab_num = width / config.tab_spaces();\n+            let alignment = width % config.tab_spaces();\n+            Indent::new(config.tab_spaces() * tab_num, alignment)\n+        } else {\n+            Indent::new(width, 0)\n+        }\n+    }\n+\n+    pub fn empty() -> Indent {\n+        Indent::new(0, 0)\n+    }\n+\n+    pub fn block_only(&self) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent,\n+            alignment: 0,\n+        }\n+    }\n+\n+    pub fn block_indent(mut self, config: &Config) -> Indent {\n+        self.block_indent += config.tab_spaces();\n+        self\n+    }\n+\n+    pub fn block_unindent(mut self, config: &Config) -> Indent {\n+        if self.block_indent < config.tab_spaces() {\n+            Indent::new(self.block_indent, 0)\n+        } else {\n+            self.block_indent -= config.tab_spaces();\n+            self\n+        }\n+    }\n+\n+    pub fn width(&self) -> usize {\n+        self.block_indent + self.alignment\n+    }\n+\n+    pub fn to_string(&self, config: &Config) -> String {\n+        let (num_tabs, num_spaces) = if config.hard_tabs() {\n+            (self.block_indent / config.tab_spaces(), self.alignment)\n+        } else {\n+            (0, self.width())\n+        };\n+        let num_chars = num_tabs + num_spaces;\n+        let mut indent = String::with_capacity(num_chars);\n+        for _ in 0..num_tabs {\n+            indent.push('\\t')\n+        }\n+        for _ in 0..num_spaces {\n+            indent.push(' ')\n+        }\n+        indent\n+    }\n+}\n+\n+impl Add for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: Indent) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent + rhs.block_indent,\n+            alignment: self.alignment + rhs.alignment,\n+        }\n+    }\n+}\n+\n+impl Sub for Indent {\n+    type Output = Indent;\n+\n+    fn sub(self, rhs: Indent) -> Indent {\n+        Indent::new(\n+            self.block_indent - rhs.block_indent,\n+            self.alignment - rhs.alignment,\n+        )\n+    }\n+}\n+\n+impl Add<usize> for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: usize) -> Indent {\n+        Indent::new(self.block_indent, self.alignment + rhs)\n+    }\n+}\n+\n+impl Sub<usize> for Indent {\n+    type Output = Indent;\n+\n+    fn sub(self, rhs: usize) -> Indent {\n+        Indent::new(self.block_indent, self.alignment - rhs)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Shape {\n+    pub width: usize,\n+    // The current indentation of code.\n+    pub indent: Indent,\n+    // Indentation + any already emitted text on the first line of the current\n+    // statement.\n+    pub offset: usize,\n+}\n+\n+impl Shape {\n+    /// `indent` is the indentation of the first line. The next lines\n+    /// should begin with at least `indent` spaces (except backwards\n+    /// indentation). The first line should not begin with indentation.\n+    /// `width` is the maximum number of characters on the last line\n+    /// (excluding `indent`). The width of other lines is not limited by\n+    /// `width`.\n+    /// Note that in reality, we sometimes use width for lines other than the\n+    /// last (i.e., we are conservative).\n+    // .......*-------*\n+    //        |       |\n+    //        |     *-*\n+    //        *-----|\n+    // |<------------>|  max width\n+    // |<---->|          indent\n+    //        |<--->|    width\n+    pub fn legacy(width: usize, indent: Indent) -> Shape {\n+        Shape {\n+            width: width,\n+            indent: indent,\n+            offset: indent.alignment,\n+        }\n+    }\n+\n+    pub fn indented(indent: Indent, config: &Config) -> Shape {\n+        Shape {\n+            width: config.max_width().checked_sub(indent.width()).unwrap_or(0),\n+            indent: indent,\n+            offset: indent.alignment,\n+        }\n+    }\n+\n+    pub fn with_max_width(&self, config: &Config) -> Shape {\n+        Shape {\n+            width: config\n+                .max_width()\n+                .checked_sub(self.indent.width())\n+                .unwrap_or(0),\n+            ..*self\n+        }\n+    }\n+\n+    pub fn offset(width: usize, indent: Indent, offset: usize) -> Shape {\n+        Shape {\n+            width: width,\n+            indent: indent,\n+            offset: offset,\n+        }\n+    }\n+\n+    pub fn visual_indent(&self, extra_width: usize) -> Shape {\n+        let alignment = self.offset + extra_width;\n+        Shape {\n+            width: self.width,\n+            indent: Indent::new(self.indent.block_indent, alignment),\n+            offset: alignment,\n+        }\n+    }\n+\n+    pub fn block_indent(&self, extra_width: usize) -> Shape {\n+        if self.indent.alignment == 0 {\n+            Shape {\n+                width: self.width,\n+                indent: Indent::new(self.indent.block_indent + extra_width, 0),\n+                offset: 0,\n+            }\n+        } else {\n+            Shape {\n+                width: self.width,\n+                indent: self.indent + extra_width,\n+                offset: self.indent.alignment + extra_width,\n+            }\n+        }\n+    }\n+\n+    pub fn block_left(&self, width: usize) -> Option<Shape> {\n+        self.block_indent(width).sub_width(width)\n+    }\n+\n+    pub fn add_offset(&self, extra_width: usize) -> Shape {\n+        Shape {\n+            offset: self.offset + extra_width,\n+            ..*self\n+        }\n+    }\n+\n+    pub fn block(&self) -> Shape {\n+        Shape {\n+            indent: self.indent.block_only(),\n+            ..*self\n+        }\n+    }\n+\n+    pub fn sub_width(&self, width: usize) -> Option<Shape> {\n+        Some(Shape {\n+            width: try_opt!(self.width.checked_sub(width)),\n+            ..*self\n+        })\n+    }\n+\n+    pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n+        Some(Shape {\n+            width: try_opt!(self.width.checked_sub(width)),\n+            indent: self.indent + width,\n+            offset: self.offset + width,\n+        })\n+    }\n+\n+    pub fn offset_left(&self, width: usize) -> Option<Shape> {\n+        self.add_offset(width).sub_width(width)\n+    }\n+\n+    pub fn used_width(&self) -> usize {\n+        self.indent.block_indent + self.offset\n+    }\n+\n+    pub fn rhs_overhead(&self, config: &Config) -> usize {\n+        config\n+            .max_width()\n+            .checked_sub(self.used_width() + self.width)\n+            .unwrap_or(0)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn indent_add_sub() {\n+        let indent = Indent::new(4, 8) + Indent::new(8, 12);\n+        assert_eq!(12, indent.block_indent);\n+        assert_eq!(20, indent.alignment);\n+\n+        let indent = indent - Indent::new(4, 4);\n+        assert_eq!(8, indent.block_indent);\n+        assert_eq!(16, indent.alignment);\n+    }\n+\n+    #[test]\n+    fn indent_add_sub_alignment() {\n+        let indent = Indent::new(4, 8) + 4;\n+        assert_eq!(4, indent.block_indent);\n+        assert_eq!(12, indent.alignment);\n+\n+        let indent = indent - 4;\n+        assert_eq!(4, indent.block_indent);\n+        assert_eq!(8, indent.alignment);\n+    }\n+\n+    #[test]\n+    fn indent_to_string_spaces() {\n+        let config = Config::default();\n+        let indent = Indent::new(4, 8);\n+\n+        // 12 spaces\n+        assert_eq!(\"            \", indent.to_string(&config));\n+    }\n+\n+    #[test]\n+    fn indent_to_string_hard_tabs() {\n+        let mut config = Config::default();\n+        config.set().hard_tabs(true);\n+        let indent = Indent::new(8, 4);\n+\n+        // 2 tabs + 4 spaces\n+        assert_eq!(\"\\t\\t    \", indent.to_string(&config));\n+    }\n+\n+    #[test]\n+    fn shape_visual_indent() {\n+        let config = Config::default();\n+        let indent = Indent::new(4, 8);\n+        let shape = Shape::legacy(config.max_width(), indent);\n+        let shape = shape.visual_indent(20);\n+\n+        assert_eq!(config.max_width(), shape.width);\n+        assert_eq!(4, shape.indent.block_indent);\n+        assert_eq!(28, shape.indent.alignment);\n+        assert_eq!(28, shape.offset);\n+    }\n+\n+    #[test]\n+    fn shape_block_indent_without_alignment() {\n+        let config = Config::default();\n+        let indent = Indent::new(4, 0);\n+        let shape = Shape::legacy(config.max_width(), indent);\n+        let shape = shape.block_indent(20);\n+\n+        assert_eq!(config.max_width(), shape.width);\n+        assert_eq!(24, shape.indent.block_indent);\n+        assert_eq!(0, shape.indent.alignment);\n+        assert_eq!(0, shape.offset);\n+    }\n+\n+    #[test]\n+    fn shape_block_indent_with_alignment() {\n+        let config = Config::default();\n+        let indent = Indent::new(4, 8);\n+        let shape = Shape::legacy(config.max_width(), indent);\n+        let shape = shape.block_indent(20);\n+\n+        assert_eq!(config.max_width(), shape.width);\n+        assert_eq!(4, shape.indent.block_indent);\n+        assert_eq!(28, shape.indent.alignment);\n+        assert_eq!(28, shape.offset);\n+    }\n+}"}, {"sha": "6978f2812e6ba662ad85088ba2b0b8eb8bcca3f9", "filename": "src/spanned.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use macros::MacroArg;\n+use utils::{mk_sp, outer_attributes};\n+\n+/// Spanned returns a span including attributes, if available.\n+pub trait Spanned {\n+    fn span(&self) -> Span;\n+}\n+\n+macro_rules! span_with_attrs_lo_hi {\n+    ($this:ident, $lo:expr, $hi:expr) => {\n+        {\n+            let attrs = outer_attributes(&$this.attrs);\n+            if attrs.is_empty() {\n+                mk_sp($lo, $hi)\n+            } else {\n+                mk_sp(attrs[0].span.lo(), $hi)\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! span_with_attrs {\n+    ($this:ident) => {\n+        span_with_attrs_lo_hi!($this, $this.span.lo(), $this.span.hi())\n+    }\n+}\n+\n+macro_rules! implement_spanned {\n+    ($this:ty) => {\n+        impl Spanned for $this {\n+            fn span(&self) -> Span {\n+                span_with_attrs!(self)\n+            }\n+        }\n+    }\n+}\n+\n+// Implement `Spanned` for structs with `attrs` field.\n+implement_spanned!(ast::Expr);\n+implement_spanned!(ast::Field);\n+implement_spanned!(ast::ForeignItem);\n+implement_spanned!(ast::Item);\n+implement_spanned!(ast::Local);\n+\n+impl Spanned for ast::Stmt {\n+    fn span(&self) -> Span {\n+        match self.node {\n+            ast::StmtKind::Local(ref local) => mk_sp(local.span().lo(), self.span.hi()),\n+            ast::StmtKind::Item(ref item) => mk_sp(item.span().lo(), self.span.hi()),\n+            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n+                mk_sp(expr.span().lo(), self.span.hi())\n+            }\n+            ast::StmtKind::Mac(ref mac) => {\n+                let (_, _, ref attrs) = **mac;\n+                if attrs.is_empty() {\n+                    self.span\n+                } else {\n+                    mk_sp(attrs[0].span.lo(), self.span.hi())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::Pat {\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}\n+\n+impl Spanned for ast::Ty {\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}\n+\n+impl Spanned for ast::Arm {\n+    fn span(&self) -> Span {\n+        span_with_attrs_lo_hi!(self, self.pats[0].span.lo(), self.body.span.hi())\n+    }\n+}\n+\n+impl Spanned for ast::Arg {\n+    fn span(&self) -> Span {\n+        if ::items::is_named_arg(self) {\n+            mk_sp(self.pat.span.lo(), self.ty.span.hi())\n+        } else {\n+            self.ty.span\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::StructField {\n+    fn span(&self) -> Span {\n+        span_with_attrs_lo_hi!(self, self.span.lo(), self.ty.span.hi())\n+    }\n+}\n+\n+impl Spanned for ast::WherePredicate {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::WherePredicate::BoundPredicate(ref p) => p.span,\n+            ast::WherePredicate::RegionPredicate(ref p) => p.span,\n+            ast::WherePredicate::EqPredicate(ref p) => p.span,\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::FunctionRetTy {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::FunctionRetTy::Default(span) => span,\n+            ast::FunctionRetTy::Ty(ref ty) => ty.span,\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::TyParam {\n+    fn span(&self) -> Span {\n+        // Note that ty.span is the span for ty.ident, not the whole item.\n+        let lo = if self.attrs.is_empty() {\n+            self.span.lo()\n+        } else {\n+            self.attrs[0].span.lo()\n+        };\n+        if let Some(ref def) = self.default {\n+            return mk_sp(lo, def.span.hi());\n+        }\n+        if self.bounds.is_empty() {\n+            return mk_sp(lo, self.span.hi());\n+        }\n+        let hi = self.bounds[self.bounds.len() - 1].span().hi();\n+        mk_sp(lo, hi)\n+    }\n+}\n+\n+impl Spanned for ast::TyParamBound {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span,\n+            ast::TyParamBound::RegionTyParamBound(ref l) => l.span,\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::LifetimeDef {\n+    fn span(&self) -> Span {\n+        let hi = if self.bounds.is_empty() {\n+            self.lifetime.span.hi()\n+        } else {\n+            self.bounds[self.bounds.len() - 1].span.hi()\n+        };\n+        mk_sp(self.lifetime.span.lo(), hi)\n+    }\n+}\n+\n+impl Spanned for MacroArg {\n+    fn span(&self) -> Span {\n+        match *self {\n+            MacroArg::Expr(ref expr) => expr.span(),\n+            MacroArg::Ty(ref ty) => ty.span(),\n+            MacroArg::Pat(ref pat) => pat.span(),\n+        }\n+    }\n+}"}, {"sha": "8090926522dbd9022b72e467aac11bb93a6bab04", "filename": "src/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -13,8 +13,8 @@\n use regex::Regex;\n use unicode_segmentation::UnicodeSegmentation;\n \n-use Shape;\n use config::Config;\n+use shape::Shape;\n use utils::wrap_str;\n \n const MIN_STRING: usize = 10;\n@@ -128,6 +128,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n #[cfg(test)]\n mod test {\n     use super::{rewrite_string, StringFormat};\n+    use shape::{Indent, Shape};\n \n     #[test]\n     fn issue343() {\n@@ -137,7 +138,7 @@ mod test {\n             closer: \"\\\"\",\n             line_start: \" \",\n             line_end: \"\\\\\",\n-            shape: ::Shape::legacy(2, ::Indent::empty()),\n+            shape: Shape::legacy(2, Indent::empty()),\n             trim_end: false,\n             config: &config,\n         };"}, {"sha": "311192889d3279401aa53599997e549c84c356db", "filename": "src/types.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -17,15 +17,16 @@ use syntax::codemap::{self, BytePos, Span};\n use syntax::print::pprust;\n use syntax::symbol::keywords;\n \n-use {Shape, Spanned};\n+use spanned::Spanned;\n use codemap::SpanUtils;\n use config::{IndentStyle, Style, TypeDensity};\n use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens};\n use items::{format_generics_item_list, generics_shape_from_config};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator,\n             SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n-use utils::{colon_spaces, extra_offset, format_mutability, last_line_width, mk_sp, wrap_str};\n+use shape::Shape;\n+use utils::{colon_spaces, extra_offset, format_mutability, last_line_width, mk_sp};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum PathContext {\n@@ -503,7 +504,7 @@ impl Rewrite for ast::WherePredicate {\n             }\n         };\n \n-        wrap_str(result, context.config.max_width(), shape)\n+        Some(result)\n     }\n }\n \n@@ -541,7 +542,7 @@ where\n             colon,\n             join_bounds(context, try_opt!(shape.sub_width(overhead)), &appendix)\n         );\n-        wrap_str(result, context.config.max_width(), shape)\n+        Some(result)\n     }\n }\n \n@@ -564,12 +565,8 @@ impl Rewrite for ast::TyParamBound {\n }\n \n impl Rewrite for ast::Lifetime {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(\n-            pprust::lifetime_to_string(self),\n-            context.config.max_width(),\n-            shape,\n-        )\n+    fn rewrite(&self, _: &RewriteContext, _: Shape) -> Option<String> {\n+        Some(pprust::lifetime_to_string(self))\n     }\n }\n \n@@ -611,7 +608,7 @@ impl Rewrite for ast::TyParam {\n             result.push_str(&rewrite);\n         }\n \n-        wrap_str(result, context.config.max_width(), shape)\n+        Some(result)\n     }\n }\n "}, {"sha": "3c97044f5c4b2fc34d5e73d738b6d86dc67cb1cc", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -15,8 +15,8 @@ use syntax::ast::{self, Attribute, MetaItem, MetaItemKind, NestedMetaItem, Neste\n                   Path, Visibility};\n use syntax::codemap::{BytePos, Span, NO_EXPANSION};\n \n-use Shape;\n use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n \n // When we get scoped annotations, we should have rustfmt::skip.\n const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";"}, {"sha": "4f19cd17921a0fb7a111413d0841088a5e59c81d", "filename": "src/vertical.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -15,14 +15,15 @@ use std::cmp;\n use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n \n-use {Indent, Shape, Spanned};\n+use spanned::Spanned;\n use codemap::SpanUtils;\n use comment::{combine_strs_with_missing_comments, contains_comment};\n use expr::rewrite_field;\n use items::{rewrite_struct_field, rewrite_struct_field_prefix};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator,\n             SeparatorPlace};\n use rewrite::{Rewrite, RewriteContext};\n+use shape::{Indent, Shape};\n use utils::{contains_skip, is_attributes_extendable, mk_sp};\n \n pub trait AlignedItem {"}, {"sha": "f6f46ca61886495250782bd90f2288d0c160241c", "filename": "src/visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -16,7 +16,7 @@ use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n-use {Indent, Shape, Spanned};\n+use spanned::Spanned;\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{contains_comment, recover_missing_comment_in_span, CodeCharKind, CommentCodeSlices,\n               FindUncommented};\n@@ -30,6 +30,7 @@ use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, Sepa\n use macros::{rewrite_macro, MacroPosition};\n use regex::Regex;\n use rewrite::{Rewrite, RewriteContext};\n+use shape::{Indent, Shape};\n use utils::{self, contains_skip, inner_attributes, mk_sp, ptr_vec_to_ref_vec};\n \n fn is_use_item(item: &ast::Item) -> bool {"}, {"sha": "ad813f6b98ae5ae3baf661f6a8b2779a7a92785c", "filename": "tests/source/configs-fn_call_style-block-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -4,5 +4,5 @@\n // rustfmt should not add trailing comma when rewriting macro. See #1528.\n fn a() {\n     panic!(\"this is a long string that goes past the maximum line length causing rustfmt to insert a comma here:\");\n-    foo(oooptoptoptoptptooptoptoptoptptooptoptoptoptptoptoptoptoptpt());\n+    foo(a, oooptoptoptoptptooptoptoptoptptooptoptoptoptptoptoptoptoptpt());\n }"}, {"sha": "f39f6acdb79c67f7c3c398ac349b4370ac724439", "filename": "tests/system.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[macro_use]\n+extern crate log;\n extern crate regex;\n extern crate rustfmt_nightly as rustfmt;\n extern crate term;\n@@ -201,7 +203,7 @@ where\n     let mut reports = vec![];\n \n     for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n-        println!(\"Testing '{}'...\", file_name);\n+        debug!(\"Testing '{}'...\", file_name);\n \n         match idempotent_check(file_name) {\n             Ok(ref report) if report.has_warnings() => {"}, {"sha": "4405f89f2afe64a74eab41129a7926aef887e4ba", "filename": "tests/target/configs-fn_call_style-block-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -7,6 +7,7 @@ fn a() {\n         \"this is a long string that goes past the maximum line length causing rustfmt to insert a comma here:\"\n     );\n     foo(\n+        a,\n         oooptoptoptoptptooptoptoptoptptooptoptoptoptptoptoptoptoptpt(),\n     );\n }"}, {"sha": "d2a39b241e1f6d816f3f030cf3879bf7a181bcdc", "filename": "tests/target/enum.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -170,10 +170,6 @@ enum Loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n \n // #1046\n pub enum Entry<'a, K: 'a, V: 'a> {\n-    Vacant(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>,\n-    ),\n-    Occupied(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>,\n-    ),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n }"}, {"sha": "329890e8b12f6350912a64bdfc45b7c1627b423e", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -307,9 +307,7 @@ fn combine_block() {\n     };\n \n     match x {\n-        y => func(\n-            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n-        ),\n+        y => func(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx),\n         _ => func(\n             x,\n             yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,"}, {"sha": "e262d69b43e6c4ad5cda05abcfe92adc09cb3c1c", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3cf98282f6546d713fe5c96f2e51e7f9503d5/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=c6b3cf98282f6546d713fe5c96f2e51e7f9503d5", "patch": "@@ -25,9 +25,8 @@ formatting\"#;\n \n     filename.replace(\" \", \"\\\\\");\n \n-    let xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = funktion(\n-        \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\",\n-    );\n+    let xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx =\n+        funktion(\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\");\n \n     let unicode = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n     let unicode2 = \"L\u00f6we \u8001\u864e L\u00e9opard\";"}]}