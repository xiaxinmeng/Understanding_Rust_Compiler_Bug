{"sha": "6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZTRmMzBjYWU5MzQ3OWMxOWRmZTMxM2FiMTNiOGZmZDNmN2EyN2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-05T13:53:54Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2021-03-09T17:27:23Z"}, "message": "Remove `item_scope` field from `Body`", "tree": {"sha": "cd0be846aacabcd3a69b88d7d05452c9a7cce2be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd0be846aacabcd3a69b88d7d05452c9a7cce2be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "html_url": "https://github.com/rust-lang/rust/commit/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1da0a27626559eb74d2398db314df2edca18de70", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da0a27626559eb74d2398db314df2edca18de70", "html_url": "https://github.com/rust-lang/rust/commit/1da0a27626559eb74d2398db314df2edca18de70"}], "stats": {"total": 181, "additions": 6, "deletions": 175}, "files": [{"sha": "19c4eb521dceb8a4fb029c4918b64a00863839be", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "patch": "@@ -28,7 +28,6 @@ use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n-    item_scope::ItemScope,\n     nameres::DefMap,\n     path::{ModPath, Path},\n     src::HasSource,\n@@ -228,7 +227,6 @@ pub struct Body {\n     pub body_expr: ExprId,\n     /// Block expressions in this body that may contain inner items.\n     pub block_scopes: Vec<BlockId>,\n-    pub item_scope: ItemScope,\n     _c: Count<Self>,\n }\n \n@@ -297,7 +295,7 @@ impl Body {\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (body, source_map) = Body::new(db, def, expander, params, body);\n+        let (body, source_map) = Body::new(db, expander, params, body);\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n@@ -307,12 +305,11 @@ impl Body {\n \n     fn new(\n         db: &dyn DefDatabase,\n-        def: DefWithBodyId,\n         expander: Expander,\n         params: Option<ast::ParamList>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, def, expander, params, body)\n+        lower::lower(db, expander, params, body)\n     }\n }\n "}, {"sha": "4d79ab72cd8b6998fbeeecf9c3cfda9e0e1ef6df", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 139, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "patch": "@@ -1,13 +1,13 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use std::{any::type_name, mem, sync::Arc};\n+use std::{mem, sync::Arc};\n \n use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    ExpandError, HirFileId, MacroDefId, MacroDefKind,\n+    ExpandError, HirFileId,\n };\n use la_arena::Arena;\n use profile::Count;\n@@ -32,11 +32,10 @@ use crate::{\n         Statement,\n     },\n     item_scope::BuiltinShadowMode,\n-    item_tree::{ItemTree, ItemTreeId, ItemTreeNode},\n+    item_tree::ItemTree,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockLoc, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern,\n-    ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, BlockLoc, ModuleDefId,\n };\n \n use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n@@ -60,15 +59,13 @@ impl LowerCtx {\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n-    def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n     let item_tree = db.item_tree(expander.current_file_id);\n     ExprCollector {\n         db,\n-        def,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -77,7 +74,6 @@ pub(super) fn lower(\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n             block_scopes: Vec::new(),\n-            item_scope: Default::default(),\n             _c: Count::new(),\n         },\n         item_trees: {\n@@ -92,7 +88,6 @@ pub(super) fn lower(\n \n struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n-    def: DefWithBodyId,\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n@@ -606,32 +601,6 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn find_inner_item<N: ItemTreeNode>(&self, ast: &N::Source) -> Option<ItemTreeId<N>> {\n-        let id = self.expander.ast_id(ast);\n-        let tree = &self.item_trees[&id.file_id];\n-\n-        // FIXME: This probably breaks with `use` items, since they produce multiple item tree nodes\n-\n-        // Root file (non-macro).\n-        let item_tree_id = tree\n-            .all_inner_items()\n-            .chain(tree.top_level_items().iter().copied())\n-            .filter_map(|mod_item| mod_item.downcast::<N>())\n-            .find(|tree_id| tree[*tree_id].ast_id().upcast() == id.value.upcast())\n-            .or_else(|| {\n-                log::debug!(\n-                    \"couldn't find inner {} item for {:?} (AST: `{}` - {:?})\",\n-                    type_name::<N>(),\n-                    id,\n-                    ast.syntax(),\n-                    ast.syntax(),\n-                );\n-                None\n-            })?;\n-\n-        Some(ItemTreeId::new(id.file_id, item_tree_id))\n-    }\n-\n     fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n@@ -663,7 +632,6 @@ impl ExprCollector<'_> {\n                             match expansion {\n                                 Some(expansion) => {\n                                     let statements: ast::MacroStmts = expansion;\n-                                    this.collect_stmts_items(statements.statements());\n \n                                     statements.statements().for_each(|stmt| {\n                                         if let Some(mut r) = this.collect_stmt(stmt) {\n@@ -710,7 +678,6 @@ impl ExprCollector<'_> {\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n-        self.collect_stmts_items(block.statements());\n         let statements =\n             block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n         let tail = block.tail_expr().map(|e| self.collect_expr(e));\n@@ -725,108 +692,6 @@ impl ExprCollector<'_> {\n         expr_id\n     }\n \n-    fn collect_stmts_items(&mut self, stmts: ast::AstChildren<ast::Stmt>) {\n-        let container = ContainerId::DefWithBodyId(self.def);\n-\n-        let items = stmts\n-            .filter_map(|stmt| match stmt {\n-                ast::Stmt::Item(it) => Some(it),\n-                ast::Stmt::LetStmt(_) | ast::Stmt::ExprStmt(_) => None,\n-            })\n-            .filter_map(|item| {\n-                let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n-                    ast::Item::Fn(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (\n-                            FunctionLoc { container: container.into(), id }.intern(self.db).into(),\n-                            def.name(),\n-                        )\n-                    }\n-                    ast::Item::TypeAlias(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (\n-                            TypeAliasLoc { container: container.into(), id }.intern(self.db).into(),\n-                            def.name(),\n-                        )\n-                    }\n-                    ast::Item::Const(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (\n-                            ConstLoc { container: container.into(), id }.intern(self.db).into(),\n-                            def.name(),\n-                        )\n-                    }\n-                    ast::Item::Static(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (StaticLoc { container, id }.intern(self.db).into(), def.name())\n-                    }\n-                    ast::Item::Struct(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (StructLoc { container, id }.intern(self.db).into(), def.name())\n-                    }\n-                    ast::Item::Enum(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (EnumLoc { container, id }.intern(self.db).into(), def.name())\n-                    }\n-                    ast::Item::Union(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (UnionLoc { container, id }.intern(self.db).into(), def.name())\n-                    }\n-                    ast::Item::Trait(def) => {\n-                        let id = self.find_inner_item(&def)?;\n-                        (TraitLoc { container, id }.intern(self.db).into(), def.name())\n-                    }\n-                    ast::Item::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n-                    ast::Item::Impl(_)\n-                    | ast::Item::Use(_)\n-                    | ast::Item::ExternCrate(_)\n-                    | ast::Item::Module(_)\n-                    | ast::Item::MacroCall(_) => return None,\n-                    ast::Item::MacroRules(def) => {\n-                        return Some(Either::Right(ast::Macro::from(def)));\n-                    }\n-                    ast::Item::MacroDef(def) => {\n-                        return Some(Either::Right(ast::Macro::from(def)));\n-                    }\n-                };\n-\n-                Some(Either::Left((def, name)))\n-            })\n-            .collect::<Vec<_>>();\n-\n-        for either in items {\n-            match either {\n-                Either::Left((def, name)) => {\n-                    self.body.item_scope.define_def(def);\n-                    if let Some(name) = name {\n-                        let vis = crate::visibility::Visibility::Public; // FIXME determine correctly\n-                        let has_constructor = match def {\n-                            ModuleDefId::AdtId(AdtId::StructId(s)) => {\n-                                self.db.struct_data(s).variant_data.kind() != StructKind::Record\n-                            }\n-                            _ => true,\n-                        };\n-                        self.body.item_scope.push_res(\n-                            name.as_name(),\n-                            crate::per_ns::PerNs::from_def(def, vis, has_constructor),\n-                        );\n-                    }\n-                }\n-                Either::Right(e) => {\n-                    let mac = MacroDefId {\n-                        krate: self.expander.def_map.krate(),\n-                        ast_id: Some(self.expander.ast_id(&e)),\n-                        kind: MacroDefKind::Declarative,\n-                        local_inner: false,\n-                    };\n-                    if let Some(name) = e.name() {\n-                        self.body.item_scope.define_legacy_macro(name.as_name(), mac);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n         if let Some(block) = expr {\n             self.collect_block(block)"}, {"sha": "aafd73b606d18046f475914546220056212132b9", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6be4f30cae93479c19dfe313ab13b8ffd3f7a27f/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=6be4f30cae93479c19dfe313ab13b8ffd3f7a27f", "patch": "@@ -168,37 +168,6 @@ impl ItemScope {\n         self.unnamed_trait_imports.insert(tr, vis);\n     }\n \n-    pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n-        let mut changed = false;\n-\n-        if let Some(types) = def.types {\n-            self.types.entry(name.clone()).or_insert_with(|| {\n-                changed = true;\n-                types\n-            });\n-        }\n-        if let Some(values) = def.values {\n-            self.values.entry(name.clone()).or_insert_with(|| {\n-                changed = true;\n-                values\n-            });\n-        }\n-        if let Some(macros) = def.macros {\n-            self.macros.entry(name.clone()).or_insert_with(|| {\n-                changed = true;\n-                macros\n-            });\n-        }\n-\n-        if def.is_none() {\n-            if self.unresolved.insert(name) {\n-                changed = true;\n-            }\n-        }\n-\n-        changed\n-    }\n-\n     pub(crate) fn push_res_with_import(\n         &mut self,\n         glob_imports: &mut PerNsGlobImports,"}]}