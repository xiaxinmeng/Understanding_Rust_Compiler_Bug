{"sha": "f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMmM5NmNjODg4ZWFjNGMxYzVkNDRlYTQ3NjVlNWMyYTY1ZjY0ZjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-07T14:13:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-09T08:29:49Z"}, "message": "rustdoc: add table-of-contents recording & rendering, use it with plain\nmarkdown files.\n\nThis means that\n\n    # Foo\n    ## Bar\n    # Baz\n    ### Qux\n    ## Quz\n\nGets a TOC like\n\n    1 Foo\n       1.1 Bar\n    2 Baz\n       2.0.1 Qux\n       2.1 Quz\n\nThis functionality is only used when rendering a single markdown file,\nnever on an individual module, although it could very feasibly be\nextended to allow modules to opt-in to a table of contents (std::fmt\ncomes to mind).", "tree": {"sha": "697fce4442d4fa82d11fb6476610a00f518a617d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/697fce4442d4fa82d11fb6476610a00f518a617d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "html_url": "https://github.com/rust-lang/rust/commit/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69b8ef806b3742ba7d41a77cd216713c84f36254", "url": "https://api.github.com/repos/rust-lang/rust/commits/69b8ef806b3742ba7d41a77cd216713c84f36254", "html_url": "https://github.com/rust-lang/rust/commit/69b8ef806b3742ba7d41a77cd216713c84f36254"}], "stats": {"total": 324, "additions": 312, "deletions": 12}, "files": [{"sha": "8f7829dda9d1d693b6f645fbea6d1a8915eaa42d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "patch": "@@ -36,12 +36,16 @@ use std::str;\n use std::vec;\n use collections::HashMap;\n \n+use html::toc::TocBuilder;\n use html::highlight;\n \n /// A unit struct which has the `fmt::Show` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n pub struct Markdown<'a>(&'a str);\n+/// A unit struct like `Markdown`, that renders the markdown with a\n+/// table of contents.\n+pub struct MarkdownWithToc<'a>(&'a str);\n \n static OUTPUT_UNIT: libc::size_t = 64;\n static MKDEXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 0;\n@@ -75,6 +79,7 @@ struct html_renderopt {\n struct my_opaque {\n     opt: html_renderopt,\n     dfltblk: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+    toc_builder: Option<TocBuilder>,\n }\n \n struct buf {\n@@ -121,7 +126,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n \n local_data_key!(used_header_map: HashMap<~str, uint>)\n \n-pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n+pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n@@ -162,7 +167,7 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n     }\n \n     extern fn header(ob: *buf, text: *buf, level: libc::c_int,\n-                     _opaque: *libc::c_void) {\n+                     opaque: *libc::c_void) {\n         // sundown does this, we may as well too\n         \"\\n\".with_c_str(|p| unsafe { bufputs(ob, p) });\n \n@@ -183,6 +188,8 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n             }\n         }).to_owned_vec().connect(\"-\");\n \n+        let opaque = unsafe {&mut *(opaque as *mut my_opaque)};\n+\n         // Make sure our hyphenated ID is unique for this page\n         let id = local_data::get_mut(used_header_map, |map| {\n             let map = map.unwrap();\n@@ -194,9 +201,18 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n             id.clone()\n         });\n \n+        let sec = match opaque.toc_builder {\n+            Some(ref mut builder) => {\n+                builder.push(level as u32, s.clone(), id.clone())\n+            }\n+            None => {\"\"}\n+        };\n+\n         // Render the HTML\n-        let text = format!(r#\"<h{lvl} id=\"{id}\">{}</h{lvl}>\"#,\n-                           s, lvl = level, id = id);\n+        let text = format!(r#\"<h{lvl} id=\"{id}\">{sec_len,plural,=0{}other{{sec} }}{}</h{lvl}>\"#,\n+                           s, lvl = level, id = id,\n+                           sec_len = sec.len(), sec = sec);\n+\n         text.with_c_str(|p| unsafe { bufputs(ob, p) });\n     }\n \n@@ -218,23 +234,30 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n         let mut callbacks: sd_callbacks = mem::init();\n \n         sdhtml_renderer(&callbacks, &options, 0);\n-        let opaque = my_opaque {\n+        let mut opaque = my_opaque {\n             opt: options,\n             dfltblk: callbacks.blockcode.unwrap(),\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n         };\n         callbacks.blockcode = Some(block);\n         callbacks.header = Some(header);\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n-                                       &opaque as *my_opaque as *libc::c_void);\n+                                       &mut opaque as *mut my_opaque as *libc::c_void);\n \n \n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n-        let ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n-            w.write(buf)\n-        });\n+        let mut ret = match opaque.toc_builder {\n+            Some(b) => write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", b.into_toc()),\n+            None => Ok(())\n+        };\n \n+        if ret.is_ok() {\n+            ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n+                w.write(buf)\n+            });\n+        }\n         bufrelease(ob);\n         ret\n     }\n@@ -319,6 +342,13 @@ impl<'a> fmt::Show for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n-        render(fmt.buf, md.as_slice())\n+        render(fmt.buf, md.as_slice(), false)\n+    }\n+}\n+\n+impl<'a> fmt::Show for MarkdownWithToc<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownWithToc(md) = *self;\n+        render(fmt.buf, md.as_slice(), true)\n     }\n }"}, {"sha": "61031c222e74a6f0219ceb54fc037ad3fd76e209", "filename": "src/librustdoc/html/toc.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Table-of-contents creation.\n+\n+use std::fmt;\n+use std::vec_ng::Vec;\n+\n+/// A (recursive) table of contents\n+#[deriving(Eq)]\n+pub struct Toc {\n+    /// The levels are strictly decreasing, i.e.\n+    ///\n+    /// entries[0].level >= entries[1].level >= ...\n+    ///\n+    /// Normally they are equal, but can differ in cases like A and B,\n+    /// both of which end up in the same `Toc` as they have the same\n+    /// parent (Main).\n+    ///\n+    /// # Main\n+    /// ### A\n+    /// ## B\n+    priv entries: Vec<TocEntry>\n+}\n+\n+impl Toc {\n+    fn count_entries_with_level(&self, level: u32) -> uint {\n+        self.entries.iter().count(|e| e.level == level)\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub struct TocEntry {\n+    priv level: u32,\n+    priv sec_number: ~str,\n+    priv name: ~str,\n+    priv id: ~str,\n+    priv children: Toc,\n+}\n+\n+/// Progressive construction of a table of contents.\n+#[deriving(Eq)]\n+pub struct TocBuilder {\n+    priv top_level: Toc,\n+    /// The current heirachy of parent headings, the levels are\n+    /// strictly increasing (i.e. chain[0].level < chain[1].level <\n+    /// ...) with each entry being the most recent occurance of a\n+    /// heading with that level (it doesn't include the most recent\n+    /// occurences of every level, just, if *is* in `chain` then is is\n+    /// the most recent one).\n+    ///\n+    /// We also have `chain[0].level <= top_level.entries[last]`.\n+    priv chain: Vec<TocEntry>\n+}\n+\n+impl TocBuilder {\n+    pub fn new() -> TocBuilder {\n+        TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n+    }\n+\n+\n+    /// Convert into a true `Toc` struct.\n+    pub fn into_toc(mut self) -> Toc {\n+        // we know all levels are >= 1.\n+        self.fold_until(0);\n+        self.top_level\n+    }\n+\n+    /// Collapse the chain until the first heading more important than\n+    /// `level` (i.e. lower level)\n+    ///\n+    /// Example:\n+    ///\n+    /// ## A\n+    /// # B\n+    /// # C\n+    /// ## D\n+    /// ## E\n+    /// ### F\n+    /// #### G\n+    /// ### H\n+    ///\n+    /// If we are considering H (i.e. level 3), then A and B are in\n+    /// self.top_level, D is in C.children, and C, E, F, G are in\n+    /// self.chain.\n+    ///\n+    /// When we attempt to push H, we realise that first G is not the\n+    /// parent (level is too high) so it is popped from chain and put\n+    /// into F.children, then F isn't the parent (level is equal, aka\n+    /// sibling), so it's also popped and put into E.children.\n+    ///\n+    /// This leaves us looking at E, which does have a smaller level,\n+    /// and, by construction, it's the most recent thing with smaller\n+    /// level, i.e. it's the immediate parent of H.\n+    fn fold_until(&mut self, level: u32) {\n+        let mut this = None;\n+        loop {\n+            match self.chain.pop() {\n+                Some(mut next) => {\n+                    this.map(|e| next.children.entries.push(e));\n+                    if next.level < level {\n+                        // this is the parent we want, so return it to\n+                        // its rightful place.\n+                        self.chain.push(next);\n+                        return\n+                    } else {\n+                        this = Some(next);\n+                    }\n+                }\n+                None => {\n+                    this.map(|e| self.top_level.entries.push(e));\n+                    return\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Push a level `level` heading into the appropriate place in the\n+    /// heirarchy, returning a string containing the section number in\n+    /// `<num>.<num>.<num>` format.\n+    pub fn push<'a>(&'a mut self, level: u32, name: ~str, id: ~str) -> &'a str {\n+        assert!(level >= 1);\n+\n+        // collapse all previous sections into their parents until we\n+        // get to relevant heading (i.e. the first one with a smaller\n+        // level than us)\n+        self.fold_until(level);\n+\n+        let mut sec_number;\n+        {\n+            let (toc_level, toc) = match self.chain.last() {\n+                None => {\n+                    sec_number = ~\"\";\n+                    (0, &self.top_level)\n+                }\n+                Some(entry) => {\n+                    sec_number = entry.sec_number.clone();\n+                    sec_number.push_str(\".\");\n+                    (entry.level, &entry.children)\n+                }\n+            };\n+            // fill in any missing zeros, e.g. for\n+            // # Foo (1)\n+            // ### Bar (1.0.1)\n+            for _ in range(toc_level, level - 1) {\n+                sec_number.push_str(\"0.\");\n+            }\n+            let number = toc.count_entries_with_level(level);\n+            sec_number.push_str(format!(\"{}\", number + 1))\n+        }\n+\n+        self.chain.push(TocEntry {\n+                level: level,\n+                name: name,\n+                sec_number: sec_number,\n+                id: id,\n+                children: Toc { entries: Vec::new() }\n+            });\n+\n+        // get the thing we just pushed, so we can borrow the string\n+        // out of it with the right lifetime\n+        let just_inserted = self.chain.mut_last().unwrap();\n+        just_inserted.sec_number.as_slice()\n+    }\n+}\n+\n+impl fmt::Show for Toc {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt.buf, \"<ul>\"));\n+        for entry in self.entries.iter() {\n+            // recursively format this table of contents (the\n+            // `{children}` is the key).\n+            try!(write!(fmt.buf,\n+                        \"\\n<li><a href=\\\"\\\\#{id}\\\">{num} {name}</a>{children}</li>\",\n+                        id = entry.id,\n+                        num = entry.sec_number, name = entry.name,\n+                        children = entry.children))\n+        }\n+        write!(fmt.buf, \"</ul>\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{TocBuilder, Toc, TocEntry};\n+\n+    #[test]\n+    fn builder_smoke() {\n+        let mut builder = TocBuilder::new();\n+\n+        // this is purposely not using a fancy macro like below so\n+        // that we're sure that this is doing the correct thing, and\n+        // there's been no macro mistake.\n+        macro_rules! push {\n+            ($level: expr, $name: expr) => {\n+                assert_eq!(builder.push($level, $name.to_owned(), ~\"\"), $name);\n+            }\n+        }\n+        push!(2, \"0.1\");\n+        push!(1, \"1\");\n+        {\n+            push!(2, \"1.1\");\n+            {\n+                push!(3, \"1.1.1\");\n+                push!(3, \"1.1.2\");\n+            }\n+            push!(2, \"1.2\");\n+            {\n+                push!(3, \"1.2.1\");\n+                push!(3, \"1.2.2\");\n+            }\n+        }\n+        push!(1, \"2\");\n+        push!(1, \"3\");\n+        {\n+            push!(4, \"3.0.0.1\");\n+            {\n+                push!(6, \"3.0.0.1.0.1\");\n+            }\n+            push!(4, \"3.0.0.2\");\n+            push!(2, \"3.1\");\n+            {\n+                push!(4, \"3.1.0.1\");\n+            }\n+        }\n+\n+        macro_rules! toc {\n+            ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n+                Toc {\n+                    entries: vec!(\n+                        $(\n+                            TocEntry {\n+                                level: $level,\n+                                name: $name.to_owned(),\n+                                sec_number: $name.to_owned(),\n+                                id: ~\"\",\n+                                children: toc!($($sub),*)\n+                            }\n+                            ),*\n+                        )\n+                }\n+            }\n+        }\n+        let expected = toc!(\n+            (2, \"0.1\", ),\n+\n+            (1, \"1\",\n+             ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n+             ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n+             ),\n+\n+            (1, \"2\", ),\n+\n+            (1, \"3\",\n+             ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n+             ((4, \"3.0.0.2\", ))\n+             ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n+             )\n+            );\n+        assert_eq!(expected, builder.into_toc());\n+    }\n+}"}, {"sha": "2d08dca97b986af22d987226a7f18d316474dfe0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "patch": "@@ -44,6 +44,7 @@ pub mod html {\n     pub mod layout;\n     pub mod markdown;\n     pub mod render;\n+    pub mod toc;\n }\n pub mod markdown;\n pub mod passes;"}, {"sha": "67a08706e982c83a8403662cb4f26662ecfe4421", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=f22c96cc888eac4c1c5d44ea4765e5c2a65f64f3", "patch": "@@ -18,7 +18,7 @@ use getopts;\n use testing;\n \n use html::escape::Escape;\n-use html::markdown::{Markdown, find_testable_code, reset_headers};\n+use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n use test::Collector;\n \n fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n@@ -145,7 +145,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n         css = css,\n         in_header = in_header,\n         before_content = before_content,\n-        text = Markdown(text),\n+        text = MarkdownWithToc(text),\n         after_content = after_content);\n \n     match err {"}]}