{"sha": "2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMjkzZWQ4YjgxYjFlMTQ1NGY4N2EzNmViMDIzN2FjMDBhZTNhNDk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-14T22:10:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T01:20:14Z"}, "message": "Convert *u8 native string users to *c_char", "tree": {"sha": "19b57abbf627ad6e9b990218cfe731b340d64b99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b57abbf627ad6e9b990218cfe731b340d64b99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "html_url": "https://github.com/rust-lang/rust/commit/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5dea87f4336f0b0edb5e3b6679c99df4d0891e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5dea87f4336f0b0edb5e3b6679c99df4d0891e5", "html_url": "https://github.com/rust-lang/rust/commit/e5dea87f4336f0b0edb5e3b6679c99df4d0891e5"}], "stats": {"total": 455, "additions": 231, "deletions": 224}, "files": [{"sha": "214c9a4fa9cde168004fa37c7729f1da4a9d79eb", "filename": "src/libcore/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -38,8 +38,8 @@ export as_c_charp, fill_charp_buf;\n native mod rustrt {\n     fn rust_env_pairs() -> [str];\n     fn rust_getcwd() -> str;\n-    fn rust_path_is_dir(path: *u8) -> c_int;\n-    fn rust_path_exists(path: *u8) -> c_int;\n+    fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n+    fn rust_path_exists(path: *libc::c_char) -> c_int;\n     fn rust_list_files(path: str) -> [str];\n     fn rust_process_wait(handle: c_int) -> c_int;\n }\n@@ -58,7 +58,7 @@ fn env() -> [(str,str)] {\n const tmpbuf_sz : uint = 1000u;\n \n fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n-    str::as_buf(s) {|b| f(b as *c_char) }\n+    str::as_c_str(s) {|b| f(b as *c_char) }\n }\n \n fn fill_charp_buf(f: fn(*mutable c_char, size_t) -> bool)\n@@ -386,14 +386,14 @@ fn homedir() -> option<path> {\n \n #[doc = \"Indicates whether a path represents a directory\"]\n fn path_is_dir(p: path) -> bool {\n-    str::as_buf(p) {|buf|\n+    str::as_c_str(p) {|buf|\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n #[doc = \"Indicates whether a path exists\"]\n fn path_exists(p: path) -> bool {\n-    str::as_buf(p) {|buf|\n+    str::as_c_str(p) {|buf|\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n }"}, {"sha": "58354bc49ca2a63641aaf1501ed771f88c76cf3f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -11,7 +11,8 @@ export waitpid;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_run_program(argv: **u8, envp: *c_void, dir: *u8,\n+    fn rust_run_program(argv: **libc::c_char, envp: *c_void,\n+                        dir: *libc::c_char,\n                         in_fd: c_int, out_fd: c_int, err_fd: c_int)\n         -> pid_t;\n }\n@@ -77,13 +78,13 @@ fn spawn_process(prog: str, args: [str],\n }\n \n fn with_argv<T>(prog: str, args: [str],\n-                cb: fn(**u8) -> T) -> T unsafe {\n-    let mut argptrs = str::as_buf(prog) {|b| [b] };\n+                cb: fn(**libc::c_char) -> T) -> T unsafe {\n+    let mut argptrs = str::as_c_str(prog) {|b| [b] };\n     let mut tmps = [];\n     for arg in args {\n         let t = @arg;\n         tmps += [t];\n-        argptrs += str::as_buf(*t) {|b| [b] };\n+        argptrs += str::as_c_str(*t) {|b| [b] };\n     }\n     argptrs += [ptr::null()];\n     vec::as_buf(argptrs, cb)\n@@ -104,7 +105,7 @@ fn with_envp<T>(env: option<[(str,str)]>,\n         for (k,v) in es {\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n-            ptrs += str::as_buf(*t) {|b| [b]};\n+            ptrs += str::as_c_str(*t) {|b| [b]};\n         }\n         ptrs += [ptr::null()];\n         vec::as_buf(ptrs) { |p| cb(::unsafe::reinterpret_cast(p)) }\n@@ -140,9 +141,9 @@ fn with_envp<T>(env: option<[(str,str)]>,\n }\n \n fn with_dirp<T>(d: option<str>,\n-                cb: fn(*u8) -> T) -> T unsafe {\n+                cb: fn(*libc::c_char) -> T) -> T unsafe {\n     alt d {\n-      some(dir) { str::as_buf(dir, cb) }\n+      some(dir) { str::as_c_str(dir, cb) }\n       none { cb(ptr::null()) }\n     }\n }"}, {"sha": "4ecd29d4a97948e3fe48f7ae029e5e22538c7afb", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -24,10 +24,10 @@ enum output_type {\n }\n \n fn llvm_err(sess: session, msg: str) -> ! unsafe {\n-    let buf = llvm::LLVMRustGetLastError();\n-    if buf == ptr::null() {\n+    let cstr = llvm::LLVMRustGetLastError();\n+    if cstr == ptr::null() {\n         sess.fatal(msg);\n-    } else { sess.fatal(msg + \": \" + str::from_buf(buf)); }\n+    } else { sess.fatal(msg + \": \" + str::from_c_str(cstr)); }\n }\n \n fn load_intrinsics_bc(sess: session) -> option<ModuleRef> {\n@@ -40,7 +40,7 @@ fn load_intrinsics_bc(sess: session) -> option<ModuleRef> {\n         ret option::none;\n       }\n     };\n-    let membuf = str::as_buf(path, {|buf|\n+    let membuf = str::as_c_str(path, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n     if membuf as uint == 0u {\n@@ -63,7 +63,7 @@ fn load_intrinsics_ll(sess: session) -> ModuleRef {\n       option::some(path) { path }\n       option::none { sess.fatal(\"couldn't find intrinsics.ll\") }\n     };\n-    let llintrinsicsmod = str::as_buf(path, { |buf|\n+    let llintrinsicsmod = str::as_c_str(path, { |buf|\n         llvm::LLVMRustParseAssemblyFile(buf)\n                                         });\n     if llintrinsicsmod as uint == 0u {\n@@ -131,15 +131,15 @@ mod write {\n               output_type_bitcode {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, \"no-opt.bc\");\n-                    str::as_buf(filename,\n+                    str::as_c_str(filename,\n                                 {|buf|\n                                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                                 });\n                 }\n               }\n               _ {\n                 let filename = mk_intermediate_name(output, \"bc\");\n-                str::as_buf(filename,\n+                str::as_c_str(filename,\n                             {|buf|\n                                 llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                             });\n@@ -215,18 +215,18 @@ mod write {\n \n                 let filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                str::as_buf(filename,\n+                str::as_c_str(filename,\n                             {|buf|\n                                 llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                             });\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n-                    let _: () = str::as_buf(\n+                    let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n                         {|buf_t|\n-                            str::as_buf(output, {|buf_o|\n+                            str::as_c_str(output, {|buf_o|\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm,\n                                     llmod,\n@@ -243,10 +243,10 @@ mod write {\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n                     let _: () =\n-                        str::as_buf(\n+                        str::as_c_str(\n                             sess.targ_cfg.target_strs.target_triple,\n                             {|buf_t|\n-                                str::as_buf(output, {|buf_o|\n+                                str::as_c_str(output, {|buf_o|\n                                     llvm::LLVMRustWriteOutputFile(\n                                         pm.llpm,\n                                         llmod,\n@@ -261,10 +261,10 @@ mod write {\n                 // type corresponding to the '-c' or '-S' flag used\n \n                 let _: () =\n-                    str::as_buf(\n+                    str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n                         {|buf_t|\n-                            str::as_buf(output, {|buf_o|\n+                            str::as_c_str(output, {|buf_o|\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm,\n                                     llmod,\n@@ -283,13 +283,13 @@ mod write {\n \n         if opts.output_type == output_type_llvm_assembly {\n             // Given options \"-S --emit-llvm\": output LLVM assembly\n-            str::as_buf(output, {|buf_o|\n+            str::as_c_str(output, {|buf_o|\n                 llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n         } else {\n             // If only a bitcode file is asked for by using the '--emit-llvm'\n             // flag, then output it here\n             llvm::LLVMRunPassManager(pm.llpm, llmod);\n-            str::as_buf(output,\n+            str::as_c_str(output,\n                         {|buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) });\n         }\n "}, {"sha": "37226d3941e611bb54eef4c166e2ad51b537cf94", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 154, "deletions": 148, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -1,6 +1,6 @@\n import std::map::hashmap;\n \n-import libc::{c_int, c_uint, c_longlong, c_ulonglong};\n+import libc::{c_char, c_int, c_uint, c_longlong, c_ulonglong};\n \n type Opcode = u32;\n type Bool = c_uint;\n@@ -147,28 +147,28 @@ native mod llvm {\n     fn LLVMContextCreate() -> ContextRef;\n     fn LLVMGetGlobalContext() -> ContextRef;\n     fn LLVMContextDispose(C: ContextRef);\n-    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *u8, SLen: c_uint) ->\n+    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *c_char, SLen: c_uint) ->\n        c_uint;\n-    fn LLVMGetMDKindID(Name: *u8, SLen: c_uint) -> c_uint;\n+    fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n     /* Create and destroy modules. */\n-    fn LLVMModuleCreateWithNameInContext(ModuleID: *u8, C: ContextRef) ->\n+    fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char, C: ContextRef) ->\n        ModuleRef;\n     fn LLVMDisposeModule(M: ModuleRef);\n \n     /** Data layout. See Module::getDataLayout. */\n-    fn LLVMGetDataLayout(M: ModuleRef) -> *u8;\n-    fn LLVMSetDataLayout(M: ModuleRef, Triple: *u8);\n+    fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n+    fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n \n     /** Target triple. See Module::getTargetTriple. */\n-    fn LLVMGetTarget(M: ModuleRef) -> *u8;\n-    fn LLVMSetTarget(M: ModuleRef, Triple: *u8);\n+    fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n+    fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n \n     /** See Module::dump. */\n     fn LLVMDumpModule(M: ModuleRef);\n \n     /** See Module::setModuleInlineAsm. */\n-    fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *u8);\n+    fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n \n     /** See llvm::LLVMTypeKind::getTypeID. */\n \n@@ -252,8 +252,8 @@ native mod llvm {\n \n     /* Operations on all values */\n     fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    fn LLVMGetValueName(Val: ValueRef) -> *u8;\n-    fn LLVMSetValueName(Val: ValueRef, Name: *u8);\n+    fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n+    fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n     fn LLVMDumpValue(Val: ValueRef);\n     fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n     fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n@@ -282,39 +282,40 @@ native mod llvm {\n     fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    fn LLVMMDStringInContext(C: ContextRef, Str: *u8, SLen: c_uint) ->\n+    fn LLVMMDStringInContext(C: ContextRef, Str: *c_char, SLen: c_uint) ->\n        ValueRef;\n-    fn LLVMMDString(Str: *u8, SLen: c_uint) -> ValueRef;\n+    fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n     fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: c_uint) ->\n        ValueRef;\n     fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-    fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *u8,\n+    fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n     fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) ->\n        ValueRef;\n     // FIXME: radix is actually u8, but our native layer can't handle this\n     // yet.  lucky for us we're little-endian. Small miracles.\n-    fn LLVMConstIntOfString(IntTy: TypeRef, Text: *u8, Radix: c_int) ->\n+    fn LLVMConstIntOfString(IntTy: TypeRef, Text: *c_char, Radix: c_int) ->\n        ValueRef;\n-    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *u8, SLen: c_uint,\n+    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *c_char,\n+                                   SLen: c_uint,\n                                    Radix: u8) -> ValueRef;\n     fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    fn LLVMConstRealOfString(RealTy: TypeRef, Text: *u8) -> ValueRef;\n-    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *u8,\n+    fn LLVMConstRealOfString(RealTy: TypeRef, Text: *c_char) -> ValueRef;\n+    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *c_char,\n                                     SLen: c_uint) -> ValueRef;\n     fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n \n \n     /* Operations on composite constants */\n-    fn LLVMConstStringInContext(C: ContextRef, Str: *u8, Length: c_uint,\n+    fn LLVMConstStringInContext(C: ContextRef, Str: *c_char, Length: c_uint,\n                                 DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n                                 Count: c_uint, Packed: Bool) -> ValueRef;\n \n-    fn LLVMConstString(Str: *u8, Length: c_uint,\n+    fn LLVMConstString(Str: *c_char, Length: c_uint,\n                        DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n                       Length: c_uint) -> ValueRef;\n@@ -416,9 +417,9 @@ native mod llvm {\n     fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *uint,\n                             NumIdx: c_uint) -> ValueRef;\n-    fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *u8, Constraints: *u8,\n-                          HasSideEffects: Bool, IsAlignStack: Bool) ->\n-       ValueRef;\n+    fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n+                          Constraints: *c_char, HasSideEffects: Bool,\n+                          IsAlignStack: Bool) -> ValueRef;\n     fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n \n \n@@ -428,19 +429,19 @@ native mod llvm {\n     fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n     fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n     fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    fn LLVMGetSection(Global: ValueRef) -> *u8;\n-    fn LLVMSetSection(Global: ValueRef, Section: *u8);\n+    fn LLVMGetSection(Global: ValueRef) -> *c_char;\n+    fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n     fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n     fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n     fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n     fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n     /* Operations on global variables */\n-    fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n-    fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: *u8,\n+    fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n+    fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: *c_char,\n                                    AddressSpace: c_uint) -> ValueRef;\n-    fn LLVMGetNamedGlobal(M: ModuleRef, Name: *u8) -> ValueRef;\n+    fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n     fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n@@ -454,25 +455,25 @@ native mod llvm {\n     fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n \n     /* Operations on aliases */\n-    fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef, Name: *u8)\n-       -> ValueRef;\n+    fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n \n     /* Operations on functions */\n-    fn LLVMAddFunction(M: ModuleRef, Name: *u8, FunctionTy: TypeRef) ->\n+    fn LLVMAddFunction(M: ModuleRef, Name: *c_char, FunctionTy: TypeRef) ->\n        ValueRef;\n-    fn LLVMGetNamedFunction(M: ModuleRef, Name: *u8) -> ValueRef;\n+    fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n     fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n     fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n     fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n     fn LLVMDeleteFunction(Fn: ValueRef);\n-    fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *u8, FunctionTy: TypeRef)\n-       -> ValueRef;\n+    fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n+                               FunctionTy: TypeRef) -> ValueRef;\n     fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n     fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n     fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    fn LLVMGetGC(Fn: ValueRef) -> *u8;\n-    fn LLVMSetGC(Fn: ValueRef, Name: *u8);\n+    fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n+    fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n     fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n     fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n     fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n@@ -504,13 +505,13 @@ native mod llvm {\n     fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n     fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n \n-    fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef, Name: *u8)\n-       -> BasicBlockRef;\n+    fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef,\n+                                     Name: *c_char) -> BasicBlockRef;\n     fn LLVMInsertBasicBlockInContext(C: ContextRef, BB: BasicBlockRef,\n-                                     Name: *u8) -> BasicBlockRef;\n+                                     Name: *c_char) -> BasicBlockRef;\n \n-    fn LLVMAppendBasicBlock(Fn: ValueRef, Name: *u8) -> BasicBlockRef;\n-    fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef, Name: *u8) ->\n+    fn LLVMAppendBasicBlock(Fn: ValueRef, Name: *c_char) -> BasicBlockRef;\n+    fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef, Name: *c_char) ->\n        BasicBlockRef;\n     fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -553,7 +554,7 @@ native mod llvm {\n     fn LLVMClearInsertionPosition(Builder: BuilderRef);\n     fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n     fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef, Instr: ValueRef,\n-                                     Name: *u8);\n+                                     Name: *c_char);\n     fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n     /* Metadata */\n@@ -575,9 +576,9 @@ native mod llvm {\n                            NumDests: c_uint) -> ValueRef;\n     fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n                        NumArgs: c_uint, Then: BasicBlockRef,\n-                       Catch: BasicBlockRef, Name: *u8) -> ValueRef;\n+                       Catch: BasicBlockRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildLandingPad(B: BuilderRef, Ty: TypeRef, PersFn: ValueRef,\n-                           NumClauses: c_uint, Name: *u8) -> ValueRef;\n+                           NumClauses: c_uint, Name: *c_char) -> ValueRef;\n     fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n     fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n@@ -594,169 +595,172 @@ native mod llvm {\n     fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n     /* Arithmetic */\n-    fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n+    fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n     fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n-    fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n     fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n-    fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n     fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: *u8) -> ValueRef;\n-    fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n     fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                          Name: *u8) -> ValueRef;\n-    fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n-    fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8) ->\n-       ValueRef;\n-    fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n-       -> ValueRef;\n+                          Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n+    fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                     Name: *c_char) -> ValueRef;\n+    fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n+    fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                   Name: *c_char) -> ValueRef;\n+    fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+                    Name: *c_char) -> ValueRef;\n     fn LLVMBuildBinOp(B: BuilderRef, Op: Opcode, LHS: ValueRef, RHS: ValueRef,\n-                      Name: *u8) -> ValueRef;\n-    fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n+                      Name: *c_char) -> ValueRef;\n+    fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n+    fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n+    fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n+    fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n+    fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n \n     /* Memory */\n-    fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildArrayMalloc(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: *u8) -> ValueRef;\n-    fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n+                            Name: *c_char) -> ValueRef;\n+    fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildArrayAlloca(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: *u8) -> ValueRef;\n+                            Name: *c_char) -> ValueRef;\n     fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *u8) ->\n+    fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *c_char) ->\n        ValueRef;\n     fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n        ValueRef;\n     fn LLVMBuildGEP(B: BuilderRef, Pointer: ValueRef, Indices: *ValueRef,\n-                    NumIndices: c_uint, Name: *u8) -> ValueRef;\n+                    NumIndices: c_uint, Name: *c_char) -> ValueRef;\n     fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                             Indices: *ValueRef, NumIndices: c_uint,\n-                            Name: *u8)\n+                            Name: *c_char)\n        -> ValueRef;\n     fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: c_uint,\n-                          Name: *u8) -> ValueRef;\n-    fn LLVMBuildGlobalString(B: BuilderRef, Str: *u8, Name: *u8) ->\n+                          Name: *c_char) -> ValueRef;\n+    fn LLVMBuildGlobalString(B: BuilderRef, Str: *c_char, Name: *c_char) ->\n        ValueRef;\n-    fn LLVMBuildGlobalStringPtr(B: BuilderRef, Str: *u8, Name: *u8) ->\n+    fn LLVMBuildGlobalStringPtr(B: BuilderRef, Str: *c_char, Name: *c_char) ->\n        ValueRef;\n \n     /* Casts */\n     fn LLVMBuildTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: *u8) -> ValueRef;\n+                      Name: *c_char) -> ValueRef;\n     fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                     Name: *u8) -> ValueRef;\n+                     Name: *c_char) -> ValueRef;\n     fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                     Name: *u8) -> ValueRef;\n+                     Name: *c_char) -> ValueRef;\n     fn LLVMBuildFPToUI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildFPToSI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildUIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildSIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n     fn LLVMBuildFPTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *u8) -> ValueRef;\n+                        Name: *c_char) -> ValueRef;\n     fn LLVMBuildFPExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: *u8) -> ValueRef;\n+                      Name: *c_char) -> ValueRef;\n     fn LLVMBuildPtrToInt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: *u8) -> ValueRef;\n+                         Name: *c_char) -> ValueRef;\n     fn LLVMBuildIntToPtr(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: *u8) -> ValueRef;\n+                         Name: *c_char) -> ValueRef;\n     fn LLVMBuildBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *u8) -> ValueRef;\n+                        Name: *c_char) -> ValueRef;\n     fn LLVMBuildZExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: *u8) -> ValueRef;\n+                              Name: *c_char) -> ValueRef;\n     fn LLVMBuildSExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: *u8) -> ValueRef;\n+                              Name: *c_char) -> ValueRef;\n     fn LLVMBuildTruncOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                               Name: *u8) -> ValueRef;\n+                               Name: *c_char) -> ValueRef;\n     fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n-                     DestTy: TypeRef, Name: *u8) -> ValueRef;\n+                     DestTy: TypeRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildPointerCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                            Name: *u8) -> ValueRef;\n+                            Name: *c_char) -> ValueRef;\n     fn LLVMBuildIntCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *u8) -> ValueRef;\n+                        Name: *c_char) -> ValueRef;\n     fn LLVMBuildFPCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *u8) -> ValueRef;\n+                       Name: *c_char) -> ValueRef;\n \n     /* Comparisons */\n     fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n-                     RHS: ValueRef, Name: *u8) -> ValueRef;\n+                     RHS: ValueRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n-                     RHS: ValueRef, Name: *u8) -> ValueRef;\n+                     RHS: ValueRef, Name: *c_char) -> ValueRef;\n \n     /* Miscellaneous instructions */\n-    fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                     NumArgs: c_uint, Name: *u8) -> ValueRef;\n+                     NumArgs: c_uint, Name: *c_char) -> ValueRef;\n     fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n-                       Else: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef, Name: *u8)\n+                       Else: ValueRef, Name: *c_char) -> ValueRef;\n+    fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef,\n+                      Name: *c_char)\n        -> ValueRef;\n     fn LLVMBuildExtractElement(B: BuilderRef, VecVal: ValueRef,\n-                               Index: ValueRef, Name: *u8) -> ValueRef;\n+                               Index: ValueRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildInsertElement(B: BuilderRef, VecVal: ValueRef,\n-                              EltVal: ValueRef, Index: ValueRef, Name: *u8)\n+                              EltVal: ValueRef, Index: ValueRef,\n+                              Name: *c_char)\n        -> ValueRef;\n     fn LLVMBuildShuffleVector(B: BuilderRef, V1: ValueRef, V2: ValueRef,\n-                              Mask: ValueRef, Name: *u8) -> ValueRef;\n+                              Mask: ValueRef, Name: *c_char) -> ValueRef;\n     fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: c_uint,\n-                             Name: *u8) -> ValueRef;\n+                             Name: *c_char) -> ValueRef;\n     fn LLVMBuildInsertValue(B: BuilderRef, AggVal: ValueRef, EltVal: ValueRef,\n-                            Index: c_uint, Name: *u8) -> ValueRef;\n+                            Index: c_uint, Name: *c_char) -> ValueRef;\n \n-    fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *u8) -> ValueRef;\n-    fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *u8) ->\n+    fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef,\n+                       Name: *c_char) -> ValueRef;\n+    fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char) ->\n        ValueRef;\n     fn LLVMBuildPtrDiff(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                        Name: *u8) -> ValueRef;\n+                        Name: *c_char) -> ValueRef;\n \n     /* Selected entries from the downcasts. */\n     fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n-    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *u8) -> c_int;\n+    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n \n     /** Creates target data from a target layout string. */\n-    fn LLVMCreateTargetData(StringRep: *u8) -> TargetDataRef;\n+    fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n     fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n@@ -856,46 +860,48 @@ native mod llvm {\n     /** Moves the section iterator to point to the next section. */\n     fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n     /** Returns the current section name. */\n-    fn LLVMGetSectionName(SI: SectionIteratorRef) -> *u8;\n+    fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n     /** Returns the current section size. */\n     fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n     /** Returns the current section contents as a string buffer. */\n-    fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *u8;\n+    fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n \n     /** Reads the given file and returns it as a memory buffer. Use\n         LLVMDisposeMemoryBuffer() to get rid of it. */\n-    fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *u8) ->\n+    fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char) ->\n        MemoryBufferRef;\n \n     /* FIXME: The FileType is an enum.*/\n-    fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef, Triple: *u8,\n-                               Output: *u8, FileType: c_int, OptLevel: c_int,\n+    fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef,\n+                               Triple: *c_char,\n+                               Output: *c_char, FileType: c_int,\n+                               OptLevel: c_int,\n                                EnableSegmentedStacks: bool);\n \n     /** Returns a string describing the last error caused by an LLVMRust*\n         call. */\n-    fn LLVMRustGetLastError() -> *u8;\n+    fn LLVMRustGetLastError() -> *c_char;\n \n     /** Parses the bitcode in the given memory buffer. */\n     fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n \n     /** Parses LLVM asm in the given file */\n-    fn LLVMRustParseAssemblyFile(Filename: *u8) -> ModuleRef;\n+    fn LLVMRustParseAssemblyFile(Filename: *c_char) -> ModuleRef;\n \n     /** FiXME: Hacky adaptor for lack of c_ulonglong in FFI: */\n     fn LLVMRustConstInt(IntTy: TypeRef, N_hi: c_uint, N_lo: c_uint,\n                         SignExtend: Bool) -> ValueRef;\n \n     fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n-                                  Output: *u8);\n+                                  Output: *c_char);\n \n     /** Turn on LLVM pass-timing. */\n     fn LLVMRustEnableTimePasses();\n \n     /** Print the pass timings since static dtors aren't picking them up. */\n     fn LLVMRustPrintPassTimings();\n \n-    fn LLVMStructCreateNamed(C: ContextRef, Name: *u8) -> TypeRef;\n+    fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n \n     fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n                          ElementCount: c_uint, Packed: Bool);\n@@ -1058,7 +1064,7 @@ type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n fn mk_target_data(string_rep: str) -> target_data {\n     let lltd =\n-        str::as_buf(string_rep, {|buf| llvm::LLVMCreateTargetData(buf) });\n+        str::as_c_str(string_rep, {|buf| llvm::LLVMCreateTargetData(buf) });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n "}, {"sha": "1560b4642ce2e83c252130cc3b7fa6db40287633", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -205,7 +205,7 @@ fn find_library_crate_aux(sess: session::session,\n \n fn get_metadata_section(sess: session::session,\n                         filename: str) -> option<@[u8]> unsafe {\n-    let mb = str::as_buf(filename, {|buf|\n+    let mb = str::as_c_str(filename, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n@@ -216,13 +216,13 @@ fn get_metadata_section(sess: session::session,\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = unsafe { str::from_buf(name_buf) };\n+        let name = unsafe { str::from_c_str(name_buf) };\n         if str::eq(name, sess.targ_cfg.target_strs.meta_sect_name) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {\n                 let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n-                ret option::some::<@[u8]>(@vec::unsafe::from_buf(cvbuf, csz));\n+                ret some(@vec::unsafe::from_buf(cvbuf, csz));\n             }\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);"}, {"sha": "ce6c5dea7ad7009cc07a4db095277f8d474efd90", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -166,7 +166,7 @@ fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timeval,\n \n fn decl_fn(llmod: ModuleRef, name: str, cc: lib::llvm::CallConv,\n            llty: TypeRef) -> ValueRef {\n-    let llfn: ValueRef = str::as_buf(name, {|buf|\n+    let llfn: ValueRef = str::as_c_str(name, {|buf|\n         llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n     });\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n@@ -198,7 +198,7 @@ fn get_extern_fn(externs: hashmap<str, ValueRef>, llmod: ModuleRef, name: str,\n fn get_extern_const(externs: hashmap<str, ValueRef>, llmod: ModuleRef,\n                     name: str, ty: TypeRef) -> ValueRef {\n     if externs.contains_key(name) { ret externs.get(name); }\n-    let c = str::as_buf(name, {|buf| llvm::LLVMAddGlobal(llmod, ty, buf) });\n+    let c = str::as_c_str(name, {|buf| llvm::LLVMAddGlobal(llmod, ty, buf) });\n     externs.insert(name, c);\n     ret c;\n }\n@@ -698,7 +698,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n         name = mangle_internal_name_by_type_only(ccx, t, \"tydesc\");\n         name = sanitize(name);\n     } else { name = mangle_internal_name_by_seq(ccx, \"tydesc\"); }\n-    let gvar = str::as_buf(name, {|buf|\n+    let gvar = str::as_c_str(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n     let info =\n@@ -1028,7 +1028,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n     if cx.sess.opts.save_temps {\n-        let _: () = str::as_buf(s, {|buf| llvm::LLVMSetValueName(v, buf) });\n+        let _: () = str::as_c_str(s, {|buf| llvm::LLVMSetValueName(v, buf) });\n     }\n }\n \n@@ -2306,7 +2306,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n-        let gvar = str::as_buf(sym, {|buf|\n+        let gvar = str::as_c_str(sym, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n         lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n@@ -3407,7 +3407,7 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, \"loglevel\");\n-        let global = str::as_buf(s, {|buf|\n+        let global = str::as_c_str(s, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n@@ -3669,7 +3669,7 @@ fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n     if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         s = cx.ccx.names(name);\n     }\n-    let llbb: BasicBlockRef = str::as_buf(s, {|buf|\n+    let llbb: BasicBlockRef = str::as_c_str(s, {|buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = @{llbb: llbb,\n@@ -3892,7 +3892,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let {bcx, val} = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::may(simple_name) {|name|\n-            str::as_buf(name, {|buf|\n+            str::as_c_str(name, {|buf|\n                 llvm::LLVMSetValueName(val, buf)\n             });\n         }\n@@ -3928,15 +3928,15 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n     dt: BasicBlockRef,\n     da: BasicBlockRef,\n     rt: BasicBlockRef} {\n-    ret {sa: str::as_buf(\"static_allocas\", {|buf|\n+    ret {sa: str::as_c_str(\"static_allocas\", {|buf|\n                  llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         ca: str::as_buf(\"load_env\", {|buf|\n+         ca: str::as_c_str(\"load_env\", {|buf|\n                  llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         dt: str::as_buf(\"derived_tydescs\", {|buf|\n+         dt: str::as_c_str(\"derived_tydescs\", {|buf|\n                  llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         da: str::as_buf(\"dynamic_allocas\", {|buf|\n+         da: str::as_c_str(\"dynamic_allocas\", {|buf|\n                  llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         rt: str::as_buf(\"return\", {|buf|\n+         rt: str::as_c_str(\"return\", {|buf|\n                  llvm::LLVMAppendBasicBlock(llfn, buf) })};\n }\n \n@@ -4629,15 +4629,15 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         fn main_name() -> str { ret \"main\"; }\n         let llfty = T_fn([ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n-        let llbb = str::as_buf(\"top\", {|buf|\n+        let llbb = str::as_c_str(\"top\", {|buf|\n             llvm::LLVMAppendBasicBlock(llfn, buf)\n         });\n         let bld = *ccx.builder;\n         llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n         let crate_map = ccx.crate_map;\n         let start_ty = T_fn([val_ty(rust_main), ccx.int_type, ccx.int_type,\n                              val_ty(crate_map)], ccx.int_type);\n-        let start = str::as_buf(\"rust_start\", {|buf|\n+        let start = str::as_c_str(\"rust_start\", {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, start_ty, buf)\n         });\n         let args = [rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n@@ -4687,7 +4687,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n               ast::item_const(_, _) {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n-                let g = str::as_buf(s, {|buf|\n+                let g = str::as_c_str(s, {|buf|\n                     llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n                 });\n                 ccx.item_symbols.insert(i.id, s);\n@@ -4772,7 +4772,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n                             path_name(\"discrim\")];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n-            let discrim_gvar = str::as_buf(s, {|buf|\n+            let discrim_gvar = str::as_c_str(s, {|buf|\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n             });\n             llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n@@ -4876,7 +4876,7 @@ fn trap(bcx: block) {\n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct([ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n-    let map = str::as_buf(\"_rust_mod_map\", {|buf|\n+    let map = str::as_c_str(\"_rust_mod_map\", {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n@@ -4904,7 +4904,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct([int_type, arrtype]);\n-    let map = str::as_buf(sym_name, {|buf|\n+    let map = str::as_c_str(sym_name, {|buf|\n         llvm::LLVMAddGlobal(llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n@@ -4918,7 +4918,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let nm = \"_rust_crate_map_\" + cstore::get_crate_data(cstore, i).name;\n-        let cr = str::as_buf(nm, {|buf|\n+        let cr = str::as_c_str(nm, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n         subcrates += [p2i(ccx, cr)];\n@@ -4934,18 +4934,18 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n-    let llglobal = str::as_buf(\"rust_metadata\", {|buf|\n+    let llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    str::as_buf(cx.sess.targ_cfg.target_strs.meta_sect_name, {|buf|\n+    str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, {|buf|\n         llvm::LLVMSetSection(llglobal, buf)\n     });\n     lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n     let t_ptr_i8 = T_ptr(T_i8());\n     llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-    let llvm_used = str::as_buf(\"llvm.used\", {|buf|\n+    let llvm_used = str::as_c_str(\"llvm.used\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n     });\n     lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n@@ -4974,17 +4974,17 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.name + \".rc\";\n \n-    let llmod = str::as_buf(llmod_id, {|buf|\n+    let llmod = str::as_c_str(llmod_id, {|buf|\n         llvm::LLVMModuleCreateWithNameInContext\n             (buf, llvm::LLVMGetGlobalContext())\n     });\n     let data_layout = sess.targ_cfg.target_strs.data_layout;\n     let targ_triple = sess.targ_cfg.target_strs.target_triple;\n     let _: () =\n-        str::as_buf(data_layout,\n+        str::as_c_str(data_layout,\n                     {|buf| llvm::LLVMSetDataLayout(llmod, buf) });\n     let _: () =\n-        str::as_buf(targ_triple,\n+        str::as_c_str(targ_triple,\n                     {|buf| llvm::LLVMSetTarget(llmod, buf) });\n     let targ_cfg = sess.targ_cfg;\n     let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "2a149a014930b607db5ce11563aede8b4afea1c1", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -81,8 +81,8 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n-// lot more efficient) than doing str::as_buf(\"\", ...) every time.\n-fn noname() -> *u8 unsafe {\n+// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n+fn noname() -> *libc::c_char unsafe {\n     const cnull: uint = 0u;\n     ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n@@ -359,12 +359,12 @@ fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n-fn GlobalString(cx: block, _Str: *u8) -> ValueRef {\n+fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n-fn GlobalStringPtr(cx: block, _Str: *u8) -> ValueRef {\n+fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n@@ -534,8 +534,8 @@ fn add_comment(bcx: block, text: str) {\n     if (!ccx.sess.opts.no_asm_comments) {\n         let sanitized = str::replace(text, \"$\", \"\");\n         let comment_text = \"; \" + sanitized;\n-        let asm = str::as_buf(comment_text, {|c|\n-            str::as_buf(\"\", {|e|\n+        let asm = str::as_c_str(comment_text, {|c|\n+            str::as_c_str(\"\", {|e|\n                 llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n                                          False, False)\n             })\n@@ -636,7 +636,7 @@ fn Trap(cx: block) {\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef = str::as_buf(\"llvm.trap\", {|buf|\n+    let T: ValueRef = str::as_c_str(\"llvm.trap\", {|buf|\n         llvm::LLVMGetNamedFunction(M, buf)\n     });\n     assert (T as int != 0);"}, {"sha": "5f0dda5267c6fbf32b0cb679f4f83ac61d054ec6", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -530,7 +530,7 @@ fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n \n fn T_named_struct(name: str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret str::as_buf(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n+    ret str::as_c_str(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n }\n \n fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n@@ -746,7 +746,7 @@ fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n }\n \n fn C_floating(s: str, t: TypeRef) -> ValueRef {\n-    ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n+    ret str::as_c_str(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n }\n \n fn C_nil() -> ValueRef {\n@@ -783,11 +783,11 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n-    let sc = str::as_buf(s) {|buf|\n+    let sc = str::as_c_str(s) {|buf|\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n-        str::as_buf(cx.names(\"str\"),\n+        str::as_c_str(cx.names(\"str\"),\n                     {|buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf) });\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n@@ -797,7 +797,7 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n-    ret str::as_buf(s) {|buf|\n+    ret str::as_c_str(s) {|buf|\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n }\n@@ -833,7 +833,7 @@ fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = str::as_buf(ccx.names(\"shape\"), {|buf|\n+    let llglobal = str::as_c_str(ccx.names(\"shape\"), {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);"}, {"sha": "3f50be550df519fca6e9e26a8a44ee379a455ddd", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -46,7 +46,7 @@ const DW_ATE_unsigned: int = 0x07;\n const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n-    str::as_buf(s, {|sbuf|\n+    str::as_c_str(s, {|sbuf|\n         llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n     })\n }\n@@ -74,7 +74,7 @@ fn llnull() -> ValueRef unsafe {\n }\n \n fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n-    str::as_buf(name, {|sbuf|\n+    str::as_c_str(name, {|sbuf|\n         llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf,\n                                           val)\n     })"}, {"sha": "7d350ae7fadf362c2dffe10a68226051e1135ba8", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -210,7 +210,7 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n                 ptrs: [ValueRef]) {\n     let tbl = C_struct(ptrs);\n-    let vt_gvar = str::as_buf(name, {|buf|\n+    let vt_gvar = str::as_c_str(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n     });\n     llvm::LLVMSetInitializer(vt_gvar, tbl);\n@@ -467,7 +467,7 @@ fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n     }\n     let ptrs = C_struct(get_dict_ptrs(bcx, origin).ptrs);\n     let name = ccx.names(\"dict\");\n-    let gvar = str::as_buf(name, {|buf|\n+    let gvar = str::as_c_str(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(ptrs), buf)\n     });\n     llvm::LLVMSetGlobalConstant(gvar, lib::llvm::True);"}, {"sha": "0502fc9abb1f4d73b95a431511947730b066b8ab", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a293ed8b81b1e1454f87a36eb0237ac00ae3a49/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=2a293ed8b81b1e1454f87a36eb0237ac00ae3a49", "patch": "@@ -79,7 +79,7 @@ fn eq_res_info(a: res_info, b: res_info) -> bool {\n fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n     let llglobal =\n-        str::as_buf(name,\n+        str::as_c_str(name,\n                     {|buf|\n                         lib::llvm::llvm::LLVMAddGlobal(ccx.llmod,\n                                                        val_ty(llval), buf)\n@@ -270,7 +270,7 @@ fn s_send_tydesc(_tcx: ty_ctxt) -> u8 {\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n-    let llshapetables = str::as_buf(\"shapes\", {|buf|\n+    let llshapetables = str::as_c_str(\"shapes\", {|buf|\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n "}]}