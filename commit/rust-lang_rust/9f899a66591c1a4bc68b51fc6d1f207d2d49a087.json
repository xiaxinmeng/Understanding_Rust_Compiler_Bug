{"sha": "9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODk5YTY2NTkxYzFhNGJjNjhiNTFmYzZkMWYyMDdkMmQ0OWEwODc=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-17T01:35:36Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-24T05:42:23Z"}, "message": "error during parsing for malformed inclusive range\n\nNow it is impossible for `...` or `a...` to reach HIR lowering\nwithout a rogue syntax extension in play.", "tree": {"sha": "6b90968173b7d0b368b3a44bb26fda8308c3bef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b90968173b7d0b368b3a44bb26fda8308c3bef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "html_url": "https://github.com/rust-lang/rust/commit/9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f899a66591c1a4bc68b51fc6d1f207d2d49a087/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9799cacba3042420cc7b49d555289241cf0456e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9799cacba3042420cc7b49d555289241cf0456e1", "html_url": "https://github.com/rust-lang/rust/commit/9799cacba3042420cc7b49d555289241cf0456e1"}], "stats": {"total": 71, "additions": 41, "deletions": 30}, "files": [{"sha": "deda0c59051794b3c14b019e21949f87b6ce0095", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9f899a66591c1a4bc68b51fc6d1f207d2d49a087/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f899a66591c1a4bc68b51fc6d1f207d2d49a087/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "patch": "@@ -2072,8 +2072,15 @@ impl<'a> Parser<'a> {\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>,\n                     limits: RangeLimits)\n-                    -> ast::ExprKind {\n-        ExprKind::Range(start, end, limits)\n+                    -> PResult<'a, ast::ExprKind> {\n+        if end.is_none() && limits == RangeLimits::Closed {\n+            Err(self.span_fatal_help(self.span,\n+                                     \"inclusive range with no end\",\n+                                     \"currently, inclusive ranges must be bounded at the end \\\n+                                      (`...b` or `a...b`) -- see tracking issue #28237\"))\n+        } else {\n+            Ok(ExprKind::Range(start, end, limits))\n+        }\n     }\n \n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n@@ -2961,12 +2968,12 @@ impl<'a> Parser<'a> {\n                 lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n                                    ExprKind::Type(lhs, rhs), None);\n                 continue\n-            } else if op == AssocOp::DotDot {\n-                // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n-                // it to the Fixity::None code.\n+            } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n+                // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n+                // generalise it to the Fixity::None code.\n                 //\n-                // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n-                // handled with `parse_prefix_range_expr` call above.\n+                // We have 2 alternatives here: `x..y`/`x...y` and `x..`/`x...` The other\n+                // two variants are handled with `parse_prefix_range_expr` call above.\n                 let rhs = if self.is_at_start_of_range_notation_rhs() {\n                     let rhs = self.parse_assoc_expr_with(op.precedence() + 1,\n                                                          LhsExpr::NotYetParsed);\n@@ -2985,7 +2992,13 @@ impl<'a> Parser<'a> {\n                 } else {\n                     cur_op_span\n                 });\n-                let r = self.mk_range(Some(lhs), rhs, RangeLimits::HalfOpen);\n+                let limits = if op == AssocOp::DotDot {\n+                    RangeLimits::HalfOpen\n+                } else {\n+                    RangeLimits::Closed\n+                };\n+\n+                let r = try!(self.mk_range(Some(lhs), rhs, limits));\n                 lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n                 break\n             }\n@@ -3003,8 +3016,7 @@ impl<'a> Parser<'a> {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n-                // the only operator handled here is `...` (the other non-associative operators are\n-                // special-cased above)\n+                // no operators are currently handled here\n                 Fixity::None => self.with_res(\n                     restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n                     |this| {\n@@ -3045,13 +3057,8 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n-                AssocOp::DotDotDot => {\n-                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n-                    let r = self.mk_range(Some(lhs), Some(rhs), RangeLimits::Closed);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, r, None)\n-                }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot => {\n-                    self.bug(\"As, Colon or DotDot branch reached\")\n+                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n+                    self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n                 }\n             };\n \n@@ -3095,21 +3102,23 @@ impl<'a> Parser<'a> {\n             // RHS must be parsed with more associativity than the dots.\n             let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n             Some(self.parse_assoc_expr_with(next_prec,\n-                                                 LhsExpr::NotYetParsed)\n-            .map(|x|{\n-                hi = x.span.hi;\n-                x\n-            })?)\n+                                            LhsExpr::NotYetParsed)\n+                .map(|x|{\n+                    hi = x.span.hi;\n+                    x\n+                })?)\n          } else {\n             None\n         };\n-        let r = self.mk_range(None,\n-                              opt_end,\n-                              if tok == token::DotDot {\n-                                  RangeLimits::HalfOpen\n-                              } else {\n-                                  RangeLimits::Closed\n-                              });\n+        let limits = if tok == token::DotDot {\n+            RangeLimits::HalfOpen\n+        } else {\n+            RangeLimits::Closed\n+        };\n+\n+        let r = try!(self.mk_range(None,\n+                                   opt_end,\n+                                   limits));\n         Ok(self.mk_expr(lo, hi, r, attrs))\n     }\n "}, {"sha": "169ba44224079c4041fcea9c4a14f5f6d59faa62", "filename": "src/test/compile-fail/impossible_range.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f899a66591c1a4bc68b51fc6d1f207d2d49a087/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f899a66591c1a4bc68b51fc6d1f207d2d49a087/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs?ref=9f899a66591c1a4bc68b51fc6d1f207d2d49a087", "patch": "@@ -19,7 +19,9 @@ pub fn main() {\n     0..1;\n \n     ...; //~ERROR inclusive range with no end\n-    0...; //~ERROR unexpected token\n+         //~^HELP 28237\n+    0...; //~ERROR inclusive range with no end\n+          //~^HELP 28237\n     ...1;\n     0...1;\n }"}]}