{"sha": "e7244e899f84721857d9702479c051292862f7f9", "node_id": "C_kwDOAAsO6NoAKGU3MjQ0ZTg5OWY4NDcyMTg1N2Q5NzAyNDc5YzA1MTI5Mjg2MmY3Zjk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-10T17:27:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-10T17:27:24Z"}, "message": "Merge #10739\n\n10739: internal: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "026f1714bc7b9d87d2cfb30bc11a0c2229ac1fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026f1714bc7b9d87d2cfb30bc11a0c2229ac1fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7244e899f84721857d9702479c051292862f7f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhjAD8CRBK7hj4Ov3rIwAAKpgIAGmnPJqQ3iXlPFI1cfyRh/mD\n+SD4Vo/PgFh5Kx9VSpOILaXz9JEIon825Tk98hMuUcJJwfDSNZeJKnPVHFw6bq6T\nzFXUUsb/n/gWxDowxJ8FidDb/duTVUZTgUgA4aN6x0OqO46EX9i4x9r/K+QOxbkJ\nhZPn/E7Hz65ybbg/xYsN7JT8lp+6CoPwvoEtKRnnPVJh8YTcoFzAsC2zqcjfL3wG\nDyMhrVaHuGCJoNTDS2n61hD/G7i2imRNorqkmDwPBYQ3xSz34w62XRO0Ql1ML3XH\nGEOBPT84Nfao2fBB5wenqo51pQua4os2KiPtuUi1Cp46S0BFtysTPHHfuzRU0EI=\n=OGwW\n-----END PGP SIGNATURE-----\n", "payload": "tree 026f1714bc7b9d87d2cfb30bc11a0c2229ac1fdb\nparent b2bce38bb44f46b9a68b7f98b03000f099cef4f8\nparent dea973089c026a13859eecf06a5da9f2d11ab46e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1636565244 +0000\ncommitter GitHub <noreply@github.com> 1636565244 +0000\n\nMerge #10739\n\n10739: internal: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7244e899f84721857d9702479c051292862f7f9", "html_url": "https://github.com/rust-lang/rust/commit/e7244e899f84721857d9702479c051292862f7f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7244e899f84721857d9702479c051292862f7f9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2bce38bb44f46b9a68b7f98b03000f099cef4f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bce38bb44f46b9a68b7f98b03000f099cef4f8", "html_url": "https://github.com/rust-lang/rust/commit/b2bce38bb44f46b9a68b7f98b03000f099cef4f8"}, {"sha": "dea973089c026a13859eecf06a5da9f2d11ab46e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dea973089c026a13859eecf06a5da9f2d11ab46e", "html_url": "https://github.com/rust-lang/rust/commit/dea973089c026a13859eecf06a5da9f2d11ab46e"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "c753369bfd98e5626b479b1ab8ef26d7fef8b7f4", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7244e899f84721857d9702479c051292862f7f9/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7244e899f84721857d9702479c051292862f7f9/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e7244e899f84721857d9702479c051292862f7f9", "patch": "@@ -897,13 +897,13 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n-        let sa = self.analyze(node);\n-        SemanticsScope { db: self.db, file_id: sa.file_id, resolver: sa.resolver }\n+        let SourceAnalyzer { file_id, resolver, .. } = self.analyze(node);\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n-        let sa = self.analyze_with_offset(node, offset);\n-        SemanticsScope { db: self.db, file_id: sa.file_id, resolver: sa.resolver }\n+        let SourceAnalyzer { file_id, resolver, .. } = self.analyze_with_offset(node, offset);\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n@@ -924,9 +924,11 @@ impl<'db> SemanticsImpl<'db> {\n     fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n         self.analyze_impl(node, None)\n     }\n+\n     fn analyze_with_offset(&self, node: &SyntaxNode, offset: TextSize) -> SourceAnalyzer {\n         self.analyze_impl(node, Some(offset))\n     }\n+\n     fn analyze_impl(&self, node: &SyntaxNode, offset: Option<TextSize>) -> SourceAnalyzer {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node.clone());"}, {"sha": "8e19928746cf427af14ee5c3fe55b99fe65bd7a3", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7244e899f84721857d9702479c051292862f7f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7244e899f84721857d9702479c051292862f7f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=e7244e899f84721857d9702479c051292862f7f9", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::never;\n \n use crate::{\n     autoderef,\n@@ -334,7 +335,7 @@ pub fn def_crates(\n             }};\n         }\n \n-    let mod_to_crate_ids = |module: ModuleId| Some(std::iter::once(module.krate()).collect());\n+    let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n \n     let lang_item_targets = match ty.kind(&Interner) {\n         TyKind::Adt(AdtId(def_id), _) => {\n@@ -533,9 +534,16 @@ fn iterate_method_candidates_with_autoref(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let (receiver_ty, rest) = match deref_chain.split_first() {\n+        Some((rec, rest)) => (rec.clone(), rest),\n+        None => {\n+            never!(\"received empty deref-chain\");\n+            return ControlFlow::Break(());\n+        }\n+    };\n     iterate_method_candidates_by_receiver(\n-        &deref_chain[0],\n-        &deref_chain[1..],\n+        &receiver_ty,\n+        &rest,\n         db,\n         env.clone(),\n         krate,\n@@ -546,8 +554,8 @@ fn iterate_method_candidates_with_autoref(\n     )?;\n \n     let refed = Canonical {\n-        binders: deref_chain[0].binders.clone(),\n-        value: TyKind::Ref(Mutability::Not, static_lifetime(), deref_chain[0].value.clone())\n+        binders: receiver_ty.binders.clone(),\n+        value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())\n             .intern(&Interner),\n     };\n \n@@ -564,9 +572,8 @@ fn iterate_method_candidates_with_autoref(\n     )?;\n \n     let ref_muted = Canonical {\n-        binders: deref_chain[0].binders.clone(),\n-        value: TyKind::Ref(Mutability::Mut, static_lifetime(), deref_chain[0].value.clone())\n-            .intern(&Interner),\n+        binders: receiver_ty.binders,\n+        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value).intern(&Interner),\n     };\n \n     iterate_method_candidates_by_receiver(\n@@ -596,7 +603,7 @@ fn iterate_method_candidates_by_receiver(\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n         iterate_inherent_methods(\n             self_ty,\n             db,\n@@ -609,7 +616,7 @@ fn iterate_method_candidates_by_receiver(\n         )?\n     }\n \n-    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n         iterate_trait_method_candidates(\n             self_ty,\n             db,\n@@ -671,8 +678,7 @@ fn iterate_trait_method_candidates(\n         }\n         _ => Vec::new(),\n     };\n-    let traits =\n-        inherent_trait.chain(env_traits.into_iter()).chain(traits_in_scope.iter().copied());\n+    let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     'traits: for t in traits {\n         let data = db.trait_data(t);\n@@ -800,7 +806,7 @@ fn iterate_inherent_methods(\n     ) -> ControlFlow<()> {\n         let impls_for_self_ty = filter_inherent_impls_for_self_ty(impls, &self_ty.value);\n         for &impl_def in impls_for_self_ty {\n-            for &item in db.impl_data(impl_def).items.iter() {\n+            for &item in &db.impl_data(impl_def).items {\n                 if !is_valid_candidate(\n                     db,\n                     env.clone(),"}, {"sha": "05ae95769b002251330f864327d7d8f30e25ecf4", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7244e899f84721857d9702479c051292862f7f9/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7244e899f84721857d9702479c051292862f7f9/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=e7244e899f84721857d9702479c051292862f7f9", "patch": "@@ -350,29 +350,28 @@ impl<'a> CompletionContext<'a> {\n impl<'a> CompletionContext<'a> {\n     pub(super) fn new(\n         db: &'a RootDatabase,\n-        position: FilePosition,\n+        position @ FilePosition { file_id, offset }: FilePosition,\n         config: &'a CompletionConfig,\n     ) -> Option<CompletionContext<'a>> {\n         let _p = profile::span(\"CompletionContext::new\");\n         let sema = Semantics::new(db);\n \n-        let original_file = sema.parse(position.file_id);\n+        let original_file = sema.parse(file_id);\n \n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n         let file_with_fake_ident = {\n-            let parse = db.parse(position.file_id);\n-            let edit = Indel::insert(position.offset, \"intellijRulezz\".to_string());\n+            let parse = db.parse(file_id);\n+            let edit = Indel::insert(offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token =\n-            file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n+            file_with_fake_ident.syntax().token_at_offset(offset).right_biased().unwrap();\n \n-        let original_token =\n-            original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token, position.offset);\n+        let scope = sema.scope_at_offset(&token, offset);\n         let krate = scope.krate();\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n@@ -408,7 +407,7 @@ impl<'a> CompletionContext<'a> {\n         ctx.expand_and_fill(\n             original_file.syntax().clone(),\n             file_with_fake_ident.syntax().clone(),\n-            position.offset,\n+            offset,\n             fake_ident_token,\n         );\n         Some(ctx)"}]}