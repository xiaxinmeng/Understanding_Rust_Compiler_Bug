{"sha": "4ace4e75201d5bfc187bd40cf918cd2df6009419", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhY2U0ZTc1MjAxZDViZmMxODdiZDQwY2Y5MThjZDJkZjYwMDk0MTk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-21T01:29:14Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:48:19Z"}, "message": "Use fewer `.to_string()`s", "tree": {"sha": "99b065de1274f9f650cb9ff2717fdc791a9e522e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b065de1274f9f650cb9ff2717fdc791a9e522e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ace4e75201d5bfc187bd40cf918cd2df6009419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ace4e75201d5bfc187bd40cf918cd2df6009419", "html_url": "https://github.com/rust-lang/rust/commit/4ace4e75201d5bfc187bd40cf918cd2df6009419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ace4e75201d5bfc187bd40cf918cd2df6009419/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f45e7b586259b795babf49231cd7de4a4534a2e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45e7b586259b795babf49231cd7de4a4534a2e7", "html_url": "https://github.com/rust-lang/rust/commit/f45e7b586259b795babf49231cd7de4a4534a2e7"}], "stats": {"total": 81, "additions": 42, "deletions": 39}, "files": [{"sha": "9bf30c71892aa94c1a9ad26164d883ddf830abdf", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4ace4e75201d5bfc187bd40cf918cd2df6009419/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ace4e75201d5bfc187bd40cf918cd2df6009419/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4ace4e75201d5bfc187bd40cf918cd2df6009419", "patch": "@@ -19,6 +19,7 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n use smallvec::{smallvec, SmallVec};\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::ops::Range;\n \n@@ -46,40 +47,40 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n-enum ErrorKind {\n-    Resolve(ResolutionFailure),\n+enum ErrorKind<'a> {\n+    Resolve(ResolutionFailure<'a>),\n     AnchorFailure(AnchorFailure),\n }\n \n #[derive(Debug)]\n-enum ResolutionFailure {\n+enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     /// `Namespace` is the expected namespace (as opposed to the actual).\n     WrongNamespace(Res, Namespace),\n     /// `String` is the base name of the path (not necessarily the whole link)\n-    NotInScope(String),\n+    NotInScope(Cow<'a, str>),\n     /// this is a primitive type without an impls (no associated methods)\n     /// when will this actually happen?\n     /// the `Res` is the primitive it resolved to\n     NoPrimitiveImpl(Res, String),\n     /// `[u8::not_found]`\n     /// the `Res` is the primitive it resolved to\n-    NoPrimitiveAssocItem { res: Res, prim_name: String, assoc_item: String },\n+    NoPrimitiveAssocItem { res: Res, prim_name: &'a str, assoc_item: Symbol },\n     /// `[S::not_found]`\n     /// the `String` is the associated item that wasn't found\n-    NoAssocItem(Res, String),\n+    NoAssocItem(Res, Symbol),\n     /// should not ever happen\n     NoParentItem,\n     /// the root of this path resolved, but it was not an enum.\n     NotAnEnum(Res),\n     /// this could be an enum variant, but the last path fragment wasn't resolved.\n     /// the `String` is the variant that didn't exist\n-    NotAVariant(Res, String),\n+    NotAVariant(Res, Symbol),\n     /// used to communicate that this should be ignored, but shouldn't be reported to the user\n     Dummy,\n }\n \n-impl ResolutionFailure {\n+impl ResolutionFailure<'a> {\n     fn res(&self) -> Option<Res> {\n         use ResolutionFailure::*;\n         match self {\n@@ -121,10 +122,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n     fn variant_field(\n         &self,\n-        path_str: &str,\n+        path_str: &'path str,\n         current_item: &Option<String>,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<String>), ErrorKind> {\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n         let mut split = path_str.rsplitn(3, \"::\");\n@@ -134,7 +135,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .expect(\"fold_item should ensure link is non-empty\");\n         let variant_name =\n             // we're not sure this is a variant at all, so use the full string\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_str.to_string())))?;\n+            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_str.into())))?;\n         // TODO: this looks very wrong, why are we requiring 3 fields?\n         let path = split\n             .next()\n@@ -147,14 +148,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 f.to_owned()\n             })\n             // TODO: is this right?\n-            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(variant_name.to_string())))?;\n+            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(\n+                variant_name.to_string().into(),\n+            )))?;\n         let (_, ty_res) = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n-            .map_err(|_| ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string())))?;\n+            .map_err(|_| {\n+                ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string().into()))\n+            })?;\n         if let Res::Err = ty_res {\n-            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string())));\n+            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string().into())));\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -183,7 +188,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         } else {\n                             Err(ErrorKind::Resolve(ResolutionFailure::NotAVariant(\n                                 ty_res,\n-                                variant_field_name.to_string(),\n+                                variant_field_name,\n                             )))\n                         }\n                     }\n@@ -197,9 +202,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Resolves a string as a macro.\n     fn macro_resolve(\n         &self,\n-        path_str: &str,\n+        path_str: &'a str,\n         parent_id: Option<DefId>,\n-    ) -> Result<Res, ResolutionFailure> {\n+    ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n@@ -232,19 +237,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 debug!(\"attempting to resolve item without parent module: {}\", path_str);\n                 return Err(ResolutionFailure::NoParentItem);\n             }\n-            return Err(ResolutionFailure::NotInScope(path_str.to_string()));\n+            return Err(ResolutionFailure::NotInScope(path_str.into()));\n         })\n     }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n-    fn resolve(\n+    fn resolve<'path>(\n         &self,\n-        path_str: &str,\n+        path_str: &'path str,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n         extra_fragment: &Option<String>,\n-    ) -> Result<(Res, Option<String>), ErrorKind> {\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative path.\n@@ -309,11 +314,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 })\n                 // If there's no `::`, it's not an associated item.\n                 // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n-                .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(item_name.to_string())))?;\n+                .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(\n+                    item_name.to_string().into(),\n+                )))?;\n \n             if let Some((path, prim)) = is_primitive(&path_root, ns) {\n                 let impls = primitive_impl(cx, &path).ok_or_else(|| {\n-                    ErrorKind::Resolve(ResolutionFailure::NoPrimitiveImpl(prim, path_root))\n+                    ErrorKind::Resolve(ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))\n                 })?;\n                 for &impl_ in impls {\n                     let link = cx\n@@ -337,8 +344,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 return Err(ErrorKind::Resolve(ResolutionFailure::NoPrimitiveAssocItem {\n                     res: prim,\n-                    prim_name: path.to_string(),\n-                    assoc_item: item_name.to_string(),\n+                    prim_name: path,\n+                    assoc_item: item_name,\n                 }));\n             }\n \n@@ -347,13 +354,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n                 })\n                 .map_err(|_| {\n-                    ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root.clone()))\n+                    ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root.clone().into()))\n                 })?;\n             if let Res::Err = ty_res {\n                 return if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root)))\n+                    Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root.into())))\n                 };\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n@@ -450,8 +457,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     } else {\n                         // We already know this isn't in ValueNS, so no need to check variant_field\n                         return Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n-                            ty_res,\n-                            item_name.to_string(),\n+                            ty_res, item_name,\n                         )));\n                     }\n                 }\n@@ -491,10 +497,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n-                        ty_res,\n-                        item_name.to_string(),\n-                    )))\n+                    Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(ty_res, item_name)))\n                 }\n             })\n         } else {\n@@ -638,7 +641,7 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case\n-fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure>>) -> bool {\n+fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n     if let PerNS {\n         type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n         macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n@@ -941,7 +944,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             drop(candidates_iter);\n                             if is_derive_trait_collision(&candidates) {\n                                 candidates.macro_ns =\n-                                    Err(ResolutionFailure::NotInScope(path_str.to_string()));\n+                                    Err(ResolutionFailure::NotInScope(path_str.into()));\n                             }\n                             // If we're reporting an ambiguity, don't mention the namespaces that failed\n                             let candidates =\n@@ -1348,7 +1351,7 @@ fn resolution_failure(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n-    kinds: SmallVec<[ResolutionFailure; 3]>,\n+    kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n         cx,\n@@ -1494,10 +1497,10 @@ fn anchor_failure(\n     });\n }\n \n-fn ambiguity_error(\n+fn ambiguity_error<'a>(\n     cx: &DocContext<'_>,\n     item: &Item,\n-    path_str: &str,\n+    path_str: &'a str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n     candidates: Vec<Res>,\n@@ -1593,7 +1596,7 @@ fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n     extra_fragment: &Option<String>,\n-) -> Result<(Res, Option<String>), ErrorKind> {\n+) -> Result<(Res, Option<String>), ErrorKind<'static>> {\n     use rustc_middle::ty::DefIdTree;\n \n     if extra_fragment.is_some() {"}]}