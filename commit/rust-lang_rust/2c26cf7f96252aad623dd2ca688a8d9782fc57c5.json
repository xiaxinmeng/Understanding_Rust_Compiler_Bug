{"sha": "2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjZjZjdmOTYyNTJhYWQ2MjNkZDJjYTY4OGE4ZDk3ODJmYzU3YzU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-30T14:19:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:49Z"}, "message": "add low-level uv_async bindings for use in tcp test", "tree": {"sha": "2ac99558f17ca4cc0d27dbf175a1c8edc930e8bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ac99558f17ca4cc0d27dbf175a1c8edc930e8bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "html_url": "https://github.com/rust-lang/rust/commit/2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "717632168515cc3249fa6610baf484713c132226", "url": "https://api.github.com/repos/rust-lang/rust/commits/717632168515cc3249fa6610baf484713c132226", "html_url": "https://github.com/rust-lang/rust/commit/717632168515cc3249fa6610baf484713c132226"}], "stats": {"total": 141, "additions": 123, "deletions": 18}, "files": [{"sha": "0e21d1d5da6c3a861f22b8428b1d74687fd14ad5", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 102, "deletions": 10, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "patch": "@@ -274,6 +274,30 @@ fn gen_stub_uv_write_t() -> uv_write_t {\n         a12: 0 as *u8\n     };\n }\n+// unix size: 120\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+type uv_async_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8\n+};\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+fn gen_stub_uv_async_t() -> uv_async_t {\n+    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    mut data: ptr::null() },\n+        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n+        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n+        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n+    };\n+}\n \n // unix size: 16\n #[cfg(target_os = \"linux\")]\n@@ -312,8 +336,11 @@ native mod rustrt {\n     fn rust_uv_hilvl_close(handle: *libc::c_void, cb: *u8);\n     fn rust_uv_hilvl_close_async(handle: *libc::c_void);\n     fn rust_uv_hilvl_close_timer(handle: *libc::c_void);\n-    fn rust_uv_async_send(handle: *libc::c_void);\n-    fn rust_uv_async_init(\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *libc::c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> libc::c_int;\n+    fn rust_uv_hilvl_async_init(\n         loop_handle: *libc::c_void,\n         cb: *u8,\n         id: *u8) -> *libc::c_void;\n@@ -366,6 +393,7 @@ native mod rustrt {\n     fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n     fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n     fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n \n     // data accessors for rust-mapped uv structs\n     fn rust_uv_get_stream_handle_from_connect_req(\n@@ -460,6 +488,18 @@ mod direct {\n         ret rustrt::rust_uv_last_error(loop_handle);\n     }\n \n+    unsafe fn async_init(loop_handle: *libc::c_void,\n+                         async_handle: *uv_async_t,\n+                         cb: *u8) -> libc::c_int {\n+        ret rustrt::rust_uv_async_init(loop_handle,\n+                                       async_handle,\n+                                       cb);\n+    }\n+\n+    unsafe fn async_send(async_handle: *uv_async_t) {\n+        ret rustrt::rust_uv_async_send(async_handle);\n+    }\n+\n     // libuv struct initializers\n     unsafe fn tcp_t() -> uv_tcp_t {\n         ret gen_stub_uv_tcp_t();\n@@ -470,6 +510,9 @@ mod direct {\n     unsafe fn write_t() -> uv_write_t {\n         ret gen_stub_uv_write_t();\n     }\n+    unsafe fn async_t() -> uv_async_t {\n+        ret gen_stub_uv_async_t();\n+    }\n     unsafe fn get_loop_for_uv_handle(handle: *libc::c_void)\n         -> *libc::c_void {\n         ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n@@ -855,7 +898,7 @@ fn pass_to_libuv(\n     do_send(op_handle);\n }\n fn do_send(h: *libc::c_void) {\n-    rustrt::rust_uv_async_send(h);\n+    rustrt::rust_uv_async_send(h as *uv_async_t);\n }\n fn gen_handle_id() -> [u8] {\n     ret rand::rng().gen_bytes(16u);\n@@ -920,7 +963,7 @@ crust fn process_operation(\n         alt comm::recv(op_port) {\n           op_async_init(id) {\n             let id_ptr = vec::unsafe::to_ptr(id);\n-            let async_handle = rustrt::rust_uv_async_init(\n+            let async_handle = rustrt::rust_uv_hilvl_async_init(\n                 lp,\n                 process_async_send,\n                 id_ptr);\n@@ -1367,12 +1410,29 @@ type tcp_server_data = {\n     server_write_req: *uv_write_t\n };\n \n+type async_handle_data = {\n+    continue_chan: *comm::chan<bool>\n+};\n+\n+crust fn continue_async_cb(async_handle: *uv_async_t,\n+                           status: libc::c_int) unsafe {\n+    // once we're in the body of this callback,\n+    // the tcp server's loop is set up, so we\n+    // can continue on to let the tcp client\n+    // do its thang\n+    let data = direct::get_data_for_uv_handle(\n+        async_handle as *libc::c_void) as *async_handle_data;\n+    let continue_chan = *((*data).continue_chan);\n+    comm::send(continue_chan, true);\n+    direct::close(async_handle as *libc::c_void, 0 as *u8);\n+}\n+\n fn impl_uv_tcp_server(server_ip: str,\n                       server_port: int,\n                       kill_server_msg: str,\n                       server_resp_msg: str,\n                       server_chan: *comm::chan<str>,\n-                      continue_chan: comm::chan<bool>) unsafe {\n+                      continue_chan: *comm::chan<bool>) unsafe {\n     let test_loop = direct::loop_new();\n     let tcp_server = direct::tcp_t();\n     let tcp_server_ptr = ptr::addr_of(tcp_server);\n@@ -1389,6 +1449,13 @@ fn impl_uv_tcp_server(server_ip: str,\n         direct::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n     ];\n \n+    let continue_async_handle = direct::async_t();\n+    let continue_async_handle_ptr =\n+        ptr::addr_of(continue_async_handle);\n+    let async_data =\n+        { continue_chan: continue_chan };\n+    let async_data_ptr = ptr::addr_of(async_data);\n+\n     let server_data: tcp_server_data = {\n         client: tcp_client_ptr,\n         server: tcp_server_ptr,\n@@ -1423,10 +1490,22 @@ fn impl_uv_tcp_server(server_ip: str,\n             if (listen_result == 0i32) {\n                 // let the test know it can set up the tcp server,\n                 // now.. this may still present a race, not sure..\n-                comm::send(continue_chan, true);\n-\n-                // uv_run()\n-                direct::run(test_loop);\n+                let async_result = direct::async_init(test_loop,\n+                                   continue_async_handle_ptr,\n+                                   continue_async_cb);\n+                if (async_result == 0i32) {\n+                    direct::set_data_for_uv_handle(\n+                        continue_async_handle_ptr as *libc::c_void,\n+                        async_data_ptr as *libc::c_void);\n+                    direct::async_send(continue_async_handle_ptr);\n+                    // uv_run()\n+                    direct::run(test_loop);\n+                }\n+                else {\n+                    io::println(#fmt(\"uv_async_init failure: %d\",\n+                            async_result as int));\n+                    assert false;\n+                }\n             }\n             else {\n                 io::println(#fmt(\"non-zero result on uv_listen: %d\",\n@@ -1462,13 +1541,14 @@ fn test_uv_tcp_server_and_request() unsafe {\n \n     let continue_port = comm::port::<bool>();\n     let continue_chan = comm::chan::<bool>(continue_port);\n+    let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n     task::spawn_sched(task::manual_threads(1u)) {||\n         impl_uv_tcp_server(ip, port,\n                            kill_server_msg,\n                            server_resp_msg,\n                            ptr::addr_of(server_chan),\n-                           continue_chan);\n+                           continue_chan_ptr);\n     };\n \n     // block until the server up is.. possibly a race?\n@@ -1546,6 +1626,18 @@ fn test_uv_struct_size_sockaddr_in() {\n     assert native_handle_size as uint == rust_handle_size;\n }\n \n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_uv_async_t() {\n+    let native_handle_size =\n+        rustrt::rust_uv_helper_uv_async_t_size();\n+    let rust_handle_size = sys::size_of::<uv_async_t>();\n+    let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}\n+\n fn impl_uv_byval_test() unsafe {\n     let addr = direct::ip4_addr(\"173.194.33.111\", 80);\n     io::println(#fmt(\"after build addr in rust. port: %u\","}, {"sha": "6303bd700a6b673acad4a5d24e2521fb7bd05bb2", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "patch": "@@ -167,15 +167,22 @@ rust_uv_async_send(uv_async_t* handle) {\n     uv_async_send(handle);\n }\n \n+extern \"C\" int\n+rust_uv_async_init(uv_loop_t* loop_handle,\n+\t\t\t\t   uv_async_t* async_handle,\n+\t\t\t\t   uv_async_cb cb) {\n+\treturn uv_async_init(loop_handle, async_handle, cb);\n+}\n+\n extern \"C\" void*\n-rust_uv_async_init(uv_loop_t* loop, crust_simple_cb cb,\n-                                                 uint8_t* buf) {\n-        uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-                sizeof(uv_async_t),\n-                \"uv_async_t\");\n-        uv_async_init(loop, async, native_async_cb);\n-        handle_data* data = new_handle_data_from(buf, cb);\n-        async->data = data;\n+rust_uv_hilvl_async_init(uv_loop_t* loop, crust_simple_cb cb,\n+\t\t\t\t\t\t uint8_t* buf) {\n+\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\t\tsizeof(uv_async_t),\n+\t\t\"uv_async_t\");\n+\tuv_async_init(loop, async, native_async_cb);\n+\thandle_data* data = new_handle_data_from(buf, cb);\n+\tasync->data = data;\n \n         return async;\n }\n@@ -270,6 +277,10 @@ extern \"C\" size_t\n rust_uv_helper_sockaddr_in_size() {\n \treturn sizeof(sockaddr_in);\n }\n+extern \"C\" size_t\n+rust_uv_helper_uv_async_t_size() {\n+\treturn sizeof(uv_async_t);\n+}\n \n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {"}, {"sha": "38d97f0c3ed254802aba5e3a2a795a5aaa4b9536", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/2c26cf7f96252aad623dd2ca688a8d9782fc57c5/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "patch": "@@ -92,6 +92,7 @@ rust_uv_hilvl_close_async\n rust_uv_hilvl_close_timer\n rust_uv_async_send\n rust_uv_async_init\n+rust_uv_hilvl_async_init\n rust_uv_timer_init\n rust_uv_timer_start\n rust_uv_timer_stop\n@@ -116,6 +117,7 @@ rust_uv_helper_uv_buf_t_size\n rust_uv_helper_uv_write_t_size\n rust_uv_helper_uv_err_t_size\n rust_uv_helper_sockaddr_in_size\n+rust_uv_helper_uv_async_t_size\n rust_uv_get_stream_handle_from_connect_req\n rust_uv_get_stream_handle_from_write_req\n rust_uv_get_loop_for_uv_handle"}]}