{"sha": "3bfa28c3a8e09364207c4f5c437c8e73dac67716", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZmEyOGMzYThlMDkzNjQyMDdjNGY1YzQzN2M4ZTczZGFjNjc3MTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-10T01:47:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-10T01:47:33Z"}, "message": "Rollup merge of #67922 - Centril:lowering-cleanup, r=petrochenkov\n\nrustc_ast_lowering: misc cleanup & rustc dep reductions\n\n- The first two commits do some code simplification.\n- The next three do some file splitting (getting `lib.rs` below the 3kloc tidy lint).\n- The remaining commits reduce the number of `rustc::` imports. This works towards making lowering independent of the `rustc` crate.\n\nr? @oli-obk cc @Zoxc", "tree": {"sha": "6105e39a006125f7cbc4328fff4722dc6416ccff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6105e39a006125f7cbc4328fff4722dc6416ccff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bfa28c3a8e09364207c4f5c437c8e73dac67716", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeF9e1CRBK7hj4Ov3rIwAAdHIIALNVHB3G3pCFRiKvawKwurtC\nQcBLJLbel+p3/ERWDV/V3KfCIWRgQDfexNWeNHSTwoSwCUCBmKanYdiIhPpHCQGg\nzlqfGZC3xiQoFPkODeoQhdQDukumIXwrm0t/e0ZFf+D/OY6M7kMd1NcF/hZgaout\n3z4uz3q6qSIgVQ2Fx5xC1RTKbSwTAiBCWiQCrJ4WvJ3/TiyxgWEc+zLc5StIqTBE\nizciHz3wAp9fRxghdQDxbdJvJLjR/0zbhYQWhuTJpZBQd/42ns1T3CFm07mvfpV4\nJQTTJX6gLJaxVGAmyfgg/w+ZJeXgAdoFZ7u/fUNS0o+UWER9tkqQb459XJ/4S+k=\n=u9/s\n-----END PGP SIGNATURE-----\n", "payload": "tree 6105e39a006125f7cbc4328fff4722dc6416ccff\nparent f3963873aac5fbc3ace85ae290710b58506f3645\nparent 5dafa6a46466ab26b7cd7c38f965d37af045af5d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1578620853 +0100\ncommitter GitHub <noreply@github.com> 1578620853 +0100\n\nRollup merge of #67922 - Centril:lowering-cleanup, r=petrochenkov\n\nrustc_ast_lowering: misc cleanup & rustc dep reductions\n\n- The first two commits do some code simplification.\n- The next three do some file splitting (getting `lib.rs` below the 3kloc tidy lint).\n- The remaining commits reduce the number of `rustc::` imports. This works towards making lowering independent of the `rustc` crate.\n\nr? @oli-obk cc @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfa28c3a8e09364207c4f5c437c8e73dac67716", "html_url": "https://github.com/rust-lang/rust/commit/3bfa28c3a8e09364207c4f5c437c8e73dac67716", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bfa28c3a8e09364207c4f5c437c8e73dac67716/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3963873aac5fbc3ace85ae290710b58506f3645", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3963873aac5fbc3ace85ae290710b58506f3645", "html_url": "https://github.com/rust-lang/rust/commit/f3963873aac5fbc3ace85ae290710b58506f3645"}, {"sha": "5dafa6a46466ab26b7cd7c38f965d37af045af5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dafa6a46466ab26b7cd7c38f965d37af045af5d", "html_url": "https://github.com/rust-lang/rust/commit/5dafa6a46466ab26b7cd7c38f965d37af045af5d"}], "stats": {"total": 1500, "additions": 752, "deletions": 748}, "files": [{"sha": "012900f8af51b1ec19e6a094c226feb01d23582f", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, BoundVar, Ty, TyCtxt};\n-use crate::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;"}, {"sha": "8ee8482e79dbc3f1b216cc79bdb161277e7e2831", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "cf424ffe7b2930f2dbf8029a8babcad37682ae62", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -100,7 +100,6 @@ pub mod ty;\n \n pub mod util {\n     pub mod bug;\n-    pub mod captures;\n     pub mod common;\n }\n "}, {"sha": "5b1e7673629b192fefb1c6cf5a01b331f253474b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -5,8 +5,8 @@\n use crate::hir::map as hir_map;\n use crate::hir::map::definitions::{DefKey, DefPathTable};\n use crate::session::search_paths::PathKind;\n-use crate::session::{CrateDisambiguator, Session};\n-use crate::ty::{self, TyCtxt};\n+use crate::session::CrateDisambiguator;\n+use crate::ty::TyCtxt;\n \n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, MetadataRef};\n@@ -208,7 +208,6 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that."}, {"sha": "738bbd936fea437c04ce67b2fac5cb29efde3a79", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -17,7 +17,6 @@ use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n-use crate::util::common::FN_OUTPUT_NAME;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n@@ -1364,7 +1363,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n         projection_ty: ty::ProjectionTy::from_ref_and_name(\n             tcx,\n             trait_ref,\n-            Ident::with_dummy_span(FN_OUTPUT_NAME),\n+            Ident::with_dummy_span(rustc_hir::FN_OUTPUT_NAME),\n         ),\n         ty: ret_type,\n     });"}, {"sha": "d1e37a4ea1151f09e8a1dc01e9d2c71ae784fc03", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -26,8 +26,8 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use crate::ty::walk::TypeWalker;\n-use crate::util::captures::Captures;\n use arena::SyncDroplessArena;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};"}, {"sha": "c89d045cebb739f7dda8e68f67a5fac6e79478e3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -13,11 +13,10 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable};\n use crate::ty::{List, ParamEnv, ParamEnvAnd, TyS};\n-use crate::util::captures::Captures;\n+use polonius_engine::Atom;\n+use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-\n-use polonius_engine::Atom;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Symbol};"}, {"sha": "9324b26a09b6f35071b1ee582d0714933457986a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -5,14 +5,9 @@ use rustc_data_structures::sync::Lock;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use rustc_span::symbol::{sym, Symbol};\n-\n #[cfg(test)]\n mod tests;\n \n-// The name of the associated type for `Fn` return types.\n-pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n-\n pub use errors::ErrorReported;\n \n pub fn to_readable_str(mut val: usize) -> String {"}, {"sha": "beb53a19ac4ffae7bdbcb5e1be8111656b919dfa", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -25,19 +25,16 @@ pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n \n-impl<'a, 'lowering, 'hir> ItemLowerer<'a, 'lowering, 'hir> {\n-    fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n+impl ItemLowerer<'_, '_, '_> {\n+    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n         let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = if let &None = trait_impl_ref { false } else { true };\n+        self.lctx.is_in_trait_impl = if let &None = impl_ref { false } else { true };\n         f(self);\n         self.lctx.is_in_trait_impl = old;\n     }\n }\n \n-impl<'a, 'lowering, 'hir> Visitor<'a> for ItemLowerer<'a, 'lowering, 'hir> {\n+impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n         let hir_id = self.lctx.lower_node_id(n);\n "}, {"sha": "527aa6796bc22269185aa885e8b1a8dae675315b", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 36, "deletions": 711, "changes": 747, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Lowers the AST to the HIR.\n //!\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n@@ -33,21 +31,20 @@\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(array_value_iter)]\n+#![feature(crate_visibility_modifier)]\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map::definitions::{DefKey, DefPathData, Definitions};\n use rustc::hir::map::Map;\n use rustc::lint;\n-use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n-use rustc::middle::cstore::CrateStore;\n-use rustc::util::captures::Captures;\n-use rustc::util::common::FN_OUTPUT_NAME;\n+use rustc::lint::builtin;\n use rustc::{bug, span_bug};\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_error_codes::*;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, DefIndex, CRATE_DEF_INDEX};\n@@ -58,14 +55,13 @@ use rustc_session::config::nightly_options;\n use rustc_session::node_id::NodeMap;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::print::pprust;\n-use syntax::ptr::P as AstP;\n use syntax::sess::ParseSess;\n use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -86,6 +82,8 @@ macro_rules! arena_vec {\n \n mod expr;\n mod item;\n+mod pat;\n+mod path;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -173,7 +171,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n }\n \n pub trait Resolver {\n-    fn cstore(&self) -> &dyn CrateStore;\n+    fn def_key(&mut self, id: DefId) -> DefKey;\n+\n+    fn item_generics_num_lifetimes(&self, def: DefId, sess: &Session) -> usize;\n \n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n@@ -433,18 +433,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n             }\n \n-            fn with_hir_id_owner<F, T>(&mut self, owner: Option<NodeId>, f: F) -> T\n-            where\n-                F: FnOnce(&mut Self) -> T,\n-            {\n+            fn with_hir_id_owner<T>(\n+                &mut self,\n+                owner: Option<NodeId>,\n+                f: impl FnOnce(&mut Self) -> T,\n+            ) -> T {\n                 let old = mem::replace(&mut self.hir_id_owner, owner);\n                 let r = f(self);\n                 self.hir_id_owner = old;\n                 r\n             }\n         }\n \n-        impl<'tcx, 'lowering, 'hir> Visitor<'tcx> for MiscCollector<'tcx, 'lowering, 'hir> {\n+        impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n                 if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n                     // Doesn't generate a HIR node\n@@ -577,10 +578,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         lowered\n     }\n \n-    fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> hir::HirId\n-    where\n-        F: FnOnce(&mut Self) -> hir::HirId,\n-    {\n+    fn lower_node_id_generic(\n+        &mut self,\n+        ast_node_id: NodeId,\n+        alloc_hir_id: impl FnOnce(&mut Self) -> hir::HirId,\n+    ) -> hir::HirId {\n         if ast_node_id == DUMMY_NODE_ID {\n             return hir::DUMMY_HIR_ID;\n         }\n@@ -604,10 +606,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn with_hir_id_owner<F, T>(&mut self, owner: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_hir_id_owner<T>(&mut self, owner: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let counter = self\n             .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n@@ -736,15 +735,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n     /// parameter while `f` is running (and restored afterwards).\n-    fn collect_in_band_defs<T, F>(\n+    fn collect_in_band_defs<T>(\n         &mut self,\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: F,\n-    ) -> (Vec<hir::GenericParam<'hir>>, T)\n-    where\n-        F: FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n-    {\n+        f: impl FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n+    ) -> (Vec<hir::GenericParam<'hir>>, T) {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n@@ -847,10 +843,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // This is used to track which lifetimes have already been defined, and\n     // which are new in-band lifetimes that need to have a definition created\n     // for them.\n-    fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &[GenericParam], f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_in_scope_lifetime_defs<T>(\n+        &mut self,\n+        params: &[GenericParam],\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n@@ -870,16 +867,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n     /// parameter while `f` is running (and restored afterwards).\n-    fn add_in_band_defs<F, T>(\n+    fn add_in_band_defs<T>(\n         &mut self,\n         generics: &Generics,\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: F,\n-    ) -> (hir::Generics<'hir>, T)\n-    where\n-        F: FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n-    {\n+        f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n+    ) -> (hir::Generics<'hir>, T) {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n@@ -917,10 +911,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (lowered_generics, res)\n     }\n \n-    fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n \n@@ -931,10 +922,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         result\n     }\n \n-    fn with_new_scopes<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_new_scopes<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n@@ -949,14 +937,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn def_key(&mut self, id: DefId) -> DefKey {\n-        if id.is_local() {\n-            self.resolver.definitions().def_key(id.index)\n-        } else {\n-            self.resolver.cstore().def_key(id)\n-        }\n-    }\n-\n     fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n         self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n     }\n@@ -1635,403 +1615,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_qpath(\n-        &mut self,\n-        id: NodeId,\n-        qself: &Option<QSelf>,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::QPath<'hir> {\n-        let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n-\n-        let partial_res =\n-            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n-\n-        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n-        let path = self.arena.alloc(hir::Path {\n-            res: self.lower_res(partial_res.base_res()),\n-            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n-                |(i, segment)| {\n-                    let param_mode = match (qself_position, param_mode) {\n-                        (Some(j), ParamMode::Optional) if i < j => {\n-                            // This segment is part of the trait path in a\n-                            // qualified path - one of `a`, `b` or `Trait`\n-                            // in `<X as a::b::Trait>::T::U::method`.\n-                            ParamMode::Explicit\n-                        }\n-                        _ => param_mode,\n-                    };\n-\n-                    // Figure out if this is a type/trait segment,\n-                    // which may need lifetime elision performed.\n-                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n-                        krate: def_id.krate,\n-                        index: this.def_key(def_id).parent.expect(\"missing parent\"),\n-                    };\n-                    let type_def_id = match partial_res.base_res() {\n-                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Struct, def_id)\n-                        | Res::Def(DefKind::Union, def_id)\n-                        | Res::Def(DefKind::Enum, def_id)\n-                        | Res::Def(DefKind::TyAlias, def_id)\n-                        | Res::Def(DefKind::Trait, def_id)\n-                            if i + 1 == proj_start =>\n-                        {\n-                            Some(def_id)\n-                        }\n-                        _ => None,\n-                    };\n-                    let parenthesized_generic_args = match partial_res.base_res() {\n-                        // `a::b::Trait(Args)`\n-                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // `a::b::Trait(Args)::TraitItem`\n-                        Res::Def(DefKind::Method, _)\n-                        | Res::Def(DefKind::AssocConst, _)\n-                        | Res::Def(DefKind::AssocTy, _)\n-                            if i + 2 == proj_start =>\n-                        {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // Avoid duplicated errors.\n-                        Res::Err => ParenthesizedGenericArgs::Ok,\n-                        // An error\n-                        _ => ParenthesizedGenericArgs::Err,\n-                    };\n-\n-                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n-                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n-                            return n;\n-                        }\n-                        assert!(!def_id.is_local());\n-                        let item_generics = self\n-                            .resolver\n-                            .cstore()\n-                            .item_generics_cloned_untracked(def_id, self.sess);\n-                        let n = item_generics.own_counts().lifetimes;\n-                        self.type_def_lifetime_params.insert(def_id, n);\n-                        n\n-                    });\n-                    self.lower_path_segment(\n-                        p.span,\n-                        segment,\n-                        param_mode,\n-                        num_lifetimes,\n-                        parenthesized_generic_args,\n-                        itctx.reborrow(),\n-                        None,\n-                    )\n-                },\n-            )),\n-            span: p.span,\n-        });\n-\n-        // Simple case, either no projections, or only fully-qualified.\n-        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if partial_res.unresolved_segments() == 0 {\n-            return hir::QPath::Resolved(qself, path);\n-        }\n-\n-        // Create the innermost type that we're projecting from.\n-        let mut ty = if path.segments.is_empty() {\n-            // If the base path is empty that means there exists a\n-            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n-            qself.expect(\"missing QSelf for <T>::...\")\n-        } else {\n-            // Otherwise, the base path is an implicit `Self` type path,\n-            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n-            // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n-            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n-        };\n-\n-        // Anything after the base path are associated \"extensions\",\n-        // out of which all but the last one are associated types,\n-        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n-        // * base path is `std::vec::Vec<T>`\n-        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n-        // * type nodes are:\n-        //   1. `std::vec::Vec<T>` (created above)\n-        //   2. `<std::vec::Vec<T>>::IntoIter`\n-        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n-        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n-        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = self.arena.alloc(self.lower_path_segment(\n-                p.span,\n-                segment,\n-                param_mode,\n-                0,\n-                ParenthesizedGenericArgs::Err,\n-                itctx.reborrow(),\n-                None,\n-            ));\n-            let qpath = hir::QPath::TypeRelative(ty, segment);\n-\n-            // It's finished, return the extension of the right node type.\n-            if i == p.segments.len() - 1 {\n-                return qpath;\n-            }\n-\n-            // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n-            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n-        }\n-\n-        // We should've returned in the for loop above.\n-        span_bug!(\n-            p.span,\n-            \"lower_qpath: no final extension segment in {}..{}\",\n-            proj_start,\n-            p.segments.len()\n-        )\n-    }\n-\n-    fn lower_path_extra(\n-        &mut self,\n-        res: Res,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        explicit_owner: Option<NodeId>,\n-    ) -> &'hir hir::Path<'hir> {\n-        self.arena.alloc(hir::Path {\n-            res,\n-            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n-                self.lower_path_segment(\n-                    p.span,\n-                    segment,\n-                    param_mode,\n-                    0,\n-                    ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::disallowed(),\n-                    explicit_owner,\n-                )\n-            })),\n-            span: p.span,\n-        })\n-    }\n-\n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> &'hir hir::Path<'hir> {\n-        let res = self.expect_full_res(id);\n-        let res = self.lower_res(res);\n-        self.lower_path_extra(res, p, param_mode, None)\n-    }\n-\n-    fn lower_path_segment(\n-        &mut self,\n-        path_span: Span,\n-        segment: &PathSegment,\n-        param_mode: ParamMode,\n-        expected_lifetimes: usize,\n-        parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_, 'hir>,\n-        explicit_owner: Option<NodeId>,\n-    ) -> hir::PathSegment<'hir> {\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n-                }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n-                    ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n-                            // Do not suggest going from `Trait()` to `Trait<>`\n-                            if data.inputs.len() > 0 {\n-                                if let Some(split) = snippet.find('(') {\n-                                    let trait_name = &snippet[0..split];\n-                                    let args = &snippet[split + 1..snippet.len() - 1];\n-                                    err.span_suggestion(\n-                                        data.span,\n-                                        \"use angle brackets instead\",\n-                                        format!(\"{}<{}>\", trait_name, args),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        };\n-                        err.emit();\n-                        (\n-                            self.lower_angle_bracketed_parameter_data(\n-                                &data.as_angle_bracketed_args(),\n-                                param_mode,\n-                                itctx,\n-                            )\n-                            .0,\n-                            false,\n-                        )\n-                    }\n-                },\n-            }\n-        } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n-        };\n-\n-        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n-            GenericArg::Lifetime(_) => true,\n-            _ => false,\n-        });\n-        let first_generic_span = generic_args\n-            .args\n-            .iter()\n-            .map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span))\n-            .next();\n-        if !generic_args.parenthesized && !has_lifetimes {\n-            generic_args.args = self\n-                .elided_path_lifetimes(path_span, expected_lifetimes)\n-                .map(|lt| GenericArg::Lifetime(lt))\n-                .chain(generic_args.args.into_iter())\n-                .collect();\n-            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n-                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n-                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n-                let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated type\n-                    // bindings, our suggestion includes the angle brackets.\n-                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n-                } else {\n-                    // Otherwise (sorry, this is kind of gross) we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist.\n-                    let first_generic_span = first_generic_span\n-                        .expect(\"already checked that non-lifetime args or bindings exist\");\n-                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n-                };\n-                match self.anonymous_lifetime_mode {\n-                    // In create-parameter mode we error here because we don't want to support\n-                    // deprecated impl elision in new features like impl elision and `async fn`,\n-                    // both of which work using the `CreateParameter` mode:\n-                    //\n-                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    AnonymousLifetimeMode::CreateParameter => {\n-                        let mut err = struct_span_err!(\n-                            self.sess,\n-                            path_span,\n-                            E0726,\n-                            \"implicit elided lifetime not allowed here\"\n-                        );\n-                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n-                            &self.sess,\n-                            &mut err,\n-                            expected_lifetimes,\n-                            path_span,\n-                            incl_angl_brckt,\n-                            insertion_sp,\n-                            suggestion,\n-                        );\n-                        err.emit();\n-                    }\n-                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n-                            ELIDED_LIFETIMES_IN_PATHS,\n-                            CRATE_NODE_ID,\n-                            path_span,\n-                            \"hidden lifetime parameters in types are deprecated\",\n-                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                                expected_lifetimes,\n-                                path_span,\n-                                incl_angl_brckt,\n-                                insertion_sp,\n-                                suggestion,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        let res = self.expect_full_res(segment.id);\n-        let id = if let Some(owner) = explicit_owner {\n-            self.lower_node_id_with_owner(segment.id, owner)\n-        } else {\n-            self.lower_node_id(segment.id)\n-        };\n-        debug!(\n-            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n-            segment.ident, segment.id, id,\n-        );\n-\n-        hir::PathSegment {\n-            ident: segment.ident,\n-            hir_id: Some(id),\n-            res: Some(self.lower_res(res)),\n-            infer_args,\n-            args: if generic_args.is_empty() {\n-                None\n-            } else {\n-                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n-            },\n-        }\n-    }\n-\n-    fn lower_angle_bracketed_parameter_data(\n-        &mut self,\n-        data: &AngleBracketedArgs,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_non_lt_args = args.iter().any(|arg| match arg {\n-            ast::GenericArg::Lifetime(_) => false,\n-            ast::GenericArg::Type(_) => true,\n-            ast::GenericArg::Const(_) => true,\n-        });\n-        (\n-            GenericArgsCtor {\n-                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: self.arena.alloc_from_iter(\n-                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n-                ),\n-                parenthesized: false,\n-            },\n-            !has_non_lt_args && param_mode == ParamMode::Optional,\n-        )\n-    }\n-\n-    fn lower_parenthesized_parameter_data(\n-        &mut self,\n-        data: &ParenthesizedArgs,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        // Switch to `PassThrough` mode for anonymous lifetimes; this\n-        // means that we permit things like `&Ref<T>`, where `Ref` has\n-        // a hidden lifetime parameter. This is needed for backwards\n-        // compatibility, even in contexts like an impl header where\n-        // we generally don't permit such things (see #51008).\n-        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-            let inputs = this.arena.alloc_from_iter(\n-                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n-            );\n-            let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n-            let binding = hir::TypeBinding {\n-                hir_id: this.next_id(),\n-                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                span: output_ty.span,\n-                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-            };\n-            (\n-                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n-                false,\n-            )\n-        })\n-    }\n-\n     fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n         let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -2387,12 +1970,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // \"<Output = T>\"\n         let future_params = self.arena.alloc(hir::GenericArgs {\n             args: &[],\n-            bindings: arena_vec![self; hir::TypeBinding {\n-                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-                hir_id: self.next_id(),\n-                span,\n-            }],\n+            bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n         });\n \n@@ -2652,250 +2230,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        let node = match p.kind {\n-            PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                node\n-            }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-            PatKind::TupleStruct(ref path, ref pats) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-            }\n-            PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n-            }\n-            PatKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::PatKind::Path(qpath)\n-            }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-\n-                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                    hir_id: self.next_id(),\n-                    ident: f.ident,\n-                    pat: self.lower_pat(&f.pat),\n-                    is_shorthand: f.is_shorthand,\n-                    span: f.span,\n-                }));\n-                hir::PatKind::Struct(qpath, fs, etc)\n-            }\n-            PatKind::Tuple(ref pats) => {\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                hir::PatKind::Tuple(pats, ddpos)\n-            }\n-            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                self.lower_expr(e1),\n-                self.lower_expr(e2),\n-                self.lower_range_end(end),\n-            ),\n-            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-            PatKind::Rest => {\n-                // If we reach here the `..` pattern is not semantically allowed.\n-                self.ban_illegal_rest_pat(p.span)\n-            }\n-            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-        };\n-\n-        self.pat_with_node_id_of(p, node)\n-    }\n-\n-    fn lower_pat_tuple(\n-        &mut self,\n-        pats: &[AstP<Pat>],\n-        ctx: &str,\n-    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n-        let mut elems = Vec::with_capacity(pats.len());\n-        let mut rest = None;\n-\n-        let mut iter = pats.iter().enumerate();\n-        for (idx, pat) in iter.by_ref() {\n-            // Interpret the first `..` pattern as a sub-tuple pattern.\n-            // Note that unlike for slice patterns,\n-            // where `xs @ ..` is a legal sub-slice pattern,\n-            // it is not a legal sub-tuple pattern.\n-            if pat.is_rest() {\n-                rest = Some((idx, pat.span));\n-                break;\n-            }\n-            // It was not a sub-tuple pattern so lower it normally.\n-            elems.push(self.lower_pat(pat));\n-        }\n-\n-        for (_, pat) in iter {\n-            // There was a previous sub-tuple pattern; make sure we don't allow more...\n-            if pat.is_rest() {\n-                // ...but there was one again, so error.\n-                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n-            } else {\n-                elems.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n-    }\n-\n-    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n-    /// `hir::PatKind::Slice(before, slice, after)`.\n-    ///\n-    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n-    /// this is interpreted as a sub-slice pattern semantically.\n-    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n-    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind<'hir> {\n-        let mut before = Vec::new();\n-        let mut after = Vec::new();\n-        let mut slice = None;\n-        let mut prev_rest_span = None;\n-\n-        let mut iter = pats.iter();\n-        // Lower all the patterns until the first occurence of a sub-slice pattern.\n-        for pat in iter.by_ref() {\n-            match pat.kind {\n-                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n-                PatKind::Rest => {\n-                    prev_rest_span = Some(pat.span);\n-                    slice = Some(self.pat_wild_with_node_id_of(pat));\n-                    break;\n-                }\n-                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n-                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n-                    prev_rest_span = Some(sub.span);\n-                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n-                    slice = Some(self.pat_with_node_id_of(pat, node));\n-                    break;\n-                }\n-                // It was not a subslice pattern so lower it normally.\n-                _ => before.push(self.lower_pat(pat)),\n-            }\n-        }\n-\n-        // Lower all the patterns after the first sub-slice pattern.\n-        for pat in iter {\n-            // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n-                PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n-                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n-                    after.push(self.pat_wild_with_node_id_of(pat));\n-                    Some(sub.span)\n-                }\n-                _ => None,\n-            };\n-            if let Some(rest_span) = rest_span {\n-                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n-                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n-            } else {\n-                // Lower the pattern normally.\n-                after.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        hir::PatKind::Slice(\n-            self.arena.alloc_from_iter(before),\n-            slice,\n-            self.arena.alloc_from_iter(after),\n-        )\n-    }\n-\n-    fn lower_pat_ident(\n-        &mut self,\n-        p: &Pat,\n-        binding_mode: &BindingMode,\n-        ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n-    ) -> hir::PatKind<'hir> {\n-        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n-            // `None` can occur in body-less function signatures\n-            res @ None | res @ Some(Res::Local(_)) => {\n-                let canonical_id = match res {\n-                    Some(Res::Local(id)) => id,\n-                    _ => p.id,\n-                };\n-\n-                hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n-                    self.lower_node_id(canonical_id),\n-                    ident,\n-                    lower_sub(self),\n-                )\n-            }\n-            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                self.arena.alloc(hir::Path {\n-                    span: ident.span,\n-                    res: self.lower_res(res),\n-                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n-                }),\n-            )),\n-        }\n-    }\n-\n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n-    }\n-\n-    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n-    }\n-\n-    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n-    }\n-\n-    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n-    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n-\n-        // We're not in a list context so `..` can be reasonably treated\n-        // as `_` because it should always be valid and roughly matches the\n-        // intent of `..` (notice that the rest of a single slot is that slot).\n-        hir::PatKind::Wild\n-    }\n-\n-    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n-        match *e {\n-            RangeEnd::Included(_) => hir::RangeEnd::Included,\n-            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n-        }\n-    }\n-\n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n         self.with_new_scopes(|this| hir::AnonConst {\n             hir_id: this.lower_node_id(c.id),\n@@ -2955,15 +2289,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n-        match *b {\n-            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n-        }\n-    }\n-\n     fn lower_unsafe_source(&mut self, u: UnsafeSource) -> hir::UnsafeSource {\n         match u {\n             CompilerGenerated => hir::UnsafeSource::CompilerGenerated,"}, {"sha": "cd69646d0c53ae57e9d7ec023fa53da53b8541fe", "filename": "src/librustc_ast_lowering/pat.rs", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -0,0 +1,262 @@\n+use super::{ImplTraitContext, LoweringContext, ParamMode};\n+\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_span::{source_map::Spanned, Span};\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        let node = match p.kind {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                node\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+            PatKind::TupleStruct(ref path, ref pats) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n+            }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    qself,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                hir::PatKind::Path(qpath)\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+\n+                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                    hir_id: self.next_id(),\n+                    ident: f.ident,\n+                    pat: self.lower_pat(&f.pat),\n+                    is_shorthand: f.is_shorthand,\n+                    span: f.span,\n+                }));\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref pats) => {\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                hir::PatKind::Tuple(pats, ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n+            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n+                self.lower_expr(e1),\n+                self.lower_expr(e2),\n+                self.lower_range_end(end),\n+            ),\n+            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+            PatKind::Rest => {\n+                // If we reach here the `..` pattern is not semantically allowed.\n+                self.ban_illegal_rest_pat(p.span)\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n+\n+        self.pat_with_node_id_of(p, node)\n+    }\n+\n+    fn lower_pat_tuple(\n+        &mut self,\n+        pats: &[P<Pat>],\n+        ctx: &str,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n+        let mut elems = Vec::with_capacity(pats.len());\n+        let mut rest = None;\n+\n+        let mut iter = pats.iter().enumerate();\n+        for (idx, pat) in iter.by_ref() {\n+            // Interpret the first `..` pattern as a sub-tuple pattern.\n+            // Note that unlike for slice patterns,\n+            // where `xs @ ..` is a legal sub-slice pattern,\n+            // it is not a legal sub-tuple pattern.\n+            if pat.is_rest() {\n+                rest = Some((idx, pat.span));\n+                break;\n+            }\n+            // It was not a sub-tuple pattern so lower it normally.\n+            elems.push(self.lower_pat(pat));\n+        }\n+\n+        for (_, pat) in iter {\n+            // There was a previous sub-tuple pattern; make sure we don't allow more...\n+            if pat.is_rest() {\n+                // ...but there was one again, so error.\n+                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n+            } else {\n+                elems.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n+    }\n+\n+    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n+    /// `hir::PatKind::Slice(before, slice, after)`.\n+    ///\n+    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n+    /// this is interpreted as a sub-slice pattern semantically.\n+    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n+    fn lower_pat_slice(&mut self, pats: &[P<Pat>]) -> hir::PatKind<'hir> {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        let mut iter = pats.iter();\n+        // Lower all the patterns until the first occurence of a sub-slice pattern.\n+        for pat in iter.by_ref() {\n+            match pat.kind {\n+                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_wild_with_node_id_of(pat));\n+                    break;\n+                }\n+                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n+                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n+                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    break;\n+                }\n+                // It was not a subslice pattern so lower it normally.\n+                _ => before.push(self.lower_pat(pat)),\n+            }\n+        }\n+\n+        // Lower all the patterns after the first sub-slice pattern.\n+        for pat in iter {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.kind {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n+                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n+                    after.push(self.pat_wild_with_node_id_of(pat));\n+                    Some(sub.span)\n+                }\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                // Lower the pattern normally.\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n+    ) -> hir::PatKind<'hir> {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ None | res @ Some(Res::Local(_)) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                self.arena.alloc(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n+        match *b {\n+            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n+        }\n+    }\n+\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    }\n+\n+    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n+    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+        self.diagnostic()\n+            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n+            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n+            .span_label(prev_sp, \"previously used here\")\n+            .emit();\n+    }\n+\n+    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n+        self.diagnostic()\n+            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n+            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n+            .emit();\n+\n+        // We're not in a list context so `..` can be reasonably treated\n+        // as `_` because it should always be valid and roughly matches the\n+        // intent of `..` (notice that the rest of a single slot is that slot).\n+        hir::PatKind::Wild\n+    }\n+\n+    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n+        match *e {\n+            RangeEnd::Included(_) => hir::RangeEnd::Included,\n+            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n+        }\n+    }\n+}"}, {"sha": "9b504704ae06ca6103d7535b63d39400fc8fdebd", "filename": "src/librustc_ast_lowering/path.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -0,0 +1,422 @@\n+use super::{AnonymousLifetimeMode, ImplTraitContext, LoweringContext, ParamMode};\n+use super::{GenericArgsCtor, ParenthesizedGenericArgs};\n+\n+use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n+use rustc::span_bug;\n+use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, PartialRes, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::GenericArg;\n+use rustc_span::Span;\n+use syntax::ast::{self, *};\n+\n+use log::debug;\n+use smallvec::smallvec;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: &Option<QSelf>,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::QPath<'hir> {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n+\n+        let partial_res =\n+            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let path = self.arena.alloc(hir::Path {\n+            res: self.lower_res(partial_res.base_res()),\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n+                    let param_mode = match (qself_position, param_mode) {\n+                        (Some(j), ParamMode::Optional) if i < j => {\n+                            // This segment is part of the trait path in a\n+                            // qualified path - one of `a`, `b` or `Trait`\n+                            // in `<X as a::b::Trait>::T::U::method`.\n+                            ParamMode::Explicit\n+                        }\n+                        _ => param_mode,\n+                    };\n+\n+                    // Figure out if this is a type/trait segment,\n+                    // which may need lifetime elision performed.\n+                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n+                        krate: def_id.krate,\n+                        index: this.resolver.def_key(def_id).parent.expect(\"missing parent\"),\n+                    };\n+                    let type_def_id = match partial_res.base_res() {\n+                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Struct, def_id)\n+                        | Res::Def(DefKind::Union, def_id)\n+                        | Res::Def(DefKind::Enum, def_id)\n+                        | Res::Def(DefKind::TyAlias, def_id)\n+                        | Res::Def(DefKind::Trait, def_id)\n+                            if i + 1 == proj_start =>\n+                        {\n+                            Some(def_id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n+                        // `a::b::Trait(Args)`\n+                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // `a::b::Trait(Args)::TraitItem`\n+                        Res::Def(DefKind::Method, _)\n+                        | Res::Def(DefKind::AssocConst, _)\n+                        | Res::Def(DefKind::AssocTy, _)\n+                            if i + 2 == proj_start =>\n+                        {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // Avoid duplicated errors.\n+                        Res::Err => ParenthesizedGenericArgs::Ok,\n+                        // An error\n+                        _ => ParenthesizedGenericArgs::Err,\n+                    };\n+\n+                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                            return n;\n+                        }\n+                        assert!(!def_id.is_local());\n+                        let n = self.resolver.item_generics_num_lifetimes(def_id, self.sess);\n+                        self.type_def_lifetime_params.insert(def_id, n);\n+                        n\n+                    });\n+                    self.lower_path_segment(\n+                        p.span,\n+                        segment,\n+                        param_mode,\n+                        num_lifetimes,\n+                        parenthesized_generic_args,\n+                        itctx.reborrow(),\n+                        None,\n+                    )\n+                },\n+            )),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if partial_res.unresolved_segments() == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let new_id = self.next_id();\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = self.arena.alloc(self.lower_path_segment(\n+                p.span,\n+                segment,\n+                param_mode,\n+                0,\n+                ParenthesizedGenericArgs::Err,\n+                itctx.reborrow(),\n+                None,\n+            ));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            let new_id = self.next_id();\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n+        }\n+\n+        // We should've returned in the for loop above.\n+        span_bug!(\n+            p.span,\n+            \"lower_qpath: no final extension segment in {}..{}\",\n+            proj_start,\n+            p.segments.len()\n+        )\n+    }\n+\n+    crate fn lower_path_extra(\n+        &mut self,\n+        res: Res,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        explicit_owner: Option<NodeId>,\n+    ) -> &'hir hir::Path<'hir> {\n+        self.arena.alloc(hir::Path {\n+            res,\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n+            span: p.span,\n+        })\n+    }\n+\n+    crate fn lower_path(\n+        &mut self,\n+        id: NodeId,\n+        p: &Path,\n+        param_mode: ParamMode,\n+    ) -> &'hir hir::Path<'hir> {\n+        let res = self.expect_full_res(id);\n+        let res = self.lower_res(res);\n+        self.lower_path_extra(res, p, param_mode, None)\n+    }\n+\n+    crate fn lower_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        segment: &PathSegment,\n+        param_mode: ParamMode,\n+        expected_lifetimes: usize,\n+        parenthesized_generic_args: ParenthesizedGenericArgs,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::PathSegment<'hir> {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n+            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n+            match **generic_args {\n+                GenericArgs::AngleBracketed(ref data) => {\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n+                }\n+                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Err => {\n+                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n+                            // Do not suggest going from `Trait()` to `Trait<>`\n+                            if data.inputs.len() > 0 {\n+                                if let Some(split) = snippet.find('(') {\n+                                    let trait_name = &snippet[0..split];\n+                                    let args = &snippet[split + 1..snippet.len() - 1];\n+                                    err.span_suggestion(\n+                                        data.span,\n+                                        \"use angle brackets instead\",\n+                                        format!(\"{}<{}>\", trait_name, args),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        };\n+                        err.emit();\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx,\n+                            )\n+                            .0,\n+                            false,\n+                        )\n+                    }\n+                },\n+            }\n+        } else {\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+        };\n+\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        let first_generic_span = generic_args\n+            .args\n+            .iter()\n+            .map(|a| a.span())\n+            .chain(generic_args.bindings.iter().map(|b| b.span))\n+            .next();\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            generic_args.args = self\n+                .elided_path_lifetimes(path_span, expected_lifetimes)\n+                .map(|lt| GenericArg::Lifetime(lt))\n+                .chain(generic_args.args.into_iter())\n+                .collect();\n+            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n+                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n+                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n+                let no_bindings = generic_args.bindings.is_empty();\n+                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n+                    // If there are no (non-implicit) generic args or associated type\n+                    // bindings, our suggestion includes the angle brackets.\n+                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n+                } else {\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n+                    // place to splice in the `'_, ` from the generics that do exist.\n+                    let first_generic_span = first_generic_span\n+                        .expect(\"already checked that non-lifetime args or bindings exist\");\n+                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                };\n+                match self.anonymous_lifetime_mode {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess,\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            incl_angl_brckt,\n+                            insertion_sp,\n+                            suggestion,\n+                        );\n+                        err.emit();\n+                    }\n+                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n+                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n+                            ELIDED_LIFETIMES_IN_PATHS,\n+                            CRATE_NODE_ID,\n+                            path_span,\n+                            \"hidden lifetime parameters in types are deprecated\",\n+                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                                expected_lifetimes,\n+                                path_span,\n+                                incl_angl_brckt,\n+                                insertion_sp,\n+                                suggestion,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        let res = self.expect_full_res(segment.id);\n+        let id = if let Some(owner) = explicit_owner {\n+            self.lower_node_id_with_owner(segment.id, owner)\n+        } else {\n+            self.lower_node_id(segment.id)\n+        };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n+\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n+            infer_args,\n+            args: if generic_args.is_empty() {\n+                None\n+            } else {\n+                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n+            },\n+        }\n+    }\n+\n+    fn lower_angle_bracketed_parameter_data(\n+        &mut self,\n+        data: &AngleBracketedArgs,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n+        let has_non_lt_args = args.iter().any(|arg| match arg {\n+            ast::GenericArg::Lifetime(_) => false,\n+            ast::GenericArg::Type(_) => true,\n+            ast::GenericArg::Const(_) => true,\n+        });\n+        (\n+            GenericArgsCtor {\n+                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n+                bindings: self.arena.alloc_from_iter(\n+                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n+                ),\n+                parenthesized: false,\n+            },\n+            !has_non_lt_args && param_mode == ParamMode::Optional,\n+        )\n+    }\n+\n+    fn lower_parenthesized_parameter_data(\n+        &mut self,\n+        data: &ParenthesizedArgs,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n+        // means that we permit things like `&Ref<T>`, where `Ref` has\n+        // a hidden lifetime parameter. This is needed for backwards\n+        // compatibility, even in contexts like an impl header where\n+        // we generally don't permit such things (see #51008).\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n+            };\n+            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let binding = this.output_ty_binding(output_ty.span, output_ty);\n+            (\n+                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n+        })\n+    }\n+\n+    /// An associated type binding `Output = $ty`.\n+    crate fn output_ty_binding(\n+        &mut self,\n+        span: Span,\n+        ty: &'hir hir::Ty<'hir>,\n+    ) -> hir::TypeBinding<'hir> {\n+        let ident = Ident::with_dummy_span(hir::FN_OUTPUT_NAME);\n+        let kind = hir::TypeBindingKind::Equality { ty };\n+        hir::TypeBinding { hir_id: self.next_id(), span, ident, kind }\n+    }\n+}"}, {"sha": "26b90ebfd5f117076cd4a99d4f1c772e0e1a8e5d", "filename": "src/librustc_data_structures/captures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_data_structures%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_data_structures%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcaptures.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "previous_filename": "src/librustc/util/captures.rs"}, {"sha": "51a38a7d2ab9ce84a82f0b37d5faf8034a2bbb5e", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -67,6 +67,7 @@ macro_rules! unlikely {\n pub mod base_n;\n pub mod binary_search_util;\n pub mod box_region;\n+pub mod captures;\n pub mod const_cstr;\n pub mod flock;\n pub mod fx;"}, {"sha": "603c21188e3ac03173643cf5da5f18b91ce32330", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -1875,6 +1875,9 @@ pub enum ImplItemKind<'hir> {\n     OpaqueTy(GenericBounds<'hir>),\n }\n \n+// The name of the associated type for `Fn` return types.\n+pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n+\n /// Bind a type to an associated type (i.e., `A = Foo`).\n ///\n /// Bindings like `A: Debug` are represented as a special type `A ="}, {"sha": "30d049d143eabc576d5ea4af9f3399bd36019565", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -12,8 +12,7 @@ use rustc::session::{CrateDisambiguator, Session};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::CrateNum;\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n "}, {"sha": "f5a05751f4c407aa08b383db883e53ca5ffb0505", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -16,8 +16,8 @@ use rustc::mir::{self, interpret, BodyAndCache, Promoted};\n use rustc::session::Session;\n use rustc::ty::codec::TyDecoder;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::captures::Captures;\n use rustc::util::common::record_time;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;"}, {"sha": "eb5754bf99bfbcec0f808bb05be51f5694b6119c", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -478,17 +478,17 @@ impl CStore {\n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n         self.get_crate_data(cnum).source.clone()\n     }\n+\n+    pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n+        self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n+    }\n }\n \n impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n \n-    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n-        self.get_crate_data(def.krate).get_generics(def.index, sess)\n-    }\n-\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name\n     }"}, {"sha": "2bf1efd4441e90e99d79bea3a45f7f5fc69e6cf3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -229,6 +229,7 @@ use self::SliceKind::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n@@ -243,7 +244,6 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc::lint;\n use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc::mir::Field;\n-use rustc::util::captures::Captures;\n use rustc::util::common::ErrorReported;\n \n use rustc_span::{Span, DUMMY_SP};"}, {"sha": "9e4486e16f2ccb0a716ce8c7570f7b6c54e220da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -22,7 +22,7 @@ use Determinacy::*;\n \n use errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc::hir::exports::ExportMap;\n-use rustc::hir::map::Definitions;\n+use rustc::hir::map::{DefKey, Definitions};\n use rustc::lint;\n use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc::session::Session;\n@@ -1027,8 +1027,12 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl rustc_ast_lowering::Resolver for Resolver<'_> {\n-    fn cstore(&self) -> &dyn CrateStore {\n-        self.cstore()\n+    fn def_key(&mut self, id: DefId) -> DefKey {\n+        if id.is_local() { self.definitions().def_key(id.index) } else { self.cstore().def_key(id) }\n+    }\n+\n+    fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n+        self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n     fn resolve_str_path("}, {"sha": "5e73f8e3e128f0f03a24a07c8024f41977ae8e32", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -114,6 +114,7 @@ use rustc::ty::{\n     self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n     ToPredicate, Ty, TyCtxt, UserType,\n };\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -146,7 +147,6 @@ use crate::lint;\n use crate::require_c_abi_if_c_variadic;\n use crate::session::config::EntryFnType;\n use crate::session::Session;\n-use crate::util::captures::Captures;\n use crate::util::common::{indenter, ErrorReported};\n use crate::TypeAndSubsts;\n "}, {"sha": "3ec09e5f19af55dcd552206f206ff1ca0eb0117b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfa28c3a8e09364207c4f5c437c8e73dac67716/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3bfa28c3a8e09364207c4f5c437c8e73dac67716", "patch": "@@ -32,7 +32,7 @@ use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate};\n-use rustc::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};"}]}