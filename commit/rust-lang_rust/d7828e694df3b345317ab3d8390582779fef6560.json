{"sha": "d7828e694df3b345317ab3d8390582779fef6560", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ODI4ZTY5NGRmM2IzNDUzMTdhYjNkODM5MDU4Mjc3OWZlZjY1NjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-06T00:50:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-06T00:50:59Z"}, "message": "rt: Uncomment data<T>", "tree": {"sha": "e90810cc44179ad4033fcc283ea59a2ea9d82691", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e90810cc44179ad4033fcc283ea59a2ea9d82691"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7828e694df3b345317ab3d8390582779fef6560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7828e694df3b345317ab3d8390582779fef6560", "html_url": "https://github.com/rust-lang/rust/commit/d7828e694df3b345317ab3d8390582779fef6560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7828e694df3b345317ab3d8390582779fef6560/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50670eb4267b165441b8cb36739a636887cc683c", "url": "https://api.github.com/repos/rust-lang/rust/commits/50670eb4267b165441b8cb36739a636887cc683c", "html_url": "https://github.com/rust-lang/rust/commit/50670eb4267b165441b8cb36739a636887cc683c"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "e33d70913f20bfa94f2ff031ca5ec03976cf73e0", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d7828e694df3b345317ab3d8390582779fef6560/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d7828e694df3b345317ab3d8390582779fef6560/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=d7828e694df3b345317ab3d8390582779fef6560", "patch": "@@ -577,9 +577,16 @@ class size_of : public ctxt<size_of> {\n \n public:\n     size_of(const size_of &other,\n-            const uint8_t *in_sp,\n-            const type_param *in_params,\n-            const rust_shape_tables *in_tables)\n+            const uint8_t *in_sp = NULL,\n+            const type_param *in_params = NULL,\n+            const rust_shape_tables *in_tables = NULL)\n+    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n+\n+    template<typename T>\n+    size_of(const ctxt<T> &other,\n+            const uint8_t *in_sp = NULL,\n+            const type_param *in_params = NULL,\n+            const rust_shape_tables *in_tables = NULL)\n     : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n \n     void walk_tag(bool align, tag_info &tinfo);\n@@ -612,25 +619,31 @@ class size_of : public ctxt<size_of> {\n     template<typename T>\n     void walk_number(bool align) { sa.set(sizeof(T), ALIGNOF(T)); }\n \n+    void compute_tag_size(tag_info &tinfo);\n+\n+    template<typename T>\n+    static void compute_tag_size(const ctxt<T> &other_cx, tag_info &tinfo) {\n+        size_of cx(other_cx);\n+        cx.compute_tag_size(tinfo);\n+    }\n+\n     template<typename T>\n     static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n-        size_of cx(*other_cx, other_cx->sp - back_up);\n+        size_of cx(other_cx, other_cx->sp - back_up);\n         cx.walk(false);\n         assert(cx.sa.alignment > 0);\n         return cx.sa;\n     }\n };\n \n void\n-size_of::walk_tag(bool align, tag_info &tinfo) {\n+size_of::compute_tag_size(tag_info &tinfo) {\n     // If the precalculated size and alignment are good, use them.\n-    if (tinfo.tag_sa.is_set()) {\n-        sa = tinfo.tag_sa;\n+    if (tinfo.tag_sa.is_set())\n         return;\n-    }\n \n     uint16_t n_largest_variants = get_u16_bump(tinfo.largest_variants_ptr);\n-    sa.set(0, 0);\n+    tinfo.tag_sa.set(0, 0);\n     for (uint16_t i = 0; i < n_largest_variants; i++) {\n         uint16_t variant_id = get_u16_bump(tinfo.largest_variants_ptr);\n         uint16_t variant_offset = get_u16(tinfo.info_ptr +\n@@ -654,19 +667,25 @@ size_of::walk_tag(bool align, tag_info &tinfo) {\n             variant_sa.add(sub.sa.size, sub.sa.alignment);\n         }\n \n-        if (sa.size < variant_sa.size)\n-            sa = variant_sa;\n+        if (tinfo.tag_sa.size < variant_sa.size)\n+            tinfo.tag_sa = variant_sa;\n     }\n \n     if (tinfo.variant_count == 1) {\n-        if (!sa.size)\n-            sa.set(1, 1);\n+        if (!tinfo.tag_sa.size)\n+            tinfo.tag_sa.set(1, 1);\n     } else {\n         // Add in space for the tag.\n-        sa.add(sizeof(uint32_t), ALIGNOF(uint32_t));\n+        tinfo.tag_sa.add(sizeof(uint32_t), ALIGNOF(uint32_t));\n     }\n }\n \n+void\n+size_of::walk_tag(bool align, tag_info &tinfo) {\n+    compute_tag_size(*this, tinfo);\n+    sa = tinfo.tag_sa;\n+}\n+\n void\n size_of::walk_struct(bool align, const uint8_t *end_sp) {\n     size_align struct_sa(0, 1);\n@@ -696,32 +715,27 @@ size_of::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n }\n \n \n-#if 0\n-\n // An abstract class (again using the curiously recurring template pattern)\n // for methods that actually manipulate the data involved.\n \n #define DATA_SIMPLE(ty, call) \\\n-    if (align) dp.align(sizeof(ty)); \\\n+    if (align) dp.align_to(sizeof(ty)); \\\n     static_cast<T *>(this)->call; \\\n     dp += sizeof(ty);\n \n-template<typename T,typename U>\n-class data : public ctxt<data> {\n+template<typename T>\n+class data : public ctxt< data<T> > {\n private:\n-    U dp;\n+    typename T::data_ptr dp;\n \n public:\n-    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n-                  size_align &tag_sa, uint16_t n_params,\n-                  const type_param *params);\n+    void walk_tag(bool align, tag_info &tinfo);\n     void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n \n     void walk_struct(bool align, const uint8_t *end_sp) {\n-        while (sp != end_sp) {\n+        while (this->sp != end_sp) {\n             // TODO: Allow subclasses to optimize for POD if they want to.\n-            walk(align);\n+            this->walk(align);\n             align = true;\n         }\n     }\n@@ -736,14 +750,14 @@ class data : public ctxt<data> {\n     void walk_task(bool align)  { DATA_SIMPLE(void *, walk_task(align)); }\n \n     void walk_fn(bool align) {\n-        if (align) dp.align(sizeof(void *));\n-        static_cast<T *>(this)->walk_fn(args);\n+        if (align) dp.align_to(sizeof(void *));\n+        static_cast<T *>(this)->walk_fn(align);\n         dp += sizeof(void *) * 2;\n     }\n \n     void walk_obj(bool align) {\n-        if (align) dp.align(sizeof(void *));\n-        static_cast<T *>(this)->walk_obj(args);\n+        if (align) dp.align_to(sizeof(void *));\n+        static_cast<T *>(this)->walk_obj(align);\n         dp += sizeof(void *) * 2;\n     }\n \n@@ -757,46 +771,54 @@ class data : public ctxt<data> {\n     }\n };\n \n-template<typename T,typename U>\n+template<typename T>\n void\n-data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+data<T>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n     if (!elem_sa.is_set())\n         elem_sa = size_of::get(*this);\n     else if (elem_sa.alignment == 8)\n         elem_sa.alignment = 4;  // FIXME: This is an awful hack.\n \n     // Get a pointer to the interior vector, and skip over it.\n-    if (align) dp.align(ALIGNOF(rust_ivec *));\n-    U end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) + elem_sa.size * 4;\n+    if (align) dp.align_to(ALIGNOF(rust_ivec *));\n+    typename T::data_ptr end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) +\n+        elem_sa.size * 4;\n \n     // Call to the implementation.\n     static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n \n     dp = end_dp;\n }\n \n-template<typename T,typename U>\n+template<typename T>\n void\n-data<T,U>::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n-                    uint16_t variant_count,\n-                    const uint8_t *largest_variants_ptr, size_align &tag_sa,\n-                    uint16_t n_params, const type_param *params) {\n-    uint32_t tag_variant;\n-    U end_dp;\n-    if (variant_count > 1) {\n-        if (align) dp.align(ALIGNOF(uint32_t));\n-        process_tag_variant_ids(\n-        U::data<uint32_t> tag_variant =\n-}\n+data<T>::walk_tag(bool align, tag_info &tinfo) {\n+    size_of::compute_tag_size(tinfo);\n \n-#endif\n+    if (tinfo.variant_count > 1 && align)\n+        dp.align_to(ALIGNOF(uint32_t));\n+\n+    typename T::data_ptr end_dp = tinfo.tag_sa.size;\n+\n+    typename T::template data<uint32_t> tag_variant;\n+    if (tinfo.variant_count > 1)\n+        tag_variant = dp.template get_bump<uint32_t>();\n+    else\n+        tag_variant = 0;\n+\n+    static_cast<T *>(this)->walk_tag(align, tinfo, tag_variant);\n+}\n \n \n // Copy constructors\n \n-class copy : public ctxt<copy> {\n+#if 0\n+\n+class copy : public data<copy> {\n     // TODO\n };\n \n+#endif\n+\n } // end namespace shape\n "}]}