{"sha": "76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZWQ0NDU2MjI0ZjZiZjdkYzM1ZGM3MmNjMWMyY2M5MzE4NjI4NWE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-22T08:03:42Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-17T17:12:32Z"}, "message": "Clean up and encapsulate `syntax::ext::mtwt`", "tree": {"sha": "e91209b14a183011a23baf699e1686fc9c233c27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e91209b14a183011a23baf699e1686fc9c233c27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "html_url": "https://github.com/rust-lang/rust/commit/76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145f0ec88caaae531d7ba0232c4ef39704a23af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/145f0ec88caaae531d7ba0232c4ef39704a23af2", "html_url": "https://github.com/rust-lang/rust/commit/145f0ec88caaae531d7ba0232c4ef39704a23af2"}], "stats": {"total": 261, "additions": 110, "deletions": 151}, "files": [{"sha": "6b141ca15c050ae467eea07b5fc17f1e84aab351", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -479,9 +479,8 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n-    // `clear_tables` and `clear_ident_interner` can be used to free\n-    // memory, but they do not restore the initial state.\n-    syntax::ext::mtwt::reset_tables();\n+    syntax::ext::mtwt::reset_hygiene_data();\n+    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n     token::reset_ident_interner();\n     let continue_after_error = sess.opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n@@ -763,7 +762,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n \n     // Discard MTWT tables that aren't required past lowering to HIR.\n     if !keep_mtwt_tables(sess) {\n-        syntax::ext::mtwt::clear_tables();\n+        syntax::ext::mtwt::reset_hygiene_data();\n     }\n \n     Ok(ExpansionResult {"}, {"sha": "14476cc997ff3eb35968e2540a7a99902d81205c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -456,7 +456,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n+                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n                 pp::space(&mut s.s)?;"}, {"sha": "77facbfb61798ebbcf9e0a74e695e4cc40e7261e", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -11,7 +11,7 @@\n use Resolver;\n use rustc::session::Session;\n use syntax::ast;\n-use syntax::ext::mtwt;\n+use syntax::ext::mtwt::Mark;\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n@@ -31,7 +31,7 @@ impl<'a> Resolver<'a> {\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n-    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<Mark>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {\n@@ -49,7 +49,7 @@ impl<'a> Folder for NodeIdAssigner<'a> {\n             block.stmts = block.stmts.move_flat_map(|stmt| {\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n                     if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n                         return None;\n                     }\n                 }"}, {"sha": "36cd2ef6002ac39cbbbd73f7a99511a2d0b8393a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -53,7 +53,7 @@ use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::mtwt;\n+use syntax::ext::mtwt::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n@@ -654,7 +654,7 @@ enum RibKind<'a> {\n     ModuleRibKind(Module<'a>),\n \n     // We passed through a `macro_rules!` statement with the given expansion\n-    MacroDefinition(ast::Mrk),\n+    MacroDefinition(Mark),\n }\n \n #[derive(Copy, Clone)]\n@@ -933,7 +933,7 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: HashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n@@ -1434,10 +1434,9 @@ impl<'a> Resolver<'a> {\n             if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n-                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                    if mac == source_macro {\n-                        ident = source_ident;\n-                    }\n+                let (source_ctxt, source_macro) = ident.ctxt.source();\n+                if source_macro == mac {\n+                    ident.ctxt = source_ctxt;\n                 }\n             }\n         }\n@@ -1585,10 +1584,9 @@ impl<'a> Resolver<'a> {\n                 MacroDefinition(mac) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                        if mac == source_macro {\n-                            ident = source_ident;\n-                        }\n+                    let (source_ctxt, source_macro) = ident.ctxt.source();\n+                    if source_macro == mac {\n+                        ident.ctxt = source_ctxt;\n                     }\n                 }\n                 _ => {"}, {"sha": "1f716923a16e24993f662815e0141008d289b3ca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -19,6 +19,7 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n+use ext::mtwt::SyntaxContext;\n use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n@@ -33,15 +34,6 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Name(pub u32);\n \n-/// A SyntaxContext represents a chain of macro-expandings\n-/// and renamings. Each macro expansion corresponds to\n-/// a fresh u32. This u32 is a reference to a table stored\n-/// in thread-local storage.\n-/// The special value EMPTY_CTXT is used to indicate an empty\n-/// syntax context.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct SyntaxContext(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -81,20 +73,15 @@ impl Decodable for Name {\n     }\n }\n \n-pub const EMPTY_CTXT : SyntaxContext = SyntaxContext(0);\n-\n impl Ident {\n-    pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n-        Ident {name: name, ctxt: ctxt}\n-    }\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n-        Ident {name: name, ctxt: EMPTY_CTXT}\n+        Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n }\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}#{}\", self.name, self.ctxt.0)\n+        write!(f, \"{}{:?}\", self.name, self.ctxt)\n     }\n }\n \n@@ -116,9 +103,6 @@ impl Decodable for Ident {\n     }\n }\n \n-/// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = u32;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "767d1ddb8e24d85dab976603c9b7cd086188b3ad", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -9,20 +9,19 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n-use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n+use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n use ast;\n-use attr::HasAttrs;\n-use ext::mtwt;\n-use attr;\n+use ext::mtwt::Mark;\n+use attr::{self, HasAttrs};\n use attr::AttrMetaMethods;\n-use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::token::{fresh_mark, intern, keywords};\n+use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -130,9 +129,9 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     // It would almost certainly be cleaner to pass the whole macro invocation in,\n     // rather than pulling it apart and marking the tts and the ctxt separately.\n     let Mac_ { path, tts, .. } = mac.node;\n-    let mark = fresh_mark();\n+    let mark = Mark::fresh();\n \n-    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mrk,\n+    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mark,\n                       attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n                       -> Option<Box<MacResult + 'a>> {\n         // Detect use of feature-gated or invalid attributes on macro invoations\n@@ -708,30 +707,17 @@ pub fn expand_crate(mut cx: ExtCtxt,\n     return (ret, cx.syntax_env.names);\n }\n \n-// HYGIENIC CONTEXT EXTENSION:\n-// all of these functions are for walking over\n-// ASTs and making some change to the context of every\n-// element that has one. a CtxtFn is a trait-ified\n-// version of a closure in (SyntaxContext -> SyntaxContext).\n-// the ones defined here include:\n-// Marker - add a mark to a context\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n-struct Marker { mark: Mrk, expn_id: Option<ExpnId> }\n+struct Marker { mark: Mark, expn_id: Option<ExpnId> }\n \n impl Folder for Marker {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(self.mark, id.ctxt))\n-    }\n-    fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n-        Spanned {\n-            node: Mac_ {\n-                path: self.fold_path(node.path),\n-                tts: self.fold_tts(&node.tts),\n-            },\n-            span: self.new_span(span),\n-        }\n+    fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n+        ident.ctxt = ident.ctxt.apply_mark(self.mark);\n+        ident\n+    }\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        noop_fold_mac(mac, self)\n     }\n \n     fn new_span(&mut self, mut span: Span) -> Span {\n@@ -743,7 +729,7 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n+fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n "}, {"sha": "c4af4a1f85b9c3df0003f344d0e8573feb8f1efc", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -15,107 +15,104 @@\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n-pub use self::SyntaxContext_::*;\n-\n-use ast::{Ident, Mrk, SyntaxContext};\n-\n use std::cell::RefCell;\n use std::collections::HashMap;\n+use std::fmt;\n \n-/// The SCTable contains a table of SyntaxContext_'s. It\n-/// represents a flattened tree structure, to avoid having\n-/// managed pointers everywhere (that caused an ICE).\n-/// The `marks` ensures that adding the same mark to the\n-/// same context gives you back the same context as before.\n-pub struct SCTable {\n-    table: RefCell<Vec<SyntaxContext_>>,\n-    marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-}\n+/// A SyntaxContext represents a chain of macro expansions (represented by marks).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Default)]\n+pub struct SyntaxContext(u32);\n \n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n-pub enum SyntaxContext_ {\n-    EmptyCtxt,\n-    Mark (Mrk,SyntaxContext),\n+#[derive(Copy, Clone)]\n+pub struct SyntaxContextData {\n+    pub outer_mark: Mark,\n+    pub prev_ctxt: SyntaxContext,\n }\n \n-/// Extend a syntax context with a given mark\n-pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| apply_mark_internal(m, ctxt, table))\n-}\n+/// A mark represents a unique id associated with a macro expansion.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n+pub struct Mark(u32);\n \n-/// Extend a syntax context with a given mark and sctable (explicit memoization)\n-fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let ctxts = &mut *table.table.borrow_mut();\n-    match ctxts[ctxt.0 as usize] {\n-        // Applying the same mark twice is a no-op.\n-        Mark(outer_mark, prev_ctxt) if outer_mark == m => return prev_ctxt,\n-        _ => *table.marks.borrow_mut().entry((ctxt, m)).or_insert_with(|| {\n-            SyntaxContext(idx_push(ctxts, Mark(m, ctxt)))\n-        }),\n+impl Mark {\n+    pub fn fresh() -> Self {\n+        HygieneData::with(|data| {\n+            let next_mark = Mark(data.next_mark.0 + 1);\n+            ::std::mem::replace(&mut data.next_mark, next_mark)\n+        })\n     }\n }\n \n-/// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn with_sctable<T, F>(op: F) -> T where\n-    F: FnOnce(&SCTable) -> T,\n-{\n-    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal());\n-    SCTABLE_KEY.with(move |slot| op(slot))\n+struct HygieneData {\n+    syntax_contexts: Vec<SyntaxContextData>,\n+    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    next_mark: Mark,\n }\n \n-// Make a fresh syntax context table with EmptyCtxt in slot zero.\n-fn new_sctable_internal() -> SCTable {\n-    SCTable {\n-        table: RefCell::new(vec![EmptyCtxt]),\n-        marks: RefCell::new(HashMap::new()),\n+impl HygieneData {\n+    fn new() -> Self {\n+        HygieneData {\n+            syntax_contexts: vec![SyntaxContextData {\n+                outer_mark: Mark(0), // the null mark\n+                prev_ctxt: SyntaxContext(0), // the empty context\n+            }],\n+            markings: HashMap::new(),\n+            next_mark: Mark(1),\n+        }\n     }\n-}\n \n-/// Clear the tables from TLD to reclaim memory.\n-pub fn clear_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = Vec::new();\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n+    fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n+        thread_local! {\n+            static HYGIENE_DATA: RefCell<HygieneData> = RefCell::new(HygieneData::new());\n+        }\n+        HYGIENE_DATA.with(|data| f(&mut *data.borrow_mut()))\n+    }\n }\n \n-/// Reset the tables to their initial state\n-pub fn reset_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = vec![EmptyCtxt];\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n+pub fn reset_hygiene_data() {\n+    HygieneData::with(|data| *data = HygieneData::new())\n }\n \n-/// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n-    vec.push(val);\n-    (vec.len() - 1) as u32\n-}\n+impl SyntaxContext {\n+    pub const fn empty() -> Self {\n+        SyntaxContext(0)\n+    }\n+\n+    pub fn data(self) -> SyntaxContextData {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize])\n+    }\n \n-/// Return the outer mark for a context with a mark at the outside.\n-/// FAILS when outside is not a mark.\n-pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n-    with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt.0 as usize] {\n-            Mark(mrk, _) => mrk,\n-            _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n+    /// Extend a syntax context with a given mark\n+    pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n+        // Applying the same mark twice is a no-op\n+        let ctxt_data = self.data();\n+        if mark == ctxt_data.outer_mark {\n+            return ctxt_data.prev_ctxt;\n         }\n-    })\n+\n+        HygieneData::with(|data| {\n+            let syntax_contexts = &mut data.syntax_contexts;\n+            *data.markings.entry((self, mark)).or_insert_with(|| {\n+                syntax_contexts.push(SyntaxContextData {\n+                    outer_mark: mark,\n+                    prev_ctxt: self,\n+                });\n+                SyntaxContext(syntax_contexts.len() as u32 - 1)\n+            })\n+        })\n+    }\n+\n+   /// If `ident` is macro expanded, return the source ident from the macro definition\n+   /// and the mark of the expansion that created the macro definition.\n+   pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n+        let macro_def_ctxt = self.data().prev_ctxt.data();\n+        (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n+   }\n }\n \n-/// If `ident` is macro expanded, return the source ident from the macro definition\n-/// and the mark of the expansion that created the macro definition.\n-pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n-    with_sctable(|sctable| {\n-        let ctxts = sctable.table.borrow();\n-        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n-            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n-                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n-            }\n-        }\n-        None\n-    })\n+impl fmt::Debug for SyntaxContext {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"#{}\", self.0)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "f0a6f8edeec73a241622a50a937b604c5896c6bd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ed4456224f6bf7dc35dc72cc1c2cc93186285a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=76ed4456224f6bf7dc35dc72cc1c2cc93186285a", "patch": "@@ -633,8 +633,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n     /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n     gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n-\n-// create a fresh mark.\n-pub fn fresh_mark() -> ast::Mrk {\n-    gensym(\"mark\").0\n-}"}]}