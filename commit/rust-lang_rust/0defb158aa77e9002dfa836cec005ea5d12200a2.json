{"sha": "0defb158aa77e9002dfa836cec005ea5d12200a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZWZiMTU4YWE3N2U5MDAyZGZhODM2Y2VjMDA1ZWE1ZDEyMjAwYTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-18T19:44:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-14T17:59:50Z"}, "message": "implement the obligation forest data structure and add some unit tests", "tree": {"sha": "8bfe44545f764174c1d5bccfebc9d34cc7f63fe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bfe44545f764174c1d5bccfebc9d34cc7f63fe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0defb158aa77e9002dfa836cec005ea5d12200a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0defb158aa77e9002dfa836cec005ea5d12200a2", "html_url": "https://github.com/rust-lang/rust/commit/0defb158aa77e9002dfa836cec005ea5d12200a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0defb158aa77e9002dfa836cec005ea5d12200a2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82c43432e02de111c3dda56be86d5fc68b538f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/82c43432e02de111c3dda56be86d5fc68b538f2e", "html_url": "https://github.com/rust-lang/rust/commit/82c43432e02de111c3dda56be86d5fc68b538f2e"}], "stats": {"total": 629, "additions": 627, "deletions": 2}, "files": [{"sha": "1fbbdf17455b27872b1297bc3b8982348e92ff01", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0defb158aa77e9002dfa836cec005ea5d12200a2", "patch": "@@ -24,17 +24,21 @@\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(rustc_private, staged_api)]\n #![feature(hashmap_hasher)]\n+#![feature(nonzero)]\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n \n #![cfg_attr(test, feature(test))]\n \n+extern crate core;\n #[macro_use] extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n+pub mod obligation_forest;\n pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;"}, {"sha": "21fa150b01297973427538c85edf19caad5f3258", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=0defb158aa77e9002dfa836cec005ea5d12200a2", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Debug;\n+use std::mem;\n+\n+mod node_index;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct ObligationForest<O> {\n+    nodes: Vec<Node<O>>,\n+    snapshots: Vec<usize>\n+}\n+\n+pub struct Snapshot {\n+    len: usize,\n+}\n+\n+pub use self::node_index::NodeIndex;\n+\n+struct Node<O> {\n+    state: NodeState<O>,\n+    parent: Option<NodeIndex>,\n+    root: NodeIndex, // points to the root, which may be the current node\n+}\n+\n+#[derive(Debug)]\n+enum NodeState<O> {\n+    Leaf { obligation: O },\n+    Success { obligation: O, num_children: usize },\n+    Error,\n+}\n+\n+#[derive(Debug)]\n+pub struct Outcome<O,E> {\n+    /// Obligations that were completely evaluated, including all\n+    /// (transitive) subobligations.\n+    pub successful: Vec<O>,\n+\n+    /// Backtrace of obligations that were found to be in error.\n+    pub errors: Vec<Error<O,E>>,\n+\n+    /// If true, then we saw no successful obligations, which means\n+    /// there is no point in further iteration. This is based on the\n+    /// assumption that `Err` and `Ok(None)` results do not affect\n+    /// environmental inference state. (Note that if we invoke\n+    /// `process_obligations` with no pending obligations, stalled\n+    /// will be true.)\n+    pub stalled: bool,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Error<O,E> {\n+    pub error: E,\n+    pub backtrace: Vec<O>,\n+}\n+\n+impl<O: Debug> ObligationForest<O> {\n+    pub fn new() -> ObligationForest<O> {\n+        ObligationForest {\n+            nodes: vec![],\n+            snapshots: vec![]\n+        }\n+    }\n+\n+    /// Return the total number of nodes in the forest that have not\n+    /// yet been fully resolved.\n+    pub fn len(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> Snapshot {\n+        self.snapshots.push(self.nodes.len());\n+        Snapshot { len: self.snapshots.len() }\n+    }\n+\n+    pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n+        assert_eq!(snapshot.len, self.snapshots.len());\n+        let nodes_len = self.snapshots.pop().unwrap();\n+        assert!(self.nodes.len() >= nodes_len);\n+    }\n+\n+    pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n+        // check that we are obeying stack discipline\n+        assert_eq!(snapshot.len, self.snapshots.len());\n+        let nodes_len = self.snapshots.pop().unwrap();\n+\n+        // the only action permitted while in a snapshot is to push new roots\n+        debug_assert!(self.nodes[nodes_len..].iter().all(|n| match n.state {\n+            NodeState::Leaf { .. } => true,\n+            _ => false,\n+        }));\n+\n+        self.nodes.truncate(nodes_len);\n+    }\n+\n+    pub fn in_snapshot(&self) -> bool {\n+        !self.snapshots.is_empty()\n+    }\n+\n+    /// Adds a new tree to the forest.\n+    ///\n+    /// This CAN be done during a snapshot.\n+    pub fn push_root(&mut self, obligation: O) {\n+        let index = NodeIndex::new(self.nodes.len());\n+        self.nodes.push(Node::new(index, None, obligation));\n+    }\n+\n+    /// Convert all remaining obligations to the given error.\n+    pub fn to_errors<E:Clone>(&mut self, error: E) -> Vec<Error<O,E>> {\n+        let mut errors = vec![];\n+        for index in 0..self.nodes.len() {\n+            debug_assert!(!self.nodes[index].is_popped());\n+            self.inherit_error(index);\n+            if let NodeState::Leaf { .. } = self.nodes[index].state {\n+                let backtrace = self.backtrace(index);\n+                errors.push(Error { error: error.clone(), backtrace: backtrace });\n+            }\n+        }\n+        let successful_obligations = self.compress();\n+        assert!(successful_obligations.is_empty());\n+        errors\n+    }\n+\n+    /// Convert all remaining obligations to the given error.\n+    pub fn pending_obligations(&self) -> Vec<O> where O: Clone {\n+        self.nodes.iter()\n+                  .filter_map(|n| match n.state {\n+                      NodeState::Leaf { ref obligation } => Some(obligation),\n+                      _ => None,\n+                  })\n+                  .cloned()\n+                  .collect()\n+    }\n+\n+    /// Process the obligations.\n+    ///\n+    /// This CANNOT be unrolled (presently, at least).\n+    pub fn process_obligations<E,F>(&mut self, mut action: F) -> Outcome<O,E>\n+        where E: Debug, F: FnMut(&mut O, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+    {\n+        debug!(\"process_obligations(len={})\", self.nodes.len());\n+        assert!(!self.in_snapshot()); // cannot unroll this action\n+\n+        let mut errors = vec![];\n+        let mut stalled = true;\n+\n+        // We maintain the invariant that the list is in pre-order, so\n+        // parents occur before their children. Also, whenever an\n+        // error occurs, we propagate it from the child all the way to\n+        // the root of the tree. Together, these two facts mean that\n+        // when we visit a node, we can check if its root is in error,\n+        // and we will find out if any prior node within this forest\n+        // encountered an error.\n+\n+        for index in 0..self.nodes.len() {\n+            debug_assert!(!self.nodes[index].is_popped());\n+            self.inherit_error(index);\n+\n+            debug!(\"process_obligations: node {} == {:?}\",\n+                   index, self.nodes[index].state);\n+\n+            let result = {\n+                let parent = self.nodes[index].parent;\n+                let (prefix, suffix) = self.nodes.split_at_mut(index);\n+                let backtrace = Backtrace::new(prefix, parent);\n+                match suffix[0].state {\n+                    NodeState::Error => continue,\n+                    NodeState::Success { .. } => continue,\n+                    NodeState::Leaf { ref mut obligation } => action(obligation, backtrace),\n+                }\n+            };\n+\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+\n+            match result {\n+                Ok(None) => {\n+                    // no change in state\n+                }\n+                Ok(Some(children)) => {\n+                    // if we saw a Some(_) result, we are not (yet) stalled\n+                    stalled = false;\n+                    self.success(index, children);\n+                }\n+                Err(err) => {\n+                    let backtrace = self.backtrace(index);\n+                    errors.push(Error { error: err, backtrace: backtrace });\n+                }\n+            }\n+        }\n+\n+        // Now we have to compress the result\n+        let successful_obligations = self.compress();\n+\n+        debug!(\"process_obligations: complete\");\n+\n+        Outcome {\n+            successful: successful_obligations,\n+            errors: errors,\n+            stalled: stalled,\n+        }\n+    }\n+\n+    /// Indicates that node `index` has been processed successfully,\n+    /// yielding `children` as the derivative work. If children is an\n+    /// empty vector, this will update the ref count on the parent of\n+    /// `index` to indicate that a child has completed\n+    /// successfully. Otherwise, adds new nodes to represent the child\n+    /// work.\n+    fn success(&mut self, index: usize, children: Vec<O>) {\n+        debug!(\"success(index={}, children={:?})\", index, children);\n+\n+        let num_children = children.len();\n+\n+        if num_children == 0 {\n+            // if there is no work left to be done, decrement parent's ref count\n+            self.update_parent(index);\n+        } else {\n+            // create child work\n+            let root_index = self.nodes[index].root;\n+            let node_index = NodeIndex::new(index);\n+            self.nodes.extend(\n+                children.into_iter()\n+                        .map(|o| Node::new(root_index, Some(node_index), o)));\n+        }\n+\n+        // change state from `Leaf` to `Success`, temporarily swapping in `Error`\n+        let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n+        self.nodes[index].state = match state {\n+            NodeState::Leaf { obligation } =>\n+                NodeState::Success { obligation: obligation,\n+                                     num_children: num_children },\n+            NodeState::Success { .. } | NodeState::Error =>\n+                unreachable!()\n+        };\n+    }\n+\n+    /// Decrements the ref count on the parent of `child`; if the\n+    /// parent's ref count then reaches zero, proceeds recursively.\n+    fn update_parent(&mut self, child: usize) {\n+        debug!(\"update_parent(child={})\", child);\n+        if let Some(parent) = self.nodes[child].parent {\n+            let parent = parent.get();\n+            match self.nodes[parent].state {\n+                NodeState::Success { ref mut num_children, .. } => {\n+                    *num_children -= 1;\n+                    if *num_children > 0 {\n+                        return;\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+            self.update_parent(parent);\n+        }\n+    }\n+\n+    /// If the root of `child` is in an error error, places `child`\n+    /// into an error state.\n+    fn inherit_error(&mut self, child: usize) {\n+        let root = self.nodes[child].root.get();\n+        if let NodeState::Error = self.nodes[root].state {\n+            self.nodes[child].state = NodeState::Error;\n+        }\n+    }\n+\n+    /// Returns a vector of obligations for `p` and all of its\n+    /// ancestors, putting them into the error state in the process.\n+    fn backtrace(&mut self, mut p: usize) -> Vec<O> {\n+        let mut trace = vec![];\n+        loop {\n+            let state = mem::replace(&mut self.nodes[p].state, NodeState::Error);\n+            match state {\n+                NodeState::Leaf { obligation } |\n+                NodeState::Success { obligation, .. } => {\n+                    trace.push(obligation);\n+                }\n+                NodeState::Error => {\n+                    // we should not encounter an error, because if\n+                    // there was an error in the ancestors, it should\n+                    // have been propagated down and we should never\n+                    // have tried to process this obligation\n+                    panic!(\"encountered error in node {:?} when collecting stack trace\", p);\n+                }\n+            }\n+\n+            // loop to the parent\n+            match self.nodes[p].parent {\n+                Some(q) => { p = q.get(); }\n+                None => { return trace; }\n+            }\n+        }\n+    }\n+\n+    /// Compresses the vector, removing all popped nodes. This adjusts\n+    /// the indices and hence invalidates any outstanding\n+    /// indices. Cannot be used during a transaction.\n+    fn compress(&mut self) -> Vec<O> {\n+        assert!(!self.in_snapshot()); // didn't write code to unroll this action\n+        let mut rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+\n+        // Finish propagating error state. Note that in this case we\n+        // only have to check immediate parents, rather than all\n+        // ancestors, because all errors have already occurred that\n+        // are going to occur.\n+        let nodes_len = self.nodes.len();\n+        for i in 0..nodes_len {\n+            if !self.nodes[i].is_popped() {\n+                self.inherit_error(i);\n+            }\n+        }\n+\n+        // Now go through and move all nodes that are either\n+        // successful or which have an error over into to the end of\n+        // the list, preserving the relative order of the survivors\n+        // (which is important for the `inherit_error` logic).\n+        let mut dead = 0;\n+        for i in 0..nodes_len {\n+            if self.nodes[i].is_popped() {\n+                dead += 1;\n+            } else if dead > 0 {\n+                self.nodes.swap(i, i - dead);\n+                rewrites[i] -= dead;\n+            }\n+        }\n+\n+        // Pop off all the nodes we killed and extract the success\n+        // stories.\n+        let successful =\n+            (0 .. dead).map(|_| self.nodes.pop().unwrap())\n+                       .flat_map(|node| match node.state {\n+                           NodeState::Error => None,\n+                           NodeState::Leaf { .. } => unreachable!(),\n+                           NodeState::Success { obligation, num_children } => {\n+                               assert_eq!(num_children, 0);\n+                               Some(obligation)\n+                           }\n+                       })\n+                       .collect();\n+\n+        // Adjust the parent indices, since we compressed things.\n+        for node in &mut self.nodes {\n+            if let Some(ref mut index) = node.parent {\n+                let new_index = rewrites[index.get()];\n+                debug_assert!(new_index < (nodes_len - dead));\n+                *index = NodeIndex::new(new_index);\n+            }\n+\n+            node.root = NodeIndex::new(rewrites[node.root.get()]);\n+        }\n+\n+        successful\n+    }\n+}\n+\n+impl<O> Node<O> {\n+    fn new(root: NodeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+        Node {\n+            parent: parent,\n+            state: NodeState::Leaf { obligation: obligation },\n+            root: root\n+        }\n+    }\n+\n+    fn is_popped(&self) -> bool {\n+        match self.state {\n+            NodeState::Leaf { .. } => false,\n+            NodeState::Success { num_children, .. } => num_children == 0,\n+            NodeState::Error => true,\n+        }\n+    }\n+}\n+\n+pub struct Backtrace<'b, O: 'b> {\n+    nodes: &'b [Node<O>],\n+    pointer: Option<NodeIndex>,\n+}\n+\n+impl<'b, O> Backtrace<'b, O> {\n+    fn new(nodes: &'b [Node<O>], pointer: Option<NodeIndex>) -> Backtrace<'b, O> {\n+        Backtrace { nodes: nodes, pointer: pointer }\n+    }\n+}\n+\n+impl<'b, O> Iterator for Backtrace<'b, O> {\n+    type Item = &'b O;\n+\n+    fn next(&mut self) -> Option<&'b O> {\n+        debug!(\"Backtrace: self.pointer = {:?}\", self.pointer);\n+        if let Some(p) = self.pointer {\n+            self.pointer = self.nodes[p.get()].parent;\n+            match self.nodes[p.get()].state {\n+                NodeState::Leaf { ref obligation } | NodeState::Success { ref obligation, .. } => {\n+                    Some(obligation)\n+                }\n+                NodeState::Error => {\n+                    panic!(\"Backtrace encountered an error.\");\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "ecfecd4e62823808ceb7d946c105f73f391d70bf", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=0defb158aa77e9002dfa836cec005ea5d12200a2", "patch": "@@ -0,0 +1,21 @@\n+use core::nonzero::NonZero;\n+use std::u32;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct NodeIndex {\n+    index: NonZero<u32>\n+}\n+\n+impl NodeIndex {\n+    pub fn new(value: usize) -> NodeIndex {\n+        assert!(value < (u32::MAX as usize));\n+        unsafe {\n+            NodeIndex { index: NonZero::new((value as u32) + 1) }\n+        }\n+    }\n+\n+    pub fn get(self) -> usize {\n+        (*self.index - 1) as usize\n+    }\n+}\n+"}, {"sha": "039b683717fce0d14a55745e93ecb455616d3d6e", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=0defb158aa77e9002dfa836cec005ea5d12200a2", "patch": "@@ -0,0 +1,188 @@\n+use super::{ObligationForest, Outcome, Error};\n+\n+#[test]\n+fn push_pop() {\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    forest.push_root(\"B\");\n+    forest.push_root(\"C\");\n+\n+    // first round, B errors out, A has subtasks, and C completes, creating this:\n+    //      A |-> A.1\n+    //        |-> A.2\n+    //        |-> A.3\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+            \"B\" => Err(\"B is for broken\"),\n+            \"C\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"C\"]);\n+    assert_eq!(err, vec![Error {error: \"B is for broken\",\n+                                backtrace: vec![\"B\"]}]);\n+\n+    // second round: two delays, one success, creating an uneven set of subtasks:\n+    //      A |-> A.1\n+    //        |-> A.2\n+    //        |-> A.3 |-> A.3.i\n+    //      D |-> D.1\n+    //        |-> D.2\n+    forest.push_root(\"D\");\n+    let Outcome { successful: ok, errors: err, .. }: Outcome<&'static str, ()> =\n+        forest.process_obligations(|obligation, _| {\n+            match *obligation {\n+                \"A.1\" => Ok(None),\n+                \"A.2\" => Ok(None),\n+                \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n+                \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok, Vec::<&'static str>::new());\n+    assert_eq!(err, Vec::new());\n+\n+\n+    // third round: ok in A.1 but trigger an error in A.2. Check that it\n+    // propagates to A.3.i, but not D.1 or D.2.\n+    //      D |-> D.1 |-> D.1.i\n+    //        |-> D.2 |-> D.2.i\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"A.1\" => Ok(Some(vec![])),\n+            \"A.2\" => Err(\"A is for apple\"),\n+            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"A.1\"]);\n+    assert_eq!(err, vec![Error { error: \"A is for apple\",\n+                                 backtrace: vec![\"A.2\", \"A\"] }]);\n+\n+    // fourth round: error in D.1.i that should propagate to D.2.i\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"D.1.i\" => Err(\"D is for dumb\"),\n+            _ => panic!(\"unexpected obligation {:?}\", obligation),\n+        }\n+    });\n+    assert_eq!(ok, Vec::<&'static str>::new());\n+    assert_eq!(err, vec![Error { error: \"D is for dumb\",\n+                                 backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n+}\n+\n+// Test that if a tree with grandchildren succeeds, everything is\n+// reported as expected:\n+// A\n+//   A.1\n+//   A.2\n+//      A.2.i\n+//      A.2.ii\n+//   A.3\n+#[test]\n+fn success_in_grandchildren() {\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, _| {\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, _| {\n+        match *obligation {\n+            \"A.1\" => Ok(Some(vec![])),\n+            \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n+            \"A.3\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, _| {\n+        match *obligation {\n+            \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n+            \"A.2.ii\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"A.2.ii\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, _| {\n+        match *obligation {\n+            \"A.2.i.a\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { successful: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|_, _| unreachable!());\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+}\n+\n+#[test]\n+fn to_errors_no_throw() {\n+    // check that converting multiple children with common parent (A)\n+    // only yields one of them (and does not panic, in particular).\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, _| {\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 1);\n+}\n+\n+#[test]\n+fn backtrace() {\n+    // check that converting multiple children with common parent (A)\n+    // only yields one of them (and does not panic, in particular).\n+    let mut forest: ObligationForest<&'static str> = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        assert!(backtrace.next().is_none());\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        assert!(backtrace.next().unwrap() == &\"A\");\n+        assert!(backtrace.next().is_none());\n+        match *obligation {\n+            \"A.1\" => Ok(Some(vec![\"A.1.i\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+    let Outcome { successful: ok, errors: err, .. } = forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        assert!(backtrace.next().unwrap() == &\"A.1\");\n+        assert!(backtrace.next().unwrap() == &\"A\");\n+        assert!(backtrace.next().is_none());\n+        match *obligation {\n+            \"A.1.i\" => Ok(None),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok.len(), 0);\n+    assert!(err.is_empty());\n+}"}, {"sha": "8985b1e56bc0097a2679137adc5c81b7c74046d4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0defb158aa77e9002dfa836cec005ea5d12200a2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0defb158aa77e9002dfa836cec005ea5d12200a2", "patch": "@@ -869,7 +869,7 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env), false);\n+                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {\n                         // The method comes from a `T: Trait` bound."}]}