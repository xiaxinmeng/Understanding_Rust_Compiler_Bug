{"sha": "128dc5355b81b0217fede903ae79f75ba0124716", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGRjNTM1NWI4MWIwMjE3ZmVkZTkwM2FlNzlmNzViYTAxMjQ3MTY=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-26T18:04:47Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-26T18:04:47Z"}, "message": "Refactor `Name` ready for hygienic macro", "tree": {"sha": "7ded1337bc7a77c66098d4307a2d381cb9a1f3b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ded1337bc7a77c66098d4307a2d381cb9a1f3b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128dc5355b81b0217fede903ae79f75ba0124716", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2M/cMACgkQztOS3gxI\nPQAqBQ/+IMWyBcIIj/Qap3Biudlm8s7p+jc9CjB/Fh0c/NUAJSSvqCzZ5icmSV92\noP8qj5dWeEKdJeI6AubjXMjhPMeIQf0BxAC6aOxl9tGTDE8seabAQkTum7pjkKDJ\nzecZ7W9mcMqjK/SsrvqX6bT2jHrvHRPZLgixJmHnKcuvsIdP7IX2SZZNHAt6eyca\n69hIzbI3mQQQNlQ8PLMqJMS/Q2O2NPKIf+ppQvMYXxCkaPniQNAd0iWQvBuxkwTP\nmM3A1R7XYrqWCKo60nhHjLQqnfgez7GetjCLLrJ6GQA6p4k5xpnLGbAntoOxuk6L\nr/BMFo3I+7qre1PNTcVlLMwlzrqCnmH9LnJyb6L9qgEEL09HivIzTEbefoxwvBBm\nz30aYKA67dCa9yar7cs1D91ofnEMyRS2FwlL6Ka3wswmXcwTp7MgtyWgzuBK6vWq\ndSQBG17riFaGSepqLPprQXDIQSF43lIp+XRSB9g3LcZ2RPPTtet41+oHq3h+W7GY\n2R1Z6/n7FmgzDtk9mScjHqfFb+bqVNsxquRldwaKLwlrAVyaejfcaIu/V7IAOoZM\nm4Q2fYggwnsJjThpV6+D6BUXIFLkmIvelY67RXxWLVxF0+IVKGhRBIGPM7IrJRdr\nB/1ESq8ePGEv5IxeTevx693ABKSytZj1XmF2YybcI+0iaRSQuNo=\n=n3ip\n-----END PGP SIGNATURE-----", "payload": "tree 7ded1337bc7a77c66098d4307a2d381cb9a1f3b2\nparent 53a30d9e69ee5149e4fdb1c6fe4081281e879d0e\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1569521087 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569521087 +0800\n\nRefactor `Name` ready for hygienic macro\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128dc5355b81b0217fede903ae79f75ba0124716", "html_url": "https://github.com/rust-lang/rust/commit/128dc5355b81b0217fede903ae79f75ba0124716", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128dc5355b81b0217fede903ae79f75ba0124716/comments", "author": null, "committer": null, "parents": [{"sha": "53a30d9e69ee5149e4fdb1c6fe4081281e879d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a30d9e69ee5149e4fdb1c6fe4081281e879d0e", "html_url": "https://github.com/rust-lang/rust/commit/53a30d9e69ee5149e4fdb1c6fe4081281e879d0e"}], "stats": {"total": 178, "additions": 94, "deletions": 84}, "files": [{"sha": "99d28621509a673b2e23c0891a21526d4cbf19d3", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=128dc5355b81b0217fede903ae79f75ba0124716", "patch": "@@ -133,7 +133,7 @@ impl VariantData {\n                     .fields()\n                     .enumerate()\n                     .map(|(i, fd)| StructFieldData {\n-                        name: Name::tuple_field_name(i),\n+                        name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();"}, {"sha": "d50867f5dcf9ef68a0e71c5a1302694aa1420c51", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=128dc5355b81b0217fede903ae79f75ba0124716", "patch": "@@ -5,50 +5,60 @@ use ra_syntax::{ast, SmolStr};\n /// `Name` is a wrapper around string, which is used in hir for both references\n /// and declarations. In theory, names should also carry hygiene info, but we are\n /// not there yet!\n-#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct Name {\n-    text: SmolStr,\n-}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Name(Repr);\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.text, f)\n-    }\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+enum Repr {\n+    Text(SmolStr),\n+    TupleField(usize),\n }\n \n-impl fmt::Debug for Name {\n+impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.text, f)\n+        match &self.0 {\n+            Repr::Text(text) => fmt::Display::fmt(&text, f),\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n     }\n }\n \n impl Name {\n     /// Note: this is private to make creating name from random string hard.\n     /// Hopefully, this should allow us to integrate hygiene cleaner in the\n     /// future, and to switch to interned representation of names.\n-    const fn new(text: SmolStr) -> Name {\n-        Name { text }\n+    const fn new_text(text: SmolStr) -> Name {\n+        Name(Repr::Text(text))\n     }\n \n-    pub(crate) fn missing() -> Name {\n-        Name::new(\"[missing name]\".into())\n+    pub(crate) fn new_tuple_field(idx: usize) -> Name {\n+        Name(Repr::TupleField(idx))\n     }\n \n-    pub(crate) fn tuple_field_name(idx: usize) -> Name {\n-        Name::new(idx.to_string().into())\n+    /// Shortcut to create inline plain text name\n+    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n+        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n     }\n \n-    // There's should be no way to extract a string out of `Name`: `Name` in the\n-    // future, `Name` will include hygiene information, and you can't encode\n-    // hygiene into a String.\n-    //\n-    // If you need to compare something with `Name`, compare `Name`s directly.\n-    //\n-    // If you need to render `Name` for the user, use the `Display` impl, but be\n-    // aware that it strips hygiene info.\n-    #[deprecated(note = \"use to_string instead\")]\n-    pub fn as_smolstr(&self) -> &SmolStr {\n-        &self.text\n+    /// Resolve a name from the text of token.\n+    fn resolve(raw_text: &SmolStr) -> Name {\n+        let raw_start = \"r#\";\n+        if raw_text.as_str().starts_with(raw_start) {\n+            Name::new_text(SmolStr::new(&raw_text[raw_start.len()..]))\n+        } else {\n+            Name::new_text(raw_text.clone())\n+        }\n+    }\n+\n+    pub(crate) fn missing() -> Name {\n+        Name::new_text(\"[missing name]\".into())\n+    }\n+\n+    pub(crate) fn as_tuple_index(&self) -> Option<usize> {\n+        match self.0 {\n+            Repr::TupleField(idx) => Some(idx),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -58,82 +68,73 @@ pub(crate) trait AsName {\n \n impl AsName for ast::NameRef {\n     fn as_name(&self) -> Name {\n-        let name = resolve_name(self.text());\n-        Name::new(name)\n+        match self.as_tuple_field() {\n+            Some(idx) => Name::new_tuple_field(idx),\n+            None => Name::resolve(self.text()),\n+        }\n     }\n }\n \n impl AsName for ast::Name {\n     fn as_name(&self) -> Name {\n-        let name = resolve_name(self.text());\n-        Name::new(name)\n+        Name::resolve(self.text())\n     }\n }\n \n impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n             ast::FieldKind::Name(nr) => nr.as_name(),\n-            ast::FieldKind::Index(idx) => Name::new(idx.text().clone()),\n+            ast::FieldKind::Index(idx) => Name::new_tuple_field(idx.text().parse().unwrap()),\n         }\n     }\n }\n \n impl AsName for ra_db::Dependency {\n     fn as_name(&self) -> Name {\n-        Name::new(self.name.clone())\n+        Name::new_text(self.name.clone())\n     }\n }\n \n // Primitives\n-pub(crate) const ISIZE: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"isize\"));\n-pub(crate) const I8: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"i8\"));\n-pub(crate) const I16: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i16\"));\n-pub(crate) const I32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i32\"));\n-pub(crate) const I64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i64\"));\n-pub(crate) const I128: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"i128\"));\n-pub(crate) const USIZE: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"usize\"));\n-pub(crate) const U8: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"u8\"));\n-pub(crate) const U16: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u16\"));\n-pub(crate) const U32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u32\"));\n-pub(crate) const U64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u64\"));\n-pub(crate) const U128: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"u128\"));\n-pub(crate) const F32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"f32\"));\n-pub(crate) const F64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"f64\"));\n-pub(crate) const BOOL: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"bool\"));\n-pub(crate) const CHAR: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"char\"));\n-pub(crate) const STR: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"str\"));\n+pub(crate) const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n+pub(crate) const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n+pub(crate) const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n+pub(crate) const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n+pub(crate) const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n+pub(crate) const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n+pub(crate) const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n+pub(crate) const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n+pub(crate) const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n+pub(crate) const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n+pub(crate) const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n+pub(crate) const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n+pub(crate) const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n+pub(crate) const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n+pub(crate) const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n+pub(crate) const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n+pub(crate) const STR: Name = Name::new_inline_ascii(3, b\"str\");\n \n // Special names\n-pub(crate) const SELF_PARAM: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"self\"));\n-pub(crate) const SELF_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Self\"));\n-pub(crate) const MACRO_RULES: Name = Name::new(SmolStr::new_inline_from_ascii(11, b\"macro_rules\"));\n+pub(crate) const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n+pub(crate) const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n+pub(crate) const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n \n // Components of known path (value or mod name)\n-pub(crate) const STD: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"std\"));\n-pub(crate) const ITER: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"iter\"));\n-pub(crate) const OPS: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"ops\"));\n-pub(crate) const FUTURE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"future\"));\n-pub(crate) const RESULT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n-pub(crate) const BOXED: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"boxed\"));\n+pub(crate) const STD: Name = Name::new_inline_ascii(3, b\"std\");\n+pub(crate) const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n+pub(crate) const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n+pub(crate) const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n+pub(crate) const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n+pub(crate) const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n \n // Components of known path (type name)\n-pub(crate) const INTO_ITERATOR_TYPE: Name =\n-    Name::new(SmolStr::new_inline_from_ascii(12, b\"IntoIterator\"));\n-pub(crate) const ITEM_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Item\"));\n-pub(crate) const TRY_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\"));\n-pub(crate) const OK_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n-pub(crate) const FUTURE_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Future\"));\n-pub(crate) const RESULT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Result\"));\n-pub(crate) const OUTPUT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n-pub(crate) const TARGET_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Target\"));\n-pub(crate) const BOX_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Box\"));\n-\n-fn resolve_name(text: &SmolStr) -> SmolStr {\n-    let raw_start = \"r#\";\n-    if text.as_str().starts_with(raw_start) {\n-        SmolStr::new(&text[raw_start.len()..])\n-    } else {\n-        text.clone()\n-    }\n-}\n+pub(crate) const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n+pub(crate) const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n+pub(crate) const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n+pub(crate) const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n+pub(crate) const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n+pub(crate) const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n+pub(crate) const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n+pub(crate) const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n+pub(crate) const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");"}, {"sha": "8f92468e675f95a2ac95cf43b5155b5816cd3060", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=128dc5355b81b0217fede903ae79f75ba0124716", "patch": "@@ -609,7 +609,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         for (i, &subpat) in subpats.iter().enumerate() {\n             let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n+                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n@@ -1375,10 +1375,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 )\n                 .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n                     Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Tuple { .. } => {\n-                            let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n-                        }\n+                        TypeCtor::Tuple { .. } => name\n+                            .as_tuple_index()\n+                            .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n                         TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n                             self.write_field_resolution(tgt_expr, field);\n                             field.ty(self.db).subst(&a_ty.parameters)"}, {"sha": "0433edb84e66ec7e3d4cc268e4c431104cc43d34", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128dc5355b81b0217fede903ae79f75ba0124716/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=128dc5355b81b0217fede903ae79f75ba0124716", "patch": "@@ -21,6 +21,16 @@ impl ast::NameRef {\n     pub fn text(&self) -> &SmolStr {\n         text_of_first_token(self.syntax())\n     }\n+\n+    pub fn as_tuple_field(&self) -> Option<usize> {\n+        self.syntax().children_with_tokens().find_map(|c| {\n+            if c.kind() == SyntaxKind::INT_NUMBER {\n+                c.as_token().and_then(|tok| tok.text().as_str().parse().ok())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }\n \n fn text_of_first_token(node: &SyntaxNode) -> &SmolStr {"}]}