{"sha": "f24d532749674c41940120866937860c8d4abcc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNGQ1MzI3NDk2NzRjNDE5NDAxMjA4NjY5Mzc4NjBjOGQ0YWJjYzg=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-11T07:00:21Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-18T15:11:34Z"}, "message": "refactor AbstractConstBuilder", "tree": {"sha": "4cd4bd1e7ec0a967d43d05ab06db51fea8b1d95a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cd4bd1e7ec0a967d43d05ab06db51fea8b1d95a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24d532749674c41940120866937860c8d4abcc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24d532749674c41940120866937860c8d4abcc8", "html_url": "https://github.com/rust-lang/rust/commit/f24d532749674c41940120866937860c8d4abcc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24d532749674c41940120866937860c8d4abcc8/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a772f55f2263cd2f2709f2bb187f59a8b4a673", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a772f55f2263cd2f2709f2bb187f59a8b4a673", "html_url": "https://github.com/rust-lang/rust/commit/c3a772f55f2263cd2f2709f2bb187f59a8b4a673"}], "stats": {"total": 125, "additions": 67, "deletions": 58}, "files": [{"sha": "337276fd811e75219ff838aa1b18acc6d835fcbe", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f24d532749674c41940120866937860c8d4abcc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d532749674c41940120866937860c8d4abcc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f24d532749674c41940120866937860c8d4abcc8", "patch": "@@ -187,70 +187,79 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n-        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n-        loop {\n-            debug!(\"AbstractConstBuilder: block={:?}\", block);\n-            for stmt in block.statements.iter() {\n-                debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n-                match stmt.kind {\n-                    StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                        let local = place.as_local()?;\n-                        match *rvalue {\n-                            Rvalue::Use(ref operand) => {\n-                                self.locals[local] = self.operand_to_node(operand)?;\n-                            }\n-                            Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                                let lhs = self.operand_to_node(lhs)?;\n-                                let rhs = self.operand_to_node(rhs)?;\n-                                self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n-                                if op.is_checkable() {\n-                                    bug!(\"unexpected unchecked checkable binary operation\");\n-                                }\n-                            }\n-                            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs)\n-                                if Self::check_binop(op) =>\n-                            {\n-                                let lhs = self.operand_to_node(lhs)?;\n-                                let rhs = self.operand_to_node(rhs)?;\n-                                self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n-                                self.checked_op_locals.insert(local);\n-                            }\n-                            _ => return None,\n+    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Option<()> {\n+        debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(box (ref place, ref rvalue)) => {\n+                let local = place.as_local()?;\n+                match *rvalue {\n+                    Rvalue::Use(ref operand) => {\n+                        self.locals[local] = self.operand_to_node(operand)?;\n+                    }\n+                    Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n+                        let lhs = self.operand_to_node(lhs)?;\n+                        let rhs = self.operand_to_node(rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        if op.is_checkable() {\n+                            bug!(\"unexpected unchecked checkable binary operation\");\n                         }\n                     }\n+                    Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n+                        let lhs = self.operand_to_node(lhs)?;\n+                        let rhs = self.operand_to_node(rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        self.checked_op_locals.insert(local);\n+                    }\n                     _ => return None,\n                 }\n             }\n+            _ => return None,\n+        }\n \n-            debug!(\"AbstractConstBuilder: terminator={:?}\", block.terminator());\n-            match block.terminator().kind {\n-                TerminatorKind::Goto { target } => {\n-                    block = &self.body.basic_blocks()[target];\n-                }\n-                TerminatorKind::Return => {\n-                    warn!(?self.nodes);\n-                    return { Some(self.tcx.arena.alloc_from_iter(self.nodes)) };\n-                }\n-                TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n-                    let p = match cond {\n-                        mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n-                        mir::Operand::Constant(_) => bug!(\"Unexpected assert\"),\n-                    };\n+        Some(())\n+    }\n \n-                    const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n-                    debug!(\"proj: {:?}\", p.projection);\n-                    if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n-                        // Only allow asserts checking the result of a checked operation.\n-                        if self.checked_op_locals.contains(p.local) {\n-                            block = &self.body.basic_blocks()[target];\n-                            continue;\n-                        }\n-                    }\n+    fn build_terminator(\n+        &mut self,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> Option<Option<mir::BasicBlock>> {\n+        debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n+        match terminator.kind {\n+            TerminatorKind::Goto { target } => Some(Some(target)),\n+            TerminatorKind::Return => Some(None),\n+            TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n+                let p = match cond {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n+                    mir::Operand::Constant(_) => bug!(\"Unexpected assert\"),\n+                };\n \n-                    return None;\n+                const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n+                debug!(\"proj: {:?}\", p.projection);\n+                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                    // Only allow asserts checking the result of a checked operation.\n+                    if self.checked_op_locals.contains(p.local) {\n+                        return Some(Some(target));\n+                    }\n                 }\n-                _ => return None,\n+\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n+        loop {\n+            debug!(\"AbstractConstBuilder: block={:?}\", block);\n+            for stmt in block.statements.iter() {\n+                self.build_statement(stmt)?;\n+            }\n+\n+            if let Some(next) = self.build_terminator(block.terminator())? {\n+                block = &self.body.basic_blocks()[next];\n+            } else {\n+                return Some(self.tcx.arena.alloc_from_iter(self.nodes));\n             }\n         }\n     }\n@@ -261,11 +270,11 @@ pub(super) fn mir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> Option<&'tcx [Node<'tcx>]> {\n-    if !tcx.features().const_evaluatable_checked {\n-        None\n-    } else {\n+    if tcx.features().const_evaluatable_checked {\n         let body = tcx.mir_const(def).borrow();\n         AbstractConstBuilder::new(tcx, &body)?.build()\n+    } else {\n+        None\n     }\n }\n "}]}