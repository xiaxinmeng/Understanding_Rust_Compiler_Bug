{"sha": "c67d4749a547a0c937e257ad9e0248075178ddc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2N2Q0NzQ5YTU0N2EwYzkzN2UyNTdhZDllMDI0ODA3NTE3OGRkYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-14T04:22:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-14T04:22:35Z"}, "message": "Auto merge of #58446 - Centril:rollup, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #57451 (suggestion-diagnostics: as_ref improve snippet)\n - #57856 (Convert old first edition links to current edition one)\n - #57992 (Update the future/task API)\n - #58258 (Reduce the size of `hir::Expr`.)\n - #58267 (Tweak \"incompatible match arms\" error)\n - #58296 (Hidden suggestion support)\n - #58301 (Enable comparing fat pointers)\n - #58308 (Extract block to insert an intrinsic into its own function)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fd070f430bac8a7e503c2a8d59302a1bbb987b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd070f430bac8a7e503c2a8d59302a1bbb987b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67d4749a547a0c937e257ad9e0248075178ddc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67d4749a547a0c937e257ad9e0248075178ddc4", "html_url": "https://github.com/rust-lang/rust/commit/c67d4749a547a0c937e257ad9e0248075178ddc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67d4749a547a0c937e257ad9e0248075178ddc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4772dc8087b1d0f2bab6d064fd930e596c82d439", "url": "https://api.github.com/repos/rust-lang/rust/commits/4772dc8087b1d0f2bab6d064fd930e596c82d439", "html_url": "https://github.com/rust-lang/rust/commit/4772dc8087b1d0f2bab6d064fd930e596c82d439"}, {"sha": "a0767d6096e2da69381b4d925f3f22887f754aef", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0767d6096e2da69381b4d925f3f22887f754aef", "html_url": "https://github.com/rust-lang/rust/commit/a0767d6096e2da69381b4d925f3f22887f754aef"}], "stats": {"total": 1775, "additions": 959, "deletions": 816}, "files": [{"sha": "fd71d3e3c8e79e1030039dc17f587cda6018df3a", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,4 +1,4 @@\n % Error Handling in Rust\n \n This content has moved into\n-[the Rust Programming Language book](book/error-handling.html).\n+[the Rust Programming Language book](book/ch09-00-error-handling.html)."}, {"sha": "767dafc5baf9208e3927680947fe3da83c493201", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,4 +1,4 @@\n % The (old) Rust Ownership Guide\n \n This content has moved into\n-[the Rust Programming Language book](book/ownership.html).\n+[the Rust Programming Language book](book/ch04-00-understanding-ownership.html)."}, {"sha": "bafdb2fe0bbc3790867d1e8a117226f033c298ae", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,6 +2,6 @@\n \n This content has been removed, with no direct replacement. Rust only\n has two built-in pointer types now,\n-[references](book/references-and-borrowing.html) and [raw\n+[references](book/ch04-02-references-and-borrowing.html) and [raw\n pointers](book/raw-pointers.html). Older Rusts had many more pointer\n types, they\u2019re gone now."}, {"sha": "28d9fb48b73e74485f6a8b930428a7fbb6db81ef", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,4 +1,4 @@\n % The (old) Rust Testing Guide\n \n This content has moved into\n-[the Rust Programming Language book](book/testing.html).\n+[the Rust Programming Language book](book/ch11-00-testing.html)."}, {"sha": "51549f92d4dbf02e50a2a48c21ff8339988c2e3b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -71,7 +71,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -896,7 +896,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), waker)\n     }\n }"}, {"sha": "95b9dacf8565aa5ea9357e26bded9031129ac3d6", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -132,10 +132,6 @@ mod macros;\n \n pub mod alloc;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub mod task;\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid"}, {"sha": "2261dabe2779af4b35d35107db0db391023b879d", "filename": "src/liballoc/task.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,130 +0,0 @@\n-//! Types and Traits for working with asynchronous tasks.\n-\n-pub use core::task::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-pub use if_arc::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-mod if_arc {\n-    use super::*;\n-    use core::marker::PhantomData;\n-    use core::mem;\n-    use core::ptr::{self, NonNull};\n-    use crate::sync::Arc;\n-\n-    /// A way of waking up a specific task.\n-    ///\n-    /// Any task executor must provide a way of signaling that a task it owns\n-    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n-    pub trait Wake: Send + Sync {\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-        /// the associated task onto this queue.\n-        fn wake(arc_self: &Arc<Self>);\n-\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed. This function is like `wake`, but can only be called from the\n-        /// thread on which this `Wake` was created.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-        /// the associated task onto this queue.\n-        #[inline]\n-        unsafe fn wake_local(arc_self: &Arc<Self>) {\n-            Self::wake(arc_self);\n-        }\n-    }\n-\n-    #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-    struct ArcWrapped<T>(PhantomData<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            let me: *const ArcWrapped<T> = self;\n-            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n-            Waker::from(arc)\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            let mut me: *const ArcWrapped<T> = self;\n-            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n-            ptr::drop_in_place(me);\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-    }\n-\n-    impl<T> From<Arc<T>> for Waker\n-        where T: Wake + 'static,\n-    {\n-        fn from(rc: Arc<T>) -> Self {\n-            unsafe {\n-                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n-                Waker::new(ptr)\n-            }\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a local `wake`.\n-    ///\n-    /// This function requires that `wake` is \"local\" (created on the current thread).\n-    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n-    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n-    #[inline]\n-    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n-        LocalWaker::new(ptr)\n-    }\n-\n-    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            self.0.clone_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            self.0.drop_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            self.0.wake()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            // Since we're nonlocal, we can't call wake_local\n-            self.0.wake()\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a non-local `wake`.\n-    ///\n-    /// This function is similar to `local_waker`, but does not require that `wake`\n-    /// is local to the current thread. The resulting `LocalWaker` will call\n-    /// `wake.wake()` when awoken.\n-    #[inline]\n-    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        unsafe {\n-            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n-            LocalWaker::new(ptr)\n-        }\n-    }\n-}"}, {"sha": "b8d751cfbb6df24f06b8d5e8dd0ed9fb33210436", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -116,9 +116,6 @@ pub const fn identity<T>(x: T) -> T { x }\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n ///\n-/// See [the book][book] for a more detailed comparison.\n-///\n-/// [book]: ../../book/first-edition/borrow-and-asref.html\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n /// **Note: this trait must not fail**. If the conversion can fail, use a\n@@ -351,7 +348,7 @@ pub trait Into<T>: Sized {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Into<U>`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n-/// [book]: ../../book/first-edition/error-handling.html\n+/// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion."}, {"sha": "02457e00054c8eb0f19f8d95a1d9a2300f53f942", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -5,7 +5,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{Poll, LocalWaker};\n+use task::{Poll, Waker};\n \n /// A future represents an asynchronous computation.\n ///\n@@ -19,13 +19,14 @@ use task::{Poll, LocalWaker};\n /// final value. This method does not block if the value is not ready. Instead,\n /// the current task is scheduled to be woken up when it's possible to make\n /// further progress by `poll`ing again. The wake up is performed using\n-/// `cx.waker()`, a handle for waking up the current task.\n+/// the `waker` argument of the `poll()` method, which is a handle for waking\n+/// up the current task.\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n #[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n-    /// The result of the `Future`.\n+    /// The type of value produced on completion.\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering\n@@ -42,16 +43,16 @@ pub trait Future {\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n     /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n-    /// stores a clone of the [`LocalWaker`] to be woken once the future can\n+    /// stores a clone of the [`Waker`] to be woken once the future can\n     /// make progress. For example, a future waiting for a socket to become\n-    /// readable would call `.clone()` on the [`LocalWaker`] and store it.\n+    /// readable would call `.clone()` on the [`Waker`] and store it.\n     /// When a signal arrives elsewhere indicating that the socket is readable,\n-    /// `[LocalWaker::wake]` is called and the socket future's task is awoken.\n+    /// `[Waker::wake]` is called and the socket future's task is awoken.\n     /// Once a task has been woken up, it should attempt to `poll` the future\n     /// again, which may or may not produce a final value.\n     ///\n     /// Note that on multiple calls to `poll`, only the most recent\n-    /// [`LocalWaker`] passed to `poll` should be scheduled to receive a\n+    /// [`Waker`] passed to `poll` should be scheduled to receive a\n     /// wakeup.\n     ///\n     /// # Runtime characteristics\n@@ -67,44 +68,35 @@ pub trait Future {\n     /// typically do *not* suffer the same problems of \"all wakeups must poll\n     /// all events\"; they are more like `epoll(4)`.\n     ///\n-    /// An implementation of `poll` should strive to return quickly, and must\n-    /// *never* block. Returning quickly prevents unnecessarily clogging up\n+    /// An implementation of `poll` should strive to return quickly, and should\n+    /// not block. Returning quickly prevents unnecessarily clogging up\n     /// threads or event loops. If it is known ahead of time that a call to\n     /// `poll` may end up taking awhile, the work should be offloaded to a\n     /// thread pool (or something similar) to ensure that `poll` can return\n     /// quickly.\n     ///\n-    /// # [`LocalWaker`], [`Waker`] and thread-safety\n-    ///\n-    /// The `poll` function takes a [`LocalWaker`], an object which knows how to\n-    /// awaken the current task. [`LocalWaker`] is not `Send` nor `Sync`, so in\n-    /// order to make thread-safe futures the [`LocalWaker::into_waker`] method\n-    /// should be used to convert the [`LocalWaker`] into a thread-safe version.\n-    /// [`LocalWaker::wake`] implementations have the ability to be more\n-    /// efficient, however, so when thread safety is not necessary,\n-    /// [`LocalWaker`] should be preferred.\n+    /// An implementation of `poll` may also never cause memory unsafety.\n     ///\n     /// # Panics\n     ///\n     /// Once a future has completed (returned `Ready` from `poll`),\n     /// then any future calls to `poll` may panic, block forever, or otherwise\n-    /// cause bad behavior. The `Future` trait itself provides no guarantees\n-    /// about the behavior of `poll` after a future has completed.\n+    /// cause any kind of bad behavior expect causing memory unsafety.\n+    /// The `Future` trait itself provides no guarantees about the behavior\n+    /// of `poll` after a future has completed.\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n-    /// [`LocalWaker`]: ../task/struct.LocalWaker.html\n-    /// [`LocalWaker::into_waker`]: ../task/struct.LocalWaker.html#method.into_waker\n-    /// [`LocalWaker::wake`]: ../task/struct.LocalWaker.html#method.wake\n     /// [`Waker`]: ../task/struct.Waker.html\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output>;\n+    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), waker)\n     }\n }\n \n@@ -115,7 +107,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(lw)\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(waker)\n     }\n }"}, {"sha": "c4b41f1a3090c3685e52a228a6b9efbf1ebb9836", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -78,7 +78,7 @@ impl<T: ?Sized> !Send for *mut T { }\n ///                         // be made into an object\n /// ```\n ///\n-/// [trait object]: ../../book/first-edition/trait-objects.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented(\n@@ -518,7 +518,7 @@ macro_rules! impls{\n /// types. We track the Rust type using a phantom type parameter on\n /// the struct `ExternalResource` which wraps a handle.\n ///\n-/// [FFI]: ../../book/first-edition/ffi.html\n+/// [FFI]: ../../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n ///\n /// ```\n /// # #![allow(dead_code)]"}, {"sha": "3f7455aeb59b9bcfef22fabdb5f9b4c7cb0c2351", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -299,7 +299,7 @@ pub const fn size_of<T>() -> usize {\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n-/// [trait object]: ../../book/first-edition/trait-objects.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n ///\n /// # Examples\n ///"}, {"sha": "9b8f59811620083edf04be7e8cb1b8795d2d1253", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -8,4 +8,4 @@ mod poll;\n pub use self::poll::Poll;\n \n mod wake;\n-pub use self::wake::{Waker, LocalWaker, UnsafeWake};\n+pub use self::wake::{Waker, RawWaker, RawWakerVTable};"}, {"sha": "21f0a8cea4168a87667a3aa571545aa92091a4d5", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 112, "deletions": 234, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -4,281 +4,159 @@\n \n use fmt;\n use marker::Unpin;\n-use ptr::NonNull;\n+\n+/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n+/// which provides customized wakeup behavior.\n+///\n+/// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n+///\n+/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n+/// customizes the behavior of the `RawWaker`.\n+#[derive(PartialEq, Debug)]\n+pub struct RawWaker {\n+    /// A data pointer, which can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this field gets passed to all functions that are part of\n+    /// the vtable as the first parameter.\n+    data: *const (),\n+    /// Virtual function pointer table that customizes the behavior of this waker.\n+    vtable: &'static RawWakerVTable,\n+}\n+\n+impl RawWaker {\n+    /// Creates a new `RawWaker` from the provided `data` pointer and `vtable`.\n+    ///\n+    /// The `data` pointer can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this poiner will get passed to all functions that are part\n+    /// of the `vtable` as the first parameter.\n+    ///\n+    /// The `vtable` customizes the behavior of a `Waker` which gets created\n+    /// from a `RawWaker`. For each operation on the `Waker`, the associated\n+    /// function in the `vtable` of the underlying `RawWaker` will be called.\n+    pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n+        RawWaker {\n+            data,\n+            vtable,\n+        }\n+    }\n+}\n+\n+/// A virtual function pointer table (vtable) that specifies the behavior\n+/// of a [`RawWaker`].\n+///\n+/// The pointer passed to all functions inside the vtable is the `data` pointer\n+/// from the enclosing [`RawWaker`] object.\n+///\n+/// The functions inside this struct are only intended be called on the `data`\n+/// pointer of a properly constructed [`RawWaker`] object from inside the\n+/// [`RawWaker`] implementation. Calling one of the contained functions using\n+/// any other `data` pointer will cause undefined behavior.\n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub struct RawWakerVTable {\n+    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n+    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n+    ///\n+    /// The implementation of this function must retain all resources that are\n+    /// required for this additional instance of a [`RawWaker`] and associated\n+    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n+    /// of the same task that would have been awoken by the original [`RawWaker`].\n+    pub clone: unsafe fn(*const ()) -> RawWaker,\n+\n+    /// This function will be called when `wake` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// The implemention of this function must not consume the provided data\n+    /// pointer.\n+    pub wake: unsafe fn(*const ()),\n+\n+    /// This function gets called when a [`RawWaker`] gets dropped.\n+    ///\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    pub drop: unsafe fn(*const ()),\n+}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n ///\n-/// This handle contains a trait object pointing to an instance of the `UnsafeWake`\n-/// trait, allowing notifications to get routed through it.\n+/// This handle encapsulates a [`RawWaker`] instance, which defines the\n+/// executor-specific wakeup behavior.\n+///\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n #[repr(transparent)]\n pub struct Waker {\n-    inner: NonNull<dyn UnsafeWake>,\n+    waker: RawWaker,\n }\n \n impl Unpin for Waker {}\n unsafe impl Send for Waker {}\n unsafe impl Sync for Waker {}\n \n impl Waker {\n-    /// Constructs a new `Waker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `Waker::from` function instead which works with the safe\n-    /// `Arc` type and the safe `Wake` trait.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        Waker { inner }\n-    }\n-\n     /// Wake up the task associated with this `Waker`.\n-    #[inline]\n     pub fn wake(&self) {\n-        unsafe { self.inner.as_ref().wake() }\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `wake` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns `true` if or not this `Waker` and `other` awaken the same task.\n+    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n     ///\n     /// This function is primarily used for optimization purposes.\n-    #[inline]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n-        self.inner == other.inner\n+        self.waker == other.waker\n     }\n \n-    /// Returns `true` if or not this `Waker` and `other` `LocalWaker` awaken\n-    /// the same task.\n+    /// Creates a new `Waker` from [`RawWaker`].\n     ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_local(&self, other: &LocalWaker) -> bool {\n-        self.will_wake(&other.0)\n+    /// The behavior of the returned `Waker` is undefined if the contract defined\n+    /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n+    /// Therefore this method is unsafe.\n+    pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n+        Waker {\n+            waker,\n+        }\n     }\n }\n \n impl Clone for Waker {\n-    #[inline]\n     fn clone(&self) -> Self {\n-        unsafe {\n-            self.inner.as_ref().clone_raw()\n+        Waker {\n+            // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+            // to initialize `clone` and `data` requiring the user to acknowledge\n+            // that the contract of [`RawWaker`] is upheld.\n+            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n         }\n     }\n }\n \n-impl fmt::Debug for Waker {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Waker\")\n-            .finish()\n-    }\n-}\n-\n impl Drop for Waker {\n-    #[inline]\n     fn drop(&mut self) {\n-        unsafe {\n-            self.inner.as_ref().drop_raw()\n-        }\n-    }\n-}\n-\n-/// A `LocalWaker` is a handle for waking up a task by notifying its executor that it\n-/// is ready to be run.\n-///\n-/// This is similar to the `Waker` type, but cannot be sent across threads.\n-/// Task executors can use this type to implement more optimized single-threaded wakeup\n-/// behavior.\n-#[repr(transparent)]\n-#[derive(Clone)]\n-pub struct LocalWaker(Waker);\n-\n-impl Unpin for LocalWaker {}\n-impl !Send for LocalWaker {}\n-impl !Sync for LocalWaker {}\n-\n-impl LocalWaker {\n-    /// Constructs a new `LocalWaker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `local_waker_from_nonlocal` or `local_waker` to convert a `Waker`\n-    /// into a `LocalWaker`.\n-    ///\n-    /// For this function to be used safely, it must be sound to call `inner.wake_local()`\n-    /// on the current thread.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        LocalWaker(Waker::new(inner))\n-    }\n-\n-    /// Borrows this `LocalWaker` as a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn as_waker(&self) -> &Waker {\n-        &self.0\n-    }\n-\n-    /// Converts this `LocalWaker` into a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn into_waker(self) -> Waker {\n-        self.0\n-    }\n-\n-    /// Wake up the task associated with this `LocalWaker`.\n-    #[inline]\n-    pub fn wake(&self) {\n-        unsafe { self.0.inner.as_ref().wake_local() }\n-    }\n-\n-    /// Returns `true` if or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `LocalWaker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake(&self, other: &LocalWaker) -> bool {\n-        self.0.will_wake(&other.0)\n-    }\n-\n-    /// Returns `true` if or not this `LocalWaker` and `other` `Waker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_nonlocal(&self, other: &Waker) -> bool {\n-        self.0.will_wake(other)\n-    }\n-}\n-\n-impl From<LocalWaker> for Waker {\n-    /// Converts a `LocalWaker` into a `Waker`.\n-    ///\n-    /// This conversion turns a `!Sync` `LocalWaker` into a `Sync` `Waker`, allowing a wakeup\n-    /// object to be sent to another thread, but giving up its ability to do specialized\n-    /// thread-local wakeup behavior.\n-    #[inline]\n-    fn from(local_waker: LocalWaker) -> Self {\n-        local_waker.0\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `drop` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.drop)(self.waker.data) }\n     }\n }\n \n-impl fmt::Debug for LocalWaker {\n+impl fmt::Debug for Waker {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LocalWaker\")\n+        let vtable_ptr = self.waker.vtable as *const RawWakerVTable;\n+        f.debug_struct(\"Waker\")\n+            .field(\"data\", &self.waker.data)\n+            .field(\"vtable\", &vtable_ptr)\n             .finish()\n     }\n }\n-\n-/// An unsafe trait for implementing custom memory management for a `Waker` or `LocalWaker`.\n-///\n-/// A `Waker` conceptually is a cloneable trait object for `Wake`, and is\n-/// most often essentially just `Arc<dyn Wake>`. However, in some contexts\n-/// (particularly `no_std`), it's desirable to avoid `Arc` in favor of some\n-/// custom memory management strategy. This trait is designed to allow for such\n-/// customization.\n-///\n-/// When using `std`, a default implementation of the `UnsafeWake` trait is provided for\n-/// `Arc<T>` where `T: Wake`.\n-pub unsafe trait UnsafeWake: Send + Sync {\n-    /// Creates a clone of this `UnsafeWake` and stores it behind a `Waker`.\n-    ///\n-    /// This function will create a new uniquely owned handle that under the\n-    /// hood references the same notification instance. In other words calls\n-    /// to `wake` on the returned handle should be equivalent to calls to\n-    /// `wake` on this handle.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn clone_raw(&self) -> Waker;\n-\n-    /// Drops this instance of `UnsafeWake`, deallocating resources\n-    /// associated with it.\n-    ///\n-    // FIXME(cramertj):\n-    /// This method is intended to have a signature such as:\n-    ///\n-    /// ```ignore (not-a-doctest)\n-    /// fn drop_raw(self: *mut Self);\n-    /// ```\n-    ///\n-    /// Unfortunately, in Rust today that signature is not object safe.\n-    /// Nevertheless it's recommended to implement this function *as if* that\n-    /// were its signature. As such it is not safe to call on an invalid\n-    /// pointer, nor is the validity of the pointer guaranteed after this\n-    /// function returns.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn drop_raw(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn wake(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed. This function is the same as `wake`, but can only be called\n-    /// from the thread that this `UnsafeWake` is \"local\" to. This allows for\n-    /// implementors to provide specialized wakeup behavior specific to the current\n-    /// thread. This function is called by `LocalWaker::wake`.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n-    /// `UnsafeWake` hasn't moved from the thread on which it was created.\n-    unsafe fn wake_local(&self) {\n-        self.wake()\n-    }\n-}"}, {"sha": "6c061189d00d7915002da588f0452ce5645a6227", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -5,7 +5,9 @@\n //! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n //! custom derive attributes`#[proc_macro_derive]`.\n //!\n-//! See [the book](../book/first-edition/procedural-macros.html) for more.\n+//! See [the book] for more.\n+//!\n+//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n \n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #![deny(missing_docs)]"}, {"sha": "f46ff6f6062c2648037fbc0ecfe2ac3a665c6ea8", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-linelength\n #![allow(non_snake_case)]\n \n // Error messages for EXXXX errors.\n@@ -410,7 +411,7 @@ fn baz<'a>(x: &'a str, y: &str) -> &str { }\n Lifetime elision in implementation headers was part of the lifetime elision\n RFC. It is, however, [currently unimplemented][iss15872].\n \n-[book-le]: https://doc.rust-lang.org/nightly/book/first-edition/lifetimes.html#lifetime-elision\n+[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n@@ -646,7 +647,9 @@ attributes:\n #![no_std]\n ```\n \n-See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n+See also the [unstable book][1].\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n \"##,\n \n E0214: r##\"\n@@ -1713,7 +1716,7 @@ fn main() {\n ```\n \n To understand better how closures work in Rust, read:\n-https://doc.rust-lang.org/book/first-edition/closures.html\n+https://doc.rust-lang.org/book/ch13-01-closures.html\n \"##,\n \n E0580: r##\""}, {"sha": "84487c40f874508f4d6ad469d941139d1109266f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -3859,15 +3859,15 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Call(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.lower_path_segment(\n+                let hir_seg = P(self.lower_path_segment(\n                     e.span,\n                     seg,\n                     ParamMode::Optional,\n                     0,\n                     ParenthesizedGenericArgs::Err,\n                     ImplTraitContext::disallowed(),\n                     None,\n-                );\n+                ));\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n             }\n@@ -4148,7 +4148,7 @@ impl<'a> LoweringContext<'a> {\n                     node: if is_unit {\n                         hir::ExprKind::Path(struct_path)\n                     } else {\n-                        hir::ExprKind::Struct(struct_path, fields, None)\n+                        hir::ExprKind::Struct(P(struct_path), fields, None)\n                     },\n                     span: e.span,\n                     attrs: e.attrs.clone(),\n@@ -4220,13 +4220,13 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n             }\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n-                self.lower_qpath(\n+                P(self.lower_qpath(\n                     e.id,\n                     &None,\n                     path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n-                ),\n+                )),\n                 fields.iter().map(|x| self.lower_field(x)).collect(),\n                 maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n             ),"}, {"sha": "d774359fa79ec2fb8f9b242cab2416ddd6d79943", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1319,6 +1319,10 @@ pub struct Expr {\n     pub hir_id: HirId,\n }\n \n+// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 72);\n+\n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.node {\n@@ -1438,7 +1442,7 @@ pub enum ExprKind {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    MethodCall(PathSegment, Span, HirVec<Expr>),\n+    MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n     /// A tuple (e.g., `(a, b, c ,d)`).\n     Tup(HirVec<Expr>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -1506,7 +1510,7 @@ pub enum ExprKind {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    Struct(QPath, HirVec<Field>, Option<P<Expr>>),\n+    Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///"}, {"sha": "705d9c4cf93ea94acc0388fcaae8ffe867476452", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -508,22 +508,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n+            ObligationCauseCode::MatchExpressionArm {\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+                ..\n+            } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n-                    let msg = \"`if let` arm with an incompatible type\";\n-                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n-                        err.span_note(arm_span, msg);\n-                    } else {\n-                        err.span_label(arm_span, msg);\n-                    }\n+                    let msg = \"`if let` arms have incompatible types\";\n+                    err.span_label(cause.span, msg);\n                 }\n                 hir::MatchSource::TryDesugar => {}\n                 _ => {\n-                    let msg = \"match arm with an incompatible type\";\n-                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n-                        err.span_note(arm_span, msg);\n-                    } else {\n-                        err.span_label(arm_span, msg);\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(cause.span, msg);\n+                    if prior_arms.len() <= 4 {\n+                        for sp in prior_arms {\n+                            err.span_label(*sp, format!(\n+                                \"this is found to be of type `{}`\",\n+                                last_ty,\n+                            ));\n+                        }\n+                    } else if let Some(sp) = prior_arms.last() {\n+                        err.span_label(*sp, format!(\n+                            \"this and all prior arms are found to be of type `{}`\", last_ty,\n+                        ));\n                     }\n                 }\n             },"}, {"sha": "655707ff9bd0da0f962192f28c0bd5d0eb690818", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -557,7 +557,7 @@ impl BuiltinLintDiagnostics {\n             }\n             BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n                 if !replaces.is_empty() {\n-                    db.multipart_suggestion(\n+                    db.tool_only_multipart_suggestion(\n                         &message,\n                         replaces,\n                         Applicability::MachineApplicable,"}, {"sha": "99d1e32d52398cdb15b7b048601c4f9e665cb820", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -145,6 +145,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::StartFunctionType => {\n                 tcx.sess.source_map().def_span(self.span)\n             }\n+            ObligationCauseCode::MatchExpressionArm { arm_span, .. } => arm_span,\n             _ => self.span,\n         }\n     }\n@@ -223,6 +224,8 @@ pub enum ObligationCauseCode<'tcx> {\n     MatchExpressionArm {\n         arm_span: Span,\n         source: hir::MatchSource,\n+        prior_arms: Vec<Span>,\n+        last_ty: Ty<'tcx>,\n     },\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression"}, {"sha": "b5be1777fa0d8804c7dbba9afa31aee9a86c157d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -513,10 +513,21 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 trait_item_def_id,\n             }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm { arm_span, source } => Some(super::MatchExpressionArm {\n+            super::MatchExpressionArm {\n                 arm_span,\n-                source: source,\n-            }),\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+            } => {\n+                tcx.lift(&last_ty).map(|last_ty| {\n+                    super::MatchExpressionArm {\n+                        arm_span,\n+                        source,\n+                        prior_arms: prior_arms.clone(),\n+                        last_ty,\n+                    }\n+                })\n+            }\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }"}, {"sha": "8144132832e50cbca7d3cfe625da98a2e7f4e230", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -465,33 +465,38 @@ impl CodegenCx<'b, 'tcx> {\n         self.declare_intrinsic(key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n     }\n \n+    fn insert_intrinsic(\n+        &self, name: &'static str, args: Option<&[&'b llvm::Type]>, ret: &'b llvm::Type\n+    ) -> &'b llvm::Value {\n+        let fn_ty = if let Some(args) = args {\n+            self.type_func(args, ret)\n+        } else {\n+            self.type_variadic_func(&[], ret)\n+        };\n+        let f = self.declare_cfn(name, fn_ty);\n+        llvm::SetUnnamedAddr(f, false);\n+        self.intrinsics.borrow_mut().insert(name, f.clone());\n+        f\n+    }\n+\n     fn declare_intrinsic(\n         &self,\n         key: &str\n     ) -> Option<&'b Value> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {\n-                    let f = self.declare_cfn($name, self.type_func(&[], $ret));\n-                    llvm::SetUnnamedAddr(f, false);\n-                    self.intrinsics.borrow_mut().insert($name, f.clone());\n-                    return Some(f);\n+                    return Some(self.insert_intrinsic($name, Some(&[]), $ret));\n                 }\n             );\n             ($name:expr, fn(...) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = self.declare_cfn($name, self.type_variadic_func(&[], $ret));\n-                    llvm::SetUnnamedAddr(f, false);\n-                    self.intrinsics.borrow_mut().insert($name, f.clone());\n-                    return Some(f);\n+                    return Some(self.insert_intrinsic($name, None, $ret));\n                 }\n             );\n             ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = self.declare_cfn($name, self.type_func(&[$($arg),*], $ret));\n-                    llvm::SetUnnamedAddr(f, false);\n-                    self.intrinsics.borrow_mut().insert($name, f.clone());\n-                    return Some(f);\n+                    return Some(self.insert_intrinsic($name, Some(&[$($arg),*]), $ret));\n                 }\n             );\n         }"}, {"sha": "851b19e8177b53917f37cf4a9bcab637fb5f2abe", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,4 +1,5 @@\n use crate::CodeSuggestion;\n+use crate::SuggestionStyle;\n use crate::SubstitutionPart;\n use crate::Substitution;\n use crate::Applicability;\n@@ -243,7 +244,33 @@ impl Diagnostic {\n                     .collect(),\n             }],\n             msg: msg.to_owned(),\n-            show_code_when_inline: true,\n+            style: SuggestionStyle::ShowCode,\n+            applicability,\n+        });\n+        self\n+    }\n+\n+    /// Prints out a message with for a multipart suggestion without showing the suggested code.\n+    ///\n+    /// This is intended to be used for suggestions that are obvious in what the changes need to\n+    /// be from the message, showing the span label inline would be visually unpleasant\n+    /// (marginally overlapping spans or multiline spans) and showing the snippet window wouldn't\n+    /// improve understandability.\n+    pub fn tool_only_multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: suggestion\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect(),\n+            }],\n+            msg: msg.to_owned(),\n+            style: SuggestionStyle::CompletelyHidden,\n             applicability,\n         });\n         self\n@@ -277,7 +304,7 @@ impl Diagnostic {\n                 }],\n             }],\n             msg: msg.to_owned(),\n-            show_code_when_inline: true,\n+            style: SuggestionStyle::ShowCode,\n             applicability,\n         });\n         self\n@@ -295,7 +322,7 @@ impl Diagnostic {\n                 }],\n             }).collect(),\n             msg: msg.to_owned(),\n-            show_code_when_inline: true,\n+            style: SuggestionStyle::ShowCode,\n             applicability,\n         });\n         self\n@@ -316,7 +343,51 @@ impl Diagnostic {\n                 }],\n             }],\n             msg: msg.to_owned(),\n-            show_code_when_inline: false,\n+            style: SuggestionStyle::HideCodeInline,\n+            applicability,\n+        });\n+        self\n+    }\n+\n+    /// Prints out a message with for a suggestion without showing the suggested code.\n+    ///\n+    /// This is intended to be used for suggestions that are obvious in what the changes need to\n+    /// be from the message, showing the span label inline would be visually unpleasant\n+    /// (marginally overlapping spans or multiline spans) and showing the snippet window wouldn't\n+    /// improve understandability.\n+    pub fn span_suggestion_hidden(\n+        &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n+            }],\n+            msg: msg.to_owned(),\n+            style: SuggestionStyle::HideCodeInline,\n+            applicability,\n+        });\n+        self\n+    }\n+\n+    /// Adds a suggestion to the json output, but otherwise remains silent/undisplayed in the cli.\n+    ///\n+    /// This is intended to be used for suggestions that are *very* obvious in what the changes\n+    /// need to be from the message, but we still want other tools to be able to apply them.\n+    pub fn tool_only_span_suggestion(\n+        &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n+            }],\n+            msg: msg.to_owned(),\n+            style: SuggestionStyle::CompletelyHidden,\n             applicability: applicability,\n         });\n         self"}, {"sha": "8a30790174d45bec2886204aaff5dc2a2c211e48", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -205,6 +205,24 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    pub fn tool_only_multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        if !self.allow_suggestions {\n+            return self\n+        }\n+        self.diagnostic.tool_only_multipart_suggestion(\n+            msg,\n+            suggestion,\n+            applicability,\n+        );\n+        self\n+    }\n+\n+\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n@@ -261,6 +279,45 @@ impl<'a> DiagnosticBuilder<'a> {\n         );\n         self\n     }\n+\n+    pub fn span_suggestion_hidden(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        if !self.allow_suggestions {\n+            return self\n+        }\n+        self.diagnostic.span_suggestion_hidden(\n+            sp,\n+            msg,\n+            suggestion,\n+            applicability,\n+        );\n+        self\n+    }\n+\n+    pub fn tool_only_span_suggestion(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        if !self.allow_suggestions {\n+            return self\n+        }\n+        self.diagnostic.tool_only_span_suggestion(\n+            sp,\n+            msg,\n+            suggestion,\n+            applicability,\n+        );\n+        self\n+    }\n+\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n "}, {"sha": "e9f269b6e2410b311fbee1c6ad15fd632baf17fe", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 64, "deletions": 32, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,10 @@ use Destination::*;\n \n use syntax_pos::{SourceFile, Span, MultiSpan};\n \n-use crate::{Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, SourceMapperDyn, DiagnosticId};\n+use crate::{\n+    Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic,\n+    SuggestionStyle, SourceMapperDyn, DiagnosticId,\n+};\n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use crate::styled_buffer::StyledBuffer;\n \n@@ -43,9 +46,14 @@ impl Emitter for EmitterWriter {\n                // don't display long messages as labels\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n-               !sugg.substitutions[0].parts[0].snippet.contains('\\n') {\n+               !sugg.substitutions[0].parts[0].snippet.contains('\\n') &&\n+               // when this style is set we want the suggestion to be a message, not inline\n+               sugg.style != SuggestionStyle::HideCodeAlways &&\n+               // trivial suggestion for tooling's sake, never shown\n+               sugg.style != SuggestionStyle::CompletelyHidden\n+            {\n                 let substitution = &sugg.substitutions[0].parts[0].snippet.trim();\n-                let msg = if substitution.len() == 0 || !sugg.show_code_when_inline {\n+                let msg = if substitution.len() == 0 || sugg.style.hide_inline() {\n                     // This substitution is only removal or we explicitly don't want to show the\n                     // code inline, don't show it\n                     format!(\"help: {}\", sugg.msg)\n@@ -942,14 +950,15 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn emit_message_default(&mut self,\n-                            msp: &MultiSpan,\n-                            msg: &[(String, Style)],\n-                            code: &Option<DiagnosticId>,\n-                            level: &Level,\n-                            max_line_num_len: usize,\n-                            is_secondary: bool)\n-                            -> io::Result<()> {\n+    fn emit_message_default(\n+        &mut self,\n+        msp: &MultiSpan,\n+        msg: &[(String, Style)],\n+        code: &Option<DiagnosticId>,\n+        level: &Level,\n+        max_line_num_len: usize,\n+        is_secondary: bool,\n+    ) -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n         let header_style = if is_secondary {\n             Style::HeaderMsg\n@@ -1184,11 +1193,12 @@ impl EmitterWriter {\n \n     }\n \n-    fn emit_suggestion_default(&mut self,\n-                               suggestion: &CodeSuggestion,\n-                               level: &Level,\n-                               max_line_num_len: usize)\n-                               -> io::Result<()> {\n+    fn emit_suggestion_default(\n+        &mut self,\n+        suggestion: &CodeSuggestion,\n+        level: &Level,\n+        max_line_num_len: usize,\n+    ) -> io::Result<()> {\n         if let Some(ref sm) = self.sm {\n             let mut buffer = StyledBuffer::new();\n \n@@ -1198,11 +1208,13 @@ impl EmitterWriter {\n                 buffer.append(0, &level_str, Style::Level(level.clone()));\n                 buffer.append(0, \": \", Style::HeaderMsg);\n             }\n-            self.msg_to_buffer(&mut buffer,\n-                               &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                               max_line_num_len,\n-                               \"suggestion\",\n-                               Some(Style::HeaderMsg));\n+            self.msg_to_buffer(\n+                &mut buffer,\n+                &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+                max_line_num_len,\n+                \"suggestion\",\n+                Some(Style::HeaderMsg),\n+            );\n \n             // Render the replacements for each suggestion\n             let suggestions = suggestion.splice_lines(&**sm);\n@@ -1340,22 +1352,42 @@ impl EmitterWriter {\n                 if !self.short_message {\n                     for child in children {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n-                        match self.emit_message_default(&span,\n-                                                        &child.styled_message(),\n-                                                        &None,\n-                                                        &child.level,\n-                                                        max_line_num_len,\n-                                                        true) {\n+                        match self.emit_message_default(\n+                            &span,\n+                            &child.styled_message(),\n+                            &None,\n+                            &child.level,\n+                            max_line_num_len,\n+                            true,\n+                        ) {\n                             Err(e) => panic!(\"failed to emit error: {}\", e),\n                             _ => ()\n                         }\n                     }\n                     for sugg in suggestions {\n-                        match self.emit_suggestion_default(sugg,\n-                                                           &Level::Help,\n-                                                           max_line_num_len) {\n-                            Err(e) => panic!(\"failed to emit error: {}\", e),\n-                            _ => ()\n+                        if sugg.style == SuggestionStyle::CompletelyHidden {\n+                            // do not display this suggestion, it is meant only for tools\n+                        } else if sugg.style == SuggestionStyle::HideCodeAlways {\n+                            match self.emit_message_default(\n+                                &MultiSpan::new(),\n+                                &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                &None,\n+                                &Level::Help,\n+                                max_line_num_len,\n+                                true,\n+                            ) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        } else {\n+                            match self.emit_suggestion_default(\n+                                sugg,\n+                                &Level::Help,\n+                                max_line_num_len,\n+                            ) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "87b47515268359b1331af2c676fd278fb14b02a3", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -69,6 +69,29 @@ pub enum Applicability {\n     Unspecified,\n }\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, RustcEncodable, RustcDecodable)]\n+pub enum SuggestionStyle {\n+    /// Hide the suggested code when displaying this suggestion inline.\n+    HideCodeInline,\n+    /// Always hide the suggested code but display the message.\n+    HideCodeAlways,\n+    /// Do not display this suggestion in the cli output, it is only meant for tools.\n+    CompletelyHidden,\n+    /// Always show the suggested code.\n+    /// This will *not* show the code if the suggestion is inline *and* the suggested code is\n+    /// empty.\n+    ShowCode,\n+}\n+\n+impl SuggestionStyle {\n+    fn hide_inline(&self) -> bool {\n+        match *self {\n+            SuggestionStyle::ShowCode => false,\n+            _ => true,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct CodeSuggestion {\n     /// Each substitute can have multiple variants due to multiple\n@@ -94,7 +117,8 @@ pub struct CodeSuggestion {\n     /// ```\n     pub substitutions: Vec<Substitution>,\n     pub msg: String,\n-    pub show_code_when_inline: bool,\n+    /// Visual representation of this suggestion.\n+    pub style: SuggestionStyle,\n     /// Whether or not the suggestion is approximate\n     ///\n     /// Sometimes we may show suggestions with placeholders,"}, {"sha": "9ac582ebc42dab1b0cf0133606de3c81d4da7a59", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -37,7 +37,7 @@ extern {}\n ```\n \n See more:\n-https://doc.rust-lang.org/book/first-edition/conditional-compilation.html\n+https://doc.rust-lang.org/reference/attributes.html#conditional-compilation\n \"##,\n \n E0458: r##\""}, {"sha": "7be7f4b439289bc0615fc703f2711f9947fd0bd6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n@@ -21,7 +21,8 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, RawConst, ConstValue, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Operand, Immediate, Scalar, Pointer,\n+    RawConst, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -77,7 +78,7 @@ pub fn op_to_const<'tcx>(\n     let normalized_op = if normalize {\n         ecx.try_read_immediate(op)?\n     } else {\n-        match op.op {\n+        match *op {\n             Operand::Indirect(mplace) => Err(mplace),\n             Operand::Immediate(val) => Ok(val)\n         }\n@@ -105,15 +106,6 @@ pub fn op_to_const<'tcx>(\n     Ok(ty::Const { val, ty: op.layout.ty })\n }\n \n-pub fn lazy_const_to_op<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n-    cnst: ty::LazyConst<'tcx>,\n-    ty: ty::Ty<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(ty)? })\n-}\n-\n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n@@ -388,10 +380,8 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn ptr_op(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        _left: Scalar,\n-        _left_layout: TyLayout<'tcx>,\n-        _right: Scalar,\n-        _right_layout: TyLayout<'tcx>,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n@@ -486,7 +476,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n-        let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n+        let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(value), value.ty)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -512,7 +502,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n+    let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n "}, {"sha": "31aa3c2782697184f614251c22b43003ecb54b33", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -690,7 +690,7 @@ fn main() {\n }\n ```\n \n-See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n \"##,\n \n E0373: r##\"\n@@ -873,7 +873,7 @@ that at most one writer or multiple readers can access the data at any one time.\n If you wish to learn more about ownership in Rust, start with the chapter in the\n Book:\n \n-https://doc.rust-lang.org/book/first-edition/ownership.html\n+https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n \"##,\n \n E0383: r##\"\n@@ -1207,7 +1207,7 @@ let mut a = &mut i;\n \n Please note that in rust, you can either have many immutable references, or one\n mutable reference. Take a look at\n-https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\n information. Example:\n \n \n@@ -1374,7 +1374,7 @@ fn foo(a: &mut i32) {\n ```\n \n For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/stable/book/references-and-borrowing.html.\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n \"##,\n \n E0503: r##\"\n@@ -1430,7 +1430,7 @@ fn main() {\n ```\n \n You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n \"##,\n \n E0504: r##\"\n@@ -1614,7 +1614,7 @@ fn main() {\n ```\n \n You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n \"##,\n \n E0506: r##\"\n@@ -1825,7 +1825,7 @@ mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n ```\n \n You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n \"##,\n \n E0508: r##\""}, {"sha": "ce62d79e585a8bbf32d5695216950f18f73424e0", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, Immediate};\n+use super::{EvalContext, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -372,7 +372,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field_layout.size, src.layout.size);\n                             // just sawp out the layout\n-                            OpTy { op: src.op, layout: src_field_layout }\n+                            OpTy::from(ImmTy { imm: src.to_immediate(), layout: src_field_layout })\n                         }\n                     };\n                     if src_field.layout.ty == dst_field.layout.ty {"}, {"sha": "e002c3fd511d6d780a80e731f283b3f22ba53efb", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let is_add = intrinsic_name == \"saturating_add\";\n-                let (val, overflowed) = self.binary_op_imm(if is_add {\n+                let (val, overflowed) = self.binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n                     BinOp::Sub\n@@ -173,7 +173,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op_imm(bin_op, l, r)?;\n+                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "7fb4c47d92acb4d4d12c64fd47a18a130f5a5149", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    EvalContext, PlaceTy, MPlaceTy, OpTy, Pointer, MemoryKind,\n+    EvalContext, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -158,10 +158,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar<Self::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<Self::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n+        left: ImmTy<'tcx, Self::PointerTag>,\n+        right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword."}, {"sha": "7da907028eebfd542a5bd62032991f77294d7b07", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -11,7 +11,10 @@ use rustc::mir::interpret::{\n     ConstValue, Pointer, Scalar,\n     EvalResult, EvalErrorKind,\n };\n-use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n+use super::{\n+    EvalContext, Machine, AllocMap, Allocation, AllocationExtra,\n+    MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n+};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n \n /// A `Value` represents a single immediate self-contained Rust value.\n@@ -41,6 +44,11 @@ impl Immediate {\n }\n \n impl<'tcx, Tag> Immediate<Tag> {\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>) -> Self {\n+        Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n+    }\n+\n     #[inline]\n     pub fn erase_tag(self) -> Immediate\n     {\n@@ -112,15 +120,15 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    immediate: Immediate<Tag>,\n+    pub imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n-        &self.immediate\n+        &self.imm\n     }\n }\n \n@@ -180,7 +188,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    crate op: Operand<Tag>, // ideally we'd make this private, but const_prop needs this\n+    op: Operand<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -206,12 +214,25 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy {\n-            op: Operand::Immediate(val.immediate),\n+            op: Operand::Immediate(val.imm),\n             layout: val.layout\n         }\n     }\n }\n \n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n+{\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n+        ImmTy { imm: Immediate::from_scalar(val), layout }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(self) -> EvalResult<'tcx, u128> {\n+        self.to_scalar()?.to_bits(self.layout.size)\n+    }\n+}\n+\n impl<'tcx, Tag> OpTy<'tcx, Tag>\n {\n     #[inline]\n@@ -324,8 +345,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(immediate) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { immediate, layout: op.layout })\n+        if let Ok(imm) = self.try_read_immediate(op)? {\n+            Ok(ImmTy { imm, layout: op.layout })\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -469,6 +490,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(OpTy { op, layout })\n     }\n \n+    /// Every place can be read from, so we can turm them into an operand\n+    #[inline(always)]\n+    pub fn place_to_op(\n+        &self,\n+        place: PlaceTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let op = match *place {\n+            Place::Ptr(mplace) => {\n+                Operand::Indirect(mplace)\n+            }\n+            Place::Local { frame, local } =>\n+                *self.stack[frame].locals[local].access()?\n+        };\n+        Ok(OpTy { op, layout: place.layout })\n+    }\n+\n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n     fn eval_place_to_op(\n@@ -531,10 +568,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when miri runs into a constant, and by CTFE.\n-    // FIXME: CTFE should use allocations, then we can make this private (embed it into\n-    // `eval_operand`, ideally).\n-    pub(crate) fn const_value_to_op(\n+    // Used when Miri runs into a constant, and (indirectly through lazy_const_to_op) by CTFE.\n+    fn const_value_to_op(\n         &self,\n         val: ty::LazyConst<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n@@ -666,3 +701,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n }\n+\n+impl<'a, 'mir, 'tcx, M> EvalContext<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<(), M::AllocExtra>)>,\n+    M::AllocExtra: AllocationExtra<(), M::MemoryExtra>,\n+{\n+    // FIXME: CTFE should use allocations, then we can remove this.\n+    pub(crate) fn lazy_const_to_op(\n+        &self,\n+        cnst: ty::LazyConst<'tcx>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = self.const_value_to_op(cnst)?;\n+        Ok(OpTy { op, layout: self.layout_of(ty)? })\n+    }\n+}"}, {"sha": "b3b9c742d6c282bc020aaaa879d3a07d9029da3b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, _overflowed) = self.binary_op(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n }\n@@ -272,83 +272,70 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok((val, false))\n     }\n \n-    /// Convenience wrapper that's useful when keeping the layout together with the\n-    /// immediate value.\n+    /// Returns the result of the specified operation and whether it overflowed.\n     #[inline]\n-    pub fn binary_op_imm(\n+    pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n-        self.binary_op(\n-            bin_op,\n-            left.to_scalar()?, left.layout,\n-            right.to_scalar()?, right.layout,\n-        )\n-    }\n-\n-    /// Returns the result of the specified operation and whether it overflowed.\n-    pub fn binary_op(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Scalar<M::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<M::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-            bin_op, left, left_layout.ty, right, right_layout.ty);\n+            bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n-        match left_layout.ty.sty {\n+        match left.layout.ty.sty {\n             ty::Char => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_char()?;\n-                let right = right.to_char()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_char()?;\n+                let right = right.to_scalar()?.to_char()?;\n                 self.binary_char_op(bin_op, left, right)\n             }\n             ty::Bool => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bool()?;\n-                let right = right.to_bool()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_bool()?;\n+                let right = right.to_scalar()?.to_bool()?;\n                 self.binary_bool_op(bin_op, left, right)\n             }\n             ty::Float(fty) => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bits(left_layout.size)?;\n-                let right = right.to_bits(right_layout.size)?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_bits()?;\n+                let right = right.to_bits()?;\n                 self.binary_float_op(bin_op, fty, left, right)\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(left_layout.ty.is_integral() || left_layout.ty.is_unsafe_ptr() ||\n-                    left_layout.ty.is_fn());\n-                assert!(right_layout.ty.is_integral() || right_layout.ty.is_unsafe_ptr() ||\n-                    right_layout.ty.is_fn());\n+                assert!(left.layout.ty.is_integral() || left.layout.ty.is_unsafe_ptr() ||\n+                    left.layout.ty.is_fn());\n+                assert!(right.layout.ty.is_integral() || right.layout.ty.is_unsafe_ptr() ||\n+                    right.layout.ty.is_fn());\n \n                 // Handle operations that support pointer values\n-                if left.is_ptr() || right.is_ptr() || bin_op == mir::BinOp::Offset {\n-                    return M::ptr_op(self, bin_op, left, left_layout, right, right_layout);\n+                if left.to_scalar_ptr()?.is_ptr() ||\n+                    right.to_scalar_ptr()?.is_ptr() ||\n+                    bin_op == mir::BinOp::Offset\n+                {\n+                    return M::ptr_op(self, bin_op, left, right);\n                 }\n \n                 // Everything else only works with \"proper\" bits\n-                let left = left.to_bits(left_layout.size).expect(\"we checked is_ptr\");\n-                let right = right.to_bits(right_layout.size).expect(\"we checked is_ptr\");\n-                self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n+                let l = left.to_bits().expect(\"we checked is_ptr\");\n+                let r = right.to_bits().expect(\"we checked is_ptr\");\n+                self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n         }\n     }\n \n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: Scalar<M::PointerTag>,\n-        layout: TyLayout<'tcx>,\n+        val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n+        let layout = val.layout;\n+        let val = val.to_scalar()?;\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n \n         match layout.ty.sty {"}, {"sha": "b29e09900f6b1e2e1dc0b67eeda4ce7bb8c46837", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -244,10 +244,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n-        match self.op {\n+        match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(imm) => Err(imm),\n         }\n@@ -487,9 +487,9 @@ where\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n-                let n = *self.frame().locals[local].access()?;\n-                let n_layout = self.layout_of(self.tcx.types.usize)?;\n-                let n = self.read_scalar(OpTy { op: n, layout: n_layout })?;\n+                let layout = self.layout_of(self.tcx.types.usize)?;\n+                let n = self.access_local(self.frame(), local, Some(layout))?;\n+                let n = self.read_scalar(n)?;\n                 let n = n.to_bits(self.tcx.data_layout.pointer_size)?;\n                 self.mplace_field(base, u64::try_from(n).unwrap())?\n             }\n@@ -991,22 +991,6 @@ where\n         Ok(())\n     }\n \n-    /// Every place can be read from, so we can turm them into an operand\n-    #[inline(always)]\n-    pub fn place_to_op(\n-        &self,\n-        place: PlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match place.place {\n-            Place::Ptr(mplace) => {\n-                Operand::Indirect(mplace)\n-            }\n-            Place::Local { frame, local } =>\n-                *self.stack[frame].locals[local].access()?\n-        };\n-        Ok(OpTy { op, layout: place.layout })\n-    }\n-\n     pub fn raw_const_to_mplace(\n         &self,\n         raw: RawConst<'tcx>,"}, {"sha": "97ef2b5fa3485342b1b58689ed74e204fb3b1721", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n+                let val = self.unary_op(un_op, val)?;\n                 self.write_scalar(val, dest)?;\n             }\n "}, {"sha": "c2ee3f5715bd370bafa580a2acbb1522affdaeb2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -7,7 +7,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Immediate, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -51,8 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // Compare using binary_op, to also support pointer values\n                     let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n-                        discr.to_scalar()?, discr.layout,\n-                        const_int, discr.layout,\n+                        discr,\n+                        ImmTy::from_scalar(const_int, discr.layout),\n                     )?;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n@@ -418,8 +418,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let mut args = args.to_vec();\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n-                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?;\n-                args[0].op = Operand::Immediate(Immediate::Scalar(ptr.ptr.into())); // strip vtable\n+                args[0] = OpTy::from(ImmTy { // strip vtable\n+                    layout: self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?,\n+                    imm: Immediate::Scalar(ptr.ptr.into())\n+                });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n@@ -448,8 +450,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             _ => (instance, place),\n         };\n \n-        let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref()),\n+        let arg = ImmTy {\n+            imm: place.to_ref(),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n@@ -460,7 +462,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             instance,\n             span,\n             Abi::Rust,\n-            &[arg],\n+            &[arg.into()],\n             Some(dest.into()),\n             Some(target),\n         )"}, {"sha": "1b0a9b17d3686cab83e21d001292b571fa1a859a", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -22,6 +22,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n+            // This means we guarantee that there are no duplicate vtables, we will\n+            // always use the same vtable for the same (Type, Trait) combination.\n+            // That's not what happens in rustc, but emulating per-crate deduplication\n+            // does not sound like it actually makes anything any better.\n             return Ok(Pointer::from(vtable).with_default_tag());\n         }\n "}, {"sha": "7da00c4ea0c36f0d7bb1a80ce9f9308e47cf12d0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -18,10 +18,9 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n+use crate::interpret::{EvalContext, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n-    lazy_const_to_op,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -254,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match lazy_const_to_op(&self.ecx, *c.literal, c.ty) {\n+        match self.ecx.lazy_const_to_op(*c.literal, c.ty) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },\n@@ -345,15 +344,15 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    OpTy {\n-                        op: interpret::Operand::Immediate(Immediate::Scalar(\n+                    ImmTy {\n+                        imm: Immediate::Scalar(\n                             Scalar::Bits {\n                                 bits: n as u128,\n                                 size: self.tcx.data_layout.pointer_size.bytes() as u8,\n                             }.into()\n-                        )),\n+                        ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    },\n+                    }.into(),\n                     span,\n                 )))\n             }\n@@ -371,13 +370,12 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n                 let (arg, _) = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n-                    let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    let prim = this.ecx.read_immediate(arg)?;\n                     match op {\n                         UnOp::Neg => {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n-                            let size = arg.layout.size;\n-                            if prim.to_bits(size)? == (1 << (size.bits() - 1)) {\n+                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n                                 return err!(OverflowNeg);\n                             }\n                         }\n@@ -386,13 +384,13 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         }\n                     }\n                     // Now run the actual operation.\n-                    this.ecx.unary_op(op, prim, arg.layout)\n+                    this.ecx.unary_op(op, prim)\n                 })?;\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(Immediate::Scalar(val.into())),\n+                let res = ImmTy {\n+                    imm: Immediate::Scalar(val.into()),\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -447,7 +445,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op_imm(op, l, r)\n+                    this.ecx.binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair(\n@@ -462,11 +460,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     }\n                     Immediate::Scalar(val.into())\n                 };\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(val),\n+                let res = ImmTy {\n+                    imm: val,\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             },\n         }\n     }"}, {"sha": "8ab9a8e8dda86484356ea118ca322675e466888b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -614,11 +614,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     Some(def) if def != HirDef::Err => def,\n                     _ => self.get_path_def(self.tcx.hir().get_parent_node(id)),\n                 }\n-            },\n+            }\n+\n             Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n-            }) |\n+            }) => {\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                self.tables.qpath_def(qpath, hir_id)\n+            }\n+\n             Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Path(ref qpath),\n                 .."}, {"sha": "0e6ab5b1eb3b20621973fc0e8e1f4f2474b46b0a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -689,6 +689,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n         };\n \n+        let mut other_arms = vec![];  // used only for diagnostics\n+        let mut prior_arm_ty = None;\n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n             if let Some(ref g) = arm.guard {\n                 self.diverges.set(pats_diverge);\n@@ -709,17 +711,36 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 _ => false\n             };\n \n+            let arm_span = if let hir::ExprKind::Block(ref blk, _) = arm.body.node {\n+                // Point at the block expr instead of the entire block\n+                blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n+            } else {\n+                arm.body.span\n+            };\n             if is_if_let_fallback {\n                 let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n                 assert!(arm_ty.is_unit());\n                 coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n             } else {\n-                let cause = self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n-                    arm_span: arm.body.span,\n-                    source: match_src\n-                });\n+                let cause = if i == 0 {\n+                    // The reason for the first arm to fail is not that the match arms diverge,\n+                    // but rather that there's a prior obligation that doesn't hold.\n+                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.id))\n+                } else {\n+                    self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                        arm_span,\n+                        source: match_src,\n+                        prior_arms: other_arms.clone(),\n+                        last_ty: prior_arm_ty.unwrap(),\n+                    })\n+                };\n                 coercion.coerce(self, &cause, &arm.body, arm_ty);\n             }\n+            other_arms.push(arm_span);\n+            if other_arms.len() > 5 {\n+                other_arms.remove(0);\n+            }\n+            prior_arm_ty = Some(arm_ty);\n         }\n \n         // We won't diverge unless the discriminant or all arms diverge."}, {"sha": "8b80fba4d19d01e096b72c3d5a033a5f9c442f09", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -210,7 +210,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// opt.map(|arg| { takes_ref(arg) });\n     /// ```\n-    fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n+    fn can_use_as_ref(\n+        &self,\n+        expr: &hir::Expr,\n+    ) -> Option<(Span, &'static str, String)> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir().get_parent_node(id);\n@@ -233,10 +236,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self_ty.starts_with(\"std::option::Option\") ||\n                             self_ty.starts_with(\"std::result::Result\")\n                         ) && (name == \"map\" || name == \"and_then\");\n-                        if is_as_ref_able {\n-                            return Some((span.shrink_to_lo(),\n-                                         \"consider using `as_ref` instead\",\n-                                         \"as_ref().\".into()));\n+                        match (is_as_ref_able, self.sess().source_map().span_to_snippet(*span)) {\n+                            (true, Ok(src)) => {\n+                                return Some((*span, \"consider using `as_ref` instead\",\n+                                             format!(\"as_ref().{}\", src)));\n+                            },\n+                            _ => ()\n                         }\n                     }\n                 }\n@@ -430,7 +435,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match expr.node {\n             // All built-in range literals but `..=` and `..` desugar to Structs\n-            ExprKind::Struct(QPath::Resolved(None, ref path), _, _) |\n+            ExprKind::Struct(ref qpath, _, _) => {\n+                if let QPath::Resolved(None, ref path) = **qpath {\n+                    return is_range_path(&path) && span_is_range_literal(&expr.span);\n+                }\n+            }\n             // `..` desugars to its struct path\n             ExprKind::Path(QPath::Resolved(None, ref path)) => {\n                 return is_range_path(&path) && span_is_range_literal(&expr.span);"}, {"sha": "71767fcfd49339ad5256d7c9b8a0e45209fe21d7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-linelength\n #![allow(non_snake_case)]\n \n register_long_diagnostics! {\n@@ -1544,7 +1545,9 @@ fn f<T>() {}\n \n It is not possible to declare type parameters on a function that has the `start`\n attribute. Such a function must have the following type signature (for more\n-information: http://doc.rust-lang.org/stable/book/first-edition/no-stdlib.html):\n+information, view [the unstable book][1]):\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n \n ```\n # let _:\n@@ -2918,10 +2921,11 @@ impl Baz for Bar { } // Note: This is OK\n \n E0374: r##\"\n A struct without a field containing an unsized type cannot implement\n-`CoerceUnsized`. An\n-[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)\n-is any type that the compiler doesn't know the length or alignment of at\n-compile time. Any struct containing an unsized type is also unsized.\n+`CoerceUnsized`. An [unsized type][1] is any type that the compiler\n+doesn't know the length or alignment of at compile time. Any struct\n+containing an unsized type is also unsized.\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n \n Example of erroneous code:\n \n@@ -2978,9 +2982,9 @@ A struct with more than one field containing an unsized type cannot implement\n `CoerceUnsized`. This only occurs when you are trying to coerce one of the\n types in your struct to another type in the struct. In this case we try to\n impl `CoerceUnsized` from `T` to `U` which are both types that the struct\n-takes. An [unsized type] is any type that the compiler doesn't know the length\n-or alignment of at compile time. Any struct containing an unsized type is also\n-unsized.\n+takes. An [unsized type][1] is any type that the compiler doesn't know the\n+length or alignment of at compile time. Any struct containing an unsized type\n+is also unsized.\n \n Example of erroneous code:\n \n@@ -3025,19 +3029,20 @@ fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {\n }\n ```\n \n-[unsized type]: https://doc.rust-lang.org/book/first-edition/unsized-types.html\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n \"##,\n \n E0376: r##\"\n The type you are trying to impl `CoerceUnsized` for is not a struct.\n `CoerceUnsized` can only be implemented for a struct. Unsized types are\n already able to be coerced without an implementation of `CoerceUnsized`\n whereas a struct containing an unsized type needs to know the unsized type\n-field it's containing is able to be coerced. An\n-[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)\n+field it's containing is able to be coerced. An [unsized type][1]\n is any type that the compiler doesn't know the length or alignment of at\n compile time. Any struct containing an unsized type is also unsized.\n \n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n+\n Example of erroneous code:\n \n ```compile_fail,E0376\n@@ -3883,8 +3888,10 @@ let c = 86u8 as char; // ok!\n assert_eq!(c, 'V');\n ```\n \n-For more information about casts, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+For more information about casts, take a look at the Type cast section in\n+[The Reference Book][1].\n+\n+[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n \"##,\n \n E0605: r##\"\n@@ -3912,8 +3919,10 @@ let v = 0 as *const u8;\n v as *const i8; // ok!\n ```\n \n-For more information about casts, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+For more information about casts, take a look at the Type cast section in\n+[The Reference Book][1].\n+\n+[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n \"##,\n \n E0606: r##\"\n@@ -3934,8 +3943,10 @@ let x = &0u8;\n let y: u32 = *x as u32; // We dereference it first and then cast it.\n ```\n \n-For more information about casts, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+For more information about casts, take a look at the Type cast section in\n+[The Reference Book][1].\n+\n+[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n \"##,\n \n E0607: r##\"\n@@ -3961,8 +3972,10 @@ pointer holds is their size.\n \n To fix this error, don't try to cast directly between thin and fat pointers.\n \n-For more information about casts, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+For more information about casts, take a look at the Type cast section in\n+[The Reference Book][1].\n+\n+[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n \"##,\n \n E0609: r##\"\n@@ -4020,8 +4033,8 @@ println!(\"x: {}, y: {}\", variable.x, variable.y);\n ```\n \n For more information about primitives and structs, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/primitive-types.html\n-https://doc.rust-lang.org/book/first-edition/structs.html\n+https://doc.rust-lang.org/book/ch03-02-data-types.html\n+https://doc.rust-lang.org/book/ch05-00-structs.html\n \"##,\n \n E0614: r##\""}, {"sha": "3e3eab8cf4cfb2e19315195d1927c82f3bdbfad1", "filename": "src/librustc_typeck/structured_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibrustc_typeck%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fstructured_errors.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -137,7 +137,7 @@ To fix this error, don't try to cast directly between thin and fat\n pointers.\n \n For more information about casts, take a look at The Book:\n-https://doc.rust-lang.org/book/first-edition/casting-between-types.html\");\n+https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\");\n         err\n     }\n }"}, {"sha": "aa784746122db71e82ccc8896d491d67a2587333", "filename": "src/libstd/future.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -5,7 +5,7 @@ use core::marker::Unpin;\n use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n@@ -32,21 +32,21 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n-        set_task_waker(lw, || match gen.resume() {\n+        set_task_waker(waker, || match gen.resume() {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n     }\n }\n \n thread_local! {\n-    static TLS_WAKER: Cell<Option<NonNull<LocalWaker>>> = Cell::new(None);\n+    static TLS_WAKER: Cell<Option<NonNull<Waker>>> = Cell::new(None);\n }\n \n-struct SetOnDrop(Option<NonNull<LocalWaker>>);\n+struct SetOnDrop(Option<NonNull<Waker>>);\n \n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n@@ -58,12 +58,12 @@ impl Drop for SetOnDrop {\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n-pub fn set_task_waker<F, R>(lw: &LocalWaker, f: F) -> R\n+pub fn set_task_waker<F, R>(waker: &Waker, f: F) -> R\n where\n     F: FnOnce() -> R\n {\n     let old_waker = TLS_WAKER.with(|tls_waker| {\n-        tls_waker.replace(Some(NonNull::from(lw)))\n+        tls_waker.replace(Some(NonNull::from(waker)))\n     });\n     let _reset_waker = SetOnDrop(old_waker);\n     f()\n@@ -78,7 +78,7 @@ where\n /// retrieved by a surrounding call to get_task_waker.\n pub fn get_task_waker<F, R>(f: F) -> R\n where\n-    F: FnOnce(&LocalWaker) -> R\n+    F: FnOnce(&Waker) -> R\n {\n     let waker_ptr = TLS_WAKER.with(|tls_waker| {\n         // Clear the entry so that nested `get_task_waker` calls\n@@ -88,7 +88,7 @@ where\n     let _reset_waker = SetOnDrop(waker_ptr);\n \n     let waker_ptr = waker_ptr.expect(\n-        \"TLS LocalWaker not set. This is a rustc bug. \\\n+        \"TLS Waker not set. This is a rustc bug. \\\n         Please file an issue on https://github.com/rust-lang/rust.\");\n     unsafe { f(waker_ptr.as_ref()) }\n }\n@@ -99,5 +99,5 @@ pub fn poll_with_tls_waker<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_waker(|lw| F::poll(f, lw))\n+    get_task_waker(|waker| F::poll(f, waker))\n }"}, {"sha": "4f900e8cbad2d17be96337255645854191900459", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -463,8 +463,6 @@ pub mod task {\n     //! Types and Traits for working with asynchronous tasks.\n     #[doc(inline)]\n     pub use core::task::*;\n-    #[doc(inline)]\n-    pub use alloc_crate::task::*;\n }\n \n #[unstable(feature = \"futures_api\","}, {"sha": "862fdf051ccd10b1d6344c4802c18ed94246fba5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -12,7 +12,7 @@ use panicking;\n use ptr::{Unique, NonNull};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock, atomic};\n-use task::{LocalWaker, Poll};\n+use task::{Waker, Poll};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -323,9 +323,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, lw)\n+        F::poll(pinned_field, waker)\n     }\n }\n "}, {"sha": "551e982a3c68566397967b4122bd60829c3bc17e", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -129,10 +129,10 @@\n //! [`std::string`]: ../string/index.html\n //! [`std::vec`]: ../vec/index.html\n //! [`to_owned`]: ../borrow/trait.ToOwned.html#tymethod.to_owned\n-//! [book-closures]: ../../book/first-edition/closures.html\n-//! [book-dtor]: ../../book/first-edition/drop.html\n-//! [book-enums]: ../../book/first-edition/enums.html\n-//! [book-iter]: ../../book/first-edition/iterators.html\n+//! [book-closures]: ../../book/ch13-01-closures.html\n+//! [book-dtor]: ../../book/ch15-03-drop.html\n+//! [book-enums]: ../../book/ch06-01-defining-an-enum.html\n+//! [book-iter]: ../../book/ch13-02-iterators.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "5c7fb1b80446187007749a6e3ce55976def98eae", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -6,7 +6,7 @@\n //! benchmarks themselves) should be done via the `#[test]` and\n //! `#[bench]` attributes.\n //!\n-//! See the [Testing Chapter](../book/first-edition/testing.html) of the book for more details.\n+//! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.\n \n // Currently, not much of this is meant for users. It is intended to\n // support the simplest interface possible for representing and"}, {"sha": "b4f07ab33214cca85abd97673399deeaea057a9d", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -4,7 +4,7 @@\n use std::iter::Iterator;\n use std::future::Future;\n \n-use std::task::{Poll, LocalWaker};\n+use std::task::{Poll, Waker};\n use std::pin::Pin;\n use std::unimplemented;\n \n@@ -13,7 +13,7 @@ struct MyFuture;\n impl Future for MyFuture {\n    type Output = u32;\n \n-   fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<u32> {\n+   fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<u32> {\n       Poll::Pending\n    }\n }"}, {"sha": "1843feed927a23ede730677397cdf7196c78b8a8", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,25 +1,28 @@\n // edition:2018\n+// aux-build:arc_wake.rs\n \n #![feature(arbitrary_self_types, async_await, await_macro, futures_api)]\n \n+extern crate arc_wake;\n+\n use std::pin::Pin;\n use std::future::Future;\n use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    LocalWaker, Poll, Wake,\n-    local_waker_from_nonlocal,\n+    Poll, Waker,\n };\n+use arc_wake::ArcWake;\n \n struct Counter {\n     wakes: AtomicUsize,\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+impl ArcWake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n@@ -29,11 +32,11 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            lw.wake();\n+            waker.wake();\n             self.0 = true;\n             Poll::Pending\n         }\n@@ -130,7 +133,7 @@ where\n {\n     let mut fut = Box::pin(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n-    let waker = local_waker_from_nonlocal(counter.clone());\n+    let waker = ArcWake::into_waker(counter.clone());\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(Poll::Pending, fut.as_mut().poll(&waker));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));"}, {"sha": "034e378af7f19267fab999cfd1852bbc4db8b06a", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -0,0 +1,56 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, futures_api)]\n+\n+use std::sync::Arc;\n+use std::task::{\n+    Poll, Waker, RawWaker, RawWakerVTable,\n+};\n+\n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable {\n+            clone: clone_arc_raw::<$ty>,\n+            drop: drop_arc_raw::<$ty>,\n+            wake: wake_arc_raw::<$ty>,\n+        }\n+    };\n+}\n+\n+pub trait ArcWake {\n+    fn wake(arc_self: &Arc<Self>);\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const();\n+\n+        unsafe {\n+            Waker::new_unchecked(RawWaker::new(ptr, waker_vtable!(Self)))\n+        }\n+    }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n+\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker::new(data, waker_vtable!(T))\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(&arc);\n+    let _ = Arc::into_raw(arc);\n+}"}, {"sha": "fd4b585d3457273026d65391dcf3c03d3981ad36", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,71 +1,57 @@\n+// aux-build:arc_wake.rs\n+\n #![feature(arbitrary_self_types, futures_api)]\n #![allow(unused)]\n \n+extern crate arc_wake;\n+\n use std::future::Future;\n use std::pin::Pin;\n-use std::rc::Rc;\n use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    Poll, Wake, Waker, LocalWaker,\n-    local_waker, local_waker_from_nonlocal,\n+    Poll, Waker,\n };\n+use arc_wake::ArcWake;\n \n struct Counter {\n-    local_wakes: AtomicUsize,\n-    nonlocal_wakes: AtomicUsize,\n+    wakes: AtomicUsize,\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.nonlocal_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n-    }\n-\n-    unsafe fn wake_local(this: &Arc<Self>) {\n-        this.local_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+impl ArcWake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        // Wake once locally\n-        lw.wake();\n-        // Wake twice non-locally\n-        let waker = lw.clone().into_waker();\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        // Wake twice\n         waker.wake();\n         waker.wake();\n         Poll::Ready(())\n     }\n }\n \n-fn test_local_waker() {\n+fn test_waker() {\n     let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n+        wakes: AtomicUsize::new(0),\n     });\n-    let waker = unsafe { local_waker(counter.clone()) };\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n-}\n+    let waker = ArcWake::into_waker(counter.clone());\n+    assert_eq!(2, Arc::strong_count(&counter));\n \n-fn test_local_as_nonlocal_waker() {\n-    let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n-    });\n-    let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n     assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(2, counter.wakes.load(atomic::Ordering::SeqCst));\n+\n+    drop(waker);\n+    assert_eq!(1, Arc::strong_count(&counter));\n }\n \n fn main() {\n-    test_local_waker();\n-    test_local_as_nonlocal_waker();\n+    test_waker();\n }"}, {"sha": "3a6750151f7d8e138668ac54624c34f9dd8d84f3", "filename": "src/test/rustdoc-js/substring.js", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc-js%2Fsubstring.js", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc-js%2Fsubstring.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fsubstring.js?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,10 +0,0 @@\n-// exact-check\n-\n-const QUERY = 'waker_from';\n-\n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std::task', 'name': 'local_waker_from_nonlocal' },\n-        { 'path': 'alloc::task', 'name': 'local_waker_from_nonlocal' },\n-    ],\n-};"}, {"sha": "d7ec41489d15615b186138b92abd3f6f46a83905", "filename": "src/test/ui/bad/bad-lint-cap2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap2.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `std::option`\n   --> $DIR/bad-lint-cap2.rs:6:5\n    |\n LL | use std::option; //~ ERROR\n-   | ----^^^^^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/bad-lint-cap2.rs:4:9"}, {"sha": "5bf0b089afa20340b908341a8e8b4d00debec7e6", "filename": "src/test/ui/bad/bad-lint-cap3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-lint-cap3.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ warning: unused import: `std::option`\n   --> $DIR/bad-lint-cap3.rs:7:5\n    |\n LL | use std::option; //~ WARN\n-   | ----^^^^^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/bad-lint-cap3.rs:4:9"}, {"sha": "819f5dd1cfc352ca57e52014f66cd79cc33d0b8e", "filename": "src/test/ui/if/if-let-arm-types.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,10 +1,11 @@\n fn main() {\n-    if let Some(b) = None { //~ ERROR: `if let` arms have incompatible types\n-        //~^ expected (), found integer\n-        //~| expected type `()`\n-        //~| found type `{integer}`\n+    if let Some(b) = None {\n+        //~^ NOTE if let` arms have incompatible types\n         ()\n     } else {\n         1\n     };\n+    //~^^ ERROR: `if let` arms have incompatible types\n+    //~| NOTE expected (), found integer\n+    //~| NOTE expected type `()`\n }"}, {"sha": "6401a62c06ba26be8c4a85e72f014ee603c52a57", "filename": "src/test/ui/if/if-let-arm-types.stderr", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-let-arm-types.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,25 +1,17 @@\n error[E0308]: `if let` arms have incompatible types\n-  --> $DIR/if-let-arm-types.rs:2:5\n+  --> $DIR/if-let-arm-types.rs:6:9\n    |\n-LL | /     if let Some(b) = None { //~ ERROR: `if let` arms have incompatible types\n-LL | |         //~^ expected (), found integer\n-LL | |         //~| expected type `()`\n-LL | |         //~| found type `{integer}`\n-...  |\n+LL | /     if let Some(b) = None {\n+LL | |         //~^ NOTE if let` arms have incompatible types\n+LL | |         ()\n+LL | |     } else {\n LL | |         1\n+   | |         ^ expected (), found integer\n LL | |     };\n-   | |_____^ expected (), found integer\n+   | |_____- `if let` arms have incompatible types\n    |\n    = note: expected type `()`\n               found type `{integer}`\n-note: `if let` arm with an incompatible type\n-  --> $DIR/if-let-arm-types.rs:7:12\n-   |\n-LL |       } else {\n-   |  ____________^\n-LL | |         1\n-LL | |     };\n-   | |_____^\n \n error: aborting due to previous error\n "}, {"sha": "b56e930158cc1be5ec073716719021c9421c7da8", "filename": "src/test/ui/imports/unused.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fimports%2Funused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fimports%2Funused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funused.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `super::f`\n   --> $DIR/unused.rs:7:24\n    |\n LL |         pub(super) use super::f; //~ ERROR unused\n-   |         ---------------^^^^^^^^- help: remove the whole `use` item\n+   |                        ^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/unused.rs:1:9"}, {"sha": "726c437355e53cbef382f5706a69dd435def67a7", "filename": "src/test/ui/issues/issue-11319.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-11319.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-11319.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11319.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,12 +1,14 @@\n fn main() {\n     match Some(10) {\n-    //~^ ERROR match arms have incompatible types\n-    //~| expected type `bool`\n-    //~| found type `()`\n-    //~| expected bool, found ()\n+    //~^ NOTE `match` arms have incompatible types\n         Some(5) => false,\n+        //~^ NOTE this is found to be of type `bool`\n         Some(2) => true,\n+        //~^ NOTE this is found to be of type `bool`\n         None    => (),\n+        //~^ ERROR match arms have incompatible types\n+        //~| NOTE expected bool, found ()\n+        //~| NOTE expected type `bool`\n         _       => true\n     }\n }"}, {"sha": "10db477b8ca7bfd6fa9f3b2e13f6113f6ea3190e", "filename": "src/test/ui/issues/issue-11319.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-11319.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-11319.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11319.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -1,16 +1,20 @@\n error[E0308]: match arms have incompatible types\n-  --> $DIR/issue-11319.rs:2:5\n+  --> $DIR/issue-11319.rs:8:20\n    |\n LL | /     match Some(10) {\n-LL | |     //~^ ERROR match arms have incompatible types\n-LL | |     //~| expected type `bool`\n-LL | |     //~| found type `()`\n-...  |\n+LL | |     //~^ NOTE `match` arms have incompatible types\n+LL | |         Some(5) => false,\n+   | |                    ----- this is found to be of type `bool`\n+LL | |         //~^ NOTE this is found to be of type `bool`\n+LL | |         Some(2) => true,\n+   | |                    ---- this is found to be of type `bool`\n+LL | |         //~^ NOTE this is found to be of type `bool`\n LL | |         None    => (),\n-   | |                    -- match arm with an incompatible type\n+   | |                    ^^ expected bool, found ()\n+...  |\n LL | |         _       => true\n LL | |     }\n-   | |_____^ expected bool, found ()\n+   | |_____- `match` arms have incompatible types\n    |\n    = note: expected type `bool`\n               found type `()`"}, {"sha": "15cea1d609d5382baed28eef39e9d99add1a8b00", "filename": "src/test/ui/issues/issue-17728.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17728.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -97,7 +97,7 @@ impl Debug for Player {\n }\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n-    match to_parse { //~ ERROR match arms have incompatible types\n+    match to_parse {\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -108,6 +108,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"down\" => RoomDirection::Down,\n         _ => None\n     }\n+        //~^^ ERROR match arms have incompatible types\n }\n \n fn main() {"}, {"sha": "2c2efad19f5691ec076a5d63f2b4c9075436aef4", "filename": "src/test/ui/issues/issue-17728.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -10,17 +10,19 @@ LL |             Some(entry) => Ok(entry),\n    |                            ^^^^^^^^^ ...but data from `room` is returned here\n \n error[E0308]: match arms have incompatible types\n-  --> $DIR/issue-17728.rs:100:5\n+  --> $DIR/issue-17728.rs:109:14\n    |\n-LL | /     match to_parse { //~ ERROR match arms have incompatible types\n+LL | /     match to_parse {\n LL | |         \"w\" | \"west\" => RoomDirection::West,\n LL | |         \"e\" | \"east\" => RoomDirection::East,\n LL | |         \"n\" | \"north\" => RoomDirection::North,\n ...  |\n+LL | |         \"down\" => RoomDirection::Down,\n+   | |                   ------------------- this and all prior arms are found to be of type `RoomDirection`\n LL | |         _ => None\n-   | |              ---- match arm with an incompatible type\n+   | |              ^^^^ expected enum `RoomDirection`, found enum `std::option::Option`\n LL | |     }\n-   | |_____^ expected enum `RoomDirection`, found enum `std::option::Option`\n+   | |_____- `match` arms have incompatible types\n    |\n    = note: expected type `RoomDirection`\n               found type `std::option::Option<_>`"}, {"sha": "2f501b941b5a6108a86de4329cbcae1460e1bd63", "filename": "src/test/ui/issues/issue-24036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -6,11 +6,11 @@ fn closure_to_loc() {\n \n fn closure_from_match() {\n     let x = match 1usize {\n-    //~^ ERROR match arms have incompatible types\n         1 => |c| c + 1,\n         2 => |c| c - 1,\n         _ => |c| c - 1\n     };\n+    //~^^^ ERROR match arms have incompatible types\n }\n \n fn main() { }"}, {"sha": "fa9935fcf619dadc969f5736b336cfde854ab7ec", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -10,20 +10,20 @@ LL |     x = |c| c + 1;\n    = help: consider boxing your closure and/or using it as a trait object\n \n error[E0308]: match arms have incompatible types\n-  --> $DIR/issue-24036.rs:8:13\n+  --> $DIR/issue-24036.rs:10:14\n    |\n LL |       let x = match 1usize {\n-   |  _____________^\n-LL | |     //~^ ERROR match arms have incompatible types\n+   |  _____________-\n LL | |         1 => |c| c + 1,\n+   | |              --------- this is found to be of type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n LL | |         2 => |c| c - 1,\n-   | |              --------- match arm with an incompatible type\n+   | |              ^^^^^^^^^ expected closure, found a different closure\n LL | |         _ => |c| c - 1\n LL | |     };\n-   | |_____^ expected closure, found a different closure\n+   | |_____- `match` arms have incompatible types\n    |\n-   = note: expected type `[closure@$DIR/issue-24036.rs:10:14: 10:23]`\n-              found type `[closure@$DIR/issue-24036.rs:11:14: 11:23]`\n+   = note: expected type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n+              found type `[closure@$DIR/issue-24036.rs:10:14: 10:23]`\n    = note: no two closures, even if identical, have the same type\n    = help: consider boxing your closure and/or using it as a trait object\n "}, {"sha": "0a901076f467aabf0b1e6627f364890e9d70db8e", "filename": "src/test/ui/issues/issue-30730.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-30730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fissues%2Fissue-30730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30730.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `std::thread`\n   --> $DIR/issue-30730.rs:3:5\n    |\n LL | use std::thread;\n-   | ----^^^^^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/issue-30730.rs:2:9"}, {"sha": "170b98a12a848d275c311855be4273a1a93d0251", "filename": "src/test/ui/lint/lint-directives-on-use-items-issue-10534.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flint-directives-on-use-items-issue-10534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flint-directives-on-use-items-issue-10534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-directives-on-use-items-issue-10534.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `a::x`\n   --> $DIR/lint-directives-on-use-items-issue-10534.rs:12:9\n    |\n LL |     use a::x; //~ ERROR: unused import\n-   |     ----^^^^- help: remove the whole `use` item\n+   |         ^^^^\n    |\n note: lint level defined here\n   --> $DIR/lint-directives-on-use-items-issue-10534.rs:1:9\n@@ -14,7 +14,7 @@ error: unused import: `a::y`\n   --> $DIR/lint-directives-on-use-items-issue-10534.rs:21:9\n    |\n LL |     use a::y; //~ ERROR: unused import\n-   |     ----^^^^- help: remove the whole `use` item\n+   |         ^^^^\n    |\n note: lint level defined here\n   --> $DIR/lint-directives-on-use-items-issue-10534.rs:20:12"}, {"sha": "18f2fae0067eb94cdd9c313f1ab6641ec1e62433", "filename": "src/test/ui/lint/lint-unused-imports.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flint-unused-imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flint-unused-imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-imports.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `std::fmt::{}`\n   --> $DIR/lint-unused-imports.rs:8:5\n    |\n LL | use std::fmt::{};\n-   | ----^^^^^^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/lint-unused-imports.rs:1:9\n@@ -14,39 +14,37 @@ error: unused imports: `None`, `Some`\n   --> $DIR/lint-unused-imports.rs:12:27\n    |\n LL | use std::option::Option::{Some, None};\n-   | --------------------------^^^^--^^^^-- help: remove the whole `use` item\n+   |                           ^^^^  ^^^^\n \n error: unused import: `test::A`\n   --> $DIR/lint-unused-imports.rs:15:5\n    |\n LL | use test::A;       //~ ERROR unused import: `test::A`\n-   | ----^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^\n \n error: unused import: `bar`\n   --> $DIR/lint-unused-imports.rs:24:18\n    |\n LL | use test2::{foo, bar}; //~ ERROR unused import: `bar`\n-   |                --^^^\n-   |                |\n-   |                help: remove the unused import\n+   |                  ^^^\n \n error: unused import: `foo::Square`\n   --> $DIR/lint-unused-imports.rs:52:13\n    |\n LL |         use foo::Square; //~ ERROR unused import: `foo::Square`\n-   |         ----^^^^^^^^^^^- help: remove the whole `use` item\n+   |             ^^^^^^^^^^^\n \n error: unused import: `self::g`\n   --> $DIR/lint-unused-imports.rs:68:9\n    |\n LL |     use self::g; //~ ERROR unused import: `self::g`\n-   |     ----^^^^^^^- help: remove the whole `use` item\n+   |         ^^^^^^^\n \n error: unused import: `test2::foo`\n   --> $DIR/lint-unused-imports.rs:77:9\n    |\n LL |     use test2::foo; //~ ERROR unused import: `test2::foo`\n-   |     ----^^^^^^^^^^- help: remove the whole `use` item\n+   |         ^^^^^^^^^^\n \n error: unused import: `test::B2`\n   --> $DIR/lint-unused-imports.rs:20:5"}, {"sha": "8287ca5692bd98f3485f4d451bcc1166fd0954c0", "filename": "src/test/ui/lint/lints-in-foreign-macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ warning: unused import: `std::string::ToString`\n   --> $DIR/lints-in-foreign-macros.rs:11:16\n    |\n LL |     () => {use std::string::ToString;} //~ WARN: unused import\n-   |            ----^^^^^^^^^^^^^^^^^^^^^- help: remove the whole `use` item\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | mod a { foo!(); }\n    |         ------- in this macro invocation\n@@ -17,13 +17,13 @@ warning: unused import: `std::string::ToString`\n   --> $DIR/lints-in-foreign-macros.rs:16:18\n    |\n LL | mod c { baz!(use std::string::ToString;); } //~ WARN: unused import\n-   |              ----^^^^^^^^^^^^^^^^^^^^^- help: remove the whole `use` item\n+   |                  ^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused import: `std::string::ToString`\n   --> $DIR/lints-in-foreign-macros.rs:17:19\n    |\n LL | mod d { baz2!(use std::string::ToString;); } //~ WARN: unused import\n-   |               ----^^^^^^^^^^^^^^^^^^^^^- help: remove the whole `use` item\n+   |                   ^^^^^^^^^^^^^^^^^^^^^\n \n warning: missing documentation for crate\n   --> $DIR/lints-in-foreign-macros.rs:4:1"}, {"sha": "b4b84ef8f1cec796aaf37632c69f2f52437ff839", "filename": "src/test/ui/match/match-type-err-first-arm.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -0,0 +1,45 @@\n+fn main() {\n+    let _ = test_func1(1);\n+    let _ = test_func2(1);\n+}\n+\n+fn test_func1(n: i32) -> i32 {\n+    //~^ NOTE expected `i32` because of return type\n+    match n {\n+        12 => 'b',\n+        //~^ ERROR mismatched types\n+        //~| NOTE expected i32, found char\n+        _ => 42,\n+    }\n+}\n+\n+fn test_func2(n: i32) -> i32 {\n+    let x = match n {\n+    //~^ NOTE `match` arms have incompatible types\n+        12 => 'b',\n+        //~^ NOTE this is found to be of type `char`\n+        _ => 42,\n+        //~^ ERROR match arms have incompatible types\n+        //~| NOTE expected char, found integer\n+        //~| NOTE expected type `char`\n+    };\n+    x\n+}\n+\n+fn test_func3(n: i32) -> i32 {\n+    let x = match n {\n+    //~^ NOTE `match` arms have incompatible types\n+        1 => 'b',\n+        2 => 'b',\n+        3 => 'b',\n+        4 => 'b',\n+        5 => 'b',\n+        6 => 'b',\n+        //~^ NOTE this and all prior arms are found to be of type `char`\n+        _ => 42,\n+        //~^ ERROR match arms have incompatible types\n+        //~| NOTE expected char, found integer\n+        //~| NOTE expected type `char`\n+    };\n+    x\n+}"}, {"sha": "db8bef8dc77555f2964e1192d11efcb2d503bf35", "filename": "src/test/ui/match/match-type-err-first-arm.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -0,0 +1,53 @@\n+error[E0308]: mismatched types\n+  --> $DIR/match-type-err-first-arm.rs:9:15\n+   |\n+LL | fn test_func1(n: i32) -> i32 {\n+   |                          --- expected `i32` because of return type\n+...\n+LL |         12 => 'b',\n+   |               ^^^ expected i32, found char\n+\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/match-type-err-first-arm.rs:21:14\n+   |\n+LL |       let x = match n {\n+   |  _____________-\n+LL | |     //~^ NOTE `match` arms have incompatible types\n+LL | |         12 => 'b',\n+   | |               --- this is found to be of type `char`\n+LL | |         //~^ NOTE this is found to be of type `char`\n+LL | |         _ => 42,\n+   | |              ^^ expected char, found integer\n+...  |\n+LL | |         //~| NOTE expected type `char`\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `char`\n+              found type `{integer}`\n+\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/match-type-err-first-arm.rs:39:14\n+   |\n+LL |       let x = match n {\n+   |  _____________-\n+LL | |     //~^ NOTE `match` arms have incompatible types\n+LL | |         1 => 'b',\n+LL | |         2 => 'b',\n+...  |\n+LL | |         6 => 'b',\n+   | |              --- this and all prior arms are found to be of type `char`\n+LL | |         //~^ NOTE this and all prior arms are found to be of type `char`\n+LL | |         _ => 42,\n+   | |              ^^ expected char, found integer\n+...  |\n+LL | |         //~| NOTE expected type `char`\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `char`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "308035919260377fcf1e64ae1aded3dfbb9f4ec6", "filename": "src/test/ui/rfc-2166-underscore-imports/basic.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Fbasic.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ warning: unused import: `m::Tr1 as _`\n   --> $DIR/basic.rs:26:9\n    |\n LL |     use m::Tr1 as _; //~ WARN unused import\n-   |     ----^^^^^^^^^^^- help: remove the whole `use` item\n+   |         ^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/basic.rs:4:9\n@@ -14,5 +14,5 @@ warning: unused import: `S as _`\n   --> $DIR/basic.rs:27:9\n    |\n LL |     use S as _; //~ WARN unused import\n-   |     ----^^^^^^- help: remove the whole `use` item\n+   |         ^^^^^^\n "}, {"sha": "4163c2876074befdc95f7a8fda5184b84e03d9a2", "filename": "src/test/ui/rfc-2166-underscore-imports/unused-2018.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Funused-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Funused-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2166-underscore-imports%2Funused-2018.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused import: `core::any`\n   --> $DIR/unused-2018.rs:6:9\n    |\n LL |     use core::any; //~ ERROR unused import: `core::any`\n-   |     ----^^^^^^^^^- help: remove the whole `use` item\n+   |         ^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/unused-2018.rs:3:9\n@@ -14,7 +14,7 @@ error: unused import: `core`\n   --> $DIR/unused-2018.rs:10:9\n    |\n LL |     use core; //~ ERROR unused import: `core`\n-   |     ----^^^^- help: remove the whole `use` item\n+   |         ^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a730d081b7c035e0e2330fc5fce8029f09033665", "filename": "src/test/ui/span/multispan-import-lint.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -10,8 +10,4 @@ note: lint level defined here\n LL | #![warn(unused)]\n    |         ^^^^^^\n    = note: #[warn(unused_imports)] implied by #[warn(unused)]\n-help: remove the unused imports\n-   |\n-LL | use std::cmp::{min};\n-   |               -- --\n "}, {"sha": "8143acc957b4ca243a802a432355645c413dd6e0", "filename": "src/test/ui/suggestions/as-ref.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,9 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:6:27\n    |\n LL |   opt.map(|arg| takes_ref(arg));\n-   |       -                   ^^^ expected &Foo, found struct `Foo`\n+   |       ---                 ^^^ expected &Foo, found struct `Foo`\n    |       |\n-   |       help: consider using `as_ref` instead: `as_ref().`\n+   |       help: consider using `as_ref` instead: `as_ref().map`\n    |\n    = note: expected type `&Foo`\n               found type `Foo`\n@@ -13,9 +13,9 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:8:37\n    |\n LL |   opt.and_then(|arg| Some(takes_ref(arg)));\n-   |       -                             ^^^ expected &Foo, found struct `Foo`\n+   |       --------                      ^^^ expected &Foo, found struct `Foo`\n    |       |\n-   |       help: consider using `as_ref` instead: `as_ref().`\n+   |       help: consider using `as_ref` instead: `as_ref().and_then`\n    |\n    = note: expected type `&Foo`\n               found type `Foo`\n@@ -24,9 +24,9 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:11:27\n    |\n LL |   opt.map(|arg| takes_ref(arg));\n-   |       -                   ^^^ expected &Foo, found struct `Foo`\n+   |       ---                 ^^^ expected &Foo, found struct `Foo`\n    |       |\n-   |       help: consider using `as_ref` instead: `as_ref().`\n+   |       help: consider using `as_ref` instead: `as_ref().map`\n    |\n    = note: expected type `&Foo`\n               found type `Foo`\n@@ -35,9 +35,9 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:13:35\n    |\n LL |   opt.and_then(|arg| Ok(takes_ref(arg)));\n-   |       -                           ^^^ expected &Foo, found struct `Foo`\n+   |       --------                    ^^^ expected &Foo, found struct `Foo`\n    |       |\n-   |       help: consider using `as_ref` instead: `as_ref().`\n+   |       help: consider using `as_ref` instead: `as_ref().and_then`\n    |\n    = note: expected type `&Foo`\n               found type `Foo`"}, {"sha": "c8df6cbc57dcab71de0cb3fdeb8a58dbeb07afbb", "filename": "src/test/ui/use/use-nested-groups-unused-imports.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-unused-imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c67d4749a547a0c937e257ad9e0248075178ddc4/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-unused-imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-unused-imports.stderr?ref=c67d4749a547a0c937e257ad9e0248075178ddc4", "patch": "@@ -2,7 +2,7 @@ error: unused imports: `*`, `Foo`, `baz::{}`, `foobar::*`\n   --> $DIR/use-nested-groups-unused-imports.rs:16:11\n    |\n LL | use foo::{Foo, bar::{baz::{}, foobar::*}, *};\n-   | ----------^^^--------^^^^^^^--^^^^^^^^^---^-- help: remove the whole `use` item\n+   |           ^^^        ^^^^^^^  ^^^^^^^^^   ^\n    |\n note: lint level defined here\n   --> $DIR/use-nested-groups-unused-imports.rs:3:9\n@@ -14,15 +14,13 @@ error: unused import: `*`\n   --> $DIR/use-nested-groups-unused-imports.rs:18:24\n    |\n LL | use foo::bar::baz::{*, *};\n-   |                      --^\n-   |                      |\n-   |                      help: remove the unused import\n+   |                        ^\n \n error: unused import: `foo::{}`\n   --> $DIR/use-nested-groups-unused-imports.rs:20:5\n    |\n LL | use foo::{};\n-   | ----^^^^^^^- help: remove the whole `use` item\n+   |     ^^^^^^^\n \n error: aborting due to 3 previous errors\n "}]}