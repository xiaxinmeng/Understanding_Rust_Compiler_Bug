{"sha": "4f11f84dee891e80680f47d48cc33a0cb0229080", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTFmODRkZWU4OTFlODA2ODBmNDdkNDhjYzMzYTBjYjAyMjkwODA=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-25T15:15:19Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-25T19:14:14Z"}, "message": "Lint binary regexes", "tree": {"sha": "de09410b9c2e6a69060846a94da4c34bc50dbbd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de09410b9c2e6a69060846a94da4c34bc50dbbd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f11f84dee891e80680f47d48cc33a0cb0229080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f11f84dee891e80680f47d48cc33a0cb0229080", "html_url": "https://github.com/rust-lang/rust/commit/4f11f84dee891e80680f47d48cc33a0cb0229080", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f11f84dee891e80680f47d48cc33a0cb0229080/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77ed8999418828f05bd48a5dee9b3b2daa3be441", "url": "https://api.github.com/repos/rust-lang/rust/commits/77ed8999418828f05bd48a5dee9b3b2daa3be441", "html_url": "https://github.com/rust-lang/rust/commit/77ed8999418828f05bd48a5dee9b3b2daa3be441"}], "stats": {"total": 153, "additions": 109, "deletions": 44}, "files": [{"sha": "f17b1dd083748583940844a1378d613ea8ce579d", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f11f84dee891e80680f47d48cc33a0cb0229080/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f11f84dee891e80680f47d48cc33a0cb0229080/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4f11f84dee891e80680f47d48cc33a0cb0229080", "patch": "@@ -1,9 +1,13 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.70 \u2014 TBD\n+* [`invalid_regex`] and [`trivial_regex`] can now warn on `RegexSet::new` and\n+  byte regexes\n+\n ## 0.0.69 \u2014 2016-05-20\n * Rustup to *rustc 1.10.0-nightly (476fe6eef 2016-05-21)*\n-* `used_underscore_binding` has been made `Allow` temporarily\n+* [`used_underscore_binding`] has been made `Allow` temporarily\n \n ## 0.0.68 \u2014 2016-05-17\n * Rustup to *rustc 1.10.0-nightly (cd6a40017 2016-05-16)*"}, {"sha": "8876a649e5d9d403d5124132e83a14d2f279f0ce", "filename": "src/regex.rs", "status": "modified", "additions": 67, "deletions": 41, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4f11f84dee891e80680f47d48cc33a0cb0229080/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f11f84dee891e80680f47d48cc33a0cb0229080/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=4f11f84dee891e80680f47d48cc33a0cb0229080", "patch": "@@ -9,7 +9,7 @@ use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n-use utils::{is_expn_of, match_path, match_type, paths, span_lint, span_help_and_lint};\n+use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_and_lint};\n \n /// **What it does:** This lint checks `Regex::new(_)` invocations for correct regex syntax.\n ///\n@@ -81,7 +81,7 @@ impl LateLintPass for RegexPass {\n                           span,\n                           \"`regex!(_)` found. \\\n                           Please use `Regex::new(_)`, which is faster for now.\");\n-                self.spans.insert(span);                    \n+                self.spans.insert(span);\n             }\n             self.last = Some(block.id);\n         }}\n@@ -96,46 +96,18 @@ impl LateLintPass for RegexPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(_, ref path) = fun.node,\n-            match_path(path, &paths::REGEX_NEW) && args.len() == 1\n+            args.len() == 1,\n+            let Some(def) = cx.tcx.def_map.borrow().get(&fun.id),\n         ], {\n-            if let ExprLit(ref lit) = args[0].node {\n-                if let LitKind::Str(ref r, _) = lit.node {\n-                    match regex_syntax::Expr::parse(r) {\n-                        Ok(r) => {\n-                            if let Some(repl) = is_trivial_regex(&r) {\n-                                span_help_and_lint(cx, TRIVIAL_REGEX, args[0].span,\n-                                                   \"trivial regex\",\n-                                                   &format!(\"consider using {}\", repl));\n-                            }\n-                        }\n-                        Err(e) => {\n-                            span_lint(cx,\n-                                      INVALID_REGEX,\n-                                      str_span(args[0].span, &r, e.position()),\n-                                      &format!(\"regex syntax error: {}\",\n-                                               e.description()));\n-                        }\n-                    }\n-                }\n-            } else if let Some(r) = const_str(cx, &*args[0]) {\n-                match regex_syntax::Expr::parse(&r) {\n-                    Ok(r) => {\n-                        if let Some(repl) = is_trivial_regex(&r) {\n-                            span_help_and_lint(cx, TRIVIAL_REGEX, args[0].span,\n-                                               \"trivial regex\",\n-                                               &format!(\"consider using {}\", repl));\n-                        }\n-                    }\n-                    Err(e) => {\n-                        span_lint(cx,\n-                                  INVALID_REGEX,\n-                                  args[0].span,\n-                                  &format!(\"regex syntax error on position {}: {}\",\n-                                           e.position(),\n-                                           e.description()));\n-                    }\n-                }\n+            let def_id = def.def_id();\n+            if match_def_path(cx, def_id, &paths::REGEX_NEW) {\n+                check_regex(cx, &args[0], true);\n+            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_NEW) {\n+                check_regex(cx, &args[0], false);\n+            } else if match_def_path(cx, def_id, &paths::REGEX_SET_NEW) {\n+                check_set(cx, &args[0], true);\n+            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n+                check_set(cx, &args[0], false);\n             }\n         }}\n     }\n@@ -193,3 +165,57 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n         _ => None,\n     }\n }\n+\n+fn check_set(cx: &LateContext, expr: &Expr, utf8: bool) {\n+    if_let_chain! {[\n+        let ExprAddrOf(_, ref expr) = expr.node,\n+        let ExprVec(ref exprs) = expr.node,\n+    ], {\n+        for expr in exprs {\n+            check_regex(cx, expr, utf8);\n+        }\n+    }}\n+}\n+\n+fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n+    let builder = regex_syntax::ExprBuilder::new().unicode(utf8);\n+\n+    if let ExprLit(ref lit) = expr.node {\n+        if let LitKind::Str(ref r, _) = lit.node {\n+            match builder.parse(r) {\n+                Ok(r) => {\n+                    if let Some(repl) = is_trivial_regex(&r) {\n+                        span_help_and_lint(cx, TRIVIAL_REGEX, expr.span,\n+                                           \"trivial regex\",\n+                                           &format!(\"consider using {}\", repl));\n+                    }\n+                }\n+                Err(e) => {\n+                    span_lint(cx,\n+                              INVALID_REGEX,\n+                              str_span(expr.span, r, e.position()),\n+                              &format!(\"regex syntax error: {}\",\n+                                       e.description()));\n+                }\n+            }\n+        }\n+    } else if let Some(r) = const_str(cx, expr) {\n+        match builder.parse(&r) {\n+            Ok(r) => {\n+                if let Some(repl) = is_trivial_regex(&r) {\n+                    span_help_and_lint(cx, TRIVIAL_REGEX, expr.span,\n+                                       \"trivial regex\",\n+                                       &format!(\"consider using {}\", repl));\n+                }\n+            }\n+            Err(e) => {\n+                span_lint(cx,\n+                          INVALID_REGEX,\n+                          expr.span,\n+                          &format!(\"regex syntax error on position {}: {}\",\n+                                   e.position(),\n+                                   e.description()));\n+            }\n+        }\n+    }\n+}"}, {"sha": "b0ce8b4a2339881c532fbc25d0024bfcf4091d04", "filename": "src/utils/paths.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f11f84dee891e80680f47d48cc33a0cb0229080/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f11f84dee891e80680f47d48cc33a0cb0229080/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=4f11f84dee891e80680f47d48cc33a0cb0229080", "patch": "@@ -46,7 +46,11 @@ pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"core\", \"ops\", \"RangeToInclus\n pub const RANGE_TO_INCLUSIVE_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n pub const RANGE_TO_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const REGEX: [&'static str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n-pub const REGEX_NEW: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n+pub const REGEX_BYTES: [&'static str; 3] = [\"regex\", \"re_bytes\", \"Regex\"];\n+pub const REGEX_BYTES_NEW: [&'static str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n+pub const REGEX_BYTES_SET_NEW: [&'static str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n+pub const REGEX_NEW: [&'static str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n+pub const REGEX_SET_NEW: [&'static str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];"}, {"sha": "d9f262fb045a0639f169108fcb1d692b5eefe3ca", "filename": "tests/compile-fail/regex.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4f11f84dee891e80680f47d48cc33a0cb0229080/tests%2Fcompile-fail%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f11f84dee891e80680f47d48cc33a0cb0229080/tests%2Fcompile-fail%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fregex.rs?ref=4f11f84dee891e80680f47d48cc33a0cb0229080", "patch": "@@ -6,7 +6,8 @@\n \n extern crate regex;\n \n-use regex::Regex;\n+use regex::{Regex, RegexSet};\n+use regex::bytes::{Regex as BRegex, RegexSet as BRegexSet};\n \n const OPENING_PAREN : &'static str = \"(\";\n const NOT_A_REAL_REGEX : &'static str = \"foobar\";\n@@ -22,8 +23,33 @@ fn syntax_error() {\n     let some_regex = Regex::new(OPENING_PAREN);\n     //~^ERROR: regex syntax error on position 0: unclosed\n \n+    let binary_pipe_in_wrong_position = BRegex::new(\"|\");\n+    //~^ERROR: regex syntax error: empty alternate\n+    let some_binary_regex = BRegex::new(OPENING_PAREN);\n+    //~^ERROR: regex syntax error on position 0: unclosed\n+\n     let closing_paren = \")\";\n     let not_linted = Regex::new(closing_paren);\n+\n+    let set = RegexSet::new(&[\n+        r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n+        r\"[a-z]+\\.(com|org|net)\",\n+    ]);\n+    let bset = BRegexSet::new(&[\n+        r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n+        r\"[a-z]+\\.(com|org|net)\",\n+    ]);\n+\n+    let set_error = RegexSet::new(&[\n+        OPENING_PAREN,\n+        //~^ERROR: regex syntax error on position 0: unclosed\n+        r\"[a-z]+\\.(com|org|net)\",\n+    ]);\n+    let bset_error = BRegexSet::new(&[\n+        OPENING_PAREN,\n+        //~^ERROR: regex syntax error on position 0: unclosed\n+        r\"[a-z]+\\.(com|org|net)\",\n+    ]);\n }\n \n fn trivial_regex() {\n@@ -64,12 +90,17 @@ fn trivial_regex() {\n     //~^ERROR: trivial regex\n     //~|HELP consider using `str::is_empty`\n \n+    let binary_trivial_empty = BRegex::new(\"^$\");\n+    //~^ERROR: trivial regex\n+    //~|HELP consider using `str::is_empty`\n+\n     // non-trivial regexes\n     let non_trivial_dot = Regex::new(\"a.b\");\n     let non_trivial_eq = Regex::new(\"^foo|bar$\");\n     let non_trivial_starts_with = Regex::new(\"^foo|bar\");\n     let non_trivial_ends_with = Regex::new(\"^foo|bar\");\n     let non_trivial_ends_with = Regex::new(\"foo|bar\");\n+    let non_trivial_binary = BRegex::new(\"foo|bar\");\n }\n \n fn main() {"}]}