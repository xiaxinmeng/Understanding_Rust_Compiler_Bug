{"sha": "92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTNmYjNlYmU2ZDcxMjlmZjBmZTg1YzE3ZjMwYzg2Njk4OTkxMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-20T16:57:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-20T16:57:57Z"}, "message": "Auto merge of #31709 - ranma42:target_feature-from-llvm, r=alexcrichton\n\nCompute `target_feature` from LLVM\n\nThis is a work-in-progress fix for #31662.\n\nThe logic that computes the target features from the command line has been replaced with queries to the `TargetMachine`.", "tree": {"sha": "7d783992f028cebcef184a04ebd6d08dc44bd224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d783992f028cebcef184a04ebd6d08dc44bd224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "html_url": "https://github.com/rust-lang/rust/commit/92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ece1447f02b2310e5f4c7ef1efd1312476cae80", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ece1447f02b2310e5f4c7ef1efd1312476cae80", "html_url": "https://github.com/rust-lang/rust/commit/6ece1447f02b2310e5f4c7ef1efd1312476cae80"}, {"sha": "ce99a5e5d8ead9140bb9b48c01f1a200950f8ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce99a5e5d8ead9140bb9b48c01f1a200950f8ea3", "html_url": "https://github.com/rust-lang/rust/commit/ce99a5e5d8ead9140bb9b48c01f1a200950f8ea3"}], "stats": {"total": 320, "additions": 203, "deletions": 117}, "files": [{"sha": "c55a6e791b68da3a3e3c5a05572d64cd26698502", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -97,7 +97,7 @@ DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n \t\t\t\t\t     rustc_back graphviz\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n-              log graphviz rustc_back rustc_data_structures\\\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t\t  \t  rustc_const_math\n DEPS_rustc_back := std syntax flate log libc\n DEPS_rustc_borrowck := rustc rustc_mir log graphviz syntax"}, {"sha": "834a11d37fa40d18e0c4f79df8dc2821f50f7018", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -43,6 +43,9 @@ $$(RT_OUTPUT_DIR_$(1))/$$(call CFG_STATIC_LIB_NAME_$(1),rustllvm): \\\n \t@$$(call E, link: $$@)\n \t$$(Q)$$(call CFG_CREATE_ARCHIVE_$(1),$$@) $$^\n \n+RUSTLLVM_COMPONENTS_$(1) = $$(shell echo $$(LLVM_ALL_COMPONENTS_$(1)) |\\\n+\ttr 'a-z-' 'A-Z_'| sed -e 's/^ //;s/\\([^ ]*\\)/\\-DLLVM_COMPONENT_\\1/g')\n+\n # On MSVC we need to double-escape arguments that llvm-config printed which\n # start with a '/'. The shell we're running in will auto-translate the argument\n # `/foo` to `C:/msys64/foo` but we really want it to be passed through as `/foo`\n@@ -51,6 +54,7 @@ $(1)/rustllvm/%.o: $(S)src/rustllvm/%.cpp $$(MKFILE_DEPS) $$(LLVM_CONFIG_$(1))\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@,) \\\n \t\t$$(subst  /,//,$$(LLVM_CXXFLAGS_$(1))) \\\n+\t\t$$(RUSTLLVM_COMPONENTS_$(1)) \\\n \t\t$$(EXTRA_RUSTLLVM_CXXFLAGS_$(1)) \\\n \t\t$$(RUSTLLVM_INCS_$(1)) \\\n \t\t$$<"}, {"sha": "9291227a734f78b7978aedfe79368c5ab1402257", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -19,5 +19,6 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "ed63783366bf846d73b9b6e144bbead74da61a9a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -49,6 +49,7 @@ extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n extern crate rbml;\n+extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate serialize;"}, {"sha": "da285c62ae426b4c1d3163ee1cf713997185b635", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -30,13 +30,16 @@ use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n \n use rustc_back::target::Target;\n+use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::env;\n+use std::ffi::CString;\n use std::rc::Rc;\n use std::fmt;\n+use libc::c_int;\n \n pub mod config;\n pub mod filesearch;\n@@ -491,9 +494,63 @@ pub fn build_session_(sopts: config::Options,\n         imported_macro_spans: RefCell::new(HashMap::new()),\n     };\n \n+    init_llvm(&sess);\n+\n     sess\n }\n \n+fn init_llvm(sess: &Session) {\n+    unsafe {\n+        // Before we touch LLVM, make sure that multithreading is enabled.\n+        use std::sync::Once;\n+        static INIT: Once = Once::new();\n+        static mut POISONED: bool = false;\n+        INIT.call_once(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED = true;\n+            }\n+\n+            configure_llvm(sess);\n+        });\n+\n+        if POISONED {\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+\n+    {\n+        let mut add = |arg: &str| {\n+            let s = CString::new(arg).unwrap();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        // FIXME #21627 disable faulty FastISel on AArch64 (even for -O0)\n+        if sess.target.target.arch == \"aarch64\" { add(\"-fast-isel=0\"); }\n+\n+        for arg in &sess.opts.cg.llvm_args {\n+            add(&(*arg));\n+        }\n+    }\n+\n+    llvm::LLVMInitializePasses();\n+\n+    llvm::initialize_available_targets();\n+\n+    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                 llvm_args.as_ptr());\n+}\n+\n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let mut emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {"}, {"sha": "fad0af19a127037ad0861b1842860cecb2eb621b", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 40, "deletions": 65, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -9,79 +9,54 @@\n // except according to those terms.\n \n use syntax::{ast, attr};\n+use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n+use rustc_trans::back::write::create_target_machine;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::intern_and_get_ident as intern;\n+use libc::c_char;\n+\n+// WARNING: the features must be known to LLVM or the feature\n+// detection code will walk past the end of the feature array,\n+// leading to crashes.\n+\n+const ARM_WHITELIST: &'static [&'static str] = &[\n+    \"neon\\0\",\n+    \"vfp2\\0\",\n+    \"vfp3\\0\",\n+    \"vfp4\\0\",\n+];\n+\n+const X86_WHITELIST: &'static [&'static str] = &[\n+    \"avx\\0\",\n+    \"avx2\\0\",\n+    \"sse\\0\",\n+    \"sse2\\0\",\n+    \"sse3\\0\",\n+    \"sse4.1\\0\",\n+    \"sse4.2\\0\",\n+    \"ssse3\\0\",\n+];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n-/// This uses a scheme similar to that employed by clang: reimplement\n-/// the target feature knowledge. *Theoretically* we could query LLVM\n-/// since that has perfect knowledge about what things are enabled in\n-/// code-generation, however, it is extremely non-obvious how to do\n-/// this successfully. Each platform defines a subclass of a\n-/// SubtargetInfo, which knows all this information, but the ways to\n-/// query them do not seem to be public.\n+/// This is performed by checking whether a whitelisted set of\n+/// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let tf = InternedString::new(\"target_feature\");\n-    macro_rules! fillout {\n-        ($($func: ident, $name: expr;)*) => {{\n-            $(if $func(sess) {\n-                cfg.push(attr::mk_name_value_item_str(tf.clone(), intern($name)))\n-            })*\n-        }}\n-    }\n-    fillout! {\n-        has_sse, \"sse\";\n-        has_sse2, \"sse2\";\n-        has_sse3, \"sse3\";\n-        has_ssse3, \"ssse3\";\n-        has_sse41, \"sse4.1\";\n-        has_sse42, \"sse4.2\";\n-        has_avx, \"avx\";\n-        has_avx2, \"avx2\";\n-        has_neon, \"neon\";\n-        has_vfp, \"vfp\";\n-    }\n-}\n-\n+    let target_machine = create_target_machine(sess);\n \n-fn features_contain(sess: &Session, s: &str) -> bool {\n-    sess.target.target.options.features.contains(s) || sess.opts.cg.target_feature.contains(s)\n-}\n+    let whitelist = match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        _ => &[],\n+    };\n \n-pub fn has_sse(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse\") || has_sse2(sess)\n-}\n-pub fn has_sse2(sess: &Session) -> bool {\n-    // x86-64 requires at least SSE2 support\n-    sess.target.target.arch == \"x86_64\" || features_contain(sess, \"+sse2\") || has_sse3(sess)\n-}\n-pub fn has_sse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse3\") || has_ssse3(sess)\n-}\n-pub fn has_ssse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+ssse3\") || has_sse41(sess)\n-}\n-pub fn has_sse41(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.1\") || has_sse42(sess)\n-}\n-pub fn has_sse42(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.2\") || has_avx(sess)\n-}\n-pub fn has_avx(sess: &Session) -> bool {\n-    features_contain(sess, \"+avx\") || has_avx2(sess)\n-}\n-pub fn has_avx2(sess: &Session) -> bool {\n-    features_contain(sess, \"+avx2\")\n-}\n-\n-pub fn has_neon(sess: &Session) -> bool {\n-    // AArch64 requires NEON support\n-    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+neon\")\n-}\n-pub fn has_vfp(sess: &Session) -> bool {\n-    // AArch64 requires VFP support\n-    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+vfp\")\n+    let tf = InternedString::new(\"target_feature\");\n+    for feat in whitelist {\n+        assert_eq!(feat.chars().last(), Some('\\0'));\n+        if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n+            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len()-1])))\n+        }\n+    }\n }"}, {"sha": "0c6db2cb8ba8d63c39ebf6796b6ad213e0a48dc9", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -100,6 +100,13 @@ fn main() {\n         }\n         cfg.flag(flag);\n     }\n+\n+    for component in &components[..] {\n+        let mut flag = String::from(\"-DLLVM_COMPONENT_\");\n+        flag.push_str(&component.to_uppercase());\n+        cfg.flag(&flag);\n+    }\n+\n     cfg.file(\"../rustllvm/ExecutionEngineWrapper.cpp\")\n        .file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")"}, {"sha": "12d652bd5cb8737173c5b7ea431339387bdb2995", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -2013,6 +2013,9 @@ extern {\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n     pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n \n+    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n+                              s: *const c_char) -> bool;\n+\n     pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n                                        CPU: *const c_char,\n                                        Features: *const c_char,"}, {"sha": "8a915f044053a440138b70a16f3da605dc10de14", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -31,7 +31,7 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::sync::mpsc::channel;\n use std::thread;\n-use libc::{c_uint, c_int, c_void};\n+use libc::{c_uint, c_void};\n \n pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n     match llvm::last_error() {\n@@ -984,36 +984,6 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     }\n }\n \n-pub unsafe fn configure_llvm(sess: &Session) {\n-    let mut llvm_c_strs = Vec::new();\n-    let mut llvm_args = Vec::new();\n-\n-    {\n-        let mut add = |arg: &str| {\n-            let s = CString::new(arg).unwrap();\n-            llvm_args.push(s.as_ptr());\n-            llvm_c_strs.push(s);\n-        };\n-        add(\"rustc\"); // fake program name\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-        // FIXME #21627 disable faulty FastISel on AArch64 (even for -O0)\n-        if sess.target.target.arch == \"aarch64\" { add(\"-fast-isel=0\"); }\n-\n-        for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg));\n-        }\n-    }\n-\n-    llvm::LLVMInitializePasses();\n-\n-    llvm::initialize_available_targets();\n-\n-    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                 llvm_args.as_ptr());\n-}\n-\n pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n                             config: &ModuleConfig,\n                             f: &mut FnMut(llvm::PassManagerBuilderRef)) {"}, {"sha": "cea67f46db527b95f63269b7fc001f5989ed05d7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -2713,26 +2713,6 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    // Before we touch LLVM, make sure that multithreading is enabled.\n-    unsafe {\n-        use std::sync::Once;\n-        static INIT: Once = Once::new();\n-        static mut POISONED: bool = false;\n-        INIT.call_once(|| {\n-            if llvm::LLVMStartMultithreaded() != 1 {\n-                // use an extra bool to make sure that all future usage of LLVM\n-                // cannot proceed despite the Once not running more than once.\n-                POISONED = true;\n-            }\n-\n-            ::back::write::configure_llvm(&tcx.sess);\n-        });\n-\n-        if POISONED {\n-            bug!(\"couldn't enable multi-threaded LLVM\");\n-        }\n-    }\n-\n     let link_meta = link::build_link_meta(&tcx, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;"}, {"sha": "b3d4e35d7b09c75560a9bba4f2c069dda4be76c7", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -97,6 +97,75 @@ LLVMRustAddPass(LLVMPassManagerRef PM, Pass *pass) {\n     pm->add(pass);\n }\n \n+#ifdef LLVM_COMPONENT_X86\n+#define SUBTARGET_X86 SUBTARGET(X86)\n+#else\n+#define SUBTARGET_X86\n+#endif\n+\n+#ifdef LLVM_COMPONENT_ARM\n+#define SUBTARGET_ARM SUBTARGET(ARM)\n+#else\n+#define SUBTARGET_ARM\n+#endif\n+\n+#ifdef LLVM_COMPONENT_AARCH64\n+#define SUBTARGET_AARCH64 SUBTARGET(AArch64)\n+#else\n+#define SUBTARGET_AARCH64\n+#endif\n+\n+#ifdef LLVM_COMPONENT_MIPS\n+#define SUBTARGET_MIPS SUBTARGET(Mips)\n+#else\n+#define SUBTARGET_MIPS\n+#endif\n+\n+#ifdef LLVM_COMPONENT_POWERPC\n+#define SUBTARGET_PPC SUBTARGET(PPC)\n+#else\n+#define SUBTARGET_PPC\n+#endif\n+\n+#define GEN_SUBTARGETS    \\\n+        SUBTARGET_X86     \\\n+        SUBTARGET_ARM     \\\n+        SUBTARGET_AARCH64 \\\n+        SUBTARGET_MIPS    \\\n+        SUBTARGET_PPC\n+\n+#define SUBTARGET(x) namespace llvm {                \\\n+    extern const SubtargetFeatureKV x##FeatureKV[];  \\\n+    extern const SubtargetFeatureKV x##SubTypeKV[];  \\\n+  }\n+\n+GEN_SUBTARGETS\n+#undef SUBTARGET\n+\n+extern \"C\" bool\n+LLVMRustHasFeature(LLVMTargetMachineRef TM,\n+\t\t   const char *feature) {\n+    TargetMachine *Target = unwrap(TM);\n+    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+    const FeatureBitset &Bits = MCInfo->getFeatureBits();\n+    const llvm::SubtargetFeatureKV *FeatureEntry;\n+\n+#define SUBTARGET(x)                                        \\\n+    if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {    \\\n+        FeatureEntry = x##FeatureKV;                       \\\n+    } else\n+\n+    GEN_SUBTARGETS {\n+        return false;\n+    }\n+#undef SUBTARGET\n+\n+    while (strcmp(feature, FeatureEntry->Key) != 0)\n+        FeatureEntry++;\n+\n+    return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n+}\n+\n extern \"C\" LLVMTargetMachineRef\n LLVMRustCreateTargetMachine(const char *triple,\n                             const char *cpu,"}, {"sha": "a820a463f4a0293c822db47941a8faaf8eaf66ef", "filename": "src/test/run-make/print-cfg/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -5,6 +5,7 @@ all: default\n \t$(RUSTC) --target x86_64-pc-windows-gnu --print cfg | grep x86_64\n \t$(RUSTC) --target i686-pc-windows-msvc --print cfg | grep msvc\n \t$(RUSTC) --target i686-apple-darwin --print cfg | grep macos\n+\t$(RUSTC) --target i686-unknown-linux-gnu --print cfg | grep sse2\n \n ifdef IS_WINDOWS\n default:"}, {"sha": "78d91b2f3120e541ba40fb9b7a0aef6ae3b8b3f5", "filename": "src/test/run-pass/sse2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Ftest%2Frun-pass%2Fsse2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e3fb3ebe6d7129ff0fe85c17f30c8669899129/src%2Ftest%2Frun-pass%2Fsse2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsse2.rs?ref=92e3fb3ebe6d7129ff0fe85c17f30c8669899129", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(cfg_target_feature)]\n+\n+pub fn main() {\n+    if cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\")) {\n+        assert!(cfg!(target_feature = \"sse2\"),\n+            \"SSE2 was not detected as available on an x86 platform\");\n+    }\n+}"}]}