{"sha": "9d67d5a71dafe105167acf0e8b960f5aa118652b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNjdkNWE3MWRhZmUxMDUxNjdhY2YwZThiOTYwZjVhYTExODY1MmI=", "commit": {"author": {"name": "Ian Douglas Scott", "email": "ian@iandouglasscott.com", "date": "2017-08-04T05:49:46Z"}, "committer": {"name": "Ian Douglas Scott", "email": "ian@iandouglasscott.com", "date": "2017-08-04T06:05:58Z"}, "message": "Simplify Redox backtrace/ to not include non-Redox implementations", "tree": {"sha": "354c00fdd28d08fa6c38540b5d2975bdf24d10dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/354c00fdd28d08fa6c38540b5d2975bdf24d10dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d67d5a71dafe105167acf0e8b960f5aa118652b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEECYv1aaNg4jTOK4YaSSThDhmbWVkFAlmEDscACgkQSSThDhmb\nWVlpdAgAoEjWL6H4/rd/eHmENKZudg09IuuohnWmxU0SCZsKMkUWEBL5xHZtpQQt\nCqMTjlIPi2iGhlOJgKfXtefqDXTZoLNDx5U+v1HXXwZkM/WW6RYbmVNnAfNo+03X\nNH1FarpDL5kv9eGo4Gq3qihvAiaYnKAjHNMXLJm+DyywjxUkcsPeq1fHuhIt+o9I\nayj9AavmaiQM9+sDTEYoh3xkULyUxRr7JCaNw+8Vm6ZcJ6FmMTMS6JbbvQd6Pw54\nKXMNVO9WAv3wURAW/HxxNxGlERYmqRL1Jj7stWioIFGwsew65zhh4qHicfe7k7gU\nOjctEtl4vSW8hFx7mXQX4es84EBCyA==\n=WAya\n-----END PGP SIGNATURE-----", "payload": "tree 354c00fdd28d08fa6c38540b5d2975bdf24d10dd\nparent 2fd4663feeec050379c91393474d3ecfd198b2b4\nauthor Ian Douglas Scott <ian@iandouglasscott.com> 1501825786 -0700\ncommitter Ian Douglas Scott <ian@iandouglasscott.com> 1501826758 -0700\n\nSimplify Redox backtrace/ to not include non-Redox implementations\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d67d5a71dafe105167acf0e8b960f5aa118652b", "html_url": "https://github.com/rust-lang/rust/commit/9d67d5a71dafe105167acf0e8b960f5aa118652b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d67d5a71dafe105167acf0e8b960f5aa118652b/comments", "author": {"login": "ids1024", "id": 2263150, "node_id": "MDQ6VXNlcjIyNjMxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2263150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ids1024", "html_url": "https://github.com/ids1024", "followers_url": "https://api.github.com/users/ids1024/followers", "following_url": "https://api.github.com/users/ids1024/following{/other_user}", "gists_url": "https://api.github.com/users/ids1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/ids1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ids1024/subscriptions", "organizations_url": "https://api.github.com/users/ids1024/orgs", "repos_url": "https://api.github.com/users/ids1024/repos", "events_url": "https://api.github.com/users/ids1024/events{/privacy}", "received_events_url": "https://api.github.com/users/ids1024/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ids1024", "id": 2263150, "node_id": "MDQ6VXNlcjIyNjMxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2263150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ids1024", "html_url": "https://github.com/ids1024", "followers_url": "https://api.github.com/users/ids1024/followers", "following_url": "https://api.github.com/users/ids1024/following{/other_user}", "gists_url": "https://api.github.com/users/ids1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/ids1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ids1024/subscriptions", "organizations_url": "https://api.github.com/users/ids1024/orgs", "repos_url": "https://api.github.com/users/ids1024/repos", "events_url": "https://api.github.com/users/ids1024/events{/privacy}", "received_events_url": "https://api.github.com/users/ids1024/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fd4663feeec050379c91393474d3ecfd198b2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd4663feeec050379c91393474d3ecfd198b2b4", "html_url": "https://github.com/rust-lang/rust/commit/2fd4663feeec050379c91393474d3ecfd198b2b4"}], "stats": {"total": 210, "additions": 3, "deletions": 207}, "files": [{"sha": "40b957d847b0f23088b0a3f98141c1e44b765529", "filename": "src/libstd/sys/redox/backtrace/mod.rs", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs?ref=9d67d5a71dafe105167acf0e8b960f5aa118652b", "patch": "@@ -8,80 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on macOS, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering thread\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not macOS, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n+/// See sys/unix/backtrace/mod.rs for an explanation of the method used here.\n \n pub use self::tracing::unwind_backtrace;\n pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n@@ -91,7 +18,6 @@ mod tracing;\n // symbol resolvers:\n mod printing;\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\")))]\n pub mod gnu {\n     use io;\n     use fs;"}, {"sha": "3e937dbe623e728a1d97dff88ddf220f5c5ed339", "filename": "src/libstd/sys/redox/backtrace/printing.rs", "status": "renamed", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs?ref=9d67d5a71dafe105167acf0e8b960f5aa118652b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::imp::*;\n-\n-#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-#[path = \"gcc_s.rs\"]\n-mod imp;\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[path = \"backtrace_fn.rs\"]\n-mod imp;\n+pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};", "previous_filename": "src/libstd/sys/redox/backtrace/tracing/mod.rs"}, {"sha": "05a071a79783841072bd20c7bf505e5197cf8b1b", "filename": "src/libstd/sys/redox/backtrace/printing/dladdr.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use io;\n-use intrinsics;\n-use ffi::CStr;\n-use libc;\n-use sys::backtrace::BacktraceContext;\n-use sys_common::backtrace::Frame;\n-\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsafe {\n-        let mut info: Dl_info = intrinsics::init();\n-        let symname = if dladdr(frame.exact_position, &mut info) == 0 {\n-            None\n-        } else {\n-            CStr::from_ptr(info.dli_sname).to_str().ok()\n-        };\n-        callback(symname)\n-    }\n-}\n-\n-pub fn foreach_symbol_fileline<F>(_symbol_addr: Frame,\n-                                  _f: F,\n-                                  _: &BacktraceContext) -> io::Result<bool>\n-    where F: FnMut(&[u8], libc::c_int) -> io::Result<()>\n-{\n-    Ok(false)\n-}\n-\n-#[repr(C)]\n-struct Dl_info {\n-    dli_fname: *const libc::c_char,\n-    dli_fbase: *mut libc::c_void,\n-    dli_sname: *const libc::c_char,\n-    dli_saddr: *mut libc::c_void,\n-}\n-\n-extern {\n-    fn dladdr(addr: *const libc::c_void,\n-              info: *mut Dl_info) -> libc::c_int;\n-}"}, {"sha": "1ae82e01100169e5cd451f317ce4eb944547e4b7", "filename": "src/libstd/sys/redox/backtrace/printing/mod.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::imp::{foreach_symbol_fileline, resolve_symname};\n-\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\",\n-          target_os = \"emscripten\"))]\n-#[path = \"dladdr.rs\"]\n-mod imp;\n-\n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\",\n-              target_os = \"emscripten\")))]\n-mod imp {\n-    pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n-}"}, {"sha": "cfeabaddda9859fea27aa88a3da3da5d40d7d50d", "filename": "src/libstd/sys/redox/backtrace/tracing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d67d5a71dafe105167acf0e8b960f5aa118652b/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs?ref=9d67d5a71dafe105167acf0e8b960f5aa118652b", "previous_filename": "src/libstd/sys/redox/backtrace/tracing/gcc_s.rs"}, {"sha": "ecd32aa9462a904d5dea1ca929328892ed3dcebe", "filename": "src/libstd/sys/redox/backtrace/tracing/backtrace_fn.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// As always - iOS on arm uses SjLj exceptions and\n-/// _Unwind_Backtrace is even not available there. Still,\n-/// backtraces could be extracted using a backtrace function,\n-/// which thanks god is public\n-///\n-/// As mentioned in a huge comment block in `super::super`, backtrace\n-/// doesn't play well with green threads, so while it is extremely nice and\n-/// simple to use it should be used only on iOS devices as the only viable\n-/// option.\n-\n-use io;\n-use libc;\n-use sys::backtrace::BacktraceContext;\n-use sys_common::backtrace::Frame;\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    const FRAME_LEN: usize = 100;\n-    assert!(FRAME_LEN >= frames.len());\n-    let mut raw_frames = [::ptr::null_mut(); FRAME_LEN];\n-    let nb_frames = unsafe {\n-        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n-    } as usize;\n-    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n-        *to = Frame {\n-            exact_position: *from,\n-            symbol_addr: *from,\n-        };\n-    }\n-    Ok((nb_frames as usize, BacktraceContext))\n-}\n-\n-extern {\n-    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n-}"}]}