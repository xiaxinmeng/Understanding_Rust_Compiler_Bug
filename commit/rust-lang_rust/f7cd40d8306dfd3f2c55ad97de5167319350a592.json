{"sha": "f7cd40d8306dfd3f2c55ad97de5167319350a592", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Y2Q0MGQ4MzA2ZGZkM2YyYzU1YWQ5N2RlNTE2NzMxOTM1MGE1OTI=", "commit": {"author": {"name": "Unreal Hoang", "email": "unrealhoang@gmail.com", "date": "2019-07-07T07:31:09Z"}, "committer": {"name": "Unreal Hoang", "email": "unrealhoang@gmail.com", "date": "2019-07-07T13:26:51Z"}, "message": "add projection to infer for loop variable", "tree": {"sha": "73d1da8789a0a6109805768d7f2cad3336d3453b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73d1da8789a0a6109805768d7f2cad3336d3453b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7cd40d8306dfd3f2c55ad97de5167319350a592", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5FNMeJ7UuhhqQiT99mIXvcbzfPoFAl0h8yAACgkQ9mIXvcbz\nfPpd5Q//eVXwMVxBbZXNyUdlXIekPIe6EIf7SDFJFlLtfnt+kYBzIDRaGwj9Wqye\ntdVOuW11zMmTEXiSQ23otjtaWx2qVaXpqLRPwmd7uidcGcEiDr3KYUY2o/C/IoZg\n34LhZrhiAFUEfXdjFb/kNGtDIs6ihayEwiyWzQnqE5jS1q5XG4kZHbhWXp8MamMO\nS2025+9UUBgcwV6G23weDP9ofItv8sLVCy4QzxhjJt+tVWJS1KE1bUYd2pUZbbH8\nfoAlTEVjn6/HOd+mh4nPD5yk2714vtWYYBDvG5d/Af6fDUaXDt+aoBSwQgTVKABE\nr4KhZ8eU2LaS+uHPiiPEso7vBzHWn2LlzFOBK41NS/Y319A24XwxAmrlLULe0Z/D\nbebln6N0Ku+aOClYsXXWVaGU3BCQ2RVdD2DgTLvh5x9T6Op6R2/ZKQG7CJfuYytI\noWPdndS2RlididUz5zHfEprShFvulUoUT+hSBcAW5P9TyRoV0Gq7PAmM2v8yiMqk\n1IF/hIYeYRVL3+GsdAuLcefbmujCUFYfPDebFqywbY7qmZEHafa9C0M5m/NQtVUd\nq9tGz7zv7JhL76hyVEtOQ2E40dPzZK6QULb2HOG7JT+ceds20zDR2B/4ostrqcNW\nR8COBAcQJj2dZ8AIEyLsJmGPhQ/sqacIN5I94r5+MR0t28wAuhY=\n=e9aE\n-----END PGP SIGNATURE-----", "payload": "tree 73d1da8789a0a6109805768d7f2cad3336d3453b\nparent fee552d4873b1cce4e622c7eb2f0189b276b01be\nauthor Unreal Hoang <unrealhoang@gmail.com> 1562484669 +0900\ncommitter Unreal Hoang <unrealhoang@gmail.com> 1562506011 +0900\n\nadd projection to infer for loop variable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cd40d8306dfd3f2c55ad97de5167319350a592", "html_url": "https://github.com/rust-lang/rust/commit/f7cd40d8306dfd3f2c55ad97de5167319350a592", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7cd40d8306dfd3f2c55ad97de5167319350a592/comments", "author": {"login": "unrealhoang", "id": 1218094, "node_id": "MDQ6VXNlcjEyMTgwOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1218094?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unrealhoang", "html_url": "https://github.com/unrealhoang", "followers_url": "https://api.github.com/users/unrealhoang/followers", "following_url": "https://api.github.com/users/unrealhoang/following{/other_user}", "gists_url": "https://api.github.com/users/unrealhoang/gists{/gist_id}", "starred_url": "https://api.github.com/users/unrealhoang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unrealhoang/subscriptions", "organizations_url": "https://api.github.com/users/unrealhoang/orgs", "repos_url": "https://api.github.com/users/unrealhoang/repos", "events_url": "https://api.github.com/users/unrealhoang/events{/privacy}", "received_events_url": "https://api.github.com/users/unrealhoang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unrealhoang", "id": 1218094, "node_id": "MDQ6VXNlcjEyMTgwOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1218094?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unrealhoang", "html_url": "https://github.com/unrealhoang", "followers_url": "https://api.github.com/users/unrealhoang/followers", "following_url": "https://api.github.com/users/unrealhoang/following{/other_user}", "gists_url": "https://api.github.com/users/unrealhoang/gists{/gist_id}", "starred_url": "https://api.github.com/users/unrealhoang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unrealhoang/subscriptions", "organizations_url": "https://api.github.com/users/unrealhoang/orgs", "repos_url": "https://api.github.com/users/unrealhoang/repos", "events_url": "https://api.github.com/users/unrealhoang/events{/privacy}", "received_events_url": "https://api.github.com/users/unrealhoang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fee552d4873b1cce4e622c7eb2f0189b276b01be", "url": "https://api.github.com/repos/rust-lang/rust/commits/fee552d4873b1cce4e622c7eb2f0189b276b01be", "html_url": "https://github.com/rust-lang/rust/commit/fee552d4873b1cce4e622c7eb2f0189b276b01be"}], "stats": {"total": 205, "additions": 170, "deletions": 35}, "files": [{"sha": "b71590560e3c170ca273ff6f74c8008b98f8391c", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=f7cd40d8306dfd3f2c55ad97de5167319350a592", "patch": "@@ -86,6 +86,11 @@ impl Name {\n             \"Self\" => KnownName::SelfType,\n             \"self\" => KnownName::SelfParam,\n             \"macro_rules\" => KnownName::MacroRules,\n+\n+            \"std\" => KnownName::Std,\n+            \"iter\" => KnownName::Iter,\n+            \"IntoIterator\" => KnownName::IntoIterator,\n+            \"Item\" => KnownName::Item,\n             _ => return None,\n         };\n         Some(name)\n@@ -157,6 +162,11 @@ pub(crate) enum KnownName {\n     SelfParam,\n \n     MacroRules,\n+\n+    Std,\n+    Iter,\n+    IntoIterator,\n+    Item,\n }\n \n impl AsName for KnownName {\n@@ -182,6 +192,10 @@ impl AsName for KnownName {\n             KnownName::SelfType => \"Self\",\n             KnownName::SelfParam => \"self\",\n             KnownName::MacroRules => \"macro_rules\",\n+            KnownName::Std => \"std\",\n+            KnownName::Iter => \"iter\",\n+            KnownName::IntoIterator => \"IntoIterator\",\n+            KnownName::Item => \"Item\",\n         };\n         Name::new(s.into())\n     }"}, {"sha": "973de70dfb2498f0e3395caf780a5dee2424c1c7", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=f7cd40d8306dfd3f2c55ad97de5167319350a592", "patch": "@@ -28,24 +28,28 @@ use test_utils::tested_by;\n \n use super::{\n     autoderef, method_resolution, op, primitive,\n-    traits::{Guidance, Obligation, Solution},\n-    ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypableDef, TypeCtor,\n+    traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n+    ApplicationTy, CallableDef, ProjectionTy, Substs, TraitRef, Ty, TypableDef, TypeCtor,\n };\n use crate::{\n     adt::VariantDef,\n+    code_model::{ModuleDef::Trait, TypeAlias},\n     diagnostics::DiagnosticSink,\n     expr::{\n         self, Array, BinaryOp, BindingAnnotation, Body, Expr, ExprId, FieldPat, Literal, Pat,\n         PatId, Statement, UnaryOp,\n     },\n     generics::{GenericParams, HasGenericParams},\n-    nameres::Namespace,\n-    path::{GenericArg, GenericArgs},\n-    resolve::{Resolution, Resolver},\n+    nameres::{Namespace, PerNs},\n+    path::{GenericArg, GenericArgs, PathKind, PathSegment},\n+    resolve::{\n+        Resolution::{self, Def},\n+        Resolver,\n+    },\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    AdtDef, ConstData, DefWithBody, FnData, Function, HirDatabase, ImplItem, ModuleDef, Name, Path,\n-    StructField,\n+    AdtDef, AsName, ConstData, DefWithBody, FnData, Function, HirDatabase, ImplItem, KnownName,\n+    ModuleDef, Name, Path, StructField,\n };\n \n mod unify;\n@@ -323,34 +327,53 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            let (solution, canonicalized) = match &obligation {\n+            match &obligation {\n                 Obligation::Trait(tr) => {\n                     let canonicalized = self.canonicalizer().canonicalize_trait_ref(tr.clone());\n-                    (\n-                        self.db.implements(\n-                            self.resolver.krate().unwrap(),\n-                            canonicalized.value.clone(),\n-                        ),\n-                        canonicalized,\n-                    )\n-                }\n-            };\n-            match solution {\n-                Some(Solution::Unique(substs)) => {\n-                    canonicalized.apply_solution(self, substs.0);\n-                }\n-                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    canonicalized.apply_solution(self, substs.0);\n-                    self.obligations.push(obligation);\n-                }\n-                Some(_) => {\n-                    // FIXME use this when trying to resolve everything at the end\n-                    self.obligations.push(obligation);\n+                    let solution = self\n+                        .db\n+                        .implements(self.resolver.krate().unwrap(), canonicalized.value.clone());\n+                    match solution {\n+                        Some(Solution::Unique(substs)) => {\n+                            canonicalized.apply_solution(self, substs.0);\n+                        }\n+                        Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                            canonicalized.apply_solution(self, substs.0);\n+                            self.obligations.push(obligation);\n+                        }\n+                        Some(_) => {\n+                            // FIXME use this when trying to resolve everything at the end\n+                            self.obligations.push(obligation);\n+                        }\n+                        None => {\n+                            // FIXME obligation cannot be fulfilled => diagnostic\n+                        }\n+                    };\n                 }\n-                None => {\n-                    // FIXME obligation cannot be fulfilled => diagnostic\n+                Obligation::Projection(pr) => {\n+                    let canonicalized = self.canonicalizer().canonicalize_projection(pr.clone());\n+                    let solution = self\n+                        .db\n+                        .normalize(self.resolver.krate().unwrap(), canonicalized.value.clone());\n+\n+                    match solution {\n+                        Some(Solution::Unique(substs)) => {\n+                            canonicalized.apply_solution(self, substs.0);\n+                        }\n+                        Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                            canonicalized.apply_solution(self, substs.0);\n+                            self.obligations.push(obligation);\n+                        }\n+                        Some(_) => {\n+                            // FIXME use this when trying to resolve everything at the end\n+                            self.obligations.push(obligation);\n+                        }\n+                        None => {\n+                            // FIXME obligation cannot be fulfilled => diagnostic\n+                        }\n+                    };\n                 }\n-            }\n+            };\n         }\n     }\n \n@@ -967,8 +990,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, pat } => {\n-                let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                self.infer_pat(*pat, &Ty::Unknown, BindingMode::default());\n+                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n+\n+                let pat_ty = match self.resolve_into_iter_item() {\n+                    Some(into_iter_item_alias) => {\n+                        let pat_ty = self.new_type_var();\n+                        let projection = ProjectionPredicate {\n+                            ty: pat_ty.clone(),\n+                            projection_ty: ProjectionTy {\n+                                associated_ty: into_iter_item_alias,\n+                                parameters: vec![iterable_ty].into(),\n+                            },\n+                        };\n+                        self.obligations.push(Obligation::Projection(projection));\n+                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n+                    }\n+                    None => Ty::Unknown,\n+                };\n+\n+                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -1301,6 +1341,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_body(&mut self) {\n         self.infer_expr(self.body.body_expr(), &Expectation::has_type(self.return_ty.clone()));\n     }\n+\n+    fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n+        let into_iter_path = Path {\n+            kind: PathKind::Abs,\n+            segments: vec![\n+                PathSegment { name: KnownName::Std.as_name(), args_and_bindings: None },\n+                PathSegment { name: KnownName::Iter.as_name(), args_and_bindings: None },\n+                PathSegment { name: KnownName::IntoIterator.as_name(), args_and_bindings: None },\n+            ],\n+        };\n+\n+        match self.resolver.resolve_path_segments(self.db, &into_iter_path).into_fully_resolved() {\n+            PerNs { types: Some(Def(Trait(trait_))), .. } => {\n+                Some(trait_.associated_type_by_name(self.db, KnownName::Item.as_name())?)\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n /// The ID of a type variable."}, {"sha": "a24e5eb5c636fdfa010aea970b5154c73f49d2fc", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=f7cd40d8306dfd3f2c55ad97de5167319350a592", "patch": "@@ -2,7 +2,7 @@\n \n use super::InferenceContext;\n use crate::db::HirDatabase;\n-use crate::ty::{Canonical, InferTy, TraitRef, Ty};\n+use crate::ty::{Canonical, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -86,6 +86,25 @@ where\n         }\n     }\n \n+    fn do_canonicalize_projection_ty(&mut self, projection_ty: ProjectionTy) -> ProjectionTy {\n+        let params = projection_ty\n+            .parameters\n+            .iter()\n+            .map(|ty| self.do_canonicalize_ty(ty.clone()))\n+            .collect::<Vec<_>>();\n+        ProjectionTy { associated_ty: projection_ty.associated_ty, parameters: params.into() }\n+    }\n+\n+    fn do_canonicalize_projection_predicate(\n+        &mut self,\n+        projection: ProjectionPredicate,\n+    ) -> ProjectionPredicate {\n+        let ty = self.do_canonicalize_ty(projection.ty);\n+        let projection_ty = self.do_canonicalize_projection_ty(projection.projection_ty);\n+\n+        ProjectionPredicate { ty, projection_ty }\n+    }\n+\n     pub fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n         let result = self.do_canonicalize_ty(ty);\n         self.into_canonicalized(result)\n@@ -95,6 +114,14 @@ where\n         let result = self.do_canonicalize_trait_ref(trait_ref);\n         self.into_canonicalized(result)\n     }\n+\n+    pub fn canonicalize_projection(\n+        mut self,\n+        projection: ProjectionPredicate,\n+    ) -> Canonicalized<ProjectionPredicate> {\n+        let result = self.do_canonicalize_projection_predicate(projection);\n+        self.into_canonicalized(result)\n+    }\n }\n \n impl<T> Canonicalized<T> {"}, {"sha": "fe5e89f2d307db6702b4f6e31d3052640b541e9d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=f7cd40d8306dfd3f2c55ad97de5167319350a592", "patch": "@@ -20,6 +20,42 @@ use crate::{\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n+#[test]\n+fn infer_for_loop() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+struct Vec<T> {}\n+impl<T> Vec<T> {\n+    fn new() -> Self { Vec {} }\n+    fn push(&mut self, t: T) { }\n+}\n+\n+impl<T> ::std::iter::IntoIterator for Vec<T> {\n+    type Item=T;\n+}\n+fn test() {\n+    let v = Vec::new();\n+    v.push(\"foo\");\n+    for x in v {\n+        x<|>;\n+    }\n+}\n+\n+//- /lib.rs\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+}\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"std\"]),\n+        \"std\": (\"/lib.rs\", []),\n+    });\n+    assert_eq!(\"&str\", type_at_pos(&db, pos));\n+}\n #[test]\n fn infer_basics() {\n     assert_snapshot_matches!("}, {"sha": "3e28852b6bbe3292651c49c6d0c2ddb1ed64b175", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd40d8306dfd3f2c55ad97de5167319350a592/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=f7cd40d8306dfd3f2c55ad97de5167319350a592", "patch": "@@ -75,7 +75,7 @@ pub enum Obligation {\n     /// Prove that a certain type implements a trait (the type is the `Self` type\n     /// parameter to the `TraitRef`).\n     Trait(TraitRef),\n-    // Projection(ProjectionPredicate),\n+    Projection(ProjectionPredicate),\n }\n \n impl Obligation {"}]}