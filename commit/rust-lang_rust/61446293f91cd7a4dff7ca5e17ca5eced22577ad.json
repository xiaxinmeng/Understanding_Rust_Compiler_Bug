{"sha": "61446293f91cd7a4dff7ca5e17ca5eced22577ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNDQ2MjkzZjkxY2Q3YTRkZmY3Y2E1ZTE3Y2E1ZWNlZDIyNTc3YWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T23:46:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T23:46:19Z"}, "message": "rustc: Move some more routines that operate on struct definitions out of line", "tree": {"sha": "97d369ffb2cde11b0f94337a7efb8aaca0020af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97d369ffb2cde11b0f94337a7efb8aaca0020af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61446293f91cd7a4dff7ca5e17ca5eced22577ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61446293f91cd7a4dff7ca5e17ca5eced22577ad", "html_url": "https://github.com/rust-lang/rust/commit/61446293f91cd7a4dff7ca5e17ca5eced22577ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61446293f91cd7a4dff7ca5e17ca5eced22577ad/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f711e72f72cf69166902fe9df9c5063e5aa14ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f711e72f72cf69166902fe9df9c5063e5aa14ff", "html_url": "https://github.com/rust-lang/rust/commit/0f711e72f72cf69166902fe9df9c5063e5aa14ff"}], "stats": {"total": 311, "additions": 169, "deletions": 142}, "files": [{"sha": "545d3821f02eddc74cb03120b3c83684c772af39", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=61446293f91cd7a4dff7ca5e17ca5eced22577ad", "patch": "@@ -205,20 +205,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                 // class and for its ctor\n                 add_to_index(ebml_w, path, index, it.ident);\n \n-                match struct_def.ctor {\n-                    none => {\n-                        // Nothing to do.\n-                    }\n-                    some(ctor) => {\n-                        encode_named_def_id(ebml_w, it.ident,\n-                                            local_def(ctor.node.id));\n-                    }\n-                }\n-\n-                encode_class_item_paths(ebml_w,\n-                                        struct_def.members,\n-                                        vec::append_one(path, it.ident),\n-                                        index);\n+                encode_struct_def(ebml_w, struct_def, path, it.ident, index);\n             }\n           }\n           item_enum(variants, _) => {\n@@ -238,6 +225,26 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     }\n }\n \n+fn encode_struct_def(ebml_w: ebml::writer,\n+                     struct_def: ast::struct_def,\n+                     path: ~[ast::ident],\n+                     ident: ast::ident,\n+                     &index: ~[entry<~str>]) {\n+    match struct_def.ctor {\n+        none => {\n+            // Nothing to do.\n+        }\n+        some(ctor) => {\n+            encode_named_def_id(ebml_w, ident, local_def(ctor.node.id));\n+        }\n+    }\n+\n+    encode_class_item_paths(ebml_w,\n+                            struct_def.members,\n+                            vec::append_one(path, ident),\n+                            index);\n+}\n+\n fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));"}, {"sha": "36397250f1ae8e769b27529fee415f69581e6ff7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=61446293f91cd7a4dff7ca5e17ca5eced22577ad", "patch": "@@ -4900,30 +4900,36 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n       ast::item_class(struct_def, tps) => {\n-        if tps.len() == 0u {\n-          let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n-                         vtables: none,\n-                         bounds: @~[]};\n-          do option::iter(struct_def.ctor) |ctor| {\n-            trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n-                             get_item_val(ccx, ctor.node.id), psubsts,\n-                             ctor.node.id, local_def(item.id), ctor.span);\n-          }\n-          do option::iter(struct_def.dtor) |dtor| {\n-             trans_class_dtor(ccx, *path, dtor.node.body,\n-               dtor.node.id, none, none, local_def(item.id));\n-          };\n-        }\n-        // If there are ty params, the ctor will get monomorphized\n-\n-        // Translate methods\n-        let (_, ms) = ast_util::split_class_items(struct_def.members);\n-        impl::trans_impl(ccx, *path, item.ident, ms, tps);\n+        trans_struct_def(ccx, struct_def, tps, path, item.ident, item.id);\n       }\n       _ => {/* fall through */ }\n     }\n }\n \n+fn trans_struct_def(ccx: @crate_ctxt, struct_def: ast::struct_def,\n+                    tps: ~[ast::ty_param], path: @ast_map::path,\n+                    ident: ast::ident, id: ast::node_id) {\n+    if tps.len() == 0u {\n+      let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n+                     vtables: none,\n+                     bounds: @~[]};\n+      do option::iter(struct_def.ctor) |ctor| {\n+        trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n+                         get_item_val(ccx, ctor.node.id), psubsts,\n+                         ctor.node.id, local_def(id), ctor.span);\n+      }\n+      do option::iter(struct_def.dtor) |dtor| {\n+         trans_class_dtor(ccx, *path, dtor.node.body,\n+           dtor.node.id, none, none, local_def(id));\n+      };\n+    }\n+    // If there are ty params, the ctor will get monomorphized\n+\n+    // Translate methods\n+    let (_, ms) = ast_util::split_class_items(struct_def.members);\n+    impl::trans_impl(ccx, *path, ident, ms, tps);\n+}\n+\n // Translate a module. Doing this amounts to translating the items in the\n // module; there ends up being no artifact (aside from linkage names) of\n // separate modules in the compiled program.  That's because modules exist"}, {"sha": "d5165e26a2b54c51295f9c134894e2880c7cf56a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=61446293f91cd7a4dff7ca5e17ca5eced22577ad", "patch": "@@ -400,6 +400,42 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n \n }\n \n+fn check_struct(ccx: @crate_ctxt, struct_def: ast::struct_def,\n+                id: ast::node_id, span: span) {\n+    let tcx = ccx.tcx;\n+    let class_t = {self_ty: ty::node_id_to_type(tcx, id), node_id: id};\n+\n+    do option::iter(struct_def.ctor) |ctor| {\n+        // typecheck the ctor\n+        check_bare_fn(ccx, ctor.node.dec,\n+                      ctor.node.body, ctor.node.id,\n+                      some(class_t));\n+        // Write the ctor's self's type\n+        write_ty_to_tcx(tcx, ctor.node.self_id, class_t.self_ty);\n+    }\n+\n+    do option::iter(struct_def.dtor) |dtor| {\n+        // typecheck the dtor\n+        check_bare_fn(ccx, ast_util::dtor_dec(),\n+                      dtor.node.body, dtor.node.id,\n+                      some(class_t));\n+        // Write the dtor's self's type\n+        write_ty_to_tcx(tcx, dtor.node.self_id, class_t.self_ty);\n+    };\n+\n+    // typecheck the members\n+    for struct_def.members.each |m| {\n+        check_class_member(ccx, class_t, m);\n+    }\n+    // Check that there's at least one field\n+    let (fields,_) = split_class_items(struct_def.members);\n+    if fields.len() < 1u {\n+        ccx.tcx.sess.span_err(span, ~\"a class must have at least one field\");\n+    }\n+    // Check that the class is instantiable\n+    check_instantiable(ccx.tcx, span, id);\n+}\n+\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     match it.node {\n       ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n@@ -433,41 +469,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         }\n       }\n       ast::item_class(struct_def, _) => {\n-        let tcx = ccx.tcx;\n-        let class_t = {self_ty: ty::node_id_to_type(tcx, it.id),\n-                       node_id: it.id};\n-\n-        do option::iter(struct_def.ctor) |ctor| {\n-            // typecheck the ctor\n-            check_bare_fn(ccx, ctor.node.dec,\n-                          ctor.node.body, ctor.node.id,\n-                          some(class_t));\n-            // Write the ctor's self's type\n-            write_ty_to_tcx(tcx, ctor.node.self_id, class_t.self_ty);\n-        }\n-\n-        do option::iter(struct_def.dtor) |dtor| {\n-            // typecheck the dtor\n-            check_bare_fn(ccx, ast_util::dtor_dec(),\n-                          dtor.node.body, dtor.node.id,\n-                          some(class_t));\n-            // Write the dtor's self's type\n-            write_ty_to_tcx(tcx, dtor.node.self_id, class_t.self_ty);\n-        };\n-\n-        // typecheck the members\n-        for struct_def.members.each |m| {\n-            check_class_member(ccx, class_t, m);\n-        }\n-        // Check that there's at least one field\n-        let (fields,_) = split_class_items(struct_def.members);\n-        if fields.len() < 1u {\n-            ccx.tcx.sess.span_err(\n-                it.span,\n-                ~\"a class must have at least one field\");\n-        }\n-        // Check that the class is instantiable\n-        check_instantiable(ccx.tcx, it.span, it.id);\n+        check_struct(ccx, struct_def, it.id, it.span);\n       }\n       ast::item_ty(t, tps) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);"}, {"sha": "539c0ea2e5a030128852a7c73441f6fd421f7e38", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=61446293f91cd7a4dff7ca5e17ca5eced22577ad", "patch": "@@ -505,29 +505,9 @@ class CoherenceChecker {\n                     methods: methods\n                 };\n             }\n-            item_class(struct_def, ty_params) => {\n-                let mut methods = ~[];\n-                for struct_def.members.each |class_member| {\n-                    match class_member.node {\n-                        instance_var(*) => {\n-                            // Nothing to do.\n-                        }\n-                        class_method(ast_method) => {\n-                            push(methods, @{\n-                                did: local_def(ast_method.id),\n-                                n_tps: ast_method.tps.len(),\n-                                ident: ast_method.ident,\n-                                self_type: ast_method.self_ty.node\n-                            });\n-                        }\n-                    }\n-                }\n-\n-                return @{\n-                    did: local_def(item.id),\n-                    ident: item.ident,\n-                    methods: methods\n-                };\n+            item_class(struct_def, _) => {\n+                return self.create_impl_from_struct(struct_def, item.ident,\n+                                                    item.id);\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n@@ -537,6 +517,30 @@ class CoherenceChecker {\n         }\n     }\n \n+    fn create_impl_from_struct(struct_def: ast::struct_def,\n+                               ident: ast::ident,\n+                               id: node_id)\n+                            -> @Impl {\n+        let mut methods = ~[];\n+        for struct_def.members.each |class_member| {\n+            match class_member.node {\n+                instance_var(*) => {\n+                    // Nothing to do.\n+                }\n+                class_method(ast_method) => {\n+                    push(methods, @{\n+                        did: local_def(ast_method.id),\n+                        n_tps: ast_method.tps.len(),\n+                        ident: ast_method.ident,\n+                        self_type: ast_method.self_ty.node\n+                    });\n+                }\n+            }\n+        }\n+\n+        return @{ did: local_def(id), ident: ident, methods: methods };\n+    }\n+\n     fn span_of_impl(implementation: @Impl) -> span {\n         assert implementation.did.crate == local_crate;\n         match self.crate_context.tcx.items.find(implementation.did.node) {"}, {"sha": "2abc201d132c11e275c8bc5dc269bbd9ded0fdd5", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61446293f91cd7a4dff7ca5e17ca5eced22577ad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=61446293f91cd7a4dff7ca5e17ca5eced22577ad", "patch": "@@ -388,57 +388,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        do option::iter(struct_def.ctor) |ctor| {\n-            // Write the ctor type\n-            let t_args = ctor.node.dec.inputs.map(\n-                |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n-            let t_res = ty::mk_class(\n-                tcx, local_def(it.id),\n-                {self_r: if rp {some(ty::re_bound(ty::br_self))} else {none},\n-                 self_ty: none,\n-                 tps: ty::ty_params_to_tys(tcx, tps)});\n-            let t_ctor = ty::mk_fn(\n-                tcx, {purity: ast::impure_fn,\n-                      proto: ast::proto_block,\n-                      bounds: @~[],\n-                      inputs: t_args,\n-                      output: t_res,\n-                      ret_style: ast::return_val});\n-            write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n-            tcx.tcache.insert(local_def(ctor.node.id),\n-                              {bounds: tpt.bounds,\n-                               rp: rp,\n-                               ty: t_ctor});\n-        }\n-\n-        do option::iter(struct_def.dtor) |dtor| {\n-            // Write the dtor type\n-            let t_dtor = ty::mk_fn(\n-                tcx,\n-                ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_block, @~[],\n-                              ast_util::dtor_dec(), none));\n-            write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n-            tcx.tcache.insert(local_def(dtor.node.id),\n-                              {bounds: tpt.bounds,\n-                               rp: rp,\n-                               ty: t_dtor});\n-        };\n-        ensure_trait_methods(ccx, it.id);\n-\n-        // Write the type of each of the members\n-        let (fields, methods) = split_class_items(struct_def.members);\n-        for fields.each |f| {\n-           convert_field(ccx, rp, tpt.bounds, f);\n-        }\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n-        let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n-        for struct_def.traits.each |trait_ref| {\n-            check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n-            // trait_ref.impl_id represents (class, trait) pair\n-            write_ty_to_tcx(tcx, trait_ref.impl_id, tpt.ty);\n-            tcx.tcache.insert(local_def(trait_ref.impl_id), tpt);\n-        }\n+        convert_struct(ccx, rp, struct_def, tps, tpt, it.id);\n       }\n       _ => {\n         // This call populates the type cache with the converted type\n@@ -449,6 +399,64 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n       }\n     }\n }\n+\n+fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: ast::struct_def,\n+                  tps: ~[ast::ty_param], tpt: ty::ty_param_bounds_and_ty,\n+                  id: ast::node_id) {\n+    let tcx = ccx.tcx;\n+    do option::iter(struct_def.ctor) |ctor| {\n+        // Write the ctor type\n+        let t_args = ctor.node.dec.inputs.map(\n+            |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n+        let t_res = ty::mk_class(\n+            tcx, local_def(id),\n+            {self_r: if rp {some(ty::re_bound(ty::br_self))} else {none},\n+             self_ty: none,\n+             tps: ty::ty_params_to_tys(tcx, tps)});\n+        let t_ctor = ty::mk_fn(\n+            tcx, {purity: ast::impure_fn,\n+                  proto: ast::proto_block,\n+                  bounds: @~[],\n+                  inputs: t_args,\n+                  output: t_res,\n+                  ret_style: ast::return_val});\n+        write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n+        tcx.tcache.insert(local_def(ctor.node.id),\n+                          {bounds: tpt.bounds,\n+                           rp: rp,\n+                           ty: t_ctor});\n+    }\n+\n+    do option::iter(struct_def.dtor) |dtor| {\n+        // Write the dtor type\n+        let t_dtor = ty::mk_fn(\n+            tcx,\n+            ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_block, @~[],\n+                          ast_util::dtor_dec(), none));\n+        write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n+        tcx.tcache.insert(local_def(dtor.node.id),\n+                          {bounds: tpt.bounds,\n+                           rp: rp,\n+                           ty: t_dtor});\n+    };\n+    ensure_trait_methods(ccx, id);\n+\n+    // Write the type of each of the members\n+    let (fields, methods) = split_class_items(struct_def.members);\n+    for fields.each |f| {\n+       convert_field(ccx, rp, tpt.bounds, f);\n+    }\n+    let {bounds, substs} = mk_substs(ccx, tps, rp);\n+    let selfty = ty::mk_class(tcx, local_def(id), substs);\n+    let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n+    for struct_def.traits.each |trait_ref| {\n+        check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n+        // trait_ref.impl_id represents (class, trait) pair\n+        write_ty_to_tcx(tcx, trait_ref.impl_id, tpt.ty);\n+        tcx.tcache.insert(local_def(trait_ref.impl_id), tpt);\n+    }\n+}\n+\n fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type"}]}