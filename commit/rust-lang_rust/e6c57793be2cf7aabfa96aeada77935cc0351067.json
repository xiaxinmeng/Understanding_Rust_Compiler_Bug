{"sha": "e6c57793be2cf7aabfa96aeada77935cc0351067", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YzU3NzkzYmUyY2Y3YWFiZmE5NmFlYWRhNzc5MzVjYzAzNTEwNjc=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-02T23:40:57Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-02T23:40:57Z"}, "message": "IPv6 support for UDP and TCP.", "tree": {"sha": "f2f4dcb8a4b3b32e692dbfb549024e3c1e9fa580", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2f4dcb8a4b3b32e692dbfb549024e3c1e9fa580"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6c57793be2cf7aabfa96aeada77935cc0351067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c57793be2cf7aabfa96aeada77935cc0351067", "html_url": "https://github.com/rust-lang/rust/commit/e6c57793be2cf7aabfa96aeada77935cc0351067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6c57793be2cf7aabfa96aeada77935cc0351067/comments", "author": null, "committer": null, "parents": [{"sha": "42f3f069fa1963cdf19117e57a83089889a64f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/42f3f069fa1963cdf19117e57a83089889a64f37", "html_url": "https://github.com/rust-lang/rust/commit/42f3f069fa1963cdf19117e57a83089889a64f37"}], "stats": {"total": 1008, "additions": 877, "deletions": 131}, "files": [{"sha": "2425c909bf3d8b0a4a09a9ebdb5a9dde0ec698a9", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 200, "deletions": 7, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -148,7 +148,7 @@ mod test {\n     }\n \n     #[test]\n-    fn smoke_test() {\n+    fn smoke_test_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -168,7 +168,27 @@ mod test {\n     }\n \n     #[test]\n-    fn read_eof() {\n+    fn smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n+            }\n+\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -188,7 +208,27 @@ mod test {\n     }\n \n     #[test]\n-    fn read_eof_twice() {\n+    fn read_eof_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_twice_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -210,7 +250,29 @@ mod test {\n     }\n \n     #[test]\n-    fn write_close() {\n+    fn read_eof_twice_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn write_close_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n@@ -239,7 +301,36 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_serial() {\n+    fn write_close_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let buf = [0];\n+                loop {\n+                    let mut stop = false;\n+                    do io_error::cond.trap(|e| {\n+                        // NB: ECONNRESET on linux, EPIPE on mac\n+                        assert!(e.kind == ConnectionReset || e.kind == BrokenPipe);\n+                        stop = true;\n+                    }).in {\n+                        stream.write(buf);\n+                    }\n+                    if stop { break }\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             let max = 10;\n@@ -264,7 +355,32 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_interleaved_greedy_schedule() {\n+    fn multiple_connect_serial_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            let max = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for max.times {\n+                    let mut stream = listener.accept();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert_eq!(buf[0], 99);\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                for max.times {\n+                    let mut stream = TcpStream::connect(addr);\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n@@ -303,7 +419,46 @@ mod test {\n     }\n \n     #[test]\n-    fn multiple_connect_interleaved_lazy_schedule() {\n+    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell::new(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n@@ -340,5 +495,43 @@ mod test {\n             }\n         }\n     }\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip6();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell::new(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n \n }"}, {"sha": "f3b5278357392d94fbdecebea5b6ef025d7c4f61", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -115,7 +115,7 @@ mod test {\n     }\n \n     #[test]\n-    fn socket_smoke_test() {\n+    fn socket_smoke_test_ip4() {\n         do run_in_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n@@ -147,7 +147,39 @@ mod test {\n     }\n \n     #[test]\n-    fn stream_smoke_test() {\n+    fn socket_smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip6();\n+            let client_ip = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let mut buf = [0];\n+                        match server.recvfrom(buf) {\n+                            Some((nread, src)) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                                assert_eq!(src, client_ip);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => client.sendto([99], server_ip),\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip4() {\n         do run_in_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n@@ -182,4 +214,41 @@ mod test {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn stream_smoke_test_ip6() {\n+        do run_in_newsched_task {\n+            let server_ip = next_test_ip6();\n+            let client_ip = next_test_ip6();\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(server_ip) {\n+                    Some(server) => {\n+                        let server = ~server;\n+                        let mut stream = server.connect(client_ip);\n+                        let mut buf = [0];\n+                        match stream.read(buf) {\n+                            Some(nread) => {\n+                                assert_eq!(nread, 1);\n+                                assert_eq!(buf[0], 99);\n+                            }\n+                            None => fail!()\n+                        }\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                match UdpSocket::bind(client_ip) {\n+                    Some(client) => {\n+                        let client = ~client;\n+                        let mut stream = client.connect(server_ip);\n+                        stream.write([99]);\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "bcbdea03234c898af554998b778b9d044ef1eebb", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -23,6 +23,7 @@ pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n+pub type RtioTcpSocketObject = (); // TODO\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -48,16 +49,39 @@ pub trait IoFactory {\n     fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError>;\n }\n \n-pub trait RtioTcpListener {\n+pub trait RtioTcpListener : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn accept_simultaneously(&self);\n+    fn dont_accept_simultaneously(&self);\n }\n \n-pub trait RtioTcpStream {\n+pub trait RtioTcpStream : RtioSocket {\n     fn read(&self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&self, buf: &[u8]) -> Result<(), IoError>;\n+    fn peer_name(&self) -> IpAddr;\n+    fn control_congestion(&self);\n+    fn nodelay(&self);\n+    fn keepalive(&self, delay_in_seconds: uint);\n+    fn letdie(&self);\n }\n \n-pub trait RtioUdpSocket {\n+pub trait RtioSocket {\n+    fn socket_name(&self) -> IpAddr;\n+}\n+\n+pub trait RtioUdpSocket : RtioSocket {\n     fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n     fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n+\n+    fn join_multicast(&self, multi: IpAddr);\n+    fn leave_multicast(&self, multi: IpAddr);\n+\n+    fn loop_multicast_locally(&self);\n+    fn dont_loop_multicast_locally(&self);\n+\n+    fn multicast_time_to_live(&self, ttl: int);\n+    fn time_to_live(&self, ttl: int);\n+\n+    fn hear_broadcasts(&self);\n+    fn ignore_broadcasts(&self);\n }"}, {"sha": "e1b338e2cad18f10eb116f21a3e348a0c3774d8c", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -17,7 +17,7 @@ use iterator::IteratorUtil;\n use vec::{OwnedVector, MutableVector};\n use result::{Result, Ok, Err};\n use unstable::run_in_bare_thread;\n-use super::io::net::ip::{IpAddr, Ipv4};\n+use super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::comm::oneshot;\n use rt::task::Task;\n use rt::thread::Thread;\n@@ -405,11 +405,16 @@ pub fn next_test_port() -> u16 {\n     }\n }\n \n-/// Get a unique localhost:port pair starting at 9600\n+/// Get a unique IPv4 localhost:port pair starting at 9600\n pub fn next_test_ip4() -> IpAddr {\n     Ipv4(127, 0, 0, 1, next_test_port())\n }\n \n+/// Get a unique IPv6 localhost:port pair starting at 9600\n+pub fn next_test_ip6() -> IpAddr {\n+    Ipv6(0, 0, 0, 0, 0, 0, 0, 1, next_test_port())\n+}\n+\n /// Get a constant that represents the number of times to repeat stress tests. Default 1.\n pub fn stress_factor() -> uint {\n     use os::getenv;"}, {"sha": "4c3cde7d6df6f0a51c38b6f59cb3f589125a6af8", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 329, "deletions": 90, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -15,48 +15,144 @@ use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n-use rt::io::net::ip::{IpAddr, Ipv4};\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n+use num;\n \n-pub fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n-    match addr {\n-        Ipv4(a, b, c, d, p) => {\n-            unsafe {\n-                let addr = malloc_ip4_addr(fmt!(\"%u.%u.%u.%u\",\n-                                                a as uint,\n-                                                b as uint,\n-                                                c as uint,\n-                                                d as uint), p as int);\n-                do (|| {\n-                    f(addr)\n-                }).finally {\n-                    free_ip4_addr(addr);\n-                }\n-            }\n+enum UvIpAddr {\n+    UvIpv4(*sockaddr_in),\n+    UvIpv6(*sockaddr_in6),\n+}\n+\n+fn sockaddr_to_UvIpAddr(addr: *uvll::sockaddr) -> UvIpAddr {\n+    unsafe {\n+        assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n+        assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n+        match addr {\n+            _ if is_ip4_addr(addr) => UvIpv4(as_sockaddr_in(addr)),\n+            _ if is_ip6_addr(addr) => UvIpv6(as_sockaddr_in6(addr)),\n+            _ => fail!(),\n         }\n-        _ => fail!() // TODO ipv6\n     }\n }\n \n-pub fn uv_ip4_to_ip4(addr: *sockaddr_in) -> IpAddr {\n-    let ip4_size = 16;\n-    let buf = vec::from_elem(ip4_size + 1 /*null terminated*/, 0u8);\n-    unsafe { uvll::ip4_name(addr, vec::raw::to_ptr(buf), ip4_size as u64) };\n-    let port = unsafe { uvll::ip4_port(addr) };\n-    let ip_str = str::from_bytes_slice(buf).trim_right_chars(&'\\x00');\n-    let ip: ~[u8] = ip_str.split_iter('.')\n-                          .transform(|s: &str| -> u8 {\n-                                        let x = FromStr::from_str(s);\n-                                        assert!(x.is_some());\n-                                        x.unwrap() })\n-                          .collect();\n-    assert!(ip.len() >= 4);\n-    Ipv4(ip[0], ip[1], ip[2], ip[3], port as u16)\n+fn ip_as_uv_ip<T>(addr: IpAddr, f: &fn(UvIpAddr) -> T) -> T {\n+    let malloc = match addr {\n+        Ipv4(*) => malloc_ip4_addr,\n+        Ipv6(*) => malloc_ip6_addr,\n+    };\n+    let wrap = match addr {\n+        Ipv4(*) => UvIpv4,\n+        Ipv6(*) => UvIpv6,\n+    };\n+    let ip_str = match addr {\n+        Ipv4(x1, x2, x3, x4, _) =>\n+            fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n+        Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n+            fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                  x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n+                  x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n+    };\n+    let port = match addr {\n+        Ipv4(_, _, _, _, p) | Ipv6(_, _, _, _, _, _, _, _, p) => p as int\n+    };\n+    let free = match addr {\n+        Ipv4(*) => free_ip4_addr,\n+        Ipv6(*) => free_ip6_addr,\n+    };\n+\n+    let addr = unsafe { malloc(ip_str, port) };\n+    do (|| {\n+        f(wrap(addr))\n+    }).finally {\n+        unsafe { free(addr) };\n+    }\n+}\n+\n+fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n+    let ip_size = match addr {\n+        UvIpv4(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n+        UvIpv6(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n+    };\n+    let ip_name = {\n+        let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n+        unsafe {\n+            match addr {\n+                UvIpv4(addr) => uvll::ip4_name(addr, vec::raw::to_ptr(buf), ip_size as u64),\n+                UvIpv6(addr) => uvll::ip6_name(addr, vec::raw::to_ptr(buf), ip_size as u64),\n+            }\n+        };\n+        buf\n+    };\n+    let ip_port = unsafe {\n+        let port = match addr {\n+            UvIpv4(addr) => uvll::ip4_port(addr),\n+            UvIpv6(addr) => uvll::ip6_port(addr),\n+        };\n+        port as u16\n+    };\n+    let ip_str = str::from_bytes_slice(ip_name).trim_right_chars(&'\\x00');\n+    let ip = match addr {\n+        UvIpv4(*) => {\n+            let ip: ~[u8] = \n+                ip_str.split_iter('.')\n+                      .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n+                      .collect();\n+            assert_eq!(ip.len(), 4);\n+            Ipv4(ip[0], ip[1], ip[2], ip[3], ip_port)\n+        },\n+        UvIpv6(*) => {\n+            let ip: ~[u16] = {\n+                let read_hex_segment = |s: &str| -> u16 {\n+                    num::FromStrRadix::from_str_radix(s, 16u).unwrap()\n+                };\n+                let convert_each_segment = |s: &str| -> ~[u16] {\n+                    match s {\n+                        \"\" => ~[],\n+                        s => s.split_iter(':').transform(read_hex_segment).collect(),\n+                    }\n+                };\n+                let expand_shorthand_and_convert = |s: &str| -> ~[~[u16]] {\n+                    s.split_str_iter(\"::\").transform(convert_each_segment).collect()\n+                };\n+                match expand_shorthand_and_convert(ip_str) {\n+                    [x] => x, // no shorthand found\n+                    [l, r] => l + vec::from_elem(8 - l.len() - r.len(), 0u16) + r, // fill the gap\n+                    _ => fail!(), // impossible. only one shorthand allowed.\n+                }\n+            };\n+            assert_eq!(ip.len(), 8);\n+            Ipv6(ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7], ip_port)\n+        },\n+    };\n+\n+    // finally run the closure\n+    f(ip)\n+}\n+\n+fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n+    use util;\n+    uv_ip_as_ip(addr, util::id)\n }\n \n+#[cfg(test)]\n+#[test]\n+fn test_ip4_conversion() {\n+    use rt;\n+    let ip4 = rt::test::next_test_ip4();\n+    assert_eq!(ip4, ip_as_uv_ip(ip4, uv_ip_to_ip));\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_ip6_conversion() {\n+    use rt;\n+    let ip6 = rt::test::next_test_ip6();\n+    assert_eq!(ip6, ip_as_uv_ip(ip6, uv_ip_to_ip));\n+}\n \n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n@@ -169,18 +265,17 @@ impl TcpWatcher {\n     }\n \n     pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n-        match address {\n-            Ipv4(*) => {\n-                do ip4_as_uv_ip4(address) |addr| {\n-                    let result = unsafe { uvll::tcp_bind(self.native_handle(), addr) };\n-                    if result == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(last_uv_error(self))\n-                    }\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::tcp_bind(self.native_handle(), addr),\n+                    UvIpv6(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n                 }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(last_uv_error(self)),\n             }\n-            _ => fail!()\n         }\n     }\n \n@@ -190,16 +285,13 @@ impl TcpWatcher {\n             self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n-            match address {\n-                Ipv4(*) => {\n-                    do ip4_as_uv_ip4(address) |addr| {\n-                        rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                        assert_eq!(0, \n-                                   uvll::tcp_connect(connect_handle, self.native_handle(),\n-                                                    addr, connect_cb));\n-                    }\n-                }\n-                _ => fail!()\n+            rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+            do ip_as_uv_ip(address) |addr| {\n+                let result = match addr {\n+                    UvIpv4(addr) => uvll::tcp_connect(connect_handle, self.native_handle(), addr, connect_cb),\n+                    UvIpv6(addr) => uvll::tcp_connect6(connect_handle, self.native_handle(), addr, connect_cb),\n+                };\n+                assert_eq!(0, result);\n             }\n \n             extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n@@ -266,20 +358,17 @@ impl UdpWatcher {\n     }\n \n     pub fn bind(&self, address: IpAddr) -> Result<(), UvError> {\n-        match address {\n-            Ipv4(*) => {\n-                do ip4_as_uv_ip4(address) |addr| {\n-                    let result = unsafe {\n-                        uvll::udp_bind(self.native_handle(), addr, 0u32)\n-                    };\n-                    if result == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(last_uv_error(self))\n-                    }\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n+                    UvIpv6(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n                 }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(last_uv_error(self)),\n             }\n-            _ => fail!() // TODO ipv6\n         }\n     }\n \n@@ -299,17 +388,15 @@ impl UdpWatcher {\n             return (*alloc_cb)(suggested_size as uint);\n         }\n \n-        /* TODO the socket address should actually be a pointer to\n-           either a sockaddr_in or sockaddr_in6.\n-           In libuv, the udp_recv callback takes a struct *sockaddr */\n         extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n-                          addr: *uvll::sockaddr_in, flags: c_uint) {\n+                          addr: *uvll::sockaddr, flags: c_uint) {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n             let status = status_to_maybe_uv_error(handle, nread as c_int);\n-            (*cb)(udp_watcher, nread as int, buf, uv_ip4_to_ip4(addr), flags as uint, status);\n+            let addr = uv_ip_to_ip(sockaddr_to_UvIpAddr(addr));\n+            (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n     }\n \n@@ -326,17 +413,14 @@ impl UdpWatcher {\n         }\n \n         let req = UdpSendRequest::new();\n-        match address {\n-            Ipv4(*) => {\n-                do ip4_as_uv_ip4(address) |addr| {\n-                    unsafe {\n-                        assert_eq!(0, uvll::udp_send(req.native_handle(),\n-                                                    self.native_handle(),\n-                                                    [buf], addr, send_cb));\n-                    }\n+        do ip_as_uv_ip(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4(addr) => uvll::udp_send(req.native_handle(), self.native_handle(), [buf], addr, send_cb),\n+                    UvIpv6(addr) => uvll::udp_send6(req.native_handle(), self.native_handle(), [buf], addr, send_cb),\n                 }\n-            }\n-            _ => fail!() // TODO ipv6\n+            };\n+            assert_eq!(0, result);\n         }\n \n         extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n@@ -486,18 +570,30 @@ mod test {\n     use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n \n     #[test]\n-    fn test_ip4_conversion() {\n-        let ip4 = next_test_ip4();\n-        assert_eq!(ip4, ip4_as_uv_ip4(ip4, uv_ip4_to_ip4));\n+    fn connect_close_ip4() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n     }\n \n     #[test]\n-    fn connect_close() {\n+    fn connect_close_ip6() {\n         do run_in_bare_thread() {\n             let mut loop_ = Loop::new();\n             let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n             // Connect to a port where nobody is listening\n-            let addr = next_test_ip4();\n+            let addr = next_test_ip6();\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n@@ -510,7 +606,7 @@ mod test {\n     }\n \n     #[test]\n-    fn udp_bind_close() {\n+    fn udp_bind_close_ip4() {\n         do run_in_bare_thread() {\n             let mut loop_ = Loop::new();\n             let udp_watcher = { UdpWatcher::new(&mut loop_) };\n@@ -523,7 +619,20 @@ mod test {\n     }\n \n     #[test]\n-    fn listen() {\n+    fn udp_bind_close_ip6() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            udp_watcher.bind(addr);\n+            udp_watcher.close(||());\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_ip4() {\n         do run_in_bare_thread() {\n             static MAX: int = 10;\n             let mut loop_ = Loop::new();\n@@ -532,10 +641,82 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell::new(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc) |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).each |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert_eq!(count, MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n+                    }\n+                    count_cell.put_back(count);\n+                }\n+            }\n+\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n+                    assert!(status.is_none());\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell::new(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell::new(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n+                }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n-                let mut server_stream_watcher = server_stream_watcher;\n                 let mut loop_ = loop_;\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n                 let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n@@ -574,10 +755,9 @@ mod test {\n                 rtdebug!(\"starting client thread\");\n                 let mut loop_ = Loop::new();\n                 let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n                     rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    let mut stream_watcher = stream_watcher;\n                     let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n                     let buf = slice_to_uv_buf(msg);\n                     let msg_cell = Cell::new(msg);\n@@ -599,7 +779,7 @@ mod test {\n     }\n \n     #[test]\n-    fn udp_recv() {\n+    fn udp_recv_ip4() {\n         do run_in_bare_thread() {\n             static MAX: int = 10;\n             let mut loop_ = Loop::new();\n@@ -656,4 +836,63 @@ mod test {\n             loop_.close();\n         }\n     }\n+\n+    #[test]\n+    fn udp_recv_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let server_addr = next_test_ip6();\n+            let client_addr = next_test_ip6();\n+\n+            let server = UdpWatcher::new(&loop_);\n+            assert!(server.bind(server_addr).is_ok());\n+\n+            rtdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+\n+            do server.recv_start(alloc) |server, nread, buf, src, flags, status| {\n+                server.recv_stop();\n+                rtdebug!(\"i'm reading!\");\n+                assert!(status.is_none());\n+                assert_eq!(flags, 0);\n+                assert_eq!(src, client_addr);\n+\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = 0;\n+                rtdebug!(\"got %d bytes\", nread);\n+\n+                let buf = buf.unwrap();\n+                for buf.slice(0, nread as uint).iter().advance() |&byte| {\n+                    assert!(byte == count as u8);\n+                    rtdebug!(\"%u\", byte as uint);\n+                    count += 1;\n+                }\n+                assert_eq!(count, MAX);\n+\n+                server.close(||{});\n+            }\n+\n+            do Thread::start {\n+                let mut loop_ = Loop::new();\n+                let client = UdpWatcher::new(&loop_);\n+                assert!(client.bind(client_addr).is_ok());\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+                let buf = slice_to_uv_buf(msg);\n+                do client.send(buf, server_addr) |client, status| {\n+                    rtdebug!(\"writing\");\n+                    assert!(status.is_none());\n+                    client.close(||{});\n+                }\n+\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n }"}, {"sha": "e1ff8ba1e22ac40128fbbf971e92ce1363cf0c60", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -60,9 +60,8 @@ impl EventLoop for UvEventLoop {\n \n     fn callback(&mut self, f: ~fn()) {\n         let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |idle_watcher, status| {\n+        do idle_watcher.start |mut idle_watcher, status| {\n             assert!(status.is_none());\n-            let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n             idle_watcher.close(||());\n             f();\n@@ -218,7 +217,7 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+                    let res = Ok(~UvTcpStream(stream_watcher));\n \n                     // Store the stream in the task's stack\n                     unsafe { (*result_cell_ptr).put_back(res); }\n@@ -313,6 +312,11 @@ impl Drop for UvTcpListener {\n     }\n }\n \n+impl RtioSocket for UvTcpListener {\n+    // TODO\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n impl RtioTcpListener for UvTcpListener {\n \n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n@@ -329,15 +333,14 @@ impl RtioTcpListener for UvTcpListener {\n \n         let incoming_streams_cell = Cell::new(incoming_streams_cell.take());\n         let mut server_tcp_watcher = server_tcp_watcher;\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+        do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n             let maybe_stream = if status.is_none() {\n-                let mut server_stream_watcher = server_stream_watcher;\n                 let mut loop_ = server_stream_watcher.event_loop();\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n                 let client_tcp_watcher = client_tcp_watcher.as_stream();\n                 // XXX: Need's to be surfaced in interface\n                 server_stream_watcher.accept(client_tcp_watcher);\n-                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+                Ok(~UvTcpStream(client_tcp_watcher))\n             } else {\n                 Err(standard_error(OtherIoError))\n             };\n@@ -349,58 +352,58 @@ impl RtioTcpListener for UvTcpListener {\n \n         return self.incoming_streams.recv();\n     }\n-}\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n-pub struct UvTcpStream {\n-    watcher: StreamWatcher\n+    // TODO\n+    fn accept_simultaneously(&self) { fail!(); }\n+    fn dont_accept_simultaneously(&self) { fail!(); }\n }\n \n-impl UvTcpStream {\n-    fn watcher(&self) -> StreamWatcher { self.watcher }\n-}\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream(StreamWatcher);\n \n impl Drop for UvTcpStream {\n     fn finalize(&self) {\n         rtdebug!(\"closing tcp stream\");\n-        let watcher = self.watcher();\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            do watcher.close {\n+            do self.close {\n                 let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n     }\n }\n \n+impl RtioSocket for UvTcpStream {\n+    // TODO\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n impl RtioTcpStream for UvTcpStream {\n     fn read(&self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |sched, task| {\n             rtdebug!(\"read: entered scheduler context\");\n             assert!(!sched.in_task_context());\n-            let mut watcher = watcher;\n             let task_cell = Cell::new(task);\n             // XXX: We shouldn't reallocate these callbacks every\n             // call to read\n             let alloc: AllocCallback = |_| unsafe {\n                 slice_to_uv_buf(*buf_ptr)\n             };\n-            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+            let mut watcher = **self;\n+            do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                 // Stop reading so that no read callbacks are\n                 // triggered before the user calls `read` again.\n                 // XXX: Is there a performance impact to calling\n                 // stop here?\n-                let mut watcher = watcher;\n                 watcher.read_stop();\n \n                 let result = if status.is_none() {\n@@ -426,12 +429,11 @@ impl RtioTcpStream for UvTcpStream {\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |_, task| {\n-            let mut watcher = watcher;\n             let task_cell = Cell::new(task);\n             let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            let mut watcher = **self;\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n@@ -449,6 +451,13 @@ impl RtioTcpStream for UvTcpStream {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    // TODO\n+    fn peer_name(&self) -> IpAddr { fail!(); }\n+    fn control_congestion(&self) { fail!(); }\n+    fn nodelay(&self) { fail!(); }\n+    fn keepalive(&self, _delay_in_seconds: uint) { fail!(); }\n+    fn letdie(&self) { fail!(); }\n }\n \n pub struct UvUdpSocket(UdpWatcher);\n@@ -467,6 +476,11 @@ impl Drop for UvUdpSocket {\n     }\n }\n \n+impl RtioSocket for UvUdpSocket {\n+    // TODO\n+    fn socket_name(&self) -> IpAddr { fail!(); }\n+}\n+\n impl RtioUdpSocket for UvUdpSocket {\n     fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n         let result_cell = Cell::new_empty();\n@@ -530,6 +544,19 @@ impl RtioUdpSocket for UvUdpSocket {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    // TODO\n+    fn join_multicast(&self, _multi: IpAddr) { fail!(); }\n+    fn leave_multicast(&self, _multi: IpAddr) { fail!(); }\n+\n+    fn loop_multicast_locally(&self) { fail!(); }\n+    fn dont_loop_multicast_locally(&self) { fail!(); }\n+\n+    fn multicast_time_to_live(&self, _ttl: int) { fail!(); }\n+    fn time_to_live(&self, _ttl: int) { fail!(); }\n+\n+    fn hear_broadcasts(&self) { fail!(); }\n+    fn ignore_broadcasts(&self) { fail!(); }\n }\n \n #[test]"}, {"sha": "62bf8f27af93de00b3f4838719a8096dd01598e9", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 86, "deletions": 6, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -74,8 +74,10 @@ pub type uv_alloc_cb = *u8;\n pub type uv_udp_send_cb = *u8;\n pub type uv_udp_recv_cb = *u8;\n \n+pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n+pub type uv_membership = c_void;\n \n #[deriving(Eq)]\n pub enum uv_handle_type {\n@@ -231,6 +233,31 @@ pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n+pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_udp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn udp_get_sockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int {\n+    return rust_uv_udp_getsockname6(handle, name);\n+}\n+\n+pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                 interface_addr: *c_char, membership: uv_membership) -> c_int {\n+    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership);\n+}\n+\n+pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n+    return rust_uv_udp_set_multicast_loop(handle, on);\n+}\n+\n+pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    return rust_uv_udp_set_multicast_ttl(handle, ttl);\n+}\n+\n+pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n+    return rust_uv_udp_set_broadcast(handle, on);\n+}\n+\n pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n     return rust_uv_tcp_init(loop_handle, handle);\n }\n@@ -261,6 +288,26 @@ pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) -\n     return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n }\n \n+pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int {\n+    return rust_uv_tcp_getsockname6(handle, name);\n+}\n+\n+pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    return rust_uv_tcp_nodelay(handle, enable);\n+}\n+\n+pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n+    return rust_uv_tcp_keepalive(handle, enable, delay);\n+}\n+\n+pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    return rust_uv_tcp_simultaneous_accepts(handle, enable);\n+}\n+\n pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n     return rust_uv_listen(stream as *c_void, backlog, cb);\n }\n@@ -318,6 +365,22 @@ pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_stop(timer_ptr);\n }\n \n+pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n+    match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n+    match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in {\n+    return rust_uv_sockaddr_as_sockaddr_in(addr);\n+}\n+\n+pub unsafe fn as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6 {\n+    return rust_uv_sockaddr_as_sockaddr_in6(addr);\n+}\n+\n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n@@ -451,25 +514,42 @@ extern {\n     fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n     fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n     fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n-    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t, after_cb: *u8,\n+    fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                            addr: *sockaddr_in) -> c_int;\n     fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t, after_cb: *u8,\n+    fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                             addr: *sockaddr_in6) -> c_int;\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n     fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n     fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n+    fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n+    fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n \n     fn rust_uv_udp_init(loop_handle: *uv_loop_t, handle_ptr: *uv_udp_t) -> c_int;\n     fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n     fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n-    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t, buf_cnt: c_int,\n-                        addr: *sockaddr_in, cb: *u8) -> c_int;\n-    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t, buf_cnt: c_int,\n-                         addr: *sockaddr_in6, cb: *u8) -> c_int;\n+    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                        buf_cnt: c_int, addr: *sockaddr_in, cb: *u8) -> c_int;\n+    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                         buf_cnt: c_int, addr: *sockaddr_in6, cb: *u8) -> c_int;\n     fn rust_uv_udp_recv_start(server: *uv_udp_t, on_alloc: *u8, on_recv: *u8) -> c_int;\n     fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n     fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n+    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int;\n+    fn rust_uv_udp_getsockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                  interface_addr: *c_char, membership: uv_membership) -> c_int;\n+    fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n+    fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n+\n+    fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_sockaddr_as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in;\n+    fn rust_uv_sockaddr_as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6;\n \n     fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n     fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;"}, {"sha": "32ccc9ba4a82b7e5a43ae0914d5639284d58ab82", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -293,6 +293,38 @@ rust_uv_tcp_getpeername6\n     return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n }\n \n+extern \"C\" int\n+rust_uv_tcp_getsockname\n+(uv_tcp_t* handle, sockaddr_in* name) {\n+    int namelen = sizeof(sockaddr_in);\n+    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_getsockname6\n+(uv_tcp_t* handle, sockaddr_in6* name) {\n+    int namelen = sizeof(sockaddr_in6);\n+    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_nodelay\n+(uv_tcp_t* handle, int enable) {\n+    return uv_tcp_nodelay(handle, enable);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_keepalive\n+(uv_tcp_t* handle, int enable, unsigned int delay) {\n+    return uv_tcp_keepalive(handle, enable, delay);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_simultaneous_accepts\n+(uv_tcp_t* handle, int enable) {\n+    return uv_tcp_simultaneous_accepts(handle, enable);\n+}\n+\n extern \"C\" int\n rust_uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n     return uv_udp_init(loop, handle);\n@@ -335,6 +367,44 @@ rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n     return send_req->handle;\n }\n \n+extern \"C\" int\n+rust_uv_udp_getsockname\n+(uv_udp_t* handle, sockaddr_in* name) {\n+    int namelen = sizeof(sockaddr_in);\n+    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_getsockname6\n+(uv_udp_t* handle, sockaddr_in6* name) {\n+    int namelen = sizeof(sockaddr_in6);\n+    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_membership\n+(uv_udp_t* handle, const char* m_addr, const char* i_addr, uv_membership membership) {\n+    return uv_udp_set_membership(handle, m_addr, i_addr, membership);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_multicast_loop\n+(uv_udp_t* handle, int on) {\n+    return uv_udp_set_multicast_loop(handle, on);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_multicast_ttl\n+(uv_udp_t* handle, int ttl) {\n+    return uv_udp_set_multicast_ttl(handle, ttl);\n+}\n+\n+extern \"C\" int\n+rust_uv_udp_set_broadcast\n+(uv_udp_t* handle, int on) {\n+    return uv_udp_set_broadcast(handle, on);\n+}\n+\n extern \"C\" int\n rust_uv_listen(uv_stream_t* stream, int backlog,\n         uv_connection_cb cb) {\n@@ -587,10 +657,34 @@ extern \"C\" void\n rust_uv_freeaddrinfo(addrinfo* res) {\n     uv_freeaddrinfo(res);\n }\n+\n+extern \"C\" int\n+rust_uv_is_ipv4_sockaddr(sockaddr* addr) {\n+    return addr->sa_family == AF_INET;\n+}\n+\n+extern \"C\" int\n+rust_uv_is_ipv6_sockaddr(sockaddr* addr) {\n+    return addr->sa_family == AF_INET6;\n+}\n+\n+extern \"C\" sockaddr_in*\n+rust_uv_sockaddr_as_sockaddr_in(sockaddr* addr) {\n+//    return (sockaddr_in*)addr->sa_data;\n+    return (sockaddr_in*)addr;\n+}\n+\n+extern \"C\" sockaddr_in6*\n+rust_uv_sockaddr_as_sockaddr_in6(sockaddr* addr) {\n+    //return (sockaddr_in6*)addr->sa_data;\n+    return (sockaddr_in6*)addr;\n+}\n+\n extern \"C\" bool\n rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET;\n }\n+\n extern \"C\" bool\n rust_uv_is_ipv6_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET6;"}, {"sha": "e8a46cf5a652e47268c928550dddeca4132fe0e1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e6c57793be2cf7aabfa96aeada77935cc0351067/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=e6c57793be2cf7aabfa96aeada77935cc0351067", "patch": "@@ -105,6 +105,11 @@ rust_uv_tcp_connect\n rust_uv_tcp_bind\n rust_uv_tcp_connect6\n rust_uv_tcp_bind6\n+rust_uv_tcp_getsockname\n+rust_uv_tcp_getsockname6\n+rust_uv_tcp_nodelay\n+rust_uv_tcp_keepalive\n+rust_uv_tcp_simultaneous_accepts\n rust_uv_udp_init\n rust_uv_udp_bind\n rust_uv_udp_bind6\n@@ -113,6 +118,16 @@ rust_uv_udp_send6\n rust_uv_udp_recv_start\n rust_uv_udp_recv_stop\n rust_uv_get_udp_handle_from_send_req\n+rust_uv_udp_getsockname\n+rust_uv_udp_getsockname6\n+rust_uv_udp_set_membership\n+rust_uv_udp_set_multicast_loop\n+rust_uv_udp_set_multicast_ttl\n+rust_uv_udp_set_broadcast\n+rust_uv_is_ipv4_sockaddr\n+rust_uv_is_ipv6_sockaddr\n+rust_uv_sockaddr_as_sockaddr_in\n+rust_uv_sockaddr_as_sockaddr_in6\n rust_uv_listen\n rust_uv_accept\n rust_uv_write"}]}