{"sha": "b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YTE0NWU2MGY0YmJjOTBkYzc4MDIzOWNjNDljMDI0YjlmNTJjYTg=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-29T00:58:44Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-30T18:32:10Z"}, "message": "Added a nanosecond timer to time.rs, support for some floating point casts, and a commandline-driven mode for pfib.rs", "tree": {"sha": "020734b92aa7fea2269b3915d45d1d9730c4192c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020734b92aa7fea2269b3915d45d1d9730c4192c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "html_url": "https://github.com/rust-lang/rust/commit/b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/comments", "author": null, "committer": null, "parents": [{"sha": "441c7e06109772f7ff942682fb6d0a7535f03666", "url": "https://api.github.com/repos/rust-lang/rust/commits/441c7e06109772f7ff942682fb6d0a7535f03666", "html_url": "https://github.com/rust-lang/rust/commit/441c7e06109772f7ff942682fb6d0a7535f03666"}], "stats": {"total": 126, "additions": 94, "deletions": 32}, "files": [{"sha": "01ae30bf4e17241d656493d3b31206c1f891e27f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -5113,7 +5113,22 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n                     int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n                              ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)));\n         }\n-    } else { cx.fcx.lcx.ccx.sess.unimpl(\"fp cast\"); }\n+    } \n+    else { \n+        if (ty::type_is_integral(cx.fcx.lcx.ccx.tcx,\n+                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n+            if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx,\n+                                   ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n+                e_res = rslt(e_res.bcx,\n+                             e_res.bcx.build.SIToFP(e_res.val, lldsttype));\n+            }\n+            else {\n+                e_res = rslt(e_res.bcx,\n+                             e_res.bcx.build.UIToFP(e_res.val, lldsttype));\n+            }\n+        }\n+        else { cx.fcx.lcx.ccx.sess.unimpl(\"fp cast\"); }\n+    }\n     ret e_res;\n }\n "}, {"sha": "d2c61b74e9884cf82d28622c69c70c5080140824", "filename": "src/lib/time.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -2,6 +2,7 @@\n \n native \"rust\" mod rustrt {\n     fn get_time(&mutable u32 sec, &mutable u32 usec);\n+    fn nano_time(&mutable u64 ns);\n }\n \n type timeval = rec(u32 sec, u32 usec);\n@@ -11,4 +12,14 @@ fn get_time() -> timeval {\n     auto usec = 0u32;\n     rustrt::get_time(sec, usec);\n     ret rec(sec=sec, usec=usec);\n-}\n\\ No newline at end of file\n+}\n+\n+fn precise_time_ns() -> u64 {\n+    auto ns = 0u64;\n+    rustrt::nano_time(ns);\n+    ret ns;\n+}\n+\n+fn precise_time_s() -> float {\n+    ret (precise_time_ns() as float) / 1000000000.;\n+}"}, {"sha": "0ccc83435f7306850abcd4bb556ccc39e83e66b6", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -612,6 +612,12 @@ get_time(rust_task *task, uint32_t *sec, uint32_t *usec) {\n }\n #endif\n \n+extern \"C\" CDECL void\n+nano_time(rust_task *task, uint64_t *ns) {\n+    timer t;\n+    *ns = t.nano_time();\n+}\n+\n /**\n  * Preallocates the exact number of bytes in the given interior vector.\n  */"}, {"sha": "444faccef26084e794e186432cec5ea796262682", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -15,6 +15,7 @@ ivec_on_heap\n ivec_reserve\n ivec_to_ptr\n last_os_error\n+nano_time\n pin_task\n unpin_task\n rand_free"}, {"sha": "3af441c39502ba48226e93f93a22877450f7d465", "filename": "src/rt/sync/timer.cpp", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Fsync%2Ftimer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Fsync%2Ftimer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ftimer.cpp?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -9,7 +9,7 @@ timer::timer() {\n #if __WIN32__\n     uint64_t ticks_per_second;\n     QueryPerformanceFrequency((LARGE_INTEGER *)&ticks_per_second);\n-    _ticks_per_us = ticks_per_second / 1000000;\n+    _ticks_per_ns = ticks_per_second / 1000;\n #endif\n     reset(0);\n }\n@@ -41,26 +41,31 @@ timer::has_timed_out() {\n }\n \n uint64_t\n-timer::get_time() {\n+timer::nano_time() {\n #ifdef __APPLE__\n     uint64_t time = mach_absolute_time();\n     mach_timebase_info_data_t info = {0, 0};\n     if (info.denom == 0) {\n         mach_timebase_info(&info);\n     }\n     uint64_t time_nano = time * (info.numer / info.denom);\n-    return time_nano / 1000;\n+    return time_nano;\n #elif __WIN32__\n     uint64_t ticks;\n     QueryPerformanceCounter((LARGE_INTEGER *)&ticks);\n-    return ticks / _ticks_per_us;\n+    return ticks / _ticks_per_ns;\n #else\n     timespec ts;\n     clock_gettime(CLOCK_MONOTONIC, &ts);\n-    return (ts.tv_sec * 1000000000LL + ts.tv_nsec) / 1000;\n+    return (ts.tv_sec * 1000000000LL + ts.tv_nsec);\n #endif\n }\n \n+uint64_t\n+timer::get_time() {\n+    return nano_time() / 1000;\n+}\n+\n timer::~timer() {\n     // Nop.\n }"}, {"sha": "6d833396cf9242e11007029be3869b0c56667b12", "filename": "src/rt/sync/timer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Fsync%2Ftimer.h", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Frt%2Fsync%2Ftimer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ftimer.h?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -11,7 +11,7 @@ class timer {\n     uint64_t _timeout;\n     uint64_t get_time();\n #if __WIN32__\n-    uint64_t _ticks_per_us;\n+    uint64_t _ticks_per_ns;\n #endif\n public:\n     timer();\n@@ -20,6 +20,7 @@ class timer {\n     double get_elapsed_time_in_ms();\n     int64_t get_timeout();\n     bool has_timed_out();\n+    uint64_t nano_time();\n     virtual ~timer();\n };\n "}, {"sha": "cbe0813efc40b0ef1794ec38cacebf1b0be5fd96", "filename": "src/test/bench/shootout/pfib.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a145e60f4bbc90dc780239cc49c024b9f52ca8/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs?ref=b4a145e60f4bbc90dc780239cc49c024b9f52ca8", "patch": "@@ -4,38 +4,61 @@\n   A parallel version of fibonacci numbers.\n */\n \n+use std;\n+\n+import std::vec;\n+import std::uint;\n+import std::time;\n+import std::str;\n+\n fn recv[T](&port[T] p) -> T {\n-  let T x;\n-  p |> x;\n-  ret x;\n+    let T x;\n+    p |> x;\n+    ret x;\n }\n \n fn fib(int n) -> int {\n-  fn pfib(chan[int] c, int n) {\n-    if (n == 0) {\n-      c <| 0;\n-    }\n-    else if (n <= 2) {\n-      c <| 1;\n-    }\n-    else {\n-      let port[int] p = port();\n+    fn pfib(chan[int] c, int n) {\n+        if (n == 0) {\n+            c <| 0;\n+        }\n+        else if (n <= 2) {\n+            c <| 1;\n+        }\n+        else {\n+            let port[int] p = port();\n       \n-      auto t1 = spawn pfib(chan(p), n - 1);\n-      auto t2 = spawn pfib(chan(p), n - 2);\n+            auto t1 = spawn pfib(chan(p), n - 1);\n+            auto t2 = spawn pfib(chan(p), n - 2);\n \n-      c <| recv(p) + recv(p);\n+            c <| recv(p) + recv(p);\n+        }\n     }\n-  }\n \n-  let port[int] p = port();\n-  auto t = spawn pfib(chan(p), n);\n-  ret recv(p);\n+    let port[int] p = port();\n+    auto t = spawn pfib(chan(p), n);\n+    ret recv(p);\n }\n \n-fn main() {\n-  assert (fib(8) == 21);\n-  assert (fib(15) == 610);\n-  log fib(8);\n-  log fib(15);\n+fn main(vec[str] argv) {\n+    if(vec::len(argv) == 1u) {\n+        assert (fib(8) == 21);\n+        assert (fib(15) == 610);\n+        log fib(8);\n+        log fib(15);\n+    }\n+    else {\n+        // Interactive mode! Wooo!!!!\n+\n+        auto n = uint::parse_buf(str::bytes(argv.(1)), 10u) as int;\n+        auto start = time::precise_time_ns();\n+        auto fibn = fib(n);\n+        auto stop = time::precise_time_ns();\n+\n+        auto elapsed = (stop - start) as int;\n+        auto us_task = elapsed / fibn / 1000; \n+\n+        log_err #fmt(\"Determined that fib(%d) = %d in %d ns (%d us / task)\",\n+                     n, fibn, elapsed, us_task);\n+    }\n }"}]}