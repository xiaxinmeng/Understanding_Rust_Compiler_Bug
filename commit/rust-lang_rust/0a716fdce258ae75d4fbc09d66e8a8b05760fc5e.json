{"sha": "0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNzE2ZmRjZTI1OGFlNzVkNGZiYzA5ZDY2ZThhOGIwNTc2MGZjNWU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-08-31T02:11:48Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-08-31T15:24:34Z"}, "message": "Expand docs of multi-address behavior of some UDP/TCP APIs.\n\nFixes https://github.com/rust-lang/rust/issues/22569.", "tree": {"sha": "f070b3b3be19a3e3090e211142256b513a7ad5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f070b3b3be19a3e3090e211142256b513a7ad5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "html_url": "https://github.com/rust-lang/rust/commit/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eeac1b81446c6327f1827ef334eca2db7fe28f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eeac1b81446c6327f1827ef334eca2db7fe28f7", "html_url": "https://github.com/rust-lang/rust/commit/7eeac1b81446c6327f1827ef334eca2db7fe28f7"}], "stats": {"total": 98, "additions": 92, "deletions": 6}, "files": [{"sha": "5467eff202b02847cd45ca92966ffbd7ce6df08e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "patch": "@@ -111,15 +111,18 @@ impl TcpStream {\n     /// `addr` is an address of the remote host. Anything which implements\n     /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n     /// documentation for concrete examples.\n-    /// In case [`ToSocketAddrs::to_socket_addrs()`] returns more than one entry,\n-    /// then the first valid and reachable address is used.\n+    ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses result in a successful connection, the error returned from\n+    /// the last connection attempt (the last address) is returned.\n     ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n-    /// [`ToSocketAddrs::to_socket_addrs()`]:\n-    /// ../../std/net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\n     ///\n     /// # Examples\n     ///\n+    /// Open a TCP connection to `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpStream;\n     ///\n@@ -129,6 +132,23 @@ impl TcpStream {\n     ///     println!(\"Couldn't connect to server...\");\n     /// }\n     /// ```\n+    ///\n+    /// Open a TCP connection to `127.0.0.1:8080`. If the connection fails, open\n+    /// a TCP connection to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpStream};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// if let Ok(stream) = TcpStream::connect(&addrs[..]) {\n+    ///     println!(\"Connected to the server!\");\n+    /// } else {\n+    ///     println!(\"Couldn't connect to server...\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n@@ -557,16 +577,36 @@ impl TcpListener {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the listener. If\n+    /// none of the addresses succeed in creating a listener, the error returned\n+    /// from the last attempt (the last address) is returned.\n+    ///\n     /// [`local_addr`]: #method.local_addr\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpListener;\n     ///\n     /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n     /// ```\n+    ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n+    /// TCP listener bound to `127.0.0.1:443`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpListener};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 80)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 443)),\n+    /// ];\n+    /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)"}, {"sha": "35001833383c0253da750d37385d77e52cb42a0c", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a716fdce258ae75d4fbc09d66e8a8b05760fc5e/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=0a716fdce258ae75d4fbc09d66e8a8b05760fc5e", "patch": "@@ -69,14 +69,34 @@ impl UdpSocket {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the socket. If none\n+    /// of the addresses succeed in creating a socket, the error returned from\n+    /// the last attempt (the last address) is returned.\n+    ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n+    /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3400)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3401)),\n+    /// ];\n+    /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n@@ -130,6 +150,9 @@ impl UdpSocket {\n     /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n     /// documentation for concrete examples.\n     ///\n+    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n+    /// will only send data to the first address yielded by `addr`.\n+    ///\n     /// This will return an error when the IP version of the local socket\n     /// does not match that returned from [`ToSocketAddrs`].\n     ///\n@@ -562,14 +585,37 @@ impl UdpSocket {\n     /// `recv` syscalls to be used to send data and also applies filters to only\n     /// receive data from the specified address.\n     ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses are able to be connected, the error returned from the\n+    /// last connection attempt (the last address) is returned.\n+    ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`. If that connection fails, then the UDP socket will\n+    /// connect to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// let connect_addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// socket.connect(&connect_addrs[..]).expect(\"connect function failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))"}]}