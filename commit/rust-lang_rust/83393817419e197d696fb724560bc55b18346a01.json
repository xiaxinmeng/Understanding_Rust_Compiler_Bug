{"sha": "83393817419e197d696fb724560bc55b18346a01", "node_id": "C_kwDOAAsO6NoAKDgzMzkzODE3NDE5ZTE5N2Q2OTZmYjcyNDU2MGJjNTViMTgzNDZhMDE", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-11T12:52:02Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-11T12:52:02Z"}, "message": "Use is_ or has_ prefix for pure `-> bool` functions.", "tree": {"sha": "eea3b7735c3897a79627cc7291894927d0b2db33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea3b7735c3897a79627cc7291894927d0b2db33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83393817419e197d696fb724560bc55b18346a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83393817419e197d696fb724560bc55b18346a01", "html_url": "https://github.com/rust-lang/rust/commit/83393817419e197d696fb724560bc55b18346a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83393817419e197d696fb724560bc55b18346a01/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4a4f48c527453ddce2a2f1496473319290c6d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a4f48c527453ddce2a2f1496473319290c6d8e", "html_url": "https://github.com/rust-lang/rust/commit/c4a4f48c527453ddce2a2f1496473319290c6d8e"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "aa16da97e4c19c4937ef31675be81df80294990c", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/83393817419e197d696fb724560bc55b18346a01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83393817419e197d696fb724560bc55b18346a01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=83393817419e197d696fb724560bc55b18346a01", "patch": "@@ -27,33 +27,33 @@ const MAX_READERS: i32 = MASK - 1;\n const READERS_WAITING: i32 = 1 << 30;\n const WRITERS_WAITING: i32 = 1 << 31;\n \n-fn unlocked(state: i32) -> bool {\n+fn is_unlocked(state: i32) -> bool {\n     state & MASK == 0\n }\n \n-fn write_locked(state: i32) -> bool {\n+fn is_write_locked(state: i32) -> bool {\n     state & MASK == WRITE_LOCKED\n }\n \n-fn readers_waiting(state: i32) -> bool {\n+fn has_readers_waiting(state: i32) -> bool {\n     state & READERS_WAITING != 0\n }\n \n-fn writers_waiting(state: i32) -> bool {\n+fn has_writers_waiting(state: i32) -> bool {\n     state & WRITERS_WAITING != 0\n }\n \n-fn read_lockable(state: i32) -> bool {\n+fn is_read_lockable(state: i32) -> bool {\n     // This also returns false if the counter could overflow if we tried to read lock it.\n     //\n     // We don't allow read-locking if there's readers waiting, even if the lock is unlocked\n     // and there's no writers waiting. The only situation when this happens is after unlocking,\n     // at which point the unlocking thread might be waking up writers, which have priority over readers.\n     // The unlocking thread will clear the readers waiting bit and wake up readers, if necssary.\n-    state & MASK < MAX_READERS && !readers_waiting(state) && !writers_waiting(state)\n+    state & MASK < MAX_READERS && !has_readers_waiting(state) && !has_writers_waiting(state)\n }\n \n-fn reached_max_readers(state: i32) -> bool {\n+fn has_reached_max_readers(state: i32) -> bool {\n     state & MASK == MAX_READERS\n }\n \n@@ -69,14 +69,14 @@ impl RwLock {\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n         self.state\n-            .fetch_update(Acquire, Relaxed, |s| read_lockable(s).then(|| s + READ_LOCKED))\n+            .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))\n             .is_ok()\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n         let state = self.state.load(Relaxed);\n-        if !read_lockable(state)\n+        if !is_read_lockable(state)\n             || self\n                 .state\n                 .compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n@@ -92,10 +92,10 @@ impl RwLock {\n \n         // It's impossible for a reader to be waiting on a read-locked RwLock,\n         // except if there is also a writer waiting.\n-        debug_assert!(!readers_waiting(state) || writers_waiting(state));\n+        debug_assert!(!has_readers_waiting(state) || has_writers_waiting(state));\n \n         // Wake up a writer if we were the last reader and there's a writer waiting.\n-        if unlocked(state) && writers_waiting(state) {\n+        if is_unlocked(state) && has_writers_waiting(state) {\n             self.wake_writer_or_readers(state);\n         }\n     }\n@@ -106,7 +106,7 @@ impl RwLock {\n \n         loop {\n             // If we can lock it, lock it.\n-            if read_lockable(state) {\n+            if is_read_lockable(state) {\n                 match self.state.compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n                 {\n                     Ok(_) => return, // Locked!\n@@ -118,12 +118,12 @@ impl RwLock {\n             }\n \n             // Check for overflow.\n-            if reached_max_readers(state) {\n+            if has_reached_max_readers(state) {\n                 panic!(\"too many active read locks on RwLock\");\n             }\n \n             // Make sure the readers waiting bit is set before we go to sleep.\n-            if !readers_waiting(state) {\n+            if !has_readers_waiting(state) {\n                 if let Err(s) =\n                     self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)\n                 {\n@@ -142,7 +142,9 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        self.state.fetch_update(Acquire, Relaxed, |s| unlocked(s).then(|| s + WRITE_LOCKED)).is_ok()\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n+            .is_ok()\n     }\n \n     #[inline]\n@@ -156,9 +158,9 @@ impl RwLock {\n     pub unsafe fn write_unlock(&self) {\n         let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;\n \n-        debug_assert!(unlocked(state));\n+        debug_assert!(is_unlocked(state));\n \n-        if writers_waiting(state) || readers_waiting(state) {\n+        if has_writers_waiting(state) || has_readers_waiting(state) {\n             self.wake_writer_or_readers(state);\n         }\n     }\n@@ -171,7 +173,7 @@ impl RwLock {\n \n         loop {\n             // If it's unlocked, we try to lock it.\n-            if unlocked(state) {\n+            if is_unlocked(state) {\n                 match self.state.compare_exchange_weak(\n                     state,\n                     state | WRITE_LOCKED | other_writers_waiting,\n@@ -187,7 +189,7 @@ impl RwLock {\n             }\n \n             // Set the waiting bit indicating that we're waiting on it.\n-            if !writers_waiting(state) {\n+            if !has_writers_waiting(state) {\n                 if let Err(s) =\n                     self.state.compare_exchange(state, state | WRITERS_WAITING, Relaxed, Relaxed)\n                 {\n@@ -207,7 +209,7 @@ impl RwLock {\n             // Don't go to sleep if the lock has become available,\n             // or if the writers waiting bit is no longer set.\n             let s = self.state.load(Relaxed);\n-            if unlocked(state) || !writers_waiting(s) {\n+            if is_unlocked(state) || !has_writers_waiting(s) {\n                 state = s;\n                 continue;\n             }\n@@ -226,7 +228,7 @@ impl RwLock {\n     /// back to waking up readers if there was no writer to wake up.\n     #[cold]\n     fn wake_writer_or_readers(&self, mut state: i32) {\n-        assert!(unlocked(state));\n+        assert!(is_unlocked(state));\n \n         // The readers waiting bit might be turned on at any point now,\n         // since readers will block when there's anything waiting.\n@@ -299,13 +301,13 @@ impl RwLock {\n \n     fn spin_write(&self) -> i32 {\n         // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n-        self.spin_until(|state| unlocked(state) || writers_waiting(state))\n+        self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))\n     }\n \n     fn spin_read(&self) -> i32 {\n         // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n         self.spin_until(|state| {\n-            !write_locked(state) || readers_waiting(state) || writers_waiting(state)\n+            !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)\n         })\n     }\n }"}]}